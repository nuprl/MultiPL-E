{
  "name": "HumanEval_153_Strongest_Extension",
  "language": "d",
  "prompt": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n",
  "tests": "unittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "results": [
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else if (extensions[i][j] == 'a')\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (extensions[i] == class_name)\n            return class_name + \".\" + extensions[i];\n    }\n    return class_name + \".\" + extensions[0];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "/tmp/tmpzlzmspcl.d(31): Error: no property `length` for type `string`\n/tmp/tmpzlzmspcl.d(43): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpzlzmspcl.d(45): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzlzmspcl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    string result = class_name;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        if(strength == strength)\n        {\n            if(extensions[i] < result)\n                result = extensions[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "/tmp/tmph_92lcq_.d(31): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph_92lcq_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    string result = class_name + \".\";\n    for(int i = 0; i < extensions.length; i++)\n    {\n        if(extensions[i] == result)\n            continue;\n        cap = 0;\n        sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        if(cap - sm > strength)\n        {\n            result = extensions[i];\n            strength = cap - sm;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "/tmp/tmpcf4f85ab.d(31): Error: no property `length` for type `string`\n/tmp/tmpcf4f85ab.d(40): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpcf4f85ab.d(47): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcf4f85ab.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int CAP, SM;\n    CAP = SM = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        CAP += extensions[i].count('A');\n        SM += extensions[i].count('a');\n    }\n    return class_name + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\"\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "/tmp/tmph4r_c30r.d(32): Error: found `unittest` when expecting `;` following `return` statement\n/tmp/tmph4r_c30r.d(46): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph4r_c30r.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string result = class_name;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        int cap = 0;\n        int sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    for(int i = 0; i < extensions.length; i++)\n    {\n        if(strength == 0)\n            break;\n        if(strength > 0 && strength == extensions[i].length())\n        {\n            result += \".\" + extensions[i];\n            strength = 0;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "/tmp/tmpeqtwe38z.d(30): Error: no property `length` for type `string`\n/tmp/tmpeqtwe38z.d(43): Error: no property `length` for type `string`\n/tmp/tmpeqtwe38z.d(45): Error: invalid array operation `\".\" + extensions[cast(ulong)i]` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeqtwe38z.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string strongest_extension = \"\";\n    for(int i = 0; i < extensions.length; i++)\n    {\n        int cap = 0;\n        int sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else if(extensions[i][j] == 'a')\n                sm++;\n        }\n        strength += (cap - sm);\n        if(strength > strongest_extension.length())\n            strongest_extension = extensions[i];\n    }\n    return class_name + \".\" + strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "/tmp/tmp2dy68gun.d(30): Error: no property `length` for type `string`\n/tmp/tmp2dy68gun.d(38): Error: no property `length` for type `string`\n/tmp/tmp2dy68gun.d(41): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2dy68gun.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int c = 0;\n        int l = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                c++;\n            if (extensions[i][j] == 'a')\n                l++;\n        }\n        if (c > strength)\n            strength = c;\n        if (l > sm)\n            sm = l;\n    }\n    cap = strength - sm;\n    string result = class_name;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (cap == strength && extensions[i] < result)\n            result = extensions[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "/tmp/tmptm__czrt.d(31): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptm__czrt.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int CAP, SM;\n    CAP = SM = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        CAP += count(extensions[i], 'A');\n        SM += count(extensions[i], 'a');\n    }\n    CAP -= SM;\n    if(CAP == 0)\n        return class_name + \".\" + extensions[0];\n    else\n    {\n        for(int i = 0; i < extensions.length; i++)\n        {\n            if(CAP - SM == count(extensions[i], 'a') - count(extensions[i], 'A'))\n                return class_name + \".\" + extensions[i];\n        }\n    }\n    return class_name + \".\" + extensions[0];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "/tmp/tmpg4i7tv7e.d(28): Error: undefined identifier `count`\n/tmp/tmpg4i7tv7e.d(29): Error: undefined identifier `count`\n/tmp/tmpg4i7tv7e.d(33): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpg4i7tv7e.d(38): Error: undefined identifier `count`\n/tmp/tmpg4i7tv7e.d(38): Error: undefined identifier `count`\n/tmp/tmpg4i7tv7e.d(39): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpg4i7tv7e.d(42): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg4i7tv7e.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        int c = 0;\n        int l = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                c++;\n            if(extensions[i][j] == 'a' || extensions[i][j] == 'A')\n                l++;\n        }\n        cap += c;\n        sm += l;\n        strength += c - l;\n    }\n    return class_name + \".\" + extensions[0];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "/tmp/tmp4hzcdgcb.d(31): Error: no property `length` for type `string`\n/tmp/tmp4hzcdgcb.d(42): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4hzcdgcb.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int c = 0;\n        int l = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                c++;\n            if (extensions[i][j] == 'a' || extensions[i][j] == 'e' || extensions[i][j] == 'i' || extensions[i][j] == 'o' || extensions[i][j] == 'u')\n                l++;\n        }\n        strength += (c - l);\n        if (c > cap)\n            cap = c;\n        if (l > sm)\n            sm = l;\n    }\n    if (cap - sm > 0)\n        return class_name + \".\" + extensions[0];\n    else\n        return class_name + \".\" + extensions[extensions.length - 1];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "/tmp/tmpjymbsm8m.d(31): Error: no property `length` for type `string`\n/tmp/tmpjymbsm8m.d(45): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpjymbsm8m.d(47): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjymbsm8m.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        int c = 0;\n        int l = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                c++;\n            if(extensions[i][j] == 'a' || extensions[i][j] == 'A')\n                l++;\n        }\n        strength += (c - l);\n        if(c > cap)\n            cap = c;\n        if(l > sm)\n            sm = l;\n    }\n    return class_name + \".\" + extensions[strength - sm];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "/tmp/tmppwugw1z7.d(31): Error: no property `length` for type `string`\n/tmp/tmppwugw1z7.d(44): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppwugw1z7.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string strongest_extension = \"\";\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int cap = 0;\n        int sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n            {\n                cap++;\n            }\n            if (extensions[i][j] == 'a' || extensions[i][j] == 'A')\n            {\n                sm++;\n            }\n        }\n        strength += cap - sm;\n        if (strength > strongest_extension.length())\n        {\n            strongest_extension = extensions[i];\n        }\n    }\n    return class_name + \".\" + strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "/tmp/tmprf2ndbpx.d(30): Error: no property `length` for type `string`\n/tmp/tmprf2ndbpx.d(42): Error: no property `length` for type `string`\n/tmp/tmprf2ndbpx.d(47): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprf2ndbpx.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string strongest_extension = \"\";\n    for(int i = 0; i < extensions.length; i++)\n    {\n        int CAP = 0;\n        int SM = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                CAP++;\n            else\n                SM++;\n        }\n        strength += CAP - SM;\n        if(strength > strongest_extension.length())\n            strongest_extension = extensions[i];\n    }\n    return class_name + \".\" + strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "/tmp/tmppeugy_30.d(30): Error: no property `length` for type `string`\n/tmp/tmppeugy_30.d(38): Error: no property `length` for type `string`\n/tmp/tmppeugy_30.d(41): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppeugy_30.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string strongest_extension = \"\";\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int cap = 0, sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            if (extensions[i][j] == 'a' || extensions[i][j] == 'A')\n                sm++;\n        }\n        strength += cap - sm;\n        if (strength > strongest_extension.length())\n            strongest_extension = extensions[i];\n    }\n    return class_name + \".\" + strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "/tmp/tmpj0sfiirt.d(29): Error: no property `length` for type `string`\n/tmp/tmpj0sfiirt.d(37): Error: no property `length` for type `string`\n/tmp/tmpj0sfiirt.d(40): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj0sfiirt.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string result = class_name;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int cap = 0, sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else if (extensions[i][j] == 'a')\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (strength == 0)\n            break;\n        if (strength == strength && extensions[i] < result)\n            result = extensions[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "/tmp/tmpl69laoh9.d(29): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl69laoh9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string strongest_extension = \"\";\n    for(int i = 0; i < extensions.length; i++)\n    {\n        int CAP = 0;\n        int SM = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                CAP++;\n            else\n                SM++;\n        }\n        strength += CAP - SM;\n        if(strength > strongest_extension.length())\n            strongest_extension = extensions[i];\n    }\n    return class_name + \".\" + strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "/tmp/tmppeugy_30.d(30): Error: no property `length` for type `string`\n/tmp/tmppeugy_30.d(38): Error: no property `length` for type `string`\n/tmp/tmppeugy_30.d(41): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppeugy_30.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int CAP, SM;\n    CAP = SM = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        CAP += count(extensions[i], 'A');\n        SM += count(extensions[i], 'a');\n    }\n    return class_name + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "/tmp/tmp62gn5jzl.d(32): Error: found `unittest` when expecting `,`\n/tmp/tmp62gn5jzl.d(46): Error: found `void` when expecting `,`\n/tmp/tmp62gn5jzl.d(46): Error: found `{` when expecting `,`\n/tmp/tmp62gn5jzl.d(46): Error: expression expected, not `}`\n/tmp/tmp62gn5jzl.d(46): Error: found `End of File` when expecting `,`\n/tmp/tmp62gn5jzl.d(46): Error: found `End of File` when expecting `]`\n/tmp/tmp62gn5jzl.d(46): Error: found `End of File` when expecting `;` following `return` statement\n/tmp/tmp62gn5jzl.d(46): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp62gn5jzl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    string result = class_name;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        if(strength == 0)\n            break;\n        if(strength < 0)\n            strength = 0;\n        if(strength == strength)\n        {\n            result += \".\" + extensions[i];\n            break;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "/tmp/tmp3oqbksrl.d(31): Error: no property `length` for type `string`\n/tmp/tmp3oqbksrl.d(49): Error: invalid array operation `\".\" + extensions[cast(ulong)i]` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3oqbksrl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    int max = 0;\n    string max_ext = \"\";\n    for(int i = 0; i < extensions.length; i++)\n    {\n        if(extensions[i] == class_name)\n            continue;\n        if(extensions[i].length() > max)\n        {\n            max = extensions[i].length();\n            max_ext = extensions[i];\n        }\n    }\n    if(max == 0)\n        return class_name;\n    return class_name + \".\" + max_ext;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "/tmp/tmprrzf1imu.d(31): Error: no property `length` for type `string`\n/tmp/tmprrzf1imu.d(46): Error: no property `length` for type `string`\n/tmp/tmprrzf1imu.d(48): Error: no property `length` for type `string`\n/tmp/tmprrzf1imu.d(54): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprrzf1imu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int cap, sm;\n    string result;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        if(cap - sm > result.length())\n            result = extensions[i];\n    }\n    return class_name + \".\" + result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "/tmp/tmpegyublei.d(30): Error: no property `length` for type `string`\n/tmp/tmpegyublei.d(37): Error: no property `length` for type `string`\n/tmp/tmpegyublei.d(40): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpegyublei.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        int c = 0;\n        int l = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                c++;\n            if(extensions[i][j] == 'a' || extensions[i][j] == 'A')\n                l++;\n        }\n        strength += c - l;\n        if(c > cap)\n            cap = c;\n        if(l > sm)\n            sm = l;\n    }\n    return class_name + \".\" + extensions[strength - sm];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "/tmp/tmp143gfhm9.d(31): Error: no property `length` for type `string`\n/tmp/tmp143gfhm9.d(44): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp143gfhm9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        strength += (cap - sm);\n    }\n    for(int i = 0; i < extensions.length; i++)\n    {\n        if(extensions[i] == class_name)\n            continue;\n        cap = 0;\n        sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        if(strength < (cap - sm))\n        {\n            strength = cap - sm;\n            class_name = extensions[i];\n        }\n    }\n    return class_name + \".\" + class_name.substr(0, class_name.length() - strength);\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "/tmp/tmpmytb7ezj.d(31): Error: no property `length` for type `string`\n/tmp/tmpmytb7ezj.d(46): Error: no property `length` for type `string`\n/tmp/tmpmytb7ezj.d(59): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpmytb7ezj.d(59): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmytb7ezj.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n            {\n                cap++;\n            }\n            else\n            {\n                sm++;\n            }\n        }\n        strength += cap - sm;\n    }\n    for(int i = 0; i < extensions.length; i++)\n    {\n        if(strength == 0)\n        {\n            return class_name + \".\" + extensions[i];\n        }\n        else if(strength < 0 && strength > -1)\n        {\n            if(cap > sm)\n            {\n                return class_name + \".\" + extensions[i];\n            }\n            else\n            {\n                return class_name + \".\" + extensions[i];\n            }\n        }\n        else if(strength > 0)\n        {\n            if(cap > sm)\n            {\n                return class_name + \".\" + extensions[i];\n            }\n            else\n            {\n                return class_name + \".\" + extensions[i];\n            }\n        }\n    }\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "/tmp/tmpqsfseez7.d(31): Error: no property `length` for type `string`\n/tmp/tmpqsfseez7.d(48): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpqsfseez7.d(54): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpqsfseez7.d(58): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpqsfseez7.d(65): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpqsfseez7.d(69): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqsfseez7.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int c = 0;\n        int l = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n            {\n                c++;\n            }\n            if (extensions[i][j] == 'a' || extensions[i][j] == 'A')\n            {\n                l++;\n            }\n        }\n        strength += (c - l);\n        if (c > l)\n        {\n            cap = c;\n        }\n        if (l > c)\n        {\n            sm = l;\n        }\n    }\n    string result = class_name + \".\" + extensions[0];\n    for (int i = 1; i < extensions.length; i++)\n    {\n        if (strength == 0)\n        {\n            break;\n        }\n        if (cap - sm > strength)\n        {\n            result = class_name + \".\" + extensions[i];\n            strength = 0;\n        }\n        else if (cap - sm == strength)\n        {\n            if (extensions[i] < extensions[i - 1])\n            {\n                result = class_name + \".\" + extensions[i];\n                strength = 0;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "/tmp/tmp1nulrhcb.d(31): Error: no property `length` for type `string`\n/tmp/tmp1nulrhcb.d(52): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmp1nulrhcb.d(61): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmp1nulrhcb.d(68): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1nulrhcb.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string result = class_name;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int cap = 0, sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] >= 'A' && extensions[i][j] <= 'Z')\n                cap++;\n            else\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (extensions[i] == result)\n            continue;\n        int cap = 0, sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] >= 'A' && extensions[i][j] <= 'Z')\n                cap++;\n            else\n                sm++;\n        }\n        if (cap - sm > strength)\n        {\n            strength = cap - sm;\n            result = extensions[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "/tmp/tmp_mn1wfiz.d(29): Error: no property `length` for type `string`\n/tmp/tmp_mn1wfiz.d(43): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_mn1wfiz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n            {\n                cap++;\n            }\n            else if (extensions[i][j] == 'a')\n            {\n                sm++;\n            }\n        }\n        strength += cap - sm;\n    }\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (extensions[i] == class_name)\n        {\n            continue;\n        }\n        if (extensions[i] == class_name + \".java\")\n        {\n            continue;\n        }\n        if (extensions[i] == class_name + \".class\")\n        {\n            continue;\n        }\n        if (extensions[i] == class_name + \".cpp\")\n        {\n            continue;\n        }\n        if (extensions[i] == class_name + \".h\")\n        {\n            continue;\n        }\n        if (extensions[i] == class_name + \".py\")\n        {\n            continue;\n        }\n        if (extensions[i] == class_name + \".rb\")\n        {\n            continue;\n        }\n        if (extensions[i] == class_name + \".cs\")\n        {\n            continue;\n        }\n        if (extensions[i] == class_name + \".java\")\n        {\n            continue;\n        }\n        if (extensions[i] == class_name + \".cpp\")\n        {\n            continue;\n        }\n        if (extensions[i] == class_name + \".h\")\n        {\n            continue;\n        }\n        if (extensions[i] == class_name + \".py\")\n        {\n            continue;\n        }\n        if (extensions[i] == class_name + \".rb\")\n        \nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "/tmp/tmpunm1ojc5.d(96): Error: found `unittest` instead of statement\n/tmp/tmpunm1ojc5.d(110): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpunm1ojc5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string result = class_name;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int cap = 0;\n        int sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n            {\n                cap++;\n            }\n            if (extensions[i][j] == 'a' || extensions[i][j] == 'A')\n            {\n                sm++;\n            }\n        }\n        strength += cap - sm;\n    }\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (extensions[i] == result)\n        {\n            continue;\n        }\n        int cap = 0;\n        int sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n            {\n                cap++;\n            }\n            if (extensions[i][j] == 'a' || extensions[i][j] == 'A')\n            {\n                sm++;\n            }\n        }\n        if (cap - sm > strength)\n        {\n            strength = cap - sm;\n            result = extensions[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpm0h4w1k3.d(30): Error: no property `length` for type `string`\n/tmp/tmpm0h4w1k3.d(51): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm0h4w1k3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int CAP = 0, SM = 0;\n    for (int i = 0; i < class_name.length(); i++)\n        if (isupper(class_name[i]))\n            CAP++;\n        else\n            SM++;\n    \n    string result = class_name;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int CAP_ext = 0, SM_ext = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n            if (isupper(extensions[i][j]))\n                CAP_ext++;\n            else\n                SM_ext++;\n        \n        if (CAP_ext - SM_ext > CAP - SM)\n        {\n            CAP = CAP_ext;\n            SM = SM_ext;\n            result = class_name + \".\" + extensions[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmps5qxgd_r.d(25): Error: no property `length` for type `string`\n/tmp/tmps5qxgd_r.d(26): Error: undefined identifier `isupper`\n/tmp/tmps5qxgd_r.d(35): Error: no property `length` for type `string`\n/tmp/tmps5qxgd_r.d(36): Error: undefined identifier `isupper`\n/tmp/tmps5qxgd_r.d(45): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps5qxgd_r.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (extensions[i] == class_name)\n            return class_name + \".\" + extensions[i];\n    }\n    return class_name + \".\" + extensions[0];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpowfcrjae.d(31): Error: no property `length` for type `string`\n/tmp/tmpowfcrjae.d(43): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpowfcrjae.d(45): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpowfcrjae.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            if (extensions[i][j] == 'a' || extensions[i][j] == 'A')\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    \n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (strength == 0)\n            return class_name + \".\" + extensions[i];\n        if (strength == strength)\n        {\n            if (extensions[i] < class_name)\n                return class_name + \".\" + extensions[i];\n        }\n        if (strength > strength)\n        {\n            if (extensions[i] < class_name)\n                return class_name + \".\" + extensions[i];\n        }\n    }\n    return class_name + \".\" + extensions[0];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpd3ihgd3y.d(31): Error: no property `length` for type `string`\n/tmp/tmpd3ihgd3y.d(44): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpd3ihgd3y.d(48): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpd3ihgd3y.d(53): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpd3ihgd3y.d(56): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd3ihgd3y.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int cap = 0, sm = 0;\n    for (int i = 0; i < class_name.length(); i++)\n    {\n        if (class_name[i] >= 'A' && class_name[i] <= 'Z')\n            cap++;\n        else if (class_name[i] >= 'a' && class_name[i] <= 'z')\n            sm++;\n    }\n    int strength = cap - sm;\n    string result = class_name;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (cap - sm == strength && extensions[i] < result)\n            result = extensions[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpwm1aotra.d(25): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwm1aotra.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n            {\n                cap++;\n            }\n            else\n            {\n                sm++;\n            }\n        }\n        strength += cap - sm;\n    }\n    string result = class_name + \".\" + extensions[0];\n    for(int i = 1; i < extensions.length; i++)\n    {\n        if(strength == extensions[i].length())\n        {\n            if(extensions[i] < result)\n            {\n                result = extensions[i];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpc3tqa4oi.d(31): Error: no property `length` for type `string`\n/tmp/tmpc3tqa4oi.d(44): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpc3tqa4oi.d(47): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc3tqa4oi.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string strongest_extension = \"\";\n    for(int i = 0; i < extensions.length; i++)\n    {\n        int cap = 0;\n        int sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else if(extensions[i][j] == 'a')\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    for(int i = 0; i < extensions.length; i++)\n    {\n        if(strength == 0)\n        {\n            strongest_extension = class_name + \".\" + extensions[i];\n            break;\n        }\n        if(strength < 0 && strength > -1)\n        {\n            if(strength > -1)\n                strength = -1;\n            strongest_extension = class_name + \".\" + extensions[i];\n            break;\n        }\n        if(strength > 0 && strength < 1)\n        {\n            if(strength < 1)\n                strength = 1;\n            strongest_extension = class_name + \".\" + extensions[i];\n            break;\n        }\n    }\n    return strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmp5zuz9t_v.d(30): Error: no property `length` for type `string`\n/tmp/tmp5zuz9t_v.d(43): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmp5zuz9t_v.d(50): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmp5zuz9t_v.d(57): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5zuz9t_v.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int c = 0;\n        int l = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                c++;\n            if (extensions[i][j] == 'a' || extensions[i][j] == 'A')\n                l++;\n        }\n        cap += c;\n        sm += l;\n        strength += (cap - sm);\n    }\n    string result = class_name;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (extensions[i] == result)\n            continue;\n        if (strength == 0)\n        {\n            result = extensions[i];\n            break;\n        }\n        if (strength > extensions[i].length())\n            continue;\n        if (strength == extensions[i].length())\n        {\n            if (extensions[i] < result)\n                result = extensions[i];\n        }\n        else\n        {\n            if (extensions[i].length() > strength)\n                result = extensions[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmp1h0ddez7.d(31): Error: no property `length` for type `string`\n/tmp/tmp1h0ddez7.d(52): Error: no property `length` for type `string`\n/tmp/tmp1h0ddez7.d(54): Error: no property `length` for type `string`\n/tmp/tmp1h0ddez7.d(61): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1h0ddez7.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        cap += extensions[i].count('A');\n        sm += extensions[i].count('a');\n    }\n    cap -= sm;\n    if (cap == 0)\n        return class_name + \".\" + extensions[0];\n    else\n    {\n        for (int i = 0; i < extensions.length; i++)\n        {\n            if (cap - sm == extensions[i].count('a') - extensions[i].count('A'))\n            {\n                if (i == 0)\n                    return class_name + \".\" + extensions[i];\n                else\n                    return class_name + \".\" + extensions[i] + \".\" + extensions[i - 1];\n            }\n        }\n    }\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmp58z4u90r.d(28): Error: no property `count` for type `string`\n/tmp/tmp58z4u90r.d(29): Error: no property `count` for type `string`\n/tmp/tmp58z4u90r.d(33): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmp58z4u90r.d(38): Error: no property `count` for type `string`\n/tmp/tmp58z4u90r.d(38): Error: no property `count` for type `string`\n/tmp/tmp58z4u90r.d(41): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmp58z4u90r.d(43): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp58z4u90r.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int CAP = 0;\n    int SM = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        CAP += count(extensions[i], 'A');\n        SM += count(extensions[i], 'a');\n    }\n    int strength = CAP - SM;\n    string result = class_name + \".\" + extensions[0];\n    for(int i = 1; i < extensions.length; i++)\n    {\n        if(strength < CAP - SM)\n        {\n            result = class_name + \".\" + extensions[i];\n            strength = CAP - SM;\n        }\n        else if(strength == CAP - SM && extensions[i] < extensions[i-1])\n        {\n            result = class_name + \".\" + extensions[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmp0o20clvu.d(28): Error: undefined identifier `count`\n/tmp/tmp0o20clvu.d(29): Error: undefined identifier `count`\n/tmp/tmp0o20clvu.d(32): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmp0o20clvu.d(37): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmp0o20clvu.d(42): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0o20clvu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string strongest_extension = \"\";\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int cap = 0, sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            if (extensions[i][j] == 'a' || extensions[i][j] == 'A')\n                sm++;\n        }\n        strength += cap - sm;\n        if (strength > strongest_extension.length())\n            strongest_extension = extensions[i];\n    }\n    return class_name + \".\" + strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "/tmp/tmpj0sfiirt.d(29): Error: no property `length` for type `string`\n/tmp/tmpj0sfiirt.d(37): Error: no property `length` for type `string`\n/tmp/tmpj0sfiirt.d(40): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj0sfiirt.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int CAP = 0, SM = 0;\n    for (int i = 0; i < class_name.length(); i++)\n    {\n        if (class_name[i] >= 'A' && class_name[i] <= 'Z')\n            CAP++;\n        else\n            SM++;\n    }\n    \n    string result = class_name;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int CAP_ext = 0, SM_ext = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] >= 'A' && extensions[i][j] <= 'Z')\n                CAP_ext++;\n            else\n                SM_ext++;\n        }\n        \n        if (CAP_ext - SM_ext > CAP - SM)\n        {\n            CAP = CAP_ext;\n            SM = SM_ext;\n            result = class_name + \".\" + extensions[i];\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpup__893_.d(25): Error: no property `length` for type `string`\n/tmp/tmpup__893_.d(37): Error: no property `length` for type `string`\n/tmp/tmpup__893_.d(49): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpup__893_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        cap += count(extensions[i], 'A');\n        sm += count(extensions[i], 'a');\n    }\n    cap -= sm;\n    if (cap == 0)\n        return class_name + \".\" + extensions[0];\n    else\n    {\n        for (int i = 0; i < extensions.length; i++)\n        {\n            if (cap - sm == count(extensions[i], 'a') - count(extensions[i], 'A'))\n                return class_name + \".\" + extensions[i];\n        }\n    }\n    return class_name + \".\" + extensions[0];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpvm4_z7sl.d(28): Error: undefined identifier `count`\n/tmp/tmpvm4_z7sl.d(29): Error: undefined identifier `count`\n/tmp/tmpvm4_z7sl.d(33): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpvm4_z7sl.d(38): Error: undefined identifier `count`\n/tmp/tmpvm4_z7sl.d(38): Error: undefined identifier `count`\n/tmp/tmpvm4_z7sl.d(39): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpvm4_z7sl.d(42): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvm4_z7sl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int CAP, SM;\n    string result;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        CAP = 0;\n        SM = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] >= 'A' && extensions[i][j] <= 'Z')\n                CAP++;\n            else\n                SM++;\n        }\n        if (CAP - SM > result.length())\n            result = extensions[i];\n    }\n    return class_name + \".\" + result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmp_ov3n0lh.d(30): Error: no property `length` for type `string`\n/tmp/tmp_ov3n0lh.d(37): Error: no property `length` for type `string`\n/tmp/tmp_ov3n0lh.d(40): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_ov3n0lh.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    string result = \"\";\n    for (int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (extensions[i] == class_name)\n            continue;\n        if (extensions[i] == class_name + \".\" + class_name)\n            continue;\n        if (extensions[i] == class_name + \".\" + class_name + \".\" + class_name)\n            continue;\n        if (extensions[i] == class_name + \".\" + class_name + \".\" + class_name + \".\" + class_name)\n            continue;\n        if (extensions[i] == class_name + \".\" + class_name + \".\" + class_name + \".\" + class_name + \".\" + class_name)\n            continue;\n        if (extensions[i] == class_name + \".\" + class_name + \".\" + class_name + \".\" + class_name + \".\" + class_name + \".\" + class_name)\n            continue;\n        if (extensions[i] == class_name + \".\" + class_name + \".\" + class_name + \".\" + class_name + \".\" + class_name + \".\" + class_name + \".\" + class_name)\n            continue;\n        if (extensions[i] == class_name + \".\" + class_name + \".\" + class_name + \".\" + class_name + \".\" + class_name + \".\" + class_name + \".\" + class_name + \".\" + class_name)\n            continue;\n        if (extensions[i] == class_name + \".\" + class\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "/tmp/tmpeqmiqntq.d(59): Error: expression expected, not `class`\n/tmp/tmpeqmiqntq.d(60): Error: found `unittest` when expecting `)`\n/tmp/tmpeqmiqntq.d(74): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpeqmiqntq.d(74): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeqmiqntq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string result = class_name;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int cap = 0, sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            if (extensions[i][j] == 'a' || extensions[i][j] == 'A')\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (strength == 0)\n            break;\n        if (strength == strength && strength > 0)\n        {\n            if (extensions[i] < result)\n                result = extensions[i];\n        }\n        else if (strength > 0 && strength < strength && strength > 0)\n        {\n            if (extensions[i] < result)\n                result = extensions[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpiocb2rwm.d(29): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiocb2rwm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int CAP, SM;\n    CAP = SM = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        CAP += count(extensions[i], 'A');\n        SM += count(extensions[i], 'a');\n    }\n    return class_name + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "/tmp/tmp62gn5jzl.d(32): Error: found `unittest` when expecting `,`\n/tmp/tmp62gn5jzl.d(46): Error: found `void` when expecting `,`\n/tmp/tmp62gn5jzl.d(46): Error: found `{` when expecting `,`\n/tmp/tmp62gn5jzl.d(46): Error: expression expected, not `}`\n/tmp/tmp62gn5jzl.d(46): Error: found `End of File` when expecting `,`\n/tmp/tmp62gn5jzl.d(46): Error: found `End of File` when expecting `]`\n/tmp/tmp62gn5jzl.d(46): Error: found `End of File` when expecting `;` following `return` statement\n/tmp/tmp62gn5jzl.d(46): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp62gn5jzl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string strongest_extension = \"\";\n    for(int i = 0; i < extensions.length; i++)\n    {\n        int cap = 0;\n        int sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else if(extensions[i][j] == 'a')\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    for(int i = 0; i < extensions.length; i++)\n    {\n        if(strength == 0)\n        {\n            strongest_extension = class_name + \".\" + extensions[i];\n            break;\n        }\n        if(strength < 0 && strength > -1)\n        {\n            if(strength > -1)\n                strength = -1;\n            strongest_extension = class_name + \".\" + extensions[i];\n            break;\n        }\n        if(strength > 0 && strength < 1)\n        {\n            if(strength < 1)\n                strength = 1;\n            strongest_extension = class_name + \".\" + extensions[i];\n            break;\n        }\n    }\n    return strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmp5zuz9t_v.d(30): Error: no property `length` for type `string`\n/tmp/tmp5zuz9t_v.d(43): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmp5zuz9t_v.d(50): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmp5zuz9t_v.d(57): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5zuz9t_v.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n            {\n                cap++;\n            }\n            else\n            {\n                sm++;\n            }\n        }\n        strength += (cap - sm);\n    }\n    string result = class_name;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (extensions[i] == class_name)\n        {\n            continue;\n        }\n        if (extensions[i] == result)\n        {\n            continue;\n        }\n        if (strength == 0)\n        {\n            result = extensions[i];\n            break;\n        }\n        if (strength < 0 && strength > -1)\n        {\n            if (cap > sm)\n            {\n                result = extensions[i];\n                break;\n            }\n            else\n            {\n                continue;\n            }\n        }\n        if (strength > 0 && strength < 1)\n        {\n            if (cap > sm)\n            {\n                result = extensions[i];\n                break;\n            }\n            else\n            {\n                continue;\n            }\n        }\n        if (strength > 1 && strength < 2)\n        {\n            if (cap > sm)\n            {\n                result = extensions[i];\n                break;\n            }\n            else\n            {\n                continue;\n            }\n        }\n        if (strength > 2 && strength < 3)\n        {\n            if (cap > sm)\n            {\n                result = extensions[i];\n                break;\n            }\n            else\n            {\n                continue;\n            }\n        }\n        if (strength > 3 && strength < 4)\n        {\n            if (cap > sm)\n            {\n                result = extensions[i];\n                break;\n            }\n\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "/tmp/tmpga0anrtq.d(116): Error: found `unittest` instead of statement\n/tmp/tmpga0anrtq.d(130): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpga0anrtq.d(130): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpga0anrtq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n            {\n                cap++;\n            }\n            else\n            {\n                sm++;\n            }\n        }\n        strength += cap - sm;\n    }\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (extensions[i] == class_name)\n        {\n            return class_name + \".\" + extensions[i];\n        }\n    }\n    return class_name + \".\" + extensions[0];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpf7nn1q2w.d(31): Error: no property `length` for type `string`\n/tmp/tmpf7nn1q2w.d(48): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpf7nn1q2w.d(51): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf7nn1q2w.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int c = 0;\n        int l = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n            {\n                c++;\n            }\n            if (extensions[i][j] == 'a' || extensions[i][j] == 'A')\n            {\n                l++;\n            }\n        }\n        strength += (c - l);\n        if (c > cap)\n        {\n            cap = c;\n        }\n        if (l > sm)\n        {\n            sm = l;\n        }\n    }\n    if (cap - sm == 0)\n    {\n        return class_name + \".\" + extensions[0];\n    }\n    else\n    {\n        for (int i = 0; i < extensions.length; i++)\n        {\n            if (strength == extensions[i].length())\n            {\n                return class_name + \".\" + extensions[i];\n            }\n        }\n    }\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpipcbvbue.d(31): Error: no property `length` for type `string`\n/tmp/tmpipcbvbue.d(54): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpipcbvbue.d(60): Error: no property `length` for type `string`\n/tmp/tmpipcbvbue.d(62): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpipcbvbue.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string best_extension = \"\";\n    for(int i = 0; i < extensions.length; i++)\n    {\n        int cap = 0, sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else if(extensions[i][j] == 'a')\n                sm++;\n        }\n        strength += cap - sm;\n        if(strength > best_extension.length())\n            best_extension = extensions[i];\n    }\n    return class_name + \".\" + best_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpffsotsvv.d(29): Error: no property `length` for type `string`\n/tmp/tmpffsotsvv.d(37): Error: no property `length` for type `string`\n/tmp/tmpffsotsvv.d(40): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpffsotsvv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int CAP = 0, SM = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        CAP += extensions[i].count('A');\n        SM += extensions[i].count('a');\n    }\n    return class_name + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "/tmp/tmpb5kuzsio.d(31): Error: found `unittest` when expecting `,`\n/tmp/tmpb5kuzsio.d(45): Error: found `void` when expecting `,`\n/tmp/tmpb5kuzsio.d(45): Error: found `{` when expecting `,`\n/tmp/tmpb5kuzsio.d(45): Error: expression expected, not `}`\n/tmp/tmpb5kuzsio.d(45): Error: found `End of File` when expecting `,`\n/tmp/tmpb5kuzsio.d(45): Error: found `End of File` when expecting `]`\n/tmp/tmpb5kuzsio.d(45): Error: found `End of File` when expecting `;` following `return` statement\n/tmp/tmpb5kuzsio.d(45): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb5kuzsio.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    \n    string result = class_name;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (extensions[i] == result)\n            continue;\n        if (extensions[i].length() > result.length())\n        {\n            result = extensions[i];\n            continue;\n        }\n        if (extensions[i].length() == result.length())\n        {\n            if (extensions[i] < result)\n                result = extensions[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpsmt0j0rf.d(31): Error: no property `length` for type `string`\n/tmp/tmpsmt0j0rf.d(46): Error: no property `length` for type `string`\n/tmp/tmpsmt0j0rf.d(46): Error: no property `length` for type `string`\n/tmp/tmpsmt0j0rf.d(51): Error: no property `length` for type `string`\n/tmp/tmpsmt0j0rf.d(51): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsmt0j0rf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int c = 0;\n        int l = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n            {\n                c++;\n            }\n            if (extensions[i][j] == 'a' || extensions[i][j] == 'A')\n            {\n                l++;\n            }\n        }\n        strength += (c - l);\n        if (c > cap)\n        {\n            cap = c;\n        }\n        if (l > sm)\n        {\n            sm = l;\n        }\n    }\n    if (cap - sm == 0)\n    {\n        return class_name + \".\" + extensions[0];\n    }\n    else\n    {\n        return class_name + \".\" + extensions[0] + \".\" + to_string(strength);\n    }\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpyzkhttem.d(31): Error: no property `length` for type `string`\n/tmp/tmpyzkhttem.d(54): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpyzkhttem.d(58): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpyzkhttem.d(58): Error: undefined identifier `to_string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyzkhttem.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int CAP, SM;\n    int strength = 0;\n    string ext_name;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        CAP = 0;\n        SM = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                CAP++;\n            else\n                SM++;\n        }\n        strength += CAP - SM;\n        ext_name = extensions[i];\n    }\n    return class_name + \".\" + ext_name;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmp_ublfdrz.d(31): Error: no property `length` for type `string`\n/tmp/tmp_ublfdrz.d(41): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_ublfdrz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int CAP = 0, SM = 0;\n    for (int i = 0; i < class_name.length(); i++)\n        if (class_name[i] >= 'A' && class_name[i] <= 'Z')\n            CAP++;\n        else\n            SM++;\n    for (int i = 0; i < extensions.length; i++)\n        for (int j = 0; j < extensions[i].length(); j++)\n            if (extensions[i][j] >= 'A' && extensions[i][j] <= 'Z')\n                CAP++;\n            else\n                SM++;\n    return class_name + \".\" + extensions[0];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpdjde5925.d(25): Error: no property `length` for type `string`\n/tmp/tmpdjde5925.d(31): Error: no property `length` for type `string`\n/tmp/tmpdjde5925.d(36): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdjde5925.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int c = 0;\n        int l = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                c++;\n            if (extensions[i][j] == 'a' || extensions[i][j] == 'A')\n                l++;\n        }\n        if (c > sm)\n            sm = c;\n        if (l > cap)\n            cap = l;\n    }\n    strength = cap - sm;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (extensions[i].compare(class_name) == 0)\n            return class_name + \".\" + extensions[i];\n        if (extensions[i].compare(class_name) > 0 && strength == extensions[i].length())\n            return class_name + \".\" + extensions[i];\n    }\n    return class_name + \".\" + extensions[0];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpvi6erfda.d(31): Error: no property `length` for type `string`\n/tmp/tmpvi6erfda.d(46): Error: no property `compare` for type `string`\n/tmp/tmpvi6erfda.d(47): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpvi6erfda.d(48): Error: no property `compare` for type `string`\n/tmp/tmpvi6erfda.d(48): Error: no property `length` for type `string`\n/tmp/tmpvi6erfda.d(49): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpvi6erfda.d(51): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvi6erfda.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int CAP, SM;\n    CAP = SM = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        CAP += extensions[i].length() - extensions[i].length() % 2;\n        SM += extensions[i].length() % 2;\n    }\n    return class_name + \".\" + extensions[0];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpgd8xesfh.d(28): Error: no property `length` for type `string`\n/tmp/tmpgd8xesfh.d(28): Error: no property `length` for type `string`\n/tmp/tmpgd8xesfh.d(29): Error: no property `length` for type `string`\n/tmp/tmpgd8xesfh.d(31): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgd8xesfh.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string strongest_extension = \"\";\n    for(int i = 0; i < extensions.length; i++)\n    {\n        int CAP = 0;\n        int SM = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                CAP++;\n            else\n                SM++;\n        }\n        strength = CAP - SM;\n        if(strength > strength)\n        {\n            strength = CAP - SM;\n            strongest_extension = extensions[i];\n        }\n    }\n    return class_name + \".\" + strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpjuh_tuct.d(30): Error: no property `length` for type `string`\n/tmp/tmpjuh_tuct.d(44): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjuh_tuct.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    for(int i = 0; i < extensions.length; i++)\n    {\n        if(extensions[i] == class_name)\n            continue;\n        cap = 0;\n        sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        if(cap - sm > strength)\n        {\n            strength = cap - sm;\n            class_name = extensions[i];\n        }\n    }\n    return class_name + \".\" + class_name.substr(0, class_name.length() - strength);\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmp7scapf6g.d(31): Error: no property `length` for type `string`\n/tmp/tmp7scapf6g.d(46): Error: no property `length` for type `string`\n/tmp/tmp7scapf6g.d(59): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmp7scapf6g.d(59): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7scapf6g.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            if(extensions[i][j] == 'a' || extensions[i][j] == 'A')\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    for(int i = 0; i < extensions.length; i++)\n    {\n        if(extensions[i].compare(class_name) == 0)\n            return class_name + \".\" + extensions[i];\n    }\n    return class_name + \".\" + extensions[0];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmp4q59jj1j.d(31): Error: no property `length` for type `string`\n/tmp/tmp4q59jj1j.d(42): Error: no property `compare` for type `string`\n/tmp/tmp4q59jj1j.d(43): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmp4q59jj1j.d(45): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4q59jj1j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string strongest_extension = \"\";\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int cap = 0, sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else if (extensions[i][j] == 'a')\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (strength == 0)\n            break;\n        if (strength > 0 && strength == extensions[i].length())\n        {\n            strongest_extension = class_name + \".\" + extensions[i];\n            break;\n        }\n        else if (strength < 0 && strength == -extensions[i].length())\n        {\n            strongest_extension = class_name + \".\" + extensions[i];\n            break;\n        }\n    }\n    return strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpn08mq8_v.d(29): Error: no property `length` for type `string`\n/tmp/tmpn08mq8_v.d(42): Error: no property `length` for type `string`\n/tmp/tmpn08mq8_v.d(44): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpn08mq8_v.d(47): Error: no property `length` for type `string`\n/tmp/tmpn08mq8_v.d(49): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn08mq8_v.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string strongest_extension = \"\";\n    for(int i = 0; i < extensions.length; i++)\n    {\n        int cap = 0;\n        int sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            if(extensions[i][j] == 'a' || extensions[i][j] == 'A')\n                sm++;\n        }\n        strength += cap - sm;\n        if(strength > strongest_extension.length())\n            strongest_extension = extensions[i];\n    }\n    return class_name + \".\" + strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmptdujac98.d(30): Error: no property `length` for type `string`\n/tmp/tmptdujac98.d(38): Error: no property `length` for type `string`\n/tmp/tmptdujac98.d(41): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptdujac98.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n            {\n                cap++;\n            }\n            else\n            {\n                sm++;\n            }\n        }\n        strength += cap - sm;\n    }\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (extensions[i] == class_name)\n        {\n            return class_name + \".\" + extensions[i];\n        }\n        else if (extensions[i] == class_name + \".\" + extensions[i])\n        {\n            return class_name + \".\" + extensions[i];\n        }\n        else if (extensions[i] == class_name + \".\" + extensions[i].substr(0, class_name.length()))\n        {\n            return class_name + \".\" + extensions[i];\n        }\n        else if (extensions[i] == class_name + \".\" + extensions[i].substr(0, class_name.length()) + \".\" + class_name)\n        {\n            return class_name + \".\" + extensions[i];\n        }\n        else if (extensions[i] == class_name + \".\" + extensions[i].substr(0, class_name.length()) + \".\" + class_name + \".\" + class_name)\n        {\n            return class_name + \".\" + extensions[i];\n        }\n        else if (extensions[i] == class_name + \".\" + extensions[i].substr(0, class_name.length()) + \".\" + class_name + \".\" + class_name + \".\" + class_name)\n        {\n            return class_name + \".\" + extensions[i];\n        }\n        else if (extensions[i] == class_name + \".\" + extensions\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpujxj6c1k.d(71): Error: found `unittest` when expecting `)`\n/tmp/tmpujxj6c1k.d(85): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpujxj6c1k.d(85): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpujxj6c1k.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            if (extensions[i][j] == 'a' || extensions[i][j] == 'A')\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (extensions[i] == class_name)\n            return class_name + \".\" + extensions[i];\n    }\n    return class_name + \".\" + extensions[0];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpx7xzm5oc.d(31): Error: no property `length` for type `string`\n/tmp/tmpx7xzm5oc.d(43): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpx7xzm5oc.d(45): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx7xzm5oc.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int CAP, SM;\n    int strength = 0;\n    string result = \"\";\n    \n    for (int i = 0; i < extensions.length; i++)\n    {\n        CAP = 0;\n        SM = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                CAP++;\n            else if (extensions[i][j] == 'a')\n                SM++;\n        }\n        strength = CAP - SM;\n        if (strength > strength)\n        {\n            result = class_name + \".\" + extensions[i];\n            strength = CAP - SM;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpy_i9j4py.d(32): Error: no property `length` for type `string`\n/tmp/tmpy_i9j4py.d(42): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy_i9j4py.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int cap = 0, sm = 0;\n    for (int i = 0; i < class_name.length(); i++)\n        if (class_name[i] >= 'A' && class_name[i] <= 'Z')\n            cap++;\n        else if (class_name[i] >= 'a' && class_name[i] <= 'z')\n            sm++;\n    \n    int strength = cap - sm;\n    \n    for (int i = 0; i < extensions.length; i++)\n        if (extensions[i].length() > 0)\n            if (extensions[i][0] >= 'A' && extensions[i][0] <= 'Z')\n                cap++;\n            else if (extensions[i][0] >= 'a' && extensions[i][0] <= 'z')\n                sm++;\n            \n        if (cap - sm > strength)\n        {\n            strength = cap - sm;\n            class_name += \".\" + extensions[i];\n        }\n    \n    return class_name;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmp_0pyy3wi.d(25): Error: no property `length` for type `string`\n/tmp/tmp_0pyy3wi.d(34): Error: no property `length` for type `string`\n/tmp/tmp_0pyy3wi.d(43): Error: undefined identifier `i`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_0pyy3wi.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] >= 'A' && extensions[i][j] <= 'Z')\n                cap++;\n            else if (extensions[i][j] >= 'a' && extensions[i][j] <= 'z')\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (strength == 0)\n            return class_name + \".\" + extensions[i];\n        if (strength < 0)\n            strength = 0;\n        if (strength == strength)\n            return class_name + \".\" + extensions[i];\n    }\n    return class_name + \".\" + extensions[0];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpmjdj3df7.d(31): Error: no property `length` for type `string`\n/tmp/tmpmjdj3df7.d(43): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpmjdj3df7.d(47): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpmjdj3df7.d(49): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmjdj3df7.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int CAP, SM;\n    CAP = SM = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        CAP += count(extensions[i], 'A');\n        SM += count(extensions[i], 'a');\n    }\n    CAP -= SM;\n    if (CAP == 0)\n        return class_name + \".\" + extensions[0];\n    else\n    {\n        for (int i = 0; i < extensions.length; i++)\n        {\n            if (CAP - SM == count(extensions[i], 'a') - count(extensions[i], 'A') && extensions[i] < extensions[0])\n                return class_name + \".\" + extensions[i];\n        }\n    }\n    return class_name + \".\" + extensions[0];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmp6wuud36f.d(28): Error: undefined identifier `count`\n/tmp/tmp6wuud36f.d(29): Error: undefined identifier `count`\n/tmp/tmp6wuud36f.d(33): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmp6wuud36f.d(38): Error: undefined identifier `count`\n/tmp/tmp6wuud36f.d(38): Error: undefined identifier `count`\n/tmp/tmp6wuud36f.d(39): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmp6wuud36f.d(42): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6wuud36f.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string strongest_extension = \"\";\n    for(int i = 0; i < extensions.length; i++)\n    {\n        int CAP = 0, SM = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] >= 'A' && extensions[i][j] <= 'Z')\n                CAP++;\n            else\n                SM++;\n        }\n        strength += CAP - SM;\n        if(strength > strongest_extension.length())\n            strongest_extension = extensions[i];\n    }\n    return class_name + \".\" + strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpb8ykunqc.d(29): Error: no property `length` for type `string`\n/tmp/tmpb8ykunqc.d(37): Error: no property `length` for type `string`\n/tmp/tmpb8ykunqc.d(40): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb8ykunqc.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    string str = \"\";\n    for(int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        strength = cap - sm;\n        if(str == \"\")\n        {\n            str = class_name + \".\" + extensions[i];\n        }\n        else if(strength > strength)\n        {\n            str = class_name + \".\" + extensions[i];\n        }\n    }\n    return str;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmp23pwqz_h.d(32): Error: no property `length` for type `string`\n/tmp/tmp23pwqz_h.d(42): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmp23pwqz_h.d(46): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp23pwqz_h.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int CAP, SM;\n    string result;\n    CAP = SM = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        CAP += count_char(extensions[i], 'A');\n        SM += count_char(extensions[i], 'a');\n    }\n    result = class_name + \".\" + extensions[0];\n    for (int i = 1; i < extensions.length; i++)\n    {\n        if (CAP - SM < CAP - SM)\n        {\n            result = class_name + \".\" + extensions[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmp7xnxxbpi.d(29): Error: undefined identifier `count_char`\n/tmp/tmp7xnxxbpi.d(30): Error: undefined identifier `count_char`\n/tmp/tmp7xnxxbpi.d(32): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmp7xnxxbpi.d(37): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7xnxxbpi.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int cap, sm;\n    cap = sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        cap += (extensions[i].length() - extensions[i].find_first_of(\"abcdefghijklmnopqrstuvwxyz\"));\n        sm += (extensions[i].length() - extensions[i].find_first_of(\"abcdefghijklmnopqrstuvwxyz\"));\n    }\n    return class_name + \".\" + extensions[0];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmp8tds_fts.d(28): Error: no property `length` for type `string`\n/tmp/tmp8tds_fts.d(28): Error: no property `find_first_of` for type `string`\n/tmp/tmp8tds_fts.d(29): Error: no property `length` for type `string`\n/tmp/tmp8tds_fts.d(29): Error: no property `find_first_of` for type `string`\n/tmp/tmp8tds_fts.d(31): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8tds_fts.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    string str = \"\";\n    for (int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        strength += (cap - sm);\n    }\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (extensions[i] == class_name)\n            continue;\n        cap = 0;\n        sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        if (cap - sm > strength)\n        {\n            str = class_name + \".\" + extensions[i];\n            strength = cap - sm;\n        }\n    }\n    return str;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpsbdxcioj.d(32): Error: no property `length` for type `string`\n/tmp/tmpsbdxcioj.d(47): Error: no property `length` for type `string`\n/tmp/tmpsbdxcioj.d(56): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsbdxcioj.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int CAP, SM;\n    CAP = SM = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        CAP += (extensions[i].length() - extensions[i].count('.'));\n        SM += (extensions[i].length() - extensions[i].count('.'));\n    }\n    return class_name + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] +\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpxwcbnstf.d(32): Error: expression expected, not `unittest`\n/tmp/tmpxwcbnstf.d(33): Error: found `{` when expecting `;` following `return` statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxwcbnstf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n            {\n                cap++;\n            }\n            else\n            {\n                sm++;\n            }\n        }\n        strength += (cap - sm);\n    }\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (extensions[i] == class_name)\n        {\n            return class_name + \".\" + extensions[i];\n        }\n    }\n    return class_name + \".\" + extensions[0];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmp510et8u7.d(31): Error: no property `length` for type `string`\n/tmp/tmp510et8u7.d(48): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmp510et8u7.d(51): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp510et8u7.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            if(extensions[i][j] == 'a' || extensions[i][j] == 'A')\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    for(int i = 0; i < extensions.length; i++)\n    {\n        if(strength == 0)\n            return class_name + \".\" + extensions[i];\n        if(strength < 0)\n            return class_name + \".\" + extensions[i];\n        if(strength == 0)\n            return class_name + \".\" + extensions[i];\n        if(strength > 0 && strength < extensions.length)\n            return class_name + \".\" + extensions[i];\n    }\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpnngo2ic7.d(31): Error: no property `length` for type `string`\n/tmp/tmpnngo2ic7.d(43): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpnngo2ic7.d(45): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpnngo2ic7.d(47): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpnngo2ic7.d(49): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnngo2ic7.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        int c = 0;\n        int l = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == '.')\n            {\n                c++;\n                l = 0;\n            }\n            else\n            {\n                l++;\n            }\n        }\n        cap += c;\n        sm += l;\n        strength += (cap - sm);\n    }\n    for(int i = 0; i < extensions.length; i++)\n    {\n        if(strength == 0)\n        {\n            return class_name + \".\" + extensions[i];\n        }\n        if(strength == strength && extensions[i] < class_name)\n        {\n            return class_name + \".\" + extensions[i];\n        }\n    }\n    return class_name + \".\" + extensions[0];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpywot3gij.d(31): Error: no property `length` for type `string`\n/tmp/tmpywot3gij.d(51): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpywot3gij.d(55): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpywot3gij.d(58): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpywot3gij.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int cap = 0, sm = 0;\n    for(int i = 0; i < class_name.length(); i++)\n        if(class_name[i] >= 'A' && class_name[i] <= 'Z')\n            cap++;\n        else\n            sm++;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        int cap_ext = 0, sm_ext = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n            if(extensions[i][j] >= 'A' && extensions[i][j] <= 'Z')\n                cap_ext++;\n            else\n                sm_ext++;\n        cap -= sm_ext;\n        sm += cap_ext;\n        if(cap_ext > sm_ext)\n            cap = cap_ext;\n        else\n            sm = sm_ext;\n    }\n    return class_name + \".\" + extensions[cap - sm];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmp4p53rj5e.d(25): Error: no property `length` for type `string`\n/tmp/tmp4p53rj5e.d(33): Error: no property `length` for type `string`\n/tmp/tmp4p53rj5e.d(45): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4p53rj5e.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        int c = 0;\n        int l = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                c++;\n            if(extensions[i][j] == 'a')\n                l++;\n        }\n        cap += c;\n        sm += l;\n        strength += (cap - sm);\n    }\n    \n    string result = class_name;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        if(strength == strength)\n        {\n            if(extensions[i] < result)\n                result = extensions[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmp89swzvfq.d(31): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp89swzvfq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int c = 0;\n        int l = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                c++;\n            if (extensions[i][j] == 'a')\n                l++;\n        }\n        strength += c - l;\n        if (c > cap)\n            cap = c;\n        if (l > sm)\n            sm = l;\n    }\n    if (cap - sm == 0)\n        return class_name + \".\" + extensions[0];\n    else\n    {\n        int index = 0;\n        for (int i = 0; i < extensions.length; i++)\n        {\n            if (cap - sm == strength && extensions[i] < extensions[index])\n                index = i;\n        }\n        return class_name + \".\" + extensions[index];\n    }\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpmf_8ahc2.d(31): Error: no property `length` for type `string`\n/tmp/tmpmf_8ahc2.d(45): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpmf_8ahc2.d(54): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmf_8ahc2.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int CAP, SM;\n    CAP = SM = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        CAP += extensions[i].count('A');\n        SM += extensions[i].count('a');\n    }\n    CAP -= SM;\n    string result = class_name + \".\" + extensions[0];\n    for(int i = 1; i < extensions.length; i++)\n    {\n        if(CAP - SM < CAP - SM)\n        {\n            result = class_name + \".\" + extensions[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpoegt1srl.d(28): Error: no property `count` for type `string`\n/tmp/tmpoegt1srl.d(29): Error: no property `count` for type `string`\n/tmp/tmpoegt1srl.d(32): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpoegt1srl.d(37): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoegt1srl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int CAP = 0, SM = 0;\n    for (int i = 0; i < class_name.length(); i++)\n        if (class_name[i] >= 'A' && class_name[i] <= 'Z')\n            CAP++;\n        else\n            SM++;\n    \n    int max_strength = CAP - SM;\n    string max_extension = \"\";\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int strength = CAP - SM;\n        for (int j = 0; j < extensions[i].length(); j++)\n            if (extensions[i][j] >= 'A' && extensions[i][j] <= 'Z')\n                strength--;\n            else\n                strength++;\n        if (strength > max_strength)\n        {\n            max_strength = strength;\n            max_extension = extensions[i];\n        }\n    }\n    return class_name + \".\" + max_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpxckkva7y.d(25): Error: no property `length` for type `string`\n/tmp/tmpxckkva7y.d(36): Error: no property `length` for type `string`\n/tmp/tmpxckkva7y.d(47): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxckkva7y.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int CAP, SM;\n    CAP = SM = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        CAP += count(extensions[i], 'A');\n        SM += count(extensions[i], 'a');\n    }\n    return class_name + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "/tmp/tmp62gn5jzl.d(32): Error: found `unittest` when expecting `,`\n/tmp/tmp62gn5jzl.d(46): Error: found `void` when expecting `,`\n/tmp/tmp62gn5jzl.d(46): Error: found `{` when expecting `,`\n/tmp/tmp62gn5jzl.d(46): Error: expression expected, not `}`\n/tmp/tmp62gn5jzl.d(46): Error: found `End of File` when expecting `,`\n/tmp/tmp62gn5jzl.d(46): Error: found `End of File` when expecting `]`\n/tmp/tmp62gn5jzl.d(46): Error: found `End of File` when expecting `;` following `return` statement\n/tmp/tmp62gn5jzl.d(46): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp62gn5jzl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    string ext = \"\";\n    for(int i = 0; i < extensions.length; i++)\n    {\n        ext = extensions[i];\n        cap = 0;\n        sm = 0;\n        for(int j = 0; j < ext.length(); j++)\n        {\n            if(ext[j] == 'A' || ext[j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    for(int i = 0; i < extensions.length; i++)\n    {\n        ext = extensions[i];\n        if(ext.compare(class_name) == 0)\n            continue;\n        cap = 0;\n        sm = 0;\n        for(int j = 0; j < ext.length(); j++)\n        {\n            if(ext[j] == 'A' || ext[j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        if(cap - sm > strength)\n        {\n            strength = cap - sm;\n            ext = extensions[i];\n        }\n    }\n    return class_name + \".\" + ext;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmp11ohjdfs.d(33): Error: no property `length` for type `string`\n/tmp/tmp11ohjdfs.d(45): Error: no property `compare` for type `string`\n/tmp/tmp11ohjdfs.d(49): Error: no property `length` for type `string`\n/tmp/tmp11ohjdfs.d(62): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp11ohjdfs.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int cap, sm;\n    string str;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] >= 'A' && extensions[i][j] <= 'Z')\n                cap++;\n            else\n                sm++;\n        }\n        if (cap - sm > 0)\n        {\n            str = class_name + \".\" + extensions[i];\n            return str;\n        }\n    }\n    return class_name;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmp5idcgeu0.d(30): Error: no property `length` for type `string`\n/tmp/tmp5idcgeu0.d(39): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5idcgeu0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        int c = 0;\n        int l = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                c++;\n            if(extensions[i][j] == 'a')\n                l++;\n        }\n        strength += c - l;\n        if(c > cap)\n            cap = c;\n        if(l > sm)\n            sm = l;\n    }\n    return class_name + \".\" + extensions[strength - sm];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpvmm86sk_.d(31): Error: no property `length` for type `string`\n/tmp/tmpvmm86sk_.d(44): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvmm86sk_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    \n    for(int i = 0; i < extensions.length; i++)\n    {\n        if(extensions[i] == class_name)\n            continue;\n        if(extensions[i] == class_name + \".\" + class_name)\n            continue;\n        if(extensions[i] == class_name + \".\" + class_name + \".\" + class_name)\n            continue;\n        if(extensions[i] == class_name + \".\" + class_name + \".\" + class_name + \".\" + class_name)\n            continue;\n        if(extensions[i] == class_name + \".\" + class_name + \".\" + class_name + \".\" + class_name + \".\" + class_name)\n            continue;\n        if(extensions[i] == class_name + \".\" + class_name + \".\" + class_name + \".\" + class_name + \".\" + class_name + \".\" + class_name)\n            continue;\n        if(extensions[i] == class_name + \".\" + class_name + \".\" + class_name + \".\" + class_name + \".\" + class_name + \".\" + class_name + \".\" + class_name)\n            continue;\n        if(extensions[i] == class_name + \".\" + class_name + \".\" + class_name + \".\" + class_name + \".\" + class_name + \".\" + class_name + \".\" + class_name + \".\" + class_name)\n            continue;\n        if(extensions[i] == class_name + \".\" + class_name + \".\"\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpsqzmmkdo.d(60): Error: found `unittest` when expecting `)`\n/tmp/tmpsqzmmkdo.d(74): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpsqzmmkdo.d(74): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsqzmmkdo.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    \n    string result = class_name;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (strength == strength)\n        {\n            if (extensions[i] < result)\n                result = extensions[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmppdogq6g1.d(31): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppdogq6g1.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int i = 0;\n    string name = class_name;\n    string extension = \"\";\n    while (i < extensions.length)\n    {\n        extension = extensions[i];\n        int CAP = 0;\n        int SM = 0;\n        for (int j = 0; j < extension.length(); j++)\n        {\n            if (extension[j] == 'A' || extension[j] == 'a')\n                CAP++;\n            if (extension[j] == 'a' || extension[j] == 'A')\n                SM++;\n        }\n        strength += CAP - SM;\n        i++;\n    }\n    i = 0;\n    while (i < extensions.length)\n    {\n        extension = extensions[i];\n        if (extension.length() > name.length())\n            name = extension;\n        i++;\n    }\n    return name + \".\" + extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpyltdjcm2.d(33): Error: no property `length` for type `string`\n/tmp/tmpyltdjcm2.d(47): Error: no property `length` for type `string`\n/tmp/tmpyltdjcm2.d(47): Error: no property `length` for type `string`\n/tmp/tmpyltdjcm2.d(51): Error: invalid array operation `name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyltdjcm2.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string extension = \"\";\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int cap = 0;\n        int sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else if (extensions[i][j] == 'a')\n                sm++;\n        }\n        strength += cap - sm;\n        if (strength > extension.length())\n            extension = extensions[i];\n    }\n    return class_name + \".\" + extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpyqsdshsk.d(30): Error: no property `length` for type `string`\n/tmp/tmpyqsdshsk.d(38): Error: no property `length` for type `string`\n/tmp/tmpyqsdshsk.d(41): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyqsdshsk.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int CAP = 0, SM = 0;\n    for (int i = 0; i < class_name.length(); i++)\n    {\n        if (class_name[i] >= 'A' && class_name[i] <= 'Z')\n            CAP++;\n        else\n            SM++;\n    }\n    \n    int max_strength = CAP - SM;\n    string max_extension = \"\";\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int strength = CAP - SM;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] >= 'A' && extensions[i][j] <= 'Z')\n                strength--;\n            else\n                strength++;\n        }\n        if (strength > max_strength)\n        {\n            max_strength = strength;\n            max_extension = extensions[i];\n        }\n    }\n    return class_name + \".\" + max_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpmfkpyyyo.d(25): Error: no property `length` for type `string`\n/tmp/tmpmfkpyyyo.d(38): Error: no property `length` for type `string`\n/tmp/tmpmfkpyyyo.d(51): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmfkpyyyo.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string strongest_extension = \"\";\n    for(int i = 0; i < extensions.length; i++)\n    {\n        int CAP = 0, SM = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                CAP++;\n            else if(extensions[i][j] == 'a')\n                SM++;\n        }\n        strength += CAP - SM;\n        if(strength > strongest_extension.length())\n            strongest_extension = extensions[i];\n    }\n    return class_name + \".\" + strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmp3puvl5gt.d(29): Error: no property `length` for type `string`\n/tmp/tmp3puvl5gt.d(37): Error: no property `length` for type `string`\n/tmp/tmp3puvl5gt.d(40): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3puvl5gt.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int cap, sm;\n    string str;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else if(extensions[i][j] == 'a')\n                sm++;\n        }\n        if(cap - sm > 0)\n        {\n            str = class_name + \".\" + extensions[i];\n            return str;\n        }\n    }\n    return class_name;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmp5b2x8jqd.d(30): Error: no property `length` for type `string`\n/tmp/tmp5b2x8jqd.d(39): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5b2x8jqd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    \n    for(int i = 0; i < extensions.length; i++)\n    {\n        if(extensions[i] == class_name)\n            continue;\n        if(extensions[i] == class_name + \".\" + class_name)\n            continue;\n        if(extensions[i] == class_name + \".\" + class_name.substr(0, class_name.length() - 1))\n            continue;\n        if(extensions[i] == class_name.substr(0, class_name.length() - 1) + \".\" + class_name)\n            continue;\n        if(extensions[i] == class_name.substr(0, class_name.length() - 1) + \".\" + class_name.substr(0, class_name.length() - 1))\n            continue;\n        if(extensions[i] == class_name.substr(0, class_name.length() - 2) + \".\" + class_name)\n            continue;\n        if(extensions[i] == class_name.substr(0, class_name.length() - 2) + \".\" + class_name.substr(0, class_name.length() - 2))\n            continue;\n        if(extensions[i] == class_name.substr(0, class_name.length() - 3) + \".\" + class_name)\n            continue;\n        if(extensions[i] == class_name.substr(0, class_name.length() - 3) + \".\" + class_name.substr(0, class_name.length() - 3))\n            continue\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpfgbdi1vv.d(61): Error: found `unittest` when expecting `;` following `continue` statement\n/tmp/tmpfgbdi1vv.d(75): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpfgbdi1vv.d(75): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfgbdi1vv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int CAP, SM;\n    int strength = 0;\n    int max_strength = 0;\n    string max_extension = \"\";\n    for (int i = 0; i < extensions.length; i++)\n    {\n        CAP = 0;\n        SM = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                CAP++;\n            if (extensions[i][j] == 'a' || extensions[i][j] == 'A')\n                SM++;\n        }\n        strength = CAP - SM;\n        if (strength > max_strength)\n        {\n            max_strength = strength;\n            max_extension = extensions[i];\n        }\n    }\n    return class_name + \".\" + max_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpp9ykdgyk.d(32): Error: no property `length` for type `string`\n/tmp/tmpp9ykdgyk.d(46): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp9ykdgyk.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int cap = 0, sm = 0;\n    for (int i = 0; i < class_name.length(); i++)\n    {\n        if (class_name[i] >= 'A' && class_name[i] <= 'Z')\n            cap++;\n        else if (class_name[i] >= 'a' && class_name[i] <= 'z')\n            sm++;\n    }\n    int strength = cap - sm;\n    string result = class_name + \".\";\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (extensions[i].length() > result.length())\n            result = extensions[i];\n        else if (extensions[i].length() == result.length() && strength < extensions[i].length())\n            result = extensions[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmp3dwhalqx.d(25): Error: no property `length` for type `string`\n/tmp/tmp3dwhalqx.d(33): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmp3dwhalqx.d(36): Error: no property `length` for type `string`\n/tmp/tmp3dwhalqx.d(36): Error: no property `length` for type `string`\n/tmp/tmp3dwhalqx.d(38): Error: no property `length` for type `string`\n/tmp/tmp3dwhalqx.d(38): Error: no property `length` for type `string`\n/tmp/tmp3dwhalqx.d(38): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3dwhalqx.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    for(int i = 0; i < extensions.length; i++)\n    {\n        if(extensions[i].compare(class_name) == 0)\n            return class_name + \".\" + extensions[i];\n    }\n    return class_name + \".\" + extensions[0];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmp3h7erwy1.d(31): Error: no property `length` for type `string`\n/tmp/tmp3h7erwy1.d(42): Error: no property `compare` for type `string`\n/tmp/tmp3h7erwy1.d(43): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmp3h7erwy1.d(45): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3h7erwy1.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int cap, sm;\n    string str;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            if (extensions[i][j] == 'a' || extensions[i][j] == 'A')\n                sm++;\n        }\n        if (cap - sm > 0)\n            str = class_name + \".\" + extensions[i];\n    }\n    return str;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpvglh4hw7.d(30): Error: no property `length` for type `string`\n/tmp/tmpvglh4hw7.d(38): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvglh4hw7.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    \n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (extensions[i] == class_name)\n            continue;\n        if (extensions[i].length() > class_name.length())\n            continue;\n        if (extensions[i].length() < class_name.length())\n            continue;\n        if (extensions[i].substr(0, class_name.length()) == class_name)\n        {\n            if (strength < 0)\n                return class_name + \".\" + extensions[i];\n            else if (strength == 0)\n            {\n                if (cap > sm)\n                    return class_name + \".\" + extensions[i];\n                else\n                    return class_name + \".\" + extensions[i];\n            }\n            else if (strength > 0)\n            {\n                if (cap > sm)\n                    return class_name + \".\" + extensions[i];\n                else\n                    return class_name + \".\" + extensions[i];\n            }\n        }\n    }\n    return class_name + \".\" + extensions[0];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmphey12hb7.d(31): Error: no property `length` for type `string`\n/tmp/tmphey12hb7.d(45): Error: no property `length` for type `string`\n/tmp/tmphey12hb7.d(45): Error: no property `length` for type `string`\n/tmp/tmphey12hb7.d(47): Error: no property `length` for type `string`\n/tmp/tmphey12hb7.d(47): Error: no property `length` for type `string`\n/tmp/tmphey12hb7.d(49): Error: no property `substr` for type `string`\n/tmp/tmphey12hb7.d(52): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmphey12hb7.d(56): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmphey12hb7.d(58): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmphey12hb7.d(63): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmphey12hb7.d(65): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmphey12hb7.d(69): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\",",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    string result = class_name;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (extensions[i].length() > 0)\n        {\n            cap = 0;\n            sm = 0;\n            for (int j = 0; j < extensions[i].length(); j++)\n            {\n                if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                    cap++;\n                else\n                    sm++;\n            }\n            strength = cap - sm;\n            if (strength > strength)\n            {\n                result = class_name + \".\" + extensions[i];\n                strength = cap - sm;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmp6xr2fx6m.d(30): Error: no property `length` for type `string`\n/tmp/tmp6xr2fx6m.d(34): Error: no property `length` for type `string`\n/tmp/tmp6xr2fx6m.d(44): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6xr2fx6m.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string result = class_name;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        int cap = 0, sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            if(extensions[i][j] == 'a' || extensions[i][j] == 'A')\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    for(int i = 0; i < extensions.length; i++)\n    {\n        if(strength == 0)\n        {\n            result = class_name + \".\" + extensions[i];\n            break;\n        }\n        if(strength < 0)\n            strength = 0;\n        if(strength == 0 && i == 0)\n            continue;\n        if(strength < extensions[i].length())\n        {\n            result = class_name + \".\" + extensions[i];\n            strength = 0;\n            break;\n        }\n        if(strength > extensions[i].length())\n            strength = extensions[i].length();\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpyioi502u.d(29): Error: no property `length` for type `string`\n/tmp/tmpyioi502u.d(42): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpyioi502u.d(49): Error: no property `length` for type `string`\n/tmp/tmpyioi502u.d(51): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpyioi502u.d(55): Error: no property `length` for type `string`\n/tmp/tmpyioi502u.d(56): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyioi502u.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int CAP, SM;\n    int strength = 0;\n    string result = \"\";\n    for (int i = 0; i < extensions.length; i++)\n    {\n        CAP = 0;\n        SM = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n            {\n                CAP++;\n            }\n            if (extensions[i][j] == 'a' || extensions[i][j] == 'A')\n            {\n                SM++;\n            }\n        }\n        strength += CAP - SM;\n    }\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (extensions[i] == class_name)\n        {\n            result = class_name + \".\" + extensions[i];\n        }\n        if (strength == 0)\n        {\n            result = class_name + \".\" + extensions[i];\n        }\n        if (strength == strength && strength != 0)\n        {\n            if (extensions[i] < result)\n            {\n                result = extensions[i];\n            }\n        }\n        if (strength == strength && strength != 0 && extensions[i] > result)\n        {\n            result = extensions[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpoyj6sae0.d(31): Error: no property `length` for type `string`\n/tmp/tmpoyj6sae0.d(48): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpoyj6sae0.d(52): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoyj6sae0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    string name = class_name;\n    for (int i = 0; i < name.length(); i++)\n    {\n        if (isupper(name[i]))\n            cap++;\n        else\n            sm++;\n    }\n    for (int i = 0; i < extensions.length; i++)\n    {\n        string ext = extensions[i];\n        int cap_ext = 0;\n        int sm_ext = 0;\n        for (int j = 0; j < ext.length(); j++)\n        {\n            if (isupper(ext[j]))\n                cap_ext++;\n            else\n                sm_ext++;\n        }\n        strength += cap_ext - sm_ext;\n    }\n    int index = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (strength == strength)\n        {\n            if (extensions[i] < name)\n                index = i;\n        }\n    }\n    return name + \".\" + extensions[index];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpzkcr65oa.d(28): Error: no property `length` for type `string`\n/tmp/tmpzkcr65oa.d(30): Error: undefined identifier `isupper`\n/tmp/tmpzkcr65oa.d(40): Error: no property `length` for type `string`\n/tmp/tmpzkcr65oa.d(42): Error: undefined identifier `isupper`\n/tmp/tmpzkcr65oa.d(58): Error: invalid array operation `name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzkcr65oa.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int CAP, SM;\n    int strength = 0;\n    string result = \"\";\n    for (int i = 0; i < extensions.length; i++)\n    {\n        CAP = 0;\n        SM = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n            {\n                CAP++;\n            }\n            else\n            {\n                SM++;\n            }\n        }\n        strength += CAP - SM;\n        if (strength > result.length())\n        {\n            result = class_name + \".\" + extensions[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpy0efthvd.d(31): Error: no property `length` for type `string`\n/tmp/tmpy0efthvd.d(43): Error: no property `length` for type `string`\n/tmp/tmpy0efthvd.d(45): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy0efthvd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] >= 'A' && extensions[i][j] <= 'Z')\n                cap++;\n            else\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    \n    string result = class_name;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (strength == extensions[i].length())\n        {\n            result += \".\" + extensions[i];\n            break;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpxdgwxizr.d(31): Error: no property `length` for type `string`\n/tmp/tmpxdgwxizr.d(44): Error: no property `length` for type `string`\n/tmp/tmpxdgwxizr.d(46): Error: invalid array operation `\".\" + extensions[cast(ulong)i]` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxdgwxizr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string best_extension = \"\";\n    for(int i = 0; i < extensions.length; i++)\n    {\n        int cap = 0, sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            if(extensions[i][j] == 'a' || extensions[i][j] == 'A')\n                sm++;\n        }\n        strength += cap - sm;\n        if(strength > best_extension.length())\n            best_extension = extensions[i];\n    }\n    return class_name + \".\" + best_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmp6b0u6pvv.d(29): Error: no property `length` for type `string`\n/tmp/tmp6b0u6pvv.d(37): Error: no property `length` for type `string`\n/tmp/tmp6b0u6pvv.d(40): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6b0u6pvv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++) {\n        int c = 0;\n        int l = 0;\n        for (int j = 0; j < extensions[i].length(); j++) {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a') {\n                c++;\n            }\n            if (extensions[i][j] == 'a' || extensions[i][j] == 'A') {\n                l++;\n            }\n        }\n        strength += (c - l);\n        if (c > cap) {\n            cap = c;\n        }\n        if (l > sm) {\n            sm = l;\n        }\n    }\n    string ret = class_name;\n    for (int i = 0; i < extensions.length; i++) {\n        if (extensions[i] == class_name) {\n            continue;\n        }\n        if (cap - sm == strength) {\n            ret += \".\" + extensions[i];\n        }\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpmull2ucy.d(30): Error: no property `length` for type `string`\n/tmp/tmpmull2ucy.d(52): Error: invalid array operation `\".\" + extensions[cast(ulong)i]` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmull2ucy.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int c = 0;\n        int l = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                c++;\n            if (extensions[i][j] == 'a' || extensions[i][j] == 'A')\n                l++;\n        }\n        strength += (c - l);\n        if (c > cap)\n            cap = c;\n        if (l > sm)\n            sm = l;\n    }\n    if (cap - sm == 0)\n        return class_name + \".\" + extensions[0];\n    else\n        return class_name + \".\" + extensions[strength - (cap - sm)];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmp3k99mmyz.d(31): Error: no property `length` for type `string`\n/tmp/tmp3k99mmyz.d(45): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmp3k99mmyz.d(47): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3k99mmyz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int CAP, SM;\n    int strength = 0;\n    string result = \"\";\n    for(int i = 0; i < extensions.length; i++)\n    {\n        CAP = 0;\n        SM = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                CAP++;\n            else\n                SM++;\n        }\n        strength += CAP - SM;\n    }\n    for(int i = 0; i < extensions.length; i++)\n    {\n        if(extensions[i] == class_name)\n            continue;\n        CAP = 0;\n        SM = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                CAP++;\n            else\n                SM++;\n        }\n        if(strength < CAP - SM)\n        {\n            result = class_name + \".\" + extensions[i];\n            break;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpkyf8zrky.d(31): Error: no property `length` for type `string`\n/tmp/tmpkyf8zrky.d(46): Error: no property `length` for type `string`\n/tmp/tmpkyf8zrky.d(55): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkyf8zrky.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    string result = class_name;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (strength == strength)\n        {\n            if (extensions[i] < result)\n                result = extensions[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpv8jztc5z.d(31): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv8jztc5z.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            if (extensions[i][j] == 'a' || extensions[i][j] == 'A')\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    \n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (extensions[i] == class_name)\n            continue;\n        if (extensions[i] == class_name + \".java\")\n            continue;\n        if (extensions[i] == class_name + \".class\")\n            continue;\n        if (extensions[i] == class_name + \".cpp\")\n            continue;\n        if (extensions[i] == class_name + \".h\")\n            continue;\n        if (extensions[i] == class_name + \".py\")\n            continue;\n        if (extensions[i] == class_name + \".pyc\")\n            continue;\n        if (extensions[i] == class_name + \".pyd\")\n            continue;\n        if (extensions[i] == class_name + \".rb\")\n            continue;\n        if (extensions[i] == class_name + \".sh\")\n            continue;\n        if (extensions[i] == class_name + \".txt\")\n            continue;\n        if (extensions[i] == class_name + \".xml\")\n            continue;\n        if (extensions[i] == class_name + \".yml\")\n            continue;\n        if (extensions[i] == class_name + \".yaml\")\n            continue;\n        if (extensions[i] == class_name + \".yml\")\n            continue;\n        if (extensions[i] == class_name + \".yml\")\n            continue;\n\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmp39ohq820.d(76): Error: found `unittest` instead of statement\n/tmp/tmp39ohq820.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp39ohq820.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int CAP = 0, SM = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        CAP += count(extensions[i], 'A');\n        SM += count(extensions[i], 'a');\n    }\n    return class_name + \".\" + extensions[count_if(extensions, is_upper) - count_if(extensions, is_lower) - CAP + SM];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmp8vsrgiwd.d(27): Error: undefined identifier `count`\n/tmp/tmp8vsrgiwd.d(28): Error: undefined identifier `count`\n/tmp/tmp8vsrgiwd.d(30): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmp8vsrgiwd.d(30): Error: undefined identifier `count_if`\n/tmp/tmp8vsrgiwd.d(30): Error: undefined identifier `count_if`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8vsrgiwd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int CAP, SM;\n    string result;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        CAP = 0;\n        SM = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] >= 'A' && extensions[i][j] <= 'Z')\n                CAP++;\n            else\n                SM++;\n        }\n        if(CAP - SM > result.length())\n            result = extensions[i];\n    }\n    return class_name + \".\" + result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpt4m5vq8h.d(30): Error: no property `length` for type `string`\n/tmp/tmpt4m5vq8h.d(37): Error: no property `length` for type `string`\n/tmp/tmpt4m5vq8h.d(40): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt4m5vq8h.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int CAP, SM;\n    CAP = SM = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        CAP += count(extensions[i], 'A');\n        SM += count(extensions[i], 'a');\n    }\n    return class_name + \".\" + extensions[count_sort(extensions, SM, CAP)];\n}\n\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpmyx89bpb.d(28): Error: undefined identifier `count`\n/tmp/tmpmyx89bpb.d(29): Error: undefined identifier `count`\n/tmp/tmpmyx89bpb.d(31): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpmyx89bpb.d(31): Error: undefined identifier `count_sort`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmyx89bpb.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (extensions[i] == class_name)\n            continue;\n        if (extensions[i] == class_name + \".\" + class_name)\n            continue;\n        if (extensions[i] == class_name + \".\" + class_name.substr(0, class_name.length() - 1))\n            continue;\n        if (extensions[i] == class_name.substr(0, class_name.length() - 1) + \".\" + class_name)\n            continue;\n        if (extensions[i] == class_name.substr(0, class_name.length() - 1) + \".\" + class_name.substr(0, class_name.length() - 1))\n            continue;\n        if (extensions[i] == class_name.substr(0, class_name.length() - 2) + \".\" + class_name)\n            continue;\n        if (extensions[i] == class_name.substr(0, class_name.length() - 2) + \".\" + class_name.substr(0, class_name.length() - 2))\n            continue;\n        if (extensions[i] == class_name.substr(0, class_name.length() - 3) + \".\" + class_name)\n            continue;\n        if (extensions[i] == class_name.substr(0, class_name.length() - 3) + \".\" + class_name.substr(0, class_name.length() - 3))\n            continue;\n\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpbji9a3jz.d(61): Error: found `unittest` instead of statement\n/tmp/tmpbji9a3jz.d(75): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbji9a3jz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string result = class_name;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        int cap = 0, sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] >= 'A' && extensions[i][j] <= 'Z')\n                cap++;\n            else\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    for(int i = 0; i < extensions.length; i++)\n    {\n        if(strength == 0)\n            break;\n        if(strength > 0 && strength == extensions[i].length())\n        {\n            result += \".\" + extensions[i];\n            strength = 0;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmph05isuom.d(29): Error: no property `length` for type `string`\n/tmp/tmph05isuom.d(42): Error: no property `length` for type `string`\n/tmp/tmph05isuom.d(44): Error: invalid array operation `\".\" + extensions[cast(ulong)i]` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph05isuom.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int cap = 0, sm = 0;\n    for(int i = 0; i < class_name.length(); i++)\n    {\n        if(class_name[i] >= 'A' && class_name[i] <= 'Z')\n            cap++;\n        else if(class_name[i] >= 'a' && class_name[i] <= 'z')\n            sm++;\n    }\n    \n    int max_cap = 0, max_sm = 0;\n    string max_ext = \"\";\n    for(int i = 0; i < extensions.length; i++)\n    {\n        int cap_ext = 0, sm_ext = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] >= 'A' && extensions[i][j] <= 'Z')\n                cap_ext++;\n            else if(extensions[i][j] >= 'a' && extensions[i][j] <= 'z')\n                sm_ext++;\n        }\n        if(cap_ext - sm_ext > max_cap - max_sm)\n        {\n            max_cap = cap_ext;\n            max_sm = sm_ext;\n            max_ext = extensions[i];\n        }\n    }\n    return class_name + \".\" + max_ext;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpb0agzg4l.d(25): Error: no property `length` for type `string`\n/tmp/tmpb0agzg4l.d(38): Error: no property `length` for type `string`\n/tmp/tmpb0agzg4l.d(52): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb0agzg4l.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string strongest_extension = \"\";\n    for(int i = 0; i < extensions.length; i++)\n    {\n        int cap = 0, sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else if(extensions[i][j] == 'a')\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    for(int i = 0; i < extensions.length; i++)\n    {\n        if(strength == 0)\n        {\n            strongest_extension = class_name + \".\" + extensions[i];\n            break;\n        }\n        if(strength < 0 && strength > -1)\n        {\n            if(strength > -1)\n                strength = -1;\n            strongest_extension = class_name + \".\" + extensions[i];\n            break;\n        }\n        if(strength > 0)\n        {\n            if(strength > extensions[i].length())\n                strength -= extensions[i].length();\n            else\n                strength = 0;\n        }\n    }\n    return strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmp6u6xfsij.d(29): Error: no property `length` for type `string`\n/tmp/tmp6u6xfsij.d(42): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmp6u6xfsij.d(49): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmp6u6xfsij.d(54): Error: no property `length` for type `string`\n/tmp/tmp6u6xfsij.d(55): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6u6xfsij.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string strongest_extension = \"\";\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int cap = 0, sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] >= 'A' && extensions[i][j] <= 'Z')\n                cap++;\n            else if (extensions[i][j] >= 'a' && extensions[i][j] <= 'z')\n                sm++;\n        }\n        strength += cap - sm;\n        if (strength > strongest_extension.length())\n            strongest_extension = extensions[i];\n    }\n    return class_name + \".\" + strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmp1oac6ipp.d(29): Error: no property `length` for type `string`\n/tmp/tmp1oac6ipp.d(37): Error: no property `length` for type `string`\n/tmp/tmp1oac6ipp.d(40): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1oac6ipp.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n            {\n                cap++;\n            }\n            else\n            {\n                sm++;\n            }\n        }\n        strength += (cap - sm);\n    }\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (extensions[i] == class_name)\n        {\n            continue;\n        }\n        if (extensions[i] == class_name + \".\" + class_name)\n        {\n            continue;\n        }\n        if (extensions[i] == class_name + \".\" + class_name.substr(0, class_name.length() - 1))\n        {\n            continue;\n        }\n        if (extensions[i] == class_name.substr(0, class_name.length() - 1) + \".\" + class_name)\n        {\n            continue;\n        }\n        if (extensions[i] == class_name.substr(0, class_name.length() - 2) + \".\" + class_name.substr(class_name.length() - 1))\n        {\n            continue;\n        }\n        if (extensions[i] == class_name.substr(0, class_name.length() - 3) + \".\" + class_name.substr(class_name.length() - 2))\n        {\n            continue;\n        }\n        if (extensions[i] == class_name.substr(0, class_name.length() - 4) + \".\" + class_name.substr(class_name.length() - 3))\n        {\n            continue;\n        }\n        if (extensions[i] == class_name.substr(0, class_name.length() - 5) + \".\" +\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpy5ysms7y.d(75): Error: expression expected, not `unittest`\n/tmp/tmpy5ysms7y.d(76): Error: found `{` when expecting `)`\n/tmp/tmpy5ysms7y.d(89): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy5ysms7y.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string result = class_name;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        int cap = 0, sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            if(extensions[i][j] == 'a' || extensions[i][j] == 'A')\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    for(int i = 0; i < extensions.length; i++)\n    {\n        if(strength == 0)\n            break;\n        if(strength < 0)\n            strength = 0;\n        if(strength == 0 && i == 0)\n            continue;\n        if(strength < extensions[i].length())\n        {\n            strength = extensions[i].length();\n            result = class_name + \".\" + extensions[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpvcxpn8ep.d(29): Error: no property `length` for type `string`\n/tmp/tmpvcxpn8ep.d(46): Error: no property `length` for type `string`\n/tmp/tmpvcxpn8ep.d(48): Error: no property `length` for type `string`\n/tmp/tmpvcxpn8ep.d(49): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvcxpn8ep.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    int i = 0;\n    string str = \"\";\n    for(i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            if(extensions[i][j] == 'a' || extensions[i][j] == 'A')\n                sm++;\n        }\n        strength = cap - sm;\n        if(strength > strength)\n        {\n            str = class_name + \".\" + extensions[i];\n            strength = cap - sm;\n        }\n    }\n    return str;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpxdb4pw80.d(33): Error: no property `length` for type `string`\n/tmp/tmpxdb4pw80.d(43): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxdb4pw80.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int cap, sm;\n    string result;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        if(cap - sm > result.length())\n            result = extensions[i];\n    }\n    return class_name + \".\" + result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "/tmp/tmpegyublei.d(30): Error: no property `length` for type `string`\n/tmp/tmpegyublei.d(37): Error: no property `length` for type `string`\n/tmp/tmpegyublei.d(40): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpegyublei.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        strength = strength + (extensions[i].length() - extensions[i].find_first_of(\"abcdefghijklmnopqrstuvwxyz\"));\n        cap = cap + extensions[i].find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n        sm = sm + extensions[i].find_first_of(\"abcdefghijklmnopqrstuvwxyz\");\n    }\n    return class_name + \".\" + extensions[strength < 0 ? 0 : strength > extensions.length - 1 ? extensions.length - 1 : strength] + \".\";\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmp370w26vv.d(29): Error: no property `length` for type `string`\n/tmp/tmp370w26vv.d(29): Error: no property `find_first_of` for type `string`\n/tmp/tmp370w26vv.d(30): Error: no property `find_first_of` for type `string`\n/tmp/tmp370w26vv.d(31): Error: no property `find_first_of` for type `string`\n/tmp/tmp370w26vv.d(33): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp370w26vv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int cap = 0, sm = 0;\n    for (int i = 0; i < class_name.length(); i++) {\n        if (class_name[i] >= 'A' && class_name[i] <= 'Z') {\n            cap++;\n        }\n        if (class_name[i] >= 'a' && class_name[i] <= 'z') {\n            sm++;\n        }\n    }\n    \n    int strength = cap - sm;\n    string result = class_name;\n    for (int i = 0; i < extensions.length; i++) {\n        if (extensions[i].length() > 0 && strength == 0) {\n            return result + \".\" + extensions[i];\n        }\n        if (extensions[i].length() > 0 && strength > 0) {\n            int ext_cap = 0, ext_sm = 0;\n            for (int j = 0; j < extensions[i].length(); j++) {\n                if (extensions[i][j] >= 'A' && extensions[i][j] <= 'Z') {\n                    ext_cap++;\n                }\n                if (extensions[i][j] >= 'a' && extensions[i][j] <= 'z') {\n                    ext_sm++;\n                }\n            }\n            if (ext_cap - ext_sm > strength) {\n                strength = ext_cap - ext_sm;\n                result = class_name;\n            }\n        }\n    }\n    return result + \".\" + extensions[0];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmp3v9021l8.d(25): Error: no property `length` for type `string`\n/tmp/tmp3v9021l8.d(37): Error: no property `length` for type `string`\n/tmp/tmp3v9021l8.d(38): Error: invalid array operation `result + \".\"` (possible missing [])\n/tmp/tmp3v9021l8.d(40): Error: no property `length` for type `string`\n/tmp/tmp3v9021l8.d(42): Error: no property `length` for type `string`\n/tmp/tmp3v9021l8.d(56): Error: invalid array operation `result + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3v9021l8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n            {\n                cap++;\n            }\n            else\n            {\n                sm++;\n            }\n        }\n        strength += cap - sm;\n    }\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (extensions[i].compare(class_name) == 0)\n        {\n            return class_name + \".\" + extensions[i];\n        }\n    }\n    return class_name + \".\" + extensions[0];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpqnecrlgt.d(31): Error: no property `length` for type `string`\n/tmp/tmpqnecrlgt.d(46): Error: no property `compare` for type `string`\n/tmp/tmpqnecrlgt.d(48): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpqnecrlgt.d(51): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqnecrlgt.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int cap, sm;\n    string ext;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        ext = extensions[i];\n        cap = 0;\n        sm = 0;\n        for (int j = 0; j < ext.length(); j++)\n        {\n            if (ext[j] >= 'A' && ext[j] <= 'Z')\n                cap++;\n            else\n                sm++;\n        }\n        if (cap - sm > 0)\n            return class_name + \".\" + ext;\n    }\n    return class_name + \".NONE\";\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmp11okmud3.d(31): Error: no property `length` for type `string`\n/tmp/tmp11okmud3.d(39): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmp11okmud3.d(41): Error: invalid array operation `class_name + \".NONE\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp11okmud3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int CAP, SM;\n    int strength = 0;\n    string result = \"\";\n    for (int i = 0; i < extensions.length; i++)\n    {\n        CAP = 0;\n        SM = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] >= 'A' && extensions[i][j] <= 'Z')\n                CAP++;\n            else if (extensions[i][j] >= 'a' && extensions[i][j] <= 'z')\n                SM++;\n        }\n        strength += CAP - SM;\n        if (strength > result.length())\n            result = class_name + \".\" + extensions[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmphhewm5et.d(31): Error: no property `length` for type `string`\n/tmp/tmphhewm5et.d(39): Error: no property `length` for type `string`\n/tmp/tmphhewm5et.d(40): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphhewm5et.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        strength += (cap - sm);\n    }\n    string ret = class_name;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        if(extensions[i] == class_name)\n            continue;\n        if(extensions[i] == ret)\n            continue;\n        if(strength == 0)\n            continue;\n        if(strength == strength)\n        {\n            if(extensions[i] < ret)\n                ret = extensions[i];\n        }\n        else if(strength > strength)\n        {\n            if(extensions[i] < ret)\n                ret = extensions[i];\n        }\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpafbfkjgi.d(31): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpafbfkjgi.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++) {\n        int c = 0;\n        int l = 0;\n        for (int j = 0; j < extensions[i].length(); j++) {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a') {\n                c++;\n            }\n            if (extensions[i][j] == 'a' || extensions[i][j] == 'A') {\n                l++;\n            }\n        }\n        strength += c - l;\n        if (c > cap) {\n            cap = c;\n        }\n        if (l > sm) {\n            sm = l;\n        }\n    }\n    string ret = class_name;\n    for (int i = 0; i < extensions.length; i++) {\n        if (cap - sm == strength && extensions[i] < ret) {\n            ret = extensions[i];\n        }\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpczcyyb5y.d(30): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpczcyyb5y.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int CAP, SM;\n    CAP = SM = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        CAP += count(extensions[i], 'A');\n        SM += count(extensions[i], 'a');\n    }\n    return class_name + \".\" + extensions[count_sort(extensions, SM, CAP)];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmp3uy_qp6t.d(28): Error: undefined identifier `count`\n/tmp/tmp3uy_qp6t.d(29): Error: undefined identifier `count`\n/tmp/tmp3uy_qp6t.d(31): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmp3uy_qp6t.d(31): Error: undefined identifier `count_sort`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3uy_qp6t.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        strength += (extensions[i].length() - extensions[i].find_first_of(\"abcdefghijklmnopqrstuvwxyz\"));\n        cap += extensions[i].find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n        sm += extensions[i].find_first_of(\"abcdefghijklmnopqrstuvwxyz\");\n    }\n    return class_name + \".\" + extensions[strength < 0 ? 0 : strength].substr(0, extensions[strength < 0 ? 0 : strength].length() - 1);\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpeipddvd4.d(29): Error: no property `length` for type `string`\n/tmp/tmpeipddvd4.d(29): Error: no property `find_first_of` for type `string`\n/tmp/tmpeipddvd4.d(30): Error: no property `find_first_of` for type `string`\n/tmp/tmpeipddvd4.d(31): Error: no property `find_first_of` for type `string`\n/tmp/tmpeipddvd4.d(33): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpeipddvd4.d(33): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeipddvd4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int cap = 0, sm = 0;\n    for (int i = 0; i < class_name.length(); i++)\n        if (class_name[i] >= 'A' && class_name[i] <= 'Z')\n            cap++;\n        else\n            sm++;\n    \n    int strength = cap - sm;\n    \n    string best_ext = \"\";\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int ext_cap = 0, ext_sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n            if (extensions[i][j] >= 'A' && extensions[i][j] <= 'Z')\n                ext_cap++;\n            else\n                ext_sm++;\n        \n        if (ext_cap - ext_sm > strength)\n        {\n            strength = ext_cap - ext_sm;\n            best_ext = extensions[i];\n        }\n    }\n    \n    return class_name + \".\" + best_ext;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpfdl12n16.d(25): Error: no property `length` for type `string`\n/tmp/tmpfdl12n16.d(37): Error: no property `length` for type `string`\n/tmp/tmpfdl12n16.d(50): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfdl12n16.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int c = 0;\n        int l = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == '.')\n            {\n                break;\n            }\n            if (extensions[i][j] == '_')\n            {\n                continue;\n            }\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n            {\n                c++;\n            }\n            if (extensions[i][j] == 'a')\n            {\n                l++;\n            }\n        }\n        strength += c - l;\n        cap += c;\n        sm += l;\n    }\n    strength = strength / (cap - sm);\n    string result = class_name;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (strength == extensions[i].length())\n        {\n            result += \".\" + extensions[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpv4hcppgm.d(31): Error: no property `length` for type `string`\n/tmp/tmpv4hcppgm.d(58): Error: no property `length` for type `string`\n/tmp/tmpv4hcppgm.d(60): Error: invalid array operation `\".\" + extensions[cast(ulong)i]` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv4hcppgm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        int c = 0;\n        int l = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                c++;\n            if(extensions[i][j] == 'a')\n                l++;\n        }\n        strength += (c - l);\n        if(c > cap)\n            cap = c;\n        if(l > sm)\n            sm = l;\n    }\n    if(cap - sm > 0)\n        return class_name + \".\" + extensions[0];\n    else\n        return class_name + \".\" + extensions[extensions.length - 1];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpc1rnfu7g.d(31): Error: no property `length` for type `string`\n/tmp/tmpc1rnfu7g.d(45): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpc1rnfu7g.d(47): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc1rnfu7g.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n            {\n                cap++;\n            }\n            else\n            {\n                sm++;\n            }\n        }\n        strength += (cap - sm);\n    }\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (extensions[i] == class_name)\n        {\n            return class_name + \".\" + extensions[i];\n        }\n    }\n    return class_name + \".\" + extensions[0];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmp510et8u7.d(31): Error: no property `length` for type `string`\n/tmp/tmp510et8u7.d(48): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmp510et8u7.d(51): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp510et8u7.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int cap, sm;\n    string ret = class_name;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            if (extensions[i][j] == 'a' || extensions[i][j] == 'A')\n                sm++;\n        }\n        if (cap - sm > ret.length())\n            ret = class_name + \".\" + extensions[i];\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpsqppyzqb.d(30): Error: no property `length` for type `string`\n/tmp/tmpsqppyzqb.d(37): Error: no property `length` for type `string`\n/tmp/tmpsqppyzqb.d(38): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsqppyzqb.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string strongest_extension = \"\";\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int cap = 0;\n        int sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            if (extensions[i][j] == 'a' || extensions[i][j] == 'A')\n                sm++;\n        }\n        strength += cap - sm;\n        if (strength > strongest_extension.length())\n            strongest_extension = extensions[i];\n    }\n    return class_name + \".\" + strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpekzcdtds.d(30): Error: no property `length` for type `string`\n/tmp/tmpekzcdtds.d(38): Error: no property `length` for type `string`\n/tmp/tmpekzcdtds.d(41): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpekzcdtds.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int CAP = 0, SM = 0;\n    for(int i = 0; i < class_name.length(); i++)\n    {\n        if(class_name[i] >= 'A' && class_name[i] <= 'Z')\n            CAP++;\n        else\n            SM++;\n    }\n    \n    int max_strength = CAP - SM;\n    int max_strength_index = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        int strength = CAP - SM;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] >= 'A' && extensions[i][j] <= 'Z')\n                strength--;\n            else\n                strength++;\n        }\n        if(strength > max_strength)\n        {\n            max_strength = strength;\n            max_strength_index = i;\n        }\n    }\n    return class_name + \".\" + extensions[max_strength_index];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpetp4j7lh.d(25): Error: no property `length` for type `string`\n/tmp/tmpetp4j7lh.d(38): Error: no property `length` for type `string`\n/tmp/tmpetp4j7lh.d(51): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpetp4j7lh.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            if(extensions[i][j] == 'a' || extensions[i][j] == 'A')\n                sm++;\n        }\n        strength += (cap - sm);\n    }\n    for(int i = 0; i < extensions.length; i++)\n    {\n        if(strength == 0)\n            return class_name + \".\" + extensions[i];\n        if(strength < 0 && strength > -1)\n            return class_name + \".\" + extensions[i];\n    }\n    return class_name + \".\" + extensions[0];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpp30dm3x8.d(31): Error: no property `length` for type `string`\n/tmp/tmpp30dm3x8.d(43): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpp30dm3x8.d(45): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpp30dm3x8.d(47): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp30dm3x8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    string result = class_name;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        if(strength == strength)\n        {\n            if(extensions[i] < result)\n                result = extensions[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "/tmp/tmph_92lcq_.d(31): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph_92lcq_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string strongest_extension = \"\";\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int cap = 0;\n        int sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n            {\n                cap++;\n            }\n            if (extensions[i][j] == 'a' || extensions[i][j] == 'A')\n            {\n                sm++;\n            }\n        }\n        strength += cap - sm;\n        if (strength > strongest_extension.length())\n        {\n            strongest_extension = extensions[i];\n        }\n    }\n    return class_name + \".\" + strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "/tmp/tmprf2ndbpx.d(30): Error: no property `length` for type `string`\n/tmp/tmprf2ndbpx.d(42): Error: no property `length` for type `string`\n/tmp/tmprf2ndbpx.d(47): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprf2ndbpx.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            if (extensions[i][j] == 'a' || extensions[i][j] == 'A')\n                sm++;\n        }\n        strength += (cap - sm);\n    }\n    string result = class_name;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (strength == 0)\n            break;\n        if (strength == strength && strength == strength)\n        {\n            if (extensions[i] < result)\n                result = extensions[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpbpwg1u75.d(31): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbpwg1u75.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            if (extensions[i][j] == 'a' || extensions[i][j] == 'A')\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (strength == 0)\n            return class_name + \".\" + extensions[i];\n        if (strength < 0 && strength > -1)\n            return class_name + \".\" + extensions[i];\n    }\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmp469p_5ya.d(31): Error: no property `length` for type `string`\n/tmp/tmp469p_5ya.d(43): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmp469p_5ya.d(45): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp469p_5ya.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int c = 0;\n        int l = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n            {\n                c++;\n            }\n            if (extensions[i][j] == 'a' || extensions[i][j] == 'A')\n            {\n                l++;\n            }\n        }\n        strength += (c - l);\n        if (c > l)\n        {\n            cap = c;\n        }\n        else\n        {\n            sm = l;\n        }\n    }\n    string result = class_name + \".\" + extensions[0];\n    for (int i = 1; i < extensions.length; i++)\n    {\n        if (cap - sm < strength)\n        {\n            result = class_name + \".\" + extensions[i];\n            break;\n        }\n        else if (cap - sm == strength)\n        {\n            if (extensions[i] < extensions[i - 1])\n            {\n                result = class_name + \".\" + extensions[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmphbwwp4p2.d(31): Error: no property `length` for type `string`\n/tmp/tmphbwwp4p2.d(52): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmphbwwp4p2.d(57): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmphbwwp4p2.d(64): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphbwwp4p2.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string strongest_extension = \"\";\n    for(int i = 0; i < extensions.length; i++)\n    {\n        int cap = 0;\n        int sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else if(extensions[i][j] == 'a')\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    for(int i = 0; i < extensions.length; i++)\n    {\n        if(strength == 0)\n        {\n            strongest_extension = class_name + \".\" + extensions[i];\n            break;\n        }\n        else if(strength < 0 && strength > -(extensions.length - i))\n        {\n            strongest_extension = class_name + \".\" + extensions[i];\n            break;\n        }\n    }\n    return strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpviv1yg7a.d(30): Error: no property `length` for type `string`\n/tmp/tmpviv1yg7a.d(43): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpviv1yg7a.d(48): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpviv1yg7a.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int CAP, SM;\n    CAP = SM = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        CAP += extensions[i].count('A');\n        SM += extensions[i].count('a');\n    }\n    return class_name + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\"\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "/tmp/tmph4r_c30r.d(32): Error: found `unittest` when expecting `;` following `return` statement\n/tmp/tmph4r_c30r.d(46): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph4r_c30r.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int CAP = 0, SM = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        CAP += count(extensions[i], 'A');\n        SM += count(extensions[i], 'a');\n    }\n    return class_name + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\"\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpg8j_oj6z.d(31): Error: found `unittest` when expecting `;` following `return` statement\n/tmp/tmpg8j_oj6z.d(45): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg8j_oj6z.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string best_extension = \"\";\n    for(int i = 0; i < extensions.length; i++)\n    {\n        int cap = 0;\n        int sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        strength += cap - sm;\n        if(strength > best_extension.length())\n            best_extension = extensions[i];\n    }\n    return class_name + \".\" + best_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpiepf98pb.d(30): Error: no property `length` for type `string`\n/tmp/tmpiepf98pb.d(38): Error: no property `length` for type `string`\n/tmp/tmpiepf98pb.d(41): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiepf98pb.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            if(extensions[i][j] == 'a' || extensions[i][j] == 'A')\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    for(int i = 0; i < extensions.length; i++)\n    {\n        if(extensions[i].compare(class_name) == 0)\n            return class_name + \".\" + extensions[i];\n    }\n    return class_name + \".\" + extensions[0];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmp4q59jj1j.d(31): Error: no property `length` for type `string`\n/tmp/tmp4q59jj1j.d(42): Error: no property `compare` for type `string`\n/tmp/tmp4q59jj1j.d(43): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmp4q59jj1j.d(45): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4q59jj1j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        cap += count(extensions[i], 'A');\n        sm += count(extensions[i], 'a');\n    }\n    return class_name + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0]\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmp9qr8_2fs.d(32): Error: found `unittest` when expecting `;` following `return` statement\n/tmp/tmp9qr8_2fs.d(46): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9qr8_2fs.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string strongest_extension = \"\";\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int cap = 0;\n        int sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n            {\n                cap++;\n            }\n            else if (extensions[i][j] == 'a' || extensions[i][j] == 'A')\n            {\n                sm++;\n            }\n        }\n        strength += cap - sm;\n        if (strength > strongest_extension.length())\n        {\n            strongest_extension = extensions[i];\n        }\n    }\n    return class_name + \".\" + strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpain7mecg.d(30): Error: no property `length` for type `string`\n/tmp/tmpain7mecg.d(42): Error: no property `length` for type `string`\n/tmp/tmpain7mecg.d(47): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpain7mecg.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n            {\n                cap++;\n            }\n            else\n            {\n                sm++;\n            }\n        }\n        strength += cap - sm;\n    }\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (extensions[i] == class_name)\n        {\n            return class_name + \".\" + extensions[i];\n        }\n    }\n    return class_name + \".\" + extensions[0];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpf7nn1q2w.d(31): Error: no property `length` for type `string`\n/tmp/tmpf7nn1q2w.d(48): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpf7nn1q2w.d(51): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf7nn1q2w.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string strongest_extension = \"\";\n    for(int i = 0; i < extensions.length; i++)\n    {\n        int cap = 0, sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else if(extensions[i][j] == 'a')\n                sm++;\n        }\n        strength += cap - sm;\n        if(strength > strongest_extension.length())\n            strongest_extension = extensions[i];\n    }\n    return class_name + \".\" + strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpnxcysaqf.d(29): Error: no property `length` for type `string`\n/tmp/tmpnxcysaqf.d(37): Error: no property `length` for type `string`\n/tmp/tmpnxcysaqf.d(40): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnxcysaqf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    string result = \"\";\n    for (int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (extensions[i] == class_name)\n            continue;\n        if (extensions[i] == \"\")\n            continue;\n        if (extensions[i] == \" \")\n            continue;\n        if (extensions[i] == \".\")\n            continue;\n        if (extensions[i] == \"..\")\n            continue;\n        if (extensions[i] == \"...\")\n            continue;\n        if (extensions[i] == \"...\")\n            continue;\n        if (extensions[i] == \"...\")\n            continue;\n        if (extensions[i] == \"...\")\n            continue;\n        if (extensions[i] == \"...\")\n            continue;\n        if (extensions[i] == \"...\")\n            continue;\n        if (extensions[i] == \"...\")\n            continue;\n        if (extensions[i] == \"...\")\n            continue;\n        if (extensions[i] == \"...\")\n            continue;\n        if (extensions[i] == \"...\")\n            continue;\n        if (extensions[i] == \"...\")\n            continue;\n        if (extensions[i] == \"...\")\n            continue;\n        if (extensions[i] == \"...\")\n            continue;\n        if (extensions[i] == \"...\")\n            continue;\n        if (extensions[i] == \"...\")\n            continue;\n        if (extensions[i] == \"...\")\n            continue;\n        \nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpiaugq_pb.d(86): Error: found `unittest` instead of statement\n/tmp/tmpiaugq_pb.d(100): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiaugq_pb.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string result = class_name;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        int cap = 0, sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] >= 'A' && extensions[i][j] <= 'Z')\n                cap++;\n            else\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    for(int i = 0; i < extensions.length; i++)\n    {\n        if(strength == 0)\n            break;\n        if(strength < 0)\n            strength = 0;\n        if(strength == 0 && i == 0)\n            continue;\n        if(strength < extensions[i].length())\n        {\n            result = class_name + \".\" + extensions[i];\n            strength = 0;\n        }\n        else if(strength == extensions[i].length())\n        {\n            if(i == 0)\n                continue;\n            result = class_name + \".\" + extensions[i];\n            strength = 0;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmps0ywf07_.d(29): Error: no property `length` for type `string`\n/tmp/tmps0ywf07_.d(46): Error: no property `length` for type `string`\n/tmp/tmps0ywf07_.d(48): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmps0ywf07_.d(51): Error: no property `length` for type `string`\n/tmp/tmps0ywf07_.d(55): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps0ywf07_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    \n    int index = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        if(strength == strength)\n        {\n            if(extensions[i] < extensions[index])\n                index = i;\n        }\n    }\n    return class_name + \".\" + extensions[index];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmp39o4t79c.d(31): Error: no property `length` for type `string`\n/tmp/tmp39o4t79c.d(50): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp39o4t79c.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int cap = 0, sm = 0;\n    for(int i = 0; i < class_name.length(); i++)\n    {\n        if(class_name[i] >= 'A' && class_name[i] <= 'Z')\n            cap++;\n        else if(class_name[i] >= 'a' && class_name[i] <= 'z')\n            sm++;\n    }\n    int max = 0;\n    string max_ext = \"\";\n    for(int i = 0; i < extensions.length; i++)\n    {\n        int curr_cap = 0, curr_sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] >= 'A' && extensions[i][j] <= 'Z')\n                curr_cap++;\n            else if(extensions[i][j] >= 'a' && extensions[i][j] <= 'z')\n                curr_sm++;\n        }\n        if(curr_cap - curr_sm > max)\n        {\n            max = curr_cap - curr_sm;\n            max_ext = extensions[i];\n        }\n    }\n    return class_name + \".\" + max_ext;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpyul0gr27.d(25): Error: no property `length` for type `string`\n/tmp/tmpyul0gr27.d(37): Error: no property `length` for type `string`\n/tmp/tmpyul0gr27.d(50): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyul0gr27.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int CAP, SM;\n    string result = class_name;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        CAP = 0;\n        SM = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] >= 'A' && extensions[i][j] <= 'Z')\n                CAP++;\n            else\n                SM++;\n        }\n        if (CAP - SM > result.length() - result.length())\n            result = class_name + \".\" + extensions[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpdkr8gfj4.d(30): Error: no property `length` for type `string`\n/tmp/tmpdkr8gfj4.d(37): Error: no property `length` for type `string`\n/tmp/tmpdkr8gfj4.d(37): Error: no property `length` for type `string`\n/tmp/tmpdkr8gfj4.d(38): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdkr8gfj4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string result = class_name;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int cap = 0, sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            if (extensions[i][j] == 'a' || extensions[i][j] == 'A')\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (strength == 0)\n            break;\n        if (strength == strength && strength > 0)\n        {\n            if (extensions[i] < result)\n                result = extensions[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmps2z7qsvs.d(29): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps2z7qsvs.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string result = class_name;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int cap = 0, sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else if (extensions[i][j] == 'a')\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (strength == 0)\n            break;\n        if (strength < 0)\n            strength = 0;\n        if (extensions[i] == result)\n            continue;\n        if (extensions[i] == result + \".\" + result)\n            continue;\n        if (extensions[i] == result + \".\" + result + \".\" + result)\n            continue;\n        if (extensions[i] == result + \".\" + result + \".\" + result + \".\" + result)\n            continue;\n        if (extensions[i] == result + \".\" + result + \".\" + result + \".\" + result + \".\" + result)\n            continue;\n        if (extensions[i] == result + \".\" + result + \".\" + result + \".\" + result + \".\" + result + \".\" + result)\n            continue;\n        if (extensions[i] == result + \".\" + result + \".\" + result + \".\" + result + \".\" + result + \".\" + result + \".\" + result)\n            continue;\n        if (extensions[i] == result + \".\" + result + \".\" + result + \".\" + result + \".\" + result + \".\" + result + \".\" + result + \".\" + result)\n            continue;\n        if (extensions[i] == result + \".\" + result + \".\" + result + \".\" + result + \".\" + result + \".\" + result + \".\" + result + \".\" + result + \".\" + result)\n            continue;\n        if (extensions[i\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmp8opu3qno.d(63): Error: found `unittest` when expecting `,`\n/tmp/tmp8opu3qno.d(77): Error: found `void` when expecting `,`\n/tmp/tmp8opu3qno.d(77): Error: found `{` when expecting `,`\n/tmp/tmp8opu3qno.d(77): Error: expression expected, not `}`\n/tmp/tmp8opu3qno.d(77): Error: found `End of File` when expecting `,`\n/tmp/tmp8opu3qno.d(77): Error: found `End of File` when expecting `]`\n/tmp/tmp8opu3qno.d(77): Error: found `End of File` when expecting `)`\n/tmp/tmp8opu3qno.d(77): Error: found `End of File` instead of statement\n/tmp/tmp8opu3qno.d(77): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp8opu3qno.d(77): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8opu3qno.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int c = 0;\n        int l = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n            {\n                c++;\n            }\n            if (extensions[i][j] == 'a')\n            {\n                l++;\n            }\n        }\n        strength += c - l;\n        if (c > cap)\n        {\n            cap = c;\n        }\n        if (l > sm)\n        {\n            sm = l;\n        }\n    }\n    string result = class_name;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (cap - sm == strength)\n        {\n            if (extensions[i] < result)\n            {\n                result = extensions[i];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292518,
      "stdout": "",
      "stderr": "/tmp/tmp_ypp53x5.d(31): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_ypp53x5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int cap, sm;\n    string result = class_name;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        if (cap - sm > result.length())\n            result = class_name + \".\" + extensions[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292518,
      "stdout": "",
      "stderr": "/tmp/tmpm6f8n0zr.d(30): Error: no property `length` for type `string`\n/tmp/tmpm6f8n0zr.d(37): Error: no property `length` for type `string`\n/tmp/tmpm6f8n0zr.d(38): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm6f8n0zr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string strongest_extension = \"\";\n    for(int i = 0; i < extensions.length; i++)\n    {\n        int cap = 0;\n        int sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            if(extensions[i][j] == 'a' || extensions[i][j] == 'A')\n                sm++;\n        }\n        strength += cap - sm;\n        if(strength > strongest_extension.length())\n            strongest_extension = extensions[i];\n    }\n    return class_name + \".\" + strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmptdujac98.d(30): Error: no property `length` for type `string`\n/tmp/tmptdujac98.d(38): Error: no property `length` for type `string`\n/tmp/tmptdujac98.d(41): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptdujac98.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string strongest_extension = \"\";\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int CAP = 0, SM = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                CAP++;\n            else\n                SM++;\n        }\n        strength += CAP - SM;\n        if (strength > strongest_extension.length())\n            strongest_extension = extensions[i];\n    }\n    return class_name + \".\" + strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292518,
      "stdout": "",
      "stderr": "/tmp/tmpx8vd77j8.d(29): Error: no property `length` for type `string`\n/tmp/tmpx8vd77j8.d(37): Error: no property `length` for type `string`\n/tmp/tmpx8vd77j8.d(40): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx8vd77j8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    string result = class_name;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        if(strength == strength)\n        {\n            if(extensions[i] < result)\n                result = extensions[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "/tmp/tmph_92lcq_.d(31): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph_92lcq_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int CAP, SM;\n    string result;\n    CAP = SM = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        CAP += count(extensions[i], 'A');\n        SM += count(extensions[i], 'a');\n    }\n    result = class_name + \".\" + extensions[0];\n    for(int i = 1; i < extensions.length; i++)\n    {\n        if(CAP - SM < CAP - SM)\n        {\n            result = class_name + \".\" + extensions[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292518,
      "stdout": "",
      "stderr": "/tmp/tmpwnl2q172.d(29): Error: undefined identifier `count`\n/tmp/tmpwnl2q172.d(30): Error: undefined identifier `count`\n/tmp/tmpwnl2q172.d(32): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpwnl2q172.d(37): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwnl2q172.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int CAP, SM;\n    int strength = 0;\n    string extension_name = \"\";\n    for(int i = 0; i < extensions.length; i++)\n    {\n        CAP = 0;\n        SM = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                CAP++;\n            else\n                SM++;\n        }\n        strength += CAP - SM;\n        if(strength > strength)\n        {\n            strength = CAP - SM;\n            extension_name = extensions[i];\n        }\n    }\n    return class_name + \".\" + extension_name;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292518,
      "stdout": "",
      "stderr": "/tmp/tmpx3oldyq2.d(31): Error: no property `length` for type `string`\n/tmp/tmpx3oldyq2.d(45): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx3oldyq2.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        int c = 0;\n        int l = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                c++;\n            if(extensions[i][j] == 'a')\n                l++;\n        }\n        if(c > strength)\n            strength = c;\n        if(l > sm)\n            sm = l;\n    }\n    cap = strength - sm;\n    string result = class_name;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        if(cap == strength && extensions[i] < result)\n            result = extensions[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292518,
      "stdout": "",
      "stderr": "/tmp/tmpqjtun0n1.d(31): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqjtun0n1.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string strongest_extension = \"\";\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int cap = 0, sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            if (extensions[i][j] == 'a' || extensions[i][j] == 'A')\n                sm++;\n        }\n        strength += cap - sm;\n        if (strength > strongest_extension.length())\n            strongest_extension = extensions[i];\n    }\n    return class_name + \".\" + strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "/tmp/tmpj0sfiirt.d(29): Error: no property `length` for type `string`\n/tmp/tmpj0sfiirt.d(37): Error: no property `length` for type `string`\n/tmp/tmpj0sfiirt.d(40): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj0sfiirt.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int cap = 0, sm = 0;\n    for (int i = 0; i < class_name.length(); i++)\n        if (class_name[i] >= 'A' && class_name[i] <= 'Z')\n            cap++;\n        else\n            sm++;\n    \n    int max_cap = 0, max_sm = 0;\n    string max_ext = \"\";\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int cap_ext = 0, sm_ext = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n            if (extensions[i][j] >= 'A' && extensions[i][j] <= 'Z')\n                cap_ext++;\n            else\n                sm_ext++;\n        if (cap_ext > max_cap || (cap_ext == max_cap && sm_ext > max_sm))\n        {\n            max_cap = cap_ext;\n            max_sm = sm_ext;\n            max_ext = extensions[i];\n        }\n    }\n    return class_name + \".\" + max_ext;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292518,
      "stdout": "",
      "stderr": "/tmp/tmp1l7agxde.d(25): Error: no property `length` for type `string`\n/tmp/tmp1l7agxde.d(36): Error: no property `length` for type `string`\n/tmp/tmp1l7agxde.d(48): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1l7agxde.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string best_extension = \"\";\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int cap = 0, sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        strength += cap - sm;\n        if (strength > best_extension.length())\n            best_extension = extensions[i];\n    }\n    return class_name + \".\" + best_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292518,
      "stdout": "",
      "stderr": "/tmp/tmpac7m0m1r.d(29): Error: no property `length` for type `string`\n/tmp/tmpac7m0m1r.d(37): Error: no property `length` for type `string`\n/tmp/tmpac7m0m1r.d(40): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpac7m0m1r.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string strongest_extension = \"\";\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int cap = 0, sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            if (extensions[i][j] == 'a' || extensions[i][j] == 'A')\n                sm++;\n        }\n        strength += cap - sm;\n        if (strength > strongest_extension.length())\n            strongest_extension = extensions[i];\n    }\n    return class_name + \".\" + strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "/tmp/tmpj0sfiirt.d(29): Error: no property `length` for type `string`\n/tmp/tmpj0sfiirt.d(37): Error: no property `length` for type `string`\n/tmp/tmpj0sfiirt.d(40): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj0sfiirt.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int CAP, SM;\n    CAP = SM = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        CAP += count(extensions[i], 'A');\n        SM += count(extensions[i], 'a');\n    }\n    return class_name + \".\" + extensions[count_sort(extensions, SM, CAP)];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292518,
      "stdout": "",
      "stderr": "/tmp/tmpg0ypjvy0.d(28): Error: undefined identifier `count`\n/tmp/tmpg0ypjvy0.d(29): Error: undefined identifier `count`\n/tmp/tmpg0ypjvy0.d(31): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpg0ypjvy0.d(31): Error: undefined identifier `count_sort`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg0ypjvy0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    string result = \"\";\n    for (int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n            {\n                cap++;\n            }\n            else\n            {\n                sm++;\n            }\n        }\n        strength += cap - sm;\n    }\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (extensions[i] == class_name)\n        {\n            continue;\n        }\n        if (extensions[i] == class_name + \".\" + class_name)\n        {\n            continue;\n        }\n        if (extensions[i] == class_name + \".\" + class_name + \".\" + class_name)\n        {\n            continue;\n        }\n        if (extensions[i] == class_name + \".\" + class_name + \".\" + class_name + \".\" + class_name)\n        {\n            continue;\n        }\n        if (extensions[i] == class_name + \".\" + class_name + \".\" + class_name + \".\" + class_name + \".\" + class_name)\n        {\n            continue;\n        }\n        if (extensions[i] == class_name + \".\" + class_name + \".\" + class_name + \".\" + class_name + \".\" + class_name + \".\" + class_name)\n        {\n            continue;\n        }\n        if (extensions[i] == class_name + \".\" + class_name + \".\" + class_name + \".\" + class_name + \".\" + class_name + \".\" + class_name + \".\" + class_name)\n        {\n            continue;\n        }\n        if (extensions[i] == class_name + \".\" + class_name + \".\" + class_name + \".\" +\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpkuu3qqw3.d(76): Error: expression expected, not `unittest`\n/tmp/tmpkuu3qqw3.d(77): Error: found `{` when expecting `)`\n/tmp/tmpkuu3qqw3.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkuu3qqw3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int CAP, SM;\n    string str;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        CAP = 0;\n        SM = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                CAP++;\n            else\n                SM++;\n        }\n        if (CAP - SM > 0)\n        {\n            str = class_name + \".\" + extensions[i];\n            return str;\n        }\n    }\n    return class_name;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292518,
      "stdout": "",
      "stderr": "/tmp/tmpxh8nie16.d(30): Error: no property `length` for type `string`\n/tmp/tmpxh8nie16.d(39): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxh8nie16.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string strongest_extension = \"\";\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int cap = 0;\n        int sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        strength += cap - sm;\n        if (strength > strongest_extension.length())\n            strongest_extension = extensions[i];\n    }\n    return class_name + \".\" + strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292518,
      "stdout": "",
      "stderr": "/tmp/tmp4039s2r3.d(30): Error: no property `length` for type `string`\n/tmp/tmp4039s2r3.d(38): Error: no property `length` for type `string`\n/tmp/tmp4039s2r3.d(41): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4039s2r3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    \n    int max_strength = strength;\n    string max_extension = \"\";\n    for(int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        if(strength == max_strength && strength == cap - sm)\n        {\n            if(extensions[i] < max_extension)\n                max_extension = extensions[i];\n        }\n        else if(strength > max_strength)\n        {\n            max_strength = strength;\n            max_extension = extensions[i];\n        }\n    }\n    return class_name + \".\" + max_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292518,
      "stdout": "",
      "stderr": "/tmp/tmpzui_dgc4.d(31): Error: no property `length` for type `string`\n/tmp/tmpzui_dgc4.d(47): Error: no property `length` for type `string`\n/tmp/tmpzui_dgc4.d(65): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzui_dgc4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        strength += (cap - sm);\n    }\n    string result = class_name + \".\" + extensions[0];\n    for (int i = 1; i < extensions.length; i++)\n    {\n        if (strength == extensions[i].length())\n        {\n            if (extensions[i] < result)\n                result = extensions[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292518,
      "stdout": "",
      "stderr": "/tmp/tmpu5iscgkg.d(31): Error: no property `length` for type `string`\n/tmp/tmpu5iscgkg.d(40): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpu5iscgkg.d(43): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu5iscgkg.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int CAP, SM;\n    string str;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        CAP = 0;\n        SM = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                CAP++;\n            if (extensions[i][j] == 'a' || extensions[i][j] == 'A')\n                SM++;\n        }\n        if (CAP - SM > 0)\n        {\n            str = class_name + \".\" + extensions[i];\n        }\n    }\n    return str;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292518,
      "stdout": "",
      "stderr": "/tmp/tmpa4bfyq5x.d(30): Error: no property `length` for type `string`\n/tmp/tmpa4bfyq5x.d(39): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa4bfyq5x.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string strongest_extension = \"\";\n    for(int i = 0; i < extensions.length; i++)\n    {\n        int cap = 0;\n        int sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else if(extensions[i][j] == 'a')\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    for(int i = 0; i < extensions.length; i++)\n    {\n        if(strength == 0)\n        {\n            strongest_extension = class_name + \".\" + extensions[i];\n            break;\n        }\n        else if(strength < 0 && strength > -1)\n        {\n            if(extensions[i] < strongest_extension)\n            {\n                strongest_extension = class_name + \".\" + extensions[i];\n            }\n        }\n    }\n    return strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292518,
      "stdout": "",
      "stderr": "/tmp/tmpom4x1019.d(30): Error: no property `length` for type `string`\n/tmp/tmpom4x1019.d(43): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpom4x1019.d(50): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpom4x1019.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    string result = class_name;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (extensions[i] == result)\n            continue;\n        if (extensions[i] == result + \".class\")\n            continue;\n        if (extensions[i] == result + \".java\")\n            continue;\n        if (extensions[i] == result + \".txt\")\n            continue;\n        if (extensions[i] == result + \".jpg\")\n            continue;\n        if (extensions[i] == result + \".png\")\n            continue;\n        if (extensions[i] == result + \".gif\")\n            continue;\n        if (extensions[i] == result + \".class\")\n            continue;\n        if (extensions[i] == result + \".java\")\n            continue;\n        if (extensions[i] == result + \".txt\")\n            continue;\n        if (extensions[i] == result + \".jpg\")\n            continue;\n        if (extensions[i] == result + \".png\")\n            continue;\n        if (extensions[i] == result + \".gif\")\n            continue;\n        if (extensions[i] == result + \".class\")\n            continue;\n        if (extensions[i] == result + \".java\")\n            continue;\n        if (extensions[i] == result + \".txt\")\n            continue;\n        if (extensions[i] == result + \".jpg\")\n            continue;\n        if (extensions[i] == result + \".png\")\n            continue;\n        if (extensions[i] == result + \".gif\")\n            \nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292518,
      "stdout": "",
      "stderr": "/tmp/tmp7ua_wnx0.d(81): Error: found `unittest` instead of statement\n/tmp/tmp7ua_wnx0.d(95): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7ua_wnx0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    for(int i = 0; i < extensions.length; i++)\n    {\n        if(strength == 0)\n            return class_name + \".\" + extensions[i];\n        if(strength < 0 && strength > -1)\n            return class_name + \".\" + extensions[i];\n        if(strength > 0 && strength < 1)\n            return class_name + \".\" + extensions[i];\n    }\n    return class_name + \".\" + extensions[0];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292518,
      "stdout": "",
      "stderr": "/tmp/tmp9vg9oqh5.d(31): Error: no property `length` for type `string`\n/tmp/tmp9vg9oqh5.d(43): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmp9vg9oqh5.d(45): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmp9vg9oqh5.d(47): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmp9vg9oqh5.d(49): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9vg9oqh5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    string result = \"\";\n    for (int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (extensions[i] == class_name)\n            continue;\n        if (extensions[i] == class_name + \".\" + class_name)\n            continue;\n        if (extensions[i] == class_name + \".\" + class_name.substr(0, class_name.length() - 1))\n            continue;\n        if (extensions[i] == class_name.substr(0, class_name.length() - 1) + \".\" + class_name)\n            continue;\n        if (extensions[i] == class_name.substr(0, class_name.length() - 1) + \".\" + class_name.substr(0, class_name.length() - 1))\n            continue;\n        if (extensions[i] == class_name.substr(0, class_name.length() - 2) + \".\" + class_name)\n            continue;\n        if (extensions[i] == class_name.substr(0, class_name.length() - 2) + \".\" + class_name.substr(0, class_name.length() - 2))\n            continue;\n        if (extensions[i] == class_name.substr(0, class_name.length() - 3) + \".\" + class_name)\n            continue;\n        if (extensions[i] == class_name.substr(0, class_name.length() - 3) + \".\" + class_name.substr(0, class_name.length() -\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292518,
      "stdout": "",
      "stderr": "/tmp/tmpzzlgt9kd.d(60): Error: expression expected, not `unittest`\n/tmp/tmpzzlgt9kd.d(61): Error: found `{` when expecting `,`\n/tmp/tmpzzlgt9kd.d(62): Error: expression expected, not `alias`\n/tmp/tmpzzlgt9kd.d(62): Error: found `candidate` when expecting `,`\n/tmp/tmpzzlgt9kd.d(62): Error: expression expected, not `=`\n/tmp/tmpzzlgt9kd.d(62): Error: found `Strongest_Extension` when expecting `,`\n/tmp/tmpzzlgt9kd.d(62): Error: expression expected, not `;`\n/tmp/tmpzzlgt9kd.d(64): Error: found `assert` when expecting `,`\n/tmp/tmpzzlgt9kd.d(64): Error: found `;` when expecting `,`\n/tmp/tmpzzlgt9kd.d(65): Error: found `;` when expecting `,`\n/tmp/tmpzzlgt9kd.d(66): Error: found `;` when expecting `,`\n/tmp/tmpzzlgt9kd.d(67): Error: found `;` when expecting `,`\n/tmp/tmpzzlgt9kd.d(68): Error: found `;` when expecting `,`\n/tmp/tmpzzlgt9kd.d(69): Error: found `;` when expecting `,`\n/tmp/tmpzzlgt9kd.d(70): Error: found `;` when expecting `,`\n/tmp/tmpzzlgt9kd.d(71): Error: found `;` when expecting `,`\n/tmp/tmpzzlgt9kd.d(72)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    \n    for(int i = 0; i < extensions.length; i++)\n    {\n        if(extensions[i] == class_name)\n            continue;\n        if(extensions[i] == class_name + \".java\")\n            continue;\n        if(extensions[i] == class_name + \".class\")\n            continue;\n        if(extensions[i] == class_name + \".cpp\")\n            continue;\n        if(extensions[i] == class_name + \".h\")\n            continue;\n        if(extensions[i] == class_name + \".c\")\n            continue;\n        if(extensions[i] == class_name + \".py\")\n            continue;\n        if(extensions[i] == class_name + \".rb\")\n            continue;\n        if(extensions[i] == class_name + \".sh\")\n            continue;\n        if(extensions[i] == class_name + \".cs\")\n            continue;\n        if(extensions[i] == class_name + \".java\")\n            continue;\n        if(extensions[i] == class_name + \".scala\")\n            continue;\n        if(extensions[i] == class_name + \".groovy\")\n            continue;\n        if(extensions[i] == class_name + \".clj\")\n            continue;\n        if(extensions[i] == class_name + \".js\")\n            continue;\n        if(extensions[i] == class_name + \".ts\")\n            continue;\n        if(extensions[i] == class_name + \".tsx\")\n            continue;\n        if(ext\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292518,
      "stdout": "",
      "stderr": "/tmp/tmpvc4i2vc4.d(78): Error: found `unittest` when expecting `)`\n/tmp/tmpvc4i2vc4.d(92): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpvc4i2vc4.d(92): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvc4i2vc4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int CAP = 0, SM = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        CAP += count(extensions[i], 'A');\n        SM += count(extensions[i], 'a');\n    }\n    return class_name + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\" + extensions[0] + \".\"\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292518,
      "stdout": "",
      "stderr": "/tmp/tmp0evqhoed.d(31): Error: found `unittest` when expecting `;` following `return` statement\n/tmp/tmp0evqhoed.d(45): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0evqhoed.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int CAP = 0, SM = 0;\n    for (int i = 0; i < class_name.length(); i++)\n    {\n        if (class_name[i] >= 'A' && class_name[i] <= 'Z')\n            CAP++;\n        else\n            SM++;\n    }\n    \n    string result = class_name;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        CAP = 0;\n        SM = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] >= 'A' && extensions[i][j] <= 'Z')\n                CAP++;\n            else\n                SM++;\n        }\n        if (CAP - SM > result.length() - result.length() / 2)\n            result = class_name + \".\" + extensions[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292518,
      "stdout": "",
      "stderr": "/tmp/tmpny5_fn1w.d(25): Error: no property `length` for type `string`\n/tmp/tmpny5_fn1w.d(38): Error: no property `length` for type `string`\n/tmp/tmpny5_fn1w.d(45): Error: no property `length` for type `string`\n/tmp/tmpny5_fn1w.d(45): Error: no property `length` for type `string`\n/tmp/tmpny5_fn1w.d(46): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpny5_fn1w.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string strongest_extension = \"\";\n    for(int i = 0; i < extensions.length; i++)\n    {\n        int CAP = 0;\n        int SM = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                CAP++;\n            else\n                SM++;\n        }\n        strength += CAP - SM;\n        if(strength > strongest_extension.length())\n            strongest_extension = extensions[i];\n    }\n    return class_name + \".\" + strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "/tmp/tmppeugy_30.d(30): Error: no property `length` for type `string`\n/tmp/tmppeugy_30.d(38): Error: no property `length` for type `string`\n/tmp/tmppeugy_30.d(41): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppeugy_30.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int CAP, SM;\n    int strength = 0;\n    string extension = \"\";\n    \n    for(int i = 0; i < extensions.length; i++)\n    {\n        CAP = 0;\n        SM = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                CAP++;\n            else\n                SM++;\n        }\n        strength += CAP - SM;\n        if(strength > extension.length())\n            extension = extensions[i];\n    }\n    return class_name + \".\" + extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292518,
      "stdout": "",
      "stderr": "/tmp/tmpv_b9zbl_.d(32): Error: no property `length` for type `string`\n/tmp/tmpv_b9zbl_.d(40): Error: no property `length` for type `string`\n/tmp/tmpv_b9zbl_.d(43): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv_b9zbl_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        int c = 0;\n        int l = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                c++;\n            if(extensions[i][j] == 'a')\n                l++;\n        }\n        if(c > sm)\n            sm = c;\n        if(l > cap)\n            cap = l;\n        strength += c - l;\n    }\n    strength = strength / (cap - sm);\n    string result = class_name;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        if(strength == extensions[i].length())\n        {\n            result += \".\" + extensions[i];\n            break;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292518,
      "stdout": "",
      "stderr": "/tmp/tmp5az9xc5x.d(31): Error: no property `length` for type `string`\n/tmp/tmp5az9xc5x.d(48): Error: no property `length` for type `string`\n/tmp/tmp5az9xc5x.d(50): Error: invalid array operation `\".\" + extensions[cast(ulong)i]` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5az9xc5x.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int CAP, SM;\n    CAP = SM = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        CAP += count(extensions[i], 'A');\n        SM += count(extensions[i], 'a');\n    }\n    return class_name + \".\" + extensions[count_sort(extensions, SM, CAP)];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmp3uy_qp6t.d(28): Error: undefined identifier `count`\n/tmp/tmp3uy_qp6t.d(29): Error: undefined identifier `count`\n/tmp/tmp3uy_qp6t.d(31): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmp3uy_qp6t.d(31): Error: undefined identifier `count_sort`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3uy_qp6t.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int CAP, SM;\n    int strength = 0;\n    string str = class_name;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        CAP = 0;\n        SM = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                CAP++;\n            if (extensions[i][j] == 'a' || extensions[i][j] == 'A')\n                SM++;\n        }\n        strength += CAP - SM;\n    }\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (extensions[i] == class_name)\n            continue;\n        CAP = 0;\n        SM = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                CAP++;\n            if (extensions[i][j] == 'a' || extensions[i][j] == 'A')\n                SM++;\n        }\n        if (strength < CAP - SM)\n        {\n            str = class_name + \".\" + extensions[i];\n            strength = CAP - SM;\n        }\n    }\n    return str;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292518,
      "stdout": "",
      "stderr": "/tmp/tmpioa8s_um.d(31): Error: no property `length` for type `string`\n/tmp/tmpioa8s_um.d(46): Error: no property `length` for type `string`\n/tmp/tmpioa8s_um.d(55): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpioa8s_um.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int cap, sm;\n    string result;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] >= 'A' && extensions[i][j] <= 'Z')\n                cap++;\n            else\n                sm++;\n        }\n        if(cap - sm > result.length())\n            result = extensions[i];\n    }\n    return class_name + \".\" + result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292518,
      "stdout": "",
      "stderr": "/tmp/tmp62oldykq.d(30): Error: no property `length` for type `string`\n/tmp/tmp62oldykq.d(37): Error: no property `length` for type `string`\n/tmp/tmp62oldykq.d(40): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp62oldykq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        strength = 0;\n        cap = 0;\n        sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            if (extensions[i][j] == 'a' || extensions[i][j] == 'A')\n                sm++;\n        }\n        strength = cap - sm;\n        if (strength > strength)\n        {\n            strength = strength;\n            cap = cap;\n            sm = sm;\n        }\n    }\n    return class_name + \".\" + extensions[strength];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292518,
      "stdout": "",
      "stderr": "/tmp/tmp8wpnos7a.d(32): Error: no property `length` for type `string`\n/tmp/tmp8wpnos7a.d(47): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8wpnos7a.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string strongest_extension = \"\";\n    for(int i = 0; i < extensions.length; i++)\n    {\n        int cap = 0, sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            if(extensions[i][j] == 'a' || extensions[i][j] == 'A')\n                sm++;\n        }\n        strength += cap - sm;\n        if(strength > strongest_extension.length())\n            strongest_extension = extensions[i];\n    }\n    return class_name + \".\" + strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292518,
      "stdout": "",
      "stderr": "/tmp/tmp3vm4yo0m.d(29): Error: no property `length` for type `string`\n/tmp/tmp3vm4yo0m.d(37): Error: no property `length` for type `string`\n/tmp/tmp3vm4yo0m.d(40): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3vm4yo0m.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    string strongest_extension = \"\";\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int cap = 0;\n        int sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            if (extensions[i][j] == 'a' || extensions[i][j] == 'A')\n                sm++;\n        }\n        strength += cap - sm;\n        if (strength > strongest_extension.length())\n            strongest_extension = extensions[i];\n    }\n    return class_name + \".\" + strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpekzcdtds.d(30): Error: no property `length` for type `string`\n/tmp/tmpekzcdtds.d(38): Error: no property `length` for type `string`\n/tmp/tmpekzcdtds.d(41): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpekzcdtds.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        strength += cap - sm;\n    }\n    int max = 0;\n    string max_ext = \"\";\n    for(int i = 0; i < extensions.length; i++)\n    {\n        if(strength == max)\n        {\n            if(extensions[i] < max_ext)\n                max_ext = extensions[i];\n        }\n        else if(strength > max)\n        {\n            max = strength;\n            max_ext = extensions[i];\n        }\n    }\n    return class_name + \".\" + max_ext;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292518,
      "stdout": "",
      "stderr": "/tmp/tmpci4serjl.d(31): Error: no property `length` for type `string`\n/tmp/tmpci4serjl.d(55): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpci4serjl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int cap, sm;\n    string ret = class_name;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        if(cap - sm > ret.length())\n            ret = class_name + \".\" + extensions[i];\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292518,
      "stdout": "",
      "stderr": "/tmp/tmp_h0twzwc.d(30): Error: no property `length` for type `string`\n/tmp/tmp_h0twzwc.d(37): Error: no property `length` for type `string`\n/tmp/tmp_h0twzwc.d(38): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_h0twzwc.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int cap, sm;\n    string result;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for(int j = 0; j < extensions[i].length(); j++)\n        {\n            if(extensions[i][j] == 'A' || extensions[i][j] == 'a')\n                cap++;\n            else\n                sm++;\n        }\n        if(cap - sm > result.length())\n            result = extensions[i];\n    }\n    return class_name + \".\" + result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "/tmp/tmpegyublei.d(30): Error: no property `length` for type `string`\n/tmp/tmpegyublei.d(37): Error: no property `length` for type `string`\n/tmp/tmpegyublei.d(40): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpegyublei.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] == 'A' || extensions[i][j] == 'a')\n            {\n                cap++;\n            }\n            else\n            {\n                sm++;\n            }\n        }\n        strength += cap - sm;\n    }\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (extensions[i] == class_name)\n        {\n            return class_name + \".\" + extensions[i];\n        }\n    }\n    return class_name + \".\" + extensions[0];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292517,
      "stdout": "",
      "stderr": "/tmp/tmpf7nn1q2w.d(31): Error: no property `length` for type `string`\n/tmp/tmpf7nn1q2w.d(48): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpf7nn1q2w.d(51): Error: invalid array operation `class_name + \".\"` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf7nn1q2w.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        string extension = extensions[i];\n        cap = count_uppercase(extension);\n        sm = count_lowercase(extension);\n        strength += cap - sm;\n    }\n    string result = class_name + \".\" + extensions[0];\n    for (int i = 1; i < extensions.length; i++)\n    {\n        if (strength == extensions[i].length())\n        {\n            if (extensions[i] < result)\n            {\n                result = extensions[i];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292518,
      "stdout": "",
      "stderr": "/tmp/tmpyag2dmty.d(30): Error: undefined identifier `count_uppercase`\n/tmp/tmpyag2dmty.d(31): Error: undefined identifier `count_lowercase`\n/tmp/tmpyag2dmty.d(34): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmpyag2dmty.d(37): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyag2dmty.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of a class (a string) and an array of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the array.\n    For example, if you are given \"Slices\" as the class and an array of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name, string[] extensions) \n{\n    int strength = 0;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        cap = 0;\n        sm = 0;\n        for (int j = 0; j < extensions[i].length(); j++)\n        {\n            if (extensions[i][j] >= 'A' && extensions[i][j] <= 'Z')\n            {\n                cap++;\n            }\n            else if (extensions[i][j] >= 'a' && extensions[i][j] <= 'z')\n            {\n                sm++;\n            }\n        }\n        strength += (cap - sm);\n    }\n    string result = class_name + \".\";\n    for (int i = 0; i < extensions.length; i++)\n    {\n        if (strength == extensions[i].length())\n        {\n            result += extensions[i];\n            return result;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}",
      "timestamp": 1664292518,
      "stdout": "",
      "stderr": "/tmp/tmp2pr7zxdq.d(31): Error: no property `length` for type `string`\n/tmp/tmp2pr7zxdq.d(44): Error: invalid array operation `class_name + \".\"` (possible missing [])\n/tmp/tmp2pr7zxdq.d(47): Error: no property `length` for type `string`\n/tmp/tmp2pr7zxdq.d(49): Error: slice `result` is not mutable\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2pr7zxdq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}