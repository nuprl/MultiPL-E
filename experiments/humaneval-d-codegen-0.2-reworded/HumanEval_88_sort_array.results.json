{
  "name": "HumanEval_88_sort_array",
  "language": "d",
  "prompt": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n",
  "tests": "unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "results": [
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = array.clone();\n    if(array.length == 0)\n        return sorted_array;\n    \n    long sum = 0;\n    for(int i = 0; i < array.length; i++)\n        sum += array[i];\n    \n    if(sum % 2 == 0)\n        sort_array_descending(sorted_array);\n    else\n        sort_array_ascending(sorted_array);\n    \n    return sorted_array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmp8j0jebr8.d(24): Error: no property `clone` for type `long[]`\n/tmp/tmp8j0jebr8.d(33): Error: undefined identifier `sort_array_descending`\n/tmp/tmp8j0jebr8.d(35): Error: undefined identifier `sort_array_ascending`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8j0jebr8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = new long[array.length];\n    int i = 0;\n    int j = 0;\n    long sum = 0;\n    while (i < array.length) {\n        sum = array[i] + array[array.length - 1 - i];\n        if (sum % 2 == 1) {\n            sorted_array[j++] = array[i++];\n        } else {\n            sorted_array[array.length - 1 - j++] = array[i++];\n        }\n    }\n    return sorted_array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpm48surit.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x428725]\n??:? void tmpm48surit.__unittest_L39_C1() [0x428126]\n??:? void tmpm48surit.__modtest() [0x4284a4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c7df]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b672]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308fd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430dac]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430889]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b649]\n??:? runModuleUnitTests [0x42c5b5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428be8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        sort_array_ascending(array);\n    } else {\n        sort_array_descending(array);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmp7g1beil_.d(29): Error: undefined identifier `sort_array_ascending`\n/tmp/tmp7g1beil_.d(31): Error: undefined identifier `sort_array_descending`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7g1beil_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = new long[array.length];\n    int i = 0;\n    int j = 0;\n    long sum = 0;\n    for (i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        for (i = 0; i < array.length; i++) {\n            sorted_array[i] = array[i];\n        }\n        for (i = 0; i < array.length; i++) {\n            for (j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    } else {\n        for (i = 0; i < array.length; i++) {\n            sorted_array[i] = array[i];\n        }\n        for (i = 0; i < array.length; i++) {\n            for (j = i + 1; j < array.length; j++) {\n                if (array[i] < array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    }\n    return sorted_array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp34pxlqim.d(67): unittest failure\n----------------\n??:? _d_unittestp [0x428955]\n??:? void tmp34pxlqim.__unittest_L61_C1() [0x428356]\n??:? void tmp34pxlqim.__modtest() [0x4286d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca0f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b2d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fdc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ab9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b879]\n??:? runModuleUnitTests [0x42c7e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e18]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = new long[array.length];\n    for(int i = 0; i < array.length; i++)\n    {\n        sorted_array[i] = array[i];\n    }\n    \n    if(array.length == 1)\n    {\n        return sorted_array;\n    }\n    \n    long sum = 0;\n    for(int i = 0; i < array.length; i++)\n    {\n        sum += array[i];\n    }\n    \n    if(sum % 2 == 1)\n    {\n        for(int i = 0; i < array.length; i++)\n        {\n            for(int j = 0; j < array.length - 1; j++)\n            {\n                if(array[j] > array[j + 1])\n                {\n                    long temp = array[j];\n                    array[j] = array[j + 1];\n                    array[j + 1] = temp;\n                }\n            }\n        }\n    }\n    else\n    {\n        for(int i = 0; i < array.length; i++)\n        {\n            for(int j = 0; j < array.length - 1; j++)\n            {\n                if(array[j] > array[j + 1])\n                {\n                    long temp = array[j];\n                    array[j] = array[j + 1];\n                    array[j + 1] = temp;\n                }\n            }\n        }\n    }\n    \n    return sorted_array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpvvzmo2cr.d(81): unittest failure\n----------------\n??:? _d_unittestp [0x428905]\n??:? void tmpvvzmo2cr.__unittest_L75_C1() [0x428306]\n??:? void tmpvvzmo2cr.__modtest() [0x428684]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9bf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b852]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430add]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f8c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a69]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b829]\n??:? runModuleUnitTests [0x42c795]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428dc8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for(int i = 0; i < array.length; i++)\n        sum += array[i];\n    if(sum % 2 == 1)\n        sort_array_ascending(array);\n    else\n        sort_array_descending(array);\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpzeslto0_.d(28): Error: undefined identifier `sort_array_ascending`\n/tmp/tmpzeslto0_.d(30): Error: undefined identifier `sort_array_descending`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzeslto0_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        return sort_array_asc(array);\n    } else {\n        return sort_array_desc(array);\n    }\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpalpr4qht.d(29): Error: undefined identifier `sort_array_asc`\n/tmp/tmpalpr4qht.d(31): Error: undefined identifier `sort_array_desc`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpalpr4qht.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = array.clone();\n    if (array.length == 0) return sorted_array;\n    \n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    \n    if (sum % 2 == 0) {\n        sort_array_descending(sorted_array);\n    } else {\n        sort_array_ascending(sorted_array);\n    }\n    \n    return sorted_array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmple7j8x1i.d(24): Error: no property `clone` for type `long[]`\n/tmp/tmple7j8x1i.d(33): Error: undefined identifier `sort_array_descending`\n/tmp/tmple7j8x1i.d(35): Error: undefined identifier `sort_array_ascending`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmple7j8x1i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted = new long[array.length];\n    int i = 0;\n    int j = 0;\n    int sum = 0;\n    while(i < array.length)\n    {\n        sum += array[i];\n        i++;\n    }\n    if(sum % 2 == 1)\n    {\n        for(i = 0; i < array.length; i++)\n        {\n            sorted[j] = array[i];\n            j++;\n        }\n    }\n    else\n    {\n        for(i = array.length - 1; i >= 0; i--)\n        {\n            sorted[j] = array[i];\n            j++;\n        }\n    }\n    return sorted;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpkxfm6pxi.d(43): Error: cannot implicitly convert expression `array.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkxfm6pxi.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for(int i = 0; i < array.length; i++)\n        sum += array[i];\n    if(sum % 2 == 1)\n        sort(array, 0, array.length - 1);\n    else\n        sort(array, 0, array.length - 1, true);\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpmw1h5hgo.d(28): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpmw1h5hgo.d(30): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmw1h5hgo.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if(array.length == 0)\n        return array;\n    \n    long sum = 0;\n    for(int i = 0; i < array.length; i++)\n        sum += array[i];\n    \n    if(sum % 2 == 1)\n        return sort_array_ascending(array);\n    else\n        return sort_array_descending(array);\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpeb2_2fb8.d(32): Error: undefined identifier `sort_array_ascending`\n/tmp/tmpeb2_2fb8.d(34): Error: undefined identifier `sort_array_descending`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeb2_2fb8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length == 0)\n        return array;\n    \n    long[] sorted = new long[array.length];\n    \n    for (int i = 0; i < array.length; i++) {\n        sorted[i] = array[i];\n    }\n    \n    int start = 0;\n    int end = array.length - 1;\n    \n    while (start < end) {\n        if (sum(sorted[start], sorted[end]) % 2 == 1) {\n            long temp = sorted[start];\n            sorted[start] = sorted[end];\n            sorted[end] = temp;\n            start++;\n            end--;\n        } else {\n            start++;\n            end--;\n        }\n    }\n    \n    return sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpu_tsvn9e.d(34): Error: cannot implicitly convert expression `array.length - 1LU` of type `ulong` to `int`\n/tmp/tmpu_tsvn9e.d(37): Error: undefined identifier `sum`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu_tsvn9e.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        sort(array);\n    } else {\n        sort(array, true);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpzjif39gu.d(29): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpzjif39gu.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzjif39gu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = new long[array.length];\n    int start = 0;\n    int end = array.length - 1;\n    while (start < end) {\n        if (array[start] + array[end] == 0) {\n            sorted_array[start] = array[start];\n            sorted_array[end] = array[end];\n            start++;\n            end--;\n        } else if (array[start] + array[end] % 2 == 1) {\n            sorted_array[start] = array[start];\n            sorted_array[end] = array[end];\n            start++;\n            end--;\n        } else {\n            sorted_array[start] = array[end];\n            sorted_array[end] = array[start];\n            start++;\n            end--;\n        }\n    }\n    if (start == end) {\n        sorted_array[start] = array[start];\n    }\n    return sorted_array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpf22bf3hk.d(26): Error: cannot implicitly convert expression `array.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf22bf3hk.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length == 0) return array;\n    \n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    \n    if (sum % 2 == 1) {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    } else {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    }\n    \n    return array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpvyh_f76i.d(63): unittest failure\n----------------\n??:? _d_unittestp [0x428885]\n??:? void tmpvyh_f76i.__unittest_L56_C1() [0x42835e]\n??:? void tmpvyh_f76i.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8e3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b776]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430909]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430db8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430895]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b74d]\n??:? runModuleUnitTests [0x42c6b9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d48]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if(array.length == 0)\n        return array;\n    long sum = 0;\n    for(int i = 0; i < array.length; i++)\n        sum += array[i];\n    if(sum % 2 == 1)\n        return sort_array_ascending(array);\n    else\n        return sort_array_descending(array);\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpkv815ytu.d(30): Error: undefined identifier `sort_array_ascending`\n/tmp/tmpkv815ytu.d(32): Error: undefined identifier `sort_array_descending`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkv815ytu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length == 0) return array;\n    \n    long sum = 0;\n    for (int i = 0; i < array.length; i++)\n        sum += array[i];\n    \n    if (sum % 2 == 1)\n        sort_array_ascending(array);\n    else\n        sort_array_descending(array);\n    \n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpj1upjkpx.d(31): Error: undefined identifier `sort_array_ascending`\n/tmp/tmpj1upjkpx.d(33): Error: undefined identifier `sort_array_descending`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj1upjkpx.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted = new long[array.length];\n    int i = 0;\n    int j = 0;\n    long sum = 0;\n    while(i < array.length)\n    {\n        sum += array[i];\n        i++;\n    }\n    if(sum % 2 == 1)\n    {\n        for(i = 0; i < array.length; i++)\n        {\n            sorted[j] = array[i];\n            j++;\n        }\n    }\n    else\n    {\n        for(i = array.length - 1; i >= 0; i--)\n        {\n            sorted[j] = array[i];\n            j++;\n        }\n    }\n    return sorted;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpyw3_nhw4.d(43): Error: cannot implicitly convert expression `array.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyw3_nhw4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length == 0) return array;\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    } else {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    }\n    return array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp4x5vy8di.d(60): unittest failure\n----------------\n??:? _d_unittestp [0x428885]\n??:? void tmp4x5vy8di.__unittest_L53_C1() [0x42835e]\n??:? void tmp4x5vy8di.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8e3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b776]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430909]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430db8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430895]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b74d]\n??:? runModuleUnitTests [0x42c6b9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d48]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        sort(array, 0, array.length - 1);\n    } else {\n        sort(array, 0, array.length - 1, true);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpdtcfp4jd.d(29): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpdtcfp4jd.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdtcfp4jd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 0) {\n        return sort_array_descending(array);\n    } else {\n        return sort_array_ascending(array);\n    }\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmp3xw2scfg.d(29): Error: undefined identifier `sort_array_descending`\n/tmp/tmp3xw2scfg.d(31): Error: undefined identifier `sort_array_ascending`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3xw2scfg.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = array.clone();\n    if(array.length == 0)\n        return sorted_array;\n    \n    long sum = 0;\n    for(int i = 0; i < array.length; i++)\n        sum += array[i];\n    \n    if(sum % 2 == 1)\n        sort_array_ascending(sorted_array);\n    else\n        sort_array_descending(sorted_array);\n    \n    return sorted_array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmps926atnu.d(24): Error: no property `clone` for type `long[]`\n/tmp/tmps926atnu.d(33): Error: undefined identifier `sort_array_ascending`\n/tmp/tmps926atnu.d(35): Error: undefined identifier `sort_array_descending`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps926atnu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 0) {\n        sort_array_descending(array);\n    } else {\n        sort_array_ascending(array);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmprwybgz1s.d(29): Error: undefined identifier `sort_array_descending`\n/tmp/tmprwybgz1s.d(31): Error: undefined identifier `sort_array_ascending`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprwybgz1s.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = array.clone();\n    int len = array.length;\n    if (len == 0) return sorted_array;\n    \n    long sum = 0;\n    for (int i = 0; i < len; i++) {\n        sum += sorted_array[i];\n    }\n    \n    if (sum % 2 == 0) {\n        for (int i = 0; i < len; i++) {\n            sorted_array[i] = sorted_array[i] * -1;\n        }\n    }\n    \n    sort(sorted_array);\n    return sorted_array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmproxq21n1.d(24): Error: no property `clone` for type `long[]`\n/tmp/tmproxq21n1.d(25): Error: cannot implicitly convert expression `array.length` of type `ulong` to `int`\n/tmp/tmproxq21n1.d(39): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmproxq21n1.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for(int i = 0; i < array.length; i++)\n        sum += array[i];\n    if(sum % 2 == 1)\n        sort_array_ascending(array);\n    else\n        sort_array_descending(array);\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpzeslto0_.d(28): Error: undefined identifier `sort_array_ascending`\n/tmp/tmpzeslto0_.d(30): Error: undefined identifier `sort_array_descending`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzeslto0_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length == 0) return array;\n    \n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    \n    if (sum % 2 == 0) {\n        sort_array_descending(array);\n    } else {\n        sort_array_ascending(array);\n    }\n    \n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmp4p244lx_.d(32): Error: undefined identifier `sort_array_descending`\n/tmp/tmp4p244lx_.d(34): Error: undefined identifier `sort_array_ascending`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4p244lx_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = new long[array.length];\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    long sum = 0;\n    while(i < array.length)\n    {\n        sum = array[i] + array[array.length - 1 - i];\n        if(sum % 2 == 1)\n        {\n            for(j = i; j < array.length - 1 - i; j++)\n            {\n                if(array[j] > array[j + 1])\n                {\n                    long temp = array[j];\n                    array[j] = array[j + 1];\n                    array[j + 1] = temp;\n                }\n            }\n        }\n        else\n        {\n            for(k = i; k < array.length - 1 - i; k++)\n            {\n                if(array[k] > array[k + 1])\n                {\n                    long temp = array[k];\n                    array[k] = array[k + 1];\n                    array[k + 1] = temp;\n                }\n            }\n        }\n        sorted_array[i] = array[i];\n        i++;\n    }\n    return sorted_array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpuuvqphta.d(68): unittest failure\n----------------\n??:? _d_unittestp [0x4288dd]\n??:? void tmpuuvqphta.__unittest_L62_C1() [0x4282e2]\n??:? void tmpuuvqphta.__modtest() [0x428660]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c997]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b82a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ab5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f64]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a41]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b801]\n??:? runModuleUnitTests [0x42c76d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428da0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        sort_array_ascending(array);\n    } else {\n        sort_array_descending(array);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmp7g1beil_.d(29): Error: undefined identifier `sort_array_ascending`\n/tmp/tmp7g1beil_.d(31): Error: undefined identifier `sort_array_descending`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7g1beil_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length == 0) return array;\n    \n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    \n    if (sum % 2 == 0) {\n        sort_array_descending(array);\n    } else {\n        sort_array_ascending(array);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpfsfnn1re.d(32): Error: undefined identifier `sort_array_descending`\n/tmp/tmpfsfnn1re.d(34): Error: undefined identifier `sort_array_ascending`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfsfnn1re.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length == 0) return array;\n    \n    long[] sorted = new long[array.length];\n    \n    for (int i = 0; i < array.length; i++)\n    {\n        sorted[i] = array[i];\n    }\n    \n    sort(sorted);\n    \n    if (sum(sorted) % 2 == 0)\n    {\n        for (int i = 0; i < sorted.length; i++)\n        {\n            sorted[i] = -sorted[i];\n        }\n    }\n    \n    return sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpaecm4z0u.d(33): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpaecm4z0u.d(35): Error: undefined identifier `sum`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpaecm4z0u.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = new long[array.length];\n    int i = 0;\n    int j = 0;\n    long sum = 0;\n    while(i < array.length)\n    {\n        sum += array[i];\n        i++;\n    }\n    if(sum % 2 == 1)\n    {\n        for(i = 0; i < array.length; i++)\n        {\n            sorted_array[i] = array[i];\n        }\n        for(i = 0; i < array.length; i++)\n        {\n            for(j = i + 1; j < array.length; j++)\n            {\n                if(sorted_array[i] > sorted_array[j])\n                {\n                    long temp = sorted_array[i];\n                    sorted_array[i] = sorted_array[j];\n                    sorted_array[j] = temp;\n                }\n            }\n        }\n    }\n    else\n    {\n        for(i = 0; i < array.length; i++)\n        {\n            sorted_array[i] = array[i];\n        }\n        for(i = 0; i < array.length; i++)\n        {\n            for(j = i + 1; j < array.length; j++)\n            {\n                if(sorted_array[i] > sorted_array[j])\n                {\n                    long temp = sorted_array[i];\n                    sorted_array[i] = sorted_array[j];\n                    sorted_array[j] = temp;\n                }\n            }\n        }\n    }\n    return sorted_array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpmt7u_ggy.d(81): unittest failure\n----------------\n??:? _d_unittestp [0x42894d]\n??:? void tmpmt7u_ggy.__unittest_L74_C1() [0x428426]\n??:? void tmpmt7u_ggy.__modtest() [0x4286d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca07]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b89a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b25]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fd4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ab1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b871]\n??:? runModuleUnitTests [0x42c7dd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e10]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length == 0) return array;\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    } else {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    }\n    return array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp4x5vy8di.d(60): unittest failure\n----------------\n??:? _d_unittestp [0x428885]\n??:? void tmp4x5vy8di.__unittest_L53_C1() [0x42835e]\n??:? void tmp4x5vy8di.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8e3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b776]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430909]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430db8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430895]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b74d]\n??:? runModuleUnitTests [0x42c6b9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d48]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        sort(array, 0, array.length - 1);\n    } else {\n        sort(array, 0, array.length - 1, true);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpdtcfp4jd.d(29): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpdtcfp4jd.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdtcfp4jd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length == 0) return array;\n    \n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    \n    if (sum % 2 == 1) {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    } else {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    }\n    return array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp33l66yo_.d(62): unittest failure\n----------------\n??:? _d_unittestp [0x428885]\n??:? void tmp33l66yo_.__unittest_L55_C1() [0x42835e]\n??:? void tmp33l66yo_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8e3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b776]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430909]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430db8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430895]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b74d]\n??:? runModuleUnitTests [0x42c6b9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d48]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    } else {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    }\n    return array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpt7cs4pq8.d(59): unittest failure\n----------------\n??:? _d_unittestp [0x42886d]\n??:? void tmpt7cs4pq8.__unittest_L52_C1() [0x428346]\n??:? void tmpt7cs4pq8.__modtest() [0x4285f0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8cb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b75e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308f1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430da0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43087d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b735]\n??:? runModuleUnitTests [0x42c6a1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d30]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = new long[array.length];\n    for (int i = 0; i < array.length; i++) {\n        sorted_array[i] = array[i];\n    }\n    \n    if (sorted_array.length == 1) {\n        return sorted_array;\n    }\n    \n    if (sorted_array.length == 2) {\n        if (sorted_array[0] + sorted_array[1] == 0) {\n            return sorted_array;\n        } else if (sorted_array[0] + sorted_array[1] == 1) {\n            return sorted_array;\n        } else {\n            return sorted_array;\n        }\n    }\n    \n    if (sorted_array.length == 3) {\n        if (sorted_array[0] + sorted_array[1] + sorted_array[2] == 0) {\n            return sorted_array;\n        } else if (sorted_array[0] + sorted_array[1] + sorted_array[2] == 1) {\n            return sorted_array;\n        } else if (sorted_array[0] + sorted_array[1] + sorted_array[2] == 2) {\n            return sorted_array;\n        } else {\n            return sorted_array;\n        }\n    }\n    \n    if (sorted_array.length == 4) {\n        if (sorted_array[0] + sorted_array[1] + sorted_array[2] + sorted_array[3] == 0) {\n            return sorted_array;\n        } else if (sorted_array[0] + sorted_array[1] + sorted_array[2] + sorted_array[3] == 1) {\n            return sorted_array;\n        } else if (sorted_array[0] + sorted_array[1] + sorted_array[2] + sorted_array[3] == 2) {\n            return sorted_array;\n        } else if (sorted_array[0] + sorted_array[1] + sorted_array[2] + sorted_array[3] == 3) {\n            return sorted_array;\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpfx2dr_fm.d(65): Error: found `unittest` instead of statement\n/tmp/tmpfx2dr_fm.d(77): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpfx2dr_fm.d(77): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfx2dr_fm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length == 0)\n        return array;\n    \n    long sum = 0;\n    for (int i = 0; i < array.length; i++)\n        sum += array[i];\n    \n    if (sum % 2 == 1)\n        return sort_array_descending(array);\n    else\n        return sort_array_ascending(array);\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpknojqu9i.d(32): Error: undefined identifier `sort_array_descending`\n/tmp/tmpknojqu9i.d(34): Error: undefined identifier `sort_array_ascending`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpknojqu9i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = new long[array.length];\n    for (int i = 0; i < array.length; i++) {\n        sorted_array[i] = array[i];\n    }\n    \n    if (array.length == 1) {\n        return sorted_array;\n    }\n    \n    if (array.length == 2) {\n        if (array[0] + array[1] == 0) {\n            return sorted_array;\n        } else if (array[0] + array[1] == 1) {\n            return sorted_array;\n        } else if (array[0] + array[1] == 2) {\n            return sorted_array;\n        } else if (array[0] + array[1] == 3) {\n            return sorted_array;\n        } else if (array[0] + array[1] == 4) {\n            return sorted_array;\n        } else if (array[0] + array[1] == 5) {\n            return sorted_array;\n        } else if (array[0] + array[1] == 6) {\n            return sorted_array;\n        } else if (array[0] + array[1] == 7) {\n            return sorted_array;\n        } else if (array[0] + array[1] == 8) {\n            return sorted_array;\n        } else if (array[0] + array[1] == 9) {\n            return sorted_array;\n        } else if (array[0] + array[1] == 10) {\n            return sorted_array;\n        } else if (array[0] + array[1] == 11) {\n            return sorted_array;\n        } else if (array[0] + array[1] == 12) {\n            return sorted_array;\n        } else if (array[0] + array[1] == 13) {\n            return sorted_array;\n        } else if (array[0] + array[1] == 14) {\n            return sorted_array;\n        } else if (array[0] + array[1] == 15) {\n            return sorted_array;\n        } else if (array[0] +\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpd61t_ljg.d(67): Error: expression expected, not `unittest`\n/tmp/tmpd61t_ljg.d(68): Error: found `{` when expecting `)`\n/tmp/tmpd61t_ljg.d(79): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd61t_ljg.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        return sort_array_ascending(array);\n    } else {\n        return sort_array_descending(array);\n    }\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpdfgah4bn.d(29): Error: undefined identifier `sort_array_ascending`\n/tmp/tmpdfgah4bn.d(31): Error: undefined identifier `sort_array_descending`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdfgah4bn.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 0) {\n        return array;\n    }\n    else {\n        return array.sort(Long::compare);\n    }\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpaysorcg2.d(32): Error: found `:` when expecting `,`\n/tmp/tmpaysorcg2.d(32): Error: expression expected, not `:`\n/tmp/tmpaysorcg2.d(32): Error: found `compare` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpaysorcg2.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = new long[array.length];\n    \n    for (int i = 0; i < array.length; i++) {\n        sorted_array[i] = array[i];\n    }\n    \n    if (sorted_array.length == 1) {\n        return sorted_array;\n    }\n    \n    int sum = 0;\n    for (int i = 0; i < sorted_array.length; i++) {\n        sum += sorted_array[i];\n    }\n    \n    if (sum % 2 == 1) {\n        sort_array_helper(sorted_array, 0, sorted_array.length - 1);\n    } else {\n        sort_array_helper(sorted_array, 0, sorted_array.length - 1);\n    }\n    \n    return sorted_array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpv0i37ax7.d(40): Error: undefined identifier `sort_array_helper`\n/tmp/tmpv0i37ax7.d(42): Error: undefined identifier `sort_array_helper`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv0i37ax7.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = new long[array.length];\n    int index = 0;\n    for(int i = 0; i < array.length; i++)\n    {\n        if(i == 0 || array[i] > sorted_array[index - 1])\n        {\n            sorted_array[index] = array[i];\n            index++;\n        }\n    }\n    return sorted_array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp6rb00pcc.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x4286a5]\n??:? void tmp6rb00pcc.__unittest_L36_C1() [0x4280aa]\n??:? void tmp6rb00pcc.__modtest() [0x428428]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c75f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b5f2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43087d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d2c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430809]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5c9]\n??:? runModuleUnitTests [0x42c535]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b68]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        sort(array, 0, array.length - 1);\n    } else {\n        sort(array, 0, array.length - 1, true);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpdtcfp4jd.d(29): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpdtcfp4jd.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdtcfp4jd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = new long[array.length];\n    for (int i = 0; i < array.length; i++) {\n        sorted_array[i] = array[i];\n    }\n    \n    if (array.length == 1) {\n        return sorted_array;\n    }\n    \n    if (array.length == 2) {\n        if (array[0] + array[1] == 0) {\n            return sorted_array;\n        } else if (array[0] + array[1] == 1) {\n            return sorted_array;\n        } else {\n            return sorted_array;\n        }\n    }\n    \n    if (array.length == 3) {\n        if (array[0] + array[1] + array[2] == 0) {\n            return sorted_array;\n        } else if (array[0] + array[1] + array[2] == 1) {\n            return sorted_array;\n        } else if (array[0] + array[1] + array[2] == 2) {\n            return sorted_array;\n        } else {\n            return sorted_array;\n        }\n    }\n    \n    if (array.length == 4) {\n        if (array[0] + array[1] + array[2] + array[3] == 0) {\n            return sorted_array;\n        } else if (array[0] + array[1] + array[2] + array[3] == 1) {\n            return sorted_array;\n        } else if (array[0] + array[1] + array[2] + array[3] == 2) {\n            return sorted_array;\n        } else {\n            return sorted_array;\n        }\n    }\n    \n    if (array.length == 5) {\n        if (array[0] + array[1] + array[2] + array[3] + array[4] == 0) {\n            return sorted_array;\n        } else if (array[0] + array[1] + array[2] + array[3] + array[4] == 1) {\n            return sorted_array;\n        } else if\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpb7lgq15t.d(73): Error: found `unittest` when expecting `(`\n/tmp/tmpb7lgq15t.d(85): Error: found `void` when expecting `)`\n/tmp/tmpb7lgq15t.d(85): Error: found `{` when expecting `;` following statement\n/tmp/tmpb7lgq15t.d(85): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb7lgq15t.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    } else {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    }\n    return array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpt7cs4pq8.d(59): unittest failure\n----------------\n??:? _d_unittestp [0x42886d]\n??:? void tmpt7cs4pq8.__unittest_L52_C1() [0x428346]\n??:? void tmpt7cs4pq8.__modtest() [0x4285f0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8cb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b75e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308f1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430da0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43087d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b735]\n??:? runModuleUnitTests [0x42c6a1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d30]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = new long[array.length];\n    for(int i = 0; i < array.length; i++)\n    {\n        sorted_array[i] = array[i];\n    }\n    \n    if(sorted_array.length == 1)\n    {\n        return sorted_array;\n    }\n    \n    int start = 0;\n    int end = sorted_array.length - 1;\n    \n    while(start < end)\n    {\n        if(sorted_array[start] + sorted_array[end] == sorted_array.length)\n        {\n            long temp = sorted_array[start];\n            sorted_array[start] = sorted_array[end];\n            sorted_array[end] = temp;\n            \n            start++;\n            end--;\n        }\n        else if(sorted_array[start] + sorted_array[end] < sorted_array.length)\n        {\n            start++;\n        }\n        else\n        {\n            end--;\n        }\n    }\n    \n    return sorted_array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmprp527_50.d(36): Error: cannot implicitly convert expression `sorted_array.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprp527_50.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length == 0)\n        return array;\n    \n    long[] sorted = new long[array.length];\n    \n    for (int i = 0; i < array.length; i++)\n        sorted[i] = array[i];\n    \n    for (int i = 0; i < sorted.length - 1; i++)\n    {\n        for (int j = i + 1; j < sorted.length; j++)\n        {\n            if (sorted[i] + sorted[j] > sorted[i + 1] + sorted[j + 1])\n            {\n                long temp = sorted[i];\n                sorted[i] = sorted[i + 1];\n                sorted[i + 1] = temp;\n            }\n        }\n    }\n    \n    return sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpdhb3vqfb.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42887e]\n??:? long[] tmpdhb3vqfb.sort_array(long[]) [0x427f5f]\n??:? void tmpdhb3vqfb.__unittest_L47_C1() [0x428157]\n??:? void tmpdhb3vqfb.__modtest() [0x42854c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c887]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b71a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4309a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430e54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430931]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b6f1]\n??:? runModuleUnitTests [0x42c65d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(c",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = new long[array.length];\n    int i = 0;\n    int j = 0;\n    int sum = 0;\n    while (i < array.length) {\n        sum = array[i] + array[array.length - 1 - i];\n        if (sum % 2 == 1) {\n            for (j = 0; j < array.length; j++) {\n                if (array[j] > array[array.length - 1 - j]) {\n                    long temp = array[j];\n                    array[j] = array[array.length - 1 - j];\n                    array[array.length - 1 - j] = temp;\n                }\n            }\n        } else {\n            for (j = 0; j < array.length; j++) {\n                if (array[j] > array[array.length - 1 - j]) {\n                    long temp = array[j];\n                    array[j] = array[array.length - 1 - j];\n                    array[array.length - 1 - j] = temp;\n                }\n            }\n        }\n        i++;\n    }\n    return sorted_array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpo3hbjjcp.d(29): Error: cannot implicitly convert expression `array[cast(ulong)i] + array[array.length - 1LU - cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo3hbjjcp.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = new long[array.length];\n    int start = 0;\n    int end = array.length - 1;\n    int mid = 0;\n    while (start < end) {\n        mid = (start + end) / 2;\n        if (sum(array, start, mid) % 2 == 0) {\n            for (int i = start; i <= mid; i++) {\n                sorted_array[i] = array[i];\n            }\n            for (int i = mid + 1; i <= end; i++) {\n                sorted_array[i] = array[i];\n            }\n            end = mid - 1;\n        } else {\n            for (int i = start; i <= mid; i++) {\n                sorted_array[i] = array[i];\n            }\n            for (int i = mid + 1; i <= end; i++) {\n                sorted_array[i] = array[i];\n            }\n            start = mid + 1;\n        }\n    }\n    for (int i = 0; i < sorted_array.length; i++) {\n        array[i] = sorted_array[i];\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmp7o8cic4l.d(26): Error: cannot implicitly convert expression `array.length - 1LU` of type `ulong` to `int`\n/tmp/tmp7o8cic4l.d(30): Error: undefined identifier `sum`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7o8cic4l.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        sort(array, 0, array.length - 1);\n    } else {\n        sort(array, 0, array.length - 1, true);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpdtcfp4jd.d(29): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpdtcfp4jd.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdtcfp4jd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length == 0) return array;\n    \n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    \n    if (sum % 2 == 0) {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    } else {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    }\n    return array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpinliresq.d(62): unittest failure\n----------------\n??:? _d_unittestp [0x428885]\n??:? void tmpinliresq.__unittest_L55_C1() [0x42835e]\n??:? void tmpinliresq.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8e3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b776]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430909]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430db8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430895]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b74d]\n??:? runModuleUnitTests [0x42c6b9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d48]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length == 0) return array;\n    \n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    \n    if (sum % 2 == 0) {\n        sort_array_descending(array);\n    } else {\n        sort_array_ascending(array);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpfsfnn1re.d(32): Error: undefined identifier `sort_array_descending`\n/tmp/tmpfsfnn1re.d(34): Error: undefined identifier `sort_array_ascending`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfsfnn1re.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted = new long[array.length];\n    int i = 0;\n    int j = 0;\n    int sum = 0;\n    while(i < array.length)\n    {\n        sum += array[i];\n        i++;\n    }\n    if(sum % 2 == 1)\n    {\n        for(i = 0; i < array.length; i++)\n        {\n            sorted[i] = array[i];\n        }\n        for(i = 0; i < array.length; i++)\n        {\n            for(j = i + 1; j < array.length; j++)\n            {\n                if(sorted[i] > sorted[j])\n                {\n                    long temp = sorted[i];\n                    sorted[i] = sorted[j];\n                    sorted[j] = temp;\n                }\n            }\n        }\n    }\n    else\n    {\n        for(i = 0; i < array.length; i++)\n        {\n            sorted[i] = array[i];\n        }\n        for(i = 0; i < array.length; i++)\n        {\n            for(j = i + 1; j < array.length; j++)\n            {\n                if(sorted[i] > sorted[j])\n                {\n                    long temp = sorted[i];\n                    sorted[i] = sorted[j];\n                    sorted[j] = temp;\n                }\n            }\n        }\n    }\n    return sorted;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpl4w03jv4.d(81): unittest failure\n----------------\n??:? _d_unittestp [0x42894d]\n??:? void tmpl4w03jv4.__unittest_L74_C1() [0x428426]\n??:? void tmpl4w03jv4.__modtest() [0x4286d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca07]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b89a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b25]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fd4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ab1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b871]\n??:? runModuleUnitTests [0x42c7dd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e10]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] result = new long[array.length];\n    for (int i = 0; i < array.length; i++) {\n        result[i] = array[i];\n    }\n    \n    if (array.length == 1) {\n        return result;\n    }\n    \n    if (array.length == 2) {\n        if (array[0] + array[1] == 0) {\n            return result;\n        }\n        if (array[0] + array[1] == 1) {\n            return result;\n        }\n        if (array[0] + array[1] == 2) {\n            return result;\n        }\n        if (array[0] + array[1] == 3) {\n            return result;\n        }\n        if (array[0] + array[1] == 4) {\n            return result;\n        }\n        if (array[0] + array[1] == 5) {\n            return result;\n        }\n        if (array[0] + array[1] == 6) {\n            return result;\n        }\n        if (array[0] + array[1] == 7) {\n            return result;\n        }\n        if (array[0] + array[1] == 8) {\n            return result;\n        }\n        if (array[0] + array[1] == 9) {\n            return result;\n        }\n        if (array[0] + array[1] == 10) {\n            return result;\n        }\n        if (array[0] + array[1] == 11) {\n            return result;\n        }\n        if (array[0] + array[1] == 12) {\n            return result;\n        }\n        if (array[0] + array[1] == 13) {\n            return result;\n        }\n        if (array[0] + array[1] == 14) {\n            return result;\n        }\n        if (array[0] + array[1] == 15) {\n            return result;\n        }\n        if (array[0] + array[1] == 16) {\n            return result;\n        }\n        if (array[0\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmp5usnpb2q.d(86): Error: found `unittest` when expecting `,`\n/tmp/tmp5usnpb2q.d(98): Error: found `void` when expecting `,`\n/tmp/tmp5usnpb2q.d(98): Error: found `{` when expecting `,`\n/tmp/tmp5usnpb2q.d(98): Error: expression expected, not `}`\n/tmp/tmp5usnpb2q.d(98): Error: found `End of File` when expecting `,`\n/tmp/tmp5usnpb2q.d(98): Error: found `End of File` when expecting `]`\n/tmp/tmp5usnpb2q.d(98): Error: found `End of File` when expecting `)`\n/tmp/tmp5usnpb2q.d(98): Error: found `End of File` instead of statement\n/tmp/tmp5usnpb2q.d(98): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp5usnpb2q.d(98): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5usnpb2q.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if(array.length == 0)\n        return array;\n    \n    long sum = 0;\n    for(int i = 0; i < array.length; i++)\n        sum += array[i];\n    \n    if(sum % 2 == 1)\n        sort_array_helper(array, 0, array.length - 1);\n    else\n        sort_array_helper(array, 0, array.length - 1);\n    \n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpkd36p6q2.d(32): Error: undefined identifier `sort_array_helper`\n/tmp/tmpkd36p6q2.d(34): Error: undefined identifier `sort_array_helper`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkd36p6q2.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if(array.length == 0)\n        return array;\n    \n    long sum = 0;\n    for(int i = 0; i < array.length; i++)\n        sum += array[i];\n    \n    if(sum % 2 == 0)\n        sort_array_descending(array);\n    else\n        sort_array_ascending(array);\n    \n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpp897jfh_.d(32): Error: undefined identifier `sort_array_descending`\n/tmp/tmpp897jfh_.d(34): Error: undefined identifier `sort_array_ascending`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp897jfh_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted = new long[array.length];\n    int i = 0;\n    int j = 0;\n    int sum = 0;\n    while(i < array.length)\n    {\n        sum += array[i];\n        i++;\n    }\n    if(sum % 2 == 1)\n    {\n        for(i = 0; i < array.length; i++)\n        {\n            sorted[i] = array[i];\n        }\n        for(i = 0; i < array.length; i++)\n        {\n            for(j = i + 1; j < array.length; j++)\n            {\n                if(sorted[i] > sorted[j])\n                {\n                    long temp = sorted[i];\n                    sorted[i] = sorted[j];\n                    sorted[j] = temp;\n                }\n            }\n        }\n    }\n    else\n    {\n        for(i = 0; i < array.length; i++)\n        {\n            sorted[i] = array[i];\n        }\n        for(i = 0; i < array.length; i++)\n        {\n            for(j = i + 1; j < array.length; j++)\n            {\n                if(sorted[i] > sorted[j])\n                {\n                    long temp = sorted[i];\n                    sorted[i] = sorted[j];\n                    sorted[j] = temp;\n                }\n            }\n        }\n    }\n    return sorted;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpl4w03jv4.d(81): unittest failure\n----------------\n??:? _d_unittestp [0x42894d]\n??:? void tmpl4w03jv4.__unittest_L74_C1() [0x428426]\n??:? void tmpl4w03jv4.__modtest() [0x4286d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca07]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b89a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b25]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fd4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ab1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b871]\n??:? runModuleUnitTests [0x42c7dd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e10]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = new long[array.length];\n    int i = 0;\n    int j = 0;\n    int sum = 0;\n    while (i < array.length) {\n        sum = array[i] + array[array.length - 1 - i];\n        if (sum % 2 == 1) {\n            sorted_array[j] = array[i];\n            i++;\n        } else {\n            sorted_array[j] = array[array.length - 1 - i];\n            i++;\n        }\n        j++;\n    }\n    return sorted_array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpdy0op1lk.d(29): Error: cannot implicitly convert expression `array[cast(ulong)i] + array[array.length - 1LU - cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdy0op1lk.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    } else {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    }\n    return array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpt7cs4pq8.d(59): unittest failure\n----------------\n??:? _d_unittestp [0x42886d]\n??:? void tmpt7cs4pq8.__unittest_L52_C1() [0x428346]\n??:? void tmpt7cs4pq8.__modtest() [0x4285f0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8cb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b75e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308f1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430da0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43087d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b735]\n??:? runModuleUnitTests [0x42c6a1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d30]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length == 0) return array;\n    long[] sorted = new long[array.length];\n    int i = 0;\n    int j = 0;\n    int sum = 0;\n    while (i < array.length) {\n        sum += array[i];\n        i++;\n    }\n    if (sum % 2 == 1) {\n        for (i = 0; i < array.length; i++) {\n            sorted[i] = array[i];\n        }\n        for (i = 0; i < array.length; i++) {\n            for (j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    } else {\n        for (i = 0; i < array.length; i++) {\n            sorted[i] = array[i];\n        }\n        for (i = 0; i < array.length; i++) {\n            for (j = i + 1; j < array.length; j++) {\n                if (array[i] < array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    }\n    return sorted;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp0dzngdgb.d(69): unittest failure\n----------------\n??:? _d_unittestp [0x428965]\n??:? void tmp0dzngdgb.__unittest_L63_C1() [0x42836a]\n??:? void tmp0dzngdgb.__modtest() [0x4286e8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca1f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b3d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ac9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b889]\n??:? runModuleUnitTests [0x42c7f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e28]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        sort(array, 0, array.length - 1);\n    } else {\n        sort(array, 0, array.length - 1, true);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpdtcfp4jd.d(29): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpdtcfp4jd.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdtcfp4jd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 0) {\n        return array;\n    }\n    else {\n        return sort_array_helper(array);\n    }\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpwo33xai5.d(32): Error: undefined identifier `sort_array_helper`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwo33xai5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        return array;\n    } else {\n        return array.sort(Long::compare);\n    }\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmp634imsxf.d(31): Error: found `:` when expecting `,`\n/tmp/tmp634imsxf.d(31): Error: expression expected, not `:`\n/tmp/tmp634imsxf.d(31): Error: found `compare` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp634imsxf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if(array.length == 0)\n        return array;\n    \n    long sum = 0;\n    for(int i = 0; i < array.length; i++)\n        sum += array[i];\n    \n    if(sum % 2 == 0)\n        return sort_array_descending(array);\n    else\n        return sort_array_ascending(array);\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmp92mpqd88.d(32): Error: undefined identifier `sort_array_descending`\n/tmp/tmp92mpqd88.d(34): Error: undefined identifier `sort_array_ascending`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp92mpqd88.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        return sort_array_ascending(array);\n    } else {\n        return sort_array_descending(array);\n    }\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpdfgah4bn.d(29): Error: undefined identifier `sort_array_ascending`\n/tmp/tmpdfgah4bn.d(31): Error: undefined identifier `sort_array_descending`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdfgah4bn.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = new long[array.length];\n    int i = 0;\n    int j = 0;\n    int sum = 0;\n    while (i < array.length) {\n        sum += array[i];\n        i++;\n    }\n    if (sum % 2 == 1) {\n        for (i = 0; i < array.length; i++) {\n            sorted_array[i] = array[i];\n        }\n        for (i = 0; i < array.length; i++) {\n            for (j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    } else {\n        for (i = 0; i < array.length; i++) {\n            sorted_array[i] = array[i];\n        }\n        for (i = 0; i < array.length; i++) {\n            for (j = i + 1; j < array.length; j++) {\n                if (array[i] < array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    }\n    return sorted_array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpxshyid42.d(67): unittest failure\n----------------\n??:? _d_unittestp [0x42894d]\n??:? void tmpxshyid42.__unittest_L61_C1() [0x428352]\n??:? void tmpxshyid42.__modtest() [0x4286d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca07]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b89a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b25]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fd4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ab1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b871]\n??:? runModuleUnitTests [0x42c7dd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e10]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 0) {\n        for (int i = 0; i < array.length; i++) {\n            long temp = array[i];\n            array[i] = array[array.length - 1 - i];\n            array[array.length - 1 - i] = temp;\n        }\n    } else {\n        for (int i = 0; i < array.length; i++) {\n            long temp = array[i];\n            array[i] = array[array.length - 1 - i];\n            array[array.length - 1 - i] = temp;\n        }\n    }\n    return array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcjg3bdsf.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x428785]\n??:? void tmpcjg3bdsf.__unittest_L44_C1() [0x42818a]\n??:? void tmpcjg3bdsf.__modtest() [0x428508]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c7e3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b676]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430809]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430cb8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430795]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b64d]\n??:? runModuleUnitTests [0x42c5b9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428c48]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = array.clone();\n    if(array.length == 0) return sorted_array;\n    \n    long sum = 0;\n    for(int i = 0; i < array.length; i++)\n    {\n        sum += array[i];\n    }\n    if(sum % 2 == 1)\n    {\n        sort(sorted_array, 0, sorted_array.length - 1);\n    }\n    else\n    {\n        sort(sorted_array, 0, sorted_array.length - 1, true);\n    }\n    return sorted_array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpj86r5efa.d(24): Error: no property `clone` for type `long[]`\n/tmp/tmpj86r5efa.d(34): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpj86r5efa.d(38): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj86r5efa.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length == 0) return array;\n    \n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    \n    if (sum % 2 == 1) {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    } else {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    }\n    \n    return array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpvyh_f76i.d(63): unittest failure\n----------------\n??:? _d_unittestp [0x428885]\n??:? void tmpvyh_f76i.__unittest_L56_C1() [0x42835e]\n??:? void tmpvyh_f76i.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8e3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b776]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430909]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430db8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430895]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b74d]\n??:? runModuleUnitTests [0x42c6b9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d48]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        sort(array, 0, array.length - 1);\n    } else {\n        sort(array, 0, array.length - 1, false);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpxm7ukc4p.d(29): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpxm7ukc4p.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxm7ukc4p.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length == 0) return array;\n    \n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    \n    if (sum % 2 == 1) {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    } else {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    }\n    \n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgtcg9dg8.d(62): unittest failure\n----------------\n??:? _d_unittestp [0x428885]\n??:? void tmpgtcg9dg8.__unittest_L55_C1() [0x42835e]\n??:? void tmpgtcg9dg8.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8e3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b776]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430909]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430db8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430895]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b74d]\n??:? runModuleUnitTests [0x42c6b9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d48]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted = new long[array.length];\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    while(i < array.length)\n    {\n        if(array[i] > 0)\n        {\n            sorted[k] = array[i];\n            k++;\n        }\n        i++;\n    }\n    i = 0;\n    while(i < sorted.length)\n    {\n        if(sorted[i] > 0)\n        {\n            if(i % 2 == 0)\n            {\n                j = i + 1;\n                while(j < sorted.length)\n                {\n                    if(sorted[j] > 0)\n                    {\n                        if(sorted[i] + sorted[j] > sorted[i])\n                        {\n                            long temp = sorted[i];\n                            sorted[i] = sorted[j];\n                            sorted[j] = temp;\n                        }\n                        else\n                        {\n                            break;\n                        }\n                    }\n                    j++;\n                }\n            }\n            else\n            {\n                j = i + 1;\n                while(j < sorted.length)\n                {\n                    if(sorted[j] > 0)\n                    {\n                        if(sorted[i] + sorted[j] < sorted[i])\n                        {\n                            long temp = sorted[i];\n                            sorted[i] = sorted[j];\n                            sorted[j] = temp;\n                        }\n                        else\n                        {\n                            break;\n                        }\n                    }\n                    j++;\n                }\n            }\n        }\n        i++;\n    }\n    return sorted;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpfa5yr93i.d(96): unittest failure\n----------------\n??:? _d_unittestp [0x428985]\n??:? void tmpfa5yr93i.__unittest_L90_C1() [0x42838a]\n??:? void tmpfa5yr93i.__modtest() [0x428708]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca3f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43100c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ae9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b8a9]\n??:? runModuleUnitTests [0x42c815]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e48]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = new long[array.length];\n    int start = 0;\n    int end = array.length - 1;\n    int mid = 0;\n    int sum = 0;\n    while (start < end) {\n        mid = (start + end) / 2;\n        sum = 0;\n        for (int i = 0; i < mid; i++) {\n            sum += array[i];\n        }\n        if (sum % 2 == 1) {\n            for (int i = start; i <= mid; i++) {\n                sorted_array[i] = array[i];\n            }\n            for (int i = mid + 1; i <= end; i++) {\n                sorted_array[i] = array[i];\n            }\n            start = mid + 1;\n        } else {\n            for (int i = start; i <= mid; i++) {\n                sorted_array[i] = array[i];\n            }\n            for (int i = mid + 1; i <= end; i++) {\n                sorted_array[i] = array[i];\n            }\n            end = mid - 1;\n        }\n    }\n    return sorted_array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmp1e5ruobz.d(26): Error: cannot implicitly convert expression `array.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1e5ruobz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length == 0) return array;\n    \n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    \n    if (sum % 2 == 1) {\n        sort(array, 0, array.length - 1);\n    } else {\n        sort(array, 0, array.length - 1);\n        reverse(array, 0, array.length - 1);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpgeba70rc.d(32): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpgeba70rc.d(34): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpgeba70rc.d(35): Error: undefined identifier `reverse`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgeba70rc.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = new long[array.length];\n    int i = 0;\n    int j = 0;\n    long sum = 0;\n    while(i < array.length)\n    {\n        sum += array[i];\n        i++;\n    }\n    if(sum % 2 == 1)\n    {\n        for(i = 0; i < array.length; i++)\n        {\n            sorted_array[i] = array[i];\n        }\n        for(i = 0; i < array.length; i++)\n        {\n            for(j = i + 1; j < array.length; j++)\n            {\n                if(sorted_array[i] > sorted_array[j])\n                {\n                    long temp = sorted_array[i];\n                    sorted_array[i] = sorted_array[j];\n                    sorted_array[j] = temp;\n                }\n            }\n        }\n    }\n    else\n    {\n        for(i = 0; i < array.length; i++)\n        {\n            sorted_array[i] = array[i];\n        }\n        for(i = 0; i < array.length; i++)\n        {\n            for(j = i + 1; j < array.length; j++)\n            {\n                if(sorted_array[i] > sorted_array[j])\n                {\n                    long temp = sorted_array[i];\n                    sorted_array[i] = sorted_array[j];\n                    sorted_array[j] = temp;\n                }\n            }\n        }\n    }\n    return sorted_array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpmt7u_ggy.d(81): unittest failure\n----------------\n??:? _d_unittestp [0x42894d]\n??:? void tmpmt7u_ggy.__unittest_L74_C1() [0x428426]\n??:? void tmpmt7u_ggy.__modtest() [0x4286d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca07]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b89a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b25]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fd4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ab1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b871]\n??:? runModuleUnitTests [0x42c7dd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e10]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if(array.length == 0)\n        return array;\n    \n    long sum = 0;\n    for(int i = 0; i < array.length; i++)\n        sum += array[i];\n    \n    if(sum % 2 == 0)\n        sort_array_descending(array);\n    else\n        sort_array_ascending(array);\n    \n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpp897jfh_.d(32): Error: undefined identifier `sort_array_descending`\n/tmp/tmpp897jfh_.d(34): Error: undefined identifier `sort_array_ascending`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp897jfh_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        sort(array, 0, array.length - 1);\n    } else {\n        sort(array, 0, array.length - 1);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmp2olbbxyv.d(29): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmp2olbbxyv.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2olbbxyv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        return array;\n    }\n    else {\n        return array.sort(Long::compare);\n    }\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpb5sp9vvl.d(32): Error: found `:` when expecting `,`\n/tmp/tmpb5sp9vvl.d(32): Error: expression expected, not `:`\n/tmp/tmpb5sp9vvl.d(32): Error: found `compare` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb5sp9vvl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = new long[array.length];\n    int i = 0;\n    int j = 0;\n    int sum = 0;\n    while(i < array.length)\n    {\n        sum = array[i] + array[array.length - 1 - i];\n        if(sum % 2 == 1)\n        {\n            for(j = i; j < array.length - 1 - i; j++)\n            {\n                if(array[j] > array[j + 1])\n                {\n                    long temp = array[j];\n                    array[j] = array[j + 1];\n                    array[j + 1] = temp;\n                }\n            }\n        }\n        else\n        {\n            for(j = i; j < array.length - 1 - i; j++)\n            {\n                if(array[j] > array[j + 1])\n                {\n                    long temp = array[j];\n                    array[j] = array[j + 1];\n                    array[j + 1] = temp;\n                }\n            }\n        }\n        sorted_array[i] = array[i];\n        i++;\n    }\n    return sorted_array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpxgv0n08_.d(30): Error: cannot implicitly convert expression `array[cast(ulong)i] + array[array.length - 1LU - cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxgv0n08_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted = new long[array.length];\n    int i = 0;\n    int j = 0;\n    long sum = 0;\n    while(i < array.length)\n    {\n        sum += array[i];\n        i++;\n    }\n    if(sum % 2 == 1)\n    {\n        for(i = 0; i < array.length; i++)\n        {\n            sorted[j] = array[i];\n            j++;\n        }\n    }\n    else\n    {\n        for(i = array.length - 1; i >= 0; i--)\n        {\n            sorted[j] = array[i];\n            j++;\n        }\n    }\n    return sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpfu7cps08.d(43): Error: cannot implicitly convert expression `array.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfu7cps08.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        sort(array, 0, array.length - 1);\n    } else {\n        sort(array, 0, array.length - 1, true);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpdtcfp4jd.d(29): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpdtcfp4jd.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdtcfp4jd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length == 0) return array;\n    \n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    \n    if (sum % 2 == 1) {\n        sort(array, 0, array.length - 1);\n    } else {\n        sort(array, 0, array.length - 1);\n        reverse(array, 0, array.length - 1);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpgeba70rc.d(32): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpgeba70rc.d(34): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpgeba70rc.d(35): Error: undefined identifier `reverse`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgeba70rc.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        sort(array, 0, array.length - 1);\n    } else {\n        sort(array, 0, array.length - 1, true);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpdtcfp4jd.d(29): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpdtcfp4jd.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdtcfp4jd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = new long[array.length];\n    int i = 0;\n    int j = 0;\n    long sum = 0;\n    while(i < array.length)\n    {\n        sum += array[i];\n        i++;\n    }\n    if(sum % 2 == 1)\n    {\n        for(i = 0; i < array.length; i++)\n        {\n            sorted_array[i] = array[i];\n        }\n        for(i = 0; i < array.length; i++)\n        {\n            for(j = i + 1; j < array.length; j++)\n            {\n                if(sorted_array[i] > sorted_array[j])\n                {\n                    long temp = sorted_array[i];\n                    sorted_array[i] = sorted_array[j];\n                    sorted_array[j] = temp;\n                }\n            }\n        }\n    }\n    else\n    {\n        for(i = 0; i < array.length; i++)\n        {\n            sorted_array[i] = array[i];\n        }\n        for(i = 0; i < array.length; i++)\n        {\n            for(j = i + 1; j < array.length; j++)\n            {\n                if(sorted_array[i] > sorted_array[j])\n                {\n                    long temp = sorted_array[i];\n                    sorted_array[i] = sorted_array[j];\n                    sorted_array[j] = temp;\n                }\n            }\n        }\n    }\n    return sorted_array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpmt7u_ggy.d(81): unittest failure\n----------------\n??:? _d_unittestp [0x42894d]\n??:? void tmpmt7u_ggy.__unittest_L74_C1() [0x428426]\n??:? void tmpmt7u_ggy.__modtest() [0x4286d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca07]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b89a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b25]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fd4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ab1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b871]\n??:? runModuleUnitTests [0x42c7dd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e10]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = array.clone();\n    int length = sorted_array.length;\n    if (length == 0) return sorted_array;\n    \n    long sum = 0;\n    for (int i = 0; i < length; i++) {\n        sum += sorted_array[i];\n    }\n    \n    if (sum % 2 == 1) {\n        sort_array_ascending(sorted_array);\n    } else {\n        sort_array_descending(sorted_array);\n    }\n    return sorted_array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpxnhtzkg5.d(24): Error: no property `clone` for type `long[]`\n/tmp/tmpxnhtzkg5.d(25): Error: cannot implicitly convert expression `sorted_array.length` of type `ulong` to `int`\n/tmp/tmpxnhtzkg5.d(34): Error: undefined identifier `sort_array_ascending`\n/tmp/tmpxnhtzkg5.d(36): Error: undefined identifier `sort_array_descending`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxnhtzkg5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 0) {\n        return array;\n    }\n    else {\n        return array.sort(Long::compare);\n    }\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpaysorcg2.d(32): Error: found `:` when expecting `,`\n/tmp/tmpaysorcg2.d(32): Error: expression expected, not `:`\n/tmp/tmpaysorcg2.d(32): Error: found `compare` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpaysorcg2.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length == 0) return array;\n    \n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    \n    if (sum % 2 == 0) {\n        for (int i = 0; i < array.length; i++) {\n            array[i] = array[i] * -1;\n        }\n    }\n    \n    sort(array);\n    \n    return array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpeol58k7n.d(37): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeol58k7n.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length == 0) return array;\n    \n    long[] sorted = new long[array.length];\n    int i = 0;\n    int j = 0;\n    \n    while (i < array.length) {\n        if (i == 0 || array[i] < array[i-1]) {\n            sorted[j++] = array[i++];\n        } else {\n            i++;\n        }\n    }\n    \n    while (i < array.length) {\n        sorted[j++] = array[i++];\n    }\n    \n    return sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpdxpnrm4k.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x428725]\n??:? void tmpdxpnrm4k.__unittest_L44_C1() [0x42812a]\n??:? void tmpdxpnrm4k.__modtest() [0x4284a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c7df]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b672]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308fd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430dac]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430889]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b649]\n??:? runModuleUnitTests [0x42c5b5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428be8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if(array.length == 0)\n        return array;\n    \n    long[] sorted = new long[array.length];\n    int i = 0;\n    int j = 0;\n    int sum = 0;\n    \n    while(i < array.length)\n    {\n        sum += array[i];\n        i++;\n    }\n    \n    if(sum % 2 == 1)\n    {\n        for(j = 0; j < array.length; j++)\n        {\n            sorted[j] = array[j];\n        }\n    }\n    else\n    {\n        for(j = 0; j < array.length; j++)\n        {\n            sorted[j] = array[j];\n        }\n    }\n    \n    for(i = 0; i < array.length; i++)\n    {\n        for(j = 0; j < array.length - 1; j++)\n        {\n            if(sorted[j] > sorted[j+1])\n            {\n                long temp = sorted[j];\n                sorted[j] = sorted[j+1];\n                sorted[j+1] = temp;\n            }\n        }\n    }\n    \n    return sorted;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgs6vng_2.d(76): unittest failure\n----------------\n??:? _d_unittestp [0x42884d]\n??:? void tmpgs6vng_2.__unittest_L69_C1() [0x428326]\n??:? void tmpgs6vng_2.__modtest() [0x4285d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c907]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b79a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a25]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ed4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309b1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b771]\n??:? runModuleUnitTests [0x42c6dd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d10]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        sort(array, 0, array.length - 1);\n    } else {\n        sort(array, 0, array.length - 1, false);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpxm7ukc4p.d(29): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpxm7ukc4p.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxm7ukc4p.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length == 0) return array;\n    \n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    \n    if (sum % 2 == 1) {\n        sort(array, 0, array.length - 1);\n    } else {\n        sort(array, 0, array.length - 1);\n        reverse(array, 0, array.length - 1);\n    }\n    \n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpw50r_uhv.d(32): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpw50r_uhv.d(34): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpw50r_uhv.d(35): Error: undefined identifier `reverse`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw50r_uhv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for(int i = 0; i < array.length; i++)\n    {\n        sum += array[i];\n    }\n    if(sum % 2 == 1)\n    {\n        return array;\n    }\n    else\n    {\n        return array.sort(Long::compare);\n    }\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmphcdr8b4j.d(35): Error: found `:` when expecting `,`\n/tmp/tmphcdr8b4j.d(35): Error: expression expected, not `:`\n/tmp/tmphcdr8b4j.d(35): Error: found `compare` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphcdr8b4j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 0) {\n        sort_array_descending(array);\n    } else {\n        sort_array_ascending(array);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmprwybgz1s.d(29): Error: undefined identifier `sort_array_descending`\n/tmp/tmprwybgz1s.d(31): Error: undefined identifier `sort_array_ascending`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprwybgz1s.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        sort(array);\n    } else {\n        sort(array, true);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpzjif39gu.d(29): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpzjif39gu.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzjif39gu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        sort(array, 0, array.length - 1);\n    } else {\n        sort(array, 0, array.length - 1, true);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpdtcfp4jd.d(29): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpdtcfp4jd.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdtcfp4jd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        sort_array_ascending(array);\n    } else {\n        sort_array_descending(array);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmp7g1beil_.d(29): Error: undefined identifier `sort_array_ascending`\n/tmp/tmp7g1beil_.d(31): Error: undefined identifier `sort_array_descending`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7g1beil_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = array.clone();\n    if (sorted_array.length > 1) {\n        sort(sorted_array, 0, sorted_array.length - 1);\n    }\n    return sorted_array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpcc27ymau.d(24): Error: no property `clone` for type `long[]`\n/tmp/tmpcc27ymau.d(26): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcc27ymau.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length == 0) return array;\n    \n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    \n    if (sum % 2 == 1) {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    } else {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    }\n    \n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgtcg9dg8.d(62): unittest failure\n----------------\n??:? _d_unittestp [0x428885]\n??:? void tmpgtcg9dg8.__unittest_L55_C1() [0x42835e]\n??:? void tmpgtcg9dg8.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8e3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b776]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430909]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430db8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430895]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b74d]\n??:? runModuleUnitTests [0x42c6b9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d48]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for(int i = 0; i < array.length; i++)\n        sum += array[i];\n    if(sum % 2 == 1)\n        sort_array_ascending(array);\n    else\n        sort_array_descending(array);\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpzeslto0_.d(28): Error: undefined identifier `sort_array_ascending`\n/tmp/tmpzeslto0_.d(30): Error: undefined identifier `sort_array_descending`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzeslto0_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = array.clone();\n    if (array.length == 0) return sorted_array;\n    \n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    } else {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    }\n    return sorted_array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpnstu40mt.d(24): Error: no property `clone` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnstu40mt.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        sort(array, 0, array.length - 1);\n    } else {\n        sort(array, 0, array.length - 1, true);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpdtcfp4jd.d(29): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpdtcfp4jd.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdtcfp4jd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = array.clone();\n    if(array.length == 0)\n        return sorted_array;\n    \n    long sum = 0;\n    for(int i = 0; i < array.length; i++)\n        sum += array[i];\n    \n    if(sum % 2 == 1)\n        sort_array_ascending(sorted_array);\n    else\n        sort_array_descending(sorted_array);\n    \n    return sorted_array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmps926atnu.d(24): Error: no property `clone` for type `long[]`\n/tmp/tmps926atnu.d(33): Error: undefined identifier `sort_array_ascending`\n/tmp/tmps926atnu.d(35): Error: undefined identifier `sort_array_descending`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps926atnu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if(array.length == 0)\n        return array;\n    \n    long sum = 0;\n    for(int i = 0; i < array.length; i++)\n        sum += array[i];\n    \n    if(sum % 2 == 0)\n        return sort_array_descending(array);\n    else\n        return sort_array_ascending(array);\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmp92mpqd88.d(32): Error: undefined identifier `sort_array_descending`\n/tmp/tmp92mpqd88.d(34): Error: undefined identifier `sort_array_ascending`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp92mpqd88.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = new long[array.length];\n    int i = 0;\n    int j = 0;\n    int sum = 0;\n    while(i < array.length)\n    {\n        sum += array[i];\n        i++;\n    }\n    if(sum % 2 == 1)\n    {\n        for(i = 0; i < array.length; i++)\n        {\n            sorted_array[i] = array[i];\n        }\n        for(i = 0; i < array.length; i++)\n        {\n            for(j = i + 1; j < array.length; j++)\n            {\n                if(sorted_array[i] > sorted_array[j])\n                {\n                    long temp = sorted_array[i];\n                    sorted_array[i] = sorted_array[j];\n                    sorted_array[j] = temp;\n                }\n            }\n        }\n    }\n    else\n    {\n        for(i = 0; i < array.length; i++)\n        {\n            sorted_array[i] = array[i];\n        }\n        for(i = 0; i < array.length; i++)\n        {\n            for(j = i + 1; j < array.length; j++)\n            {\n                if(sorted_array[i] < sorted_array[j])\n                {\n                    long temp = sorted_array[i];\n                    sorted_array[i] = sorted_array[j];\n                    sorted_array[j] = temp;\n                }\n            }\n        }\n    }\n    return sorted_array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp6kpw5hmr.d(80): unittest failure\n----------------\n??:? _d_unittestp [0x42894d]\n??:? void tmp6kpw5hmr.__unittest_L73_C1() [0x428426]\n??:? void tmp6kpw5hmr.__modtest() [0x4286d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca07]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b89a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b25]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fd4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ab1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b871]\n??:? runModuleUnitTests [0x42c7dd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e10]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length == 0) return array;\n    \n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    \n    if (sum % 2 == 1) {\n        sort(array, 0, array.length - 1);\n    } else {\n        sort(array, 0, array.length - 1, true);\n    }\n    \n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpp12n1aun.d(32): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpp12n1aun.d(34): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp12n1aun.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted = new long[array.length];\n    for (int i = 0; i < array.length; i++) {\n        sorted[i] = array[i];\n    }\n    \n    if (array.length == 1) {\n        return sorted;\n    }\n    \n    if (array.length == 2) {\n        if (array[0] + array[1] == 0) {\n            return sorted;\n        } else {\n            return sorted;\n        }\n    }\n    \n    if (array.length == 3) {\n        if (array[0] + array[1] + array[2] == 0) {\n            return sorted;\n        } else {\n            return sorted;\n        }\n    }\n    \n    if (array.length == 4) {\n        if (array[0] + array[1] + array[2] + array[3] == 0) {\n            return sorted;\n        } else {\n            return sorted;\n        }\n    }\n    \n    if (array.length == 5) {\n        if (array[0] + array[1] + array[2] + array[3] + array[4] == 0) {\n            return sorted;\n        } else {\n            return sorted;\n        }\n    }\n    \n    if (array.length == 6) {\n        if (array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0) {\n            return sorted;\n        } else {\n            return sorted;\n        }\n    }\n    \n    if (array.length == 7) {\n        if (array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0) {\n            return sorted;\n        } else {\n            return sorted;\n        }\n    }\n    \n    if (array.length == 8) {\n        if (array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0) {\n            return\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpni2hrm3v.d(84): Error: expression expected, not `unittest`\n/tmp/tmpni2hrm3v.d(85): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmpni2hrm3v.d(96): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpni2hrm3v.d(96): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpni2hrm3v.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for(int i = 0; i < array.length; i++)\n        sum += array[i];\n    if(sum % 2 == 1)\n        sort(array, 0, array.length - 1);\n    else\n        sort(array, 0, array.length - 1, false);\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpdulqb41j.d(28): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpdulqb41j.d(30): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdulqb41j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        return sort_array_ascending(array);\n    } else {\n        return sort_array_descending(array);\n    }\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpdfgah4bn.d(29): Error: undefined identifier `sort_array_ascending`\n/tmp/tmpdfgah4bn.d(31): Error: undefined identifier `sort_array_descending`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdfgah4bn.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted = new long[array.length];\n    int i = 0;\n    int j = 0;\n    int sum = 0;\n    while (i < array.length) {\n        sum = array[i] + array[array.length - 1 - i];\n        if (sum % 2 == 1) {\n            for (j = i; j < array.length - 1 - i; j++) {\n                if (array[j] > array[j + 1]) {\n                    long temp = array[j];\n                    array[j] = array[j + 1];\n                    array[j + 1] = temp;\n                }\n            }\n        } else {\n            for (j = i; j < array.length - 1 - i; j++) {\n                if (array[j] > array[j + 1]) {\n                    long temp = array[j];\n                    array[j] = array[j + 1];\n                    array[j + 1] = temp;\n                }\n            }\n        }\n        sorted[i] = array[i];\n        i++;\n    }\n    return sorted;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmp8aup57dh.d(29): Error: cannot implicitly convert expression `array[cast(ulong)i] + array[array.length - 1LU - cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8aup57dh.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = array.clone();\n    if(array.length == 0)\n        return sorted_array;\n    \n    if(array.length == 1)\n        return sorted_array;\n    \n    if(array.length == 2)\n        return sorted_array;\n    \n    if(array.length == 3)\n        return sorted_array;\n    \n    if(array.length == 4)\n        return sorted_array;\n    \n    if(array.length == 5)\n        return sorted_array;\n    \n    if(array.length == 6)\n        return sorted_array;\n    \n    if(array.length == 7)\n        return sorted_array;\n    \n    if(array.length == 8)\n        return sorted_array;\n    \n    if(array.length == 9)\n        return sorted_array;\n    \n    if(array.length == 10)\n        return sorted_array;\n    \n    if(array.length == 11)\n        return sorted_array;\n    \n    if(array.length == 12)\n        return sorted_array;\n    \n    if(array.length == 13)\n        return sorted_array;\n    \n    if(array.length == 14)\n        return sorted_array;\n    \n    if(array.length == 15)\n        return sorted_array;\n    \n    if(array.length == 16)\n        return sorted_array;\n    \n    if(array.length == 17)\n        return sorted_array;\n    \n    if(array.length == 18)\n        return sorted_array;\n    \n    if(array.length == 19)\n        return sorted_array;\n    \n    if(array.length == 20)\n        return sorted_array;\n    \n    if(array.length == 21)\n        return sorted_array;\n    \n    if(array.length == 22)\n        return sorted_array;\n    \n    if(array.length == 23)\n        return sorted_array;\n    \n    if(array.length == 24)\n        return sorted_array;\n    \n    if(array.length == 25)\n        return sorted_array;\n    \n    if(array\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpnc2tbrp2.d(104): Error: found `unittest` when expecting `)`\n/tmp/tmpnc2tbrp2.d(116): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnc2tbrp2.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        return array;\n    } else {\n        return array.sort(Long::compare);\n    }\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmp634imsxf.d(31): Error: found `:` when expecting `,`\n/tmp/tmp634imsxf.d(31): Error: expression expected, not `:`\n/tmp/tmp634imsxf.d(31): Error: found `compare` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp634imsxf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length == 0) return array;\n    \n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    \n    if (sum % 2 == 1) {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    } else {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    }\n    return array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp33l66yo_.d(62): unittest failure\n----------------\n??:? _d_unittestp [0x428885]\n??:? void tmp33l66yo_.__unittest_L55_C1() [0x42835e]\n??:? void tmp33l66yo_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8e3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b776]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430909]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430db8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430895]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b74d]\n??:? runModuleUnitTests [0x42c6b9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d48]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length == 0) return array;\n    \n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    \n    if (sum % 2 == 0) {\n        sort_array_descending(array);\n    } else {\n        sort_array_ascending(array);\n    }\n    \n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmp4p244lx_.d(32): Error: undefined identifier `sort_array_descending`\n/tmp/tmp4p244lx_.d(34): Error: undefined identifier `sort_array_ascending`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4p244lx_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        sort(array, 0, array.length - 1);\n    } else {\n        sort(array, 0, array.length - 1, true);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpdtcfp4jd.d(29): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpdtcfp4jd.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdtcfp4jd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length == 0) return array;\n    \n    long[] sorted = new long[array.length];\n    \n    int start = 0;\n    int end = array.length - 1;\n    \n    while (start < end) {\n        if (array[start] + array[end] == 0) {\n            sorted[start] = array[start];\n            sorted[end] = array[end];\n            \n            start++;\n            end--;\n        } else if (array[start] + array[end] > 0) {\n            sorted[start] = array[start];\n            sorted[end] = array[end];\n            \n            start++;\n            end--;\n        } else {\n            sorted[start] = array[start];\n            sorted[end] = array[end];\n            \n            start++;\n            end--;\n        }\n    }\n    \n    if (array[start] + array[end] > 0) {\n        sorted[start] = array[start];\n        sorted[end] = array[end];\n    } else if (array[start] + array[end] == 0) {\n        sorted[start] = array[start];\n        sorted[end] = array[end];\n    }\n    \n    return sorted;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmp0ugw_prb.d(29): Error: cannot implicitly convert expression `array.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0ugw_prb.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for(int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if(sum % 2 == 1) {\n        sort(array, 0, array.length - 1);\n    } else {\n        sort(array, 0, array.length - 1, false);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpnvbsszpy.d(29): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpnvbsszpy.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnvbsszpy.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = new long[array.length];\n    for(int i = 0; i < array.length; i++)\n    {\n        sorted_array[i] = array[i];\n    }\n    \n    if(array.length == 1)\n    {\n        return sorted_array;\n    }\n    \n    int start = 0;\n    int end = array.length - 1;\n    \n    while(start < end)\n    {\n        if(sorted_array[start] + sorted_array[end] == 0)\n        {\n            long temp = sorted_array[start];\n            sorted_array[start] = sorted_array[end];\n            sorted_array[end] = temp;\n            \n            start++;\n            end--;\n        }\n        else if(sorted_array[start] + sorted_array[end] % 2 == 1)\n        {\n            long temp = sorted_array[start];\n            sorted_array[start] = sorted_array[end];\n            sorted_array[end] = temp;\n            \n            start++;\n            end--;\n        }\n        else\n        {\n            start++;\n        }\n    }\n    \n    return sorted_array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpicdsxzrt.d(36): Error: cannot implicitly convert expression `array.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpicdsxzrt.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = array.clone();\n    if (sorted_array.length == 0) return sorted_array;\n    \n    long sum = 0;\n    for (int i = 0; i < sorted_array.length; i++) {\n        sum += sorted_array[i];\n    }\n    \n    if (sum % 2 == 1) {\n        sort_array_descending(sorted_array);\n    } else {\n        sort_array_ascending(sorted_array);\n    }\n    \n    return sorted_array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpsd_lcb7h.d(24): Error: no property `clone` for type `long[]`\n/tmp/tmpsd_lcb7h.d(33): Error: undefined identifier `sort_array_descending`\n/tmp/tmpsd_lcb7h.d(35): Error: undefined identifier `sort_array_ascending`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsd_lcb7h.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = new long[array.length];\n    int index = 0;\n    for (int i = 0; i < array.length; i++) {\n        if (index == 0) {\n            sorted_array[index++] = array[i];\n        } else if (index == 1) {\n            if (array[i] > sorted_array[0]) {\n                sorted_array[index++] = array[i];\n            } else {\n                sorted_array[index++] = sorted_array[0];\n                sorted_array[0] = array[i];\n            }\n        } else {\n            if (array[i] > sorted_array[index - 1]) {\n                sorted_array[index++] = array[i];\n            } else {\n                sorted_array[index++] = sorted_array[index - 1];\n                sorted_array[index - 1] = array[i];\n            }\n        }\n    }\n    return sorted_array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpiz5r2i34.d(54): unittest failure\n----------------\n??:? _d_unittestp [0x4288f5]\n??:? void tmpiz5r2i34.__unittest_L48_C1() [0x4282f6]\n??:? void tmpiz5r2i34.__modtest() [0x428674]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9af]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b842]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430acd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f7c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a59]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b819]\n??:? runModuleUnitTests [0x42c785]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428db8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        return array;\n    } else {\n        return array.sort(Long::compare);\n    }\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmp634imsxf.d(31): Error: found `:` when expecting `,`\n/tmp/tmp634imsxf.d(31): Error: expression expected, not `:`\n/tmp/tmp634imsxf.d(31): Error: found `compare` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp634imsxf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        sort_array_ascending(array);\n    } else {\n        sort_array_descending(array);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmp7g1beil_.d(29): Error: undefined identifier `sort_array_ascending`\n/tmp/tmp7g1beil_.d(31): Error: undefined identifier `sort_array_descending`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7g1beil_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = new long[array.length];\n    int start = 0;\n    int end = array.length - 1;\n    int mid = 0;\n    int sum = 0;\n    while(start < end)\n    {\n        sum = array[start] + array[end];\n        if(sum % 2 == 1)\n        {\n            mid = start;\n            start++;\n        }\n        else\n        {\n            mid = end;\n            end--;\n        }\n        sorted_array[start] = array[mid];\n        sorted_array[end] = array[mid];\n    }\n    return sorted_array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpp4vl28mb.d(26): Error: cannot implicitly convert expression `array.length - 1LU` of type `ulong` to `int`\n/tmp/tmpp4vl28mb.d(31): Error: cannot implicitly convert expression `array[cast(ulong)start] + array[cast(ulong)end]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp4vl28mb.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for(int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if(sum % 2 == 1) {\n        sort(array, 0, array.length - 1);\n    } else {\n        sort(array, 0, array.length - 1, true);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmppfk1tpcp.d(29): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmppfk1tpcp.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppfk1tpcp.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        return array;\n    } else {\n        return array.sort(Long::compare);\n    }\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmp634imsxf.d(31): Error: found `:` when expecting `,`\n/tmp/tmp634imsxf.d(31): Error: expression expected, not `:`\n/tmp/tmp634imsxf.d(31): Error: found `compare` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp634imsxf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 0) {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    } else {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    }\n    return array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpo76sf1do.d(59): unittest failure\n----------------\n??:? _d_unittestp [0x42886d]\n??:? void tmpo76sf1do.__unittest_L52_C1() [0x428346]\n??:? void tmpo76sf1do.__modtest() [0x4285f0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8cb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b75e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308f1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430da0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43087d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b735]\n??:? runModuleUnitTests [0x42c6a1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d30]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length == 0) return array;\n    \n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    \n    if (sum % 2 == 1) {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    } else {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    }\n    return array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp33l66yo_.d(62): unittest failure\n----------------\n??:? _d_unittestp [0x428885]\n??:? void tmp33l66yo_.__unittest_L55_C1() [0x42835e]\n??:? void tmp33l66yo_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8e3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b776]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430909]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430db8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430895]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b74d]\n??:? runModuleUnitTests [0x42c6b9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d48]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = new long[array.length];\n    int start = 0;\n    int end = array.length - 1;\n    int mid = 0;\n    \n    while (start <= end) {\n        mid = (start + end) / 2;\n        if (sum(mid, end) % 2 == 0) {\n            for (int i = start; i <= end; i++) {\n                sorted_array[i] = array[i];\n            }\n            end = mid - 1;\n        } else {\n            for (int i = start; i <= end; i++) {\n                sorted_array[i] = array[i];\n            }\n            start = mid + 1;\n        }\n    }\n    return sorted_array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpp0f9lhzg.d(26): Error: cannot implicitly convert expression `array.length - 1LU` of type `ulong` to `int`\n/tmp/tmpp0f9lhzg.d(31): Error: undefined identifier `sum`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp0f9lhzg.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length == 0) return array;\n    \n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    \n    if (sum % 2 == 1) {\n        sort(array, 0, array.length - 1);\n    } else {\n        sort(array, 0, array.length - 1);\n    }\n    \n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmp32cqxxpq.d(32): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmp32cqxxpq.d(34): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp32cqxxpq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        sort(array, 0, array.length - 1);\n    } else {\n        sort(array, 0, array.length - 1, true);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpdtcfp4jd.d(29): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpdtcfp4jd.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdtcfp4jd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for(int i = 0; i < array.length; i++)\n    {\n        sum += array[i];\n    }\n    if(sum % 2 == 0)\n    {\n        return sort_array_descending(array);\n    }\n    return sort_array_ascending(array);\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmp6rimuo_1.d(31): Error: undefined identifier `sort_array_descending`\n/tmp/tmp6rimuo_1.d(33): Error: undefined identifier `sort_array_ascending`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6rimuo_1.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = array.clone();\n    if (sorted_array.length == 0) return sorted_array;\n    \n    long sum = 0;\n    for (int i = 0; i < sorted_array.length; i++) {\n        sum += sorted_array[i];\n    }\n    \n    if (sum % 2 == 0) {\n        sort_array_descending(sorted_array);\n    } else {\n        sort_array_ascending(sorted_array);\n    }\n    \n    return sorted_array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpai_omrah.d(24): Error: no property `clone` for type `long[]`\n/tmp/tmpai_omrah.d(33): Error: undefined identifier `sort_array_descending`\n/tmp/tmpai_omrah.d(35): Error: undefined identifier `sort_array_ascending`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpai_omrah.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length == 0) return array;\n    \n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    \n    if (sum % 2 == 1) {\n        sort(array, 0, array.length - 1);\n    } else {\n        sort(array, 0, array.length - 1);\n        reverse(array, 0, array.length - 1);\n    }\n    \n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpw50r_uhv.d(32): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpw50r_uhv.d(34): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpw50r_uhv.d(35): Error: undefined identifier `reverse`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw50r_uhv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = array.clone();\n    if(sorted_array.length == 0)\n        return sorted_array;\n    \n    int start = 0;\n    int end = sorted_array.length - 1;\n    \n    while(start < end)\n    {\n        if(sorted_array[start] + sorted_array[end] == 0)\n        {\n            long temp = sorted_array[start];\n            sorted_array[start] = sorted_array[end];\n            sorted_array[end] = temp;\n            start++;\n            end--;\n        }\n        else if(sorted_array[start] + sorted_array[end] % 2 == 1)\n        {\n            long temp = sorted_array[start];\n            sorted_array[start] = sorted_array[end];\n            sorted_array[end] = temp;\n            start++;\n            end--;\n        }\n        else\n        {\n            start++;\n            end--;\n        }\n    }\n    return sorted_array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmp3pfza0zr.d(24): Error: no property `clone` for type `long[]`\n/tmp/tmp3pfza0zr.d(29): Error: cannot implicitly convert expression `sorted_array.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3pfza0zr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = new long[array.length];\n    int i = 0;\n    int j = 0;\n    int sum = 0;\n    while(i < array.length)\n    {\n        sum = array[i] + array[array.length - 1 - i];\n        if(sum % 2 == 1)\n        {\n            for(j = 0; j < array.length; j++)\n            {\n                sorted_array[j] = array[j];\n            }\n        }\n        else\n        {\n            for(j = 0; j < array.length; j++)\n            {\n                sorted_array[j] = array[array.length - 1 - j];\n            }\n        }\n        i++;\n    }\n    return sorted_array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmptlojzrv0.d(30): Error: cannot implicitly convert expression `array[cast(ulong)i] + array[array.length - 1LU - cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptlojzrv0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        sort(array, 0, array.length - 1);\n    } else {\n        sort(array, 0, array.length - 1, true);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpdtcfp4jd.d(29): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpdtcfp4jd.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdtcfp4jd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length == 0) return array;\n    long[] sorted = new long[array.length];\n    for (int i = 0; i < array.length; i++) {\n        sorted[i] = array[i];\n    }\n    sort(sorted);\n    long sum = 0;\n    for (int i = 0; i < sorted.length; i++) {\n        sum += sorted[i];\n    }\n    if (sum % 2 == 1) {\n        for (int i = 0; i < sorted.length; i++) {\n            sorted[i] = sorted[i] * -1;\n        }\n    }\n    return sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpcpqpvz0e.d(29): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcpqpvz0e.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = new long[array.length];\n    int i = 0;\n    int j = 0;\n    int sum = 0;\n    while(i < array.length)\n    {\n        sum += array[i];\n        i++;\n    }\n    if(sum % 2 == 1)\n    {\n        for(i = 0; i < array.length; i++)\n        {\n            sorted_array[i] = array[i];\n        }\n        for(i = 0; i < array.length; i++)\n        {\n            for(j = i + 1; j < array.length; j++)\n            {\n                if(sorted_array[i] > sorted_array[j])\n                {\n                    long temp = sorted_array[i];\n                    sorted_array[i] = sorted_array[j];\n                    sorted_array[j] = temp;\n                }\n            }\n        }\n    }\n    else\n    {\n        for(i = 0; i < array.length; i++)\n        {\n            sorted_array[i] = array[i];\n        }\n        for(i = 0; i < array.length; i++)\n        {\n            for(j = i + 1; j < array.length; j++)\n            {\n                if(sorted_array[i] > sorted_array[j])\n                {\n                    long temp = sorted_array[i];\n                    sorted_array[i] = sorted_array[j];\n                    sorted_array[j] = temp;\n                }\n            }\n        }\n    }\n    return sorted_array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqyn5ufr3.d(81): unittest failure\n----------------\n??:? _d_unittestp [0x42894d]\n??:? void tmpqyn5ufr3.__unittest_L74_C1() [0x428426]\n??:? void tmpqyn5ufr3.__modtest() [0x4286d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca07]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b89a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b25]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fd4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ab1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b871]\n??:? runModuleUnitTests [0x42c7dd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e10]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = array.clone();\n    if(array.length == 0)\n        return sorted_array;\n    \n    if(array.length == 1)\n        return sorted_array;\n    \n    if(array.length == 2)\n        return sorted_array;\n    \n    if(array.length == 3)\n        return sorted_array;\n    \n    if(array.length == 4)\n        return sorted_array;\n    \n    if(array.length == 5)\n        return sorted_array;\n    \n    if(array.length == 6)\n        return sorted_array;\n    \n    if(array.length == 7)\n        return sorted_array;\n    \n    if(array.length == 8)\n        return sorted_array;\n    \n    if(array.length == 9)\n        return sorted_array;\n    \n    if(array.length == 10)\n        return sorted_array;\n    \n    if(array.length == 11)\n        return sorted_array;\n    \n    if(array.length == 12)\n        return sorted_array;\n    \n    if(array.length == 13)\n        return sorted_array;\n    \n    if(array.length == 14)\n        return sorted_array;\n    \n    if(array.length == 15)\n        return sorted_array;\n    \n    if(array.length == 16)\n        return sorted_array;\n    \n    if(array.length == 17)\n        return sorted_array;\n    \n    if(array.length == 18)\n        return sorted_array;\n    \n    if(array.length == 19)\n        return sorted_array;\n    \n    if(array.length == 20)\n        return sorted_array;\n    \n    if(array.length == 21)\n        return sorted_array;\n    \n    if(array.length == 22)\n        return sorted_array;\n    \n    if(array.length == 23)\n        return sorted_array;\n    \n    if(array.length == 24)\n        return sorted_array;\n    \n    if(array.length == 25)\n        return sorted_array;\n    \n    if(array\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpnc2tbrp2.d(104): Error: found `unittest` when expecting `)`\n/tmp/tmpnc2tbrp2.d(116): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnc2tbrp2.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 0) {\n        sort_array_descending(array);\n    } else {\n        sort_array_ascending(array);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmprwybgz1s.d(29): Error: undefined identifier `sort_array_descending`\n/tmp/tmprwybgz1s.d(31): Error: undefined identifier `sort_array_ascending`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprwybgz1s.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 0) {\n        return array;\n    }\n    else {\n        return array.sort(Long::compare);\n    }\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpaysorcg2.d(32): Error: found `:` when expecting `,`\n/tmp/tmpaysorcg2.d(32): Error: expression expected, not `:`\n/tmp/tmpaysorcg2.d(32): Error: found `compare` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpaysorcg2.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        sort(array, 0, array.length - 1);\n    } else {\n        sort(array, 0, array.length - 1, true);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpdtcfp4jd.d(29): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpdtcfp4jd.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdtcfp4jd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length == 0) return array;\n    \n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    \n    if (sum % 2 == 1) {\n        sort(array, 0, array.length - 1);\n    } else {\n        sort(array, 0, array.length - 1);\n        reverse(array, 0, array.length - 1);\n    }\n    \n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpw50r_uhv.d(32): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpw50r_uhv.d(34): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpw50r_uhv.d(35): Error: undefined identifier `reverse`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw50r_uhv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = new long[array.length];\n    int i = 0;\n    int j = 0;\n    long sum = 0;\n    while (i < array.length) {\n        sum += array[i];\n        i++;\n    }\n    if (sum % 2 == 0) {\n        for (i = 0; i < array.length; i++) {\n            sorted_array[i] = array[i];\n        }\n        for (i = 0; i < array.length - 1; i++) {\n            for (j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    } else {\n        for (i = 0; i < array.length; i++) {\n            sorted_array[i] = array[i];\n        }\n        for (i = 0; i < array.length - 1; i++) {\n            for (j = i + 1; j < array.length; j++) {\n                if (array[i] < array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    }\n    return sorted_array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292984,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpphwjwoz2.d(68): unittest failure\n----------------\n??:? _d_unittestp [0x428975]\n??:? void tmpphwjwoz2.__unittest_L62_C1() [0x428376]\n??:? void tmpphwjwoz2.__modtest() [0x4286f4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca2f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8c2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b4d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ffc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ad9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b899]\n??:? runModuleUnitTests [0x42c805]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e38]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        return array;\n    } else {\n        return array.sort(Long::compare);\n    }\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmp634imsxf.d(31): Error: found `:` when expecting `,`\n/tmp/tmp634imsxf.d(31): Error: expression expected, not `:`\n/tmp/tmp634imsxf.d(31): Error: found `compare` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp634imsxf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        return array;\n    } else {\n        return array.sort(Long::compare);\n    }\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmp634imsxf.d(31): Error: found `:` when expecting `,`\n/tmp/tmp634imsxf.d(31): Error: expression expected, not `:`\n/tmp/tmp634imsxf.d(31): Error: found `compare` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp634imsxf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted = new long[array.length];\n    for(int i = 0; i < array.length; i++)\n    {\n        sorted[i] = array[i];\n    }\n    \n    if(sorted.length == 1)\n    {\n        return sorted;\n    }\n    \n    if(sorted.length == 2)\n    {\n        if(sorted[0] + sorted[1] == 0)\n        {\n            return sorted;\n        }\n        else if(sorted[0] + sorted[1] == 1)\n        {\n            return sorted;\n        }\n        else if(sorted[0] + sorted[1] == 2)\n        {\n            return sorted;\n        }\n        else if(sorted[0] + sorted[1] == 3)\n        {\n            return sorted;\n        }\n        else if(sorted[0] + sorted[1] == 4)\n        {\n            return sorted;\n        }\n        else if(sorted[0] + sorted[1] == 5)\n        {\n            return sorted;\n        }\n        else if(sorted[0] + sorted[1] == 6)\n        {\n            return sorted;\n        }\n        else if(sorted[0] + sorted[1] == 7)\n        {\n            return sorted;\n        }\n        else if(sorted[0] + sorted[1] == 8)\n        {\n            return sorted;\n        }\n        else if(sorted[0] + sorted[1] == 9)\n        {\n            return sorted;\n        }\n        else if(sorted[0] + sorted[1] == 10)\n        {\n            return sorted;\n        }\n        else if(sorted[0] + sorted[1] == 11)\n        {\n            return sorted;\n        }\n        else if(sorted[0] + sorted[1] == 12)\n        {\n            return sorted;\n        }\n        else if(sorted[0] + sorted[1] == 13)\n        {\n            return sorted;\n        }\n        else if(sorted[0] + sorted[1] == 14)\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpukydb9aw.d(94): Error: found `unittest` instead of statement\n/tmp/tmpukydb9aw.d(106): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpukydb9aw.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = new long[array.length];\n    for (int i = 0; i < array.length; i++) {\n        sorted_array[i] = array[i];\n    }\n    \n    if (sorted_array.length == 1) {\n        return sorted_array;\n    }\n    \n    int start = 0;\n    int end = sorted_array.length - 1;\n    while (start < end) {\n        if (sorted_array[start] + sorted_array[end] == 0) {\n            long temp = sorted_array[start];\n            sorted_array[start] = sorted_array[end];\n            sorted_array[end] = temp;\n            start++;\n            end--;\n        } else if (sorted_array[start] + sorted_array[end] % 2 == 1) {\n            long temp = sorted_array[start];\n            sorted_array[start] = sorted_array[end];\n            sorted_array[end] = temp;\n            start++;\n            end--;\n        } else {\n            end--;\n        }\n    }\n    \n    return sorted_array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmp0mdugcrv.d(34): Error: cannot implicitly convert expression `sorted_array.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0mdugcrv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        sort(array, 0, array.length - 1);\n    } else {\n        sort(array, 0, array.length - 1, false);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpxm7ukc4p.d(29): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpxm7ukc4p.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxm7ukc4p.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = array.clone();\n    if (array.length == 0)\n        return sorted_array;\n    \n    int start = 0;\n    int end = array.length - 1;\n    \n    while (start < end) {\n        if (array[start] + array[end] == 0) {\n            long temp = sorted_array[start];\n            sorted_array[start] = sorted_array[end];\n            sorted_array[end] = temp;\n            start++;\n            end--;\n        } else if (array[start] + array[end] % 2 == 1) {\n            long temp = sorted_array[start];\n            sorted_array[start] = sorted_array[end];\n            sorted_array[end] = temp;\n            start++;\n            end--;\n        } else {\n            start++;\n            end--;\n        }\n    }\n    return sorted_array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpqefd6sx3.d(24): Error: no property `clone` for type `long[]`\n/tmp/tmpqefd6sx3.d(29): Error: cannot implicitly convert expression `array.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqefd6sx3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        sort(array, 0, array.length - 1);\n    } else {\n        sort(array, 0, array.length - 1, true);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpdtcfp4jd.d(29): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpdtcfp4jd.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdtcfp4jd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 0) {\n        sort_array_descending(array);\n    } else {\n        sort_array_ascending(array);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmprwybgz1s.d(29): Error: undefined identifier `sort_array_descending`\n/tmp/tmprwybgz1s.d(31): Error: undefined identifier `sort_array_ascending`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprwybgz1s.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = array.clone();\n    if (sorted_array.length > 1) {\n        if (sorted_array.length % 2 == 0) {\n            sort_array_desc(sorted_array);\n        } else {\n            sort_array_asc(sorted_array);\n        }\n    }\n    return sorted_array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpie0u_6eo.d(24): Error: no property `clone` for type `long[]`\n/tmp/tmpie0u_6eo.d(27): Error: undefined identifier `sort_array_desc`\n/tmp/tmpie0u_6eo.d(29): Error: undefined identifier `sort_array_asc`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpie0u_6eo.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = new long[array.length];\n    \n    for (int i = 0; i < array.length; i++) {\n        sorted_array[i] = array[i];\n    }\n    \n    if (array.length > 1) {\n        if (sum(array) % 2 == 0) {\n            sort_array_descending(sorted_array);\n        } else {\n            sort_array_ascending(sorted_array);\n        }\n    }\n    \n    return sorted_array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpwslhwj41.d(31): Error: undefined identifier `sum`\n/tmp/tmpwslhwj41.d(32): Error: undefined identifier `sort_array_descending`\n/tmp/tmpwslhwj41.d(34): Error: undefined identifier `sort_array_ascending`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwslhwj41.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 0) {\n        sort_array_descending(array);\n    } else {\n        sort_array_ascending(array);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmprwybgz1s.d(29): Error: undefined identifier `sort_array_descending`\n/tmp/tmprwybgz1s.d(31): Error: undefined identifier `sort_array_ascending`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprwybgz1s.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = new long[array.length];\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int sum = 0;\n    while(i < array.length)\n    {\n        sum = 0;\n        for(j = i; j < array.length; j++)\n        {\n            sum += array[j];\n            if(sum > 0)\n            {\n                break;\n            }\n        }\n        for(k = i; k < j; k++)\n        {\n            sorted_array[k] = array[k];\n        }\n        for(k = j; k < array.length; k++)\n        {\n            sorted_array[k] = array[k];\n        }\n        i = j;\n    }\n    return sorted_array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292990,
      "stdout": "",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        sort(array);\n    } else {\n        sort(array, true);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpzjif39gu.d(29): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpzjif39gu.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzjif39gu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length == 0) return array;\n    long[] sorted = new long[array.length];\n    for (int i = 0; i < array.length; i++) {\n        sorted[i] = array[i];\n    }\n    sort(sorted);\n    long sum = 0;\n    for (int i = 0; i < sorted.length; i++) {\n        sum += sorted[i];\n    }\n    if (sum % 2 == 1) {\n        for (int i = 0; i < sorted.length; i++) {\n            sorted[i] = -sorted[i];\n        }\n    }\n    return sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmp32yxbmei.d(29): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp32yxbmei.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    } else {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    }\n    return array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpt7cs4pq8.d(59): unittest failure\n----------------\n??:? _d_unittestp [0x42886d]\n??:? void tmpt7cs4pq8.__unittest_L52_C1() [0x428346]\n??:? void tmpt7cs4pq8.__modtest() [0x4285f0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8cb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b75e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308f1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430da0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43087d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b735]\n??:? runModuleUnitTests [0x42c6a1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d30]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = new long[array.length];\n    int start = 0;\n    int end = array.length - 1;\n    int mid = 0;\n    while (start < end) {\n        mid = (start + end) / 2;\n        if (sum(array, start, mid) % 2 == 0) {\n            // sort in descending order\n            for (int i = start; i <= mid; i++) {\n                sorted_array[i] = array[i];\n            }\n            for (int i = mid + 1; i <= end; i++) {\n                sorted_array[i] = array[i];\n            }\n            start = mid + 1;\n        } else {\n            // sort in ascending order\n            for (int i = start; i <= mid; i++) {\n                sorted_array[i] = array[i];\n            }\n            for (int i = mid + 1; i <= end; i++) {\n                sorted_array[i] = array[i];\n            }\n            end = mid - 1;\n        }\n    }\n    return sorted_array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpp44bix8u.d(26): Error: cannot implicitly convert expression `array.length - 1LU` of type `ulong` to `int`\n/tmp/tmpp44bix8u.d(30): Error: undefined identifier `sum`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp44bix8u.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        sort(array, 0, array.length - 1);\n    } else {\n        sort(array, 0, array.length - 1, true);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpdtcfp4jd.d(29): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpdtcfp4jd.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdtcfp4jd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        sort(array, 0, array.length - 1);\n    } else {\n        sort(array, 0, array.length - 1, true);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpdtcfp4jd.d(29): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpdtcfp4jd.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdtcfp4jd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if(array.length == 0) return array;\n    \n    long sum = 0;\n    for(int i = 0; i < array.length; i++)\n        sum += array[i];\n    \n    if(sum % 2 == 0)\n        sort_array_descending(array);\n    else\n        sort_array_ascending(array);\n    \n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmp7wi0g48z.d(31): Error: undefined identifier `sort_array_descending`\n/tmp/tmp7wi0g48z.d(33): Error: undefined identifier `sort_array_ascending`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7wi0g48z.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length == 0) return array;\n    \n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    \n    if (sum % 2 == 0) {\n        // sort in descending order\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    } else {\n        // sort in ascending order\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] < array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    }\n    return array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpy_x02oln.d(63): unittest failure\n----------------\n??:? _d_unittestp [0x428885]\n??:? void tmpy_x02oln.__unittest_L57_C1() [0x42828a]\n??:? void tmpy_x02oln.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8e3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b776]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430909]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430db8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430895]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b74d]\n??:? runModuleUnitTests [0x42c6b9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d48]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        sort(array, 0, array.length - 1);\n    } else {\n        sort(array, 0, array.length - 1, true);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpdtcfp4jd.d(29): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpdtcfp4jd.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdtcfp4jd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = new long[array.length];\n    int i = 0;\n    int j = 0;\n    int sum = 0;\n    while(i < array.length)\n    {\n        sum += array[i];\n        i++;\n    }\n    if(sum % 2 == 1)\n    {\n        for(i = 0; i < array.length; i++)\n        {\n            sorted_array[i] = array[i];\n        }\n        for(i = 0; i < array.length; i++)\n        {\n            for(j = i + 1; j < array.length; j++)\n            {\n                if(sorted_array[i] > sorted_array[j])\n                {\n                    long temp = sorted_array[i];\n                    sorted_array[i] = sorted_array[j];\n                    sorted_array[j] = temp;\n                }\n            }\n        }\n    }\n    else\n    {\n        for(i = 0; i < array.length; i++)\n        {\n            sorted_array[i] = array[i];\n        }\n        for(i = 0; i < array.length; i++)\n        {\n            for(j = i + 1; j < array.length; j++)\n            {\n                if(sorted_array[i] > sorted_array[j])\n                {\n                    long temp = sorted_array[i];\n                    sorted_array[i] = sorted_array[j];\n                    sorted_array[j] = temp;\n                }\n            }\n        }\n    }\n    return sorted_array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqyn5ufr3.d(81): unittest failure\n----------------\n??:? _d_unittestp [0x42894d]\n??:? void tmpqyn5ufr3.__unittest_L74_C1() [0x428426]\n??:? void tmpqyn5ufr3.__modtest() [0x4286d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca07]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b89a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b25]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fd4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ab1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b871]\n??:? runModuleUnitTests [0x42c7dd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e10]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = array.clone();\n    if (array.length == 0)\n        return sorted_array;\n    \n    if (array.length == 1)\n        return sorted_array;\n    \n    if (array.length == 2)\n    {\n        if (array[0] + array[1] == 0)\n            return sorted_array;\n        else if (array[0] + array[1] == 1)\n            return sorted_array;\n        else\n            return sorted_array;\n    }\n    \n    long sum = 0;\n    for (int i = 0; i < array.length; i++)\n        sum += array[i];\n    \n    if (sum % 2 == 0)\n    {\n        for (int i = 0; i < array.length; i++)\n            sorted_array[i] = -array[i];\n    }\n    else\n    {\n        for (int i = 0; i < array.length; i++)\n            sorted_array[i] = array[i];\n    }\n    \n    sort(sorted_array);\n    return sorted_array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpwcgmtasp.d(24): Error: no property `clone` for type `long[]`\n/tmp/tmpwcgmtasp.d(56): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwcgmtasp.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length == 0) return array;\n    \n    long sum = 0;\n    for (int i = 0; i < array.length; i++)\n        sum += array[i];\n    \n    if (sum % 2 == 1)\n        sort_array_helper(array, 0, array.length - 1);\n    else\n        sort_array_helper(array, 0, array.length - 1);\n    \n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpcyb0211g.d(31): Error: undefined identifier `sort_array_helper`\n/tmp/tmpcyb0211g.d(33): Error: undefined identifier `sort_array_helper`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcyb0211g.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length == 0) return array;\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    } else {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    }\n    return array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp4x5vy8di.d(60): unittest failure\n----------------\n??:? _d_unittestp [0x428885]\n??:? void tmp4x5vy8di.__unittest_L53_C1() [0x42835e]\n??:? void tmp4x5vy8di.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8e3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b776]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430909]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430db8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430895]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b74d]\n??:? runModuleUnitTests [0x42c6b9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d48]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted = new long[array.length];\n    int i = 0;\n    int j = 0;\n    long sum = 0;\n    while(i < array.length)\n    {\n        sum += array[i];\n        i++;\n    }\n    if(sum % 2 == 1)\n    {\n        for(i = 0; i < array.length; i++)\n        {\n            sorted[j] = array[i];\n            j++;\n        }\n    }\n    else\n    {\n        for(i = array.length - 1; i >= 0; i--)\n        {\n            sorted[j] = array[i];\n            j++;\n        }\n    }\n    return sorted;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpyw3_nhw4.d(43): Error: cannot implicitly convert expression `array.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyw3_nhw4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length == 0) return array;\n    \n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    \n    if (sum % 2 == 0) {\n        sort_array_descending(array);\n    } else {\n        sort_array_ascending(array);\n    }\n    \n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmp4p244lx_.d(32): Error: undefined identifier `sort_array_descending`\n/tmp/tmp4p244lx_.d(34): Error: undefined identifier `sort_array_ascending`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4p244lx_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if(array.length == 0) return array;\n    long sum = 0;\n    for(int i = 0; i < array.length; i++)\n        sum += array[i];\n    if(sum % 2 == 1)\n        sort(array, 0, array.length - 1);\n    else\n        sort(array, 0, array.length - 1, true);\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpjund979a.d(29): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpjund979a.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjund979a.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for(int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if(sum % 2 == 1) {\n        sort(array, 0, array.length - 1);\n    } else {\n        sort(array, 0, array.length - 1, false);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpnvbsszpy.d(29): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpnvbsszpy.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnvbsszpy.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        sort(array, 0, array.length - 1);\n    } else {\n        sort(array, 0, array.length - 1, true);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpdtcfp4jd.d(29): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpdtcfp4jd.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdtcfp4jd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    } else {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    }\n    return array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpt7cs4pq8.d(59): unittest failure\n----------------\n??:? _d_unittestp [0x42886d]\n??:? void tmpt7cs4pq8.__unittest_L52_C1() [0x428346]\n??:? void tmpt7cs4pq8.__modtest() [0x4285f0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8cb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b75e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308f1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430da0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43087d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b735]\n??:? runModuleUnitTests [0x42c6a1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d30]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        sort(array, 0, array.length - 1);\n    } else {\n        sort(array, 0, array.length - 1, true);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpdtcfp4jd.d(29): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpdtcfp4jd.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdtcfp4jd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if(array.length == 0) return array;\n    \n    long sum = 0;\n    for(int i = 0; i < array.length; i++)\n    {\n        sum += array[i];\n    }\n    \n    if(sum % 2 == 1)\n    {\n        sort(array, 0, array.length - 1);\n    }\n    else\n    {\n        sort(array, 0, array.length - 1);\n        reverse(array, 0, array.length - 1);\n    }\n    \n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpg67w423n.d(34): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpg67w423n.d(38): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpg67w423n.d(39): Error: undefined identifier `reverse`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg67w423n.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for(int i = 0; i < array.length; i++)\n    {\n        sum += array[i];\n    }\n    if(sum % 2 == 1)\n    {\n        return sort_array_ascending(array);\n    }\n    else\n    {\n        return sort_array_descending(array);\n    }\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpm0qxlw6v.d(31): Error: undefined identifier `sort_array_ascending`\n/tmp/tmpm0qxlw6v.d(35): Error: undefined identifier `sort_array_descending`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm0qxlw6v.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 0) {\n        return array;\n    }\n    else {\n        return array.sort((a, b) -> b - a);\n    }\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmp0rogjn35.d(32): Error: expression expected, not `>`\n/tmp/tmp0rogjn35.d(32): Error: found `b` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0rogjn35.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        return array;\n    } else {\n        return array.sort(Long::compare);\n    }\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmp634imsxf.d(31): Error: found `:` when expecting `,`\n/tmp/tmp634imsxf.d(31): Error: expression expected, not `:`\n/tmp/tmp634imsxf.d(31): Error: found `compare` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp634imsxf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length == 0) return array;\n    \n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    \n    if (sum % 2 == 1) {\n        sort_array_ascending(array);\n    } else {\n        sort_array_descending(array);\n    }\n    \n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmppb0yd8nj.d(32): Error: undefined identifier `sort_array_ascending`\n/tmp/tmppb0yd8nj.d(34): Error: undefined identifier `sort_array_descending`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppb0yd8nj.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for(int i = 0; i < array.length; i++)\n        sum += array[i];\n    if(sum % 2 == 1)\n        sort(array, 0, array.length - 1);\n    else\n        sort(array, 0, array.length - 1, true);\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpmw1h5hgo.d(28): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpmw1h5hgo.d(30): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmw1h5hgo.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = new long[array.length];\n    int i = 0;\n    int j = 0;\n    long sum = 0;\n    for(i = 0; i < array.length; i++)\n    {\n        sum += array[i];\n    }\n    if(sum % 2 == 1)\n    {\n        for(i = 0; i < array.length; i++)\n        {\n            sorted_array[i] = array[i];\n        }\n        for(i = 0; i < array.length; i++)\n        {\n            for(j = i + 1; j < array.length; j++)\n            {\n                if(sorted_array[i] > sorted_array[j])\n                {\n                    long temp = sorted_array[i];\n                    sorted_array[i] = sorted_array[j];\n                    sorted_array[j] = temp;\n                }\n            }\n        }\n    }\n    else\n    {\n        for(i = 0; i < array.length; i++)\n        {\n            sorted_array[i] = array[i];\n        }\n        for(i = 0; i < array.length; i++)\n        {\n            for(j = i + 1; j < array.length; j++)\n            {\n                if(sorted_array[i] > sorted_array[j])\n                {\n                    long temp = sorted_array[i];\n                    sorted_array[i] = sorted_array[j];\n                    sorted_array[j] = temp;\n                }\n            }\n        }\n    }\n    return sorted_array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp4o6qhxgj.d(80): unittest failure\n----------------\n??:? _d_unittestp [0x428955]\n??:? void tmp4o6qhxgj.__unittest_L73_C1() [0x42842a]\n??:? void tmp4o6qhxgj.__modtest() [0x4286d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca0f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b2d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fdc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ab9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b879]\n??:? runModuleUnitTests [0x42c7e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e18]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    } else {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    }\n    return array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpt7cs4pq8.d(59): unittest failure\n----------------\n??:? _d_unittestp [0x42886d]\n??:? void tmpt7cs4pq8.__unittest_L52_C1() [0x428346]\n??:? void tmpt7cs4pq8.__modtest() [0x4285f0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8cb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b75e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308f1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430da0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43087d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b735]\n??:? runModuleUnitTests [0x42c6a1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d30]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    } else {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    }\n    return array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpt7cs4pq8.d(59): unittest failure\n----------------\n??:? _d_unittestp [0x42886d]\n??:? void tmpt7cs4pq8.__unittest_L52_C1() [0x428346]\n??:? void tmpt7cs4pq8.__modtest() [0x4285f0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8cb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b75e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308f1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430da0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43087d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b735]\n??:? runModuleUnitTests [0x42c6a1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d30]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] result = new long[array.length];\n    int i = 0;\n    int j = array.length - 1;\n    while (i < j) {\n        if (array[i] + array[j] == 0) {\n            result[i] = array[i];\n            result[j] = array[j];\n            i++;\n            j--;\n        } else if (array[i] + array[j] % 2 == 1) {\n            result[i] = array[i];\n            result[j] = array[j];\n            i++;\n            j--;\n        } else {\n            result[i] = array[j];\n            result[j] = array[i];\n            i++;\n            j--;\n        }\n    }\n    if (i == j) {\n        result[i] = array[i];\n    }\n    return result;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmp95s10a1y.d(26): Error: cannot implicitly convert expression `array.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp95s10a1y.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        sort_array_ascending(array);\n    } else {\n        sort_array_descending(array);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmp7g1beil_.d(29): Error: undefined identifier `sort_array_ascending`\n/tmp/tmp7g1beil_.d(31): Error: undefined identifier `sort_array_descending`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7g1beil_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted_array = array.clone();\n    if (array.length == 0) return sorted_array;\n    \n    int start = 0;\n    int end = array.length - 1;\n    int mid = (start + end) / 2;\n    \n    while (start <= end) {\n        if (sum(sorted_array[start], sorted_array[end]) % 2 == 0) {\n            // even sum\n            if (sorted_array[start] > sorted_array[end]) {\n                long temp = sorted_array[start];\n                sorted_array[start] = sorted_array[end];\n                sorted_array[end] = temp;\n            }\n            start++;\n        } else {\n            // odd sum\n            if (sorted_array[start] > sorted_array[end]) {\n                long temp = sorted_array[start];\n                sorted_array[start] = sorted_array[end];\n                sorted_array[end] = temp;\n            }\n            start++;\n            end--;\n        }\n        mid = (start + end) / 2;\n    }\n    return sorted_array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmps6yiaxob.d(24): Error: no property `clone` for type `long[]`\n/tmp/tmps6yiaxob.d(28): Error: cannot implicitly convert expression `array.length - 1LU` of type `ulong` to `int`\n/tmp/tmps6yiaxob.d(32): Error: undefined identifier `sum`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps6yiaxob.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 0) {\n        return array;\n    } else {\n        return array.sort(Long::compare);\n    }\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpfkko_dui.d(31): Error: found `:` when expecting `,`\n/tmp/tmpfkko_dui.d(31): Error: expression expected, not `:`\n/tmp/tmpfkko_dui.d(31): Error: found `compare` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfkko_dui.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        return array;\n    } else {\n        return array.sort((a, b) -> b - a);\n    }\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmp699csi_c.d(31): Error: expression expected, not `>`\n/tmp/tmp699csi_c.d(31): Error: found `b` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp699csi_c.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if(array.length == 0) return array;\n    \n    long[] sorted = new long[array.length];\n    \n    for(int i = 0; i < array.length; i++)\n    {\n        sorted[i] = array[i];\n    }\n    \n    int start = 0;\n    int end = array.length - 1;\n    \n    while(start < end)\n    {\n        if(sum(sorted[start], sorted[end]) % 2 == 0)\n        {\n            long temp = sorted[start];\n            sorted[start] = sorted[end];\n            sorted[end] = temp;\n            start++;\n            end--;\n        }\n        else\n        {\n            start++;\n        }\n    }\n    \n    return sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpdstui9rq.d(34): Error: cannot implicitly convert expression `array.length - 1LU` of type `ulong` to `int`\n/tmp/tmpdstui9rq.d(38): Error: undefined identifier `sum`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdstui9rq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        return array;\n    } else {\n        return array.sort(Long::compare);\n    }\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmp634imsxf.d(31): Error: found `:` when expecting `,`\n/tmp/tmp634imsxf.d(31): Error: expression expected, not `:`\n/tmp/tmp634imsxf.d(31): Error: found `compare` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp634imsxf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        return array;\n    }\n    else {\n        return array.sort((a, b) -> b - a);\n    }\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmppl_0mqko.d(32): Error: expression expected, not `>`\n/tmp/tmppl_0mqko.d(32): Error: found `b` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppl_0mqko.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted = new long[array.length];\n    int i = 0;\n    int j = 0;\n    long sum = 0;\n    while(i < array.length)\n    {\n        sum += array[i];\n        i++;\n    }\n    if(sum % 2 == 1)\n    {\n        for(i = 0; i < array.length; i++)\n        {\n            sorted[j] = array[i];\n            j++;\n        }\n    }\n    else\n    {\n        for(i = array.length - 1; i >= 0; i--)\n        {\n            sorted[j] = array[i];\n            j++;\n        }\n    }\n    return sorted;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpyw3_nhw4.d(43): Error: cannot implicitly convert expression `array.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyw3_nhw4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        sort(array, 0, array.length - 1);\n    } else {\n        sort(array, 0, array.length - 1, false);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpxm7ukc4p.d(29): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpxm7ukc4p.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxm7ukc4p.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    if (array.length == 0) return array;\n    \n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    \n    if (sum % 2 == 1) {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    } else {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    }\n    \n    return array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpvyh_f76i.d(63): unittest failure\n----------------\n??:? _d_unittestp [0x428885]\n??:? void tmpvyh_f76i.__unittest_L56_C1() [0x42835e]\n??:? void tmpvyh_f76i.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8e3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b776]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430909]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430db8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430895]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b74d]\n??:? runModuleUnitTests [0x42c6b9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d48]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] sorted = new long[array.length];\n    int i = 0;\n    int j = 0;\n    int sum = 0;\n    while(i < array.length)\n    {\n        sum += array[i];\n        i++;\n    }\n    if(sum % 2 == 1)\n    {\n        for(i = 0; i < array.length; i++)\n        {\n            sorted[i] = array[i];\n        }\n        for(i = 0; i < array.length; i++)\n        {\n            for(j = i + 1; j < array.length; j++)\n            {\n                if(sorted[i] > sorted[j])\n                {\n                    long temp = sorted[i];\n                    sorted[i] = sorted[j];\n                    sorted[j] = temp;\n                }\n            }\n        }\n    }\n    else\n    {\n        for(i = 0; i < array.length; i++)\n        {\n            sorted[i] = array[i];\n        }\n        for(i = 0; i < array.length; i++)\n        {\n            for(j = i + 1; j < array.length; j++)\n            {\n                if(sorted[i] > sorted[j])\n                {\n                    long temp = sorted[i];\n                    sorted[i] = sorted[j];\n                    sorted[j] = temp;\n                }\n            }\n        }\n    }\n    return sorted;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpl4w03jv4.d(81): unittest failure\n----------------\n??:? _d_unittestp [0x42894d]\n??:? void tmpl4w03jv4.__unittest_L74_C1() [0x428426]\n??:? void tmpl4w03jv4.__modtest() [0x4286d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca07]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b89a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b25]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fd4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ab1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b871]\n??:? runModuleUnitTests [0x42c7dd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e10]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    } else {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i] > array[j]) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n    }\n    return array;\n}\n\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpt7cs4pq8.d(59): unittest failure\n----------------\n??:? _d_unittestp [0x42886d]\n??:? void tmpt7cs4pq8.__unittest_L52_C1() [0x428346]\n??:? void tmpt7cs4pq8.__modtest() [0x4285f0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8cb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b75e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308f1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430da0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43087d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b735]\n??:? runModuleUnitTests [0x42c6a1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d30]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        sort(array, 0, array.length - 1);\n    } else {\n        sort(array, 0, array.length - 1, false);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "/tmp/tmpxm7ukc4p.d(29): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpxm7ukc4p.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxm7ukc4p.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long[] result = array;\n    if (array.length > 1) {\n        long sum = 0;\n        for (int i = 0; i < array.length; i++) {\n            sum += array[i];\n        }\n        if (sum % 2 == 1) {\n            for (int i = 0; i < array.length; i++) {\n                for (int j = i + 1; j < array.length; j++) {\n                    if (array[i] > array[j]) {\n                        long temp = array[i];\n                        array[i] = array[j];\n                        array[j] = temp;\n                    }\n                }\n            }\n        } else {\n            for (int i = 0; i < array.length; i++) {\n                for (int j = i + 1; j < array.length; j++) {\n                    if (array[i] > array[j]) {\n                        long temp = array[i];\n                        array[i] = array[j];\n                        array[j] = temp;\n                    }\n                }\n            }\n        }\n        result = array;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292975,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp7lv4ezic.d(62): unittest failure\n----------------\n??:? _d_unittestp [0x42889d]\n??:? void tmp7lv4ezic.__unittest_L55_C1() [0x428372]\n??:? void tmp7lv4ezic.__modtest() [0x42861c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b78e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430921]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4308ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b765]\n??:? runModuleUnitTests [0x42c6d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d60]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\n/*\n\n    Given an array of non-negative integers, return a cod of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n    \n*/\nlong[] sort_array(long[] array) \n{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        sort(array, 0, array.length - 1);\n    } else {\n        sort(array, 0, array.length - 1, true);\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}",
      "timestamp": 1664292974,
      "stdout": "",
      "stderr": "/tmp/tmpdtcfp4jd.d(29): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpdtcfp4jd.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdtcfp4jd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}