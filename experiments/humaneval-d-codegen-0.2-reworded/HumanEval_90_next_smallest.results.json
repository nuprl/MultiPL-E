{
  "name": "HumanEval_90_next_smallest",
  "language": "d",
  "prompt": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n",
  "tests": "unittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "results": [
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min) {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min) {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpt9g1pxl1.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpt9g1pxl1.d(34): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9g1pxl1.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    \n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuldrrxjm.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuldrrxjm.d(39): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuldrrxjm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    \n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuldrrxjm.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuldrrxjm.d(39): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuldrrxjm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    \n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuldrrxjm.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuldrrxjm.d(39): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuldrrxjm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    Nullable!(long) min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n            min = lst[i];\n    }\n    \n    for (int i = 0; i < lst.length; i++)\n    {\n        if (lst[i] == min)\n            return lst[i + 1];\n    }\n    \n    return min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpcosqrykb.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpcosqrykb.d(33): Error: cannot implicitly convert expression `lst[cast(ulong)(i + 1)]` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcosqrykb.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min) {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min) {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpt9g1pxl1.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpt9g1pxl1.d(34): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9g1pxl1.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[1];\n    for (int i = 2; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    if (min == second_min)\n        return null;\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmp1euyx11c.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp1euyx11c.d(38): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp1euyx11c.d(40): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1euyx11c.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    \n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuldrrxjm.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuldrrxjm.d(39): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuldrrxjm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    \n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuldrrxjm.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuldrrxjm.d(39): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuldrrxjm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    \n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuldrrxjm.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuldrrxjm.d(39): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuldrrxjm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    \n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuldrrxjm.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuldrrxjm.d(39): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuldrrxjm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    \n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    if (second_min == min)\n        return null;\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpahqk5qyl.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpahqk5qyl.d(40): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpahqk5qyl.d(42): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpahqk5qyl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    \n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuldrrxjm.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuldrrxjm.d(39): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuldrrxjm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    if (lst.length == 1)\n        return null;\n    long min = lst[0];\n    long max = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n            min = lst[i];\n        if (lst[i] > max)\n            max = lst[i];\n    }\n    for (int i = 0; i < lst.length; i++)\n    {\n        if (lst[i] == min && lst[i] != max)\n        {\n            return lst[i + 1];\n        }\n        if (lst[i] == max && lst[i] != min)\n        {\n            return lst[i + 1];\n        }\n    }\n    return null;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpdz56o1to.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpdz56o1to.d(23): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpdz56o1to.d(37): Error: cannot implicitly convert expression `lst[cast(ulong)(i + 1)]` of type `long` to `Nullable!long`\n/tmp/tmpdz56o1to.d(41): Error: cannot implicitly convert expression `lst[cast(ulong)(i + 1)]` of type `long` to `Nullable!long`\n/tmp/tmpdz56o1to.d(44): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdz56o1to.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long max = lst[0];\n    \n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n            min = lst[i];\n        else if (lst[i] > max)\n            max = lst[i];\n    }\n    \n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] == min)\n            return lst[i];\n        else if (lst[i] == max)\n            return lst[i];\n    }\n    \n    return null;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpdvn75ne0.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpdvn75ne0.d(37): Error: cannot implicitly convert expression `lst[cast(ulong)i]` of type `long` to `Nullable!long`\n/tmp/tmpdvn75ne0.d(39): Error: cannot implicitly convert expression `lst[cast(ulong)i]` of type `long` to `Nullable!long`\n/tmp/tmpdvn75ne0.d(42): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdvn75ne0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    \n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuldrrxjm.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuldrrxjm.d(39): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuldrrxjm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[1];\n    \n    for (int i = 2; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    if (min == second_min)\n        return null;\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpv_gsygds.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpv_gsygds.d(39): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpv_gsygds.d(41): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv_gsygds.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    \n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuldrrxjm.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuldrrxjm.d(39): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuldrrxjm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min) {\n            second_min = min;\n            min = lst[i];\n        } else if (lst[i] < second_min) {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmp6vjmgjqu.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp6vjmgjqu.d(33): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6vjmgjqu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[1];\n    \n    for (int i = 2; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    if (min == second_min)\n    {\n        return second_min;\n    }\n    \n    return null;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmphvk84nt3.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmphvk84nt3.d(40): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\n/tmp/tmphvk84nt3.d(43): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphvk84nt3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min) {\n            second_min = min;\n            min = lst[i];\n        } else if (lst[i] < second_min) {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmp6vjmgjqu.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp6vjmgjqu.d(33): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6vjmgjqu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min) {\n            second_min = min;\n            min = lst[i];\n        } else if (lst[i] < second_min) {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpteo55rz8.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpteo55rz8.d(33): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpteo55rz8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    \n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuldrrxjm.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuldrrxjm.d(39): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuldrrxjm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    \n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuldrrxjm.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuldrrxjm.d(39): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuldrrxjm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[1];\n    \n    for (int i = 2; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    if (min == second_min)\n    {\n        return second_min;\n    }\n    \n    return null;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmphvk84nt3.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmphvk84nt3.d(40): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\n/tmp/tmphvk84nt3.d(43): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphvk84nt3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    \n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    if (second_min == min)\n        return null;\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpahqk5qyl.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpahqk5qyl.d(40): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpahqk5qyl.d(42): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpahqk5qyl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    \n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuldrrxjm.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuldrrxjm.d(39): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuldrrxjm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    \n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuldrrxjm.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuldrrxjm.d(39): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuldrrxjm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[1];\n    \n    for (int i = 2; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpesfk1v56.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpesfk1v56.d(39): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpesfk1v56.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    \n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuldrrxjm.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuldrrxjm.d(39): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuldrrxjm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    Nullable!(long) min = null;\n    for (long i : lst)\n    {\n        if (min == null || i < min.value)\n            min = i;\n    }\n    \n    for (long i : lst)\n    {\n        if (i == min.value)\n            continue;\n        \n        if (i < min.value)\n            return min;\n    }\n    \n    return min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293039,
      "stdout": "",
      "stderr": "/tmp/tmpu1nskpiz.d(24): Error: semicolon expected, not `:`\n/tmp/tmpu1nskpiz.d(24): Error: expression expected, not `:`\n/tmp/tmpu1nskpiz.d(24): Error: found `lst` when expecting `;` following `for` condition\n/tmp/tmpu1nskpiz.d(30): Error: semicolon expected, not `:`\n/tmp/tmpu1nskpiz.d(30): Error: expression expected, not `:`\n/tmp/tmpu1nskpiz.d(30): Error: found `lst` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu1nskpiz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    \n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuldrrxjm.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuldrrxjm.d(39): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuldrrxjm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n        return null;\n    long min = lst[0];\n    long second_min = lst[1];\n    for (int i = 2; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            min = lst[i];\n            second_min = lst[i - 1];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpp42z8f42.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpp42z8f42.d(36): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp42z8f42.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    \n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuldrrxjm.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuldrrxjm.d(39): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuldrrxjm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[1];\n    \n    for (int i = 2; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    if (min == second_min)\n    {\n        return null;\n    }\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpzd6zbm0r.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpzd6zbm0r.d(40): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpzd6zbm0r.d(43): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzd6zbm0r.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[1];\n    for (int i = 2; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpmufyy3qi.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpmufyy3qi.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmufyy3qi.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    Nullable!(long) min = null;\n    for (long i : lst)\n        if (min == null || i < min.value)\n            min = i;\n    \n    for (long i : lst)\n        if (i != min.value && i < min.value)\n            min = i;\n    \n    return min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293039,
      "stdout": "",
      "stderr": "/tmp/tmpy09670fq.d(24): Error: semicolon expected, not `:`\n/tmp/tmpy09670fq.d(24): Error: expression expected, not `:`\n/tmp/tmpy09670fq.d(24): Error: found `lst` when expecting `;` following `for` condition\n/tmp/tmpy09670fq.d(28): Error: semicolon expected, not `:`\n/tmp/tmpy09670fq.d(28): Error: expression expected, not `:`\n/tmp/tmpy09670fq.d(28): Error: found `lst` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy09670fq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[1];\n    \n    for (int i = 2; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    if (min == second_min)\n    {\n        return null;\n    }\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpzd6zbm0r.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpzd6zbm0r.d(40): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpzd6zbm0r.d(43): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzd6zbm0r.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long max = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n            min = lst[i];\n        if (lst[i] > max)\n            max = lst[i];\n    }\n    \n    for (int i = 0; i < lst.length; i++)\n    {\n        if (lst[i] == min && lst[i] != max)\n            return lst[i + 1];\n    }\n    \n    return null;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpyw_f8h7d.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpyw_f8h7d.d(36): Error: cannot implicitly convert expression `lst[cast(ulong)(i + 1)]` of type `long` to `Nullable!long`\n/tmp/tmpyw_f8h7d.d(39): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyw_f8h7d.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min) {\n            second_min = min;\n            min = lst[i];\n        } else if (lst[i] < second_min) {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmp6vjmgjqu.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp6vjmgjqu.d(33): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6vjmgjqu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[1];\n    for (int i = 2; i < lst.length; i++) {\n        if (lst[i] < min) {\n            second_min = min;\n            min = lst[i];\n        } else if (lst[i] < second_min) {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpb_84qvk4.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpb_84qvk4.d(33): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb_84qvk4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[1];\n    for (int i = 2; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpmufyy3qi.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpmufyy3qi.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmufyy3qi.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    \n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuldrrxjm.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuldrrxjm.d(39): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuldrrxjm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long max = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n            min = lst[i];\n        if (lst[i] > max)\n            max = lst[i];\n    }\n    \n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min && lst[i] > max)\n        {\n            max = lst[i];\n        }\n    }\n    \n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < max && lst[i] > min)\n        {\n            min = lst[i];\n        }\n    }\n    \n    if (min == max)\n        return null;\n    \n    return min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmprud5kgf5.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmprud5kgf5.d(50): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmprud5kgf5.d(52): Error: cannot implicitly convert expression `min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprud5kgf5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long max = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n            min = lst[i];\n        if (lst[i] > max)\n            max = lst[i];\n    }\n    \n    for (int i = 0; i < lst.length; i++)\n    {\n        if (lst[i] == min)\n            return lst[i + 1];\n        if (lst[i] == max)\n            return lst[i - 1];\n    }\n    \n    return null;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpe9aew6ps.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpe9aew6ps.d(36): Error: cannot implicitly convert expression `lst[cast(ulong)(i + 1)]` of type `long` to `Nullable!long`\n/tmp/tmpe9aew6ps.d(38): Error: cannot implicitly convert expression `lst[cast(ulong)(i - 1)]` of type `long` to `Nullable!long`\n/tmp/tmpe9aew6ps.d(41): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe9aew6ps.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[1];\n    \n    for (int i = 2; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            min = lst[i];\n            second_min = lst[i-1];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    if (min == second_min)\n        return null;\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpqunlv8gr.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpqunlv8gr.d(40): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpqunlv8gr.d(42): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqunlv8gr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[1];\n    \n    for (int i = 2; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    if (min == second_min)\n        return null;\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpv_gsygds.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpv_gsygds.d(39): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpv_gsygds.d(41): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv_gsygds.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[1];\n    \n    for (int i = 2; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpesfk1v56.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpesfk1v56.d(39): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpesfk1v56.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min) {\n            second_min = min;\n            min = lst[i];\n        } else if (lst[i] < second_min) {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmp6vjmgjqu.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp6vjmgjqu.d(33): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6vjmgjqu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    \n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min) {\n            second_min = min;\n            min = lst[i];\n        } else if (lst[i] < second_min) {\n            second_min = lst[i];\n        }\n    }\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmp9zu1q4gv.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp9zu1q4gv.d(35): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9zu1q4gv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[1];\n    \n    for (int i = 2; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    if (min == second_min)\n        return null;\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpv_gsygds.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpv_gsygds.d(39): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpv_gsygds.d(41): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv_gsygds.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min) {\n            second_min = min;\n            min = lst[i];\n        } else if (lst[i] < second_min) {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmp6vjmgjqu.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp6vjmgjqu.d(33): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6vjmgjqu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    \n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuldrrxjm.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuldrrxjm.d(39): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuldrrxjm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[1];\n    \n    for (int i = 2; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    if (min == second_min)\n    {\n        return null;\n    }\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpzd6zbm0r.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpzd6zbm0r.d(40): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpzd6zbm0r.d(43): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzd6zbm0r.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[1];\n    for (int i = 2; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n            second_min = lst[i];\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpqfu1c8sv.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpqfu1c8sv.d(35): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqfu1c8sv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long max = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n            min = lst[i];\n        if (lst[i] > max)\n            max = lst[i];\n    }\n    \n    for (int i = 0; i < lst.length; i++)\n    {\n        if (lst[i] == min)\n        {\n            if (i + 1 < lst.length)\n            {\n                if (lst[i + 1] == max)\n                {\n                    return lst[i + 1];\n                }\n            }\n        }\n    }\n    \n    return null;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293042,
      "stdout": "",
      "stderr": "/tmp/tmpz8wz3i1k.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpz8wz3i1k.d(41): Error: cannot implicitly convert expression `lst[cast(ulong)(i + 1)]` of type `long` to `Nullable!long`\n/tmp/tmpz8wz3i1k.d(47): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz8wz3i1k.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    \n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    if (second_min == min)\n        return null;\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpahqk5qyl.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpahqk5qyl.d(40): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpahqk5qyl.d(42): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpahqk5qyl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[1];\n    for (int i = 2; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpmufyy3qi.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpmufyy3qi.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmufyy3qi.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min) {\n            second_min = min;\n            min = lst[i];\n        } else if (lst[i] < second_min) {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmp6vjmgjqu.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp6vjmgjqu.d(33): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6vjmgjqu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293042,
      "stdout": "",
      "stderr": "/tmp/tmp5gdocqn6.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp5gdocqn6.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5gdocqn6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    if (lst.length == 1)\n        return null;\n    if (lst.length == 2)\n        return lst[1];\n    long min = lst[0];\n    long min_index = 0;\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            min = lst[i];\n            min_index = i;\n        }\n    }\n    if (min_index == 0)\n        return lst[1];\n    else\n        return lst[min_index];\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293042,
      "stdout": "",
      "stderr": "/tmp/tmp0yhisdvy.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp0yhisdvy.d(23): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp0yhisdvy.d(25): Error: cannot implicitly convert expression `lst[1]` of type `long` to `Nullable!long`\n/tmp/tmp0yhisdvy.d(37): Error: cannot implicitly convert expression `lst[1]` of type `long` to `Nullable!long`\n/tmp/tmp0yhisdvy.d(39): Error: cannot implicitly convert expression `lst[cast(ulong)min_index]` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0yhisdvy.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    \n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    if (min == second_min)\n        return null;\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293042,
      "stdout": "",
      "stderr": "/tmp/tmp69lwe7_t.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp69lwe7_t.d(40): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp69lwe7_t.d(42): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp69lwe7_t.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min) {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min) {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpt9g1pxl1.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpt9g1pxl1.d(34): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9g1pxl1.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    \n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuldrrxjm.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuldrrxjm.d(39): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuldrrxjm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    \n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuldrrxjm.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuldrrxjm.d(39): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuldrrxjm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293042,
      "stdout": "",
      "stderr": "/tmp/tmpqz2fdkib.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpqz2fdkib.d(38): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqz2fdkib.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    \n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    if (second_min == min)\n        return null;\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpahqk5qyl.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpahqk5qyl.d(40): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpahqk5qyl.d(42): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpahqk5qyl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    \n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuldrrxjm.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuldrrxjm.d(39): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuldrrxjm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293042,
      "stdout": "",
      "stderr": "/tmp/tmpqz2fdkib.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpqz2fdkib.d(38): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqz2fdkib.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[1];\n    \n    for (int i = 2; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpesfk1v56.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpesfk1v56.d(39): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpesfk1v56.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[1];\n    \n    for (int i = 2; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    if (min == second_min)\n        return null;\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpv_gsygds.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpv_gsygds.d(39): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpv_gsygds.d(41): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv_gsygds.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[1];\n    for (int i = 2; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpmufyy3qi.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpmufyy3qi.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmufyy3qi.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[1];\n    \n    for (int i = 2; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    if (min == second_min)\n        return null;\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpv_gsygds.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpv_gsygds.d(39): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpv_gsygds.d(41): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv_gsygds.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[1];\n    \n    for (int i = 2; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    if (min == second_min)\n        return null;\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpv_gsygds.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpv_gsygds.d(39): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpv_gsygds.d(41): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv_gsygds.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[1];\n    \n    for (int i = 2; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    if (min == second_min)\n        return null;\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpv_gsygds.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpv_gsygds.d(39): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpv_gsygds.d(41): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv_gsygds.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min) {\n            second_min = min;\n            min = lst[i];\n        } else if (lst[i] < second_min) {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmp6vjmgjqu.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp6vjmgjqu.d(33): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6vjmgjqu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min) {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min) {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpt9g1pxl1.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpt9g1pxl1.d(34): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9g1pxl1.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min) {\n            second_min = min;\n            min = lst[i];\n        } else if (lst[i] < second_min) {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmp6vjmgjqu.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp6vjmgjqu.d(33): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6vjmgjqu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[1];\n    for (int i = 2; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n            second_min = lst[i];\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpqfu1c8sv.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpqfu1c8sv.d(35): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqfu1c8sv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293042,
      "stdout": "",
      "stderr": "/tmp/tmpqz2fdkib.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpqz2fdkib.d(38): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqz2fdkib.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long max = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n            min = lst[i];\n        if (lst[i] > max)\n            max = lst[i];\n    }\n    \n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] == min)\n            return lst[i];\n        if (lst[i] == max)\n            continue;\n        if (lst[i] < min)\n            min = lst[i];\n        if (lst[i] > max)\n            max = lst[i];\n    }\n    \n    return null;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293042,
      "stdout": "",
      "stderr": "/tmp/tmpl4chycvm.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpl4chycvm.d(36): Error: cannot implicitly convert expression `lst[cast(ulong)i]` of type `long` to `Nullable!long`\n/tmp/tmpl4chycvm.d(45): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl4chycvm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    \n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuldrrxjm.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuldrrxjm.d(39): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuldrrxjm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    \n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuldrrxjm.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuldrrxjm.d(39): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuldrrxjm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min) {\n            second_min = min;\n            min = lst[i];\n        } else if (lst[i] < second_min) {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmp6vjmgjqu.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp6vjmgjqu.d(33): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6vjmgjqu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[1];\n    \n    for (int i = 2; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    if (min == second_min)\n        return null;\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpv_gsygds.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpv_gsygds.d(39): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpv_gsygds.d(41): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv_gsygds.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    Nullable!(long) min = null;\n    for (long i : lst)\n        if (min == null || i < min.value)\n            min = i;\n    \n    for (long i : lst)\n        if (i != min.value && i < min.value)\n            min = i;\n    \n    return min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293039,
      "stdout": "",
      "stderr": "/tmp/tmpy09670fq.d(24): Error: semicolon expected, not `:`\n/tmp/tmpy09670fq.d(24): Error: expression expected, not `:`\n/tmp/tmpy09670fq.d(24): Error: found `lst` when expecting `;` following `for` condition\n/tmp/tmpy09670fq.d(28): Error: semicolon expected, not `:`\n/tmp/tmpy09670fq.d(28): Error: expression expected, not `:`\n/tmp/tmpy09670fq.d(28): Error: found `lst` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy09670fq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuuzv4k8i.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuuzv4k8i.d(37): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuuzv4k8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[1];\n    \n    for (int i = 2; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    if (min == second_min)\n        return null;\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpv_gsygds.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpv_gsygds.d(39): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpv_gsygds.d(41): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv_gsygds.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length < 2)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[1];\n    \n    for (int i = 2; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    if (min == second_min)\n    {\n        return second_min;\n    }\n    \n    return null;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmphvk84nt3.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmphvk84nt3.d(40): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\n/tmp/tmphvk84nt3.d(43): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphvk84nt3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    \n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuldrrxjm.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuldrrxjm.d(39): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuldrrxjm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n    \n*/\nNullable!(long) next_smallest(long[] lst) \n{\n    if (lst.length == 0)\n        return null;\n    \n    long min = lst[0];\n    long second_min = lst[0];\n    \n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n        {\n            second_min = min;\n            min = lst[i];\n        }\n        else if (lst[i] < second_min)\n        {\n            second_min = lst[i];\n        }\n    }\n    \n    return second_min;\n}\n\nunittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n        assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull && result.get == -35L);\n}\n\n}\nvoid main(){}",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "/tmp/tmpuldrrxjm.d(21): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuldrrxjm.d(39): Error: cannot implicitly convert expression `second_min` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuldrrxjm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}