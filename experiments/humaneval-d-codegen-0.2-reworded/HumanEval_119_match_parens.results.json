{
  "name": "HumanEval_119_match_parens",
  "language": "d",
  "prompt": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n",
  "tests": "unittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "results": [
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int len = lst.length;\n    if (len == 0) return \"Yes\";\n    if (len == 1) return \"No\";\n    \n    int i = 0;\n    int j = len - 1;\n    while (i < j) {\n        if (lst[i] == '(' && lst[j] == ')') {\n            i++;\n            j--;\n        } else if (lst[i] == '(') {\n            i++;\n        } else if (lst[j] == ')') {\n            j--;\n        } else {\n            return \"No\";\n        }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp7s9qmsrc.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmp7s9qmsrc.d(30): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmp7s9qmsrc.d(30): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\n/tmp/tmp7s9qmsrc.d(33): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmp7s9qmsrc.d(35): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7s9qmsrc.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k;\n    int len = lst.length;\n    for(i = 0; i < len; i++)\n    {\n        for(j = i + 1; j < len; j++)\n        {\n            if(lst[i][0] == '(' && lst[j][0] == '(')\n            {\n                k = 0;\n                while(lst[i][k] == '(' && lst[j][k] == '(')\n                {\n                    k++;\n                }\n                if(k == 0)\n                {\n                    return \"Yes\";\n                }\n            }\n        }\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpt1p1kdlf.d(24): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt1p1kdlf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int count = 0;\n    while(i < n && j < n)\n    {\n        if(lst[i] == '(')\n        {\n            count++;\n        }\n        else if(lst[j] == ')')\n        {\n            count--;\n        }\n        if(count == 0)\n        {\n            i++;\n            j++;\n        }\n        else\n        {\n            i++;\n        }\n    }\n    if(count == 0)\n    {\n        return \"Yes\";\n    }\n    else\n    {\n        return \"No\";\n    }\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpjc1i8t0_.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpjc1i8t0_.d(30): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpjc1i8t0_.d(34): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjc1i8t0_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n, m;\n    bool flag;\n    string s;\n    for(i = 0; i < lst.length; i++)\n    {\n        for(j = 0; j < lst.length; j++)\n        {\n            if(i == j)\n                continue;\n            flag = true;\n            n = lst[i].length();\n            m = lst[j].length();\n            for(k = 0; k < n; k++)\n            {\n                if(lst[i][k] == '(')\n                    flag = false;\n            }\n            for(k = 0; k < m; k++)\n            {\n                if(lst[j][k] == '(')\n                    flag = false;\n            }\n            if(flag)\n                return \"Yes\";\n        }\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpa5xcu34h.d(33): Error: no property `length` for type `string`\n/tmp/tmpa5xcu34h.d(34): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa5xcu34h.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n, m;\n    string s;\n    for (i = 0; i < lst.length; i++) {\n        if (lst[i].length() == 0)\n            continue;\n        if (lst[i][0] == '(') {\n            n = 0;\n            for (j = i + 1; j < lst.length; j++) {\n                if (lst[j].length() == 0)\n                    continue;\n                if (lst[j][0] == '(')\n                    n++;\n                else if (lst[j][0] == ')') {\n                    if (n == 0)\n                        return \"No\";\n                    n--;\n                }\n            }\n        }\n        else if (lst[i][0] == ')') {\n            n = 0;\n            for (j = i - 1; j >= 0; j--) {\n                if (lst[j].length() == 0)\n                    continue;\n                if (lst[j][0] == '(')\n                    n++;\n                else if (lst[j][0] == ')') {\n                    if (n == 0)\n                        return \"No\";\n                    n--;\n                }\n            }\n        }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpqbu7m8eu.d(26): Error: no property `length` for type `string`\n/tmp/tmpqbu7m8eu.d(31): Error: no property `length` for type `string`\n/tmp/tmpqbu7m8eu.d(45): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqbu7m8eu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, l, m, n;\n    int len = lst.length;\n    int[][] dp = new int[len][len];\n    for(i = 0; i < len; i++)\n        dp[i][i] = 1;\n    for(i = 0; i < len; i++)\n    {\n        for(j = i + 1; j < len; j++)\n        {\n            if(lst[i].charAt(0) == '(' && lst[j].charAt(0) == '(')\n            {\n                if(lst[i].charAt(lst[i].length() - 1) == ')')\n                    dp[i][j] = dp[i + 1][j - 1] + 1;\n                else\n                    dp[i][j] = dp[i + 1][j] + 1;\n            }\n            else if(lst[i].charAt(0) == '(' && lst[j].charAt(lst[j].length() - 1) == ')')\n                dp[i][j] = dp[i + 1][j] + 1;\n            else if(lst[i].charAt(lst[i].length() - 1) == ')' && lst[j].charAt(0) == '(')\n                dp[i][j] = dp[i][j - 1] + 1;\n            else if(lst[i].charAt(lst[i].length() - 1) == ')' && lst[j].charAt(lst[j].length() - 1) == ')')\n                dp[i][j] = dp[i][j - 1] + 1;\n            else\n                dp[i][j] = 0;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = i + 1; j < len; j++)\n        {\n            if(dp[i][j] == 0)\n                return \"No\";\n        }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp7vdnrl7r.d(24): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmp7vdnrl7r.d(25): Error: variable `len` cannot be read at compile time\n/tmp/tmp7vdnrl7r.d(32): Error: no property `charAt` for type `string`\n/tmp/tmp7vdnrl7r.d(32): Error: no property `charAt` for type `string`\n/tmp/tmp7vdnrl7r.d(34): Error: no property `charAt` for type `string`\n/tmp/tmp7vdnrl7r.d(39): Error: no property `charAt` for type `string`\n/tmp/tmp7vdnrl7r.d(39): Error: no property `charAt` for type `string`\n/tmp/tmp7vdnrl7r.d(41): Error: no property `charAt` for type `string`\n/tmp/tmp7vdnrl7r.d(41): Error: no property `charAt` for type `string`\n/tmp/tmp7vdnrl7r.d(43): Error: no property `charAt` for type `string`\n/tmp/tmp7vdnrl7r.d(43): Error: no property `charAt` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7vdnrl7r.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n, m;\n    int l = lst.length;\n    int r = lst[0].length();\n    int c = 0;\n    for(i = 0; i < l; i++)\n    {\n        if(lst[i][0] == '(')\n            c++;\n        else\n            c--;\n    }\n    if(c != 0)\n        return \"No\";\n    for(i = 0; i < l; i++)\n    {\n        if(lst[i][0] == '(')\n        {\n            for(j = 1; j < r; j++)\n            {\n                if(lst[i][j] == '(')\n                    c++;\n                else\n                    c--;\n                if(c < 0)\n                    return \"No\";\n            }\n        }\n    }\n    for(i = 0; i < l; i++)\n    {\n        if(lst[i][0] == '(')\n        {\n            for(j = 1; j < r; j++)\n            {\n                if(lst[i][j] == '(')\n                    c++;\n                else\n                    c--;\n                if(c < 0)\n                    return \"No\";\n            }\n        }\n    }\n    for(i = 0; i < l; i++)\n    {\n        if(lst[i][0] == '(')\n        {\n            for(j = 1; j < r; j++)\n            {\n                if(lst[i][j] == '(')\n                    c++;\n                else\n                    c--;\n                if(c < 0)\n                    return \"No\";\n            }\n        }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpunvq22ul.d(24): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpunvq22ul.d(25): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpunvq22ul.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    if (n == 0) return \"Yes\";\n    if (n == 1) return \"No\";\n    \n    int i = 0;\n    int j = n - 1;\n    while (i < j) {\n        if (lst[i][0] == '(' && lst[j][0] == ')') {\n            lst[i] = lst[i] + lst[j];\n            lst[j] = \"\";\n            j--;\n        } else if (lst[i][0] == '(' && lst[j][0] == ')') {\n            lst[j] = lst[i] + lst[j];\n            lst[i] = \"\";\n            i++;\n        } else if (lst[i][0] == '(') {\n            i++;\n        } else if (lst[j][0] == ')') {\n            j--;\n        }\n    }\n    \n    if (i == j) {\n        if (lst[i][0] == '(') return \"No\";\n        else return \"Yes\";\n    }\n    \n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp_9cb0n4y.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmp_9cb0n4y.d(31): Error: invalid array operation `lst[cast(ulong)i] + lst[cast(ulong)j]` (possible missing [])\n/tmp/tmp_9cb0n4y.d(35): Error: invalid array operation `lst[cast(ulong)i] + lst[cast(ulong)j]` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_9cb0n4y.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int len = lst.length;\n    if (len == 0) return \"Yes\";\n    if (len == 1) return \"No\";\n    \n    int i = 0, j = len - 1;\n    while (i < j) {\n        if (lst[i] == '(' && lst[j] == ')') {\n            i++;\n            j--;\n        } else if (lst[i] == '(') {\n            i++;\n        } else if (lst[j] == ')') {\n            j--;\n        } else {\n            return \"No\";\n        }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmphdmc3hhc.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmphdmc3hhc.d(29): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmphdmc3hhc.d(29): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\n/tmp/tmphdmc3hhc.d(32): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmphdmc3hhc.d(34): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphdmc3hhc.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n, m;\n    bool flag;\n    string s;\n    for(i = 0; i < lst.length; i++)\n    {\n        if(lst[i].length() == 0)\n            continue;\n        s = lst[i];\n        n = s.length();\n        flag = true;\n        for(j = 0; j < n; j++)\n        {\n            if(s[j] == '(')\n            {\n                if(flag)\n                {\n                    flag = false;\n                    continue;\n                }\n                else\n                {\n                    flag = true;\n                    continue;\n                }\n            }\n            else if(s[j] == ')')\n            {\n                if(!flag)\n                {\n                    flag = true;\n                    continue;\n                }\n                else\n                {\n                    flag = false;\n                    continue;\n                }\n            }\n        }\n        if(flag)\n            return \"Yes\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpj_idddoi.d(28): Error: no property `length` for type `string`\n/tmp/tmpj_idddoi.d(31): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj_idddoi.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    if (n == 0) return \"Yes\";\n    if (n == 1) return \"No\";\n    \n    int i = 0;\n    int j = 1;\n    int p = 0;\n    int q = 0;\n    \n    while (i < n && j < n) {\n        if (lst[i] == '(') p++;\n        if (lst[j] == ')') q++;\n        if (p == q) {\n            i++;\n            j++;\n        } else if (p > q) {\n            j++;\n        } else {\n            i++;\n        }\n    }\n    \n    if (p == q) return \"Yes\";\n    else return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp3hmkz_ti.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmp3hmkz_ti.d(33): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmp3hmkz_ti.d(34): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3hmkz_ti.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpc137ha5a.d(24): Error: no identifier for declarator `int`\n/tmp/tmpc137ha5a.d(24): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc137ha5a.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, n = lst.length;\n    for (i = 0; i < n; i++) {\n        for (j = i + 1; j < n; j++) {\n            if (lst[i][0] == '(' && lst[j][0] == '(') {\n                if (lst[i][1] == '(' && lst[j][1] == ')') {\n                    lst[i][0] = ')';\n                    lst[j][0] = ')';\n                    lst[i][1] = ')';\n                    lst[j][1] = ')';\n                }\n                else if (lst[i][1] == '(' && lst[j][1] == ')') {\n                    lst[i][0] = ')';\n                    lst[j][0] = ')';\n                    lst[i][1] = ')';\n                    lst[j][1] = ')';\n                }\n                else if (lst[i][1] == '(' && lst[j][1] == '(') {\n                    lst[i][0] = ')';\n                    lst[j][0] = ')';\n                    lst[i][1] = ')';\n                    lst[j][1] = ')';\n                }\n                else if (lst[i][1] == '(' && lst[j][1] == ')') {\n                    lst[i][0] = ')';\n                    lst[j][0] = ')';\n                    lst[i][1] = ')';\n                    lst[j][1] = ')';\n                }\n            }\n        }\n    }\n    for (i = 0; i < n; i++) {\n        if (lst[i][0] == '(')\n            return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpto2_jqem.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpto2_jqem.d(28): Error: cannot modify `immutable` expression `lst[cast(ulong)i][0]`\n/tmp/tmpto2_jqem.d(29): Error: cannot modify `immutable` expression `lst[cast(ulong)j][0]`\n/tmp/tmpto2_jqem.d(30): Error: cannot modify `immutable` expression `lst[cast(ulong)i][1]`\n/tmp/tmpto2_jqem.d(31): Error: cannot modify `immutable` expression `lst[cast(ulong)j][1]`\n/tmp/tmpto2_jqem.d(34): Error: cannot modify `immutable` expression `lst[cast(ulong)i][0]`\n/tmp/tmpto2_jqem.d(35): Error: cannot modify `immutable` expression `lst[cast(ulong)j][0]`\n/tmp/tmpto2_jqem.d(36): Error: cannot modify `immutable` expression `lst[cast(ulong)i][1]`\n/tmp/tmpto2_jqem.d(37): Error: cannot modify `immutable` expression `lst[cast(ulong)j][1]`\n/tmp/tmpto2_jqem.d(40): Error: cannot modify `immutable` expression `lst[cast(ulong)i][0]`\n/tmp/tmpto2_jqem.d(41): Error: cannot modify `immutable` expression `lst[cast(ulong)j][0]`\n/tmp/tmp",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n, m;\n    int p_cnt[2];\n    int p_cnt_max[2];\n    int p_cnt_min[2];\n    int p_cnt_diff[2];\n    int p_cnt_diff_max[2];\n    int p_cnt_diff_min[2];\n    int p_cnt_diff_diff[2];\n    int p_cnt_diff_diff_max[2];\n    int p_cnt_diff_diff_min[2];\n    int p_cnt_diff_diff_diff[2];\n    int p_cnt_diff_diff_diff_max[2];\n    int p_cnt_diff_diff_diff_min[2];\n    int p_cnt_diff_diff_diff_diff[2];\n    int p_cnt_diff_diff_diff_diff_max[2];\n    int p_cnt_diff_diff_diff_diff_min[2];\n    int p_cnt_diff_diff_diff_diff_diff[2];\n    int p_cnt_diff_diff_diff_diff_diff_max[2];\n    int p_cnt_diff_diff_diff_diff_diff_min[2];\n    int p_cnt_diff_diff_diff_diff_diff_diff[2];\n    int p_cnt_diff_diff_diff_diff_diff_diff_max[2];\n    int p_cnt_diff_diff_diff_diff_diff_diff_min[2];\n    int p_cnt_diff_diff_diff_diff_diff_diff_diff[2];\n    int p_cnt_diff_diff_diff_diff_diff_diff_diff_max[2];\n    int p_cnt_diff_diff_diff_diff_diff_diff_diff_min[2];\n    int p_cnt_diff_diff_diff_diff_diff_diff_diff_diff[2];\n    int p_cnt_diff_diff_diff_diff_diff_diff_diff_diff_max[2];\n    int p\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp17z1bbke.d(24): Deprecation: instead of C-style syntax, use D-style syntax `int[2] p_cnt`\n/tmp/tmp17z1bbke.d(25): Deprecation: instead of C-style syntax, use D-style syntax `int[2] p_cnt_max`\n/tmp/tmp17z1bbke.d(26): Deprecation: instead of C-style syntax, use D-style syntax `int[2] p_cnt_min`\n/tmp/tmp17z1bbke.d(27): Deprecation: instead of C-style syntax, use D-style syntax `int[2] p_cnt_diff`\n/tmp/tmp17z1bbke.d(28): Deprecation: instead of C-style syntax, use D-style syntax `int[2] p_cnt_diff_max`\n/tmp/tmp17z1bbke.d(29): Deprecation: instead of C-style syntax, use D-style syntax `int[2] p_cnt_diff_min`\n/tmp/tmp17z1bbke.d(30): Deprecation: instead of C-style syntax, use D-style syntax `int[2] p_cnt_diff_diff`\n/tmp/tmp17z1bbke.d(31): Deprecation: instead of C-style syntax, use D-style syntax `int[2] p_cnt_diff_diff_max`\n/tmp/tmp17z1bbke.d(32): Deprecation: instead of C-style syntax, use D-style syntax `int[2] p_cnt_diff_diff_min`\n/tmp/tmp17z1bbke.d(33): Deprecation: instead of C-style syntax, use D-sty",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    if (n == 0) return \"Yes\";\n    if (n == 1) return \"No\";\n    \n    int i = 0;\n    int j = 1;\n    int k = 0;\n    int p = 0;\n    int q = 0;\n    while (i < n && j < n) {\n        if (lst[i] == '(') {\n            p++;\n        }\n        if (lst[j] == ')') {\n            q++;\n        }\n        if (p == q) {\n            k++;\n        }\n        if (k == 2) {\n            return \"Yes\";\n        }\n        if (p > q) {\n            i++;\n        }\n        if (q > p) {\n            j++;\n        }\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp3pa75vcm.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmp3pa75vcm.d(33): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmp3pa75vcm.d(36): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3pa75vcm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int len = lst.length;\n    if(len == 0) return \"Yes\";\n    if(len == 1) return \"No\";\n    if(len == 2) return \"Yes\";\n    \n    int i = 0, j = 1;\n    while(i < len && j < len)\n    {\n        if(lst[i] == '(' && lst[j] == ')')\n        {\n            i++;\n            j++;\n        }\n        else if(lst[i] == '(')\n        {\n            i++;\n        }\n        else if(lst[j] == ')')\n        {\n            j++;\n        }\n        else\n        {\n            return \"No\";\n        }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp1ml53rd2.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmp1ml53rd2.d(31): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmp1ml53rd2.d(31): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\n/tmp/tmp1ml53rd2.d(36): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmp1ml53rd2.d(40): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1ml53rd2.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    if (n == 0) return \"Yes\";\n    if (n == 1) return \"No\";\n    int i = 0;\n    int j = 1;\n    int p = 0;\n    while (i < n && j < n) {\n        if (lst[i] == '(') p++;\n        if (lst[j] == ')') p--;\n        if (p == 0) {\n            i++;\n            j++;\n        } else {\n            i++;\n        }\n    }\n    if (p == 0) return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpm7_m5csx.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpm7_m5csx.d(30): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpm7_m5csx.d(31): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm7_m5csx.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, l, m;\n    int len = lst.length;\n    int max = len - 1;\n    int min = 0;\n    int count = 0;\n    for(i = 0; i < len; i++)\n    {\n        if(lst[i] == '(')\n            count++;\n        else\n            count--;\n        if(count < 0)\n            return \"No\";\n    }\n    for(i = 0; i < len; i++)\n    {\n        if(lst[i] == '(')\n        {\n            for(j = i + 1; j < len; j++)\n            {\n                if(lst[j] == '(')\n                    count++;\n                else\n                    count--;\n                if(count < 0)\n                    return \"No\";\n            }\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        if(lst[i] == '(')\n        {\n            for(j = i + 1; j < len; j++)\n            {\n                if(lst[j] == '(')\n                    count++;\n                else\n                    count--;\n                if(count < 0)\n                    return \"No\";\n            }\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        if(lst[i] == '(')\n        {\n            for(j = i + 1; j < len; j++)\n            {\n                if(lst[j] == '(')\n                    count++;\n                else\n                    count--;\n                if(count < 0)\n                    return \"No\";\n            }\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        if(lst[i] == '(')\n        {\n            for(j = i + 1; j < len; j++)\n            {\n                if(lst[j] == '(')\n                    count++;\n                else\n                    count--;\n                if(count < 0)\n                    return \"No\";\n            }\n        }\n    }\n    for(i =\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp_wxtk8a3.d(98): Error: expression expected, not `unittest`\n/tmp/tmp_wxtk8a3.d(99): Error: found `{` when expecting `;` following statement\n/tmp/tmp_wxtk8a3.d(100): Error: expression expected, not `alias`\n/tmp/tmp_wxtk8a3.d(100): Error: found `candidate` when expecting `;` following `for` condition\n/tmp/tmp_wxtk8a3.d(100): Error: expression expected, not `=`\n/tmp/tmp_wxtk8a3.d(100): Error: found `match_parens` when expecting `)`\n/tmp/tmp_wxtk8a3.d(100): Error: use `{ }` for an empty statement, not `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_wxtk8a3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    if (n == 0) return \"Yes\";\n    if (n == 1) return \"No\";\n    if (lst[0] == \"\") return \"No\";\n    if (lst[1] == \"\") return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == '(') return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == ')' && lst[1][0] == '(') return \"No\";\n    if (lst[0][0] == ')' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == ')\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpqi5fyqoi.d(42): Error: unterminated character constant\n/tmp/tmpqi5fyqoi.d(43): Error: found `unittest` when expecting `)`\n/tmp/tmpqi5fyqoi.d(60): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqi5fyqoi.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    if(n == 0) return \"Yes\";\n    if(n == 1) return \"No\";\n    if(lst[0] == \"\") return \"No\";\n    if(lst[1] == \"\") return \"No\";\n    if(lst[0][0] == '(' && lst[1][0] == '(') return \"No\";\n    if(lst[0][0] == '(' && lst[1][0] == ')') return \"No\";\n    if(lst[0][0] == ')' && lst[1][0] == '(') return \"No\";\n    if(lst[0][0] == ')' && lst[1][0] == ')') return \"No\";\n    if(lst[0][0] == '(' && lst[1][0] == ')') return \"No\";\n    if(lst[0][0] == ')' && lst[1][0] == ')') return \"No\";\n    if(lst[0][0] == '(' && lst[1][0] == '(') return \"No\";\n    if(lst[0][0] == '(' && lst[1][0] == ')') return \"No\";\n    if(lst[0][0] == '(' && lst[1][0] == ')') return \"No\";\n    if(lst[0][0] == '(' && lst[1][0] == ')') return \"No\";\n    if(lst[0][0] == '(' && lst[1][0] == ')') return \"No\";\n    if(lst[0][0] == '(' && lst[1][0] == ')') return \"No\";\n    if(lst[0][0] == '(' && lst[1][0] == ')') return \"No\";\n    if(lst[0][0] == '(' && lst[1][0] == ')') return \"No\";\n    if(lst[0][0] == '(' && lst[1][0] == ')\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpof9j_j1z.d(42): Error: unterminated character constant\n/tmp/tmpof9j_j1z.d(43): Error: found `unittest` when expecting `)`\n/tmp/tmpof9j_j1z.d(60): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpof9j_j1z.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int len = lst.length;\n    if(len == 0) return \"Yes\";\n    if(len == 1) return \"No\";\n    \n    int i = 0;\n    int j = 1;\n    int count = 0;\n    while(i < len && j < len)\n    {\n        if(lst[i] == '(' && lst[j] == ')')\n        {\n            count++;\n            i++;\n            j++;\n        }\n        else if(lst[i] == '(')\n        {\n            count++;\n            i++;\n        }\n        else if(lst[j] == ')')\n        {\n            count--;\n            j++;\n        }\n        else\n        {\n            i++;\n            j++;\n        }\n    }\n    if(count == 0) return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmperf894_u.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmperf894_u.d(32): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmperf894_u.d(32): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\n/tmp/tmperf894_u.d(38): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmperf894_u.d(43): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmperf894_u.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    if(lst.length == 0)\n        return \"Yes\";\n    \n    int i = 0;\n    int j = lst.length - 1;\n    \n    while(i < j)\n    {\n        if(lst[i] == '(' && lst[j] == ')')\n        {\n            i++;\n            j--;\n        }\n        else if(lst[i] == '(')\n        {\n            return \"No\";\n        }\n        else if(lst[j] == ')')\n        {\n            return \"No\";\n        }\n        else\n        {\n            i++;\n            j--;\n        }\n    }\n    \n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmphab4quu_.d(27): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\n/tmp/tmphab4quu_.d(31): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmphab4quu_.d(31): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\n/tmp/tmphab4quu_.d(36): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmphab4quu_.d(40): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphab4quu_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l,\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpo05xvka8.d(24): Error: no identifier for declarator `int`\n/tmp/tmpo05xvka8.d(24): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo05xvka8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n;\n    int paren_count[2] = {0, 0};\n    for(i = 0; i < lst.length; i++)\n    {\n        if(lst[i] == \")\")\n            paren_count[1]++;\n        else\n            paren_count[0]++;\n    }\n    if(paren_count[0] != paren_count[1])\n        return \"No\";\n    for(i = 0; i < lst.length; i++)\n    {\n        if(lst[i] == \")\")\n            paren_count[1]--;\n        else\n            paren_count[0]--;\n    }\n    for(i = 0; i < lst.length; i++)\n    {\n        if(lst[i] == \")\")\n            paren_count[1]++;\n        else\n            paren_count[0]++;\n    }\n    if(paren_count[0] != paren_count[1])\n        return \"No\";\n    for(i = 0; i < lst.length; i++)\n    {\n        if(lst[i] == \")\")\n            paren_count[1]--;\n        else\n            paren_count[0]--;\n    }\n    for(i = 0; i < lst.length; i++)\n    {\n        if(lst[i] == \")\")\n            paren_count[1]++;\n        else\n            paren_count[0]++;\n    }\n    if(paren_count[0] != paren_count[1])\n        return \"No\";\n    for(i = 0; i < lst.length; i++)\n    {\n        if(lst[i] == \")\")\n            paren_count[1]--;\n        else\n            paren_count[0]--;\n    }\n    for(i = 0; i < lst.length; i++)\n    {\n        if(lst[i] == \")\")\n            paren_count[1]++;\n        else\n            paren_count[0]++;\n    }\n    if(paren_count\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp9hiw274v.d(24): Deprecation: instead of C-style syntax, use D-style syntax `int[2] paren_count`\n/tmp/tmp9hiw274v.d(81): Error: found `unittest` when expecting `)`\n/tmp/tmp9hiw274v.d(98): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9hiw274v.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n, m;\n    int paren_count[2];\n    for (i = 0; i < 2; i++)\n        paren_count[i] = 0;\n    for (i = 0; i < lst.length; i++)\n        for (j = 0; j < lst[i].length(); j++)\n            if (lst[i][j] == '(')\n                paren_count[0]++;\n            else if (lst[i][j] == ')')\n                paren_count[1]++;\n    if (paren_count[0] != paren_count[1])\n        return \"No\";\n    n = lst.length;\n    m = lst[0].length();\n    for (i = 0; i < n; i++)\n        for (j = 0; j < m; j++)\n            if (lst[i][j] == '(')\n                k = 0;\n            else if (lst[i][j] == ')')\n                k = 1;\n            else\n                k = -1;\n    for (i = 0; i < n; i++)\n        for (j = 0; j < m; j++)\n            if (lst[i][j] == '(')\n                k = 0;\n            else if (lst[i][j] == ')')\n                k = 1;\n            else\n                k = -1;\n    if (k == 0)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp7h5j49qw.d(24): Deprecation: instead of C-style syntax, use D-style syntax `int[2] paren_count`\n/tmp/tmp7h5j49qw.d(28): Error: no property `length` for type `string`\n/tmp/tmp7h5j49qw.d(35): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmp7h5j49qw.d(36): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7h5j49qw.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n = lst.length;\n    for (i = 0; i < n; i++) {\n        for (j = i + 1; j < n; j++) {\n            if (lst[i][0] == '(' && lst[j][0] == '(') {\n                for (k = 1; k < lst[i].length(); k++) {\n                    if (lst[i][k] == '(') {\n                        break;\n                    }\n                }\n                for (k = 1; k < lst[j].length(); k++) {\n                    if (lst[j][k] == '(') {\n                        break;\n                    }\n                }\n                if (k == lst[i].length() && k == lst[j].length()) {\n                    return \"Yes\";\n                }\n            }\n        }\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp5j3twobv.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmp5j3twobv.d(27): Error: no property `length` for type `string`\n/tmp/tmp5j3twobv.d(32): Error: no property `length` for type `string`\n/tmp/tmp5j3twobv.d(37): Error: no property `length` for type `string`\n/tmp/tmp5j3twobv.d(37): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5j3twobv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    if(n == 0)\n        return \"Yes\";\n    if(n == 1)\n        return \"No\";\n    int i = 0, j = 0;\n    while(i < n && j < n)\n    {\n        if(lst[i] == '(')\n        {\n            if(lst[j] == ')')\n            {\n                i++;\n                j++;\n            }\n            else\n                return \"No\";\n        }\n        else if(lst[j] == ')')\n            return \"No\";\n        else\n            i++;\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpflvt9wp2.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpflvt9wp2.d(31): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpflvt9wp2.d(33): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\n/tmp/tmpflvt9wp2.d(41): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpflvt9wp2.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n, m;\n    string s;\n    for(i = 0; i < lst.length; i++)\n    {\n        if(lst[i] == \")\")\n        {\n            n = 0;\n            for(j = i - 1; j >= 0; j--)\n            {\n                if(lst[j] == \"(\")\n                    n++;\n                else\n                    break;\n            }\n            if(n == 0)\n                return \"Yes\";\n        }\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp1m01mses.d(48): unittest failure\n----------------\n??:? _d_unittestp [0x42905d]\n??:? void tmp1m01mses.__unittest_L43_C1() [0x427d26]\n??:? void tmp1m01mses.__modtest() [0x4282c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428db6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a859]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7e5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d8d]\n??:? runModuleUnitTests [0x42d781]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429520]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, n = lst.length;\n    for(i = 0; i < n; i++)\n    {\n        for(j = i + 1; j < n; j++)\n        {\n            if(lst[i][0] == '(' && lst[j][0] == ')')\n            {\n                if(lst[i][1] == lst[j][1])\n                {\n                    lst[i] = lst[i][0] + lst[i][1] + lst[i][2];\n                    lst[j] = lst[j][0] + lst[j][1] + lst[j][2];\n                }\n                else\n                {\n                    lst[i] = lst[i][0] + lst[i][1] + lst[i][2];\n                    lst[j] = lst[j][0] + lst[j][1] + lst[j][2];\n                }\n            }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        if(lst[i][0] == '(')\n            return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpf8si2lxg.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpf8si2lxg.d(32): Error: cannot implicitly convert expression `cast(int)lst[cast(ulong)i][0] + cast(int)lst[cast(ulong)i][1] + cast(int)lst[cast(ulong)i][2]` of type `int` to `string`\n/tmp/tmpf8si2lxg.d(33): Error: cannot implicitly convert expression `cast(int)lst[cast(ulong)j][0] + cast(int)lst[cast(ulong)j][1] + cast(int)lst[cast(ulong)j][2]` of type `int` to `string`\n/tmp/tmpf8si2lxg.d(37): Error: cannot implicitly convert expression `cast(int)lst[cast(ulong)i][0] + cast(int)lst[cast(ulong)i][1] + cast(int)lst[cast(ulong)i][2]` of type `int` to `string`\n/tmp/tmpf8si2lxg.d(38): Error: cannot implicitly convert expression `cast(int)lst[cast(ulong)j][0] + cast(int)lst[cast(ulong)j][1] + cast(int)lst[cast(ulong)j][2]` of type `int` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf8si2lxg.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int len = lst.length;\n    int i, j, k;\n    int left_count = 0;\n    int right_count = 0;\n    for (i = 0; i < len; i++) {\n        if (lst[i] == '(') {\n            left_count++;\n        }\n        if (lst[i] == ')') {\n            right_count++;\n        }\n    }\n    if (left_count == right_count) {\n        return \"Yes\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpt4vr0c1r.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpt4vr0c1r.d(28): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpt4vr0c1r.d(31): Error: incompatible types for `(lst[cast(ulong)i]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt4vr0c1r.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    if (n == 0) return \"Yes\";\n    if (n == 1) return \"No\";\n    if (lst[0] == \"\") return \"No\";\n    if (lst[n-1] == \"\") return \"No\";\n    \n    int i = 0;\n    int j = n-1;\n    int count = 0;\n    while (i < j) {\n        if (lst[i] == \")\") count++;\n        if (lst[j] == \"(\") count--;\n        if (count < 0) return \"No\";\n        i++;\n        j--;\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp_zggwfub.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_zggwfub.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n, m;\n    n = lst.length;\n    m = n - 1;\n    for (i = 0; i < n; i++) {\n        if (lst[i] == \")\") {\n            for (j = i + 1; j < n; j++) {\n                if (lst[j] == \"(\") {\n                    k = j - 1;\n                    while (k >= 0 && lst[k] != \")\") {\n                        k--;\n                    }\n                    if (k < 0) {\n                        return \"No\";\n                    }\n                    else {\n                        i = j;\n                        m = k;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpxrvl_syj.d(24): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxrvl_syj.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n = lst.length;\n    for(i = 0; i < n; i++)\n    {\n        for(j = i + 1; j < n; j++)\n        {\n            if(lst[i][0] == '(' && lst[j][0] == '(')\n            {\n                for(k = 0; k < lst[i].length(); k++)\n                {\n                    if(lst[i][k] == '(')\n                        break;\n                }\n                for(k = 0; k < lst[j].length(); k++)\n                {\n                    if(lst[j][k] == '(')\n                        break;\n                }\n                if(k == lst[i].length() && k == lst[j].length())\n                {\n                    if(lst[i].substr(k) == lst[j].substr(k))\n                        return \"Yes\";\n                }\n            }\n        }\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpd6xu5g98.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpd6xu5g98.d(30): Error: no property `length` for type `string`\n/tmp/tmpd6xu5g98.d(35): Error: no property `length` for type `string`\n/tmp/tmpd6xu5g98.d(40): Error: no property `length` for type `string`\n/tmp/tmpd6xu5g98.d(40): Error: no property `length` for type `string`\n/tmp/tmpd6xu5g98.d(42): Error: no property `substr` for type `string`\n/tmp/tmpd6xu5g98.d(42): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd6xu5g98.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    if (n == 0) return \"Yes\";\n    if (n == 1) return \"No\";\n    \n    int i = 0, j = 1;\n    while (i < n && j < n) {\n        if (lst[i] == '(' && lst[j] == ')') {\n            i++;\n            j++;\n        } else if (lst[i] == '(') {\n            i++;\n        } else if (lst[j] == ')') {\n            j++;\n        } else {\n            return \"No\";\n        }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpyfo9gmg6.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpyfo9gmg6.d(29): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpyfo9gmg6.d(29): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\n/tmp/tmpyfo9gmg6.d(32): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpyfo9gmg6.d(34): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyfo9gmg6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n, m, p;\n    string s;\n    for(i = 0; i < lst.length; i++)\n    {\n        if(lst[i].length() == 0)\n            continue;\n        if(lst[i][0] == '(')\n            n = 1;\n        else\n            n = 0;\n        for(j = 1; j < lst[i].length(); j++)\n        {\n            if(lst[i][j] == '(')\n                n++;\n            else\n                n--;\n            if(n < 0)\n                return \"No\";\n        }\n    }\n    for(i = 0; i < lst.length; i++)\n    {\n        if(lst[i].length() == 0)\n            continue;\n        if(lst[i][0] == '(')\n            n = 1;\n        else\n            n = 0;\n        for(j = 1; j < lst[i].length(); j++)\n        {\n            if(lst[i][j] == '(')\n                n++;\n            else\n                n--;\n            if(n < 0)\n                return \"No\";\n        }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpxce1s87u.d(27): Error: no property `length` for type `string`\n/tmp/tmpxce1s87u.d(33): Error: no property `length` for type `string`\n/tmp/tmpxce1s87u.d(45): Error: no property `length` for type `string`\n/tmp/tmpxce1s87u.d(51): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxce1s87u.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, n = lst.length;\n    for (i = 0; i < n; i++) {\n        for (j = i + 1; j < n; j++) {\n            if (lst[i][0] == '(' && lst[j][0] == ')') {\n                if (lst[i][1] == lst[j][1]) {\n                    lst[i] = lst[i][0] + lst[i][1] + lst[i][2];\n                    lst[j] = lst[j][0] + lst[j][1] + lst[j][2];\n                    lst[i] = lst[i][0] + lst[i][1] + lst[i][2];\n                    lst[j] = lst[j][0] + lst[j][1] + lst[j][2];\n                    lst[i] = lst[i][0] + lst[i][1] + lst[i][2];\n                    lst[j] = lst[j][0] + lst[j][1] + lst[j][2];\n                    lst[i] = lst[i][0] + lst[i][1] + lst[i][2];\n                    lst[j] = lst[j][0] + lst[j][1] + lst[j][2];\n                    lst[i] = lst[i][0] + lst[i][1] + lst[i][2];\n                    lst[j] = lst[j][0] + lst[j][1] + lst[j][2];\n                    lst[i] = lst[i][0] + lst[i][1] + lst[i][2];\n                    lst[j] = lst[j][0] + lst[j][1] + lst[j][2];\n                    lst[i] = lst[i][0] + lst[i][1] + lst[i][2];\n                    lst[j] = lst[j][0]\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpmpjstpzb.d(42): Error: found `unittest` when expecting `;` following statement\n/tmp/tmpmpjstpzb.d(59): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpmpjstpzb.d(59): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpmpjstpzb.d(59): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpmpjstpzb.d(59): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpmpjstpzb.d(59): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmpjstpzb.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n = lst.length;\n    int p_cnt = 0, c_cnt = 0;\n    for (i = 0; i < n; i++) {\n        if (lst[i] == '(') p_cnt++;\n        if (lst[i] == ')') c_cnt++;\n    }\n    if (p_cnt != c_cnt) return \"No\";\n    for (i = 0; i < n; i++) {\n        if (lst[i] == '(') {\n            for (j = i + 1; j < n; j++) {\n                if (lst[j] == '(') p_cnt++;\n                if (lst[j] == ')') c_cnt++;\n            }\n            if (p_cnt != c_cnt) return \"No\";\n        }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmphqliainz.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmphqliainz.d(26): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmphqliainz.d(27): Error: incompatible types for `(lst[cast(ulong)i]) == (')')`: `string` and `char`\n/tmp/tmphqliainz.d(31): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmphqliainz.d(33): Error: incompatible types for `(lst[cast(ulong)j]) == ('(')`: `string` and `char`\n/tmp/tmphqliainz.d(34): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphqliainz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n = lst.length;\n    for (i = 0; i < n; i++) {\n        for (j = i + 1; j < n; j++) {\n            if (lst[i][0] == '(' && lst[j][0] == '(') {\n                for (k = 1; k < lst[i].length(); k++) {\n                    if (lst[i][k] == '(') {\n                        break;\n                    }\n                }\n                for (k = 1; k < lst[j].length(); k++) {\n                    if (lst[j][k] == '(') {\n                        break;\n                    }\n                }\n                if (k == lst[i].length() && k == lst[j].length()) {\n                    return \"Yes\";\n                }\n            }\n        }\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp5j3twobv.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmp5j3twobv.d(27): Error: no property `length` for type `string`\n/tmp/tmp5j3twobv.d(32): Error: no property `length` for type `string`\n/tmp/tmp5j3twobv.d(37): Error: no property `length` for type `string`\n/tmp/tmp5j3twobv.d(37): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5j3twobv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, n = lst.length;\n    for(i = 0; i < n; i++) {\n        for(j = i + 1; j < n; j++) {\n            if(lst[i][0] == '(' && lst[j][0] == ')') {\n                if(lst[i][1] == lst[j][1]) {\n                    lst[i] = lst[i][0] + lst[i][1] + lst[i][2];\n                    lst[j] = lst[j][0] + lst[j][1] + lst[j][2];\n                }\n            }\n        }\n    }\n    for(i = 0; i < n; i++) {\n        if(lst[i][0] == '(') {\n            return \"No\";\n        }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpqtepa4cw.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpqtepa4cw.d(28): Error: cannot implicitly convert expression `cast(int)lst[cast(ulong)i][0] + cast(int)lst[cast(ulong)i][1] + cast(int)lst[cast(ulong)i][2]` of type `int` to `string`\n/tmp/tmpqtepa4cw.d(29): Error: cannot implicitly convert expression `cast(int)lst[cast(ulong)j][0] + cast(int)lst[cast(ulong)j][1] + cast(int)lst[cast(ulong)j][2]` of type `int` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqtepa4cw.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    if (n == 0) return \"Yes\";\n    if (n == 1) return \"No\";\n    \n    int i = 0;\n    int j = 1;\n    int p = 0;\n    int q = 0;\n    \n    while (i < n && j < n) {\n        if (lst[i] == '(') p++;\n        if (lst[j] == ')') q++;\n        if (p == q) {\n            i++;\n            j++;\n        } else if (p > q) {\n            j++;\n        } else {\n            i++;\n        }\n    }\n    \n    if (p == q) return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpqwzh0gjf.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpqwzh0gjf.d(33): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpqwzh0gjf.d(34): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqwzh0gjf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    if (n == 0) return \"Yes\";\n    if (n == 1) return \"No\";\n    if (lst[0] == \")\") return \"No\";\n    if (lst[n-1] == \"(\" && lst[0] == \"(\") return \"No\";\n    if (lst[0] == \"(\" && lst[n-1] == \")\") return \"No\";\n    if (lst[0] == \"(\" && lst[n-1] == \")\") return \"No\";\n    if (lst[0] == \"(\" && lst[n-1] == \"(\" && lst[1] == \")\") return \"No\";\n    if (lst[0] == \"(\" && lst[n-1] == \"(\" && lst[n-2] == \")\") return \"No\";\n    if (lst[0] == \"(\" && lst[n-1] == \"(\" && lst[n-2] == \"(\" && lst[n-3] == \")\") return \"No\";\n    if (lst[0] == \"(\" && lst[n-1] == \"(\" && lst[n-2] == \"(\" && lst[n-3] == \"(\" && lst[n-4] == \")\") return \"No\";\n    if (lst[0] == \"(\" && lst[n-1] == \"(\" && lst[n-2] == \"(\" && lst[n-3] == \"(\" && lst[n-4] == \"(\" && lst[n-5] == \")\") return \"No\";\n    if (lst[0] == \"(\" && lst[n-1] == \"(\" && lst[n-2] == \"(\" && lst[n-3] == \"(\" && lst[n-4] == \"(\" && lst[n-5] == \"(\" && lst[n-6] == \")\") return \"No\";\n    if (lst[0] == \"(\" && lst[n-1] == \"(\" && lst[n-2] == \"(\" &&\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp_ojw3mvu.d(37): Error: expression expected, not `unittest`\n/tmp/tmp_ojw3mvu.d(38): Error: found `{` when expecting `)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_ojw3mvu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n, m, p;\n    bool flag;\n    string s;\n    \n    for(i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == '(')\n        {\n            p = 1;\n            for(j = 1; j < lst[i].length(); j++)\n            {\n                if(lst[i][j] == '(')\n                {\n                    p++;\n                }\n                else if(lst[i][j] == ')')\n                {\n                    p--;\n                }\n                if(p < 0)\n                {\n                    return \"No\";\n                }\n            }\n        }\n    }\n    \n    for(i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == '(')\n        {\n            p = 1;\n            for(j = 1; j < lst[i].length(); j++)\n            {\n                if(lst[i][j] == '(')\n                {\n                    p++;\n                }\n                else if(lst[i][j] == ')')\n                {\n                    p--;\n                }\n                if(p < 0)\n                {\n                    return \"No\";\n                }\n            }\n        }\n    }\n    \n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpgjm4dg7v.d(32): Error: no property `length` for type `string`\n/tmp/tmpgjm4dg7v.d(55): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgjm4dg7v.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    if (n == 0) return \"Yes\";\n    if (n == 1) return \"No\";\n    \n    int i = 0, j = 1;\n    while (i < n && j < n) {\n        if (lst[i] == '(' && lst[j] == ')') {\n            i++;\n            j++;\n        } else if (lst[i] == '(') {\n            i++;\n        } else if (lst[j] == ')') {\n            j++;\n        } else {\n            return \"No\";\n        }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpyfo9gmg6.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpyfo9gmg6.d(29): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpyfo9gmg6.d(29): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\n/tmp/tmpyfo9gmg6.d(32): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpyfo9gmg6.d(34): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyfo9gmg6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    if (n == 0) return \"Yes\";\n    if (n == 1) return \"No\";\n    if (lst[0] == \"\") return \"No\";\n    if (lst[1] == \"\") return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == '(') return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == ')' && lst[1][0] == '(') return \"No\";\n    if (lst[0][0] == ')' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == ')' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == '(') return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == ')' && lst[1][0] == '(') return \"No\";\n    if (lst[0][0] == ')' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == '(') return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == ')' && lst[1][0] == '(') return \"No\";\n    if (lst[0][0] == ')' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == '('\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpcq45o36e.d(43): Error: found `unittest` when expecting `)`\n/tmp/tmpcq45o36e.d(60): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcq45o36e.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int len = lst.length;\n    if(len == 0) return \"Yes\";\n    if(len == 1) return \"No\";\n    int i = 0;\n    int j = len - 1;\n    int count = 0;\n    while(i < j)\n    {\n        if(lst[i] == '(')\n            count++;\n        else if(lst[j] == ')')\n            count--;\n        i++;\n        j--;\n    }\n    if(count == 0) return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp3o_6zzy2.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmp3o_6zzy2.d(31): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmp3o_6zzy2.d(33): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3o_6zzy2.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    if (n == 0) return \"Yes\";\n    if (n == 1) return \"No\";\n    int i = 0;\n    int j = 1;\n    while (i < n && j < n) {\n        if (lst[i] == '(' && lst[j] == ')') {\n            i++;\n            j++;\n        } else if (lst[i] == '(') {\n            i++;\n        } else if (lst[j] == ')') {\n            j++;\n        } else {\n            return \"No\";\n        }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp6a5e0x51.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmp6a5e0x51.d(29): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmp6a5e0x51.d(29): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\n/tmp/tmp6a5e0x51.d(32): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmp6a5e0x51.d(34): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6a5e0x51.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    int i = 0, j = 0;\n    int p = 0;\n    while (i < n && j < n) {\n        if (lst[i] == '(') {\n            p++;\n        } else if (lst[j] == ')') {\n            p--;\n        }\n        if (p < 0) {\n            return \"No\";\n        }\n        i++;\n        j++;\n    }\n    if (p == 0) {\n        return \"Yes\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpqmblwtky.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpqmblwtky.d(27): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpqmblwtky.d(29): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqmblwtky.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, n = lst.length;\n    for (i = 0; i < n; i++) {\n        if (lst[i][0] != '(')\n            return \"No\";\n        for (j = 1; j < lst[i].length(); j++) {\n            if (lst[i][j] == '(')\n                break;\n        }\n        if (j == lst[i].length())\n            return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp2eqd7f3i.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmp2eqd7f3i.d(27): Error: no property `length` for type `string`\n/tmp/tmp2eqd7f3i.d(31): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2eqd7f3i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n, m, p, q;\n    int p_count, q_count;\n    \n    if (lst.length == 0) return \"No\";\n    \n    p_count = q_count = 0;\n    for (i = 0; i < lst.length; i++) {\n        if (lst[i] == '(') p_count++;\n        if (lst[i] == ')') q_count++;\n    }\n    \n    if (p_count == 0 || q_count == 0) return \"No\";\n    \n    if (p_count == q_count) {\n        for (i = 0; i < lst.length; i++) {\n            if (lst[i] == '(') {\n                for (j = i + 1; j < lst.length; j++) {\n                    if (lst[j] == ')') {\n                        if (j - i < 2) return \"No\";\n                        for (k = i + 1; k < j; k++) {\n                            if (lst[k] == '(') {\n                                return \"No\";\n                            }\n                        }\n                        return \"Yes\";\n                    }\n                }\n            }\n        }\n    }\n    \n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpi7otpijj.d(30): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpi7otpijj.d(31): Error: incompatible types for `(lst[cast(ulong)i]) == (')')`: `string` and `char`\n/tmp/tmpi7otpijj.d(38): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpi7otpijj.d(40): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\n/tmp/tmpi7otpijj.d(43): Error: incompatible types for `(lst[cast(ulong)k]) == ('(')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi7otpijj.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    if(lst.length == 0)\n        return \"Yes\";\n    if(lst.length == 1)\n        return \"No\";\n    if(lst[0] == \"\")\n        return \"No\";\n    if(lst[1] == \"\")\n        return \"No\";\n    if(lst[0][0] == '(' && lst[0][lst[0].length()-1] == ')')\n        return \"Yes\";\n    if(lst[1][0] == '(' && lst[1][lst[1].length()-1] == ')')\n        return \"Yes\";\n    if(lst[0][0] == '(' && lst[1][0] == '(')\n        return \"Yes\";\n    if(lst[0][0] == '(' && lst[1][lst[1].length()-1] == ')')\n        return \"Yes\";\n    if(lst[0][lst[0].length()-1] == '(' && lst[1][0] == '(')\n        return \"Yes\";\n    if(lst[0][lst[0].length()-1] == '(' && lst[1][lst[1].length()-1] == ')')\n        return \"Yes\";\n    if(lst[0][0] == '(' && lst[1][0] == '(')\n        return \"Yes\";\n    if(lst[0][lst[0].length()-1] == '(' && lst[1][lst[1].length()-1] == ')')\n        return \"Yes\";\n    if(lst[0][0] == '(' && lst[1][lst[1].length()-1] == '(')\n        return \"Yes\";\n    if(lst[0][lst[0].length()-1] == '(' && lst[1][lst[1].length()-1] == '(')\n        return \"Yes\";\n    if(lst[0][0] == '(' && lst[1][0] == '(')\n        return \"Yes\";\n\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpes2tc4tz.d(54): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpes2tc4tz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, len = lst.length;\n    for (i = 0; i < len; i++) {\n        for (j = i + 1; j < len; j++) {\n            for (k = 0; k < len - i - j; k++) {\n                if (lst[i][k] == '(' && lst[j][k] == ')') {\n                    if (match_parens(lst[i] + lst[j]) == \"Yes\") {\n                        return \"Yes\";\n                    }\n                }\n            }\n        }\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpgxbq7aov.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpgxbq7aov.d(28): Error: invalid array operation `lst[cast(ulong)i] + lst[cast(ulong)j]` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgxbq7aov.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, len = lst.length;\n    for (i = 0; i < len; i++)\n        for (j = i + 1; j < len; j++)\n            if (lst[i][0] == '(' && lst[j][0] == ')')\n                return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpwf_e0gva.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwf_e0gva.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n = lst.length;\n    for (i = 0; i < n; i++) {\n        for (j = i + 1; j < n; j++) {\n            for (k = 0; k < n; k++) {\n                if (lst[i][k] == '(' && lst[j][k] == ')') {\n                    if (k == 0) {\n                        if (lst[i][k + 1] == '(' || lst[j][k + 1] == '(') {\n                            continue;\n                        }\n                    }\n                    if (lst[i][k + 1] == '(' || lst[j][k + 1] == '(') {\n                        continue;\n                    }\n                    if (lst[i][k + 1] == ')' || lst[j][k + 1] == ')') {\n                        continue;\n                    }\n                    if (lst[i][k + 1] == ')' || lst[j][k + 1] == ')') {\n                        continue;\n                    }\n                    if (lst[i][k + 1] == '(' || lst[j][k + 1] == '(') {\n                        continue;\n                    }\n                    if (lst[i][k + 1] == '(' || lst[j][k + 1] == '(') {\n                        continue;\n                    }\n                    if (lst[i][k + 1] == '(' || lst[j][k + 1] == '(') {\n                        continue;\n                    }\n                    if (lst[i][k + 1] == '(' || lst[j][k + 1] == '(') {\n                        continue;\n                    }\n                    if (lst[i][k + 1] == '(' || lst[j][k + 1] == '(') {\n                        continue;\n                    }\n                    if (lst[i][k + 1] == '(' || lst[j][k + 1] == '(') {\n                        continue;\n                    }\n                    if (lst[i][k + 1] == '(' || lst[j][k + 1] == '('\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp10u5h9rq.d(61): Error: found `unittest` when expecting `)`\n/tmp/tmp10u5h9rq.d(78): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp10u5h9rq.d(78): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp10u5h9rq.d(78): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp10u5h9rq.d(78): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp10u5h9rq.d(78): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp10u5h9rq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int len = lst.length;\n    if(len == 0) return \"Yes\";\n    if(len == 1) return \"No\";\n    int i = 0;\n    int j = 1;\n    int count = 0;\n    while(i < len && j < len) {\n        if(lst[i] == '(' && lst[j] == ')') {\n            count++;\n            i++;\n            j++;\n        }\n        else if(lst[i] == '(') {\n            count++;\n            i++;\n        }\n        else if(lst[j] == ')') {\n            count--;\n            j++;\n        }\n        else {\n            i++;\n            j++;\n        }\n    }\n    if(count == 0) return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpdxeuue87.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpdxeuue87.d(30): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpdxeuue87.d(30): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\n/tmp/tmpdxeuue87.d(35): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpdxeuue87.d(39): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdxeuue87.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n, m, p;\n    bool flag;\n    \n    n = lst.length;\n    for(i = 0; i < n; i++)\n    {\n        if(lst[i][0] == '(')\n            p = 1;\n        else\n            p = -1;\n        \n        for(j = i + 1; j < n; j++)\n        {\n            if(lst[j][0] == '(')\n                p++;\n            else\n                p--;\n            \n            if(p == 0)\n                break;\n        }\n        \n        if(p != 0)\n            return \"No\";\n        \n        flag = true;\n        for(k = i + 1; k < j; k++)\n        {\n            if(lst[k][0] != '(' && lst[k][0] != ')')\n            {\n                flag = false;\n                break;\n            }\n        }\n        \n        if(flag)\n            return \"Yes\";\n    }\n    \n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpkatdj3pa.d(26): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkatdj3pa.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, l, m, n, p;\n    bool flag = true;\n    for(i = 0; i < lst.length; i++)\n    {\n        for(j = 0; j < lst[i].length(); j++)\n        {\n            if(lst[i][j] == '(')\n            {\n                p = 1;\n                k = j;\n                while(k < lst[i].length() && p > 0)\n                {\n                    if(lst[i][k] == '(')\n                        p++;\n                    else if(lst[i][k] == ')')\n                        p--;\n                    k++;\n                }\n                if(p == 0)\n                {\n                    flag = false;\n                    break;\n                }\n            }\n        }\n    }\n    return flag ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpzzp52sni.d(27): Error: no property `length` for type `string`\n/tmp/tmpzzp52sni.d(33): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzzp52sni.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, l, m, n, p;\n    int len = lst.length;\n    for(i = 0; i < len; i++)\n    {\n        if(lst[i] == \")\")\n        {\n            for(j = i + 1; j < len; j++)\n            {\n                if(lst[j] == \"(\")\n                {\n                    p = j;\n                    break;\n                }\n            }\n            if(j == len)\n                return \"No\";\n            for(k = i + 1; k < p; k++)\n            {\n                if(lst[k] == \")\")\n                    return \"No\";\n            }\n            for(l = p + 1; l < j; l++)\n            {\n                if(lst[l] == \"(\")\n                    return \"No\";\n            }\n            for(m = p + 1; m < j; m++)\n            {\n                if(lst[m] == \")\")\n                    return \"No\";\n            }\n            for(n = p + 1; n < j; n++)\n            {\n                if(lst[n] == \"(\" && lst[n - 1] == \")\")\n                    return \"No\";\n            }\n            for(k = p + 1; k < j; k++)\n            {\n                if(lst[k] == \"(\" && lst[k - 1] == \")\")\n                    return \"No\";\n            }\n            for(l = p + 1; l < j; l++)\n            {\n                if(lst[l] == \"(\" && lst[l - 1] == \")\")\n                    return \"No\";\n            }\n            for(m = p + 1; m < j; m++)\n            {\n                if(lst[m] == \"(\" && lst[m - 1] == \")\")\n                    return \"No\";\n            }\n            for(n = p + 1; n < j; n++)\n            {\n                if(lst[n] == \"(\" && lst[n - 1] == \")\")\n                    return \"No\";\n            }\n            for(k\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpa1rqyxg6.d(80): Error: found `unittest` when expecting `;` following statement\n/tmp/tmpa1rqyxg6.d(97): Error: found `void` when expecting `;` following `for` condition\n/tmp/tmpa1rqyxg6.d(97): Error: found `{` when expecting `)`\n/tmp/tmpa1rqyxg6.d(97): Error: found `}` instead of statement\n/tmp/tmpa1rqyxg6.d(97): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpa1rqyxg6.d(97): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa1rqyxg6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int len = lst.length;\n    if (len == 0) return \"Yes\";\n    if (len == 1) return \"No\";\n    \n    int i = 0;\n    int j = len - 1;\n    while (i < j) {\n        if (lst[i] == '(' && lst[j] == ')') {\n            i++;\n            j--;\n        } else if (lst[i] == '(') {\n            j--;\n        } else if (lst[j] == ')') {\n            i++;\n        } else {\n            return \"No\";\n        }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpsqfp_6nv.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpsqfp_6nv.d(30): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpsqfp_6nv.d(30): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\n/tmp/tmpsqfp_6nv.d(33): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpsqfp_6nv.d(35): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsqfp_6nv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n = lst.length;\n    for (i = 0; i < n; i++) {\n        for (j = i + 1; j < n; j++) {\n            if (lst[i][0] == '(' && lst[j][0] == '(') {\n                k = 0;\n                while (lst[i][k] == '(' && lst[j][k] == '(') {\n                    k++;\n                }\n                if (k > 0) {\n                    lst[i] = lst[i][k];\n                    lst[j] = lst[j][k];\n                }\n            }\n        }\n    }\n    for (i = 0; i < n; i++) {\n        if (lst[i][0] == '(') {\n            return \"No\";\n        }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpmoq9_ncs.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpmoq9_ncs.d(32): Error: cannot implicitly convert expression `lst[cast(ulong)i][cast(ulong)k]` of type `immutable(char)` to `string`\n/tmp/tmpmoq9_ncs.d(33): Error: cannot implicitly convert expression `lst[cast(ulong)j][cast(ulong)k]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmoq9_ncs.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    if (n == 0) return \"Yes\";\n    if (n == 1) return \"No\";\n    \n    int i = 0;\n    int j = n - 1;\n    while (i < j) {\n        if (lst[i][0] == '(' && lst[j][0] == ')') {\n            lst[i] = lst[i][1] + lst[i][2];\n            lst[j] = lst[j][1] + lst[j][2];\n            i++;\n            j--;\n        } else if (lst[i][0] == '(' && lst[j][0] == ')') {\n            lst[i] = lst[i][1] + lst[i][2];\n            lst[j] = lst[j][1] + lst[j][2];\n            i++;\n            j--;\n        } else if (lst[i][0] == '(' && lst[j][0] == '(') {\n            lst[i] = lst[i][1] + lst[i][2];\n            lst[j] = lst[j][1] + lst[j][2];\n            i++;\n            j--;\n        } else if (lst[i][0] == '(' && lst[j][0] == ')') {\n            lst[i] = lst[i][1] + lst[i][2];\n            lst[j] = lst[j][1] + lst[j][2];\n            i++;\n            j--;\n        } else if (lst[i][0] == '(' && lst[j][0] == '(') {\n            lst[i] = lst[i][1] + lst[i][2];\n            lst[j] = lst[j][1] + lst[j][2];\n            i++;\n            j--;\n        } else if (lst[i][0] == '(' && lst[j][0] == ')') {\n            l\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmph4gqefu8.d(57): Error: found `unittest` when expecting `;` following statement\n/tmp/tmph4gqefu8.d(74): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmph4gqefu8.d(74): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmph4gqefu8.d(74): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph4gqefu8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n = lst.length;\n    for (i = 0; i < n; i++) {\n        for (j = i + 1; j < n; j++) {\n            for (k = 0; k < n; k++) {\n                if (lst[i][k] == '(' && lst[j][k] == ')') {\n                    if (k == 0 || lst[i][k - 1] != '(' || lst[j][k + 1] != ')')\n                        return \"Yes\";\n                }\n            }\n        }\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpeaem_vx8.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeaem_vx8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, n = lst.length;\n    for (i = 0; i < n; i++) {\n        for (j = i + 1; j < n; j++) {\n            if (lst[i][0] == '(' && lst[j][0] == ')') {\n                if (lst[i][1] == lst[j][1]) {\n                    lst[i] = lst[i][0] + lst[i][1] + lst[i][2];\n                    lst[j] = lst[j][0] + lst[j][1] + lst[j][2];\n                    lst[i] = lst[i][0] + lst[i][1] + lst[i][2];\n                    lst[j] = lst[j][0] + lst[j][1] + lst[j][2];\n                }\n            }\n        }\n    }\n    for (i = 0; i < n; i++) {\n        if (lst[i][0] == '(')\n            return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp9h4wj2c8.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmp9h4wj2c8.d(28): Error: cannot implicitly convert expression `cast(int)lst[cast(ulong)i][0] + cast(int)lst[cast(ulong)i][1] + cast(int)lst[cast(ulong)i][2]` of type `int` to `string`\n/tmp/tmp9h4wj2c8.d(29): Error: cannot implicitly convert expression `cast(int)lst[cast(ulong)j][0] + cast(int)lst[cast(ulong)j][1] + cast(int)lst[cast(ulong)j][2]` of type `int` to `string`\n/tmp/tmp9h4wj2c8.d(30): Error: cannot implicitly convert expression `cast(int)lst[cast(ulong)i][0] + cast(int)lst[cast(ulong)i][1] + cast(int)lst[cast(ulong)i][2]` of type `int` to `string`\n/tmp/tmp9h4wj2c8.d(31): Error: cannot implicitly convert expression `cast(int)lst[cast(ulong)j][0] + cast(int)lst[cast(ulong)j][1] + cast(int)lst[cast(ulong)j][2]` of type `int` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9h4wj2c8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    if (lst.length == 0) return \"Yes\";\n    if (lst.length == 1) return \"No\";\n    \n    int i = 0;\n    int j = 0;\n    int p = 0;\n    int q = 0;\n    int l = lst[0].length();\n    int r = lst[1].length();\n    \n    while (i < l && j < r) {\n        if (lst[0][i] == '(') {\n            p++;\n        }\n        if (lst[1][j] == '(') {\n            q++;\n        }\n        if (lst[0][i] == ')') {\n            p--;\n        }\n        if (lst[1][j] == ')') {\n            q--;\n        }\n        if (p == 0 && q == 0) {\n            i++;\n            j++;\n        } else {\n            if (p < 0 || q < 0) return \"No\";\n        }\n    }\n    \n    if (p == 0 && q == 0) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp5881nqs_.d(30): Error: no property `length` for type `string`\n/tmp/tmp5881nqs_.d(31): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5881nqs_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int len = lst.length;\n    if(len == 0)\n        return \"No\";\n    if(len == 1)\n        return \"Yes\";\n    int i = 0;\n    int j = len - 1;\n    while(i < j)\n    {\n        if(lst[i] == '(' && lst[j] == ')')\n        {\n            lst[i] = ')';\n            lst[j] = '(';\n        }\n        else if(lst[i] == '(' && lst[j] == ')')\n        {\n            lst[i] = '(';\n            lst[j] = ')';\n        }\n        else if(lst[i] == '(' && lst[j] == '(')\n        {\n            lst[i] = ')';\n            lst[j] = '(';\n        }\n        else if(lst[i] == '(' && lst[j] == ')')\n        {\n            lst[i] = '(';\n            lst[j] = ')';\n        }\n        else if(lst[i] == '(' && lst[j] == ')')\n        {\n            lst[i] = '(';\n            lst[j] = ')';\n        }\n        else if(lst[i] == '(' && lst[j] == '(')\n        {\n            lst[i] = ')';\n            lst[j] = '(';\n        }\n        else if(lst[i] == '(' && lst[j] == ')')\n        {\n            lst[i] = '(';\n            lst[j] = ')';\n        }\n        else if(lst[i] == '(' && lst[j] == '(')\n        {\n            lst[i] = ')';\n            lst[j] = '(';\n        }\n        else if(lst[i] == '(' && lst[j] == ')')\n        {\n            lst[i] = '(';\n            \nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpu4uxqv2h.d(76): Error: found `unittest` instead of statement\n/tmp/tmpu4uxqv2h.d(93): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpu4uxqv2h.d(93): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu4uxqv2h.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    if(lst.length == 0)\n        return \"No\";\n    \n    int i = 0;\n    int j = lst.length - 1;\n    \n    while(i < j)\n    {\n        if(lst[i] == '(' && lst[j] == ')')\n        {\n            lst[i] = ')';\n            lst[j] = '(';\n        }\n        else if(lst[i] == '(' && lst[j] == '(')\n        {\n            lst[i] = ')';\n            lst[j] = '(';\n            i++;\n            j--;\n        }\n        else if(lst[i] == '(' && lst[j] == ')')\n        {\n            lst[i] = '(';\n            lst[j] = ')';\n            i++;\n            j--;\n        }\n        else if(lst[i] == '(' && lst[j] == ')')\n        {\n            lst[i] = '(';\n            lst[j] = ')';\n            i++;\n            j--;\n        }\n        else if(lst[i] == '(' && lst[j] == '(')\n        {\n            lst[i] = '(';\n            lst[j] = '(';\n            i++;\n            j--;\n        }\n        else if(lst[i] == '(' && lst[j] == ')')\n        {\n            lst[i] = '(';\n            lst[j] = ')';\n            i++;\n            j--;\n        }\n        else if(lst[i] == '(' && lst[j] == ')')\n        {\n            lst[i] = '(';\n            lst[j] = ')';\n            i++;\n            j--;\n        }\n        else if(lst[i] == '(' && lst[j] == '(')\n        {\n            lst[i] = '(';\n            lst[j] = '(';\n            \nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpwwacdo0k.d(83): Error: found `unittest` instead of statement\n/tmp/tmpwwacdo0k.d(100): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpwwacdo0k.d(100): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwwacdo0k.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n, m, p, q, r, s, t;\n    int len = lst.length;\n    string res = \"\";\n    for(i = 0; i < len; i++)\n    {\n        if(lst[i] == \")\")\n        {\n            p = 0;\n            for(j = i + 1; j < len; j++)\n            {\n                if(lst[j] == \"(\")\n                {\n                    p++;\n                }\n                else if(lst[j] == \")\")\n                {\n                    p--;\n                }\n                if(p == 0)\n                {\n                    break;\n                }\n            }\n            if(j == len)\n            {\n                return \"No\";\n            }\n            else\n            {\n                for(k = i + 1; k < j; k++)\n                {\n                    res += lst[k];\n                }\n                i = j - 1;\n            }\n        }\n    }\n    return \"Yes\";\n}\n\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpn7eyrvzh.d(24): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpn7eyrvzh.d(54): Error: slice `res` is not mutable\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn7eyrvzh.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int len = lst.length;\n    if(len == 0) return \"Yes\";\n    if(len == 1) return \"No\";\n    \n    int i, j, k;\n    int open = 0;\n    for(i = 0; i < len; i++)\n    {\n        if(lst[i] == '(')\n            open++;\n        else if(lst[i] == ')')\n            open--;\n    }\n    if(open != 0) return \"No\";\n    \n    for(i = 0; i < len; i++)\n    {\n        if(lst[i] == '(')\n        {\n            for(j = i+1; j < len; j++)\n            {\n                if(lst[j] == '(')\n                    open++;\n                else if(lst[j] == ')')\n                    open--;\n                if(open == 0)\n                    break;\n            }\n            if(j == len) return \"No\";\n            for(k = i+1; k < j; k++)\n            {\n                if(lst[k] == '(')\n                    open++;\n                else if(lst[k] == ')')\n                    open--;\n                if(open == 0)\n                    break;\n            }\n            if(k == j) return \"No\";\n            i = j;\n        }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp73yimtvs.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmp73yimtvs.d(31): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmp73yimtvs.d(33): Error: incompatible types for `(lst[cast(ulong)i]) == (')')`: `string` and `char`\n/tmp/tmp73yimtvs.d(40): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmp73yimtvs.d(44): Error: incompatible types for `(lst[cast(ulong)j]) == ('(')`: `string` and `char`\n/tmp/tmp73yimtvs.d(46): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\n/tmp/tmp73yimtvs.d(54): Error: incompatible types for `(lst[cast(ulong)k]) == ('(')`: `string` and `char`\n/tmp/tmp73yimtvs.d(56): Error: incompatible types for `(lst[cast(ulong)k]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp73yimtvs.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k;\n    int len = lst.length;\n    for(i = 0; i < len; i++)\n    {\n        for(j = i + 1; j < len; j++)\n        {\n            for(k = 0; k < len; k++)\n            {\n                if(lst[i][k] == '(' && lst[j][k] == ')')\n                {\n                    if(k == len - 1)\n                    {\n                        return \"Yes\";\n                    }\n                }\n            }\n        }\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpttke9sum.d(24): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpttke9sum.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, n = lst.length;\n    for (i = 0; i < n; i++) {\n        for (j = i + 1; j < n; j++) {\n            if (lst[i][0] == '(' && lst[j][0] == ')') {\n                if (lst[i][1] == lst[j][1]) {\n                    lst[i] = lst[i][0] + lst[i][1] + lst[i][2];\n                    lst[j] = lst[j][0] + lst[j][1] + lst[j][2];\n                    return \"Yes\";\n                }\n            }\n        }\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpp9jy23gf.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpp9jy23gf.d(28): Error: cannot implicitly convert expression `cast(int)lst[cast(ulong)i][0] + cast(int)lst[cast(ulong)i][1] + cast(int)lst[cast(ulong)i][2]` of type `int` to `string`\n/tmp/tmpp9jy23gf.d(29): Error: cannot implicitly convert expression `cast(int)lst[cast(ulong)j][0] + cast(int)lst[cast(ulong)j][1] + cast(int)lst[cast(ulong)j][2]` of type `int` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp9jy23gf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    if (lst.length == 0)\n        return \"Yes\";\n    if (lst.length == 1)\n        return \"No\";\n    if (lst[0] == \"\")\n        return \"No\";\n    if (lst[1] == \"\")\n        return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == '(')\n        return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == ')')\n        return \"No\";\n    if (lst[0][0] == ')' && lst[1][0] == '(')\n        return \"No\";\n    if (lst[0][0] == ')' && lst[1][0] == ')')\n        return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == ')')\n        return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == ')')\n        return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == ')')\n        return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == ')')\n        return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == ')')\n        return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == ')')\n        return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == ')')\n        return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == ')')\n        return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == ')')\n        return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == ')\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpwid0ukmf.d(57): Error: unterminated character constant\n/tmp/tmpwid0ukmf.d(58): Error: found `unittest` when expecting `)`\n/tmp/tmpwid0ukmf.d(75): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwid0ukmf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    if(lst.length == 0) return \"Yes\";\n    if(lst.length == 1) return \"No\";\n    \n    int i = 0;\n    int j = 0;\n    int count = 0;\n    \n    while(i < lst.length && j < lst.length)\n    {\n        if(lst[i] == '(')\n        {\n            count++;\n            i++;\n        }\n        else if(lst[j] == ')')\n        {\n            count--;\n            j++;\n        }\n        else\n        {\n            i++;\n            j++;\n        }\n    }\n    \n    if(count == 0) return \"Yes\";\n    else return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpa78p67vm.d(32): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpa78p67vm.d(37): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa78p67vm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, len = lst.length;\n    for(i = 0; i < len; i++)\n    {\n        for(j = i + 1; j < len; j++)\n        {\n            if(lst[i] == \"(\" && lst[j] == \")\")\n                continue;\n            if(lst[i] == \")\" && lst[j] == \"(\" )\n                continue;\n            if(lst[i] == \"(\" && lst[j] == \")\" )\n                continue;\n            if(lst[i] == \"(\" && lst[j] == \"(\" )\n                continue;\n            if(lst[i] == \"(\" && lst[j] == \")\" )\n                continue;\n            if(lst[i] == \"(\" && lst[j] == \"(\" )\n                continue;\n            if(lst[i] == \"(\" && lst[j] == \")\" )\n                continue;\n            if(lst[i] == \"(\" && lst[j] == \"(\" )\n                continue;\n            if(lst[i] == \"(\" && lst[j] == \")\" )\n                continue;\n            if(lst[i] == \"(\" && lst[j] == \"(\" )\n                continue;\n            if(lst[i] == \"(\" && lst[j] == \")\" )\n                continue;\n            if(lst[i] == \"(\" && lst[j] == \"(\" )\n                continue;\n            if(lst[i] == \"(\" && lst[j] == \")\" )\n                continue;\n            if(lst[i] == \"(\" && lst[j] == \"(\" )\n                continue;\n            if(lst[i] == \"(\" && lst[j] == \")\" )\n                continue;\n            if(lst[i] == \"(\" && lst[j] == \"(\" )\n                continue;\n            if(lst[i] == \"(\" && lst[j] == \")\" )\n                continue;\n            if(lst[i] == \"(\" && lst[j] ==\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpau2orv_k.d(63): Error: expression expected, not `unittest`\n/tmp/tmpau2orv_k.d(64): Error: found `{` when expecting `)`\n/tmp/tmpau2orv_k.d(80): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpau2orv_k.d(80): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpau2orv_k.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    if (n == 0) return \"Yes\";\n    if (n == 1) return \"No\";\n    if (lst[0] == \")\") return \"No\";\n    if (lst[n-1] == \"(\" && lst[0] == \"(\") return \"No\";\n    if (lst[n-1] == \"(\" && lst[0] != \")\") return \"No\";\n    if (lst[n-1] != \"(\" && lst[0] == \")\") return \"No\";\n    if (lst[n-1] != \"(\" && lst[0] != \")\") return \"No\";\n    if (lst[0] == \")\") return \"No\";\n    if (lst[n-1] == \"(\" && lst[0] == \")\") return \"No\";\n    if (lst[n-1] == \"(\" && lst[0] != \")\") return \"No\";\n    if (lst[n-1] != \"(\" && lst[0] == \")\") return \"No\";\n    if (lst[n-1] != \"(\" && lst[0] != \")\") return \"No\";\n    if (lst[0] == \")\") return \"No\";\n    if (lst[n-1] == \"(\" && lst[0] == \")\") return \"No\";\n    if (lst[n-1] == \"(\" && lst[0] != \")\") return \"No\";\n    if (lst[n-1] != \"(\" && lst[0] == \")\") return \"No\";\n    if (lst[n-1] != \"(\" && lst[0] != \")\") return \"No\";\n    if (lst[0] == \")\") return \"No\";\n    if (lst[n-1] == \"(\" && lst[0] == \")\") return \"No\";\n    if (lst[n-1] == \"(\" && lst[0] != \")\") return \"No\";\n    if (lst[n-1] != \"(\" && lst[\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmph66zy84n.d(45): Error: expression expected, not `unittest`\n/tmp/tmph66zy84n.d(46): Error: found `{` when expecting `,`\n/tmp/tmph66zy84n.d(47): Error: expression expected, not `alias`\n/tmp/tmph66zy84n.d(47): Error: found `candidate` when expecting `,`\n/tmp/tmph66zy84n.d(47): Error: expression expected, not `=`\n/tmp/tmph66zy84n.d(47): Error: found `match_parens` when expecting `,`\n/tmp/tmph66zy84n.d(47): Error: expression expected, not `;`\n/tmp/tmph66zy84n.d(49): Error: found `assert` when expecting `,`\n/tmp/tmph66zy84n.d(49): Error: found `;` when expecting `,`\n/tmp/tmph66zy84n.d(50): Error: found `;` when expecting `,`\n/tmp/tmph66zy84n.d(51): Error: found `;` when expecting `,`\n/tmp/tmph66zy84n.d(52): Error: found `;` when expecting `,`\n/tmp/tmph66zy84n.d(53): Error: found `;` when expecting `,`\n/tmp/tmph66zy84n.d(54): Error: found `;` when expecting `,`\n/tmp/tmph66zy84n.d(55): Error: found `;` when expecting `,`\n/tmp/tmph66zy84n.d(56): Error: found `;` when expecting `,`\n/tmp/tmph66zy84n.d(57): Error",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n, m;\n    string s;\n    \n    for (i = 0; i < lst.length; i++) {\n        s = lst[i];\n        n = s.length();\n        m = 0;\n        for (j = 0; j < n; j++) {\n            if (s[j] == '(')\n                m++;\n            else if (s[j] == ')')\n                m--;\n        }\n        if (m != 0)\n            return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmptd17e6fc.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptd17e6fc.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int len = lst.length;\n    if (len == 0) return \"Yes\";\n    if (len == 1) return \"No\";\n    int i = 0;\n    int j = 1;\n    int count = 0;\n    while (i < len) {\n        if (lst[i] == '(') {\n            count++;\n        }\n        if (lst[i] == ')') {\n            count--;\n        }\n        if (count < 0) return \"No\";\n        i++;\n    }\n    if (count == 0) return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmplr8etjo1.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmplr8etjo1.d(30): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmplr8etjo1.d(33): Error: incompatible types for `(lst[cast(ulong)i]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplr8etjo1.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n, m;\n    int p1, p2;\n    string s;\n    \n    if (lst.length == 0) return \"Yes\";\n    \n    for (i = 0; i < lst.length; i++) {\n        if (lst[i].length() == 0) return \"No\";\n    }\n    \n    for (i = 0; i < lst.length; i++) {\n        for (j = 0; j < lst.length; j++) {\n            if (i == j) continue;\n            \n            for (k = 0; k < lst[i].length(); k++) {\n                if (lst[i][k] == '(') p1++;\n                if (lst[i][k] == ')') p1--;\n            }\n            \n            for (k = 0; k < lst[j].length(); k++) {\n                if (lst[j][k] == '(') p2++;\n                if (lst[j][k] == ')') p2--;\n            }\n            \n            if (p1 != 0 || p2 != 0) continue;\n            \n            n = lst[i].length() + lst[j].length();\n            m = 0;\n            s = \"\";\n            \n            for (k = 0; k < lst[i].length(); k++) {\n                s += lst[i][k];\n                m++;\n                if (m == n) break;\n            }\n            \n            for (k = 0; k < lst[j].length(); k++) {\n                s += lst[j][k];\n                m++;\n                if (m == n) break;\n            }\n            \n            if (m == n) return \"Yes\";\n        }\n    }\n    \n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp532y1spd.d(30): Error: no property `length` for type `string`\n/tmp/tmp532y1spd.d(37): Error: no property `length` for type `string`\n/tmp/tmp532y1spd.d(42): Error: no property `length` for type `string`\n/tmp/tmp532y1spd.d(49): Error: no property `length` for type `string`\n/tmp/tmp532y1spd.d(49): Error: no property `length` for type `string`\n/tmp/tmp532y1spd.d(53): Error: no property `length` for type `string`\n/tmp/tmp532y1spd.d(54): Error: slice `s` is not mutable\n/tmp/tmp532y1spd.d(59): Error: no property `length` for type `string`\n/tmp/tmp532y1spd.d(60): Error: slice `s` is not mutable\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp532y1spd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    if (lst.length == 0) return \"Yes\";\n    if (lst.length == 1) return \"Yes\";\n    if (lst.length == 2) return \"Yes\";\n    \n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    \n    while (i < lst.length)\n    {\n        if (lst[i] == '(')\n        {\n            if (j < lst.length)\n            {\n                if (lst[j] == '(')\n                {\n                    i++;\n                    j++;\n                }\n                else if (lst[j] == ')')\n                {\n                    i++;\n                    j++;\n                }\n                else\n                {\n                    return \"No\";\n                }\n            }\n            else\n            {\n                return \"No\";\n            }\n        }\n        else if (lst[i] == ')')\n        {\n            if (j < lst.length)\n            {\n                if (lst[j] == '(')\n                {\n                    i++;\n                    j++;\n                }\n                else if (lst[j] == ')')\n                {\n                    i++;\n                    j++;\n                }\n                else\n                {\n                    return \"No\";\n                }\n            }\n            else\n            {\n                return \"No\";\n            }\n        }\n        else\n        {\n            i++;\n        }\n    }\n    \n    return \"Yes\";\n}\n\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpvhveb2d2.d(48): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpvhveb2d2.d(52): Error: incompatible types for `(lst[cast(ulong)j]) == ('(')`: `string` and `char`\n/tmp/tmpvhveb2d2.d(57): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\n/tmp/tmpvhveb2d2.d(72): Error: incompatible types for `(lst[cast(ulong)i]) == (')')`: `string` and `char`\n/tmp/tmpvhveb2d2.d(76): Error: incompatible types for `(lst[cast(ulong)j]) == ('(')`: `string` and `char`\n/tmp/tmpvhveb2d2.d(81): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvhveb2d2.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    if (n == 0) return \"Yes\";\n    if (n == 1) return \"No\";\n    \n    int i = 0, j = 1;\n    while (i < n && j < n) {\n        if (lst[i] == '(' && lst[j] == ')') {\n            i++;\n            j++;\n        } else if (lst[i] == '(') {\n            i++;\n        } else if (lst[j] == ')') {\n            j++;\n        } else {\n            return \"No\";\n        }\n    }\n    \n    if (i == n && j == n) return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp20ayxpla.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmp20ayxpla.d(29): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmp20ayxpla.d(29): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\n/tmp/tmp20ayxpla.d(32): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmp20ayxpla.d(34): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp20ayxpla.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, n = lst.length;\n    for (i = 0; i < n; i++) {\n        for (j = i + 1; j < n; j++) {\n            if (lst[i][0] == '(' && lst[j][0] == ')') {\n                if (lst[i][1] == lst[j][1]) {\n                    lst[i] = lst[i][0] + lst[i][1] + lst[i][2];\n                    lst[j] = lst[j][0] + lst[j][1] + lst[j][2];\n                }\n            }\n        }\n    }\n    for (i = 0; i < n; i++) {\n        if (lst[i][0] == '(') {\n            return \"No\";\n        }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp3kpn96_a.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmp3kpn96_a.d(28): Error: cannot implicitly convert expression `cast(int)lst[cast(ulong)i][0] + cast(int)lst[cast(ulong)i][1] + cast(int)lst[cast(ulong)i][2]` of type `int` to `string`\n/tmp/tmp3kpn96_a.d(29): Error: cannot implicitly convert expression `cast(int)lst[cast(ulong)j][0] + cast(int)lst[cast(ulong)j][1] + cast(int)lst[cast(ulong)j][2]` of type `int` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3kpn96_a.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, n = lst.length;\n    for(i = 0; i < n; i++)\n    {\n        for(j = i + 1; j < n; j++)\n        {\n            if(lst[i][0] == '(' && lst[j][0] == '(')\n            {\n                if(lst[i][1] == ')' && lst[j][1] == ')')\n                {\n                    if(lst[i][2] == ')' && lst[j][2] == ')')\n                    {\n                        if(lst[i][3] == ')' && lst[j][3] == ')')\n                        {\n                            if(lst[i][4] == ')' && lst[j][4] == ')')\n                            {\n                                if(lst[i][5] == ')' && lst[j][5] == ')')\n                                {\n                                    if(lst[i][6] == ')' && lst[j][6] == ')')\n                                    {\n                                        if(lst[i][7] == ')' && lst[j][7] == ')')\n                                        {\n                                            if(lst[i][8] == ')' && lst[j][8] == ')')\n                                            {\n                                                if(lst[i][9] == ')' && lst[j][9] == ')')\n                                                {\n                                                    if(lst[i][10] == ')' && lst[j][10] == ')')\n                                                    {\n                                                        if(lst[i][11] == ')' && lst[j][11] == ')')\n                                                        {\n                                                            if(lst[i][12] == ')' && lst[j][12] == ')')\n                                                            {\n                                                                if(lst[i][13] == ')' && lst[j][13]\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp0_jv7too.d(55): Error: found `unittest` when expecting `)`\n/tmp/tmp0_jv7too.d(72): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp0_jv7too.d(72): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp0_jv7too.d(72): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp0_jv7too.d(72): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp0_jv7too.d(72): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp0_jv7too.d(72): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp0_jv7too.d(72): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp0_jv7too.d(72): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp0_jv7too.d(72): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp0_jv7too.d(72): Error: found `End of File` when expecting ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, len = lst.length;\n    for (i = 0; i < len; i++) {\n        for (j = i + 1; j < len; j++) {\n            if (lst[i][0] == '(' && lst[j][0] == '(') {\n                if (lst[i][1] == ')' && lst[j][1] == ')') {\n                    if (lst[i][2] == ')' && lst[j][2] == ')') {\n                        if (lst[i][3] == ')' && lst[j][3] == ')') {\n                            if (lst[i][4] == ')' && lst[j][4] == ')') {\n                                if (lst[i][5] == ')' && lst[j][5] == ')') {\n                                    if (lst[i][6] == ')' && lst[j][6] == ')') {\n                                        if (lst[i][7] == ')' && lst[j][7] == ')') {\n                                            if (lst[i][8] == ')' && lst[j][8] == ')') {\n                                                if (lst[i][9] == ')' && lst[j][9] == ')') {\n                                                    if (lst[i][10] == ')' && lst[j][10] == ')') {\n                                                        if (lst[i][11] == ')' && lst[j][11] == ')') {\n                                                            if (lst[i][12] == ')' && lst[j][12] == ')') {\n                                                                if (lst[i][13] == ')' && lst[j][13] == ')') {\n                                                                    if (lst[i][14] == ')' && lst[j][14] == ')') {\n                                                                        if (lst[i][15] == ')' && lst[j][15\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpz_r_kdde.d(42): Error: found `unittest` when expecting `,`\n/tmp/tmpz_r_kdde.d(59): Error: found `void` when expecting `,`\n/tmp/tmpz_r_kdde.d(59): Error: found `{` when expecting `,`\n/tmp/tmpz_r_kdde.d(59): Error: expression expected, not `}`\n/tmp/tmpz_r_kdde.d(59): Error: found `End of File` when expecting `,`\n/tmp/tmpz_r_kdde.d(59): Error: found `End of File` when expecting `]`\n/tmp/tmpz_r_kdde.d(59): Error: found `End of File` when expecting `)`\n/tmp/tmpz_r_kdde.d(59): Error: found `End of File` instead of statement\n/tmp/tmpz_r_kdde.d(59): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpz_r_kdde.d(59): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpz_r_kdde.d(59): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpz_r_kdde.d(59): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpz_r_kdde.d(59): Error: found `End of File` when expecting `}` following compound stateme",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int len = lst.length;\n    if (len == 0) return \"Yes\";\n    if (len == 1) return \"No\";\n    int i = 0;\n    int j = len - 1;\n    while (i < j) {\n        if (lst[i] == '(' && lst[j] == ')') {\n            i++;\n            j--;\n        } else if (lst[i] == '(') {\n            return \"No\";\n        } else if (lst[j] == ')') {\n            return \"No\";\n        } else {\n            i++;\n            j--;\n        }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpkvtjyyck.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpkvtjyyck.d(29): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpkvtjyyck.d(29): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\n/tmp/tmpkvtjyyck.d(32): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpkvtjyyck.d(34): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkvtjyyck.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n = lst.length;\n    for (i = 0; i < n; i++) {\n        for (j = i + 1; j < n; j++) {\n            for (k = j + 1; k < n; k++) {\n                if (lst[i][0] == '(' && lst[j][0] == '(' && lst[k][0] == '(') {\n                    if (lst[i][1] == '(' && lst[j][1] == '(' && lst[k][1] == '(') {\n                        if (lst[i][2] == '(' && lst[j][2] == '(' && lst[k][2] == '(') {\n                            if (lst[i][3] == '(' && lst[j][3] == '(' && lst[k][3] == '(') {\n                                if (lst[i][4] == '(' && lst[j][4] == '(' && lst[k][4] == '(') {\n                                    if (lst[i][5] == '(' && lst[j][5] == '(' && lst[k][5] == '(') {\n                                        if (lst[i][6] == '(' && lst[j][6] == '(' && lst[k][6] == '(') {\n                                            if (lst[i][7] == '(' && lst[j][7] == '(' && lst[k][7] == '(') {\n                                                if (lst[i][8] == '(' && lst[j][8] == '(' && lst[k][8] == '(') {\n                                                    if (lst[i][9] == '(' && lst[j][9] == '(' && lst[k][9] == '(') {\n                                                        if (lst[i][10] == '(' && lst[j][10] == '(' && lst[k][10] == '(') {\n                                     \nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp50atan6g.d(39): Error: found `unittest` instead of statement\n/tmp/tmp50atan6g.d(56): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp50atan6g.d(56): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp50atan6g.d(56): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp50atan6g.d(56): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp50atan6g.d(56): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp50atan6g.d(56): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp50atan6g.d(56): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp50atan6g.d(56): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp50atan6g.d(56): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp50atan6g.d(56): Error: found `End of File` when expectin",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, n = lst.length;\n    for (i = 0; i < n; i++) {\n        for (j = i + 1; j < n; j++) {\n            if (lst[i][0] == '(' && lst[j][0] == ')') {\n                if (lst[i][1] == lst[j][1]) {\n                    lst[i] = lst[i][0] + lst[i][1] + lst[i][2];\n                    lst[j] = lst[j][0] + lst[j][1] + lst[j][2];\n                }\n            }\n        }\n    }\n    for (i = 0; i < n; i++) {\n        if (lst[i][0] == '(') {\n            return \"No\";\n        }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp3kpn96_a.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmp3kpn96_a.d(28): Error: cannot implicitly convert expression `cast(int)lst[cast(ulong)i][0] + cast(int)lst[cast(ulong)i][1] + cast(int)lst[cast(ulong)i][2]` of type `int` to `string`\n/tmp/tmp3kpn96_a.d(29): Error: cannot implicitly convert expression `cast(int)lst[cast(ulong)j][0] + cast(int)lst[cast(ulong)j][1] + cast(int)lst[cast(ulong)j][2]` of type `int` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3kpn96_a.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    int i, j, k;\n    for (i = 0; i < n; i++) {\n        for (j = i + 1; j < n; j++) {\n            for (k = j + 1; k < n; k++) {\n                if (lst[i][0] == '(' && lst[j][0] == '(' && lst[k][0] == '(') {\n                    if (lst[i][1] == ')' && lst[j][1] == ')' && lst[k][1] == ')') {\n                        if (lst[i][2] == ')' && lst[j][2] == ')' && lst[k][2] == ')') {\n                            if (lst[i][3] == ')' && lst[j][3] == ')' && lst[k][3] == ')') {\n                                if (lst[i][4] == ')' && lst[j][4] == ')' && lst[k][4] == ')') {\n                                    if (lst[i][5] == ')' && lst[j][5] == ')' && lst[k][5] == ')') {\n                                        if (lst[i][6] == ')' && lst[j][6] == ')' && lst[k][6] == ')') {\n                                            if (lst[i][7] == ')' && lst[j][7] == ')' && lst[k][7] == ')') {\n                                                if (lst[i][8] == ')' && lst[j][8] == ')' && lst[k][8] == ')') {\n                                                    if (lst[i][9] == ')' && lst[j][9] == ')' && lst[k][9] == ')') {\n                                                        if (lst[i][10] == ')' && lst[j][10] == ')' && lst[k][10] == ')') {\n                                  \nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpw8i6t8w9.d(40): Error: found `unittest` instead of statement\n/tmp/tmpw8i6t8w9.d(57): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpw8i6t8w9.d(57): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpw8i6t8w9.d(57): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpw8i6t8w9.d(57): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpw8i6t8w9.d(57): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpw8i6t8w9.d(57): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpw8i6t8w9.d(57): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpw8i6t8w9.d(57): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpw8i6t8w9.d(57): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpw8i6t8w9.d(57): Error: found `End of File` when expectin",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    if (n == 0) return \"Yes\";\n    if (n == 1) return \"No\";\n    if (lst[0] == \"\") return \"No\";\n    if (lst[1] == \"\") return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == '(') return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == ')' && lst[1][0] == '(') return \"No\";\n    if (lst[0][0] == ')' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == ')' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == '(') return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == ')' && lst[1][0] == '(') return \"No\";\n    if (lst[0][0] == ')' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == '(') return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == ')' && lst[1][0] == '(') return \"No\";\n    if (lst[0][0] == ')' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == '('\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpcq45o36e.d(43): Error: found `unittest` when expecting `)`\n/tmp/tmpcq45o36e.d(60): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcq45o36e.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, len = lst.length;\n    for (i = 0; i < len; i++) {\n        for (j = i + 1; j < len; j++) {\n            if (lst[i][0] == '(' && lst[j][0] == ')') {\n                if (lst[i][1] == lst[j][1]) {\n                    lst[i] = lst[i][0] + lst[i][1] + lst[i][2];\n                    lst[j] = lst[j][0] + lst[j][1] + lst[j][2];\n                }\n                else {\n                    lst[i] = lst[i][0] + lst[i][1] + lst[i][2];\n                    lst[j] = lst[j][0] + lst[j][1] + lst[j][2];\n                }\n            }\n        }\n    }\n    for (i = 0; i < len; i++) {\n        if (lst[i][0] == '(') {\n            return \"No\";\n        }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpnocd1bi6.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpnocd1bi6.d(28): Error: cannot implicitly convert expression `cast(int)lst[cast(ulong)i][0] + cast(int)lst[cast(ulong)i][1] + cast(int)lst[cast(ulong)i][2]` of type `int` to `string`\n/tmp/tmpnocd1bi6.d(29): Error: cannot implicitly convert expression `cast(int)lst[cast(ulong)j][0] + cast(int)lst[cast(ulong)j][1] + cast(int)lst[cast(ulong)j][2]` of type `int` to `string`\n/tmp/tmpnocd1bi6.d(32): Error: cannot implicitly convert expression `cast(int)lst[cast(ulong)i][0] + cast(int)lst[cast(ulong)i][1] + cast(int)lst[cast(ulong)i][2]` of type `int` to `string`\n/tmp/tmpnocd1bi6.d(33): Error: cannot implicitly convert expression `cast(int)lst[cast(ulong)j][0] + cast(int)lst[cast(ulong)j][1] + cast(int)lst[cast(ulong)j][2]` of type `int` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnocd1bi6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n = lst.length;\n    int paren_count[n];\n    for(i = 0; i < n; i++)\n        paren_count[i] = 0;\n    for(i = 0; i < n; i++)\n        for(j = 0; j < n; j++)\n            if(lst[i][j] == '(')\n                paren_count[i]++;\n            else if(lst[i][j] == ')')\n                paren_count[i]--;\n    for(i = 0; i < n; i++)\n        if(paren_count[i] != 0)\n            return \"No\";\n    for(i = 0; i < n; i++)\n        for(j = 0; j < n; j++)\n            if(lst[i][j] == '(')\n                for(k = 0; k < n; k++)\n                    if(lst[k][j] == '(')\n                        paren_count[k]++;\n                    else if(lst[k][j] == ')')\n                        paren_count[k]--;\n    for(i = 0; i < n; i++)\n        if(paren_count[i] != 0)\n            return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpw4iger5y.d(24): Deprecation: instead of C-style syntax, use D-style syntax `int[n] paren_count`\n/tmp/tmpw4iger5y.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpw4iger5y.d(24): Error: variable `n` cannot be read at compile time\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw4iger5y.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, n = lst.length;\n    for(i = 0; i < n; i++)\n    {\n        for(j = i + 1; j < n; j++)\n        {\n            if(lst[i][0] == '(' && lst[j][0] == '(')\n            {\n                if(lst[i][1] == lst[j][1])\n                {\n                    if(lst[i][2] == lst[j][2])\n                    {\n                        if(lst[i][3] == lst[j][3])\n                        {\n                            if(lst[i][4] == lst[j][4])\n                            {\n                                if(lst[i][5] == lst[j][5])\n                                {\n                                    if(lst[i][6] == lst[j][6])\n                                    {\n                                        if(lst[i][7] == lst[j][7])\n                                        {\n                                            if(lst[i][8] == lst[j][8])\n                                            {\n                                                if(lst[i][9] == lst[j][9])\n                                                {\n                                                    if(lst[i][10] == lst[j][10])\n                                                    {\n                                                        if(lst[i][11] == lst[j][11])\n                                                        {\n                                                            if(lst[i][12] == lst[j][12])\n                                                            {\n                                                                if(lst[i][13] == lst[j][13])\n                                                                {\n                                                                    if(lst[i][14] == lst[j][14])\n                                                                    {\n                                                                        if(lst[i][15] == lst[j][15])\n                                                                        {\n                                                                            if(lst[i][16] == lst[j][16])\n\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpbphcm2ce.d(62): Error: found `unittest` instead of statement\n/tmp/tmpbphcm2ce.d(79): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpbphcm2ce.d(79): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpbphcm2ce.d(79): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpbphcm2ce.d(79): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpbphcm2ce.d(79): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpbphcm2ce.d(79): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpbphcm2ce.d(79): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpbphcm2ce.d(79): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpbphcm2ce.d(79): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpbphcm2ce.d(79): Error: found `End of File` when expectin",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    if (n == 0) return \"Yes\";\n    if (n == 1) return \"No\";\n    \n    int i = 0;\n    int j = 1;\n    int k = 0;\n    int p = 0;\n    while (i < n && j < n) {\n        if (lst[i] == '(') {\n            p++;\n        }\n        if (lst[j] == ')') {\n            p--;\n        }\n        if (p == 0) {\n            k = i;\n            i++;\n            j++;\n        }\n        else {\n            i++;\n        }\n    }\n    if (p == 0) {\n        return \"Yes\";\n    }\n    else {\n        return \"No\";\n    }\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp0ytlg84n.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmp0ytlg84n.d(32): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmp0ytlg84n.d(35): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0ytlg84n.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, n = lst.length;\n    for(i = 0; i < n; i++)\n        for(j = i + 1; j < n; j++)\n            if(lst[i][0] == '(' && lst[j][0] == ')')\n                return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpgnctlfya.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgnctlfya.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    int i, j;\n    for (i = 0; i < n; i++) {\n        if (lst[i][0] != '(')\n            return \"No\";\n        for (j = i + 1; j < n; j++) {\n            if (lst[j][0] == '(')\n                break;\n            if (lst[i][0] == '(' && lst[j][0] == ')') {\n                lst[i] += lst[j];\n                lst[j] = \"\";\n                break;\n            }\n        }\n    }\n    for (i = 0; i < n; i++) {\n        if (lst[i][0] != ')')\n            return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp6hwq6qef.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmp6hwq6qef.d(32): Error: slice `lst[cast(ulong)i]` is not mutable\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6hwq6qef.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k;\n    int len = lst.length;\n    int paren_count = 0;\n    for(i = 0; i < len; i++)\n    {\n        if(lst[i] == '(')\n            paren_count++;\n        else if(lst[i] == ')')\n            paren_count--;\n    }\n    if(paren_count == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpv1_2riae.d(24): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpv1_2riae.d(28): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpv1_2riae.d(30): Error: incompatible types for `(lst[cast(ulong)i]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv1_2riae.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, len = lst.length;\n    for (i = 0; i < len; i++) {\n        for (j = i + 1; j < len; j++) {\n            if (lst[i][0] == '(' && lst[j][0] == ')') {\n                if (lst[i][1] == lst[j][1]) {\n                    lst[i] = lst[i][0] + lst[i][1] + lst[i][2];\n                    lst[j] = lst[j][0] + lst[j][1] + lst[j][2];\n                }\n            }\n        }\n    }\n    for (i = 0; i < len; i++) {\n        if (lst[i][0] == '(')\n            return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpmlzmp7mu.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpmlzmp7mu.d(28): Error: cannot implicitly convert expression `cast(int)lst[cast(ulong)i][0] + cast(int)lst[cast(ulong)i][1] + cast(int)lst[cast(ulong)i][2]` of type `int` to `string`\n/tmp/tmpmlzmp7mu.d(29): Error: cannot implicitly convert expression `cast(int)lst[cast(ulong)j][0] + cast(int)lst[cast(ulong)j][1] + cast(int)lst[cast(ulong)j][2]` of type `int` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmlzmp7mu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpc137ha5a.d(24): Error: no identifier for declarator `int`\n/tmp/tmpc137ha5a.d(24): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc137ha5a.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    if (n == 0) return \"Yes\";\n    if (n == 1) return \"No\";\n    \n    int i = 0;\n    int j = n - 1;\n    while (i < j) {\n        if (lst[i] == '(' && lst[j] == ')') {\n            i++;\n            j--;\n        } else if (lst[i] == '(') {\n            i++;\n        } else if (lst[j] == ')') {\n            j--;\n        } else {\n            return \"No\";\n        }\n    }\n    \n    if (lst[i] == '(') return \"No\";\n    if (lst[j] == ')') return \"No\";\n    \n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpvoyr6ci7.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpvoyr6ci7.d(30): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpvoyr6ci7.d(30): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\n/tmp/tmpvoyr6ci7.d(33): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpvoyr6ci7.d(35): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\n/tmp/tmpvoyr6ci7.d(42): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpvoyr6ci7.d(43): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvoyr6ci7.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n = lst.length;\n    for(i = 0; i < n; i++)\n        for(j = i + 1; j < n; j++)\n            if(lst[i][0] == '(' && lst[j][0] == '(')\n            {\n                k = 0;\n                while(lst[i][k] == '(' && lst[j][k] == '(')\n                    k++;\n                if(lst[i][k] == '(' && lst[j][k] == ')')\n                {\n                    lst[i] = lst[i][k + 1];\n                    lst[j] = lst[j][k + 1];\n                    for(k = i + 1; k < j; k++)\n                        lst[k] = lst[k + 1];\n                    n--;\n                    i--;\n                    j--;\n                }\n            }\n    if(n == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpfi0clpbl.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpfi0clpbl.d(33): Error: cannot implicitly convert expression `lst[cast(ulong)i][cast(ulong)(k + 1)]` of type `immutable(char)` to `string`\n/tmp/tmpfi0clpbl.d(34): Error: cannot implicitly convert expression `lst[cast(ulong)j][cast(ulong)(k + 1)]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfi0clpbl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    if (n == 0) return \"Yes\";\n    if (n == 1) return \"No\";\n    if (lst[0] == \"\") return \"No\";\n    if (lst[1] == \"\") return \"No\";\n    if (lst[0][0] == '(' && lst[0][n-1] == ')') return \"Yes\";\n    if (lst[1][0] == '(' && lst[1][n-1] == ')') return \"Yes\";\n    if (lst[0][0] == '(' && lst[1][0] == '(' && lst[0][n-1] == ')' && lst[1][n-1] == ')') return \"Yes\";\n    if (lst[1][0] == '(' && lst[0][0] == '(' && lst[1][n-1] == ')' && lst[0][n-1] == ')') return \"Yes\";\n    if (lst[0][0] == '(' && lst[1][0] == '(' && lst[0][n-1] == ')' && lst[1][n-1] == ')') return \"Yes\";\n    if (lst[1][0] == '(' && lst[0][0] == '(' && lst[1][n-1] == ')' && lst[0][n-1] == ')') return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpl4u527ru.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl4u527ru.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    if (n == 0) return \"No\";\n    if (n == 1) return \"Yes\";\n    if (lst[0] == \"\") return \"No\";\n    if (lst[n-1] == \"\") return \"No\";\n    int i = 0;\n    int j = n-1;\n    while (i < j) {\n        if (lst[i] == \"(\" && lst[j] == \")\") {\n            i++;\n            j--;\n        } else if (lst[i] == \")\" && lst[j] == \"(\" ) {\n            j--;\n        } else {\n            return \"No\";\n        }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp03_2_4zu.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp03_2_4zu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int len = lst.length;\n    int i = 0;\n    int j = len - 1;\n    int count = 0;\n    while (i < len && j >= 0) {\n        if (lst[i] == '(') {\n            count++;\n        }\n        if (lst[j] == ')') {\n            count--;\n        }\n        if (count < 0) {\n            return \"No\";\n        }\n        i++;\n        j--;\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpha26rlyg.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpha26rlyg.d(28): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpha26rlyg.d(31): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpha26rlyg.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    if (lst.length == 0) return \"Yes\";\n    if (lst.length == 1) return \"No\";\n    \n    int i = 0;\n    int j = lst.length - 1;\n    \n    while (i < j) {\n        if (lst[i] == '(' && lst[j] == ')') {\n            lst[i] = ')';\n            lst[j] = '(';\n        } else if (lst[i] == '(' && lst[j] == '(') {\n            lst[i] = ')';\n            lst[j] = '(';\n        } else if (lst[i] == '(' && lst[j] == ')') {\n            lst[i] = '(';\n            lst[j] = ')';\n        } else if (lst[i] == '(' && lst[j] == ')') {\n            lst[i] = '(';\n            lst[j] = '(';\n        } else if (lst[i] == '(' && lst[j] == '(') {\n            lst[i] = '(';\n            lst[j] = ')';\n        } else if (lst[i] == '(' && lst[j] == ')') {\n            lst[i] = '(';\n            lst[j] = '(';\n        } else if (lst[i] == '(' && lst[j] == '(') {\n            lst[i] = '(';\n            lst[j] = '(';\n        } else if (lst[i] == '(' && lst[j] == ')') {\n            lst[i] = '(';\n            lst[j] = '(';\n        } else if (lst[i] == '(' && lst[j] == ')') {\n            lst[i] = '(';\n            lst[j] = '(';\n        } else if (lst[i] == '(' && lst[j] == '(') {\n            l\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpfop3ija6.d(59): Error: found `unittest` when expecting `;` following statement\n/tmp/tmpfop3ija6.d(76): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpfop3ija6.d(76): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpfop3ija6.d(76): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfop3ija6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n = lst.length;\n    int p_cnt = 0;\n    for (i = 0; i < n; i++) {\n        if (lst[i] == '(') {\n            p_cnt++;\n        } else if (lst[i] == ')') {\n            p_cnt--;\n        }\n    }\n    if (p_cnt == 0) {\n        return \"Yes\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp7aija91u.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmp7aija91u.d(26): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmp7aija91u.d(28): Error: incompatible types for `(lst[cast(ulong)i]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7aija91u.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    if(lst.length == 0)\n        return \"Yes\";\n    if(lst.length == 1)\n        return \"No\";\n    if(lst[0] == \"\")\n        return \"No\";\n    if(lst[1] == \"\")\n        return \"No\";\n    if(lst[0][0] == '(' && lst[1][0] == '(')\n        return \"No\";\n    if(lst[0][0] == '(' && lst[1][0] == ')')\n        return \"No\";\n    if(lst[0][0] == ')' && lst[1][0] == '(')\n        return \"No\";\n    if(lst[0][0] == ')' && lst[1][0] == ')')\n        return \"No\";\n    if(lst[0][0] == '(' && lst[1][0] == ')')\n        return \"No\";\n    if(lst[0][0] == ')' && lst[1][0] == ')')\n        return \"No\";\n    if(lst[0][0] == '(' && lst[1][0] == '(')\n        return \"No\";\n    if(lst[0][0] == '(' && lst[1][0] == ')')\n        return \"No\";\n    if(lst[0][0] == '(' && lst[1][0] == ')')\n        return \"No\";\n    if(lst[0][0] == '(' && lst[1][0] == '(')\n        return \"No\";\n    if(lst[0][0] == '(' && lst[1][0] == ')')\n        return \"No\";\n    if(lst[0][0] == '(' && lst[1][0] == ')')\n        return \"No\";\n    if(lst[0][0] == '(' && lst[1][0] == '(')\n        return \"No\";\n    if(lst[0][0] == '(' && lst[1][0] == ')\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp1napuhpy.d(57): Error: unterminated character constant\n/tmp/tmp1napuhpy.d(58): Error: found `unittest` when expecting `)`\n/tmp/tmp1napuhpy.d(75): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1napuhpy.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, n = lst.length;\n    for (i = 0; i < n; i++) {\n        for (j = i + 1; j < n; j++) {\n            if (lst[i][0] == '(' && lst[j][0] == ')') {\n                if (lst[i][1] == lst[j][1]) {\n                    lst[i] = lst[i][0] + lst[i][1] + lst[i][2];\n                    lst[j] = lst[j][0] + lst[j][1] + lst[j][2];\n                }\n            }\n        }\n    }\n    for (i = 0; i < n; i++) {\n        if (lst[i][0] == '(') {\n            return \"No\";\n        }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp3kpn96_a.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmp3kpn96_a.d(28): Error: cannot implicitly convert expression `cast(int)lst[cast(ulong)i][0] + cast(int)lst[cast(ulong)i][1] + cast(int)lst[cast(ulong)i][2]` of type `int` to `string`\n/tmp/tmp3kpn96_a.d(29): Error: cannot implicitly convert expression `cast(int)lst[cast(ulong)j][0] + cast(int)lst[cast(ulong)j][1] + cast(int)lst[cast(ulong)j][2]` of type `int` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3kpn96_a.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k;\n    int len = lst.length;\n    int paren_count = 0;\n    for (i = 0; i < len; i++) {\n        if (lst[i] == '(') {\n            paren_count++;\n        }\n        else if (lst[i] == ')') {\n            paren_count--;\n        }\n    }\n    if (paren_count == 0) {\n        return \"Yes\";\n    }\n    else {\n        return \"No\";\n    }\n}\n\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp_2ta7wum.d(24): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmp_2ta7wum.d(27): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmp_2ta7wum.d(30): Error: incompatible types for `(lst[cast(ulong)i]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_2ta7wum.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, l, m, n, p, q;\n    int len = lst.length;\n    int[][] dp = new int[len][len];\n    for (i = 0; i < len; i++) {\n        dp[i][i] = 1;\n    }\n    for (i = 0; i < len - 1; i++) {\n        for (j = i + 1; j < len; j++) {\n            if (lst[i][0] == '(' && lst[j][0] == '(') {\n                dp[i][j] = dp[i + 1][j - 1];\n            } else if (lst[i][0] == '(' && lst[j][0] == ')') {\n                dp[i][j] = dp[i + 1][j] + 1;\n            } else if (lst[i][0] == ')' && lst[j][0] == '(') {\n                dp[i][j] = dp[i][j - 1] + 1;\n            } else if (lst[i][0] == ')' && lst[j][0] == ')') {\n                dp[i][j] = dp[i][j] + 1;\n            } else {\n                dp[i][j] = 0;\n            }\n        }\n    }\n    for (i = 0; i < len; i++) {\n        for (j = i + 1; j < len; j++) {\n            if (dp[i][j] == 0) {\n                return \"No\";\n            }\n        }\n    }\n    return \"Yes\";\n}\n\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpryp8yd8o.d(24): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpryp8yd8o.d(25): Error: variable `len` cannot be read at compile time\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpryp8yd8o.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int len = lst.length;\n    if (len == 0) return \"Yes\";\n    if (len == 1) return \"No\";\n    if (len == 2) return \"Yes\";\n    \n    int i = 0, j = 1;\n    int left = 0, right = 0;\n    while (i < len && j < len) {\n        if (lst[i] == '(') left++;\n        if (lst[j] == ')') right++;\n        i++; j++;\n    }\n    if (left == right) return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp63cbzjgn.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmp63cbzjgn.d(31): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmp63cbzjgn.d(32): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp63cbzjgn.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n = lst.length;\n    for(i = 0; i < n; i++)\n    {\n        for(j = i + 1; j < n; j++)\n        {\n            for(k = 0; k < n; k++)\n            {\n                if(lst[i][k] == '(' && lst[j][k] == ')')\n                {\n                    if(lst[i][k + 1] == '(' || lst[j][k + 1] == '(')\n                    {\n                        continue;\n                    }\n                    else\n                    {\n                        return \"Yes\";\n                    }\n                }\n            }\n        }\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp5pyfg2tn.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5pyfg2tn.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    if (lst.length == 0) return \"Yes\";\n    if (lst.length == 1) return \"No\";\n    if (lst[0] == \"\") return \"No\";\n    if (lst[1] == \"\") return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == '(') return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] != '(') return \"No\";\n    if (lst[0][0] != '(' && lst[1][0] == '(') return \"No\";\n    if (lst[0][0] != '(' && lst[1][0] != '(') return \"Yes\";\n    if (lst[0][0] == '(' && lst[1][0] == '(') {\n        if (lst[0][1] == ')') return \"No\";\n        if (lst[1][1] == ')') return \"No\";\n        if (lst[0][1] == '(' && lst[1][1] == '(') return \"No\";\n        if (lst[0][1] == '(' && lst[1][1] != '(') return \"Yes\";\n        if (lst[0][1] != '(' && lst[1][1] == '(') return \"Yes\";\n        if (lst[0][1] != '(' && lst[1][1] != '(') return \"Yes\";\n    }\n    if (lst[0][0] == '(' && lst[1][0] == '(') {\n        if (lst[0][1] == ')') return \"No\";\n        if (lst[1][1] == ')') return \"No\";\n        if (lst[0][1] == '(' && lst[1][1] == '(') return \"No\";\n        if (lst[0][1] == '(' && lst[1][1] != '(') return \"Yes\";\n        if (lst[0][1] != '(' && l\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpubuchoqb.d(45): Error: found `unittest` when expecting `)`\n/tmp/tmpubuchoqb.d(62): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpubuchoqb.d(62): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpubuchoqb.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n = lst.length;\n    for (i = 0; i < n; i++) {\n        for (j = i + 1; j < n; j++) {\n            for (k = 0; k < n; k++) {\n                if (lst[i][k] == '(' && lst[j][k] == ')') {\n                    if (k == 0 || lst[i][k - 1] == '(' || lst[j][k + 1] == '(') {\n                        if (k == n - 1 || lst[i][k + 1] == ')' || lst[j][k - 1] == ')') {\n                            if (k == 0 || lst[i][k - 1] == '(' || lst[j][k + 1] == '(') {\n                                if (k == n - 1 || lst[i][k + 1] == ')' || lst[j][k - 1] == ')') {\n                                    if (k == 0 || lst[i][k - 1] == '(' || lst[j][k + 1] == '(') {\n                                        if (k == n - 1 || lst[i][k + 1] == ')' || lst[j][k - 1] == ')') {\n                                            if (k == 0 || lst[i][k - 1] == '(' || lst[j][k + 1] == '(') {\n                                                if (k == n - 1 || lst[i][k + 1] == ')' || lst[j][k - 1] == ')') {\n                                                    if (k == 0 || lst[i][k - 1] == '(' || lst[j][k + 1] == '(') {\n                                                        if (k == n - 1 || lst[i][k + 1] == ')' || lst[j][k - 1] == ')') {\n                                                            if (k == 0 || lst[i][k - 1] == '(' || lst[j][k + 1] ==\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp2szgi56u.d(39): Error: expression expected, not `unittest`\n/tmp/tmp2szgi56u.d(40): Error: found `{` when expecting `)`\n/tmp/tmp2szgi56u.d(56): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp2szgi56u.d(56): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp2szgi56u.d(56): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp2szgi56u.d(56): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp2szgi56u.d(56): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp2szgi56u.d(56): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp2szgi56u.d(56): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp2szgi56u.d(56): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp2szgi56u.d(56): Error: found `End of File` when expecting `}` following compound statement\n/tmp/t",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    int i = 0;\n    int j = n-1;\n    int count = 0;\n    while(i<n && j>=0)\n    {\n        if(lst[i] == '(' && lst[j] == ')')\n        {\n            count++;\n            i++;\n            j--;\n        }\n        else if(lst[i] == '(')\n        {\n            count++;\n            i++;\n        }\n        else if(lst[j] == ')')\n        {\n            count++;\n            j--;\n        }\n        else\n        {\n            count = 0;\n        }\n        if(count > 0)\n        {\n            i++;\n            j--;\n        }\n    }\n    if(count == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp93hcf22i.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmp93hcf22i.d(29): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmp93hcf22i.d(29): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\n/tmp/tmp93hcf22i.d(35): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmp93hcf22i.d(40): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp93hcf22i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int len = lst.length;\n    if(len == 0) return \"Yes\";\n    int i = 0;\n    int j = len - 1;\n    while(i < j) {\n        if(lst[i] == '(' && lst[j] == ')') {\n            i++;\n            j--;\n        } else if(lst[i] == '(') {\n            i++;\n        } else if(lst[j] == ')') {\n            j--;\n        } else {\n            return \"No\";\n        }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpay8cj0_3.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpay8cj0_3.d(28): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpay8cj0_3.d(28): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\n/tmp/tmpay8cj0_3.d(31): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpay8cj0_3.d(33): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpay8cj0_3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n;\n    string s;\n    for(i = 0; i < lst.length; i++)\n    {\n        if(lst[i].length() == 0)\n            continue;\n        n = lst[i].length();\n        for(j = 0; j < n; j++)\n        {\n            if(lst[i][j] == '(')\n            {\n                if(j == n - 1)\n                    return \"Yes\";\n                if(lst[i][j + 1] == '(')\n                {\n                    for(k = j + 2; k < n; k++)\n                    {\n                        if(lst[i][k] == '(')\n                            continue;\n                        else\n                            break;\n                    }\n                    if(k == n)\n                        return \"Yes\";\n                    else\n                        return \"No\";\n                }\n                else\n                    return \"No\";\n            }\n        }\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp5ochtjda.d(27): Error: no property `length` for type `string`\n/tmp/tmp5ochtjda.d(29): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5ochtjda.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n = lst.length;\n    for (i = 0; i < n; i++) {\n        for (j = i + 1; j < n; j++) {\n            if (lst[i][0] == '(' && lst[j][0] == '(') {\n                for (k = 1; k < lst[i].length(); k++) {\n                    if (lst[i][k] == '(')\n                        break;\n                }\n                for (k = 1; k < lst[j].length(); k++) {\n                    if (lst[j][k] == '(')\n                        break;\n                }\n                if (k == lst[i].length() && k == lst[j].length()) {\n                    if (lst[i].substr(1, lst[i].length() - 2) == lst[j].substr(1, lst[j].length() - 2))\n                        return \"Yes\";\n                }\n            }\n        }\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp6ack6qcx.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmp6ack6qcx.d(27): Error: no property `length` for type `string`\n/tmp/tmp6ack6qcx.d(31): Error: no property `length` for type `string`\n/tmp/tmp6ack6qcx.d(35): Error: no property `length` for type `string`\n/tmp/tmp6ack6qcx.d(35): Error: no property `length` for type `string`\n/tmp/tmp6ack6qcx.d(36): Error: no property `substr` for type `string`\n/tmp/tmp6ack6qcx.d(36): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6ack6qcx.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n, m;\n    int p1, p2;\n    string s;\n    \n    for(i = 0; i < lst.length; i++)\n    {\n        for(j = 0; j < lst.length; j++)\n        {\n            if(i != j)\n            {\n                s = lst[i] + lst[j];\n                n = s.length();\n                p1 = 0;\n                p2 = 0;\n                for(k = 0; k < n; k++)\n                {\n                    if(s[k] == '(')\n                        p1++;\n                    else if(s[k] == ')')\n                        p2++;\n                }\n                if(p1 == p2)\n                    return \"Yes\";\n            }\n        }\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp_7lzd5fb.d(33): Error: invalid array operation `lst[cast(ulong)i] + lst[cast(ulong)j]` (possible missing [])\n/tmp/tmp_7lzd5fb.d(34): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_7lzd5fb.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpdnikjuf4.d(33): Error: semicolon expected, not `unittest`\n/tmp/tmpdnikjuf4.d(33): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdnikjuf4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    int i, j;\n    for(i = 0; i < n; i++)\n    {\n        for(j = i + 1; j < n; j++)\n        {\n            if(lst[i][0] == '(' && lst[j][0] == '(')\n            {\n                if(lst[i][1] == ')' && lst[j][1] == ')')\n                {\n                    if(lst[i][2] == ')' && lst[j][2] == ')')\n                    {\n                        if(lst[i][3] == ')' && lst[j][3] == ')')\n                        {\n                            if(lst[i][4] == ')' && lst[j][4] == ')')\n                            {\n                                if(lst[i][5] == ')' && lst[j][5] == ')')\n                                {\n                                    if(lst[i][6] == ')' && lst[j][6] == ')')\n                                    {\n                                        if(lst[i][7] == ')' && lst[j][7] == ')')\n                                        {\n                                            if(lst[i][8] == ')' && lst[j][8] == ')')\n                                            {\n                                                if(lst[i][9] == ')' && lst[j][9] == ')')\n                                                {\n                                                    if(lst[i][10] == ')' && lst[j][10] == ')')\n                                                    {\n                                                        if(lst[i][11] == ')' && lst[j][11] == ')')\n                                                        {\n                                                            if(lst[i][12] == ')' && lst[j][12] == ')')\n                                                            {\n                                                                if(lst[i][13] == ')' && lst[j\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpcxnm4utn.d(56): Error: found `unittest` when expecting `,`\n/tmp/tmpcxnm4utn.d(73): Error: found `void` when expecting `,`\n/tmp/tmpcxnm4utn.d(73): Error: found `{` when expecting `,`\n/tmp/tmpcxnm4utn.d(73): Error: expression expected, not `}`\n/tmp/tmpcxnm4utn.d(73): Error: found `End of File` when expecting `,`\n/tmp/tmpcxnm4utn.d(73): Error: found `End of File` when expecting `]`\n/tmp/tmpcxnm4utn.d(73): Error: found `End of File` when expecting `)`\n/tmp/tmpcxnm4utn.d(73): Error: found `End of File` instead of statement\n/tmp/tmpcxnm4utn.d(73): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpcxnm4utn.d(73): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpcxnm4utn.d(73): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpcxnm4utn.d(73): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpcxnm4utn.d(73): Error: found `End of File` when expecting `}` following compound stateme",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, n = lst.length;\n    for (i = 0; i < n; i++) {\n        for (j = i + 1; j < n; j++) {\n            if (lst[i][0] == '(' && lst[j][0] == '(') {\n                if (lst[i][1] == lst[j][1]) {\n                    if (lst[i][2] == lst[j][2]) {\n                        if (lst[i][3] == lst[j][3]) {\n                            if (lst[i][4] == lst[j][4]) {\n                                if (lst[i][5] == lst[j][5]) {\n                                    if (lst[i][6] == lst[j][6]) {\n                                        if (lst[i][7] == lst[j][7]) {\n                                            if (lst[i][8] == lst[j][8]) {\n                                                if (lst[i][9] == lst[j][9]) {\n                                                    if (lst[i][10] == lst[j][10]) {\n                                                        if (lst[i][11] == lst[j][11]) {\n                                                            if (lst[i][12] == lst[j][12]) {\n                                                                if (lst[i][13] == lst[j][13]) {\n                                                                    if (lst[i][14] == lst[j][14]) {\n                                                                        if (lst[i][15] == lst[j][15]) {\n                                                                            if (lst[i][16] == lst[j][16]) {\n                                                                                if (lst[i][17] == lst[j][17]) {\n                                                                                    if (lst[i][18] == lst[j][18]) {\n                                                                                        if (lst[i][19] == lst[j][19]) {\n                                                               \nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpkx6wh9pr.d(47): Error: found `unittest` instead of statement\n/tmp/tmpkx6wh9pr.d(64): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpkx6wh9pr.d(64): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpkx6wh9pr.d(64): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpkx6wh9pr.d(64): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpkx6wh9pr.d(64): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpkx6wh9pr.d(64): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpkx6wh9pr.d(64): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpkx6wh9pr.d(64): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpkx6wh9pr.d(64): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpkx6wh9pr.d(64): Error: found `End of File` when expectin",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    if (n == 0) return \"Yes\";\n    if (n == 1) return \"No\";\n    \n    int i = 0;\n    int j = 1;\n    int p = 0;\n    int q = 0;\n    \n    while (i < n && j < n) {\n        if (lst[i] == '(') p++;\n        if (lst[j] == ')') q++;\n        if (p == q) {\n            i++;\n            j++;\n        } else if (p > q) {\n            j++;\n        } else {\n            i++;\n        }\n    }\n    \n    if (p == q) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp6zk73zrj.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmp6zk73zrj.d(33): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmp6zk73zrj.d(34): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6zk73zrj.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, n = lst.length;\n    int p1, p2;\n    for (i = 0; i < n; i++) {\n        for (j = i + 1; j < n; j++) {\n            p1 = count_parens(lst[i]);\n            p2 = count_parens(lst[j]);\n            if (p1 != p2)\n                return \"No\";\n        }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp7g75xr6f.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmp7g75xr6f.d(27): Error: undefined identifier `count_parens`\n/tmp/tmp7g75xr6f.d(28): Error: undefined identifier `count_parens`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7g75xr6f.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, m, n;\n    string s;\n    for(i = 0; i < lst.length; i++)\n    {\n        for(j = 0; j < lst[i].length(); j++)\n        {\n            if(lst[i][j] == '(')\n            {\n                m = 0;\n                n = 0;\n                for(k = j; k < lst[i].length(); k++)\n                {\n                    if(lst[i][k] == '(')\n                        m++;\n                    else if(lst[i][k] == ')')\n                        n++;\n                }\n                if(m == n)\n                    s += lst[i][j];\n                else\n                    return \"No\";\n            }\n        }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp2b1erqqe.d(27): Error: no property `length` for type `string`\n/tmp/tmp2b1erqqe.d(33): Error: no property `length` for type `string`\n/tmp/tmp2b1erqqe.d(41): Error: slice `s` is not mutable\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2b1erqqe.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    if (n == 0) return \"Yes\";\n    if (n == 1) return \"No\";\n    \n    int i = 0;\n    int j = 1;\n    int k = 0;\n    int p = 0;\n    int q = 0;\n    \n    while (i < n && j < n) {\n        if (lst[i] == '(') {\n            p++;\n        }\n        if (lst[j] == ')') {\n            q++;\n        }\n        if (p == q) {\n            k++;\n        }\n        if (k == 2) {\n            return \"Yes\";\n        }\n        if (p > q) {\n            i++;\n        }\n        if (q > p) {\n            j++;\n        }\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpwuz6qdt4.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpwuz6qdt4.d(34): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpwuz6qdt4.d(37): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwuz6qdt4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, l, m, n;\n    int paren_count[lst.length];\n    for (i = 0; i < lst.length; i++)\n    {\n        paren_count[i] = 0;\n    }\n    for (i = 0; i < lst.length; i++)\n    {\n        for (j = 0; j < lst[i].length(); j++)\n        {\n            if (lst[i][j] == '(')\n            {\n                paren_count[i]++;\n            }\n            else if (lst[i][j] == ')')\n            {\n                paren_count[i]--;\n            }\n        }\n    }\n    for (i = 0; i < lst.length; i++)\n    {\n        for (j = 0; j < lst[i].length(); j++)\n        {\n            if (lst[i][j] == '(')\n            {\n                paren_count[i]++;\n            }\n            else if (lst[i][j] == ')')\n            {\n                paren_count[i]--;\n            }\n        }\n    }\n    for (i = 0; i < lst.length; i++)\n    {\n        for (j = 0; j < lst[i].length(); j++)\n        {\n            if (lst[i][j] == '(')\n            {\n                paren_count[i]++;\n            }\n            else if (lst[i][j] == ')')\n            {\n                paren_count[i]--;\n            }\n        }\n    }\n    for (i = 0; i < lst.length; i++)\n    {\n        for (j = 0; j < lst[i].length(); j++)\n        {\n            if (lst[i][j] == '(')\n            {\n                paren_count[i]++;\n            }\n            else if (lst[i][j] == ')')\n            {\n                paren_count[i]--;\n            }\n        }\n    }\n    for (i = 0; i\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpv904jks7.d(24): Deprecation: instead of C-style syntax, use D-style syntax `int[lst.length] paren_count`\n/tmp/tmpv904jks7.d(86): Error: found `unittest` when expecting `;` following `for` condition\n/tmp/tmpv904jks7.d(103): Error: found `void` when expecting `)`\n/tmp/tmpv904jks7.d(103): Error: found `{` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv904jks7.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, n = lst.length;\n    for (i = 0; i < n; i++) {\n        for (j = i + 1; j < n; j++) {\n            if (lst[i][0] == '(' && lst[j][0] == ')') {\n                if (lst[i][1] == lst[j][1]) {\n                    lst[i] = lst[i][0] + lst[i][1] + lst[i][2];\n                    lst[j] = lst[j][0] + lst[j][1] + lst[j][2];\n                    lst[i] = lst[i][0] + lst[i][1] + lst[i][2];\n                    lst[j] = lst[j][0] + lst[j][1] + lst[j][2];\n                }\n            }\n        }\n    }\n    for (i = 0; i < n; i++) {\n        if (lst[i][0] == '(')\n            return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp9h4wj2c8.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmp9h4wj2c8.d(28): Error: cannot implicitly convert expression `cast(int)lst[cast(ulong)i][0] + cast(int)lst[cast(ulong)i][1] + cast(int)lst[cast(ulong)i][2]` of type `int` to `string`\n/tmp/tmp9h4wj2c8.d(29): Error: cannot implicitly convert expression `cast(int)lst[cast(ulong)j][0] + cast(int)lst[cast(ulong)j][1] + cast(int)lst[cast(ulong)j][2]` of type `int` to `string`\n/tmp/tmp9h4wj2c8.d(30): Error: cannot implicitly convert expression `cast(int)lst[cast(ulong)i][0] + cast(int)lst[cast(ulong)i][1] + cast(int)lst[cast(ulong)i][2]` of type `int` to `string`\n/tmp/tmp9h4wj2c8.d(31): Error: cannot implicitly convert expression `cast(int)lst[cast(ulong)j][0] + cast(int)lst[cast(ulong)j][1] + cast(int)lst[cast(ulong)j][2]` of type `int` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9h4wj2c8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int l = lst.length;\n    if(l==0) return \"Yes\";\n    if(l==1) return \"No\";\n    int i = 0, j = 0;\n    while(i<l && j<l)\n    {\n        if(lst[i]==\")\" && lst[j]==\"(\")\n        {\n            i++;\n            j++;\n        }\n        else if(lst[i]==\"(\")\n        {\n            i++;\n        }\n        else if(lst[j]==\")\")\n        {\n            j++;\n        }\n        else\n        {\n            return \"No\";\n        }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpp8pvemfr.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp8pvemfr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, len = lst.length;\n    for(i = 0; i < len; i++)\n    {\n        for(j = i + 1; j < len; j++)\n        {\n            if(lst[i][0] == '(' && lst[j][0] == '(')\n            {\n                if(lst[i][1] == ')' && lst[j][1] == ')')\n                {\n                    if(lst[i][2] == ')' && lst[j][2] == ')')\n                    {\n                        if(lst[i][3] == ')' && lst[j][3] == ')')\n                        {\n                            if(lst[i][4] == ')' && lst[j][4] == ')')\n                            {\n                                if(lst[i][5] == ')' && lst[j][5] == ')')\n                                {\n                                    if(lst[i][6] == ')' && lst[j][6] == ')')\n                                    {\n                                        if(lst[i][7] == ')' && lst[j][7] == ')')\n                                        {\n                                            if(lst[i][8] == ')' && lst[j][8] == ')')\n                                            {\n                                                if(lst[i][9] == ')' && lst[j][9] == ')')\n                                                {\n                                                    if(lst[i][10] == ')' && lst[j][10] == ')')\n                                                    {\n                                                        if(lst[i][11] == ')' && lst[j][11] == ')')\n                                                        {\n                                                            if(lst[i][12] == ')' && lst[j][12] == ')')\n                                                            {\n                                                                if(lst[i][13] == ')' && lst[j][13]\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp_l38s3uv.d(55): Error: found `unittest` when expecting `)`\n/tmp/tmp_l38s3uv.d(72): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp_l38s3uv.d(72): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp_l38s3uv.d(72): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp_l38s3uv.d(72): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp_l38s3uv.d(72): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp_l38s3uv.d(72): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp_l38s3uv.d(72): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp_l38s3uv.d(72): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp_l38s3uv.d(72): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp_l38s3uv.d(72): Error: found `End of File` when expecting ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k;\n    int len = lst.length;\n    int count = 0;\n    for (i = 0; i < len; i++) {\n        if (lst[i] == '(') {\n            count++;\n        }\n        else if (lst[i] == ')') {\n            count--;\n        }\n    }\n    if (count == 0) {\n        return \"Yes\";\n    }\n    else {\n        return \"No\";\n    }\n}\n\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp3gxoxsyw.d(24): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmp3gxoxsyw.d(27): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmp3gxoxsyw.d(30): Error: incompatible types for `(lst[cast(ulong)i]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3gxoxsyw.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n = lst.length;\n    int paren_count = 0;\n    for (i = 0; i < n; i++) {\n        if (lst[i] == '(') {\n            paren_count++;\n        } else if (lst[i] == ')') {\n            paren_count--;\n        }\n    }\n    if (paren_count == 0) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpk0q53ax4.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpk0q53ax4.d(26): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpk0q53ax4.d(28): Error: incompatible types for `(lst[cast(ulong)i]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk0q53ax4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n = lst.length;\n    for (i = 0; i < n; i++) {\n        for (j = i + 1; j < n; j++) {\n            if (lst[i][0] == '(' && lst[j][0] == ')') {\n                k = 1;\n                while (lst[i][k] == '(' && lst[j][k] == ')') {\n                    k++;\n                }\n                if (k > 1) {\n                    return \"Yes\";\n                }\n            }\n        }\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpvmyvk3lc.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvmyvk3lc.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, l, m, n;\n    int paren_count = 0;\n    for (i = 0; i < lst.length; i++) {\n        for (j = 0; j < lst[i].length(); j++) {\n            if (lst[i][j] == '(') {\n                paren_count++;\n            }\n            if (lst[i][j] == ')') {\n                paren_count--;\n            }\n        }\n    }\n    if (paren_count == 0) {\n        return \"Yes\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmphmwco6gr.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphmwco6gr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int l = lst.length;\n    if (l == 0) return \"Yes\";\n    if (l == 1) return \"No\";\n    \n    int i = 0;\n    int j = 1;\n    int p = 0;\n    while (i < l && j < l) {\n        if (lst[i] == \")\") {\n            p++;\n        }\n        if (lst[j] == \"(\") {\n            p--;\n        }\n        if (p == 0) {\n            i++;\n            j++;\n        }\n        else {\n            j++;\n        }\n    }\n    if (p == 0) return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpfdr8ufae.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfdr8ufae.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n;\n    n = lst.length;\n    for(i = 0; i < n; i++)\n    {\n        for(j = i + 1; j < n; j++)\n        {\n            if(lst[i][0] == '(' && lst[j][0] == ')')\n            {\n                k = 0;\n                while(lst[i][k] == '(' && lst[j][k] == ')')\n                {\n                    k++;\n                }\n                if(k == 0)\n                {\n                    return \"Yes\";\n                }\n            }\n        }\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpycjwldqv.d(24): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpycjwldqv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n, m, p, q;\n    string s;\n    for (i = 0; i < lst.length; i++)\n    {\n        s = lst[i];\n        n = s.length();\n        for (j = 0; j < n; j++)\n        {\n            if (s[j] == '(')\n            {\n                p = 0;\n                for (k = j; k < n; k++)\n                {\n                    if (s[k] == '(')\n                        p++;\n                    else if (s[k] == ')')\n                    {\n                        if (p == 0)\n                            return \"No\";\n                        p--;\n                    }\n                }\n            }\n        }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpyur3jro_.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyur3jro_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    if (lst.length == 0)\n        return \"Yes\";\n    if (lst.length == 1)\n        return \"No\";\n    if (lst[0] == \"\")\n        return \"No\";\n    if (lst[1] == \"\")\n        return \"No\";\n    if (lst[0][0] == '(' && lst[0][lst[0].length()-1] == ')')\n        return \"No\";\n    if (lst[1][0] == '(' && lst[1][lst[1].length()-1] == ')')\n        return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == '(')\n        return \"No\";\n    if (lst[0][lst[0].length()-1] == ')' && lst[1][lst[1].length()-1] == ')')\n        return \"No\";\n    if (lst[0][0] == '(' && lst[1][lst[1].length()-1] == ')')\n        return \"No\";\n    if (lst[1][0] == '(' && lst[0][lst[0].length()-1] == ')')\n        return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == '(')\n        return \"No\";\n    if (lst[0][lst[0].length()-1] == ')' && lst[1][lst[1].length()-1] == ')')\n        return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == '(')\n        return \"No\";\n    if (lst[0][lst[0].length()-1] == ')' && lst[1][lst[1].length()-1] == ')')\n        return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == '(')\n        return \"No\";\n    if (lst[0][\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpm6cgfe9_.d(54): Error: expression expected, not `unittest`\n/tmp/tmpm6cgfe9_.d(55): Error: found `{` when expecting `,`\n/tmp/tmpm6cgfe9_.d(56): Error: expression expected, not `alias`\n/tmp/tmpm6cgfe9_.d(56): Error: found `candidate` when expecting `,`\n/tmp/tmpm6cgfe9_.d(56): Error: expression expected, not `=`\n/tmp/tmpm6cgfe9_.d(56): Error: found `match_parens` when expecting `,`\n/tmp/tmpm6cgfe9_.d(56): Error: expression expected, not `;`\n/tmp/tmpm6cgfe9_.d(58): Error: found `assert` when expecting `,`\n/tmp/tmpm6cgfe9_.d(58): Error: found `;` when expecting `,`\n/tmp/tmpm6cgfe9_.d(59): Error: found `;` when expecting `,`\n/tmp/tmpm6cgfe9_.d(60): Error: found `;` when expecting `,`\n/tmp/tmpm6cgfe9_.d(61): Error: found `;` when expecting `,`\n/tmp/tmpm6cgfe9_.d(62): Error: found `;` when expecting `,`\n/tmp/tmpm6cgfe9_.d(63): Error: found `;` when expecting `,`\n/tmp/tmpm6cgfe9_.d(64): Error: found `;` when expecting `,`\n/tmp/tmpm6cgfe9_.d(65): Error: found `;` when expecting `,`\n/tmp/tmpm6cgfe9_.d(66): Error",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, len = lst.length;\n    string res = \"\";\n    for(i = 0; i < len; i++)\n    {\n        for(j = i, k = 0; j < len; j++)\n        {\n            if(lst[j] == '(')\n                k++;\n            else if(lst[j] == ')')\n                k--;\n            if(k < 0)\n                return \"No\";\n        }\n        res += lst[i];\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpy7netgtx.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpy7netgtx.d(29): Error: incompatible types for `(lst[cast(ulong)j]) == ('(')`: `string` and `char`\n/tmp/tmpy7netgtx.d(31): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\n/tmp/tmpy7netgtx.d(36): Error: slice `res` is not mutable\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy7netgtx.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    if (n == 0) return \"Yes\";\n    if (n == 1) return \"No\";\n    \n    int i = 0;\n    int j = 1;\n    int k = 0;\n    int p = 0;\n    int q = 0;\n    while (i < n && j < n) {\n        if (lst[i] == '(') p++;\n        if (lst[j] == ')') q++;\n        if (p == q) {\n            k++;\n            i++;\n            j++;\n        } else if (p > q) {\n            j++;\n        } else {\n            i++;\n        }\n    }\n    if (p == q) return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp89w1baga.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmp89w1baga.d(33): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmp89w1baga.d(34): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp89w1baga.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    if (n == 0) return \"Yes\";\n    if (n == 1) return \"No\";\n    if (lst[0] == \"\") return \"No\";\n    if (lst[1] == \"\") return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == '(') return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == ')' && lst[1][0] == '(') return \"No\";\n    if (lst[0][0] == ')' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == ')' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == '(') return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == ')' && lst[1][0] == '(') return \"No\";\n    if (lst[0][0] == ')' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == '(') return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == ')' && lst[1][0] == '(') return \"No\";\n    if (lst[0][0] == ')' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == '('\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpcq45o36e.d(43): Error: found `unittest` when expecting `)`\n/tmp/tmpcq45o36e.d(60): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcq45o36e.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k;\n    int len = lst.length;\n    for (i = 0; i < len; i++) {\n        for (j = i + 1; j < len; j++) {\n            for (k = j + 1; k < len; k++) {\n                if (lst[i] == \"(\" && lst[j] == \"(\" && lst[k] == \")\") {\n                    return \"Yes\";\n                }\n            }\n        }\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp33chn901.d(24): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp33chn901.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    if (n == 0) return \"No\";\n    if (n == 1) return \"Yes\";\n    int i = 0;\n    int j = 1;\n    int k = 0;\n    int p = 0;\n    while (i < n && j < n) {\n        if (lst[i] == '(') {\n            p++;\n            i++;\n        }\n        if (lst[j] == ')') {\n            p--;\n            j++;\n        }\n        if (p == 0) {\n            k++;\n            i++;\n            j++;\n        }\n    }\n    if (p != 0) return \"No\";\n    if (k == n) return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4k10kc38.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmp4k10kc38.d(31): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmp4k10kc38.d(35): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4k10kc38.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    if (n == 0) return \"Yes\";\n    if (n == 1) return \"No\";\n    \n    int i = 0;\n    int j = 1;\n    int k = 0;\n    int p = 0;\n    int q = 0;\n    \n    while (i < n && j < n) {\n        if (lst[i] == '(') {\n            p++;\n            i++;\n        }\n        if (lst[j] == ')') {\n            q++;\n            j++;\n        }\n        if (p == q) {\n            k++;\n            i++;\n            j++;\n        }\n        if (k == n - 1) return \"Yes\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpjahz9rec.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpjahz9rec.d(34): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpjahz9rec.d(38): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjahz9rec.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n = lst.length;\n    int p1, p2;\n    for (i = 0; i < n; i++) {\n        for (j = i + 1; j < n; j++) {\n            p1 = 0;\n            p2 = 0;\n            for (k = 0; k < lst[i].length(); k++) {\n                if (lst[i][k] == '(')\n                    p1++;\n                else if (lst[i][k] == ')')\n                    p2++;\n            }\n            for (k = 0; k < lst[j].length(); k++) {\n                if (lst[j][k] == '(')\n                    p1--;\n                else if (lst[j][k] == ')')\n                    p2--;\n            }\n            if (p1 != 0 || p2 != 0)\n                return \"No\";\n        }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp5olquhmq.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmp5olquhmq.d(29): Error: no property `length` for type `string`\n/tmp/tmp5olquhmq.d(35): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5olquhmq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n = lst.length;\n    int p_cnt[n];\n    for(i = 0; i < n; i++)\n        p_cnt[i] = 0;\n    for(i = 0; i < n; i++)\n        for(j = i; j < n; j++)\n            if(lst[i][0] == '(' && lst[j][0] == ')')\n                p_cnt[i]++;\n            else if(lst[i][0] == ')' && lst[j][0] == '(')\n                p_cnt[i]--;\n    for(i = 0; i < n; i++)\n        if(p_cnt[i] != 0)\n            return \"No\";\n    for(i = 0; i < n; i++)\n        for(j = i; j < n; j++)\n            if(lst[i][0] == '(' && lst[j][0] == ')')\n                p_cnt[i]++;\n            else if(lst[i][0] == ')' && lst[j][0] == '(')\n                p_cnt[i]--;\n    for(i = 0; i < n; i++)\n        if(p_cnt[i] != 0)\n            return \"No\";\n    for(i = 0; i < n; i++)\n        for(j = i; j < n; j++)\n            if(lst[i][0] == '(' && lst[j][0] == ')')\n                p_cnt[i]++;\n            else if(lst[i][0] == ')' && lst[j][0] == '(')\n                p_cnt[i]--;\n    for(i = 0; i < n; i++)\n        if(p_cnt[i] != 0)\n            return \"No\";\n    for(i = 0; i < n; i++)\n        for(j = i; j < n; j++)\n            if(lst[i][0] == '(' && lst[j][0] ==\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp2qrvtodc.d(24): Deprecation: instead of C-style syntax, use D-style syntax `int[n] p_cnt`\n/tmp/tmp2qrvtodc.d(57): Error: expression expected, not `unittest`\n/tmp/tmp2qrvtodc.d(58): Error: found `{` when expecting `)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2qrvtodc.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n = lst.length;\n    for (i = 0; i < n; i++) {\n        for (j = i + 1; j < n; j++) {\n            if (lst[i][0] == '(' && lst[j][0] == '(') {\n                for (k = 0; k < lst[i].length(); k++) {\n                    if (lst[i][k] == '(') {\n                        lst[i][k] = ')';\n                    }\n                    if (lst[j][k] == '(') {\n                        lst[j][k] = ')';\n                    }\n                }\n            }\n        }\n    }\n    for (i = 0; i < n; i++) {\n        if (lst[i][0] == '(') {\n            return \"No\";\n        }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpmly4qz56.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpmly4qz56.d(27): Error: no property `length` for type `string`\n/tmp/tmpmly4qz56.d(29): Error: cannot modify `immutable` expression `lst[cast(ulong)i][cast(ulong)k]`\n/tmp/tmpmly4qz56.d(32): Error: cannot modify `immutable` expression `lst[cast(ulong)j][cast(ulong)k]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmly4qz56.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    if (lst.length == 0) return \"Yes\";\n    if (lst.length == 1) return \"No\";\n    if (lst[0] == \"\") return \"No\";\n    if (lst[1] == \"\") return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == '(') return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == ')' && lst[1][0] == '(') return \"No\";\n    if (lst[0][0] == ')' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == ')' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == '(') return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == ')' && lst[1][0] == '(') return \"No\";\n    if (lst[0][0] == ')' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == ')' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == '(') return \"No\";\n    if (lst[0][0] == '(' && lst[1][0] == ')') return \"No\";\n    if (lst[0][0] == ')' && lst[1][0] == '(') return \"No\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpxus_qx07.d(46): Error: found `\"]) == \"` when expecting `;` following `return` statement\n/tmp/tmpxus_qx07.d(46): Error: found `\");\\x0a    assert(candidate([\"` when expecting `;` following statement\n/tmp/tmpxus_qx07.d(47): Error: found `)` instead of statement\n/tmp/tmpxus_qx07.d(57): Error: unterminated string constant starting at /tmp/tmpxus_qx07.d(57)\n/tmp/tmpxus_qx07.d(59): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxus_qx07.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int len = lst.length;\n    if (len == 0) return \"Yes\";\n    if (len == 1) return \"No\";\n    int i = 0;\n    int j = len - 1;\n    while (i < j) {\n        if (lst[i] == '(' && lst[j] == ')') {\n            i++;\n            j--;\n        } else if (lst[i] == '(') {\n            i++;\n        } else if (lst[j] == ')') {\n            j--;\n        } else {\n            return \"No\";\n        }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpp4egwpsx.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpp4egwpsx.d(29): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpp4egwpsx.d(29): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\n/tmp/tmpp4egwpsx.d(32): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpp4egwpsx.d(34): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp4egwpsx.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n = lst.length;\n    for(i = 0; i < n; i++)\n        for(j = 0; j < n; j++)\n            if(lst[i][j] == '(')\n                for(k = 0; k < n; k++)\n                    if(lst[i][k] == '(' && lst[k][j] == ')')\n                        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmptoycm787.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptoycm787.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, n = lst.length;\n    for (i = 0; i < n; i++) {\n        for (j = i + 1; j < n; j++) {\n            if (lst[i][0] == '(' && lst[j][0] == ')') {\n                if (lst[i][1] == lst[j][1]) {\n                    lst[i] = lst[i][0] + lst[i][1] + lst[i][2];\n                    lst[j] = lst[j][0] + lst[j][1] + lst[j][2];\n                    return \"Yes\";\n                }\n            }\n        }\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpp9jy23gf.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpp9jy23gf.d(28): Error: cannot implicitly convert expression `cast(int)lst[cast(ulong)i][0] + cast(int)lst[cast(ulong)i][1] + cast(int)lst[cast(ulong)i][2]` of type `int` to `string`\n/tmp/tmpp9jy23gf.d(29): Error: cannot implicitly convert expression `cast(int)lst[cast(ulong)j][0] + cast(int)lst[cast(ulong)j][1] + cast(int)lst[cast(ulong)j][2]` of type `int` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp9jy23gf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int len = lst.length;\n    if(len == 0) return \"Yes\";\n    if(len == 1) return \"No\";\n    if(lst[0] == \"\") return \"No\";\n    if(lst[1] == \"\") return \"No\";\n    if(lst[0][0] == '(' && lst[1][0] == '(') return \"No\";\n    if(lst[0][0] == '(' && lst[1][0] == ')') return \"No\";\n    if(lst[0][0] == ')' && lst[1][0] == '(') return \"No\";\n    if(lst[0][0] == ')' && lst[1][0] == ')') return \"No\";\n    if(lst[0][0] == '(' && lst[1][0] == ')') return \"No\";\n    if(lst[0][0] == ')' && lst[1][0] == ')') return \"No\";\n    if(lst[0][0] == '(' && lst[1][0] == '(') return \"No\";\n    if(lst[0][0] == '(' && lst[1][0] == ')') return \"No\";\n    if(lst[0][0] == ')' && lst[1][0] == '(') return \"No\";\n    if(lst[0][0] == ')' && lst[1][0] == ')') return \"No\";\n    if(lst[0][0] == '(' && lst[1][0] == '(') return \"No\";\n    if(lst[0][0] == '(' && lst[1][0] == ')') return \"No\";\n    if(lst[0][0] == ')' && lst[1][0] == '(') return \"No\";\n    if(lst[0][0] == ')' && lst[1][0] == ')') return \"No\";\n    if(lst[0][0] == '(' && lst[1][0] == '('\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmphg9qnzhg.d(43): Error: found `unittest` when expecting `)`\n/tmp/tmphg9qnzhg.d(60): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphg9qnzhg.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n = lst.length;\n    int open = 0, close = 0;\n    for (i = 0; i < n; i++) {\n        if (lst[i] == '(')\n            open++;\n        else if (lst[i] == ')')\n            close++;\n    }\n    if (open != close)\n        return \"No\";\n    for (i = 0; i < n; i++) {\n        if (lst[i] == '(') {\n            for (j = i + 1; j < n; j++) {\n                if (lst[j] == '(')\n                    open++;\n                else if (lst[j] == ')')\n                    close++;\n                if (open == close)\n                    return \"Yes\";\n            }\n        }\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp497k5wv4.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmp497k5wv4.d(26): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmp497k5wv4.d(28): Error: incompatible types for `(lst[cast(ulong)i]) == (')')`: `string` and `char`\n/tmp/tmp497k5wv4.d(34): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmp497k5wv4.d(36): Error: incompatible types for `(lst[cast(ulong)j]) == ('(')`: `string` and `char`\n/tmp/tmp497k5wv4.d(38): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp497k5wv4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    if (n == 0) return \"Yes\";\n    if (n == 1) return \"No\";\n    int i = 0;\n    int j = 1;\n    int p = 0;\n    while (i < n && j < n) {\n        if (lst[i] == '(') p++;\n        if (lst[j] == ')') p--;\n        if (p == 0) {\n            i++;\n            j++;\n        } else {\n            i++;\n        }\n    }\n    if (p == 0) return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpm7_m5csx.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpm7_m5csx.d(30): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpm7_m5csx.d(31): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm7_m5csx.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, len = lst.length;\n    for (i = 0; i < len; i++)\n        for (j = i + 1; j < len; j++)\n            if (lst[i] == \"(\" && lst[j] == \")\")\n                return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpayu4brtw.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpayu4brtw.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, len = lst.length;\n    for (i = 0; i < len; i++) {\n        for (j = i + 1; j < len; j++) {\n            if (lst[i] == \"(\" && lst[j] == \")\") {\n                lst[i] = \"\";\n                lst[j] = \"\";\n            }\n        }\n    }\n    for (i = 0; i < len; i++) {\n        if (lst[i] != \"\") return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp1r1xzqe9.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1r1xzqe9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    if (n == 0) return \"Yes\";\n    if (n == 1) return \"No\";\n    \n    int i = 0;\n    int j = n - 1;\n    while (i < j) {\n        if (lst[i] == '(' && lst[j] == ')') {\n            i++;\n            j--;\n        } else if (lst[i] == '(') {\n            i++;\n        } else if (lst[j] == ')') {\n            j--;\n        } else {\n            return \"No\";\n        }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmps5wc3lfn.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmps5wc3lfn.d(30): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmps5wc3lfn.d(30): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\n/tmp/tmps5wc3lfn.d(33): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmps5wc3lfn.d(35): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps5wc3lfn.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    if (n == 0) return \"Yes\";\n    if (n == 1) return \"No\";\n    \n    int i = 0, j = n-1;\n    while (i < j) {\n        if (lst[i] == '(' && lst[j] == ')') {\n            i++;\n            j--;\n        } else if (lst[i] == '(') {\n            i++;\n        } else if (lst[j] == ')') {\n            j--;\n        } else {\n            return \"No\";\n        }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmphj0hyv6e.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmphj0hyv6e.d(29): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmphj0hyv6e.d(29): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\n/tmp/tmphj0hyv6e.d(32): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmphj0hyv6e.d(34): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphj0hyv6e.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n = lst.length;\n    int p_cnt = 0, c_cnt = 0;\n    for (i = 0; i < n; i++) {\n        if (lst[i] == '(') p_cnt++;\n        else if (lst[i] == ')') c_cnt++;\n    }\n    if (p_cnt == c_cnt) return \"Yes\";\n    else return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpt99ndaip.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpt99ndaip.d(26): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpt99ndaip.d(27): Error: incompatible types for `(lst[cast(ulong)i]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt99ndaip.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l,\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpo05xvka8.d(24): Error: no identifier for declarator `int`\n/tmp/tmpo05xvka8.d(24): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo05xvka8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n = lst.length;\n    int p1, p2;\n    for (i = 0; i < n; i++) {\n        for (j = i + 1; j < n; j++) {\n            p1 = 0;\n            p2 = 0;\n            for (k = 0; k < lst[i].length(); k++) {\n                if (lst[i][k] == '(')\n                    p1++;\n                else if (lst[i][k] == ')')\n                    p2++;\n            }\n            for (k = 0; k < lst[j].length(); k++) {\n                if (lst[j][k] == '(')\n                    p1--;\n                else if (lst[j][k] == ')')\n                    p2--;\n            }\n            if (p1 != 0 || p2 != 0)\n                return \"No\";\n        }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp5olquhmq.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmp5olquhmq.d(29): Error: no property `length` for type `string`\n/tmp/tmp5olquhmq.d(35): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5olquhmq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n = lst.length;\n    for(i = 0; i < n; i++)\n    {\n        for(j = i + 1; j < n; j++)\n        {\n            if(lst[i][0] == '(' && lst[j][0] == '(')\n            {\n                for(k = 1; k < lst[i].length(); k++)\n                {\n                    if(lst[i][k] == '(')\n                    {\n                        break;\n                    }\n                }\n                for(k = 1; k < lst[j].length(); k++)\n                {\n                    if(lst[j][k] == '(')\n                    {\n                        break;\n                    }\n                }\n                if(k == lst[i].length() && k == lst[j].length())\n                {\n                    return \"Yes\";\n                }\n            }\n        }\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpe9icp77u.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpe9icp77u.d(30): Error: no property `length` for type `string`\n/tmp/tmpe9icp77u.d(37): Error: no property `length` for type `string`\n/tmp/tmpe9icp77u.d(44): Error: no property `length` for type `string`\n/tmp/tmpe9icp77u.d(44): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe9icp77u.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    if(n < 2)\n        return \"Yes\";\n    int i, j, k;\n    for(i = 0; i < n; i++)\n    {\n        if(lst[i][0] != '(')\n            continue;\n        for(j = i + 1; j < n; j++)\n        {\n            if(lst[j][0] != ')')\n                continue;\n            for(k = 0; k < n; k++)\n            {\n                if(lst[k][0] == '(')\n                    break;\n            }\n            if(k == n)\n                return \"Yes\";\n        }\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpkg_jux2s.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkg_jux2s.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int len = lst.length;\n    if (len == 0) return \"Yes\";\n    int i = 0;\n    int j = len - 1;\n    while (i < j) {\n        if (lst[i] == '(' && lst[j] == ')') {\n            i++;\n            j--;\n        } else if (lst[i] == '(') {\n            return \"No\";\n        } else if (lst[j] == ')') {\n            return \"No\";\n        } else {\n            i++;\n            j--;\n        }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp31k2surw.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmp31k2surw.d(28): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmp31k2surw.d(28): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\n/tmp/tmp31k2surw.d(31): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmp31k2surw.d(33): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp31k2surw.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int len = lst.length;\n    if (len == 0) return \"Yes\";\n    if (len == 1) return \"No\";\n    \n    int i = 0;\n    int j = 1;\n    int k = 0;\n    int p = 0;\n    int q = 0;\n    \n    while (i < len && j < len) {\n        if (lst[i] == '(') {\n            p++;\n        }\n        if (lst[j] == ')') {\n            q++;\n        }\n        if (p == q) {\n            i++;\n            j++;\n        }\n        else if (p > q) {\n            j++;\n        }\n        else {\n            i++;\n        }\n        k++;\n    }\n    if (p == q) {\n        return \"Yes\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpb2dmnoit.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpb2dmnoit.d(34): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpb2dmnoit.d(37): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb2dmnoit.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    if (n == 0) return \"Yes\";\n    if (n == 1) return \"No\";\n    \n    int i = 0;\n    int j = 1;\n    int p = 0;\n    int q = 0;\n    \n    while (i < n && j < n) {\n        if (lst[i] == '(') {\n            p++;\n        }\n        if (lst[j] == ')') {\n            q++;\n        }\n        if (p == q) {\n            i++;\n            j++;\n        } else if (p > q) {\n            j++;\n        } else {\n            i++;\n        }\n    }\n    \n    if (p == q) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp5j6w83ng.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmp5j6w83ng.d(33): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmp5j6w83ng.d(36): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5j6w83ng.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int l = lst.length;\n    if (l == 0) return \"Yes\";\n    if (l == 1) return \"No\";\n    int i = 0;\n    int j = 1;\n    int k = 0;\n    int p = 0;\n    int q = 0;\n    while (i < l && j < l) {\n        if (lst[i] == '(') {\n            p++;\n        }\n        if (lst[j] == ')') {\n            q++;\n        }\n        if (p == q) {\n            k++;\n        }\n        if (k == 2) {\n            return \"Yes\";\n        }\n        if (lst[i] == ')') {\n            i++;\n        }\n        if (lst[j] == '(') {\n            j++;\n        }\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpoq_a6v05.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpoq_a6v05.d(32): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpoq_a6v05.d(35): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\n/tmp/tmpoq_a6v05.d(44): Error: incompatible types for `(lst[cast(ulong)i]) == (')')`: `string` and `char`\n/tmp/tmpoq_a6v05.d(47): Error: incompatible types for `(lst[cast(ulong)j]) == ('(')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoq_a6v05.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    if (n == 0) return \"Yes\";\n    if (n == 1) return \"No\";\n    \n    int i = 0;\n    int j = 1;\n    int p = 0;\n    int q = 0;\n    while (i < n && j < n) {\n        if (lst[i] == '(') p++;\n        if (lst[j] == ')') q++;\n        if (p == q) {\n            i++;\n            j++;\n        } else if (p > q) {\n            j++;\n        } else {\n            i++;\n        }\n    }\n    \n    if (p == q) return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmps8zgfuf3.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmps8zgfuf3.d(32): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmps8zgfuf3.d(33): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps8zgfuf3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, n = lst.length;\n    for (i = 0; i < n; i++) {\n        for (j = i + 1; j < n; j++) {\n            if (lst[i][0] == '(' && lst[j][0] == '(') {\n                if (lst[i][1] == '(' && lst[j][1] == ')') {\n                    if (lst[i][2] == '(' && lst[j][2] == ')') {\n                        if (lst[i][3] == '(' && lst[j][3] == ')') {\n                            if (lst[i][4] == '(' && lst[j][4] == ')') {\n                                if (lst[i][5] == '(' && lst[j][5] == ')') {\n                                    if (lst[i][6] == '(' && lst[j][6] == ')') {\n                                        if (lst[i][7] == '(' && lst[j][7] == ')') {\n                                            if (lst[i][8] == '(' && lst[j][8] == ')') {\n                                                if (lst[i][9] == '(' && lst[j][9] == ')') {\n                                                    if (lst[i][10] == '(' && lst[j][10] == ')') {\n                                                        if (lst[i][11] == '(' && lst[j][11] == ')') {\n                                                            if (lst[i][12] == '(' && lst[j][12] == ')') {\n                                                                if (lst[i][13] == '(' && lst[j][13] == ')') {\n                                                                    if (lst[i][14] == '(' && lst[j][14] == ')') {\n                                                                        if (lst[i][15] == '(' && lst[j][15\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp7m0jeoql.d(42): Error: found `unittest` when expecting `,`\n/tmp/tmp7m0jeoql.d(59): Error: found `void` when expecting `,`\n/tmp/tmp7m0jeoql.d(59): Error: found `{` when expecting `,`\n/tmp/tmp7m0jeoql.d(59): Error: expression expected, not `}`\n/tmp/tmp7m0jeoql.d(59): Error: found `End of File` when expecting `,`\n/tmp/tmp7m0jeoql.d(59): Error: found `End of File` when expecting `]`\n/tmp/tmp7m0jeoql.d(59): Error: found `End of File` when expecting `)`\n/tmp/tmp7m0jeoql.d(59): Error: found `End of File` instead of statement\n/tmp/tmp7m0jeoql.d(59): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp7m0jeoql.d(59): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp7m0jeoql.d(59): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp7m0jeoql.d(59): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp7m0jeoql.d(59): Error: found `End of File` when expecting `}` following compound stateme",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int len = lst.length;\n    if (len < 2) return \"No\";\n    int i = 0;\n    int j = len - 1;\n    while (i < j) {\n        if (lst[i] == '(' && lst[j] == ')') {\n            i++;\n            j--;\n        } else if (lst[i] == '(' && lst[j] != ')') {\n            return \"No\";\n        } else if (lst[i] != '(' && lst[j] == ')') {\n            return \"No\";\n        } else {\n            i++;\n            j--;\n        }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpxki7sjve.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpxki7sjve.d(28): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpxki7sjve.d(28): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\n/tmp/tmpxki7sjve.d(31): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpxki7sjve.d(31): Error: incompatible types for `(lst[cast(ulong)j]) != (')')`: `string` and `char`\n/tmp/tmpxki7sjve.d(33): Error: incompatible types for `(lst[cast(ulong)i]) != ('(')`: `string` and `char`\n/tmp/tmpxki7sjve.d(33): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxki7sjve.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n, m;\n    int p1, p2;\n    int count = 0;\n    int max_count = 0;\n    int max_count_index = 0;\n    for (i = 0; i < lst.length; i++) {\n        for (j = 0; j < lst.length; j++) {\n            if (i != j) {\n                count = 0;\n                for (k = 0; k < lst[i].length(); k++) {\n                    if (lst[i][k] == '(') {\n                        count++;\n                    }\n                }\n                for (k = 0; k < lst[j].length(); k++) {\n                    if (lst[j][k] == '(') {\n                        count++;\n                    }\n                }\n                if (count == 0) {\n                    max_count = count;\n                    max_count_index = i;\n                }\n                else if (count > max_count) {\n                    max_count = count;\n                    max_count_index = i;\n                }\n            }\n        }\n    }\n    if (max_count == 0) {\n        return \"No\";\n    }\n    else {\n        for (i = 0; i < lst[max_count_index].length(); i++) {\n            if (lst[max_count_index][i] == '(') {\n                p1 = i;\n            }\n            if (lst[max_count_index][i] == ')') {\n                p2 = i;\n            }\n        }\n        for (i = p1 + 1; i < lst[max_count_index].length(); i++) {\n            if (lst[max_count_index][i] == '(') {\n                p1 = i;\n            }\n            if (lst[max_count_index][i] == ')') {\n                p2 = i;\n            }\n        }\n        for (i = p2 + 1; i < lst[max_count_index].length(); i++) {\n            if (lst[max_count_index][i] == '(')\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpdhst2e9y.d(75): Error: found `unittest` instead of statement\n/tmp/tmpdhst2e9y.d(92): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpdhst2e9y.d(92): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdhst2e9y.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, l, m, n;\n    int len = lst.length;\n    int paren_count = 0;\n    for (i = 0; i < len; i++) {\n        if (lst[i] == '(') {\n            paren_count++;\n        }\n        if (lst[i] == ')') {\n            paren_count--;\n        }\n    }\n    if (paren_count == 0) {\n        return \"Yes\";\n    }\n    else {\n        return \"No\";\n    }\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpgk4f_rki.d(24): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpgk4f_rki.d(27): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpgk4f_rki.d(30): Error: incompatible types for `(lst[cast(ulong)i]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgk4f_rki.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    int i, j, k;\n    for (i = 0; i < n; i++) {\n        for (j = i + 1; j < n; j++) {\n            for (k = j + 1; k < n; k++) {\n                if (lst[i][0] == '(' && lst[j][0] == '(' && lst[k][0] == '(') {\n                    if (lst[i][1] == ')' && lst[j][1] == ')' && lst[k][1] == ')') {\n                        if (lst[i][2] == ')' && lst[j][2] == ')' && lst[k][2] == ')') {\n                            if (lst[i][3] == ')' && lst[j][3] == ')' && lst[k][3] == ')') {\n                                if (lst[i][4] == ')' && lst[j][4] == ')' && lst[k][4] == ')') {\n                                    if (lst[i][5] == ')' && lst[j][5] == ')' && lst[k][5] == ')') {\n                                        if (lst[i][6] == ')' && lst[j][6] == ')' && lst[k][6] == ')') {\n                                            if (lst[i][7] == ')' && lst[j][7] == ')' && lst[k][7] == ')') {\n                                                if (lst[i][8] == ')' && lst[j][8] == ')' && lst[k][8] == ')') {\n                                                    if (lst[i][9] == ')' && lst[j][9] == ')' && lst[k][9] == ')') {\n                                                        if (lst[i][10] == ')' && lst[j][10] == ')' && lst[k][10] == ')') {\n                                  \nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpw8i6t8w9.d(40): Error: found `unittest` instead of statement\n/tmp/tmpw8i6t8w9.d(57): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpw8i6t8w9.d(57): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpw8i6t8w9.d(57): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpw8i6t8w9.d(57): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpw8i6t8w9.d(57): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpw8i6t8w9.d(57): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpw8i6t8w9.d(57): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpw8i6t8w9.d(57): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpw8i6t8w9.d(57): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpw8i6t8w9.d(57): Error: found `End of File` when expectin",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    if (n == 0) return \"Yes\";\n    if (n == 1) return \"No\";\n    if (lst[0] == \"\") return \"No\";\n    if (lst[n-1] == \"\") return \"No\";\n    if (lst[0] == \"(\" && lst[n-1] == \")\") return \"Yes\";\n    if (lst[0] == \")\" && lst[n-1] == \")\") return \"Yes\";\n    if (lst[0] == \"(\" && lst[n-1] == \"(\" && match_parens(lst.substr(1, n-2))) return \"Yes\";\n    if (lst[0] == \")\" && lst[n-1] == \"(\" && match_parens(lst.substr(1, n-2))) return \"Yes\";\n    if (lst[0] == \"(\" && lst[n-1] == \")\" && match_parens(lst.substr(1, n-2))) return \"Yes\";\n    if (lst[0] == \")\" && lst[n-1] == \")\" && match_parens(lst.substr(1, n-2))) return \"Yes\";\n    if (lst[0] == \"(\" && lst[n-1] == \")\" && match_parens(lst.substr(1, n-2))) return \"Yes\";\n    if (lst[0] == \")\" && lst[n-1] == \"(\" && match_parens(lst.substr(1, n-2))) return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp_bpmkyug.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmp_bpmkyug.d(30): Error: no property `substr` for type `string[]`\n/tmp/tmp_bpmkyug.d(31): Error: no property `substr` for type `string[]`\n/tmp/tmp_bpmkyug.d(32): Error: no property `substr` for type `string[]`\n/tmp/tmp_bpmkyug.d(33): Error: no property `substr` for type `string[]`\n/tmp/tmp_bpmkyug.d(34): Error: no property `substr` for type `string[]`\n/tmp/tmp_bpmkyug.d(35): Error: no property `substr` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_bpmkyug.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    if (n == 0) return \"Yes\";\n    if (n == 1) return \"No\";\n    \n    int i = 0;\n    int j = 1;\n    int k = 0;\n    int p = 0;\n    int q = 0;\n    \n    while (i < n && j < n) {\n        if (lst[i] == '(') {\n            p++;\n        }\n        if (lst[j] == ')') {\n            q++;\n        }\n        if (p == q) {\n            k++;\n        }\n        if (k == 2) {\n            return \"Yes\";\n        }\n        if (p > q) {\n            i++;\n        } else {\n            j++;\n        }\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpxxsqql1t.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpxxsqql1t.d(34): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpxxsqql1t.d(37): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxxsqql1t.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n = lst.length;\n    for(i = 0; i < n; i++)\n    {\n        for(j = i + 1; j < n; j++)\n        {\n            for(k = 0; k < n; k++)\n            {\n                if(lst[i][k] == '(' && lst[j][k] == ')')\n                {\n                    if(lst[i][k + 1] == '(' && lst[j][k + 1] == ')')\n                    {\n                        if(i == 0 || j == 0)\n                        {\n                            if(i == 0 && j == 0)\n                            {\n                                return \"Yes\";\n                            }\n                            else\n                            {\n                                return \"No\";\n                            }\n                        }\n                        else\n                        {\n                            if(i == 0 && j == 0)\n                            {\n                                return \"No\";\n                            }\n                            else\n                            {\n                                return \"Yes\";\n                            }\n                        }\n                    }\n                    else\n                    {\n                        if(i == 0 && j == 0)\n                        {\n                            return \"No\";\n                        }\n                        else\n                        {\n                            return \"Yes\";\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpeht0a0d6.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeht0a0d6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n, m;\n    int paren_count[2];\n    for(i = 0; i < 2; i++)\n        paren_count[i] = 0;\n    for(i = 0; i < lst.length; i++)\n    {\n        for(j = 0; j < lst[i].length(); j++)\n        {\n            if(lst[i][j] == '(')\n                paren_count[0]++;\n            else if(lst[i][j] == ')')\n                paren_count[1]++;\n        }\n    }\n    if(paren_count[0] == 0 || paren_count[1] == 0)\n        return \"No\";\n    n = paren_count[0];\n    m = paren_count[1];\n    for(i = 0; i < lst.length; i++)\n    {\n        for(j = 0; j < lst[i].length(); j++)\n        {\n            if(lst[i][j] == '(')\n                n--;\n            else if(lst[i][j] == ')')\n                m--;\n        }\n        if(n < 0 || m < 0)\n            return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpn05jblap.d(24): Deprecation: instead of C-style syntax, use D-style syntax `int[2] paren_count`\n/tmp/tmpn05jblap.d(29): Error: no property `length` for type `string`\n/tmp/tmpn05jblap.d(43): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn05jblap.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int len = lst.length;\n    if (len == 0) return \"Yes\";\n    if (len == 1) return \"No\";\n    \n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < len) {\n        if (lst[i] == '(') {\n            count++;\n        } else if (lst[i] == ')') {\n            count--;\n        }\n        i++;\n    }\n    if (count == 0) return \"Yes\";\n    \n    i = 0;\n    j = len - 1;\n    while (i < j) {\n        if (lst[i] == '(') {\n            count++;\n        } else if (lst[i] == ')') {\n            count--;\n        }\n        i++;\n    }\n    if (count == 0) return \"Yes\";\n    \n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4q85fsbz.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmp4q85fsbz.d(31): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmp4q85fsbz.d(33): Error: incompatible types for `(lst[cast(ulong)i]) == (')')`: `string` and `char`\n/tmp/tmp4q85fsbz.d(43): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmp4q85fsbz.d(45): Error: incompatible types for `(lst[cast(ulong)i]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4q85fsbz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    int i = 0;\n    int j = 0;\n    int p = 0;\n    int q = 0;\n    int m = 0;\n    int k = 0;\n    int l = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpwsbbyhkx.d(96): Error: semicolon expected, not `unittest`\n/tmp/tmpwsbbyhkx.d(96): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwsbbyhkx.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k;\n    int len = lst.length;\n    int paren_count = 0;\n    for (i = 0; i < len; i++)\n    {\n        if (lst[i] == '(')\n            paren_count++;\n        else if (lst[i] == ')')\n            paren_count--;\n    }\n    if (paren_count == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "/tmp/tmp19wko2qg.d(24): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmp19wko2qg.d(28): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmp19wko2qg.d(30): Error: incompatible types for `(lst[cast(ulong)i]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp19wko2qg.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n = lst.length;\n    int p[n][n];\n    for(i = 0; i < n; i++)\n        for(j = 0; j < n; j++)\n            p[i][j] = 0;\n    for(i = 0; i < n; i++)\n        for(j = 0; j < n; j++)\n            if(lst[i][j] == '(')\n                p[i][j] = 1;\n            else if(lst[i][j] == ')')\n                p[i][j] = -1;\n    for(i = 0; i < n; i++)\n        for(j = 0; j < n; j++)\n            if(p[i][j] == 1)\n                for(k = 0; k < n; k++)\n                    if(p[i][k] == -1 && p[k][j] == 1)\n                        p[i][j] = 0;\n    for(i = 0; i < n; i++)\n        for(j = 0; j < n; j++)\n            if(p[i][j] == 1)\n                return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "/tmp/tmpn2wiqziu.d(24): Deprecation: instead of C-style syntax, use D-style syntax `int[n][n] p`\n/tmp/tmpn2wiqziu.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpn2wiqziu.d(24): Error: variable `n` cannot be read at compile time\n/tmp/tmpn2wiqziu.d(24): Error: variable `n` cannot be read at compile time\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn2wiqziu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k;\n    int len = lst.length;\n    int open_p = 0;\n    int close_p = 0;\n    for (i = 0; i < len; i++) {\n        if (lst[i] == '(') {\n            open_p++;\n        } else if (lst[i] == ')') {\n            close_p++;\n        }\n    }\n    if (open_p == close_p) {\n        return \"Yes\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "/tmp/tmpa_dz8usf.d(24): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpa_dz8usf.d(28): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpa_dz8usf.d(30): Error: incompatible types for `(lst[cast(ulong)i]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa_dz8usf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, n = lst.length;\n    for (i = 0; i < n; i++) {\n        for (j = i + 1; j < n; j++) {\n            if (lst[i][0] == '(' && lst[j][0] == ')') {\n                if (lst[i][1] == '(' && lst[j][1] == ')') {\n                    if (lst[i][2] == '(' && lst[j][2] == ')') {\n                        if (lst[i][3] == '(' && lst[j][3] == ')') {\n                            if (lst[i][4] == '(' && lst[j][4] == ')') {\n                                if (lst[i][5] == '(' && lst[j][5] == ')') {\n                                    if (lst[i][6] == '(' && lst[j][6] == ')') {\n                                        if (lst[i][7] == '(' && lst[j][7] == ')') {\n                                            if (lst[i][8] == '(' && lst[j][8] == ')') {\n                                                if (lst[i][9] == '(' && lst[j][9] == ')') {\n                                                    if (lst[i][10] == '(' && lst[j][10] == ')') {\n                                                        if (lst[i][11] == '(' && lst[j][11] == ')') {\n                                                            if (lst[i][12] == '(' && lst[j][12] == ')') {\n                                                                if (lst[i][13] == '(' && lst[j][13] == ')') {\n                                                                    if (lst[i][14] == '(' && lst[j][14] == ')') {\n                                                                        if (lst[i][15] == '(' && lst[j][15\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpfze8og_y.d(42): Error: found `unittest` when expecting `,`\n/tmp/tmpfze8og_y.d(59): Error: found `void` when expecting `,`\n/tmp/tmpfze8og_y.d(59): Error: found `{` when expecting `,`\n/tmp/tmpfze8og_y.d(59): Error: expression expected, not `}`\n/tmp/tmpfze8og_y.d(59): Error: found `End of File` when expecting `,`\n/tmp/tmpfze8og_y.d(59): Error: found `End of File` when expecting `]`\n/tmp/tmpfze8og_y.d(59): Error: found `End of File` when expecting `)`\n/tmp/tmpfze8og_y.d(59): Error: found `End of File` instead of statement\n/tmp/tmpfze8og_y.d(59): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpfze8og_y.d(59): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpfze8og_y.d(59): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpfze8og_y.d(59): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpfze8og_y.d(59): Error: found `End of File` when expecting `}` following compound stateme",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int len = lst.length;\n    if(len == 0) return \"Yes\";\n    if(len == 1) return \"No\";\n    int i = 0, j = len - 1;\n    while(i < j) {\n        if(lst[i] == '(' && lst[j] == ')') {\n            i++;\n            j--;\n        } else if(lst[i] == '(') {\n            i++;\n        } else if(lst[j] == ')') {\n            j--;\n        } else {\n            return \"No\";\n        }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "/tmp/tmp7kdycjl_.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmp7kdycjl_.d(28): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmp7kdycjl_.d(28): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\n/tmp/tmp7kdycjl_.d(31): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmp7kdycjl_.d(33): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7kdycjl_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i,j,k;\n    int len = lst.length;\n    int open = 0;\n    int close = 0;\n    for(i=0; i<len; i++)\n    {\n        if(lst[i] == '(')\n            open++;\n        else if(lst[i] == ')')\n            close++;\n    }\n    if(open == close)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "/tmp/tmpaamv5j4j.d(24): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpaamv5j4j.d(29): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpaamv5j4j.d(31): Error: incompatible types for `(lst[cast(ulong)i]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpaamv5j4j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, l;\n    int len = lst.length;\n    for (i = 0; i < len; i++) {\n        for (j = i + 1; j < len; j++) {\n            for (k = j + 1; k < len; k++) {\n                for (l = k + 1; l < len; l++) {\n                    if (lst[i] + lst[j] + lst[k] + lst[l] == \"()()()\") {\n                        return \"Yes\";\n                    }\n                }\n            }\n        }\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "/tmp/tmpbt42js76.d(24): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpbt42js76.d(29): Error: invalid array operation `lst[cast(ulong)i] + lst[cast(ulong)j]` (possible missing [])\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbt42js76.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n = lst.length;\n    int p1 = 0, p2 = 0;\n    for(i = 0; i < n; i++)\n    {\n        if(lst[i] == '(')\n            p1++;\n        else if(lst[i] == ')')\n            p2++;\n    }\n    if(p1 == p2)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "/tmp/tmpfvw_4enm.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpfvw_4enm.d(27): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpfvw_4enm.d(29): Error: incompatible types for `(lst[cast(ulong)i]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfvw_4enm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, l, m, n, p;\n    string s;\n    \n    for (i = 0; i < lst.length; i++) {\n        if (lst[i].length() == 0)\n            continue;\n        \n        if (lst[i][0] == '(') {\n            p = 1;\n            for (j = 1; j < lst[i].length(); j++) {\n                if (lst[i][j] == '(')\n                    p++;\n                else if (lst[i][j] == ')')\n                    p--;\n                if (p < 0)\n                    return \"No\";\n            }\n        }\n        else {\n            p = 1;\n            for (j = 1; j < lst[i].length(); j++) {\n                if (lst[i][j] == ')')\n                    p++;\n                else if (lst[i][j] == '(')\n                    p--;\n                if (p < 0)\n                    return \"No\";\n            }\n        }\n    }\n    \n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "/tmp/tmppa71rqat.d(27): Error: no property `length` for type `string`\n/tmp/tmppa71rqat.d(32): Error: no property `length` for type `string`\n/tmp/tmppa71rqat.d(43): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppa71rqat.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n, m, p, q, r;\n    int l = lst.length;\n    int[][] dp = new int[l][l];\n    \n    for(i = 0; i < l; i++)\n    {\n        for(j = 0; j < l; j++)\n        {\n            if(i == j)\n                dp[i][j] = 0;\n            else\n                dp[i][j] = -1;\n        }\n    }\n    \n    for(i = 0; i < l; i++)\n    {\n        for(j = 0; j < l; j++)\n        {\n            if(i == j)\n                continue;\n            \n            if(lst[i][0] == '(' && lst[j][0] == '(')\n            {\n                dp[i][j] = 0;\n                continue;\n            }\n            \n            if(lst[i][0] == '(' && lst[j][0] == ')')\n            {\n                dp[i][j] = 1;\n                continue;\n            }\n            \n            if(lst[i][0] == ')' && lst[j][0] == '(')\n            {\n                dp[i][j] = 2;\n                continue;\n            }\n            \n            if(lst[i][0] == ')' && lst[j][0] == ')')\n            {\n                dp[i][j] = 3;\n                continue;\n            }\n            \n            if(lst[i][0] == '(' && lst[j][0] == ')')\n            {\n                dp[i][j] = 4;\n                continue;\n            }\n            \n            if(lst[i][0] == ')' && lst[j][0] == ')')\n            {\n                dp[i][j] = 5;\n                continue;\n            }\n            \n            if(lst[i][0] == '(' && lst[j][0] == '(')\n            {\n                dp[i][j] = 6;\n                continue;\n            \nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpnaowbj47.d(86): Error: found `unittest` instead of statement\n/tmp/tmpnaowbj47.d(103): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpnaowbj47.d(103): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpnaowbj47.d(103): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnaowbj47.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k;\n    int len = lst.length;\n    int paren_count = 0;\n    for(i = 0; i < len; i++)\n    {\n        if(lst[i] == '(')\n            paren_count++;\n        else if(lst[i] == ')')\n            paren_count--;\n    }\n    if(paren_count == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpv1_2riae.d(24): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpv1_2riae.d(28): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpv1_2riae.d(30): Error: incompatible types for `(lst[cast(ulong)i]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv1_2riae.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int len = lst.length;\n    if (len == 0) return \"Yes\";\n    if (len == 1) return \"No\";\n    int i = 0;\n    int j = len - 1;\n    while (i < j) {\n        if (lst[i] == '(' && lst[j] == ')') {\n            i++;\n            j--;\n        } else if (lst[i] == '(') {\n            i++;\n        } else if (lst[j] == ')') {\n            j--;\n        } else {\n            return \"No\";\n        }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpp4egwpsx.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpp4egwpsx.d(29): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpp4egwpsx.d(29): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\n/tmp/tmpp4egwpsx.d(32): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpp4egwpsx.d(34): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp4egwpsx.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    if (n == 0) return \"Yes\";\n    if (n == 1) return \"No\";\n    \n    int i = 0, j = n - 1;\n    while (i < j) {\n        if (lst[i] == '(' && lst[j] == ')') {\n            j--;\n        } else if (lst[i] == ')' && lst[j] == '(') {\n            i++;\n        } else {\n            return \"No\";\n        }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "/tmp/tmpw8wai8oi.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpw8wai8oi.d(29): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpw8wai8oi.d(29): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\n/tmp/tmpw8wai8oi.d(31): Error: incompatible types for `(lst[cast(ulong)i]) == (')')`: `string` and `char`\n/tmp/tmpw8wai8oi.d(31): Error: incompatible types for `(lst[cast(ulong)j]) == ('(')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw8wai8oi.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n = lst.length;\n    for (i = 0; i < n; i++) {\n        for (j = i + 1; j < n; j++) {\n            for (k = 0; k < n; k++) {\n                if (lst[i][k] == '(' && lst[j][k] == ')') {\n                    if (k + 1 < n && lst[i][k + 1] == '(' && lst[j][k + 1] == ')') {\n                        lst[i][k] = ')';\n                        lst[j][k] = '(';\n                    }\n                }\n            }\n        }\n    }\n    for (i = 0; i < n; i++) {\n        for (j = 0; j < n; j++) {\n            if (lst[i][j] == '(') {\n                return \"No\";\n            }\n        }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "/tmp/tmpu489rk7f.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpu489rk7f.d(29): Error: cannot modify `immutable` expression `lst[cast(ulong)i][cast(ulong)k]`\n/tmp/tmpu489rk7f.d(30): Error: cannot modify `immutable` expression `lst[cast(ulong)j][cast(ulong)k]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu489rk7f.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n = lst.length;\n    int p_cnt = 0;\n    for(i = 0; i < n; i++)\n    {\n        if(lst[i] == '(')\n            p_cnt++;\n        else if(lst[i] == ')')\n            p_cnt--;\n    }\n    if(p_cnt == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "/tmp/tmp770ame0g.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmp770ame0g.d(27): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmp770ame0g.d(29): Error: incompatible types for `(lst[cast(ulong)i]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp770ame0g.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n = lst.length;\n    for(i = 0; i < n; i++)\n    {\n        for(j = i + 1; j < n; j++)\n        {\n            if(lst[i][0] == '(' && lst[j][0] == '(')\n            {\n                for(k = 1; k < lst[i].length(); k++)\n                {\n                    if(lst[i][k] == '(')\n                    {\n                        if(lst[j].length() - k < lst[j].length())\n                        {\n                            break;\n                        }\n                    }\n                }\n                if(k == lst[i].length())\n                {\n                    return \"Yes\";\n                }\n            }\n        }\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "/tmp/tmp74ceenle.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmp74ceenle.d(30): Error: no property `length` for type `string`\n/tmp/tmp74ceenle.d(34): Error: no property `length` for type `string`\n/tmp/tmp74ceenle.d(34): Error: no property `length` for type `string`\n/tmp/tmp74ceenle.d(40): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp74ceenle.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i,j,k,l,m,n;\n    int len = lst.length;\n    int paren_count = 0;\n    for(i=0;i<len;i++)\n    {\n        if(lst[i]=='(')\n            paren_count++;\n        else if(lst[i]==')')\n            paren_count--;\n    }\n    if(paren_count==0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "/tmp/tmprgxvxlry.d(24): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmprgxvxlry.d(28): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmprgxvxlry.d(30): Error: incompatible types for `(lst[cast(ulong)i]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprgxvxlry.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    if(n == 0) return \"Yes\";\n    if(n == 1) return \"No\";\n    \n    int i = 0;\n    int j = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    \n    while(i < n && j < n)\n    {\n        if(lst[i] == '(')\n        {\n            p++;\n            i++;\n        }\n        else if(lst[j] == ')')\n        {\n            q++;\n            j++;\n        }\n        else if(lst[i] == '(' && lst[j] == ')')\n        {\n            r++;\n            i++;\n            j++;\n        }\n        else if(lst[i] == '(' && lst[j] == '(')\n        {\n            s++;\n            i++;\n            j++;\n        }\n        else if(lst[i] == '(' && lst[j] == ')')\n        {\n            t++;\n            i++;\n            j++;\n        }\n        else if(lst[i] == '(' && lst[j] == ')')\n        {\n            u++;\n            i++;\n            j++;\n        }\n        else if(lst[i] == '(' && lst[j] == '(')\n        {\n            v++;\n            i++;\n            j++;\n        }\n        else if(lst[i] == '(' && lst[j] == ')')\n        {\n            w++;\n            i++;\n            j++;\n        }\n        else if(lst[i] == '(' && lst[j] == '(')\n        {\n            x++;\n            i++;\n            j++;\n        }\n        else if(lst[i] == '(' && lst[j] == ')')\n        \nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "/tmp/tmplbqburqr.d(97): Error: found `unittest` instead of statement\n/tmp/tmplbqburqr.d(114): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplbqburqr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int len = lst.length;\n    if (len < 2) return \"Yes\";\n    int i, j, k;\n    for (i = 0; i < len; i++) {\n        if (lst[i][0] != '(') return \"No\";\n    }\n    for (i = 0; i < len; i++) {\n        if (lst[i][lst[i].length()-1] != ')') return \"No\";\n    }\n    for (i = 0; i < len; i++) {\n        for (j = 0; j < lst[i].length(); j++) {\n            if (lst[i][j] == '(') {\n                k = j;\n                while (k < lst[i].length() && lst[i][k] == '(') k++;\n                if (k == j) return \"No\";\n                for (int l = i+1; l < len; l++) {\n                    if (lst[l][0] == '(') return \"No\";\n                    if (lst[l][lst[l].length()-1] == ')') return \"No\";\n                    if (lst[l][k] == '(') return \"No\";\n                    if (lst[l][k] == ')') {\n                        if (lst[l][l-1] == '(') return \"No\";\n                        if (lst[l][l-1] == ')') return \"No\";\n                    }\n                }\n            }\n        }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "/tmp/tmpt3ublcvb.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpt3ublcvb.d(30): Error: no property `length` for type `string`\n/tmp/tmpt3ublcvb.d(33): Error: no property `length` for type `string`\n/tmp/tmpt3ublcvb.d(36): Error: no property `length` for type `string`\n/tmp/tmpt3ublcvb.d(40): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt3ublcvb.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n = lst.length;\n    for (i = 0; i < n; i++) {\n        for (j = i + 1; j < n; j++) {\n            if (lst[i][0] == '(' && lst[j][0] == '(') {\n                for (k = 1; k < lst[i].length(); k++) {\n                    if (lst[i][k] == '(') {\n                        break;\n                    }\n                }\n                for (k = 1; k < lst[j].length(); k++) {\n                    if (lst[j][k] == '(') {\n                        break;\n                    }\n                }\n                if (k == lst[i].length() && k == lst[j].length()) {\n                    return \"Yes\";\n                }\n            }\n        }\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp5j3twobv.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmp5j3twobv.d(27): Error: no property `length` for type `string`\n/tmp/tmp5j3twobv.d(32): Error: no property `length` for type `string`\n/tmp/tmp5j3twobv.d(37): Error: no property `length` for type `string`\n/tmp/tmp5j3twobv.d(37): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5j3twobv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, len = lst.length;\n    for (i = 0; i < len; i++) {\n        if (lst[i] == \")\") {\n            for (j = i + 1; j < len; j++) {\n                if (lst[j] == \"(\") {\n                    if (j - i < 2) {\n                        return \"Yes\";\n                    }\n                    else {\n                        return \"No\";\n                    }\n                }\n            }\n        }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "/tmp/tmpx75h76je.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx75h76je.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst.length;\n    if (n == 0) return \"Yes\";\n    if (n == 1) return \"No\";\n    \n    int i = 0, j = 1;\n    int p1 = 0, p2 = 0;\n    while (i < n && j < n) {\n        if (lst[i] == '(') {\n            p1++;\n        }\n        if (lst[j] == ')') {\n            p2++;\n        }\n        if (p1 == 0 && p2 == 0) {\n            return \"Yes\";\n        }\n        if (p1 > 0 && p2 > 0) {\n            p1--;\n            p2--;\n        }\n        i++;\n        j++;\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "/tmp/tmpw3kvr8p9.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpw3kvr8p9.d(30): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpw3kvr8p9.d(33): Error: incompatible types for `(lst[cast(ulong)j]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw3kvr8p9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    if(lst.length == 0)\n        return \"Yes\";\n    if(lst.length == 1)\n        return \"No\";\n    if(lst[0] == \"\")\n        return \"No\";\n    if(lst[1] == \"\")\n        return \"No\";\n    if(lst[0][0] == '(' && lst[1][0] == '(')\n        return \"No\";\n    if(lst[0][0] == '(' && lst[1][0] == ')')\n        return \"No\";\n    if(lst[0][0] == ')' && lst[1][0] == '(')\n        return \"No\";\n    if(lst[0][0] == ')' && lst[1][0] == ')')\n        return \"No\";\n    if(lst[0][0] == '(' && lst[1][0] == ')')\n        return \"No\";\n    if(lst[0][0] == '(' && lst[1][0] == ')')\n        return \"No\";\n    if(lst[0][0] == '(' && lst[1][0] == ')')\n        return \"No\";\n    if(lst[0][0] == '(' && lst[1][0] == ')')\n        return \"No\";\n    if(lst[0][0] == '(' && lst[1][0] == ')')\n        return \"No\";\n    if(lst[0][0] == '(' && lst[1][0] == ')')\n        return \"No\";\n    if(lst[0][0] == '(' && lst[1][0] == ')')\n        return \"No\";\n    if(lst[0][0] == '(' && lst[1][0] == ')')\n        return \"No\";\n    if(lst[0][0] == '(' && lst[1][0] == ')')\n        return \"No\";\n    if(lst[0][0] == '(' && lst[1][0] == ')\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "/tmp/tmph7qqi28o.d(57): Error: unterminated character constant\n/tmp/tmph7qqi28o.d(58): Error: found `unittest` when expecting `)`\n/tmp/tmph7qqi28o.d(75): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph7qqi28o.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int i, j, k, n, m, p;\n    n = lst.length;\n    if (n == 0) return \"Yes\";\n    if (n == 1) return \"No\";\n    for (i = 0; i < n; i++) {\n        if (lst[i][0] != '(') return \"No\";\n    }\n    for (i = 0; i < n; i++) {\n        if (lst[i][lst[i].length() - 1] != ')') return \"No\";\n    }\n    for (i = 0; i < n; i++) {\n        for (j = 0; j < lst[i].length(); j++) {\n            if (lst[i][j] == '(') {\n                p = j;\n                break;\n            }\n        }\n        for (k = lst[i].length() - 1; k >= 0; k--) {\n            if (lst[i][k] == ')') {\n                m = k;\n                break;\n            }\n        }\n        if (p > m) return \"No\";\n    }\n    return \"Yes\";\n}\n\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "/tmp/tmpks9701zp.d(24): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpks9701zp.d(31): Error: no property `length` for type `string`\n/tmp/tmpks9701zp.d(34): Error: no property `length` for type `string`\n/tmp/tmpks9701zp.d(40): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpks9701zp.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int len = lst.length;\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < len)\n    {\n        if(lst[i] == '(')\n            count++;\n        else if(lst[i] == ')')\n            count--;\n        i++;\n    }\n    if(count == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "/tmp/tmpdxie4399.d(23): Error: cannot implicitly convert expression `lst.length` of type `ulong` to `int`\n/tmp/tmpdxie4399.d(29): Error: incompatible types for `(lst[cast(ulong)i]) == ('(')`: `string` and `char`\n/tmp/tmpdxie4399.d(31): Error: incompatible types for `(lst[cast(ulong)i]) == (')')`: `string` and `char`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdxie4399.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}