{
  "name": "HumanEval_110_exchange",
  "language": "d",
  "prompt": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n",
  "tests": "unittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "results": [
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    int i = 0;\n    while(i < lst1.length)\n    {\n        if(lst1[i] % 2 != 0)\n        {\n            if(lst2[i] % 2 == 0)\n            {\n                long temp = lst1[i];\n                lst1[i] = lst2[i];\n                lst2[i] = temp;\n            }\n            else\n                return \"NO\";\n        }\n        i++;\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpe_5e2q_8.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x42878d]\n??:? void tmpe_5e2q_8.__unittest_L42_C1() [0x427fda]\n??:? void tmpe_5e2q_8.__modtest() [0x42850c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c793]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b6a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4307b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430745]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b679]\n??:? runModuleUnitTests [0x42c569]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428c50]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0)\n        {\n            if(lst2[i] % 2 != 0)\n                return \"NO\";\n            else\n            {\n                lst2[i] = lst2[i] + lst1[i];\n                lst1[i] = lst2[i] - lst1[i];\n                lst2[i] = lst2[i] - lst1[i];\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0)\n            return \"NO\";\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp5i3keahj.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x42888d]\n??:? void tmp5i3keahj.__unittest_L47_C1() [0x4280da]\n??:? void tmp5i3keahj.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c893]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430845]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b779]\n??:? runModuleUnitTests [0x42c669]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d50]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    if(lst1.length == 1 && lst2.length == 1)\n        return \"YES\";\n    \n    if(lst1.length == 2 && lst2.length == 2)\n    {\n        if(lst1[0] % 2 == 0 && lst1[1] % 2 == 0 && lst2[0] % 2 == 0 && lst2[1] % 2 == 0)\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    \n    if(lst1.length == 2 && lst2.length == 3)\n    {\n        if(lst1[0] % 2 == 0 && lst1[1] % 2 == 0 && lst2[0] % 2 == 0 && lst2[1] % 2 == 0 && lst2[2] % 2 == 0)\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    \n    if(lst1.length == 3 && lst2.length == 3)\n    {\n        if(lst1[0] % 2 == 0 && lst1[1] % 2 == 0 && lst1[2] % 2 == 0 && lst2[0] % 2 == 0 && lst2[1] % 2 == 0 && lst2[2] % 2 == 0)\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    \n    if(lst1.length == 3 && lst2.length == 4)\n    {\n        if(lst1[0] % 2 == 0 && lst1[1] % 2 == 0 && lst1[2] % 2 == 0 && lst2[0] % 2 == 0 && lst2[1] % 2 == 0 && lst2[2] % 2 == 0 && lst2[3] % 2 == 0)\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    \n    if(lst1.length == 4 && lst2.length == 4)\n    {\n        \nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "/tmp/tmphaa6s9a4.d(62): Error: found `unittest` instead of statement\n/tmp/tmphaa6s9a4.d(74): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphaa6s9a4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0)\n        {\n            for (int j = 0; j < lst2.length; j++)\n            {\n                if (lst2[j] % 2 == 0)\n                {\n                    long temp = lst1[i];\n                    lst1[i] = lst2[j];\n                    lst2[j] = temp;\n                    return \"YES\";\n                }\n            }\n        }\n    }\n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp8jxoorck.d(47): unittest failure\n----------------\n??:? _d_unittestp [0x4287a5]\n??:? void tmp8jxoorck.__unittest_L42_C1() [0x4280d1]\n??:? void tmp8jxoorck.__modtest() [0x428528]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c7ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b6ba]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4307d1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c80]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43075d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b691]\n??:? runModuleUnitTests [0x42c581]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428c68]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope void delegate",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0)\n        {\n            for(int j = 0; j < lst2.length; j++)\n            {\n                if(lst2[j] % 2 == 0)\n                {\n                    long temp = lst1[i];\n                    lst1[i] = lst2[j];\n                    lst2[j] = temp;\n                    return \"YES\";\n                }\n            }\n        }\n    }\n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpmr6fmae1.d(47): unittest failure\n----------------\n??:? _d_unittestp [0x42879d]\n??:? void tmpmr6fmae1.__unittest_L42_C1() [0x4280c9]\n??:? void tmpmr6fmae1.__modtest() [0x428520]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c7a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b6b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4307c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c78]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430755]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b689]\n??:? runModuleUnitTests [0x42c579]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428c60]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    int i, j;\n    for(i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0)\n            continue;\n        \n        for(j = 0; j < lst2.length; j++)\n        {\n            if(lst2[j] % 2 != 0)\n                continue;\n            \n            if(lst1[i] == lst2[j])\n            {\n                long temp = lst1[i];\n                lst1[i] = lst2[j];\n                lst2[j] = temp;\n                return \"YES\";\n            }\n        }\n    }\n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpw5tndn2i.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x42880d]\n??:? void tmpw5tndn2i.__unittest_L46_C1() [0x428135]\n??:? void tmpw5tndn2i.__modtest() [0x42858c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c813]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b722]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430839]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ce8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307c5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b6f9]\n??:? runModuleUnitTests [0x42c5e9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cd0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    int i = 0;\n    while (i < lst1.length)\n    {\n        if (lst1[i] % 2 != 0)\n        {\n            if (lst2[i] % 2 != 0)\n                return \"NO\";\n            else\n                lst2[i] = lst2[i] + lst1[i];\n        }\n        else\n        {\n            if (lst2[i] % 2 != 0)\n                lst2[i] = lst2[i] - lst1[i];\n            else\n                lst1[i] = lst1[i] + lst2[i];\n        }\n        i++;\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpjeihhxcb.d(49): unittest failure\n----------------\n??:? _d_unittestp [0x4288e5]\n??:? void tmpjeihhxcb.__unittest_L45_C1() [0x428136]\n??:? void tmpjeihhxcb.__modtest() [0x428668]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8eb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7fa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430911]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430dc0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43089d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7d1]\n??:? runModuleUnitTests [0x42c6c1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428da8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 == 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n        if (lst1[i] % 2 != 0 && lst2[i] % 2 == 0)\n            return \"NO\";\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpiljut8sp.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x428795]\n??:? void tmpiljut8sp.__unittest_L33_C1() [0x42817f]\n??:? void tmpiljut8sp.__modtest() [0x428514]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c79b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b6aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4307c1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c70]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43074d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b681]\n??:? runModuleUnitTests [0x42c571]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428c58]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    if (lst1.length == 1)\n        return \"YES\";\n    if (lst2.length == 1)\n        return \"YES\";\n    if (lst1.length == 2 && lst2.length == 2)\n        return \"YES\";\n    if (lst1.length == 2 && lst2.length == 3)\n        return \"YES\";\n    if (lst1.length == 3 && lst2.length == 2)\n        return \"YES\";\n    if (lst1.length == 3 && lst2.length == 3)\n        return \"YES\";\n    if (lst1.length == 4 && lst2.length == 2)\n        return \"YES\";\n    if (lst1.length == 4 && lst2.length == 3)\n        return \"YES\";\n    if (lst1.length == 4 && lst2.length == 4)\n        return \"YES\";\n    if (lst1.length == 5 && lst2.length == 2)\n        return \"YES\";\n    if (lst1.length == 5 && lst2.length == 3)\n        return \"YES\";\n    if (lst1.length == 5 && lst2.length == 4)\n        return \"YES\";\n    if (lst1.length == 5 && lst2.length == 5)\n        return \"YES\";\n    if (lst1.length == 6 && lst2.length == 2)\n        return \"YES\";\n    if (lst1.length == 6 && lst2.length == 3)\n        return \"YES\";\n    if (lst1.length == 6 && lst2.length == 4)\n        return \"YES\";\n    if (lst1.length == 6 && lst2.length == 5)\n        return \"YES\";\n    if (lst1.length == 6 && lst2.length == 6)\n        return \"YES\";\n    if (lst1.length == 7 && lst2.length == 2)\n        return \"YES\";\n    if (lst1\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "/tmp/tmpot_o7efq.d(62): Error: found `unittest` when expecting `)`\n/tmp/tmpot_o7efq.d(74): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpot_o7efq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n        \n        if(lst1[i] % 2 == 0 && lst2[i] % 2 == 0)\n            continue;\n        \n        if(lst1[i] % 2 == 0)\n        {\n            lst1[i] = lst1[i] + lst2[i];\n            lst2[i] = lst1[i] - lst2[i];\n            lst1[i] = lst1[i] - lst2[i];\n        }\n        else\n        {\n            lst1[i] = lst1[i] - lst2[i];\n            lst2[i] = lst1[i] + lst2[i];\n            lst1[i] = lst1[i] + lst2[i];\n        }\n    }\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0)\n            return \"NO\";\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpopioxo76.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x428a8d]\n??:? void tmpopioxo76.__unittest_L54_C1() [0x4282de]\n??:? void tmpopioxo76.__modtest() [0x428810]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b979]\n??:? runModuleUnitTests [0x42c869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f50]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0)\n        {\n            if(lst2[i] % 2 != 0)\n                return \"NO\";\n            else\n            {\n                lst2[i] = lst2[i] + lst1[i];\n                lst1[i] = lst2[i] - lst1[i];\n                lst2[i] = lst2[i] - lst1[i];\n            }\n        }\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp8ri_nd8f.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x428825]\n??:? void tmp8ri_nd8f.__unittest_L41_C1() [0x428076]\n??:? void tmp8ri_nd8f.__modtest() [0x4285a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c82b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b73a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d00]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b711]\n??:? runModuleUnitTests [0x42c601]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428ce8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    int i = 0;\n    while(i < lst1.length)\n    {\n        if(lst1[i] % 2 != 0)\n        {\n            if(lst2[i] % 2 != 0)\n            {\n                if(lst1[i] != lst2[i])\n                    return \"NO\";\n            }\n            else\n                return \"NO\";\n        }\n        else\n        {\n            if(lst2[i] % 2 != 0)\n                return \"NO\";\n        }\n        i++;\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp95lszs5c.d(52): unittest failure\n----------------\n??:? _d_unittestp [0x4287b5]\n??:? void tmp95lszs5c.__unittest_L46_C1() [0x4281a3]\n??:? void tmp95lszs5c.__modtest() [0x428538]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c7bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b6ca]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4307e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c90]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43076d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b6a1]\n??:? runModuleUnitTests [0x42c591]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428c78]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    int i, j;\n    for (i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0)\n            break;\n    }\n    \n    if (i == lst1.length)\n        return \"YES\";\n    \n    for (j = 0; j < lst2.length; j++)\n    {\n        if (lst2[j] % 2 != 0)\n            break;\n    }\n    \n    if (j == lst2.length)\n        return \"YES\";\n    \n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpyl1dexwz.d(49): unittest failure\n----------------\n??:? _d_unittestp [0x42872d]\n??:? void tmpyl1dexwz.__unittest_L45_C1() [0x427f7e]\n??:? void tmpyl1dexwz.__modtest() [0x4284b0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c733]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b642]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430759]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c08]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306e5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b619]\n??:? runModuleUnitTests [0x42c509]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428bf0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    if (lst1.length == 1 || lst2.length == 1)\n        return \"YES\";\n    \n    if (lst1.length == 2 && lst2.length == 2)\n    {\n        if (lst1[0] == lst2[0] && lst1[1] == lst2[1])\n            return \"YES\";\n        else if (lst1[0] == lst2[1] && lst1[1] == lst2[0])\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    \n    if (lst1.length == 2 && lst2.length == 3)\n    {\n        if (lst1[0] == lst2[0] && lst1[1] == lst2[1] && lst1[2] == lst2[2])\n            return \"YES\";\n        else if (lst1[0] == lst2[0] && lst1[1] == lst2[2] && lst1[2] == lst2[1])\n            return \"YES\";\n        else if (lst1[0] == lst2[1] && lst1[1] == lst2[0] && lst1[2] == lst2[2])\n            return \"YES\";\n        else if (lst1[0] == lst2[1] && lst1[1] == lst2[2] && lst1[2] == lst2[0])\n            return \"YES\";\n        else if (lst1[0] == lst2[2] && lst1[1] == lst2[0] && lst1[2] == lst2[1])\n            return \"YES\";\n        else if (lst1[0] == lst2[2] && lst1[1] == lst2[1] && lst1[2] == lst2[0])\n            return \"YES\";\n        else\n            return \"NO\";\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "/tmp/tmpds7dzha6.d(53): Error: found `unittest` instead of statement\n/tmp/tmpds7dzha6.d(65): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpds7dzha6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    if(lst1.length == 1)\n        return \"YES\";\n    \n    if(lst1.length == 2)\n    {\n        if(lst1[0] == lst2[0] || lst1[0] == lst2[1])\n            return \"YES\";\n        else if(lst1[1] == lst2[0] || lst1[1] == lst2[1])\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    \n    if(lst1[0] == lst2[0] || lst1[0] == lst2[1])\n        return \"YES\";\n    \n    if(lst1[1] == lst2[0] || lst1[1] == lst2[1])\n        return \"YES\";\n    \n    if(lst1[2] == lst2[0] || lst1[2] == lst2[1])\n        return \"YES\";\n    \n    if(lst1[0] == lst2[2] || lst1[1] == lst2[2] || lst1[2] == lst2[2])\n        return \"YES\";\n    \n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmppepv6cw5.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x428aed]\n??:? void tmppepv6cw5.__unittest_L51_C1() [0x428415]\n??:? void tmppepv6cw5.__modtest() [0x42886c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42caf3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba02]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b19]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fc8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430aa5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b9d9]\n??:? runModuleUnitTests [0x42c8c9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428fb0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n        \n        if (lst1[i] % 2 == 0 && lst2[i] % 2 == 0)\n            continue;\n        \n        if (lst1[i] % 2 == 0)\n        {\n            lst1[i] = lst1[i] + lst2[i];\n            lst2[i] = lst1[i] - lst2[i];\n            lst1[i] = lst1[i] - lst2[i];\n        }\n        else\n        {\n            lst1[i] = lst1[i] - lst2[i];\n            lst2[i] = lst1[i] + lst2[i];\n            lst1[i] = lst1[i] + lst2[i];\n        }\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpjdfl7ac7.d(52): unittest failure\n----------------\n??:? _d_unittestp [0x428a2d]\n??:? void tmpjdfl7ac7.__unittest_L48_C1() [0x42827a]\n??:? void tmpjdfl7ac7.__modtest() [0x4287ac]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca33]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b942]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a59]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f08]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b919]\n??:? runModuleUnitTests [0x42c809]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428ef0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    if (lst1.length == 1 || lst2.length == 1)\n        return \"YES\";\n    \n    if (lst1.length == 2 && lst2.length == 2)\n    {\n        if (lst1[0] % 2 == 0 && lst1[1] % 2 == 0 && lst2[0] % 2 == 0 && lst2[1] % 2 == 0)\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    \n    if (lst1.length == 2 && lst2.length == 3)\n    {\n        if (lst1[0] % 2 == 0 && lst1[1] % 2 == 0 && lst2[0] % 2 == 0 && lst2[1] % 2 == 0 && lst2[2] % 2 == 0)\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    \n    if (lst1.length == 3 && lst2.length == 3)\n    {\n        if (lst1[0] % 2 == 0 && lst1[1] % 2 == 0 && lst1[2] % 2 == 0 && lst2[0] % 2 == 0 && lst2[1] % 2 == 0 && lst2[2] % 2 == 0)\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    \n    if (lst1.length == 3 && lst2.length == 4)\n    {\n        if (lst1[0] % 2 == 0 && lst1[1] % 2 == 0 && lst1[2] % 2 == 0 && lst2[0] % 2 == 0 && lst2[1] % 2 == 0 && lst2[2] % 2 == 0 && lst2[3] % 2 == 0)\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    \n    if (lst1.length == 4 && lst2.length == 4)\n    {\n        \nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "/tmp/tmpauy0zehl.d(62): Error: found `unittest` instead of statement\n/tmp/tmpauy0zehl.d(74): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpauy0zehl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    int i = 0;\n    int j = 0;\n    \n    while(i < lst1.length && j < lst2.length)\n    {\n        if(lst1[i] % 2 == 0 && lst2[j] % 2 == 0)\n        {\n            if(lst1[i] == lst2[j])\n            {\n                i++;\n                j++;\n            }\n            else\n            {\n                if(lst1[i] > lst2[j])\n                {\n                    i++;\n                }\n                else\n                {\n                    j++;\n                }\n            }\n        }\n        else if(lst1[i] % 2 != 0 && lst2[j] % 2 != 0)\n        {\n            if(lst1[i] == lst2[j])\n            {\n                i++;\n                j++;\n            }\n            else\n            {\n                if(lst1[i] > lst2[j])\n                {\n                    i++;\n                }\n                else\n                {\n                    j++;\n                }\n            }\n        }\n        else\n        {\n            if(lst1[i] == lst2[j])\n            {\n                i++;\n                j++;\n            }\n            else\n            {\n                if(lst1[i] > lst2[j])\n                {\n                    i++;\n                }\n                else\n                {\n                    j++;\n                }\n            }\n        }\n    }\n    \n    if(i == lst1.length && j == lst2.length)\n        return \"YES\";\n    else\n        return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpor5dibvh.d(99): unittest failure\n----------------\n??:? _d_unittestp [0x4289dd]\n??:? void tmpor5dibvh.__unittest_L93_C1() [0x4283cb]\n??:? void tmpor5dibvh.__modtest() [0x428760]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9e3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8f2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a09]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430eb8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430995]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b8c9]\n??:? runModuleUnitTests [0x42c7b9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428ea0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0 || lst2[i] % 2 != 0)\n            return \"NO\";\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpczzfg5lc.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4286fd]\n??:? void tmpczzfg5lc.__unittest_L32_C1() [0x427f4a]\n??:? void tmpczzfg5lc.__modtest() [0x42847c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c703]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430729]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c4d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428bc0]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope void delegate",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    if (lst1.length == 1 || lst2.length == 1)\n        return \"YES\";\n    if (lst1.length == 2 && lst2.length == 2)\n        return \"YES\";\n    if (lst1.length == 2 && lst2.length == 3)\n        return \"YES\";\n    if (lst1.length == 3 && lst2.length == 3)\n        return \"YES\";\n    if (lst1.length == 3 && lst2.length == 4)\n        return \"YES\";\n    if (lst1.length == 4 && lst2.length == 4)\n        return \"YES\";\n    if (lst1.length == 4 && lst2.length == 5)\n        return \"YES\";\n    if (lst1.length == 5 && lst2.length == 5)\n        return \"YES\";\n    if (lst1.length == 5 && lst2.length == 6)\n        return \"YES\";\n    if (lst1.length == 6 && lst2.length == 6)\n        return \"YES\";\n    if (lst1.length == 6 && lst2.length == 7)\n        return \"YES\";\n    if (lst1.length == 7 && lst2.length == 7)\n        return \"YES\";\n    if (lst1.length == 7 && lst2.length == 8)\n        return \"YES\";\n    if (lst1.length == 8 && lst2.length == 8)\n        return \"YES\";\n    if (lst1.length == 8 && lst2.length == 9)\n        return \"YES\";\n    if (lst1.length == 9 && lst2.length == 9)\n        return \"YES\";\n    if (lst1.length == 9 && lst2.length == 10)\n        return \"YES\";\n    if (lst1.length == 10 && lst2.length == 10)\n        return \"YES\";\n    if (lst1.length == 10 && lst2.length\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "/tmp/tmpd0thdvsp.d(60): Error: found `unittest` when expecting `)`\n/tmp/tmpd0thdvsp.d(72): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd0thdvsp.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    int i = 0;\n    while(i < lst1.length)\n    {\n        if(lst1[i] % 2 != 0)\n        {\n            if(lst2[i] % 2 != 0)\n                return \"NO\";\n            else\n                lst2[i] = lst2[i] + lst1[i];\n        }\n        else\n        {\n            if(lst2[i] % 2 != 0)\n                lst2[i] = lst2[i] - lst1[i];\n            else\n                lst1[i] = lst1[i] + lst2[i];\n        }\n        i++;\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp81b0regs.d(49): unittest failure\n----------------\n??:? _d_unittestp [0x4288e5]\n??:? void tmp81b0regs.__unittest_L45_C1() [0x428136]\n??:? void tmp81b0regs.__modtest() [0x428668]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8eb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7fa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430911]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430dc0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43089d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7d1]\n??:? runModuleUnitTests [0x42c6c1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428da8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpit8nz8bh.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x4286fd]\n??:? void tmpit8nz8bh.__unittest_L31_C1() [0x427f4a]\n??:? void tmpit8nz8bh.__modtest() [0x42847c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c703]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430729]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c4d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428bc0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    if(lst1.length == 1 || lst2.length == 1)\n        return \"YES\";\n    if(lst1.length == 2 && lst2.length == 2)\n    {\n        if(lst1[0] == lst2[0] || lst1[0] == lst2[1] || lst1[1] == lst2[0] || lst1[1] == lst2[1])\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    if(lst1.length == 2 && lst2.length == 3)\n    {\n        if(lst1[0] == lst2[0] || lst1[0] == lst2[1] || lst1[0] == lst2[2] || lst1[1] == lst2[0] || lst1[1] == lst2[1] || lst1[1] == lst2[2])\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    if(lst1.length == 3 && lst2.length == 3)\n    {\n        if(lst1[0] == lst2[0] || lst1[0] == lst2[1] || lst1[0] == lst2[2] || lst1[1] == lst2[0] || lst1[1] == lst2[1] || lst1[1] == lst2[2] || lst1[2] == lst2[0] || lst1[2] == lst2[1] || lst1[2] == lst2[2])\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    if(lst1.length == 3 && lst2.length == 4)\n    {\n        if(lst1[0] == lst2[0] || lst1[0] == lst2[1] || lst1[0]\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "/tmp/tmpdv3bnlnq.d(49): Error: found `unittest` when expecting `)`\n/tmp/tmpdv3bnlnq.d(61): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpdv3bnlnq.d(61): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdv3bnlnq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n        if(lst1[i] % 2 == 0 && lst2[i] % 2 == 0)\n            continue;\n        if(lst1[i] % 2 == 0)\n        {\n            lst1[i] = lst1[i] + lst2[i];\n            lst2[i] = lst1[i] - lst2[i];\n            lst1[i] = lst1[i] - lst2[i];\n        }\n        else\n        {\n            lst1[i] = lst1[i] - lst2[i];\n            lst2[i] = lst1[i] + lst2[i];\n            lst1[i] = lst1[i] + lst2[i];\n        }\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp4wa2bji9.d(48): unittest failure\n----------------\n??:? _d_unittestp [0x428a2d]\n??:? void tmp4wa2bji9.__unittest_L44_C1() [0x42827a]\n??:? void tmp4wa2bji9.__modtest() [0x4287ac]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca33]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b942]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a59]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f08]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b919]\n??:? runModuleUnitTests [0x42c809]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428ef0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    int i = 0, j = 0;\n    while(i < lst1.length && j < lst2.length)\n    {\n        if(lst1[i] % 2 == 0 && lst2[j] % 2 == 0)\n        {\n            if(lst1[i] == lst2[j])\n            {\n                i++;\n                j++;\n            }\n            else\n            {\n                if(lst1[i] < lst2[j])\n                {\n                    i++;\n                }\n                else\n                {\n                    j++;\n                }\n            }\n        }\n        else if(lst1[i] % 2 == 0 && lst2[j] % 2 != 0)\n        {\n            if(lst1[i] == lst2[j])\n            {\n                i++;\n                j++;\n            }\n            else\n            {\n                if(lst1[i] < lst2[j])\n                {\n                    i++;\n                }\n                else\n                {\n                    j++;\n                }\n            }\n        }\n        else if(lst1[i] % 2 != 0 && lst2[j] % 2 == 0)\n        {\n            if(lst1[i] == lst2[j])\n            {\n                i++;\n                j++;\n            }\n            else\n            {\n                if(lst1[i] < lst2[j])\n                {\n                    i++;\n                }\n                else\n                {\n                    j++;\n                }\n            }\n        }\n        else\n        {\n            if(lst1[i] == lst2[j])\n            {\n                i++;\n                j++;\n            }\n            else\n            {\n                if(lst1[i] < lst2[j])\n                {\n                    i++;\n                }\n                else\n                {\n                    j++;\n                }\n            }\n        }\n    }\n    \n    if(i == lst1.length && j == lst2\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "/tmp/tmp_ak8qsh5.d(106): Error: found `unittest` when expecting `)`\n/tmp/tmp_ak8qsh5.d(118): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_ak8qsh5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    int i, j;\n    for (i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0)\n            break;\n    }\n    \n    if (i == lst1.length)\n        return \"YES\";\n    \n    for (j = 0; j < lst2.length; j++)\n    {\n        if (lst2[j] % 2 != 0)\n            break;\n    }\n    \n    if (j == lst2.length)\n        return \"YES\";\n    \n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpyl1dexwz.d(49): unittest failure\n----------------\n??:? _d_unittestp [0x42872d]\n??:? void tmpyl1dexwz.__unittest_L45_C1() [0x427f7e]\n??:? void tmpyl1dexwz.__modtest() [0x4284b0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c733]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b642]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430759]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c08]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306e5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b619]\n??:? runModuleUnitTests [0x42c509]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428bf0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n        \n        if(lst1[i] % 2 == 0 && lst2[i] % 2 != 0)\n        {\n            long temp = lst1[i];\n            lst1[i] = lst2[i];\n            lst2[i] = temp;\n        }\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpq8b3zcri.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x428825]\n??:? void tmpq8b3zcri.__unittest_L39_C1() [0x428072]\n??:? void tmpq8b3zcri.__modtest() [0x4285a4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c82b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b73a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d00]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b711]\n??:? runModuleUnitTests [0x42c601]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428ce8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    if(lst1.length == 1)\n        return \"YES\";\n    \n    if(lst1.length == 2)\n    {\n        if(lst1[0] % 2 == 0 && lst1[1] % 2 == 0)\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    \n    if(lst1.length == 3)\n    {\n        if(lst1[0] % 2 == 0 && lst1[1] % 2 == 0 && lst1[2] % 2 == 0)\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    \n    if(lst1.length == 4)\n    {\n        if(lst1[0] % 2 == 0 && lst1[1] % 2 == 0 && lst1[2] % 2 == 0 && lst1[3] % 2 == 0)\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    \n    if(lst1.length == 5)\n    {\n        if(lst1[0] % 2 == 0 && lst1[1] % 2 == 0 && lst1[2] % 2 == 0 && lst1[3] % 2 == 0 && lst1[4] % 2 == 0)\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    \n    if(lst1.length == 6)\n    {\n        if(lst1[0] % 2 == 0 && lst1[1] % 2 == 0 && lst1[2] % 2 == 0 && lst1[3] % 2 == 0 && lst1[4] % 2 == 0 && lst1[5] % 2 == 0)\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    \n    if(lst1.length == 7)\n    {\n        if(lst1[0] % 2 == 0 && lst1[1] % 2 == 0 && lst1[2] %\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "/tmp/tmptw36ee81.d(70): Error: expression expected, not `unittest`\n/tmp/tmptw36ee81.d(71): Error: found `{` when expecting `)`\n/tmp/tmptw36ee81.d(82): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptw36ee81.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    int i = 0;\n    while (i < lst1.length)\n    {\n        if (lst1[i] % 2 != 0)\n        {\n            if (lst2[i] % 2 != 0)\n                return \"NO\";\n            else\n                lst1[i] = lst2[i];\n        }\n        else\n        {\n            if (lst2[i] % 2 != 0)\n                lst2[i] = lst1[i];\n            else\n                i++;\n        }\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpu6q8hlez.d(48): unittest failure\n----------------\n??:? _d_unittestp [0x4287ed]\n??:? void tmpu6q8hlez.__unittest_L44_C1() [0x42803e]\n??:? void tmpu6q8hlez.__modtest() [0x428570]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c7f3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b702]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430819]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430cc8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b6d9]\n??:? runModuleUnitTests [0x42c5c9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cb0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n        if (lst1[i] % 2 != 0)\n            return \"NO\";\n    \n    for (int i = 0; i < lst2.length; i++)\n        if (lst2[i] % 2 != 0)\n            return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n        for (int j = 0; j < lst2.length; j++)\n            if (lst1[i] == lst2[j])\n            {\n                long temp = lst1[i];\n                lst1[i] = lst2[j];\n                lst2[j] = temp;\n                return \"YES\";\n            }\n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpmkwapbvg.d(47): unittest failure\n----------------\n??:? _d_unittestp [0x428855]\n??:? void tmpmkwapbvg.__unittest_L43_C1() [0x4280a2]\n??:? void tmpmkwapbvg.__modtest() [0x4285d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c85b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b76a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430881]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d30]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43080d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b741]\n??:? runModuleUnitTests [0x42c631]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d18]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0)\n        {\n            if(lst2[i] % 2 != 0)\n                return \"NO\";\n            else\n            {\n                long temp = lst1[i];\n                lst1[i] = lst2[i];\n                lst2[i] = temp;\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0)\n            return \"NO\";\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpx75_udtu.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x4287fd]\n??:? void tmpx75_udtu.__unittest_L47_C1() [0x42804a]\n??:? void tmpx75_udtu.__modtest() [0x42857c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c803]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b712]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430829]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430cd8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b6e9]\n??:? runModuleUnitTests [0x42c5d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cc0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    int i = 0;\n    while (i < lst1.length)\n    {\n        if (lst1[i] % 2 != 0)\n        {\n            if (lst2[i] % 2 == 0)\n            {\n                lst1[i] = lst2[i];\n                lst2[i] = lst1[i];\n                lst1[i] = lst2[i];\n                i = 0;\n            }\n            else\n                return \"NO\";\n        }\n        else\n        {\n            i++;\n        }\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpu2rugobt.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x4287d5]\n??:? void tmpu2rugobt.__unittest_L46_C1() [0x428022]\n??:? void tmpu2rugobt.__modtest() [0x428554]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c7db]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b6ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430801]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430cb0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43078d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b6c1]\n??:? runModuleUnitTests [0x42c5b1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428c98]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n        if (lst1[i] % 2 == 0 && lst2[i] % 2 != 0)\n        {\n            lst1[i] = lst1[i] + lst2[i];\n            lst2[i] = lst1[i] - lst2[i];\n            lst1[i] = lst1[i] - lst2[i];\n        }\n        if (lst1[i] % 2 != 0 && lst2[i] % 2 == 0)\n        {\n            lst1[i] = lst1[i] + lst2[i];\n            lst2[i] = lst1[i] - lst2[i];\n            lst1[i] = lst1[i] - lst2[i];\n        }\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpzfo8wsy9.d(48): unittest failure\n----------------\n??:? _d_unittestp [0x428a9d]\n??:? void tmpzfo8wsy9.__unittest_L44_C1() [0x4282ea]\n??:? void tmpzfo8wsy9.__modtest() [0x42881c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42caa3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ac9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f78]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a55]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b989]\n??:? runModuleUnitTests [0x42c879]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f60]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp3o2um0j1.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4286fd]\n??:? void tmp3o2um0j1.__unittest_L32_C1() [0x427f4a]\n??:? void tmp3o2um0j1.__modtest() [0x42847c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c703]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430729]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c4d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428bc0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    int i, j;\n    for(i = 0; i < lst1.length; i++)\n        if(lst1[i] % 2 != 0)\n            break;\n    if(i == lst1.length)\n        return \"YES\";\n    for(j = 0; j < lst2.length; j++)\n        if(lst2[j] % 2 != 0)\n            break;\n    if(j == lst2.length)\n        return \"YES\";\n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpt2oxql9b.d(40): unittest failure\n----------------\n??:? _d_unittestp [0x42872d]\n??:? void tmpt2oxql9b.__unittest_L36_C1() [0x427f7e]\n??:? void tmpt2oxql9b.__modtest() [0x4284b0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c733]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b642]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430759]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c08]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306e5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b619]\n??:? runModuleUnitTests [0x42c509]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428bf0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0)\n        {\n            if (lst2[i] % 2 != 0)\n                return \"NO\";\n            else\n                lst2[i] = lst2[i] + lst1[i];\n        }\n        else\n        {\n            if (lst2[i] % 2 != 0)\n                lst2[i] = lst2[i] - lst1[i];\n            else\n                lst1[i] = lst1[i] + lst2[i];\n        }\n    }\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0)\n            return \"NO\";\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpwah69bnn.d(54): unittest failure\n----------------\n??:? _d_unittestp [0x428955]\n??:? void tmpwah69bnn.__unittest_L50_C1() [0x4281a2]\n??:? void tmpwah69bnn.__modtest() [0x4286d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c95b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b86a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430981]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430e30]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43090d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b841]\n??:? runModuleUnitTests [0x42c731]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e18]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    if (lst1.length == 1 || lst2.length == 1)\n        return \"YES\";\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    int i = 0;\n    int j = 0;\n    int k = 0;\n    \n    while (i < lst1.length && j < lst2.length)\n    {\n        if (lst1[i] % 2 == 0 && lst2[j] % 2 == 0)\n        {\n            if (lst1[i] == lst2[j])\n            {\n                i++;\n                j++;\n            }\n            else\n            {\n                if (lst1[i] > lst2[j])\n                {\n                    k = lst1[i];\n                    lst1[i] = lst2[j];\n                    lst2[j] = k;\n                }\n                else\n                {\n                    k = lst2[j];\n                    lst2[j] = lst1[i];\n                    lst1[i] = k;\n                }\n                i++;\n                j++;\n            }\n        }\n        else if (lst1[i] % 2 == 0)\n        {\n            i++;\n        }\n        else if (lst2[j] % 2 == 0)\n        {\n            j++;\n        }\n        else\n        {\n            if (lst1[i] > lst2[j])\n            {\n                k = lst1[i];\n                lst1[i] = lst2[j];\n                lst2[j] = k;\n            }\n            else\n            {\n                k = lst2[j];\n                lst2[j] = lst1[i];\n                lst1[i] = k;\n            }\n            i++;\n            j++;\n        }\n    }\n    \n    if (i == lst1.length && j == lst2.length)\n        return \"YES\";\n\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "/tmp/tmpm43b1ng6.d(89): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm43b1ng6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0)\n        {\n            if(lst2[i] % 2 != 0)\n            {\n                lst1[i] = lst2[i];\n                lst2[i] = lst1[i];\n                lst1[i] = lst2[i];\n                lst2[i] = lst1[i];\n            }\n            else\n                return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp3pyeq2c6.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x42880d]\n??:? void tmp3pyeq2c6.__unittest_L41_C1() [0x428139]\n??:? void tmp3pyeq2c6.__modtest() [0x428590]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c813]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b722]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430839]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ce8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307c5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b6f9]\n??:? runModuleUnitTests [0x42c5e9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cd0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    int i = 0;\n    while (i < lst1.length)\n    {\n        if (lst1[i] % 2 != 0)\n        {\n            if (lst2[i] % 2 != 0)\n                return \"NO\";\n            else\n                lst2[i] = lst2[i] + lst1[i];\n        }\n        else\n        {\n            if (lst2[i] % 2 != 0)\n                lst2[i] = lst2[i] - lst1[i];\n            else\n                lst2[i] = lst2[i] + lst1[i];\n        }\n        i++;\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmppu5ifz9t.d(49): unittest failure\n----------------\n??:? _d_unittestp [0x4288e5]\n??:? void tmppu5ifz9t.__unittest_L45_C1() [0x428136]\n??:? void tmppu5ifz9t.__modtest() [0x428668]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8eb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7fa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430911]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430dc0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43089d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7d1]\n??:? runModuleUnitTests [0x42c6c1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428da8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n        \n        if(lst1[i] % 2 == 0 && lst2[i] % 2 != 0)\n        {\n            lst2[i] = lst2[i] + lst1[i];\n            lst1[i] = lst2[i] - lst1[i];\n            lst2[i] = lst2[i] - lst1[i];\n        }\n        \n        if(lst1[i] % 2 != 0 && lst2[i] % 2 == 0)\n        {\n            lst1[i] = lst1[i] + lst2[i];\n            lst2[i] = lst1[i] - lst2[i];\n            lst1[i] = lst1[i] - lst2[i];\n        }\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpj2t3olnp.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x428a9d]\n??:? void tmpj2t3olnp.__unittest_L46_C1() [0x4282ea]\n??:? void tmpj2t3olnp.__modtest() [0x42881c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42caa3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ac9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f78]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a55]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b989]\n??:? runModuleUnitTests [0x42c879]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f60]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp3o2um0j1.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4286fd]\n??:? void tmp3o2um0j1.__unittest_L32_C1() [0x427f4a]\n??:? void tmp3o2um0j1.__modtest() [0x42847c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c703]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430729]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c4d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428bc0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < lst1.length && j < lst2.length)\n    {\n        if (lst1[i] % 2 == 0 && lst2[j] % 2 == 0)\n        {\n            count++;\n            if (count == lst1.length)\n                return \"YES\";\n        }\n        else if (lst1[i] % 2 != 0 && lst2[j] % 2 != 0)\n        {\n            count++;\n            if (count == lst1.length)\n                return \"YES\";\n        }\n        else if (lst1[i] % 2 != 0 && lst2[j] % 2 != 0)\n        {\n            count++;\n            if (count == lst1.length)\n                return \"YES\";\n        }\n        else if (lst1[i] % 2 != 0 && lst2[j] % 2 != 0)\n        {\n            count++;\n            if (count == lst1.length)\n                return \"YES\";\n        }\n        i++;\n        j++;\n    }\n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpw09ua187.d(64): unittest failure\n----------------\n??:? _d_unittestp [0x4288e5]\n??:? void tmpw09ua187.__unittest_L58_C1() [0x4282cf]\n??:? void tmpw09ua187.__modtest() [0x428664]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8eb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7fa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430911]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430dc0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43089d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7d1]\n??:? runModuleUnitTests [0x42c6c1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428da8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    int i = 0;\n    int j = 0;\n    int count = 0;\n    \n    while(i < lst1.length && j < lst2.length)\n    {\n        if(lst1[i] % 2 == 0 && lst2[j] % 2 == 0)\n        {\n            count++;\n            if(count == lst1.length)\n                return \"YES\";\n            \n            if(lst1[i] == lst2[j])\n            {\n                i++;\n                j++;\n            }\n            else if(lst1[i] < lst2[j])\n                i++;\n            else\n                j++;\n        }\n        else if(lst1[i] % 2 != 0 && lst2[j] % 2 != 0)\n        {\n            if(lst1[i] < lst2[j])\n                i++;\n            else\n                j++;\n        }\n        else\n        {\n            if(lst1[i] < lst2[j])\n                i++;\n            else\n                j++;\n        }\n    }\n    \n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpaas0v0da.d(68): unittest failure\n----------------\n??:? _d_unittestp [0x42891d]\n??:? void tmpaas0v0da.__unittest_L64_C1() [0x42816a]\n??:? void tmpaas0v0da.__modtest() [0x42869c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c923]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b832]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430949]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430df8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4308d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b809]\n??:? runModuleUnitTests [0x42c6f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428de0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n        \n        if(lst1[i] % 2 == 0 && lst2[i] % 2 != 0)\n        {\n            long temp = lst1[i];\n            lst1[i] = lst2[i];\n            lst2[i] = temp;\n            return \"YES\";\n        }\n    }\n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpxce2ggx2.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpxce2ggx2.__unittest_L39_C1() [0x428086]\n??:? void tmpxce2ggx2.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c83b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b74a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430861]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d10]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307ed]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b721]\n??:? runModuleUnitTests [0x42c611]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i]%2 != 0 && lst2[i]%2 != 0)\n            return \"NO\";\n        \n        if(lst1[i]%2 == 0 && lst2[i]%2 != 0)\n        {\n            lst2[i] = lst2[i] + lst1[i];\n            lst1[i] = lst2[i] - lst1[i];\n            lst2[i] = lst2[i] - lst1[i];\n        }\n        \n        if(lst1[i]%2 != 0 && lst2[i]%2 == 0)\n        {\n            lst1[i] = lst1[i] + lst2[i];\n            lst2[i] = lst1[i] - lst2[i];\n            lst1[i] = lst1[i] - lst2[i];\n        }\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpatuu9cco.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x428a9d]\n??:? void tmpatuu9cco.__unittest_L46_C1() [0x4282ea]\n??:? void tmpatuu9cco.__modtest() [0x42881c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42caa3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ac9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f78]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a55]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b989]\n??:? runModuleUnitTests [0x42c879]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f60]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    if(lst1.length == 1 || lst2.length == 1)\n        return \"YES\";\n    if(lst1.length == 2 && lst2.length == 2)\n        return \"YES\";\n    if(lst1.length == 2 && lst2.length == 3)\n        return \"YES\";\n    if(lst1.length == 3 && lst2.length == 3)\n        return \"YES\";\n    if(lst1.length == 3 && lst2.length == 4)\n        return \"YES\";\n    if(lst1.length == 4 && lst2.length == 4)\n        return \"YES\";\n    if(lst1.length == 4 && lst2.length == 5)\n        return \"YES\";\n    if(lst1.length == 5 && lst2.length == 5)\n        return \"YES\";\n    if(lst1.length == 5 && lst2.length == 6)\n        return \"YES\";\n    if(lst1.length == 6 && lst2.length == 6)\n        return \"YES\";\n    if(lst1.length == 6 && lst2.length == 7)\n        return \"YES\";\n    if(lst1.length == 7 && lst2.length == 7)\n        return \"YES\";\n    if(lst1.length == 7 && lst2.length == 8)\n        return \"YES\";\n    if(lst1.length == 8 && lst2.length == 8)\n        return \"YES\";\n    if(lst1.length == 8 && lst2.length == 9)\n        return \"YES\";\n    if(lst1.length == 9 && lst2.length == 9)\n        return \"YES\";\n    if(lst1.length == 9 && lst2.length == 10)\n        return \"YES\";\n    if(lst1.length == 10 && lst2.length == 10)\n        return \"YES\";\n    if(lst1.length == 10 && lst2.length\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "/tmp/tmpmt2cnn7o.d(60): Error: found `unittest` when expecting `)`\n/tmp/tmpmt2cnn7o.d(72): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmt2cnn7o.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    int i, j;\n    for (i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0)\n            break;\n    }\n    \n    if (i == lst1.length)\n        return \"YES\";\n    \n    for (j = 0; j < lst2.length; j++)\n    {\n        if (lst2[j] % 2 != 0)\n            break;\n    }\n    \n    if (j == lst2.length)\n        return \"YES\";\n    \n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpyl1dexwz.d(49): unittest failure\n----------------\n??:? _d_unittestp [0x42872d]\n??:? void tmpyl1dexwz.__unittest_L45_C1() [0x427f7e]\n??:? void tmpyl1dexwz.__modtest() [0x4284b0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c733]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b642]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430759]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c08]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306e5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b619]\n??:? runModuleUnitTests [0x42c509]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428bf0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0)\n        {\n            if(lst2[i] % 2 != 0)\n                return \"NO\";\n            else\n                lst2[i] = lst2[i] + lst1[i];\n        }\n        else\n        {\n            if(lst2[i] % 2 != 0)\n                lst2[i] = lst2[i] - lst1[i];\n            else\n                lst1[i] = lst1[i] + lst2[i];\n        }\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmppld8albr.d(48): unittest failure\n----------------\n??:? _d_unittestp [0x4288e5]\n??:? void tmppld8albr.__unittest_L44_C1() [0x428136]\n??:? void tmppld8albr.__modtest() [0x428668]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8eb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7fa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430911]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430dc0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43089d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7d1]\n??:? runModuleUnitTests [0x42c6c1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428da8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n        \n        if(lst1[i] % 2 == 0 && lst2[i] % 2 != 0)\n        {\n            lst2[i] = lst2[i] + lst1[i];\n            lst1[i] = lst2[i] - lst1[i];\n            lst2[i] = lst2[i] - lst1[i];\n            lst1[i] = lst2[i] + lst1[i];\n        }\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_4c8lmm1.d(44): unittest failure\n----------------\n??:? _d_unittestp [0x428905]\n??:? void tmp_4c8lmm1.__unittest_L40_C1() [0x428152]\n??:? void tmp_4c8lmm1.__modtest() [0x428684]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c90b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b81a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430931]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430de0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4308bd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7f1]\n??:? runModuleUnitTests [0x42c6e1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428dc8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    if(lst1.length == 1)\n        return \"YES\";\n    \n    if(lst1[0] % 2 == 0 && lst2[0] % 2 == 0)\n        return \"YES\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 == 0 && lst2[i] % 2 != 0)\n        {\n            long temp = lst1[i];\n            lst1[i] = lst2[i];\n            lst2[i] = temp;\n            return \"YES\";\n        }\n    }\n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpaq3pq704.d(49): unittest failure\n----------------\n??:? _d_unittestp [0x42885d]\n??:? void tmpaq3pq704.__unittest_L45_C1() [0x4280ae]\n??:? void tmpaq3pq704.__modtest() [0x4285e0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c863]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b772]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430889]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d38]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430815]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b749]\n??:? runModuleUnitTests [0x42c639]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d20]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    int i = 0;\n    while(i < lst1.length)\n    {\n        if(lst1[i] % 2 != 0)\n        {\n            if(lst2[i] % 2 != 0)\n                return \"NO\";\n            else\n                lst2[i] = lst2[i] + lst1[i];\n        }\n        else\n        {\n            if(lst2[i] % 2 != 0)\n                lst2[i] = lst2[i] - lst1[i];\n            else\n                return \"NO\";\n        }\n        i++;\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp1c66_ita.d(48): unittest failure\n----------------\n??:? _d_unittestp [0x42885d]\n??:? void tmp1c66_ita.__unittest_L44_C1() [0x4280aa]\n??:? void tmp1c66_ita.__modtest() [0x4285dc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c863]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b772]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430889]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d38]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430815]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b749]\n??:? runModuleUnitTests [0x42c639]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d20]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0)\n        {\n            if(lst2[i] % 2 != 0)\n                return \"NO\";\n            else\n                lst2[i] = lst2[i] + lst1[i];\n        }\n        else\n        {\n            if(lst2[i] % 2 != 0)\n                lst2[i] = lst2[i] - lst1[i];\n            else\n                lst2[i] = lst2[i] + lst1[i];\n        }\n    }\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0)\n            return \"NO\";\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqpwwtt17.d(54): unittest failure\n----------------\n??:? _d_unittestp [0x428955]\n??:? void tmpqpwwtt17.__unittest_L50_C1() [0x4281a2]\n??:? void tmpqpwwtt17.__modtest() [0x4286d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c95b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b86a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430981]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430e30]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43090d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b841]\n??:? runModuleUnitTests [0x42c731]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e18]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    int i = 0;\n    int j = 0;\n    \n    while(i < lst1.length && j < lst2.length)\n    {\n        if(lst1[i] % 2 == 0 && lst2[j] % 2 == 0)\n        {\n            if(lst1[i] == lst2[j])\n            {\n                i++;\n                j++;\n            }\n            else\n            {\n                if(lst1[i] < lst2[j])\n                {\n                    i++;\n                }\n                else\n                {\n                    j++;\n                }\n            }\n        }\n        else if(lst1[i] % 2 == 0 && lst2[j] % 2 != 0)\n        {\n            if(lst1[i] == lst2[j])\n            {\n                i++;\n                j++;\n            }\n            else\n            {\n                if(lst1[i] < lst2[j])\n                {\n                    i++;\n                }\n                else\n                {\n                    j++;\n                }\n            }\n        }\n        else if(lst1[i] % 2 != 0 && lst2[j] % 2 == 0)\n        {\n            if(lst1[i] == lst2[j])\n            {\n                i++;\n                j++;\n            }\n            else\n            {\n                if(lst1[i] < lst2[j])\n                {\n                    i++;\n                }\n                else\n                {\n                    j++;\n                }\n            }\n        }\n        else\n        {\n            if(lst1[i] == lst2[j])\n            {\n                i++;\n                j++;\n            }\n            else\n            {\n                if(lst1[i] < lst2[j])\n                {\n                    i++;\n                }\n                else\n                {\n                    j++;\n                }\n            }\n        }\n    }\n    \n    if(i == lst1.length &&\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "/tmp/tmpipfwv3aw.d(108): Error: expression expected, not `unittest`\n/tmp/tmpipfwv3aw.d(109): Error: found `{` when expecting `)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpipfwv3aw.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    int i = 0;\n    int j = 0;\n    \n    while (i < lst1.length && j < lst2.length)\n    {\n        if (lst1[i] % 2 == 0 && lst2[j] % 2 == 0)\n        {\n            if (lst1[i] == lst2[j])\n            {\n                i++;\n                j++;\n            }\n            else\n            {\n                long temp = lst1[i];\n                lst1[i] = lst2[j];\n                lst2[j] = temp;\n                i++;\n                j++;\n            }\n        }\n        else if (lst1[i] % 2 == 1 && lst2[j] % 2 == 1)\n        {\n            if (lst1[i] == lst2[j])\n            {\n                i++;\n                j++;\n            }\n            else\n            {\n                long temp = lst1[i];\n                lst1[i] = lst2[j];\n                lst2[j] = temp;\n                i++;\n                j++;\n            }\n        }\n        else if (lst1[i] % 2 == 0 && lst2[j] % 2 == 1)\n        {\n            if (lst1[i] == lst2[j])\n            {\n                i++;\n                j++;\n            }\n            else\n            {\n                long temp = lst1[i];\n                lst1[i] = lst2[j];\n                lst2[j] = temp;\n                i++;\n                j++;\n            }\n        }\n        else if (lst1[i] % 2 == 1 && lst2[j] % 2 == 0)\n        {\n            if (lst1[i] == lst2[j])\n            {\n                i++;\n                j++;\n            }\n            else\n            {\n                long temp = lst1[i];\n                lst1[i] = lst2[\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "/tmp/tmp98bycn2u.d(88): Error: expression expected, not `unittest`\n/tmp/tmp98bycn2u.d(89): Error: found `{` when expecting `,`\n/tmp/tmp98bycn2u.d(90): Error: expression expected, not `alias`\n/tmp/tmp98bycn2u.d(90): Error: found `candidate` when expecting `,`\n/tmp/tmp98bycn2u.d(90): Error: expression expected, not `=`\n/tmp/tmp98bycn2u.d(90): Error: found `exchange` when expecting `,`\n/tmp/tmp98bycn2u.d(90): Error: expression expected, not `;`\n/tmp/tmp98bycn2u.d(92): Error: found `assert` when expecting `,`\n/tmp/tmp98bycn2u.d(92): Error: found `;` when expecting `,`\n/tmp/tmp98bycn2u.d(93): Error: found `;` when expecting `,`\n/tmp/tmp98bycn2u.d(94): Error: found `;` when expecting `,`\n/tmp/tmp98bycn2u.d(95): Error: found `;` when expecting `,`\n/tmp/tmp98bycn2u.d(96): Error: found `;` when expecting `,`\n/tmp/tmp98bycn2u.d(97): Error: found `;` when expecting `,`\n/tmp/tmp98bycn2u.d(98): Error: found `;` when expecting `,`\n/tmp/tmp98bycn2u.d(99): Error: expression expected, not `}`\n/tmp/tmp98bycn2u.d(100): Error: f",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    int i = 0;\n    int j = 0;\n    \n    while (i < lst1.length && j < lst2.length)\n    {\n        if (lst1[i] % 2 == 0 && lst2[j] % 2 != 0)\n        {\n            long temp = lst1[i];\n            lst1[i] = lst2[j];\n            lst2[j] = temp;\n            return \"YES\";\n        }\n        \n        if (lst1[i] % 2 != 0 && lst2[j] % 2 == 0)\n        {\n            long temp = lst1[i];\n            lst1[i] = lst2[j];\n            lst2[j] = temp;\n            return \"YES\";\n        }\n        \n        i++;\n        j++;\n    }\n    \n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpowpo5o1p.d(55): unittest failure\n----------------\n??:? _d_unittestp [0x4288dd]\n??:? void tmpowpo5o1p.__unittest_L51_C1() [0x42812e]\n??:? void tmpowpo5o1p.__modtest() [0x428660]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8e3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7f2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430909]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430db8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430895]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7c9]\n??:? runModuleUnitTests [0x42c6b9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428da0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0)\n        {\n            if(lst2[i] % 2 != 0)\n            {\n                if(lst1[i] != lst2[i])\n                    return \"NO\";\n            }\n            else\n                return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpjbb9v8ei.d(44): unittest failure\n----------------\n??:? _d_unittestp [0x428765]\n??:? void tmpjbb9v8ei.__unittest_L39_C1() [0x428091]\n??:? void tmpjbb9v8ei.__modtest() [0x4284e8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c76b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b67a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430791]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c40]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43071d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b651]\n??:? runModuleUnitTests [0x42c541]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428c28]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0)\n        {\n            if (lst2[i] % 2 == 0)\n            {\n                lst2[i] = lst2[i] + lst1[i];\n                lst1[i] = lst1[i] + lst2[i];\n                lst2[i] = lst2[i] - lst1[i];\n                lst1[i] = lst1[i] - lst2[i];\n            }\n            else\n                return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpnrjkdkar.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x428875]\n??:? void tmpnrjkdkar.__unittest_L41_C1() [0x4280c6]\n??:? void tmpnrjkdkar.__modtest() [0x4285f8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c87b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b78a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d50]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43082d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b761]\n??:? runModuleUnitTests [0x42c651]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d38]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    int i = 0;\n    while (i < lst1.length)\n    {\n        if (lst1[i] % 2 != 0)\n        {\n            if (lst2[i] % 2 == 0)\n            {\n                lst1[i] = lst2[i];\n                lst2[i] = lst1[i];\n                lst1[i] = lst2[i];\n                i = 0;\n            }\n            else\n                return \"NO\";\n        }\n        else\n        {\n            i++;\n        }\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpmwqn7qqg.d(49): unittest failure\n----------------\n??:? _d_unittestp [0x4287d5]\n??:? void tmpmwqn7qqg.__unittest_L45_C1() [0x428022]\n??:? void tmpmwqn7qqg.__modtest() [0x428554]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c7db]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b6ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430801]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430cb0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43078d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b6c1]\n??:? runModuleUnitTests [0x42c5b1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428c98]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n        \n        if(lst1[i] % 2 == 0 && lst2[i] % 2 != 0)\n        {\n            lst2[i] = lst2[i] + lst1[i];\n            lst1[i] = lst2[i] - lst1[i];\n            lst2[i] = lst2[i] - lst1[i];\n        }\n        \n        if(lst1[i] % 2 != 0 && lst2[i] % 2 == 0)\n        {\n            lst1[i] = lst1[i] + lst2[i];\n            lst2[i] = lst1[i] - lst2[i];\n            lst1[i] = lst1[i] - lst2[i];\n        }\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpj2t3olnp.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x428a9d]\n??:? void tmpj2t3olnp.__unittest_L46_C1() [0x4282ea]\n??:? void tmpj2t3olnp.__modtest() [0x42881c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42caa3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ac9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f78]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a55]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b989]\n??:? runModuleUnitTests [0x42c879]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f60]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0)\n        {\n            if (lst2[i] % 2 != 0)\n            {\n                if (lst1[i] != lst2[i])\n                    return \"NO\";\n            }\n            else\n                return \"NO\";\n        }\n        else\n        {\n            if (lst2[i] % 2 != 0)\n                return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcdx8nldt.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x4287b5]\n??:? void tmpcdx8nldt.__unittest_L44_C1() [0x4281a3]\n??:? void tmpcdx8nldt.__modtest() [0x428538]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c7bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b6ca]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4307e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c90]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43076d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b6a1]\n??:? runModuleUnitTests [0x42c591]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428c78]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0)\n        {\n            if(lst2[i] % 2 != 0)\n            {\n                if(lst1[i] != lst2[i])\n                    return \"NO\";\n            }\n            else\n                return \"NO\";\n        }\n        else\n        {\n            if(lst2[i] % 2 != 0)\n                return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp0ou6_g7l.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x4287b5]\n??:? void tmp0ou6_g7l.__unittest_L44_C1() [0x4281a3]\n??:? void tmp0ou6_g7l.__modtest() [0x428538]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c7bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b6ca]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4307e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c90]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43076d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b6a1]\n??:? runModuleUnitTests [0x42c591]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428c78]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n        \n        if(lst1[i] % 2 == 0 && lst2[i] % 2 != 0)\n        {\n            long temp = lst1[i];\n            lst1[i] = lst2[i];\n            lst2[i] = temp;\n            return \"YES\";\n        }\n    }\n    \n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpowzm8r4c.d(44): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpowzm8r4c.__unittest_L40_C1() [0x428086]\n??:? void tmpowzm8r4c.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c83b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b74a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430861]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d10]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307ed]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b721]\n??:? runModuleUnitTests [0x42c611]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0 || lst2[i] % 2 != 0)\n            return \"NO\";\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpczzfg5lc.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4286fd]\n??:? void tmpczzfg5lc.__unittest_L32_C1() [0x427f4a]\n??:? void tmpczzfg5lc.__modtest() [0x42847c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c703]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430729]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c4d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428bc0]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope void delegate",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n        \n        if(lst1[i] % 2 == 0 && lst2[i] % 2 != 0)\n        {\n            long temp = lst1[i];\n            lst1[i] = lst2[i];\n            lst2[i] = temp;\n            return \"YES\";\n        }\n    }\n    \n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpowzm8r4c.d(44): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpowzm8r4c.__unittest_L40_C1() [0x428086]\n??:? void tmpowzm8r4c.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c83b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b74a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430861]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d10]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307ed]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b721]\n??:? runModuleUnitTests [0x42c611]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    if(lst1.length == 1 || lst2.length == 1)\n        return \"YES\";\n    if(lst1.length == 2 && lst2.length == 2)\n        return \"YES\";\n    if(lst1.length == 2 && lst2.length == 3)\n        return \"YES\";\n    if(lst1.length == 3 && lst2.length == 3)\n        return \"YES\";\n    if(lst1.length == 3 && lst2.length == 4)\n        return \"YES\";\n    if(lst1.length == 4 && lst2.length == 4)\n        return \"YES\";\n    if(lst1.length == 4 && lst2.length == 5)\n        return \"YES\";\n    if(lst1.length == 5 && lst2.length == 5)\n        return \"YES\";\n    if(lst1.length == 5 && lst2.length == 6)\n        return \"YES\";\n    if(lst1.length == 6 && lst2.length == 6)\n        return \"YES\";\n    if(lst1.length == 6 && lst2.length == 7)\n        return \"YES\";\n    if(lst1.length == 7 && lst2.length == 7)\n        return \"YES\";\n    if(lst1.length == 7 && lst2.length == 8)\n        return \"YES\";\n    if(lst1.length == 8 && lst2.length == 8)\n        return \"YES\";\n    if(lst1.length == 8 && lst2.length == 9)\n        return \"YES\";\n    if(lst1.length == 9 && lst2.length == 9)\n        return \"YES\";\n    if(lst1.length == 9 && lst2.length == 10)\n        return \"YES\";\n    if(lst1.length == 10 && lst2.length == 10)\n        return \"YES\";\n    if(lst1.length == 10 && lst2.length\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "/tmp/tmpmt2cnn7o.d(60): Error: found `unittest` when expecting `)`\n/tmp/tmpmt2cnn7o.d(72): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmt2cnn7o.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    int i, j;\n    for (i = 0; i < lst1.length; i++)\n        if (lst1[i] % 2 != 0)\n            break;\n    \n    if (i == lst1.length)\n        return \"YES\";\n    \n    for (j = 0; j < lst2.length; j++)\n        if (lst2[j] % 2 != 0)\n            break;\n    \n    if (j == lst2.length)\n        return \"YES\";\n    \n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpefsndez4.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x42872d]\n??:? void tmpefsndez4.__unittest_L41_C1() [0x427f7e]\n??:? void tmpefsndez4.__modtest() [0x4284b0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c733]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b642]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430759]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c08]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306e5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b619]\n??:? runModuleUnitTests [0x42c509]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428bf0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    int i, j;\n    for(i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 == 0)\n        {\n            for(j = 0; j < lst2.length; j++)\n            {\n                if(lst2[j] % 2 == 1)\n                {\n                    if(lst1[i] == lst2[j])\n                    {\n                        lst1[i] = lst1[j];\n                        lst2[j] = lst2[i];\n                        lst1[i] = lst1[i] + lst2[j];\n                        lst2[j] = lst1[i] - lst2[j];\n                        lst1[i] = lst1[i] - lst2[j];\n                        return \"YES\";\n                    }\n                }\n            }\n        }\n    }\n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpjae6uc_4.d(52): unittest failure\n----------------\n??:? _d_unittestp [0x428935]\n??:? void tmpjae6uc_4.__unittest_L48_C1() [0x428186]\n??:? void tmpjae6uc_4.__modtest() [0x4286b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b84a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430961]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430e10]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4308ed]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b821]\n??:? runModuleUnitTests [0x42c711]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428df8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpnwpt6jhe.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4286fd]\n??:? void tmpnwpt6jhe.__unittest_L32_C1() [0x427f4a]\n??:? void tmpnwpt6jhe.__modtest() [0x42847c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c703]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430729]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c4d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428bc0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    int i = 0;\n    while (i < lst1.length)\n    {\n        if (lst1[i] % 2 != 0)\n        {\n            if (lst2[i] % 2 != 0)\n                return \"NO\";\n            else\n            {\n                lst2[i] = lst2[i] + lst1[i];\n                lst1[i] = lst1[i] + lst2[i];\n                lst2[i] = lst2[i] - lst1[i];\n                lst1[i] = lst1[i] - lst2[i];\n            }\n        }\n        else\n        {\n            if (lst2[i] % 2 != 0)\n                return \"NO\";\n            else\n            {\n                lst2[i] = lst2[i] + lst1[i];\n                lst1[i] = lst1[i] + lst2[i];\n                lst2[i] = lst2[i] - lst1[i];\n                lst1[i] = lst1[i] - lst2[i];\n            }\n        }\n        i++;\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp7jfmfbni.d(59): unittest failure\n----------------\n??:? _d_unittestp [0x428a5d]\n??:? void tmp7jfmfbni.__unittest_L55_C1() [0x4282ae]\n??:? void tmp7jfmfbni.__modtest() [0x4287e0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca63]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b972]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a89]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f38]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a15]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b949]\n??:? runModuleUnitTests [0x42c839]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f20]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0 || lst2[i] % 2 != 0)\n            return \"NO\";\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpe5drrh_4.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x428725]\n??:? void tmpe5drrh_4.__unittest_L35_C1() [0x427f72]\n??:? void tmpe5drrh_4.__modtest() [0x4284a4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c72b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b63a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430751]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c00]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b611]\n??:? runModuleUnitTests [0x42c501]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428be8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n        \n        if(lst1[i] % 2 == 0 && lst2[i] % 2 == 0)\n            continue;\n        \n        if(lst1[i] % 2 == 0)\n        {\n            lst1[i] = lst1[i] + lst2[i];\n            lst2[i] = lst1[i] - lst2[i];\n            lst1[i] = lst1[i] - lst2[i];\n        }\n        else\n        {\n            lst1[i] = lst1[i] - lst2[i];\n            lst2[i] = lst1[i] + lst2[i];\n            lst1[i] = lst1[i] + lst2[i];\n        }\n    }\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0)\n            return \"NO\";\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpopioxo76.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x428a8d]\n??:? void tmpopioxo76.__unittest_L54_C1() [0x4282de]\n??:? void tmpopioxo76.__modtest() [0x428810]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b979]\n??:? runModuleUnitTests [0x42c869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f50]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0 || lst2[i] % 2 != 0)\n            return \"NO\";\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpczzfg5lc.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4286fd]\n??:? void tmpczzfg5lc.__unittest_L32_C1() [0x427f4a]\n??:? void tmpczzfg5lc.__modtest() [0x42847c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c703]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430729]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c4d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428bc0]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope void delegate",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n        \n        if (lst1[i] % 2 == 0 && lst2[i] % 2 == 0)\n            continue;\n        \n        if (lst1[i] % 2 == 0)\n        {\n            lst1[i] = lst1[i] + lst2[i];\n            lst2[i] = lst1[i] - lst2[i];\n            lst1[i] = lst1[i] - lst2[i];\n        }\n        else\n        {\n            lst1[i] = lst1[i] - lst2[i];\n            lst2[i] = lst1[i] + lst2[i];\n            lst1[i] = lst1[i] + lst2[i];\n        }\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpjdfl7ac7.d(52): unittest failure\n----------------\n??:? _d_unittestp [0x428a2d]\n??:? void tmpjdfl7ac7.__unittest_L48_C1() [0x42827a]\n??:? void tmpjdfl7ac7.__modtest() [0x4287ac]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca33]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b942]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a59]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f08]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b919]\n??:? runModuleUnitTests [0x42c809]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428ef0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    if(lst1.length == 1 || lst2.length == 1)\n        return \"YES\";\n    if(lst1.length == 2 && lst2.length == 2)\n        return \"YES\";\n    if(lst1.length == 2 && lst2.length == 3)\n        return \"YES\";\n    if(lst1.length == 3 && lst2.length == 3)\n        return \"YES\";\n    if(lst1.length == 3 && lst2.length == 4)\n        return \"YES\";\n    if(lst1.length == 4 && lst2.length == 4)\n        return \"YES\";\n    if(lst1.length == 4 && lst2.length == 5)\n        return \"YES\";\n    if(lst1.length == 5 && lst2.length == 5)\n        return \"YES\";\n    if(lst1.length == 5 && lst2.length == 6)\n        return \"YES\";\n    if(lst1.length == 6 && lst2.length == 6)\n        return \"YES\";\n    if(lst1.length == 6 && lst2.length == 7)\n        return \"YES\";\n    if(lst1.length == 7 && lst2.length == 7)\n        return \"YES\";\n    if(lst1.length == 7 && lst2.length == 8)\n        return \"YES\";\n    if(lst1.length == 8 && lst2.length == 8)\n        return \"YES\";\n    if(lst1.length == 8 && lst2.length == 9)\n        return \"YES\";\n    if(lst1.length == 9 && lst2.length == 9)\n        return \"YES\";\n    if(lst1.length == 9 && lst2.length == 10)\n        return \"YES\";\n    if(lst1.length == 10 && lst2.length == 10)\n        return \"YES\";\n    if(lst1.length == 10 && lst2.length\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "/tmp/tmpmt2cnn7o.d(60): Error: found `unittest` when expecting `)`\n/tmp/tmpmt2cnn7o.d(72): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmt2cnn7o.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    if(lst1.length == 1)\n        return \"YES\";\n    if(lst1.length == 2)\n    {\n        if(lst1[0] % 2 == 0 && lst1[1] % 2 == 0)\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    if(lst1.length == 3)\n    {\n        if(lst1[0] % 2 == 0 && lst1[1] % 2 == 0 && lst1[2] % 2 == 0)\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    if(lst1.length == 4)\n    {\n        if(lst1[0] % 2 == 0 && lst1[1] % 2 == 0 && lst1[2] % 2 == 0 && lst1[3] % 2 == 0)\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    if(lst1.length == 5)\n    {\n        if(lst1[0] % 2 == 0 && lst1[1] % 2 == 0 && lst1[2] % 2 == 0 && lst1[3] % 2 == 0 && lst1[4] % 2 == 0)\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    if(lst1.length == 6)\n    {\n        if(lst1[0] % 2 == 0 && lst1[1] % 2 == 0 && lst1[2] % 2 == 0 && lst1[3] % 2 == 0 && lst1[4] % 2 == 0 && lst1[5] % 2 == 0)\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    if(lst1.length == 7)\n    {\n        if(lst1[0] % 2 == 0 && lst1[1] % 2 == 0 && lst1[2] % 2 == 0 && lst1[3] % 2 == 0\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "/tmp/tmpo2l_8g39.d(63): Error: found `unittest` when expecting `)`\n/tmp/tmpo2l_8g39.d(75): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpo2l_8g39.d(75): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo2l_8g39.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    if (lst1.length == 1 || lst2.length == 1)\n        return \"YES\";\n    if (lst1.length == 2 && lst2.length == 2)\n        return \"YES\";\n    if (lst1.length == 2 && lst2.length == 3)\n        return \"NO\";\n    if (lst1.length == 3 && lst2.length == 3)\n        return \"YES\";\n    if (lst1.length == 3 && lst2.length == 4)\n        return \"NO\";\n    if (lst1.length == 4 && lst2.length == 4)\n        return \"YES\";\n    if (lst1.length == 4 && lst2.length == 5)\n        return \"NO\";\n    if (lst1.length == 5 && lst2.length == 5)\n        return \"YES\";\n    if (lst1.length == 5 && lst2.length == 6)\n        return \"NO\";\n    if (lst1.length == 6 && lst2.length == 6)\n        return \"YES\";\n    if (lst1.length == 6 && lst2.length == 7)\n        return \"NO\";\n    if (lst1.length == 7 && lst2.length == 7)\n        return \"YES\";\n    if (lst1.length == 7 && lst2.length == 8)\n        return \"NO\";\n    if (lst1.length == 8 && lst2.length == 8)\n        return \"YES\";\n    if (lst1.length == 8 && lst2.length == 9)\n        return \"NO\";\n    if (lst1.length == 9 && lst2.length == 9)\n        return \"YES\";\n    if (lst1.length == 9 && lst2.length == 10)\n        return \"NO\";\n    if (lst1.length == 10 && lst2.length == 10)\n        return \"YES\";\n    if (lst1.length == 10 && lst2.length\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "/tmp/tmpg3qf783t.d(60): Error: found `unittest` when expecting `)`\n/tmp/tmpg3qf783t.d(72): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg3qf783t.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    int i = 0;\n    while (i < lst1.length)\n    {\n        if (lst1[i] % 2 != 0)\n        {\n            if (lst2[i] % 2 != 0)\n            {\n                if (lst1[i] != lst2[i])\n                    return \"NO\";\n            }\n            else\n                return \"NO\";\n        }\n        else\n        {\n            if (lst2[i] % 2 != 0)\n                return \"NO\";\n        }\n        i++;\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpskukav1z.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x4287b5]\n??:? void tmpskukav1z.__unittest_L45_C1() [0x4281a3]\n??:? void tmpskukav1z.__modtest() [0x428538]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c7bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b6ca]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4307e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c90]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43076d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b6a1]\n??:? runModuleUnitTests [0x42c591]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428c78]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n        \n        if(lst1[i] % 2 == 0 && lst2[i] % 2 != 0)\n        {\n            lst1[i] = lst1[i] + lst2[i];\n            lst2[i] = lst1[i] - lst2[i];\n            lst1[i] = lst1[i] - lst2[i];\n        }\n        \n        if(lst1[i] % 2 != 0 && lst2[i] % 2 == 0)\n        {\n            lst1[i] = lst1[i] + lst2[i];\n            lst2[i] = lst1[i] - lst2[i];\n            lst1[i] = lst1[i] - lst2[i];\n        }\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcyr_s98j.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x428a9d]\n??:? void tmpcyr_s98j.__unittest_L46_C1() [0x4282ea]\n??:? void tmpcyr_s98j.__modtest() [0x42881c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42caa3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ac9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f78]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a55]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b989]\n??:? runModuleUnitTests [0x42c879]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f60]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0)\n        {\n            if(lst2[i] % 2 == 0)\n            {\n                long temp = lst1[i];\n                lst1[i] = lst2[i];\n                lst2[i] = temp;\n                return \"YES\";\n            }\n            else\n                return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpxx4mebgb.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x42879d]\n??:? void tmpxx4mebgb.__unittest_L41_C1() [0x427fea]\n??:? void tmpxx4mebgb.__modtest() [0x42851c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c7a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b6b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4307c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c78]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430755]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b689]\n??:? runModuleUnitTests [0x42c579]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428c60]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    int i = 0;\n    while (i < lst1.length)\n    {\n        if (lst1[i] % 2 != 0)\n        {\n            if (lst2[i] % 2 != 0)\n                return \"NO\";\n            else\n            {\n                long temp = lst1[i];\n                lst1[i] = lst2[i];\n                lst2[i] = temp;\n            }\n        }\n        i++;\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpo2vj439e.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428795]\n??:? void tmpo2vj439e.__unittest_L42_C1() [0x427fe6]\n??:? void tmpo2vj439e.__modtest() [0x428518]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c79b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b6aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4307c1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c70]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43074d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b681]\n??:? runModuleUnitTests [0x42c571]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428c58]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n        if(lst1[i] % 2 == 0 && lst2[i] % 2 == 0)\n            continue;\n        if(lst1[i] % 2 == 0)\n        {\n            lst1[i] = lst1[i] + lst2[i];\n            lst2[i] = lst1[i] - lst2[i];\n            lst1[i] = lst1[i] - lst2[i];\n        }\n        else\n        {\n            lst1[i] = lst1[i] - lst2[i];\n            lst2[i] = lst1[i] + lst2[i];\n            lst1[i] = lst1[i] + lst2[i];\n        }\n    }\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0)\n            return \"NO\";\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpwrte43te.d(55): unittest failure\n----------------\n??:? _d_unittestp [0x428a8d]\n??:? void tmpwrte43te.__unittest_L51_C1() [0x4282de]\n??:? void tmpwrte43te.__modtest() [0x428810]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b979]\n??:? runModuleUnitTests [0x42c869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f50]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0)\n        {\n            for (int j = 0; j < lst2.length; j++)\n            {\n                if (lst2[j] % 2 == 0)\n                {\n                    long temp = lst1[i];\n                    lst1[i] = lst2[j];\n                    lst2[j] = temp;\n                    return \"YES\";\n                }\n            }\n        }\n    }\n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp117tmp_2.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x4287c5]\n??:? void tmp117tmp_2.__unittest_L45_C1() [0x4280ed]\n??:? void tmp117tmp_2.__modtest() [0x428544]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c7cb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b6da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4307f1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ca0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43077d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b6b1]\n??:? runModuleUnitTests [0x42c5a1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428c88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0)\n        {\n            if (lst2[i] % 2 != 0)\n                return \"NO\";\n            else\n                lst2[i] = lst2[i] + lst1[i];\n        }\n        else\n        {\n            if (lst2[i] % 2 != 0)\n                lst2[i] = lst2[i] - lst1[i];\n            else\n                lst1[i] = lst1[i] + lst2[i];\n        }\n    }\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0)\n            return \"NO\";\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpwah69bnn.d(54): unittest failure\n----------------\n??:? _d_unittestp [0x428955]\n??:? void tmpwah69bnn.__unittest_L50_C1() [0x4281a2]\n??:? void tmpwah69bnn.__modtest() [0x4286d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c95b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b86a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430981]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430e30]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43090d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b841]\n??:? runModuleUnitTests [0x42c731]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e18]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0)\n        {\n            if (lst2[i] % 2 != 0)\n                return \"NO\";\n            else\n                lst2[i] = lst2[i] + lst1[i];\n        }\n        else\n        {\n            if (lst2[i] % 2 != 0)\n                lst2[i] = lst2[i] - lst1[i];\n            else\n                lst1[i] = lst1[i] + lst2[i];\n        }\n    }\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0)\n            return \"NO\";\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpwah69bnn.d(54): unittest failure\n----------------\n??:? _d_unittestp [0x428955]\n??:? void tmpwah69bnn.__unittest_L50_C1() [0x4281a2]\n??:? void tmpwah69bnn.__modtest() [0x4286d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c95b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b86a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430981]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430e30]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43090d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b841]\n??:? runModuleUnitTests [0x42c731]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e18]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    int i = 0;\n    while(i < lst1.length)\n    {\n        if(lst1[i] % 2 != 0)\n        {\n            if(lst2[i] % 2 != 0)\n                return \"NO\";\n            else\n                lst2[i] = lst2[i] + lst1[i];\n        }\n        else\n        {\n            if(lst2[i] % 2 != 0)\n                lst2[i] = lst2[i] - lst1[i];\n            else\n                lst1[i] = lst1[i] + lst2[i];\n        }\n        i++;\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp81b0regs.d(49): unittest failure\n----------------\n??:? _d_unittestp [0x4288e5]\n??:? void tmp81b0regs.__unittest_L45_C1() [0x428136]\n??:? void tmp81b0regs.__modtest() [0x428668]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8eb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7fa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430911]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430dc0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43089d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7d1]\n??:? runModuleUnitTests [0x42c6c1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428da8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0)\n        {\n            if (lst2[i] % 2 != 0)\n                return \"NO\";\n            else\n                lst2[i] = lst2[i] + lst1[i];\n        }\n        else\n        {\n            if (lst2[i] % 2 != 0)\n                lst2[i] = lst2[i] - lst1[i];\n            else\n                lst1[i] = lst1[i] + lst2[i];\n        }\n    }\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0)\n            return \"NO\";\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpwah69bnn.d(54): unittest failure\n----------------\n??:? _d_unittestp [0x428955]\n??:? void tmpwah69bnn.__unittest_L50_C1() [0x4281a2]\n??:? void tmpwah69bnn.__modtest() [0x4286d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c95b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b86a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430981]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430e30]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43090d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b841]\n??:? runModuleUnitTests [0x42c731]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e18]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n        \n        if(lst1[i] % 2 == 0 && lst2[i] % 2 != 0)\n        {\n            long temp = lst1[i];\n            lst1[i] = lst2[i];\n            lst2[i] = temp;\n            return \"YES\";\n        }\n    }\n    \n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpowzm8r4c.d(44): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpowzm8r4c.__unittest_L40_C1() [0x428086]\n??:? void tmpowzm8r4c.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c83b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b74a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430861]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d10]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307ed]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b721]\n??:? runModuleUnitTests [0x42c611]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    int i;\n    for(i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i]%2 != 0)\n            break;\n    }\n    if(i == lst1.length)\n        return \"YES\";\n    else\n        return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpdfvik9ld.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x4286b5]\n??:? void tmpdfvik9ld.__unittest_L34_C1() [0x427f06]\n??:? void tmpdfvik9ld.__modtest() [0x428438]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b5ca]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b90]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43066d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5a1]\n??:? runModuleUnitTests [0x42c491]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b78]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n        \n        if (lst1[i] % 2 == 0 && lst2[i] % 2 == 0)\n            continue;\n        \n        if (lst1[i] % 2 == 0)\n        {\n            lst1[i] = lst1[i] + lst2[i];\n            lst2[i] = lst1[i] - lst2[i];\n            lst1[i] = lst1[i] - lst2[i];\n        }\n        else\n        {\n            lst1[i] = lst1[i] - lst2[i];\n            lst2[i] = lst1[i] + lst2[i];\n            lst1[i] = lst1[i] + lst2[i];\n        }\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpjdfl7ac7.d(52): unittest failure\n----------------\n??:? _d_unittestp [0x428a2d]\n??:? void tmpjdfl7ac7.__unittest_L48_C1() [0x42827a]\n??:? void tmpjdfl7ac7.__modtest() [0x4287ac]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca33]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b942]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a59]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f08]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b919]\n??:? runModuleUnitTests [0x42c809]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428ef0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0)\n        {\n            if(lst2[i] % 2 != 0)\n            {\n                if(lst1[i] != lst2[i])\n                    return \"NO\";\n            }\n            else\n                return \"NO\";\n        }\n        else\n        {\n            if(lst2[i] % 2 != 0)\n                return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp0ou6_g7l.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x4287b5]\n??:? void tmp0ou6_g7l.__unittest_L44_C1() [0x4281a3]\n??:? void tmp0ou6_g7l.__modtest() [0x428538]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c7bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b6ca]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4307e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c90]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43076d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b6a1]\n??:? runModuleUnitTests [0x42c591]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428c78]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0 || lst2[i] % 2 != 0)\n            return \"NO\";\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgczyxv0g.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4286fd]\n??:? void tmpgczyxv0g.__unittest_L32_C1() [0x427f4a]\n??:? void tmpgczyxv0g.__modtest() [0x42847c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c703]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430729]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c4d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428bc0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    if(lst1.length == 1 || lst2.length == 1)\n        return \"YES\";\n    if(lst1.length == 2 && lst2.length == 2)\n        return \"YES\";\n    if(lst1.length == 2 && lst2.length == 3)\n        return \"YES\";\n    if(lst1.length == 3 && lst2.length == 3)\n        return \"YES\";\n    if(lst1.length == 3 && lst2.length == 4)\n        return \"YES\";\n    if(lst1.length == 4 && lst2.length == 4)\n        return \"YES\";\n    if(lst1.length == 4 && lst2.length == 5)\n        return \"YES\";\n    if(lst1.length == 5 && lst2.length == 5)\n        return \"YES\";\n    if(lst1.length == 5 && lst2.length == 6)\n        return \"YES\";\n    if(lst1.length == 6 && lst2.length == 6)\n        return \"YES\";\n    if(lst1.length == 6 && lst2.length == 7)\n        return \"YES\";\n    if(lst1.length == 7 && lst2.length == 7)\n        return \"YES\";\n    if(lst1.length == 7 && lst2.length == 8)\n        return \"YES\";\n    if(lst1.length == 8 && lst2.length == 8)\n        return \"YES\";\n    if(lst1.length == 8 && lst2.length == 9)\n        return \"YES\";\n    if(lst1.length == 9 && lst2.length == 9)\n        return \"YES\";\n    if(lst1.length == 9 && lst2.length == 10)\n        return \"YES\";\n    if(lst1.length == 10 && lst2.length == 10)\n        return \"YES\";\n    if(lst1.length == 10 && lst2.length\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "/tmp/tmpmt2cnn7o.d(60): Error: found `unittest` when expecting `)`\n/tmp/tmpmt2cnn7o.d(72): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmt2cnn7o.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    if(lst1.length == 1 || lst2.length == 1)\n        return \"YES\";\n    \n    if(lst1.length == 2 && lst2.length == 2)\n    {\n        if(lst1[0] == lst2[0] || lst1[0] == lst2[1] || lst1[1] == lst2[0] || lst1[1] == lst2[1])\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    \n    if(lst1.length == 2 && lst2.length == 3)\n    {\n        if(lst1[0] == lst2[0] || lst1[0] == lst2[1] || lst1[0] == lst2[2] || lst1[1] == lst2[0] || lst1[1] == lst2[1] || lst1[1] == lst2[2])\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    \n    if(lst1.length == 3 && lst2.length == 3)\n    {\n        if(lst1[0] == lst2[0] || lst1[0] == lst2[1] || lst1[0] == lst2[2] || lst1[1] == lst2[0] || lst1[1] == lst2[1] || lst1[1] == lst2[2] || lst1[2] == lst2[0] || lst1[2] == lst2[1] || lst1[2] == lst2[2])\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    \n    if(lst1.length == 3 && lst2.length == 4)\n    {\n        if(lst1[0] == lst2[0] || lst1[0] == lst2\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "/tmp/tmp6k9y9h9c.d(54): Error: found `unittest` when expecting `)`\n/tmp/tmp6k9y9h9c.d(66): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp6k9y9h9c.d(66): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6k9y9h9c.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    if (lst1.length == 1 || lst2.length == 1)\n        return \"YES\";\n    \n    if (lst1.length == 2 && lst2.length == 2)\n        return \"YES\";\n    \n    if (lst1.length == 2 && lst2.length == 3)\n        return \"YES\";\n    \n    if (lst1.length == 3 && lst2.length == 3)\n        return \"YES\";\n    \n    if (lst1.length == 3 && lst2.length == 4)\n        return \"YES\";\n    \n    if (lst1.length == 4 && lst2.length == 4)\n        return \"YES\";\n    \n    if (lst1.length == 4 && lst2.length == 5)\n        return \"YES\";\n    \n    if (lst1.length == 5 && lst2.length == 5)\n        return \"YES\";\n    \n    if (lst1.length == 5 && lst2.length == 6)\n        return \"YES\";\n    \n    if (lst1.length == 6 && lst2.length == 6)\n        return \"YES\";\n    \n    if (lst1.length == 6 && lst2.length == 7)\n        return \"YES\";\n    \n    if (lst1.length == 7 && lst2.length == 7)\n        return \"YES\";\n    \n    if (lst1.length == 7 && lst2.length == 8)\n        return \"YES\";\n    \n    if (lst1.length == 8 && lst2.length == 8)\n        return \"YES\";\n    \n    if (lst1.length == 8 && lst2.length == 9)\n        return \"YES\";\n    \n    if (lst1.length == 9 && lst2.length == 9)\n        return \"YES\";\n    \n    if (lst1.length == 9 && lst2.length == 10)\n        return \"YES\";\n    \n    if (lst1\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "/tmp/tmp34vg3ir4.d(76): Error: found `unittest` when expecting `)`\n/tmp/tmp34vg3ir4.d(88): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp34vg3ir4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0 || lst2[i] % 2 != 0)\n            return \"NO\";\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpczzfg5lc.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4286fd]\n??:? void tmpczzfg5lc.__unittest_L32_C1() [0x427f4a]\n??:? void tmpczzfg5lc.__modtest() [0x42847c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c703]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430729]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c4d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428bc0]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope void delegate",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0)\n        {\n            if(lst2[i] % 2 != 0)\n            {\n                if(lst1[i] != lst2[i])\n                    return \"NO\";\n            }\n            else\n                return \"NO\";\n        }\n        else\n        {\n            if(lst2[i] % 2 != 0)\n                return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp0ou6_g7l.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x4287b5]\n??:? void tmp0ou6_g7l.__unittest_L44_C1() [0x4281a3]\n??:? void tmp0ou6_g7l.__modtest() [0x428538]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c7bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b6ca]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4307e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c90]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43076d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b6a1]\n??:? runModuleUnitTests [0x42c591]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428c78]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp3o2um0j1.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4286fd]\n??:? void tmp3o2um0j1.__unittest_L32_C1() [0x427f4a]\n??:? void tmp3o2um0j1.__modtest() [0x42847c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c703]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430729]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c4d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428bc0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    int i, j;\n    for (i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0)\n            break;\n    }\n    if (i == lst1.length)\n        return \"YES\";\n    for (j = 0; j < lst2.length; j++)\n    {\n        if (lst2[j] % 2 != 0)\n            break;\n    }\n    if (j == lst2.length)\n        return \"YES\";\n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp3rr0dfzf.d(44): unittest failure\n----------------\n??:? _d_unittestp [0x42872d]\n??:? void tmp3rr0dfzf.__unittest_L40_C1() [0x427f7e]\n??:? void tmp3rr0dfzf.__modtest() [0x4284b0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c733]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b642]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430759]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c08]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306e5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b619]\n??:? runModuleUnitTests [0x42c509]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428bf0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    for (int i = 0; i < lst1.length; i++)\n        if (lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpv55h61yp.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x4286fd]\n??:? void tmpv55h61yp.__unittest_L28_C1() [0x427f4a]\n??:? void tmpv55h61yp.__modtest() [0x42847c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c703]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430729]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c4d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428bc0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n        if (lst1[i] % 2 == 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n        if (lst1[i] % 2 != 0 && lst2[i] % 2 == 0)\n            return \"NO\";\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqhcm2wtn.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x428815]\n??:? void tmpqhcm2wtn.__unittest_L35_C1() [0x428066]\n??:? void tmpqhcm2wtn.__modtest() [0x428598]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c81b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b72a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430841]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430cf0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307cd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b701]\n??:? runModuleUnitTests [0x42c5f1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cd8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0)\n        {\n            if (lst2[i] % 2 != 0)\n            {\n                if (lst1[i] != lst2[i])\n                    return \"NO\";\n            }\n            else\n                return \"NO\";\n        }\n        else if (lst2[i] % 2 != 0)\n            return \"NO\";\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpnop11m17.d(47): unittest failure\n----------------\n??:? _d_unittestp [0x4287b5]\n??:? void tmpnop11m17.__unittest_L41_C1() [0x4281a3]\n??:? void tmpnop11m17.__modtest() [0x428538]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c7bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b6ca]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4307e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c90]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43076d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b6a1]\n??:? runModuleUnitTests [0x42c591]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428c78]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    if(lst1.length == 1 || lst2.length == 1)\n        return \"YES\";\n    \n    if(lst1[0] % 2 == 0 && lst2[0] % 2 == 0)\n        return \"YES\";\n    \n    if(lst1[0] % 2 != 0 && lst2[0] % 2 != 0)\n        return \"NO\";\n    \n    for(int i = 1; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n        \n        if(lst1[i] % 2 == 0 && lst2[i] % 2 == 0)\n            return \"YES\";\n    }\n    \n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmplp80v5u3.d(48): unittest failure\n----------------\n??:? _d_unittestp [0x4288ad]\n??:? void tmplp80v5u3.__unittest_L44_C1() [0x4280fe]\n??:? void tmplp80v5u3.__modtest() [0x428630]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8b3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7c2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308d9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d88]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430865]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b799]\n??:? runModuleUnitTests [0x42c689]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d70]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0 || lst2[i] % 2 != 0)\n            return \"NO\";\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpczzfg5lc.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4286fd]\n??:? void tmpczzfg5lc.__unittest_L32_C1() [0x427f4a]\n??:? void tmpczzfg5lc.__modtest() [0x42847c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c703]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430729]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c4d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428bc0]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope void delegate",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    int i = 0;\n    while (i < lst1.length)\n    {\n        if (lst1[i] % 2 != 0)\n        {\n            if (lst2[i] % 2 != 0)\n                return \"NO\";\n            else\n                lst2[i] = lst2[i] + lst1[i];\n        }\n        else\n        {\n            if (lst2[i] % 2 != 0)\n                lst2[i] = lst2[i] - lst1[i];\n            else\n                return \"NO\";\n        }\n        i++;\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpes_7sfat.d(49): unittest failure\n----------------\n??:? _d_unittestp [0x42885d]\n??:? void tmpes_7sfat.__unittest_L45_C1() [0x4280aa]\n??:? void tmpes_7sfat.__modtest() [0x4285dc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c863]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b772]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430889]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d38]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430815]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b749]\n??:? runModuleUnitTests [0x42c639]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d20]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    if (lst1.length == 1)\n        return \"YES\";\n    \n    long[] even = new long[lst1.length];\n    long[] odd = new long[lst1.length];\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 == 0)\n            even[i] = lst1[i];\n        else\n            odd[i] = lst1[i];\n    }\n    \n    for (int i = 0; i < lst2.length; i++)\n    {\n        if (lst2[i] % 2 == 0)\n            even[i] = lst2[i];\n        else\n            odd[i] = lst2[i];\n    }\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (odd[i] != even[i])\n            return \"NO\";\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpi8jlf4w5.d(61): unittest failure\n----------------\n??:? _d_unittestp [0x42898d]\n??:? void tmpi8jlf4w5.__unittest_L57_C1() [0x4281da]\n??:? void tmpi8jlf4w5.__modtest() [0x42870c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8fe]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fbc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a99]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b8d5]\n??:? runModuleUnitTests [0x42c7c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e50]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0)\n        {\n            if (lst2[i] % 2 != 0)\n                return \"NO\";\n            else\n                lst2[i] = lst2[i] + lst1[i];\n        }\n        else\n        {\n            if (lst2[i] % 2 != 0)\n                lst2[i] = lst2[i] - lst1[i];\n            else\n                lst1[i] = lst1[i] + lst2[i];\n        }\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpx2gr0xqj.d(48): unittest failure\n----------------\n??:? _d_unittestp [0x4288e5]\n??:? void tmpx2gr0xqj.__unittest_L44_C1() [0x428136]\n??:? void tmpx2gr0xqj.__modtest() [0x428668]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8eb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7fa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430911]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430dc0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43089d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7d1]\n??:? runModuleUnitTests [0x42c6c1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428da8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    int i = 0;\n    int j = 0;\n    \n    while(i < lst1.length && j < lst2.length)\n    {\n        if(lst1[i] % 2 == 0 && lst2[j] % 2 == 0)\n        {\n            if(lst1[i] != lst2[j])\n            {\n                long temp = lst1[i];\n                lst1[i] = lst2[j];\n                lst2[j] = temp;\n                return \"YES\";\n            }\n        }\n        else if(lst1[i] % 2 != 0 && lst2[j] % 2 != 0)\n        {\n            if(lst1[i] != lst2[j])\n            {\n                long temp = lst1[i];\n                lst1[i] = lst2[j];\n                lst2[j] = temp;\n                return \"YES\";\n            }\n        }\n        \n        i++;\n        j++;\n    }\n    \n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpmqxz3vtj.d(60): unittest failure\n----------------\n??:? _d_unittestp [0x42898d]\n??:? void tmpmqxz3vtj.__unittest_L56_C1() [0x4281de]\n??:? void tmpmqxz3vtj.__modtest() [0x428710]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c993]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4309b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430e68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430945]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b879]\n??:? runModuleUnitTests [0x42c769]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e50]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    int i = 0;\n    int j = 0;\n    \n    while(i < lst1.length && j < lst2.length)\n    {\n        if(lst1[i] % 2 == 0 && lst2[j] % 2 == 0)\n        {\n            if(lst1[i] == lst2[j])\n            {\n                i++;\n                j++;\n            }\n            else\n            {\n                if(lst1[i] < lst2[j])\n                {\n                    i++;\n                }\n                else\n                {\n                    j++;\n                }\n            }\n        }\n        else if(lst1[i] % 2 == 0 && lst2[j] % 2 != 0)\n        {\n            if(lst1[i] == lst2[j])\n            {\n                i++;\n                j++;\n            }\n            else\n            {\n                if(lst1[i] < lst2[j])\n                {\n                    i++;\n                }\n                else\n                {\n                    j++;\n                }\n            }\n        }\n        else if(lst1[i] % 2 != 0 && lst2[j] % 2 == 0)\n        {\n            if(lst1[i] == lst2[j])\n            {\n                i++;\n                j++;\n            }\n            else\n            {\n                if(lst1[i] < lst2[j])\n                {\n                    i++;\n                }\n                else\n                {\n                    j++;\n                }\n            }\n        }\n        else\n        {\n            if(lst1[i] == lst2[j])\n            {\n                i++;\n                j++;\n            }\n            else\n            {\n                if(lst1[i] < lst2[j])\n                {\n                    i++;\n                }\n                else\n                {\n                    j++;\n                }\n            }\n        }\n    }\n    \n    if(i == lst1.length &&\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "/tmp/tmpipfwv3aw.d(108): Error: expression expected, not `unittest`\n/tmp/tmpipfwv3aw.d(109): Error: found `{` when expecting `)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpipfwv3aw.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0)\n        {\n            if (lst2[i] % 2 != 0)\n                return \"NO\";\n            else\n                lst2[i] = lst2[i] + lst1[i];\n        }\n        else\n        {\n            if (lst2[i] % 2 != 0)\n                lst2[i] = lst2[i] - lst1[i];\n            else\n                lst1[i] = lst1[i] + lst2[i];\n        }\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpx2gr0xqj.d(48): unittest failure\n----------------\n??:? _d_unittestp [0x4288e5]\n??:? void tmpx2gr0xqj.__unittest_L44_C1() [0x428136]\n??:? void tmpx2gr0xqj.__modtest() [0x428668]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8eb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7fa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430911]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430dc0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43089d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7d1]\n??:? runModuleUnitTests [0x42c6c1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428da8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    long sum = 0;\n    for (int i = 0; i < lst1.length; i++)\n        sum += lst1[i];\n    \n    if (sum % 2 != 0)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0)\n            continue;\n        \n        for (int j = 0; j < lst2.length; j++)\n        {\n            if (lst2[j] % 2 != 0)\n                continue;\n            \n            if (lst1[i] == lst2[j])\n            {\n                swap(lst1, i, j);\n                return \"YES\";\n            }\n        }\n    }\n    \n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "/tmp/tmpsobldunm.d(43): Error: undefined identifier `swap`, did you mean template `wrap(Targets...) if (Targets.length >= 1 && allSatisfy!(isMutable, Targets))`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsobldunm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    int i, j;\n    for(i = 0; i < lst1.length; i++)\n        if(lst1[i] % 2 != 0)\n            break;\n    if(i == lst1.length)\n        return \"YES\";\n    for(j = 0; j < lst2.length; j++)\n        if(lst2[j] % 2 != 0)\n            break;\n    if(j == lst2.length)\n        return \"YES\";\n    for(i = 0; i < lst1.length; i++)\n        if(lst1[i] % 2 != 0)\n            lst1[i] = lst1[i] + lst2[i];\n        else\n            lst1[i] = lst1[i] - lst2[i];\n    for(j = 0; j < lst2.length; j++)\n        if(lst2[j] % 2 != 0)\n            lst2[j] = lst2[j] + lst1[j];\n        else\n            lst2[j] = lst2[j] - lst1[j];\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpd9gbb793.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428a35]\n??:? void tmpd9gbb793.__unittest_L46_C1() [0x428361]\n??:? void tmpd9gbb793.__modtest() [0x4287b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca3b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b94a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a61]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f10]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309ed]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b921]\n??:? runModuleUnitTests [0x42c811]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428ef8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0)\n        {\n            if(lst2[i] % 2 == 0)\n            {\n                lst1[i] = lst2[i];\n                lst2[i] = lst1[i];\n                lst1[i] = lst2[i];\n            }\n            else\n                return \"NO\";\n        }\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpg6ste_2a.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x4287cd]\n??:? void tmpg6ste_2a.__unittest_L41_C1() [0x42801a]\n??:? void tmpg6ste_2a.__modtest() [0x42854c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c7d3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b6e2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4307f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ca8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430785]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b6b9]\n??:? runModuleUnitTests [0x42c5a9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428c90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    if(lst1.length == 1)\n        return \"YES\";\n    \n    if(lst1.length == 2)\n    {\n        if(lst1[0] == lst2[0] || lst1[0] == lst2[1])\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    \n    if(lst1.length == 3)\n    {\n        if(lst1[0] == lst2[0] || lst1[0] == lst2[1] || lst1[0] == lst2[2])\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    \n    if(lst1.length == 4)\n    {\n        if(lst1[0] == lst2[0] || lst1[0] == lst2[1] || lst1[0] == lst2[2] || lst1[0] == lst2[3])\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    \n    if(lst1.length == 5)\n    {\n        if(lst1[0] == lst2[0] || lst1[0] == lst2[1] || lst1[0] == lst2[2] || lst1[0] == lst2[3] || lst1[0] == lst2[4])\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    \n    if(lst1.length == 6)\n    {\n        if(lst1[0] == lst2[0] || lst1[0] == lst2[1] || lst1[0] == lst2[2] || lst1[0] == lst2[3] || lst1[0] == lst2[4] || lst1[0] == lst2[5])\n            return \"YES\";\n        else\n            return \"\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "/tmp/tmp09uezobw.d(69): Error: found `YES` when expecting `;` following `return` statement\n/tmp/tmp09uezobw.d(70): Error: found `NO` when expecting `;` following statement\n/tmp/tmp09uezobw.d(71): Error: found `YES` when expecting `;` following statement\n/tmp/tmp09uezobw.d(72): Error: found `YES` when expecting `;` following statement\n/tmp/tmp09uezobw.d(73): Error: found `NO` when expecting `;` following statement\n/tmp/tmp09uezobw.d(74): Error: found `NO` when expecting `;` following statement\n/tmp/tmp09uezobw.d(75): Error: found `YES` when expecting `;` following statement\n/tmp/tmp09uezobw.d(75): Error: unterminated string constant starting at /tmp/tmp09uezobw.d(75)\n/tmp/tmp09uezobw.d(77): Error: found `End of File` when expecting `;` following statement\n/tmp/tmp09uezobw.d(77): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp09uezobw.d(77): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp09uezobw.d",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    if(lst1.length == 1 || lst2.length == 1)\n        return \"YES\";\n    \n    if(lst1.length == 2 && lst2.length == 2)\n    {\n        if(lst1[0] == lst2[0] || lst1[0] == lst2[1] || lst1[1] == lst2[0] || lst1[1] == lst2[1])\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    \n    if(lst1.length == 2 && lst2.length == 3)\n    {\n        if(lst1[0] == lst2[0] || lst1[0] == lst2[1] || lst1[0] == lst2[2] || lst1[1] == lst2[0] || lst1[1] == lst2[1] || lst1[1] == lst2[2])\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    \n    if(lst1.length == 3 && lst2.length == 3)\n    {\n        if(lst1[0] == lst2[0] || lst1[0] == lst2[1] || lst1[0] == lst2[2] || lst1[1] == lst2[0] || lst1[1] == lst2[1] || lst1[1] == lst2[2] || lst1[2] == lst2[0] || lst1[2] == lst2[1] || lst1[2] == lst2[2])\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    \n    if(lst1.length == 3 && lst2.length == 4)\n    {\n        if(lst1[0] == lst2[0] || lst1[0] == lst2\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "/tmp/tmp6k9y9h9c.d(54): Error: found `unittest` when expecting `)`\n/tmp/tmp6k9y9h9c.d(66): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp6k9y9h9c.d(66): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6k9y9h9c.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    int i = 0;\n    while(i < lst1.length)\n    {\n        if(lst1[i] % 2 != 0)\n        {\n            if(lst2[i] % 2 != 0)\n                return \"NO\";\n            else\n            {\n                lst2[i] = lst2[i] + lst1[i];\n                lst1[i] = lst2[i] - lst1[i];\n                lst2[i] = lst2[i] - lst1[i];\n                lst1[i] = lst2[i] + lst1[i];\n            }\n        }\n        i++;\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpi95c4lec.d(47): unittest failure\n----------------\n??:? _d_unittestp [0x428875]\n??:? void tmpi95c4lec.__unittest_L43_C1() [0x4280c6]\n??:? void tmpi95c4lec.__modtest() [0x4285f8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c87b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b78a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d50]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43082d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b761]\n??:? runModuleUnitTests [0x42c651]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d38]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n        \n        if(lst1[i] % 2 == 0 && lst2[i] % 2 != 0)\n        {\n            lst1[i] = lst1[i] + lst2[i];\n            lst2[i] = lst1[i] - lst2[i];\n            lst1[i] = lst1[i] - lst2[i];\n        }\n        \n        if(lst1[i] % 2 != 0 && lst2[i] % 2 == 0)\n        {\n            lst1[i] = lst1[i] + lst2[i];\n            lst2[i] = lst1[i] - lst2[i];\n            lst1[i] = lst1[i] - lst2[i];\n        }\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcyr_s98j.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x428a9d]\n??:? void tmpcyr_s98j.__unittest_L46_C1() [0x4282ea]\n??:? void tmpcyr_s98j.__modtest() [0x42881c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42caa3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ac9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f78]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a55]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b989]\n??:? runModuleUnitTests [0x42c879]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f60]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    if(lst1.length == 1 || lst2.length == 1)\n        return \"YES\";\n    if(lst1.length == 2 && lst2.length == 2)\n        return \"YES\";\n    if(lst1.length == 2 && lst2.length == 3)\n        return \"YES\";\n    if(lst1.length == 3 && lst2.length == 3)\n        return \"YES\";\n    if(lst1.length == 3 && lst2.length == 4)\n        return \"YES\";\n    if(lst1.length == 4 && lst2.length == 4)\n        return \"YES\";\n    if(lst1.length == 4 && lst2.length == 5)\n        return \"YES\";\n    if(lst1.length == 5 && lst2.length == 5)\n        return \"YES\";\n    if(lst1.length == 5 && lst2.length == 6)\n        return \"YES\";\n    if(lst1.length == 6 && lst2.length == 6)\n        return \"YES\";\n    if(lst1.length == 6 && lst2.length == 7)\n        return \"YES\";\n    if(lst1.length == 7 && lst2.length == 7)\n        return \"YES\";\n    if(lst1.length == 7 && lst2.length == 8)\n        return \"YES\";\n    if(lst1.length == 8 && lst2.length == 8)\n        return \"YES\";\n    if(lst1.length == 8 && lst2.length == 9)\n        return \"YES\";\n    if(lst1.length == 9 && lst2.length == 9)\n        return \"YES\";\n    if(lst1.length == 9 && lst2.length == 10)\n        return \"YES\";\n    if(lst1.length == 10 && lst2.length == 10)\n        return \"YES\";\n    if(lst1.length == 10 && lst2.length\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "/tmp/tmpmt2cnn7o.d(60): Error: found `unittest` when expecting `)`\n/tmp/tmpmt2cnn7o.d(72): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmt2cnn7o.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    int i = 0;\n    while (i < lst1.length)\n    {\n        if (lst1[i] % 2 != 0)\n        {\n            if (lst2[i] % 2 != 0)\n            {\n                if (lst1[i] != lst2[i])\n                    return \"NO\";\n            }\n            else\n                return \"NO\";\n        }\n        else\n        {\n            if (lst2[i] % 2 != 0)\n                return \"NO\";\n        }\n        i++;\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpj0__wnrc.d(52): unittest failure\n----------------\n??:? _d_unittestp [0x4287b5]\n??:? void tmpj0__wnrc.__unittest_L46_C1() [0x4281a3]\n??:? void tmpj0__wnrc.__modtest() [0x428538]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c7bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b6ca]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4307e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c90]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43076d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b6a1]\n??:? runModuleUnitTests [0x42c591]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428c78]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0)\n        {\n            if(lst2[i] % 2 != 0)\n            {\n                if(lst1[i] != lst2[i])\n                    return \"NO\";\n            }\n            else\n                return \"NO\";\n        }\n        else if(lst2[i] % 2 != 0)\n            return \"NO\";\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpoafx_lz6.d(47): unittest failure\n----------------\n??:? _d_unittestp [0x4287b5]\n??:? void tmpoafx_lz6.__unittest_L41_C1() [0x4281a3]\n??:? void tmpoafx_lz6.__modtest() [0x428538]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c7bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b6ca]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4307e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c90]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43076d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b6a1]\n??:? runModuleUnitTests [0x42c591]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428c78]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    if(lst1.length == 1)\n        return \"YES\";\n    \n    if(lst1[0] % 2 != 0)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0)\n            return \"NO\";\n        \n        if(lst2[i] % 2 != 0)\n            return \"NO\";\n        \n        if(lst1[i] == lst2[i])\n            return \"NO\";\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpkkk3_f3m.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x4287fd]\n??:? void tmpkkk3_f3m.__unittest_L47_C1() [0x42804a]\n??:? void tmpkkk3_f3m.__modtest() [0x42857c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c803]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b712]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430829]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430cd8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b6e9]\n??:? runModuleUnitTests [0x42c5d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cc0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0)\n        {\n            for(int j = 0; j < lst2.length; j++)\n            {\n                if(lst2[j] % 2 == 0)\n                {\n                    long temp = lst1[i];\n                    lst1[i] = lst2[j];\n                    lst2[j] = temp;\n                    return \"YES\";\n                }\n            }\n        }\n    }\n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpmr6fmae1.d(47): unittest failure\n----------------\n??:? _d_unittestp [0x42879d]\n??:? void tmpmr6fmae1.__unittest_L42_C1() [0x4280c9]\n??:? void tmpmr6fmae1.__modtest() [0x428520]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c7a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b6b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4307c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c78]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430755]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b689]\n??:? runModuleUnitTests [0x42c579]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428c60]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n        \n        if(lst1[i] % 2 == 0 && lst2[i] % 2 != 0)\n        {\n            long temp = lst1[i];\n            lst1[i] = lst2[i];\n            lst2[i] = temp;\n        }\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpq8b3zcri.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x428825]\n??:? void tmpq8b3zcri.__unittest_L39_C1() [0x428072]\n??:? void tmpq8b3zcri.__modtest() [0x4285a4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c82b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b73a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d00]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b711]\n??:? runModuleUnitTests [0x42c601]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428ce8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0)\n            return \"NO\";\n        \n        if (lst2[i] % 2 != 0)\n            return \"NO\";\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_u_769xa.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x428705]\n??:? void tmp_u_769xa.__unittest_L35_C1() [0x427f56]\n??:? void tmp_u_769xa.__modtest() [0x428488]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c70b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430731]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430be0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306bd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c4e1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428bc8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    int i, j;\n    for (i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0)\n            continue;\n        for (j = 0; j < lst2.length; j++)\n        {\n            if (lst2[j] % 2 != 0)\n                continue;\n            if (lst1[i] == lst2[j])\n            {\n                long temp = lst1[i];\n                lst1[i] = lst2[j];\n                lst2[j] = temp;\n                return \"YES\";\n            }\n        }\n    }\n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmps_l8lt4g.d(49): unittest failure\n----------------\n??:? _d_unittestp [0x42880d]\n??:? void tmps_l8lt4g.__unittest_L44_C1() [0x428135]\n??:? void tmps_l8lt4g.__modtest() [0x42858c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c813]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b722]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430839]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ce8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307c5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b6f9]\n??:? runModuleUnitTests [0x42c5e9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cd0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    int i = 0;\n    while(i < lst1.length)\n    {\n        if(lst1[i] % 2 != 0)\n        {\n            if(lst2[i] % 2 != 0)\n                return \"NO\";\n            else\n                lst2[i] = lst2[i] + lst1[i];\n        }\n        else\n        {\n            if(lst2[i] % 2 != 0)\n                lst2[i] = lst2[i] - lst1[i];\n            else\n                lst1[i] = lst1[i] + lst2[i];\n        }\n        i++;\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcts7c5lx.d(48): unittest failure\n----------------\n??:? _d_unittestp [0x4288e5]\n??:? void tmpcts7c5lx.__unittest_L44_C1() [0x428136]\n??:? void tmpcts7c5lx.__modtest() [0x428668]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8eb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7fa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430911]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430dc0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43089d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7d1]\n??:? runModuleUnitTests [0x42c6c1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428da8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0 || lst2[i] % 2 != 0)\n            return \"NO\";\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmprph94tgl.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x4286fd]\n??:? void tmprph94tgl.__unittest_L31_C1() [0x427f4a]\n??:? void tmprph94tgl.__modtest() [0x42847c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c703]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430729]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c4d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428bc0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n        \n        if(lst1[i] % 2 == 0 && lst2[i] % 2 != 0)\n        {\n            lst1[i] = lst1[i] + lst2[i];\n            lst2[i] = lst1[i] - lst2[i];\n            lst1[i] = lst1[i] - lst2[i];\n        }\n        \n        if(lst1[i] % 2 != 0 && lst2[i] % 2 == 0)\n        {\n            lst1[i] = lst1[i] + lst2[i];\n            lst2[i] = lst1[i] - lst2[i];\n            lst1[i] = lst1[i] - lst2[i];\n        }\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcyr_s98j.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x428a9d]\n??:? void tmpcyr_s98j.__unittest_L46_C1() [0x4282ea]\n??:? void tmpcyr_s98j.__modtest() [0x42881c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42caa3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ac9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f78]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a55]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b989]\n??:? runModuleUnitTests [0x42c879]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f60]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    long[] even = new long[lst1.length];\n    long[] odd = new long[lst1.length];\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 == 0)\n            even[i] = lst1[i];\n        else\n            odd[i] = lst1[i];\n    }\n    \n    for(int i = 0; i < lst2.length; i++)\n    {\n        if(lst2[i] % 2 == 0)\n            even[i] = lst2[i];\n        else\n            odd[i] = lst2[i];\n    }\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(even[i] != odd[i])\n            return \"NO\";\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmppuz3vbur.d(55): unittest failure\n----------------\n??:? _d_unittestp [0x42894d]\n??:? void tmppuz3vbur.__unittest_L51_C1() [0x42819e]\n??:? void tmppuz3vbur.__modtest() [0x4286d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9af]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8be]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430acd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f7c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a59]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b895]\n??:? runModuleUnitTests [0x42c785]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e10]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp3o2um0j1.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4286fd]\n??:? void tmp3o2um0j1.__unittest_L32_C1() [0x427f4a]\n??:? void tmp3o2um0j1.__modtest() [0x42847c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c703]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430729]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c4d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428bc0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0)\n        {\n            if (lst2[i] % 2 != 0)\n                return \"NO\";\n            else\n            {\n                lst1[i] = lst1[i] + lst2[i];\n                lst2[i] = lst1[i] - lst2[i];\n                lst1[i] = lst1[i] - lst2[i];\n            }\n        }\n    }\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0)\n            return \"NO\";\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpajae5dnx.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x42888d]\n??:? void tmpajae5dnx.__unittest_L47_C1() [0x4280da]\n??:? void tmpajae5dnx.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c893]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430845]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b779]\n??:? runModuleUnitTests [0x42c669]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d50]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    int i = 0;\n    int j = 0;\n    int count = 0;\n    \n    while (i < lst1.length && j < lst2.length)\n    {\n        if (lst1[i] % 2 == 0 && lst2[j] % 2 == 0)\n        {\n            count++;\n            if (count == lst1.length)\n                return \"YES\";\n        }\n        else if (lst1[i] % 2 != 0 && lst2[j] % 2 != 0)\n        {\n            count++;\n            if (count == lst1.length)\n                return \"YES\";\n        }\n        \n        if (lst1[i] % 2 != 0)\n            i++;\n        if (lst2[j] % 2 != 0)\n            j++;\n    }\n    \n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp9_t4tmba.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x42882d]\n??:? void tmp9_t4tmba.__unittest_L51_C1() [0x428159]\n??:? void tmp9_t4tmba.__modtest() [0x4285b0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c833]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b742]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430859]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d08]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307e5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b719]\n??:? runModuleUnitTests [0x42c609]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    int i = 0;\n    int j = 0;\n    \n    while(i < lst1.length && j < lst2.length)\n    {\n        if(lst1[i] % 2 == 0 && lst2[j] % 2 != 0)\n        {\n            long temp = lst1[i];\n            lst1[i] = lst2[j];\n            lst2[j] = temp;\n            return \"YES\";\n        }\n        \n        if(lst1[i] % 2 != 0 && lst2[j] % 2 == 0)\n        {\n            long temp = lst1[i];\n            lst1[i] = lst2[j];\n            lst2[j] = temp;\n            return \"YES\";\n        }\n        \n        i++;\n        j++;\n    }\n    \n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpd1d2yu32.d(55): unittest failure\n----------------\n??:? _d_unittestp [0x4288dd]\n??:? void tmpd1d2yu32.__unittest_L51_C1() [0x42812e]\n??:? void tmpd1d2yu32.__modtest() [0x428660]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8e3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7f2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430909]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430db8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430895]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7c9]\n??:? runModuleUnitTests [0x42c6b9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428da0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0)\n        {\n            for(int j = 0; j < lst2.length; j++)\n            {\n                if(lst2[j] % 2 == 0)\n                {\n                    long temp = lst1[i];\n                    lst1[i] = lst2[j];\n                    lst2[j] = temp;\n                    return \"YES\";\n                }\n            }\n        }\n    }\n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp92gm648b.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x4287c5]\n??:? void tmp92gm648b.__unittest_L45_C1() [0x4280ed]\n??:? void tmp92gm648b.__modtest() [0x428544]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c7cb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b6da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4307f1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ca0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43077d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b6b1]\n??:? runModuleUnitTests [0x42c5a1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428c88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0 || lst2[i] % 2 != 0)\n            return \"NO\";\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpczzfg5lc.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4286fd]\n??:? void tmpczzfg5lc.__unittest_L32_C1() [0x427f4a]\n??:? void tmpczzfg5lc.__modtest() [0x42847c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c703]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430729]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c4d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428bc0]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope void delegate",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n        if (lst1[i] % 2 != 0)\n            return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n        if (lst1[i] % 2 != 0)\n            return \"NO\";\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp1dr1novk.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x42870d]\n??:? void tmp1dr1novk.__unittest_L34_C1() [0x427f5e]\n??:? void tmp1dr1novk.__modtest() [0x428490]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c713]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b622]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430739]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430be8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306c5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f9]\n??:? runModuleUnitTests [0x42c4e9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428bd0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    if (lst1.length == 1 || lst2.length == 1)\n        return \"YES\";\n    \n    if (lst1.length == 2 && lst2.length == 2)\n    {\n        if (lst1[0] % 2 == 0 && lst2[0] % 2 == 0)\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    \n    if (lst1.length == 2 && lst2.length == 3)\n    {\n        if (lst1[0] % 2 == 0 && lst2[0] % 2 == 0 && lst2[1] % 2 == 0)\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    \n    if (lst1.length == 3 && lst2.length == 2)\n    {\n        if (lst1[0] % 2 == 0 && lst2[0] % 2 == 0 && lst2[1] % 2 == 0)\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    \n    if (lst1.length == 3 && lst2.length == 3)\n    {\n        if (lst1[0] % 2 == 0 && lst2[0] % 2 == 0 && lst2[1] % 2 == 0 && lst2[2] % 2 == 0)\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    \n    if (lst1.length == 4 && lst2.length == 4)\n    {\n        if (lst1[0] % 2 == 0 && lst2[0] % 2 == 0 && lst2[1] % 2 == 0 && lst2[2] % 2 == 0 && lst2[3] % 2 == 0)\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    \n    if (lst1.length == 4 && lst2.length == 5)\n    {\n        if (lst1[0]\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "/tmp/tmpn2gv3ucz.d(70): Error: found `unittest` when expecting `)`\n/tmp/tmpn2gv3ucz.d(82): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpn2gv3ucz.d(82): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn2gv3ucz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    int i = 0;\n    while(i < lst1.length)\n    {\n        if(lst1[i] % 2 != 0)\n        {\n            if(lst2[i] % 2 != 0)\n                return \"NO\";\n            else\n                lst2[i] = lst2[i] + lst1[i];\n        }\n        else\n        {\n            if(lst2[i] % 2 != 0)\n                lst2[i] = lst2[i] - lst1[i];\n            else\n                lst1[i] = lst1[i] + lst2[i];\n        }\n        i++;\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp81b0regs.d(49): unittest failure\n----------------\n??:? _d_unittestp [0x4288e5]\n??:? void tmp81b0regs.__unittest_L45_C1() [0x428136]\n??:? void tmp81b0regs.__modtest() [0x428668]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8eb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7fa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430911]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430dc0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43089d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7d1]\n??:? runModuleUnitTests [0x42c6c1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428da8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    int i = 0;\n    int j = 0;\n    \n    while(i < lst1.length && j < lst2.length)\n    {\n        if(lst1[i] % 2 == 0 && lst2[j] % 2 == 0)\n        {\n            if(lst1[i] != lst2[j])\n            {\n                lst1[i] = lst1[i] + lst2[j];\n                lst2[j] = lst1[i] - lst2[j];\n                lst1[i] = lst1[i] - lst2[j];\n            }\n            \n            i++;\n            j++;\n        }\n        else if(lst1[i] % 2 != 0 && lst2[j] % 2 != 0)\n        {\n            if(lst1[i] != lst2[j])\n            {\n                lst1[i] = lst1[i] + lst2[j];\n                lst2[j] = lst1[i] - lst2[j];\n                lst1[i] = lst1[i] - lst2[j];\n            }\n            \n            i++;\n            j++;\n        }\n        else if(lst1[i] % 2 != 0 && lst2[j] % 2 == 0)\n        {\n            if(lst1[i] != lst2[j])\n            {\n                lst1[i] = lst1[i] + lst2[j];\n                lst2[j] = lst1[i] - lst2[j];\n                lst1[i] = lst1[i] - lst2[j];\n            }\n            \n            i++;\n            j++;\n        }\n        else if(lst1[i] % 2 == 0 && lst2[j] % 2 !=\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "/tmp/tmp9gxl3rwx.d(69): Error: expression expected, not `unittest`\n/tmp/tmp9gxl3rwx.d(70): Error: found `{` when expecting `)`\n/tmp/tmp9gxl3rwx.d(81): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9gxl3rwx.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpnwpt6jhe.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4286fd]\n??:? void tmpnwpt6jhe.__unittest_L32_C1() [0x427f4a]\n??:? void tmpnwpt6jhe.__modtest() [0x42847c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c703]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430729]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c4d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428bc0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0)\n        {\n            if(lst2[i] % 2 != 0)\n            {\n                if(lst1[i] != lst2[i])\n                    return \"NO\";\n            }\n            else\n                return \"NO\";\n        }\n        else\n        {\n            if(lst2[i] % 2 != 0)\n                return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp0ou6_g7l.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x4287b5]\n??:? void tmp0ou6_g7l.__unittest_L44_C1() [0x4281a3]\n??:? void tmp0ou6_g7l.__modtest() [0x428538]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c7bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b6ca]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4307e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c90]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43076d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b6a1]\n??:? runModuleUnitTests [0x42c591]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428c78]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0)\n        {\n            if(lst2[i] % 2 != 0)\n                return \"NO\";\n            else\n                lst2[i] = lst2[i] + lst1[i];\n        }\n        else\n        {\n            if(lst2[i] % 2 != 0)\n                lst2[i] = lst2[i] - lst1[i];\n            else\n                lst1[i] = lst1[i] + lst2[i];\n        }\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmppld8albr.d(48): unittest failure\n----------------\n??:? _d_unittestp [0x4288e5]\n??:? void tmppld8albr.__unittest_L44_C1() [0x428136]\n??:? void tmppld8albr.__modtest() [0x428668]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8eb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7fa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430911]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430dc0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43089d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7d1]\n??:? runModuleUnitTests [0x42c6c1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428da8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp3o2um0j1.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4286fd]\n??:? void tmp3o2um0j1.__unittest_L32_C1() [0x427f4a]\n??:? void tmp3o2um0j1.__modtest() [0x42847c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c703]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430729]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c4d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428bc0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n        if(lst1[i] % 2 == 0 && lst2[i] % 2 != 0)\n        {\n            lst2[i] = lst2[i] + lst1[i];\n            lst1[i] = lst1[i] + lst2[i];\n            lst2[i] = lst2[i] - lst1[i];\n            lst1[i] = lst1[i] - lst2[i];\n        }\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp0jaylngp.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x428905]\n??:? void tmp0jaylngp.__unittest_L38_C1() [0x428152]\n??:? void tmp0jaylngp.__modtest() [0x428684]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c90b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b81a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430931]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430de0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4308bd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7f1]\n??:? runModuleUnitTests [0x42c6e1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428dc8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < lst1.length && j < lst2.length)\n    {\n        if (lst1[i] % 2 == 0 && lst2[j] % 2 == 0)\n        {\n            count++;\n            if (count == lst1.length)\n                return \"YES\";\n        }\n        else if (lst1[i] % 2 != 0 && lst2[j] % 2 != 0)\n        {\n            count++;\n            if (count == lst1.length)\n                return \"YES\";\n        }\n        else if (lst1[i] % 2 == 0 && lst2[j] % 2 != 0)\n        {\n            count++;\n            if (count == lst1.length)\n                return \"YES\";\n        }\n        else if (lst1[i] % 2 != 0 && lst2[j] % 2 == 0)\n        {\n            count++;\n            if (count == lst1.length)\n                return \"YES\";\n        }\n        i++;\n        j++;\n    }\n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp9air_h7y.d(63): unittest failure\n----------------\n??:? _d_unittestp [0x4288e5]\n??:? void tmp9air_h7y.__unittest_L58_C1() [0x42820d]\n??:? void tmp9air_h7y.__modtest() [0x428664]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8eb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7fa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430911]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430dc0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43089d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7d1]\n??:? runModuleUnitTests [0x42c6c1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428da8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    int i = 0;\n    int j = 0;\n    \n    while (i < lst1.length && j < lst2.length)\n    {\n        if (lst1[i] % 2 == 0 && lst2[j] % 2 == 0)\n        {\n            if (lst1[i] == lst2[j])\n            {\n                i++;\n                j++;\n            }\n            else\n            {\n                if (lst1[i] < lst2[j])\n                {\n                    i++;\n                }\n                else\n                {\n                    j++;\n                }\n            }\n        }\n        else if (lst1[i] % 2 == 0)\n        {\n            i++;\n        }\n        else if (lst2[j] % 2 == 0)\n        {\n            j++;\n        }\n        else\n        {\n            if (lst1[i] < lst2[j])\n            {\n                i++;\n            }\n            else\n            {\n                j++;\n            }\n        }\n    }\n    \n    if (i == lst1.length && j == lst2.length)\n        return \"YES\";\n    else\n        return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp7glvfjsw.d(78): unittest failure\n----------------\n??:? _d_unittestp [0x4288c5]\n??:? void tmp7glvfjsw.__unittest_L74_C1() [0x428116]\n??:? void tmp7glvfjsw.__modtest() [0x428648]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8cb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308f1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430da0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43087d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c6a1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp3o2um0j1.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4286fd]\n??:? void tmp3o2um0j1.__unittest_L32_C1() [0x427f4a]\n??:? void tmp3o2um0j1.__modtest() [0x42847c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c703]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430729]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c4d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428bc0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    if (lst1.length == 1 || lst2.length == 1)\n        return \"YES\";\n    if (lst1.length == 2 && lst2.length == 2)\n        return \"YES\";\n    if (lst1.length == 2 && lst2.length == 3)\n        return \"YES\";\n    if (lst1.length == 3 && lst2.length == 3)\n        return \"YES\";\n    if (lst1.length == 3 && lst2.length == 4)\n        return \"YES\";\n    if (lst1.length == 4 && lst2.length == 4)\n        return \"YES\";\n    if (lst1.length == 4 && lst2.length == 5)\n        return \"YES\";\n    if (lst1.length == 5 && lst2.length == 5)\n        return \"YES\";\n    if (lst1.length == 5 && lst2.length == 6)\n        return \"YES\";\n    if (lst1.length == 6 && lst2.length == 6)\n        return \"YES\";\n    if (lst1.length == 6 && lst2.length == 7)\n        return \"YES\";\n    if (lst1.length == 7 && lst2.length == 7)\n        return \"YES\";\n    if (lst1.length == 7 && lst2.length == 8)\n        return \"YES\";\n    if (lst1.length == 8 && lst2.length == 8)\n        return \"YES\";\n    if (lst1.length == 8 && lst2.length == 9)\n        return \"YES\";\n    if (lst1.length == 9 && lst2.length == 9)\n        return \"YES\";\n    if (lst1.length == 9 && lst2.length == 10)\n        return \"YES\";\n    if (lst1.length == 10 && lst2.length == 10)\n        return \"YES\";\n    if (lst1.length == 10 && lst2.length\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "/tmp/tmpd0thdvsp.d(60): Error: found `unittest` when expecting `)`\n/tmp/tmpd0thdvsp.d(72): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd0thdvsp.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    if(lst1.length == 1 || lst2.length == 1)\n        return \"YES\";\n    if(lst1.length == 2 && lst2.length == 2)\n        return \"YES\";\n    if(lst1.length == 2 && lst2.length == 3)\n        return \"YES\";\n    if(lst1.length == 3 && lst2.length == 3)\n        return \"YES\";\n    if(lst1.length == 3 && lst2.length == 4)\n        return \"YES\";\n    if(lst1.length == 4 && lst2.length == 4)\n        return \"YES\";\n    if(lst1.length == 4 && lst2.length == 5)\n        return \"YES\";\n    if(lst1.length == 5 && lst2.length == 5)\n        return \"YES\";\n    if(lst1.length == 5 && lst2.length == 6)\n        return \"YES\";\n    if(lst1.length == 6 && lst2.length == 6)\n        return \"YES\";\n    if(lst1.length == 6 && lst2.length == 7)\n        return \"YES\";\n    if(lst1.length == 7 && lst2.length == 7)\n        return \"YES\";\n    if(lst1.length == 7 && lst2.length == 8)\n        return \"YES\";\n    if(lst1.length == 8 && lst2.length == 8)\n        return \"YES\";\n    if(lst1.length == 8 && lst2.length == 9)\n        return \"YES\";\n    if(lst1.length == 9 && lst2.length == 9)\n        return \"YES\";\n    if(lst1.length == 9 && lst2.length == 10)\n        return \"YES\";\n    if(lst1.length == 10 && lst2.length == 10)\n        return \"YES\";\n    if(lst1.length == 10 && lst2.length\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "/tmp/tmpmt2cnn7o.d(60): Error: found `unittest` when expecting `)`\n/tmp/tmpmt2cnn7o.d(72): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmt2cnn7o.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    int i = 0;\n    int j = 0;\n    \n    while(i < lst1.length && j < lst2.length)\n    {\n        if(lst1[i] % 2 == 0 && lst2[j] % 2 == 0)\n        {\n            if(lst1[i] == lst2[j])\n            {\n                i++;\n                j++;\n            }\n            else\n            {\n                long temp = lst1[i];\n                lst1[i] = lst2[j];\n                lst2[j] = temp;\n                i++;\n                j++;\n            }\n        }\n        else if(lst1[i] % 2 == 0 && lst2[j] % 2 != 0)\n        {\n            i++;\n        }\n        else if(lst1[i] % 2 != 0 && lst2[j] % 2 == 0)\n        {\n            j++;\n        }\n        else\n        {\n            i++;\n            j++;\n        }\n    }\n    \n    if(i == lst1.length && j == lst2.length)\n        return \"YES\";\n    else\n        return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpkafdkw08.d(71): unittest failure\n----------------\n??:? _d_unittestp [0x428925]\n??:? void tmpkafdkw08.__unittest_L65_C1() [0x428313]\n??:? void tmpkafdkw08.__modtest() [0x4286a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c92b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b83a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430951]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430e00]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4308dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b811]\n??:? runModuleUnitTests [0x42c701]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428de8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length == 1)\n        return \"YES\";\n    if(lst2.length == 1)\n        return \"NO\";\n    if(lst1.length == 2 && lst2.length == 2)\n    {\n        if(lst1[0] == lst2[0] && lst1[1] == lst2[1])\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    if(lst1.length == 2 && lst2.length == 3)\n    {\n        if(lst1[0] == lst2[0] && lst1[1] == lst2[1] && lst1[2] == lst2[2])\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    if(lst1.length == 3 && lst2.length == 3)\n    {\n        if(lst1[0] == lst2[0] && lst1[1] == lst2[1] && lst1[2] == lst2[2])\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    if(lst1.length == 3 && lst2.length == 4)\n    {\n        if(lst1[0] == lst2[0] && lst1[1] == lst2[1] && lst1[2] == lst2[2] && lst1[3] == lst2[3])\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    if(lst1.length == 4 && lst2.length == 4)\n    {\n        if(lst1[0] == lst2[0] && lst1[1] == lst2[1] && lst1[2] == lst2[2] && lst1[3] == lst2[3])\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    if(lst1.length == 4 && lst2.length == 5)\n    {\n        if(lst1[\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "/tmp/tmp__i0rgnk.d(63): Error: expression expected, not `unittest`\n/tmp/tmp__i0rgnk.d(64): Error: found `{` when expecting `,`\n/tmp/tmp__i0rgnk.d(65): Error: expression expected, not `alias`\n/tmp/tmp__i0rgnk.d(65): Error: found `candidate` when expecting `,`\n/tmp/tmp__i0rgnk.d(65): Error: expression expected, not `=`\n/tmp/tmp__i0rgnk.d(65): Error: found `exchange` when expecting `,`\n/tmp/tmp__i0rgnk.d(65): Error: expression expected, not `;`\n/tmp/tmp__i0rgnk.d(67): Error: found `assert` when expecting `,`\n/tmp/tmp__i0rgnk.d(67): Error: found `;` when expecting `,`\n/tmp/tmp__i0rgnk.d(68): Error: found `;` when expecting `,`\n/tmp/tmp__i0rgnk.d(69): Error: found `;` when expecting `,`\n/tmp/tmp__i0rgnk.d(70): Error: found `;` when expecting `,`\n/tmp/tmp__i0rgnk.d(71): Error: found `;` when expecting `,`\n/tmp/tmp__i0rgnk.d(72): Error: found `;` when expecting `,`\n/tmp/tmp__i0rgnk.d(73): Error: found `;` when expecting `,`\n/tmp/tmp__i0rgnk.d(74): Error: expression expected, not `}`\n/tmp/tmp__i0rgnk.d(75): Error: fo",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    int i = 0;\n    while (i < lst1.length)\n    {\n        if (lst1[i] % 2 != 0)\n        {\n            if (lst2[i] % 2 == 0)\n            {\n                long temp = lst1[i];\n                lst1[i] = lst2[i];\n                lst2[i] = temp;\n                return \"YES\";\n            }\n            else\n                return \"NO\";\n        }\n        i++;\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgr0ndbj5.d(47): unittest failure\n----------------\n??:? _d_unittestp [0x42879d]\n??:? void tmpgr0ndbj5.__unittest_L43_C1() [0x427fea]\n??:? void tmpgr0ndbj5.__modtest() [0x42851c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c7a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b6b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4307c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c78]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430755]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b689]\n??:? runModuleUnitTests [0x42c579]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428c60]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    if(lst1.length == 1 || lst2.length == 1)\n        return \"YES\";\n    \n    if(lst1.length == 2 && lst2.length == 2)\n    {\n        if(lst1[0] % 2 == 0 && lst2[0] % 2 == 0)\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    \n    if(lst1.length == 2 && lst2.length == 3)\n    {\n        if(lst1[0] % 2 == 0 && lst2[0] % 2 == 0 && lst2[1] % 2 == 0)\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    \n    if(lst1.length == 3 && lst2.length == 3)\n    {\n        if(lst1[0] % 2 == 0 && lst2[0] % 2 == 0 && lst2[1] % 2 == 0 && lst2[2] % 2 == 0)\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    \n    if(lst1.length == 3 && lst2.length == 4)\n    {\n        if(lst1[0] % 2 == 0 && lst2[0] % 2 == 0 && lst2[1] % 2 == 0 && lst2[2] % 2 == 0 && lst2[3] % 2 == 0)\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    \n    if(lst1.length == 4 && lst2.length == 4)\n    {\n        if(lst1[0] % 2 == 0 && lst2[0] % 2 == 0 && lst2[1] % 2 == 0 && lst2[2] % 2 == 0 && lst2[3] % 2 == 0)\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    \n    if(lst1.length == 4\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "/tmp/tmp9bna1c7t.d(68): Error: found `unittest` when expecting `)`\n/tmp/tmp9bna1c7t.d(80): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9bna1c7t.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    if (lst1.length == 1 || lst2.length == 1)\n        return \"YES\";\n    if (lst1.length == 2 && lst2.length == 2)\n        return \"YES\";\n    if (lst1.length == 2 && lst2.length == 3)\n        return \"YES\";\n    if (lst1.length == 3 && lst2.length == 3)\n        return \"YES\";\n    if (lst1.length == 3 && lst2.length == 4)\n        return \"YES\";\n    if (lst1.length == 4 && lst2.length == 4)\n        return \"YES\";\n    if (lst1.length == 4 && lst2.length == 5)\n        return \"YES\";\n    if (lst1.length == 5 && lst2.length == 5)\n        return \"YES\";\n    if (lst1.length == 5 && lst2.length == 6)\n        return \"YES\";\n    if (lst1.length == 6 && lst2.length == 6)\n        return \"YES\";\n    if (lst1.length == 6 && lst2.length == 7)\n        return \"YES\";\n    if (lst1.length == 7 && lst2.length == 7)\n        return \"YES\";\n    if (lst1.length == 7 && lst2.length == 8)\n        return \"YES\";\n    if (lst1.length == 8 && lst2.length == 8)\n        return \"YES\";\n    if (lst1.length == 8 && lst2.length == 9)\n        return \"YES\";\n    if (lst1.length == 9 && lst2.length == 9)\n        return \"YES\";\n    if (lst1.length == 9 && lst2.length == 10)\n        return \"YES\";\n    if (lst1.length == 10 && lst2.length == 10)\n        return \"YES\";\n    if (lst1.length == 10 && lst2.length\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "/tmp/tmpd0thdvsp.d(60): Error: found `unittest` when expecting `)`\n/tmp/tmpd0thdvsp.d(72): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd0thdvsp.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    if(lst1.length == 1 || lst2.length == 1)\n        return \"YES\";\n    if(lst1[0] % 2 != 0 || lst2[0] % 2 != 0)\n        return \"NO\";\n    for(int i = 1; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0 || lst2[i] % 2 != 0)\n            return \"NO\";\n        if(lst1[i] == lst2[i])\n            return \"NO\";\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpoli_xbby.d(40): unittest failure\n----------------\n??:? _d_unittestp [0x42880d]\n??:? void tmpoli_xbby.__unittest_L36_C1() [0x42805e]\n??:? void tmpoli_xbby.__modtest() [0x428590]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c813]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b722]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430839]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ce8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307c5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b6f9]\n??:? runModuleUnitTests [0x42c5e9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cd0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    if(lst1.length == 1 || lst2.length == 1)\n        return \"YES\";\n    \n    if(lst1.length == 2 && lst2.length == 2)\n    {\n        if(lst1[0] % 2 == 0 && lst1[1] % 2 == 0 && lst2[0] % 2 == 0 && lst2[1] % 2 == 0)\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    \n    if(lst1.length == 2 && lst2.length == 3)\n    {\n        if(lst1[0] % 2 == 0 && lst1[1] % 2 == 0 && lst2[0] % 2 == 0 && lst2[1] % 2 == 0 && lst2[2] % 2 == 0)\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    \n    if(lst1.length == 3 && lst2.length == 3)\n    {\n        if(lst1[0] % 2 == 0 && lst1[1] % 2 == 0 && lst1[2] % 2 == 0 && lst2[0] % 2 == 0 && lst2[1] % 2 == 0 && lst2[2] % 2 == 0)\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    \n    if(lst1.length == 3 && lst2.length == 4)\n    {\n        if(lst1[0] % 2 == 0 && lst1[1] % 2 == 0 && lst1[2] % 2 == 0 && lst2[0] % 2 == 0 && lst2[1] % 2 == 0 && lst2[2] % 2 == 0 && lst2[3] % 2 == 0)\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    \n    if(lst1.length == 4 && lst2.length == 4)\n    {\n        \nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "/tmp/tmpi09ha347.d(62): Error: found `unittest` instead of statement\n/tmp/tmpi09ha347.d(74): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi09ha347.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    int i = 0;\n    int j = 0;\n    while (i < lst1.length && j < lst2.length)\n    {\n        if (lst1[i] % 2 == 0 && lst2[j] % 2 != 0)\n        {\n            long temp = lst1[i];\n            lst1[i] = lst2[j];\n            lst2[j] = temp;\n            return \"YES\";\n        }\n        else if (lst1[i] % 2 != 0 && lst2[j] % 2 == 0)\n        {\n            long temp = lst1[i];\n            lst1[i] = lst2[j];\n            lst2[j] = temp;\n            return \"YES\";\n        }\n        i++;\n        j++;\n    }\n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpdpfjqdhf.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x4288dd]\n??:? void tmpdpfjqdhf.__unittest_L47_C1() [0x42812e]\n??:? void tmpdpfjqdhf.__modtest() [0x428660]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8e3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7f2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430909]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430db8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430895]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7c9]\n??:? runModuleUnitTests [0x42c6b9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428da0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    if(lst1.length == 1)\n        return \"YES\";\n    if(lst1.length == 2)\n    {\n        if(lst1[0] == lst2[0] || lst1[0] == lst2[1])\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    if(lst1[0] == lst2[0])\n        return \"YES\";\n    if(lst1[0] == lst2[1])\n        return \"YES\";\n    if(lst1[1] == lst2[0])\n        return \"YES\";\n    if(lst1[1] == lst2[1])\n        return \"YES\";\n    if(lst1[2] == lst2[0])\n        return \"YES\";\n    if(lst1[2] == lst2[1])\n        return \"YES\";\n    if(lst1[0] == lst2[2])\n        return \"YES\";\n    if(lst1[1] == lst2[2])\n        return \"YES\";\n    if(lst1[2] == lst2[2])\n        return \"YES\";\n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpshsh9hnn.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x428a85]\n??:? void tmpshsh9hnn.__unittest_L52_C1() [0x4283b1]\n??:? void tmpshsh9hnn.__modtest() [0x428808]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b99a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b971]\n??:? runModuleUnitTests [0x42c861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f48]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    int i = 0;\n    int j = 0;\n    \n    while(i < lst1.length && j < lst2.length)\n    {\n        if(lst1[i] % 2 == 0 && lst2[j] % 2 == 0)\n        {\n            if(lst1[i] == lst2[j])\n            {\n                i++;\n                j++;\n            }\n            else\n            {\n                if(lst1[i] > lst2[j])\n                {\n                    i++;\n                }\n                else\n                {\n                    j++;\n                }\n            }\n        }\n        else if(lst1[i] % 2 == 0 && lst2[j] % 2 != 0)\n        {\n            if(lst1[i] == lst2[j])\n            {\n                i++;\n                j++;\n            }\n            else\n            {\n                if(lst1[i] > lst2[j])\n                {\n                    i++;\n                }\n                else\n                {\n                    j++;\n                }\n            }\n        }\n        else if(lst1[i] % 2 != 0 && lst2[j] % 2 == 0)\n        {\n            if(lst1[i] == lst2[j])\n            {\n                i++;\n                j++;\n            }\n            else\n            {\n                if(lst1[i] > lst2[j])\n                {\n                    i++;\n                }\n                else\n                {\n                    j++;\n                }\n            }\n        }\n        else\n        {\n            if(lst1[i] == lst2[j])\n            {\n                i++;\n                j++;\n            }\n            else\n            {\n                if(lst1[i] > lst2[j])\n                {\n                    i++;\n                }\n                else\n                {\n                    j++;\n                }\n            }\n        }\n    }\n    \n    if(i == lst1.length &&\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "/tmp/tmpk4gfm4ol.d(108): Error: expression expected, not `unittest`\n/tmp/tmpk4gfm4ol.d(109): Error: found `{` when expecting `)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk4gfm4ol.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n        \n        if(lst1[i] % 2 == 0 && lst2[i] % 2 != 0)\n        {\n            lst1[i] = lst1[i] + lst2[i];\n            lst2[i] = lst1[i] - lst2[i];\n            lst1[i] = lst1[i] - lst2[i];\n        }\n        \n        if(lst1[i] % 2 != 0 && lst2[i] % 2 == 0)\n        {\n            lst1[i] = lst1[i] + lst2[i];\n            lst2[i] = lst1[i] - lst2[i];\n            lst1[i] = lst1[i] - lst2[i];\n        }\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcyr_s98j.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x428a9d]\n??:? void tmpcyr_s98j.__unittest_L46_C1() [0x4282ea]\n??:? void tmpcyr_s98j.__modtest() [0x42881c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42caa3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ac9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f78]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a55]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b989]\n??:? runModuleUnitTests [0x42c879]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f60]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    int i = 0;\n    while (i < lst1.length)\n    {\n        if (lst1[i] % 2 != 0)\n        {\n            if (lst2[i] % 2 != 0)\n                return \"NO\";\n            else\n                lst2[i] = lst2[i] + lst1[i];\n        }\n        else\n        {\n            if (lst2[i] % 2 != 0)\n                lst2[i] = lst2[i] - lst1[i];\n            else\n                lst1[i] = lst1[i] + lst2[i];\n        }\n        i++;\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpjeihhxcb.d(49): unittest failure\n----------------\n??:? _d_unittestp [0x4288e5]\n??:? void tmpjeihhxcb.__unittest_L45_C1() [0x428136]\n??:? void tmpjeihhxcb.__modtest() [0x428668]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8eb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7fa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430911]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430dc0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43089d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7d1]\n??:? runModuleUnitTests [0x42c6c1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428da8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpnwpt6jhe.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4286fd]\n??:? void tmpnwpt6jhe.__unittest_L32_C1() [0x427f4a]\n??:? void tmpnwpt6jhe.__modtest() [0x42847c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c703]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430729]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c4d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428bc0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n        \n        if(lst1[i] % 2 == 0 && lst2[i] % 2 == 0)\n            continue;\n        \n        if(lst1[i] % 2 == 0)\n            lst1[i] = lst1[i] + lst2[i];\n        else\n            lst2[i] = lst1[i] + lst2[i];\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp1znl_ovd.d(44): unittest failure\n----------------\n??:? _d_unittestp [0x4288a5]\n??:? void tmp1znl_ovd.__unittest_L40_C1() [0x4280f6]\n??:? void tmp1znl_ovd.__modtest() [0x428628]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7ba]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308d1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d80]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43085d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b791]\n??:? runModuleUnitTests [0x42c681]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d68]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    int i, j;\n    for(i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0)\n            break;\n    }\n    \n    if(i == lst1.length)\n        return \"YES\";\n    \n    for(j = 0; j < lst2.length; j++)\n    {\n        if(lst2[j] % 2 != 0)\n            break;\n    }\n    \n    if(j == lst2.length)\n        return \"YES\";\n    \n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpw2yw1n6p.d(49): unittest failure\n----------------\n??:? _d_unittestp [0x42872d]\n??:? void tmpw2yw1n6p.__unittest_L45_C1() [0x427f7e]\n??:? void tmpw2yw1n6p.__modtest() [0x4284b0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c733]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b642]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430759]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c08]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306e5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b619]\n??:? runModuleUnitTests [0x42c509]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428bf0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0)\n        {\n            for (int j = 0; j < lst2.length; j++)\n            {\n                if (lst2[j] % 2 == 0)\n                {\n                    long temp = lst1[i];\n                    lst1[i] = lst2[j];\n                    lst2[j] = temp;\n                    return \"YES\";\n                }\n            }\n        }\n    }\n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp8jxoorck.d(47): unittest failure\n----------------\n??:? _d_unittestp [0x4287a5]\n??:? void tmp8jxoorck.__unittest_L42_C1() [0x4280d1]\n??:? void tmp8jxoorck.__modtest() [0x428528]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c7ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b6ba]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4307d1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c80]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43075d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b691]\n??:? runModuleUnitTests [0x42c581]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428c68]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope void delegate",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0 || lst2[i] % 2 != 0)\n            return \"NO\";\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpczzfg5lc.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4286fd]\n??:? void tmpczzfg5lc.__unittest_L32_C1() [0x427f4a]\n??:? void tmpczzfg5lc.__modtest() [0x42847c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c703]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430729]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c4d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428bc0]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope void delegate",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n        \n        if(lst1[i] % 2 == 0 && lst2[i] % 2 != 0)\n        {\n            lst2[i] = lst2[i] + lst1[i];\n            lst1[i] = lst2[i] - lst1[i];\n            lst2[i] = lst2[i] - lst1[i];\n            lst1[i] = lst2[i] + lst1[i];\n        }\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_4c8lmm1.d(44): unittest failure\n----------------\n??:? _d_unittestp [0x428905]\n??:? void tmp_4c8lmm1.__unittest_L40_C1() [0x428152]\n??:? void tmp_4c8lmm1.__modtest() [0x428684]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c90b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b81a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430931]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430de0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4308bd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7f1]\n??:? runModuleUnitTests [0x42c6e1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428dc8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n        \n        if(lst1[i] % 2 == 0 && lst2[i] % 2 == 0)\n            continue;\n        \n        if(lst1[i] % 2 == 0)\n        {\n            lst1[i] = lst1[i] + lst2[i];\n            lst2[i] = lst1[i] - lst2[i];\n            lst1[i] = lst1[i] - lst2[i];\n        }\n        else\n        {\n            lst1[i] = lst1[i] - lst2[i];\n            lst2[i] = lst1[i] + lst2[i];\n            lst1[i] = lst1[i] + lst2[i];\n        }\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292818,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpshhq9dg_.d(52): unittest failure\n----------------\n??:? _d_unittestp [0x428a2d]\n??:? void tmpshhq9dg_.__unittest_L48_C1() [0x42827a]\n??:? void tmpshhq9dg_.__modtest() [0x4287ac]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca33]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b942]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a59]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f08]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b919]\n??:? runModuleUnitTests [0x42c809]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428ef0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length == 1)\n        return \"YES\";\n    if(lst2.length == 1)\n        return \"NO\";\n    if(lst1.length == 2)\n    {\n        if(lst1[0] == lst2[0])\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    if(lst1.length == 3)\n    {\n        if(lst1[0] == lst2[0] || lst1[0] == lst2[1] || lst1[0] == lst2[2])\n            return \"YES\";\n        else if(lst1[1] == lst2[0] || lst1[1] == lst2[1] || lst1[1] == lst2[2])\n            return \"YES\";\n        else if(lst1[2] == lst2[0] || lst1[2] == lst2[1] || lst1[2] == lst2[2])\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    if(lst1.length == 4)\n    {\n        if(lst1[0] == lst2[0] || lst1[0] == lst2[1] || lst1[0] == lst2[2] || lst1[0] == lst2[3])\n            return \"YES\";\n        else if(lst1[1] == lst2[0] || lst1[1] == lst2[1] || lst1[1] == lst2[2] || lst1[1] == lst2[3])\n            return \"YES\";\n        else if(lst1[2] == lst2[0] || lst1[2] == lst2[1] || lst1[2] == lst2[2] || lst1[2] == lst2[3])\n            return \"YES\";\n        else if(lst1[3] == lst2[0] || lst1[3] == lst2[1\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "/tmp/tmpdxv73vdx.d(52): Error: found `unittest` when expecting `,`\n/tmp/tmpdxv73vdx.d(64): Error: found `void` when expecting `,`\n/tmp/tmpdxv73vdx.d(64): Error: found `{` when expecting `,`\n/tmp/tmpdxv73vdx.d(64): Error: expression expected, not `}`\n/tmp/tmpdxv73vdx.d(64): Error: found `End of File` when expecting `,`\n/tmp/tmpdxv73vdx.d(64): Error: found `End of File` when expecting `]`\n/tmp/tmpdxv73vdx.d(64): Error: found `End of File` when expecting `)`\n/tmp/tmpdxv73vdx.d(64): Error: found `End of File` instead of statement\n/tmp/tmpdxv73vdx.d(64): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpdxv73vdx.d(64): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdxv73vdx.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp3o2um0j1.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4286fd]\n??:? void tmp3o2um0j1.__unittest_L32_C1() [0x427f4a]\n??:? void tmp3o2um0j1.__modtest() [0x42847c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c703]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430729]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c4d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428bc0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0)\n        {\n            if (lst2[i] % 2 != 0)\n                return \"NO\";\n            else\n                lst2[i] = lst2[i] + lst1[i];\n        }\n        else\n        {\n            if (lst2[i] % 2 != 0)\n                lst2[i] = lst2[i] - lst1[i];\n            else\n                lst1[i] = lst1[i] + lst2[i];\n        }\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpx2gr0xqj.d(48): unittest failure\n----------------\n??:? _d_unittestp [0x4288e5]\n??:? void tmpx2gr0xqj.__unittest_L44_C1() [0x428136]\n??:? void tmpx2gr0xqj.__modtest() [0x428668]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8eb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7fa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430911]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430dc0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43089d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7d1]\n??:? runModuleUnitTests [0x42c6c1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428da8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    int i, j;\n    for (i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0)\n        {\n            for (j = 0; j < lst2.length; j++)\n            {\n                if (lst2[j] % 2 == 0)\n                {\n                    long temp = lst1[i];\n                    lst1[i] = lst2[j];\n                    lst2[j] = temp;\n                    return \"YES\";\n                }\n            }\n        }\n    }\n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292818,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpruulzghq.d(48): unittest failure\n----------------\n??:? _d_unittestp [0x4287a5]\n??:? void tmpruulzghq.__unittest_L43_C1() [0x4280cd]\n??:? void tmpruulzghq.__modtest() [0x428524]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c7ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b6ba]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4307d1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c80]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43075d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b691]\n??:? runModuleUnitTests [0x42c581]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428c68]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n        \n        if(lst1[i] % 2 == 0 && lst2[i] % 2 == 0)\n            continue;\n        \n        if(lst1[i] % 2 == 0)\n        {\n            lst1[i] = lst1[i] + lst2[i];\n            lst2[i] = lst1[i] - lst2[i];\n            lst1[i] = lst1[i] - lst2[i];\n        }\n        else\n        {\n            lst1[i] = lst1[i] - lst2[i];\n            lst2[i] = lst1[i] + lst2[i];\n            lst1[i] = lst1[i] + lst2[i];\n        }\n    }\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0)\n            return \"NO\";\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpopioxo76.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x428a8d]\n??:? void tmpopioxo76.__unittest_L54_C1() [0x4282de]\n??:? void tmpopioxo76.__modtest() [0x428810]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b979]\n??:? runModuleUnitTests [0x42c869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f50]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0)\n        {\n            for (int j = 0; j < lst2.length; j++)\n            {\n                if (lst2[j] % 2 == 0)\n                {\n                    long temp = lst1[i];\n                    lst1[i] = lst2[j];\n                    lst2[j] = temp;\n                    return \"YES\";\n                }\n            }\n        }\n    }\n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp8jxoorck.d(47): unittest failure\n----------------\n??:? _d_unittestp [0x4287a5]\n??:? void tmp8jxoorck.__unittest_L42_C1() [0x4280d1]\n??:? void tmp8jxoorck.__modtest() [0x428528]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c7ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b6ba]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4307d1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c80]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43075d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b691]\n??:? runModuleUnitTests [0x42c581]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428c68]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope void delegate",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0)\n        {\n            for (int j = 0; j < lst2.length; j++)\n            {\n                if (lst2[j] % 2 == 0)\n                {\n                    long temp = lst1[i];\n                    lst1[i] = lst2[j];\n                    lst2[j] = temp;\n                    return \"YES\";\n                }\n            }\n        }\n    }\n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292818,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp1_1co7l7.d(47): unittest failure\n----------------\n??:? _d_unittestp [0x42879d]\n??:? void tmp1_1co7l7.__unittest_L42_C1() [0x4280c9]\n??:? void tmp1_1co7l7.__modtest() [0x428520]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c7a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b6b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4307c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c78]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430755]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b689]\n??:? runModuleUnitTests [0x42c579]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428c60]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0)\n        {\n            if (lst2[i] % 2 != 0)\n                return \"NO\";\n            else\n            {\n                lst2[i] = lst2[i] + lst1[i];\n                lst1[i] = lst2[i] - lst1[i];\n                lst2[i] = lst2[i] - lst1[i];\n            }\n        }\n    }\n    \n    for (int i = 0; i < lst1.length; i++)\n        if (lst1[i] % 2 != 0)\n            return \"NO\";\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292818,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpui2vpaox.d(49): unittest failure\n----------------\n??:? _d_unittestp [0x42888d]\n??:? void tmpui2vpaox.__unittest_L45_C1() [0x4280da]\n??:? void tmpui2vpaox.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c893]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430845]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b779]\n??:? runModuleUnitTests [0x42c669]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d50]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    if (lst1.length == 1)\n        return \"YES\";\n    \n    if (lst1.length == 2)\n    {\n        if (lst1[0] % 2 == 0 && lst1[1] % 2 == 0 && lst2[0] % 2 == 0 && lst2[1] % 2 == 0)\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    \n    if (lst1.length % 2 == 0)\n    {\n        if (lst1[0] % 2 == 0 && lst1[1] % 2 == 0 && lst2[0] % 2 == 0 && lst2[1] % 2 == 0)\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    \n    if (lst1[0] % 2 == 0 && lst1[1] % 2 == 0 && lst2[0] % 2 == 0 && lst2[1] % 2 == 0)\n        return \"YES\";\n    else\n        return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292818,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_1g2j0kf.d(52): unittest failure\n----------------\n??:? _d_unittestp [0x428965]\n??:? void tmp_1g2j0kf.__unittest_L48_C1() [0x4281b6]\n??:? void tmp_1g2j0kf.__modtest() [0x4286e8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c96b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b87a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430991]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430e40]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43091d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b851]\n??:? runModuleUnitTests [0x42c741]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e28]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    int i = 0;\n    int j = 0;\n    \n    while(i < lst1.length && j < lst2.length)\n    {\n        if(lst1[i] % 2 == 0 && lst2[j] % 2 == 0)\n        {\n            if(lst1[i] != lst2[j])\n            {\n                long temp = lst1[i];\n                lst1[i] = lst2[j];\n                lst2[j] = temp;\n                return \"YES\";\n            }\n        }\n        else if(lst1[i] % 2 != 0 && lst2[j] % 2 != 0)\n        {\n            if(lst1[i] != lst2[j])\n            {\n                long temp = lst1[i];\n                lst1[i] = lst2[j];\n                lst2[j] = temp;\n                return \"YES\";\n            }\n        }\n        i++;\n        j++;\n    }\n    \n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292818,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpwuoyoqgl.d(59): unittest failure\n----------------\n??:? _d_unittestp [0x42898d]\n??:? void tmpwuoyoqgl.__unittest_L55_C1() [0x4281de]\n??:? void tmpwuoyoqgl.__modtest() [0x428710]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c993]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4309b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430e68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430945]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b879]\n??:? runModuleUnitTests [0x42c769]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e50]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    if (lst1.length == 1)\n        return \"YES\";\n    \n    if (lst1.length == 2)\n    {\n        if (lst1[0] % 2 == 0 && lst1[1] % 2 == 0)\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    \n    if (lst1.length % 2 == 0)\n        return \"NO\";\n    \n    int i = 0;\n    int j = 0;\n    int k = 0;\n    \n    while (i < lst1.length && j < lst2.length)\n    {\n        if (lst1[i] % 2 == 0 && lst2[j] % 2 == 0)\n        {\n            if (lst1[i] == lst2[j])\n            {\n                i++;\n                j++;\n            }\n            else\n            {\n                lst1[k] = lst1[i];\n                lst1[i] = lst2[j];\n                lst2[j] = lst1[k];\n                i++;\n                j++;\n                k++;\n            }\n        }\n        else if (lst1[i] % 2 == 0)\n        {\n            lst1[k] = lst1[i];\n            lst1[i] = lst2[j];\n            lst2[j] = lst1[k];\n            i++;\n            j++;\n            k++;\n        }\n        else if (lst2[j] % 2 == 0)\n        {\n            lst1[k] = lst1[i];\n            lst1[i] = lst2[j];\n            lst2[j] = lst1[k];\n            i++;\n            j++;\n            k++;\n        }\n        else\n        {\n            i++;\n            j++;\n        }\n    }\n    \n    if (i == lst1.length)\n        return \"YES\";\n    else\n        return \"\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "/tmp/tmp34bm14bl.d(94): Error: found `YES` when expecting `;` following `return` statement\n/tmp/tmp34bm14bl.d(95): Error: found `NO` when expecting `;` following statement\n/tmp/tmp34bm14bl.d(96): Error: found `YES` when expecting `;` following statement\n/tmp/tmp34bm14bl.d(97): Error: found `YES` when expecting `;` following statement\n/tmp/tmp34bm14bl.d(98): Error: found `NO` when expecting `;` following statement\n/tmp/tmp34bm14bl.d(99): Error: found `NO` when expecting `;` following statement\n/tmp/tmp34bm14bl.d(100): Error: found `YES` when expecting `;` following statement\n/tmp/tmp34bm14bl.d(100): Error: unterminated string constant starting at /tmp/tmp34bm14bl.d(100)\n/tmp/tmp34bm14bl.d(102): Error: found `End of File` when expecting `;` following statement\n/tmp/tmp34bm14bl.d(102): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp34bm14bl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    int i = 0;\n    int j = 0;\n    \n    while(i < lst1.length && j < lst2.length)\n    {\n        if(lst1[i] % 2 == 0 && lst2[j] % 2 == 0)\n        {\n            if(lst1[i] != lst2[j])\n            {\n                long temp = lst1[i];\n                lst1[i] = lst2[j];\n                lst2[j] = temp;\n                return \"YES\";\n            }\n        }\n        else if(lst1[i] % 2 == 0 && lst2[j] % 2 != 0)\n        {\n            if(lst1[i] != lst2[j])\n            {\n                long temp = lst1[i];\n                lst1[i] = lst2[j];\n                lst2[j] = temp;\n                return \"YES\";\n            }\n        }\n        else if(lst1[i] % 2 != 0 && lst2[j] % 2 == 0)\n        {\n            if(lst1[i] != lst2[j])\n            {\n                long temp = lst1[i];\n                lst1[i] = lst2[j];\n                lst2[j] = temp;\n                return \"YES\";\n            }\n        }\n        else\n        {\n            if(lst1[i] != lst2[j])\n            {\n                long temp = lst1[i];\n                lst1[i] = lst2[j];\n                lst2[j] = temp;\n                return \"YES\";\n            }\n        }\n        \n        i++;\n        j++;\n    }\n    \n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292818,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpuuv7gcwd.d(80): unittest failure\n----------------\n??:? _d_unittestp [0x428c15]\n??:? void tmpuuv7gcwd.__unittest_L76_C1() [0x428466]\n??:? void tmpuuv7gcwd.__modtest() [0x428998]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cc1b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bb2a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430c41]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4310f0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430bcd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bb01]\n??:? runModuleUnitTests [0x42c9f1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4290d8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    int i = 0;\n    while(i < lst1.length)\n    {\n        if(lst1[i] % 2 != 0)\n        {\n            if(lst2[i] % 2 != 0)\n            {\n                lst1[i] = lst1[i] + lst2[i];\n                lst2[i] = lst1[i] - lst2[i];\n                lst1[i] = lst1[i] - lst2[i];\n            }\n            else\n            {\n                lst1[i] = lst1[i] + lst2[i];\n                lst2[i] = lst1[i] - lst2[i];\n                lst1[i] = lst1[i] - lst2[i];\n            }\n        }\n        else\n        {\n            if(lst2[i] % 2 != 0)\n            {\n                lst1[i] = lst1[i] + lst2[i];\n                lst2[i] = lst1[i] - lst2[i];\n                lst1[i] = lst1[i] - lst2[i];\n            }\n            else\n            {\n                lst1[i] = lst1[i] + lst2[i];\n                lst2[i] = lst1[i] - lst2[i];\n                lst1[i] = lst1[i] - lst2[i];\n            }\n        }\n        i++;\n    }\n    \n    for(i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0)\n            return \"NO\";\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292818,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgmzi85ys.d(71): unittest failure\n----------------\n??:? _d_unittestp [0x428cbd]\n??:? void tmpgmzi85ys.__unittest_L67_C1() [0x42850a]\n??:? void tmpgmzi85ys.__modtest() [0x428a3c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ccc3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bbd2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ce9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431198]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c75]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bba9]\n??:? runModuleUnitTests [0x42ca99]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429180]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpnwpt6jhe.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4286fd]\n??:? void tmpnwpt6jhe.__unittest_L32_C1() [0x427f4a]\n??:? void tmpnwpt6jhe.__modtest() [0x42847c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c703]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430729]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c4d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428bc0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n        \n        if (lst1[i] % 2 == 0 && lst2[i] % 2 == 0)\n            continue;\n        \n        if (lst1[i] % 2 == 0)\n        {\n            lst1[i] = lst1[i] + lst2[i];\n            lst2[i] = lst1[i] - lst2[i];\n            lst1[i] = lst1[i] - lst2[i];\n        }\n        else\n        {\n            lst1[i] = lst1[i] - lst2[i];\n            lst2[i] = lst1[i] + lst2[i];\n            lst1[i] = lst1[i] + lst2[i];\n        }\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpjdfl7ac7.d(52): unittest failure\n----------------\n??:? _d_unittestp [0x428a2d]\n??:? void tmpjdfl7ac7.__unittest_L48_C1() [0x42827a]\n??:? void tmpjdfl7ac7.__modtest() [0x4287ac]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca33]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b942]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a59]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f08]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b919]\n??:? runModuleUnitTests [0x42c809]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428ef0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    if (lst1.length == 1 || lst2.length == 1)\n        return \"YES\";\n    \n    if (lst1.length == 2 && lst2.length == 2)\n        return \"YES\";\n    \n    if (lst1.length == 2 && lst2.length == 3)\n        return \"YES\";\n    \n    if (lst1.length == 3 && lst2.length == 3)\n        return \"YES\";\n    \n    if (lst1.length == 3 && lst2.length == 4)\n        return \"YES\";\n    \n    if (lst1.length == 4 && lst2.length == 4)\n        return \"YES\";\n    \n    if (lst1.length == 4 && lst2.length == 5)\n        return \"YES\";\n    \n    if (lst1.length == 5 && lst2.length == 5)\n        return \"YES\";\n    \n    if (lst1.length == 5 && lst2.length == 6)\n        return \"YES\";\n    \n    if (lst1.length == 6 && lst2.length == 6)\n        return \"YES\";\n    \n    if (lst1.length == 6 && lst2.length == 7)\n        return \"YES\";\n    \n    if (lst1.length == 7 && lst2.length == 7)\n        return \"YES\";\n    \n    if (lst1.length == 7 && lst2.length == 8)\n        return \"YES\";\n    \n    if (lst1.length == 8 && lst2.length == 8)\n        return \"YES\";\n    \n    if (lst1.length == 8 && lst2.length == 9)\n        return \"YES\";\n    \n    if (lst1.length == 9 && lst2.length == 9)\n        return \"YES\";\n    \n    if (lst1.length == 9 && lst2.length == 10)\n        return \"YES\";\n    \n    if (lst1\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "/tmp/tmp34vg3ir4.d(76): Error: found `unittest` when expecting `)`\n/tmp/tmp34vg3ir4.d(88): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp34vg3ir4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0)\n        {\n            for (int j = 0; j < lst2.length; j++)\n            {\n                if (lst2[j] % 2 == 0)\n                {\n                    long temp = lst1[i];\n                    lst1[i] = lst2[j];\n                    lst2[j] = temp;\n                    return \"YES\";\n                }\n            }\n        }\n    }\n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292818,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp1_1co7l7.d(47): unittest failure\n----------------\n??:? _d_unittestp [0x42879d]\n??:? void tmp1_1co7l7.__unittest_L42_C1() [0x4280c9]\n??:? void tmp1_1co7l7.__modtest() [0x428520]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c7a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b6b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4307c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c78]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430755]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b689]\n??:? runModuleUnitTests [0x42c579]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428c60]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    int i = 0;\n    int j = 0;\n    \n    while (i < lst1.length && j < lst2.length)\n    {\n        if (lst1[i] % 2 == 0 && lst2[j] % 2 == 0)\n        {\n            if (lst1[i] == lst2[j])\n            {\n                i++;\n                j++;\n            }\n            else\n            {\n                if (lst1[i] > lst2[j])\n                {\n                    i++;\n                }\n                else\n                {\n                    j++;\n                }\n            }\n        }\n        else if (lst1[i] % 2 == 1 && lst2[j] % 2 == 1)\n        {\n            if (lst1[i] == lst2[j])\n            {\n                i++;\n                j++;\n            }\n            else\n            {\n                if (lst1[i] > lst2[j])\n                {\n                    i++;\n                }\n                else\n                {\n                    j++;\n                }\n            }\n        }\n        else\n        {\n            if (lst1[i] > lst2[j])\n            {\n                i++;\n            }\n            else\n            {\n                j++;\n            }\n        }\n    }\n    \n    if (i == lst1.length && j == lst2.length)\n        return \"YES\";\n    else\n        return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292818,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpr3g81hx6.d(91): unittest failure\n----------------\n??:? _d_unittestp [0x428985]\n??:? void tmpr3g81hx6.__unittest_L85_C1() [0x428373]\n??:? void tmpr3g81hx6.__modtest() [0x428708]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c98b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b89a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4309b1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430e60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43093d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b871]\n??:? runModuleUnitTests [0x42c761]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e48]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    long sum = 0;\n    for(int i = 0; i < lst1.length; i++)\n        sum += lst1[i];\n    \n    if(sum % 2 != 0)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n        if(lst1[i] % 2 != 0)\n            return \"NO\";\n    \n    for(int i = 0; i < lst2.length; i++)\n        if(lst2[i] % 2 != 0)\n            return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n        for(int j = 0; j < lst2.length; j++)\n            if(lst1[i] == lst2[j])\n            {\n                lst1[i] = lst1[lst1.length - 1];\n                lst1[lst1.length - 1] = lst2[j];\n                lst2[j] = lst2[lst2.length - 1];\n                lst2[lst2.length - 1] = lst1[i];\n                return \"YES\";\n            }\n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292818,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmprrhlxbo4.d(55): unittest failure\n----------------\n??:? _d_unittestp [0x42897d]\n??:? void tmprrhlxbo4.__unittest_L51_C1() [0x4281ca]\n??:? void tmprrhlxbo4.__modtest() [0x4286fc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c983]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b892]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4309a9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430e58]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430935]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b869]\n??:? runModuleUnitTests [0x42c759]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e40]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n        if(lst1[i] % 2 == 0 && lst2[i] % 2 != 0)\n        {\n            lst2[i] = lst2[i] + lst1[i];\n            lst1[i] = lst2[i] - lst1[i];\n            lst2[i] = lst2[i] - lst1[i];\n        }\n        if(lst1[i] % 2 != 0 && lst2[i] % 2 == 0)\n        {\n            lst2[i] = lst2[i] + lst1[i];\n            lst1[i] = lst2[i] - lst1[i];\n            lst2[i] = lst2[i] - lst1[i];\n        }\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292818,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcj5x67rj.d(48): unittest failure\n----------------\n??:? _d_unittestp [0x428a9d]\n??:? void tmpcj5x67rj.__unittest_L44_C1() [0x4282ea]\n??:? void tmpcj5x67rj.__modtest() [0x42881c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42caa3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ac9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f78]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a55]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b989]\n??:? runModuleUnitTests [0x42c879]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f60]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    if(lst1.length == 1 || lst2.length == 1)\n        return \"YES\";\n    \n    if(lst1.length == 2 && lst2.length == 2)\n    {\n        if(lst1[0] == lst2[0] || lst1[0] == lst2[1] || lst1[1] == lst2[0] || lst1[1] == lst2[1])\n            return \"YES\";\n        else\n            return \"NO\";\n    }\n    \n    long min = std.math.min(lst1.length, lst2.length);\n    long max = std.math.max(lst1.length, lst2.length);\n    \n    for(int i = 0; i < min; i++)\n    {\n        if(lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n        \n        if(lst1[i] % 2 == 0 && lst2[i] % 2 != 0)\n        {\n            long temp = lst1[i];\n            lst1[i] = lst2[i];\n            lst2[i] = temp;\n            \n            if(isEven(lst1) && isEven(lst2))\n                return \"YES\";\n            else\n                return \"NO\";\n        }\n        \n        if(lst1[i] % 2 != 0 && lst2[i] % 2 == 0)\n        {\n            long temp = lst1[i];\n            lst1[i] = lst2[i];\n            lst2[i] = temp;\n            \n            if(isEven(lst1) && isEven(lst2))\n                return \"YES\";\n            else\n                return \"NO\";\n        }\n    }\n    \n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "/tmp/tmpxb5u9kei.d(35): Error: undefined identifier `min` in module `std.math`, did you mean function `sin`?\n/tmp/tmpxb5u9kei.d(36): Error: undefined identifier `max` in module `std.math`, did you mean function `fmax`?\n/tmp/tmpxb5u9kei.d(49): Error: undefined identifier `isEven`\n/tmp/tmpxb5u9kei.d(49): Error: undefined identifier `isEven`\n/tmp/tmpxb5u9kei.d(61): Error: undefined identifier `isEven`\n/tmp/tmpxb5u9kei.d(61): Error: undefined identifier `isEven`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxb5u9kei.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    int i = 0;\n    int j = 0;\n    \n    while(i < lst1.length && j < lst2.length)\n    {\n        if(lst1[i] % 2 == 0 && lst2[j] % 2 == 0)\n        {\n            if(lst1[i] == lst2[j])\n            {\n                i++;\n                j++;\n            }\n            else\n            {\n                if(lst1[i] > lst2[j])\n                {\n                    i++;\n                }\n                else\n                {\n                    j++;\n                }\n            }\n        }\n        else if(lst1[i] % 2 != 0 && lst2[j] % 2 != 0)\n        {\n            if(lst1[i] > lst2[j])\n            {\n                i++;\n            }\n            else\n            {\n                j++;\n            }\n        }\n        else if(lst1[i] % 2 == 0 && lst2[j] % 2 != 0)\n        {\n            if(lst1[i] == lst2[j])\n            {\n                i++;\n                j++;\n            }\n            else\n            {\n                if(lst1[i] > lst2[j])\n                {\n                    i++;\n                }\n                else\n                {\n                    j++;\n                }\n            }\n        }\n        else if(lst1[i] % 2 != 0 && lst2[j] % 2 == 0)\n        {\n            if(lst1[i] == lst2[j])\n            {\n                i++;\n                j++;\n            }\n            else\n            {\n                if(lst1[i] > lst2[j])\n                {\n                    i++;\n                }\n                else\n                {\n                    j++;\n                }\n            }\n        }\n    }\n    \n    if(i == lst1.length && j == lst2.length)\n        return \"YES\";\n    \nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "/tmp/tmpbvvgbdkd.d(102): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbvvgbdkd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n        \n        if (lst1[i] % 2 == 0 && lst2[i] % 2 == 0)\n            continue;\n        \n        if (lst1[i] % 2 == 0)\n        {\n            lst1[i] = lst1[i] + lst2[i];\n            lst2[i] = lst1[i] - lst2[i];\n            lst1[i] = lst1[i] - lst2[i];\n        }\n        else\n        {\n            lst1[i] = lst1[i] - lst2[i];\n            lst2[i] = lst1[i] + lst2[i];\n            lst1[i] = lst1[i] + lst2[i];\n        }\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpjdfl7ac7.d(52): unittest failure\n----------------\n??:? _d_unittestp [0x428a2d]\n??:? void tmpjdfl7ac7.__unittest_L48_C1() [0x42827a]\n??:? void tmpjdfl7ac7.__modtest() [0x4287ac]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca33]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b942]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a59]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f08]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b919]\n??:? runModuleUnitTests [0x42c809]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428ef0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    if(lst1.length == 1 || lst2.length == 1)\n        return \"YES\";\n    \n    if(lst1[0] % 2 != 0 || lst2[0] % 2 != 0)\n        return \"NO\";\n    \n    for(int i = 1; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0 || lst2[i] % 2 != 0)\n            return \"NO\";\n        \n        if(lst1[i] == lst2[i])\n            continue;\n        \n        if(lst1[i] > lst2[i])\n        {\n            lst1[i] -= lst2[i];\n            lst2[i] = 0;\n        }\n        else\n        {\n            lst2[i] -= lst1[i];\n            lst1[i] = 0;\n        }\n    }\n    \n    if(lst1.length == lst2.length)\n        return \"YES\";\n    \n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292818,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp7fpbz966.d(59): unittest failure\n----------------\n??:? _d_unittestp [0x42898d]\n??:? void tmp7fpbz966.__unittest_L55_C1() [0x4281de]\n??:? void tmp7fpbz966.__modtest() [0x428710]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c993]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4309b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430e68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430945]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b879]\n??:? runModuleUnitTests [0x42c769]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e50]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    if(lst1.length == 1)\n        return \"YES\";\n    \n    if(lst1[0] % 2 == 0 && lst2[0] % 2 == 0)\n        return \"YES\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 == 0 && lst2[i] % 2 == 1)\n        {\n            lst2[i] = lst2[i] + lst1[i];\n            lst1[i] = lst1[i] + lst2[i];\n            lst2[i] = lst2[i] - lst1[i];\n            lst1[i] = lst1[i] - lst2[i];\n        }\n    }\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 == 1 && lst2[i] % 2 == 0)\n        {\n            lst2[i] = lst2[i] + lst1[i];\n            lst1[i] = lst1[i] + lst2[i];\n            lst2[i] = lst2[i] - lst1[i];\n            lst1[i] = lst1[i] - lst2[i];\n        }\n    }\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 == 0 && lst2[i] % 2 == 0)\n            return \"YES\";\n    }\n    \n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292818,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpzgyqhju6.d(65): unittest failure\n----------------\n??:? _d_unittestp [0x428c25]\n??:? void tmpzgyqhju6.__unittest_L60_C1() [0x428551]\n??:? void tmpzgyqhju6.__modtest() [0x4289a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cc2b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bb3a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430c51]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431100]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430bdd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bb11]\n??:? runModuleUnitTests [0x42ca01]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4290e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    int i = 0;\n    int j = 0;\n    \n    while(i < lst1.length && j < lst2.length)\n    {\n        if(lst1[i] % 2 == 0 && lst2[j] % 2 == 0)\n        {\n            if(lst1[i] == lst2[j])\n            {\n                i++;\n                j++;\n            }\n            else\n            {\n                return \"NO\";\n            }\n        }\n        else if(lst1[i] % 2 != 0 && lst2[j] % 2 != 0)\n        {\n            if(lst1[i] == lst2[j])\n            {\n                i++;\n                j++;\n            }\n            else\n            {\n                return \"NO\";\n            }\n        }\n        else if(lst1[i] % 2 != 0 && lst2[j] % 2 == 0)\n        {\n            if(lst1[i] == lst2[j])\n            {\n                i++;\n                j++;\n            }\n            else\n            {\n                return \"NO\";\n            }\n        }\n        else if(lst1[i] % 2 == 0 && lst2[j] % 2 != 0)\n        {\n            if(lst1[i] == lst2[j])\n            {\n                i++;\n                j++;\n            }\n            else\n            {\n                return \"NO\";\n            }\n        }\n    }\n    \n    if(i == lst1.length && j == lst2.length)\n        return \"YES\";\n    else\n        return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292818,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpja8j9mub.d(90): unittest failure\n----------------\n??:? _d_unittestp [0x428a55]\n??:? void tmpja8j9mub.__unittest_L84_C1() [0x42843f]\n??:? void tmpja8j9mub.__modtest() [0x4287d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca5b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b96a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a81]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f30]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a0d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b941]\n??:? runModuleUnitTests [0x42c831]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f18]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length == 0 || lst2.length == 0)\n        return \"NO\";\n    \n    int i = 0;\n    int j = 0;\n    \n    while(i < lst1.length && j < lst2.length)\n    {\n        if(lst1[i] % 2 == 0 && lst2[j] % 2 == 0)\n        {\n            if(lst1[i] == lst2[j])\n            {\n                i++;\n                j++;\n            }\n            else\n            {\n                if(lst1[i] > lst2[j])\n                {\n                    i++;\n                }\n                else\n                {\n                    j++;\n                }\n            }\n        }\n        else if(lst1[i] % 2 != 0 && lst2[j] % 2 != 0)\n        {\n            if(lst1[i] > lst2[j])\n            {\n                i++;\n            }\n            else\n            {\n                j++;\n            }\n        }\n        else if(lst1[i] % 2 != 0 && lst2[j] % 2 == 0)\n        {\n            if(lst1[i] > lst2[j])\n            {\n                i++;\n            }\n            else\n            {\n                j++;\n            }\n        }\n        else if(lst1[i] % 2 == 0 && lst2[j] % 2 != 0)\n        {\n            if(lst1[i] > lst2[j])\n            {\n                i++;\n            }\n            else\n            {\n                j++;\n            }\n        }\n    }\n    \n    if(i == lst1.length && j == lst2.length)\n        return \"YES\";\n    else\n        return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292818,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp8nhicryv.d(92): unittest failure\n----------------\n??:? _d_unittestp [0x428a75]\n??:? void tmp8nhicryv.__unittest_L88_C1() [0x4282c6]\n??:? void tmp8nhicryv.__modtest() [0x4287f8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca7b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b98a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430aa1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f50]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a2d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b961]\n??:? runModuleUnitTests [0x42c851]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f38]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    int i = 0;\n    while(i < lst1.length)\n    {\n        if(lst1[i] % 2 != 0)\n        {\n            if(lst2[i] % 2 == 0)\n            {\n                lst1[i] = lst2[i];\n                lst2[i] = lst1[i];\n                lst1[i] = lst2[i];\n                i++;\n            }\n            else\n                return \"NO\";\n        }\n        else\n            i++;\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292818,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmprccayu0t.d(48): unittest failure\n----------------\n??:? _d_unittestp [0x4287cd]\n??:? void tmprccayu0t.__unittest_L44_C1() [0x42801e]\n??:? void tmprccayu0t.__modtest() [0x428550]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c7d3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b6e2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4307f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ca8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430785]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b6b9]\n??:? runModuleUnitTests [0x42c5a9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428c90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    int i = 0;\n    while(i < lst1.length)\n    {\n        if(lst1[i] % 2 != 0)\n        {\n            if(lst2[i] % 2 != 0)\n            {\n                if(lst1[i] != lst2[i])\n                    return \"NO\";\n            }\n            else\n                return \"NO\";\n        }\n        else\n        {\n            if(lst2[i] % 2 != 0)\n                return \"NO\";\n        }\n        i++;\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp95lszs5c.d(52): unittest failure\n----------------\n??:? _d_unittestp [0x4287b5]\n??:? void tmp95lszs5c.__unittest_L46_C1() [0x4281a3]\n??:? void tmp95lszs5c.__modtest() [0x428538]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c7bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b6ca]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4307e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c90]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43076d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b6a1]\n??:? runModuleUnitTests [0x42c591]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428c78]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0 && lst2[i] % 2 != 0)\n            return \"NO\";\n        \n        if(lst1[i] % 2 == 0 && lst2[i] % 2 != 0)\n        {\n            long temp = lst1[i];\n            lst1[i] = lst2[i];\n            lst2[i] = temp;\n            return \"YES\";\n        }\n    }\n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpxce2ggx2.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpxce2ggx2.__unittest_L39_C1() [0x428086]\n??:? void tmpxce2ggx2.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c83b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b74a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430861]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d10]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307ed]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b721]\n??:? runModuleUnitTests [0x42c611]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if(lst1.length != lst2.length)\n        return \"NO\";\n    \n    for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i]%2 != 0 && lst2[i]%2 != 0)\n            return \"NO\";\n        if(lst1[i]%2 == 0 && lst2[i]%2 != 0)\n            return \"NO\";\n        if(lst1[i]%2 != 0 && lst2[i]%2 == 0)\n            return \"NO\";\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292818,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpl1mkirj1.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x428815]\n??:? void tmpl1mkirj1.__unittest_L35_C1() [0x428066]\n??:? void tmpl1mkirj1.__modtest() [0x428598]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c81b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b72a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430841]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430cf0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307cd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b701]\n??:? runModuleUnitTests [0x42c5f1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cd8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    int i = 0;\n    while (i < lst1.length)\n    {\n        if (lst1[i] % 2 != 0)\n        {\n            if (lst2[i] % 2 != 0)\n                return \"NO\";\n            else\n                lst2[i] = lst2[i] + lst1[i];\n        }\n        else\n        {\n            if (lst2[i] % 2 != 0)\n                lst2[i] = lst2[i] - lst1[i];\n            else\n                lst1[i] = lst1[i] + lst2[i];\n        }\n        i++;\n    }\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpjeihhxcb.d(49): unittest failure\n----------------\n??:? _d_unittestp [0x4288e5]\n??:? void tmpjeihhxcb.__unittest_L45_C1() [0x428136]\n??:? void tmpjeihhxcb.__modtest() [0x428668]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8eb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7fa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430911]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430dc0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43089d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7d1]\n??:? runModuleUnitTests [0x42c6c1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428da8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement a function that takes two arrays of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 an array of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input arrays will be non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    if (lst1.length != lst2.length)\n        return \"NO\";\n    \n    for (int i = 0; i < lst1.length; i++)\n    {\n        if (lst1[i] % 2 != 0)\n        {\n            if (lst2[i] % 2 != 0)\n                return \"NO\";\n            else\n                lst2[i] = lst2[i] + lst1[i];\n        }\n        else\n        {\n            if (lst2[i] % 2 != 0)\n                lst2[i] = lst2[i] - lst1[i];\n            else\n                lst1[i] = lst1[i] + lst2[i];\n        }\n    }\n    \n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpx2gr0xqj.d(48): unittest failure\n----------------\n??:? _d_unittestp [0x4288e5]\n??:? void tmpx2gr0xqj.__unittest_L44_C1() [0x428136]\n??:? void tmpx2gr0xqj.__modtest() [0x428668]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8eb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7fa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430911]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430dc0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43089d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7d1]\n??:? runModuleUnitTests [0x42c6c1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428da8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}