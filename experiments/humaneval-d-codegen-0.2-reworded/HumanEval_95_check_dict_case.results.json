{
  "name": "HumanEval_95_check_dict_case",
  "language": "d",
  "prompt": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n",
  "tests": "unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "results": [
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict.get())\n    {\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.get()[0] >= 'A' && kv.first.get()[0] <= 'Z')\n            continue;\n        if (kv.first.get()[0] >= 'a' && kv.first.get()[0] <= 'z')\n            continue;\n        return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpafb584tn.d(25): Error: basic type expected, not `&`\n/tmp/tmpafb584tn.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpafb584tn.d(25): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpafb584tn.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (std::isupper(kv.first[0])) return false;\n        if (std::islower(kv.first[0])) return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpf11c6r_9.d(24): Error: basic type expected, not `&`\n/tmp/tmpf11c6r_9.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpf11c6r_9.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpf11c6r_9.d(25): Error: found `:` when expecting `)`\n/tmp/tmpf11c6r_9.d(25): Error: found `:` instead of statement\n/tmp/tmpf11c6r_9.d(26): Error: found `:` when expecting `)`\n/tmp/tmpf11c6r_9.d(26): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf11c6r_9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict) {\n        if (std::isupper(kv.first[0]))\n            return false;\n        if (std::islower(kv.first[0]))\n            return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpqpod3zkd.d(25): Error: basic type expected, not `&`\n/tmp/tmpqpod3zkd.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpqpod3zkd.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpqpod3zkd.d(26): Error: found `:` when expecting `)`\n/tmp/tmpqpod3zkd.d(26): Error: found `:` instead of statement\n/tmp/tmpqpod3zkd.d(28): Error: found `:` when expecting `)`\n/tmp/tmpqpod3zkd.d(28): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqpod3zkd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict.nonNull())\n    {\n        if (std::isupper(kv.first[0]))\n            return false;\n        if (std::islower(kv.first[0]))\n            return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmp30swofc4.d(25): Error: basic type expected, not `&`\n/tmp/tmp30swofc4.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmp30swofc4.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmp30swofc4.d(27): Error: found `:` when expecting `)`\n/tmp/tmp30swofc4.d(27): Error: found `:` instead of statement\n/tmp/tmp30swofc4.d(29): Error: found `:` when expecting `)`\n/tmp/tmp30swofc4.d(29): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp30swofc4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& k : dict)\n    {\n        if (std::isupper(k.first[0])) return false;\n        if (std::islower(k.first[0])) return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpo3f3fmzc.d(24): Error: basic type expected, not `&`\n/tmp/tmpo3f3fmzc.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpo3f3fmzc.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpo3f3fmzc.d(26): Error: found `:` when expecting `)`\n/tmp/tmpo3f3fmzc.d(26): Error: found `:` instead of statement\n/tmp/tmpo3f3fmzc.d(27): Error: found `:` when expecting `)`\n/tmp/tmpo3f3fmzc.d(27): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo3f3fmzc.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& k : dict)\n    {\n        if (std::isupper(k.first[0])) return false;\n        if (std::islower(k.first[0])) return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpo3f3fmzc.d(24): Error: basic type expected, not `&`\n/tmp/tmpo3f3fmzc.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpo3f3fmzc.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpo3f3fmzc.d(26): Error: found `:` when expecting `)`\n/tmp/tmpo3f3fmzc.d(26): Error: found `:` instead of statement\n/tmp/tmpo3f3fmzc.d(27): Error: found `:` when expecting `)`\n/tmp/tmpo3f3fmzc.d(27): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo3f3fmzc.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict)\n    {\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpeuhtdspd.d(25): Error: basic type expected, not `&`\n/tmp/tmpeuhtdspd.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpeuhtdspd.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpeuhtdspd.d(84): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpeuhtdspd.d(85): Error: found `{` when expecting `)`\n/tmp/tmpeuhtdspd.d(96): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeuhtdspd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (std::isupper(kv.first[0])) return false;\n        if (std::islower(kv.first[0])) return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpf11c6r_9.d(24): Error: basic type expected, not `&`\n/tmp/tmpf11c6r_9.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpf11c6r_9.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpf11c6r_9.d(25): Error: found `:` when expecting `)`\n/tmp/tmpf11c6r_9.d(25): Error: found `:` instead of statement\n/tmp/tmpf11c6r_9.d(26): Error: found `:` when expecting `)`\n/tmp/tmpf11c6r_9.d(26): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf11c6r_9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (std::isupper(kv.first[0])) return false;\n        if (std::islower(kv.first[0])) return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpf11c6r_9.d(24): Error: basic type expected, not `&`\n/tmp/tmpf11c6r_9.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpf11c6r_9.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpf11c6r_9.d(25): Error: found `:` when expecting `)`\n/tmp/tmpf11c6r_9.d(25): Error: found `:` instead of statement\n/tmp/tmpf11c6r_9.d(26): Error: found `:` when expecting `)`\n/tmp/tmpf11c6r_9.d(26): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf11c6r_9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto &kv : dict)\n    {\n        if (std::isupper(kv.first[0]))\n            return false;\n        if (std::islower(kv.first[0]))\n            return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmp_6_u5_hv.d(25): Error: basic type expected, not `&`\n/tmp/tmp_6_u5_hv.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmp_6_u5_hv.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmp_6_u5_hv.d(27): Error: found `:` when expecting `)`\n/tmp/tmp_6_u5_hv.d(27): Error: found `:` instead of statement\n/tmp/tmp_6_u5_hv.d(29): Error: found `:` when expecting `)`\n/tmp/tmp_6_u5_hv.d(29): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_6_u5_hv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict) {\n        if (std::isupper(kv.first[0]))\n            return false;\n        if (std::islower(kv.first[0]))\n            continue;\n        return false;\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmp54pnon6c.d(25): Error: basic type expected, not `&`\n/tmp/tmp54pnon6c.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmp54pnon6c.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmp54pnon6c.d(26): Error: found `:` when expecting `)`\n/tmp/tmp54pnon6c.d(26): Error: found `:` instead of statement\n/tmp/tmp54pnon6c.d(28): Error: found `:` when expecting `)`\n/tmp/tmp54pnon6c.d(28): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp54pnon6c.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpxxeyy248.d(24): Error: basic type expected, not `&`\n/tmp/tmpxxeyy248.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpxxeyy248.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpxxeyy248.d(58): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpxxeyy248.d(59): Error: found `{` when expecting `)`\n/tmp/tmpxxeyy248.d(70): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxxeyy248.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpxxeyy248.d(24): Error: basic type expected, not `&`\n/tmp/tmpxxeyy248.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpxxeyy248.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpxxeyy248.d(58): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpxxeyy248.d(59): Error: found `{` when expecting `)`\n/tmp/tmpxxeyy248.d(70): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxxeyy248.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict)\n    {\n        if (std::isupper(kv.first[0])) return false;\n        if (std::islower(kv.first[0])) return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmp4_pofep5.d(24): Error: basic type expected, not `&`\n/tmp/tmp4_pofep5.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmp4_pofep5.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmp4_pofep5.d(26): Error: found `:` when expecting `)`\n/tmp/tmp4_pofep5.d(26): Error: found `:` instead of statement\n/tmp/tmp4_pofep5.d(27): Error: found `:` when expecting `)`\n/tmp/tmp4_pofep5.d(27): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4_pofep5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (kv.key.isNull()) return false;\n        if (kv.key.isStr()) {\n            if (kv.key.asStr() != kv.key.asStr().toLower()) return false;\n        } else {\n            if (kv.key.asStr() != kv.key.asStr().toUpper()) return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpc_i0344t.d(24): Error: basic type expected, not `&`\n/tmp/tmpc_i0344t.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpc_i0344t.d(24): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc_i0344t.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpxxeyy248.d(24): Error: basic type expected, not `&`\n/tmp/tmpxxeyy248.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpxxeyy248.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpxxeyy248.d(58): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpxxeyy248.d(59): Error: found `{` when expecting `)`\n/tmp/tmpxxeyy248.d(70): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxxeyy248.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto &kv : dict) {\n        if (std::isupper(kv.first[0]))\n            return false;\n        if (std::islower(kv.first[0]))\n            return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpal27i7g9.d(25): Error: basic type expected, not `&`\n/tmp/tmpal27i7g9.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpal27i7g9.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpal27i7g9.d(26): Error: found `:` when expecting `)`\n/tmp/tmpal27i7g9.d(26): Error: found `:` instead of statement\n/tmp/tmpal27i7g9.d(28): Error: found `:` when expecting `)`\n/tmp/tmpal27i7g9.d(28): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpal27i7g9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto &kv : dict)\n    {\n        if (kv.first.isNull()) return false;\n        if (kv.first.isStr())\n        {\n            if (kv.first.asStr().toLower() != kv.first.asStr()) return false;\n        }\n        else if (kv.first.isStr())\n        {\n            if (kv.first.asStr().toUpper() != kv.first.asStr()) return false;\n        }\n        else return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpwuy5t1rj.d(24): Error: basic type expected, not `&`\n/tmp/tmpwuy5t1rj.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpwuy5t1rj.d(24): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwuy5t1rj.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpxxeyy248.d(24): Error: basic type expected, not `&`\n/tmp/tmpxxeyy248.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpxxeyy248.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpxxeyy248.d(58): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpxxeyy248.d(59): Error: found `{` when expecting `)`\n/tmp/tmpxxeyy248.d(70): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxxeyy248.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (std::isupper(kv.first[0])) return false;\n        if (std::islower(kv.first[0])) return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpf11c6r_9.d(24): Error: basic type expected, not `&`\n/tmp/tmpf11c6r_9.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpf11c6r_9.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpf11c6r_9.d(25): Error: found `:` when expecting `)`\n/tmp/tmpf11c6r_9.d(25): Error: found `:` instead of statement\n/tmp/tmpf11c6r_9.d(26): Error: found `:` when expecting `)`\n/tmp/tmpf11c6r_9.d(26): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf11c6r_9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict)\n        if (std::isupper(kv.first[0]))\n            return false;\n        else if (std::islower(kv.first[0]))\n            return true;\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpmeotgttc.d(25): Error: basic type expected, not `&`\n/tmp/tmpmeotgttc.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpmeotgttc.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpmeotgttc.d(26): Error: found `:` when expecting `)`\n/tmp/tmpmeotgttc.d(26): Error: found `:` instead of statement\n/tmp/tmpmeotgttc.d(28): Error: found `:` when expecting `)`\n/tmp/tmpmeotgttc.d(28): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmeotgttc.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto &kv : dict) {\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpb8q0h3ok.d(24): Error: basic type expected, not `&`\n/tmp/tmpb8q0h3ok.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpb8q0h3ok.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpb8q0h3ok.d(58): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpb8q0h3ok.d(59): Error: found `{` when expecting `)`\n/tmp/tmpb8q0h3ok.d(70): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb8q0h3ok.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict) {\n        if (std::isupper(kv.first[0]))\n            return false;\n        if (std::islower(kv.first[0]))\n            continue;\n        return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpe76kaeav.d(25): Error: basic type expected, not `&`\n/tmp/tmpe76kaeav.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpe76kaeav.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpe76kaeav.d(26): Error: found `:` when expecting `)`\n/tmp/tmpe76kaeav.d(26): Error: found `:` instead of statement\n/tmp/tmpe76kaeav.d(28): Error: found `:` when expecting `)`\n/tmp/tmpe76kaeav.d(28): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe76kaeav.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpxxeyy248.d(24): Error: basic type expected, not `&`\n/tmp/tmpxxeyy248.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpxxeyy248.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpxxeyy248.d(58): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpxxeyy248.d(59): Error: found `{` when expecting `)`\n/tmp/tmpxxeyy248.d(70): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxxeyy248.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (kv.first.isNull()) return false;\n        if (kv.first.isString()) {\n            if (kv.first.asString().toLower() != kv.first.asString().toUpper()) return false;\n        }\n        else {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpubbxk54d.d(24): Error: basic type expected, not `&`\n/tmp/tmpubbxk54d.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpubbxk54d.d(24): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpubbxk54d.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (std::isupper(kv.first[0])) return false;\n        if (std::islower(kv.first[0])) return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpf11c6r_9.d(24): Error: basic type expected, not `&`\n/tmp/tmpf11c6r_9.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpf11c6r_9.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpf11c6r_9.d(25): Error: found `:` when expecting `)`\n/tmp/tmpf11c6r_9.d(25): Error: found `:` instead of statement\n/tmp/tmpf11c6r_9.d(26): Error: found `:` when expecting `)`\n/tmp/tmpf11c6r_9.d(26): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf11c6r_9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto &kv : dict) {\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpb8q0h3ok.d(24): Error: basic type expected, not `&`\n/tmp/tmpb8q0h3ok.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpb8q0h3ok.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpb8q0h3ok.d(58): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpb8q0h3ok.d(59): Error: found `{` when expecting `)`\n/tmp/tmpb8q0h3ok.d(70): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb8q0h3ok.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& x : dict) {\n        if (x.first.isNull()) return false;\n        if (x.first.isCaseInsensitive()) {\n            if (!x.first.isLowerCase()) return false;\n        } else {\n            if (!x.first.isUpperCase()) return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmp1_w4rpcz.d(24): Error: basic type expected, not `&`\n/tmp/tmp1_w4rpcz.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmp1_w4rpcz.d(24): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1_w4rpcz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull() || kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull() || kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull() || kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull() || kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull() || kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull() || kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull() || kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull() || kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull() || kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull() || kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull() || kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull() || kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull() || kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (k\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmp2_p324hr.d(25): Error: basic type expected, not `&`\n/tmp/tmp2_p324hr.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmp2_p324hr.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmp2_p324hr.d(28): Error: basic type expected, not `&`\n/tmp/tmp2_p324hr.d(28): Error: no identifier for declarator `_error_`\n/tmp/tmp2_p324hr.d(28): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmp2_p324hr.d(31): Error: basic type expected, not `&`\n/tmp/tmp2_p324hr.d(31): Error: no identifier for declarator `_error_`\n/tmp/tmp2_p324hr.d(31): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmp2_p324hr.d(34): Error: basic type expected, not `&`\n/tmp/tmp2_p324hr.d(34): Error: no identifier for declarator `_error_`\n/tmp/tmp2_p324hr.d(34): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmp2_p324hr.d(37): Error: basic type expected, not `&`\n/tmp/tmp2_p324hr.d(37): Error: no identifier for declarator `_error_`\n/tmp/tmp2_p324hr.d(37): Error:",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict)\n    {\n        if (std::isupper(kv.first[0]))\n            return false;\n        if (std::islower(kv.first[0]))\n            return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmp2gnungat.d(25): Error: basic type expected, not `&`\n/tmp/tmp2gnungat.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmp2gnungat.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmp2gnungat.d(27): Error: found `:` when expecting `)`\n/tmp/tmp2gnungat.d(27): Error: found `:` instead of statement\n/tmp/tmp2gnungat.d(29): Error: found `:` when expecting `)`\n/tmp/tmp2gnungat.d(29): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2gnungat.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict)\n    {\n        if (std::isupper(kv.first[0]))\n            return false;\n        if (std::islower(kv.first[0]))\n            return true;\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpoknzuj14.d(25): Error: basic type expected, not `&`\n/tmp/tmpoknzuj14.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpoknzuj14.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpoknzuj14.d(27): Error: found `:` when expecting `)`\n/tmp/tmpoknzuj14.d(27): Error: found `:` instead of statement\n/tmp/tmpoknzuj14.d(29): Error: found `:` when expecting `)`\n/tmp/tmpoknzuj14.d(29): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoknzuj14.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto key : dict.keys())\n    {\n        if (std::isupper(key[0]))\n            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpusc64xtp.d(25): Error: no identifier for declarator `key`\n/tmp/tmpusc64xtp.d(25): Error: expression expected, not `:`\n/tmp/tmpusc64xtp.d(25): Error: found `dict` when expecting `;` following `for` condition\n/tmp/tmpusc64xtp.d(27): Error: found `:` when expecting `)`\n/tmp/tmpusc64xtp.d(27): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpusc64xtp.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict)\n    {\n        if (std::isupper(kv.first[0]))\n            return false;\n        if (std::islower(kv.first[0]))\n            return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmp2gnungat.d(25): Error: basic type expected, not `&`\n/tmp/tmp2gnungat.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmp2gnungat.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmp2gnungat.d(27): Error: found `:` when expecting `)`\n/tmp/tmp2gnungat.d(27): Error: found `:` instead of statement\n/tmp/tmp2gnungat.d(29): Error: found `:` when expecting `)`\n/tmp/tmp2gnungat.d(29): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2gnungat.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto &kv : dict) {\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpb8q0h3ok.d(24): Error: basic type expected, not `&`\n/tmp/tmpb8q0h3ok.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpb8q0h3ok.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpb8q0h3ok.d(58): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpb8q0h3ok.d(59): Error: found `{` when expecting `)`\n/tmp/tmpb8q0h3ok.d(70): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb8q0h3ok.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto &kv : dict) {\n        if (std::isupper(kv.first[0])) return false;\n        if (std::islower(kv.first[0])) return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpzbfmby8y.d(24): Error: basic type expected, not `&`\n/tmp/tmpzbfmby8y.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpzbfmby8y.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpzbfmby8y.d(25): Error: found `:` when expecting `)`\n/tmp/tmpzbfmby8y.d(25): Error: found `:` instead of statement\n/tmp/tmpzbfmby8y.d(26): Error: found `:` when expecting `)`\n/tmp/tmpzbfmby8y.d(26): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzbfmby8y.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto &kv : dict) {\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpd6rkslbw.d(25): Error: basic type expected, not `&`\n/tmp/tmpd6rkslbw.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpd6rkslbw.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpd6rkslbw.d(83): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpd6rkslbw.d(84): Error: found `{` when expecting `)`\n/tmp/tmpd6rkslbw.d(95): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd6rkslbw.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto &kv : dict)\n    {\n        if (std::isupper(kv.first[0]))\n            return false;\n        if (std::islower(kv.first[0]))\n            return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmp_6_u5_hv.d(25): Error: basic type expected, not `&`\n/tmp/tmp_6_u5_hv.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmp_6_u5_hv.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmp_6_u5_hv.d(27): Error: found `:` when expecting `)`\n/tmp/tmp_6_u5_hv.d(27): Error: found `:` instead of statement\n/tmp/tmp_6_u5_hv.d(29): Error: found `:` when expecting `)`\n/tmp/tmp_6_u5_hv.d(29): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_6_u5_hv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (std.typecons.isLowerCase(kv.key)) return true;\n        if (std.typecons.isUpperCase(kv.key)) return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpfbnuh1uw.d(24): Error: basic type expected, not `&`\n/tmp/tmpfbnuh1uw.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpfbnuh1uw.d(24): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfbnuh1uw.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto &kv : dict) {\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpb8q0h3ok.d(24): Error: basic type expected, not `&`\n/tmp/tmpb8q0h3ok.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpb8q0h3ok.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpb8q0h3ok.d(58): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpb8q0h3ok.d(59): Error: found `{` when expecting `)`\n/tmp/tmpb8q0h3ok.d(70): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb8q0h3ok.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict) {\n        if (std::isupper(kv.first[0]))\n            return false;\n        if (std::islower(kv.first[0]))\n            continue;\n        return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpe76kaeav.d(25): Error: basic type expected, not `&`\n/tmp/tmpe76kaeav.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpe76kaeav.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpe76kaeav.d(26): Error: found `:` when expecting `)`\n/tmp/tmpe76kaeav.d(26): Error: found `:` instead of statement\n/tmp/tmpe76kaeav.d(28): Error: found `:` when expecting `)`\n/tmp/tmpe76kaeav.d(28): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe76kaeav.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto &kv : dict)\n    {\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpgy5wg6dc.d(25): Error: basic type expected, not `&`\n/tmp/tmpgy5wg6dc.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpgy5wg6dc.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpgy5wg6dc.d(84): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpgy5wg6dc.d(85): Error: found `{` when expecting `)`\n/tmp/tmpgy5wg6dc.d(96): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgy5wg6dc.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto &kv : dict)\n    {\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpgy5wg6dc.d(25): Error: basic type expected, not `&`\n/tmp/tmpgy5wg6dc.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpgy5wg6dc.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpgy5wg6dc.d(84): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpgy5wg6dc.d(85): Error: found `{` when expecting `)`\n/tmp/tmpgy5wg6dc.d(96): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgy5wg6dc.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (std::isupper(kv.first[0])) return false;\n        if (std::islower(kv.first[0])) return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpf11c6r_9.d(24): Error: basic type expected, not `&`\n/tmp/tmpf11c6r_9.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpf11c6r_9.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpf11c6r_9.d(25): Error: found `:` when expecting `)`\n/tmp/tmpf11c6r_9.d(25): Error: found `:` instead of statement\n/tmp/tmpf11c6r_9.d(26): Error: found `:` when expecting `)`\n/tmp/tmpf11c6r_9.d(26): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf11c6r_9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (std::isupper(kv.first[0])) return false;\n        if (std::islower(kv.first[0])) return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpf11c6r_9.d(24): Error: basic type expected, not `&`\n/tmp/tmpf11c6r_9.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpf11c6r_9.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpf11c6r_9.d(25): Error: found `:` when expecting `)`\n/tmp/tmpf11c6r_9.d(25): Error: found `:` instead of statement\n/tmp/tmpf11c6r_9.d(26): Error: found `:` when expecting `)`\n/tmp/tmpf11c6r_9.d(26): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf11c6r_9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (std.typecons.isLowerCase(kv.first)) return true;\n        if (std.typecons.isUpperCase(kv.first)) return false;\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmp6zrgc0o1.d(24): Error: basic type expected, not `&`\n/tmp/tmp6zrgc0o1.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmp6zrgc0o1.d(24): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6zrgc0o1.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict)\n        if (kv.first.length() != kv.second.length())\n            return false;\n    for (auto& kv : dict)\n        if (kv.first.length() != kv.second.length())\n            return false;\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmp2z0z7au3.d(25): Error: basic type expected, not `&`\n/tmp/tmp2z0z7au3.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmp2z0z7au3.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmp2z0z7au3.d(28): Error: basic type expected, not `&`\n/tmp/tmp2z0z7au3.d(28): Error: no identifier for declarator `_error_`\n/tmp/tmp2z0z7au3.d(28): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2z0z7au3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& k : dict)\n    {\n        if (k.isNull())\n            return false;\n        if (k.isStr())\n        {\n            if (k.toStr().toLower() != k.toStr().toUpper())\n                return false;\n        }\n        else\n            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpqvw6xkkd.d(25): Error: basic type expected, not `&`\n/tmp/tmpqvw6xkkd.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpqvw6xkkd.d(25): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqvw6xkkd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict)\n        if (std::isupper(kv.first[0]) || std::islower(kv.first[0]))\n            return false;\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpkytsf635.d(25): Error: basic type expected, not `&`\n/tmp/tmpkytsf635.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpkytsf635.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpkytsf635.d(26): Error: found `:` when expecting `)`\n/tmp/tmpkytsf635.d(26): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkytsf635.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict)\n    {\n        if (std::isupper(kv.first[0]))\n            return false;\n        if (std::islower(kv.first[0]))\n            return true;\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpoknzuj14.d(25): Error: basic type expected, not `&`\n/tmp/tmpoknzuj14.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpoknzuj14.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpoknzuj14.d(27): Error: found `:` when expecting `)`\n/tmp/tmpoknzuj14.d(27): Error: found `:` instead of statement\n/tmp/tmpoknzuj14.d(29): Error: found `:` when expecting `)`\n/tmp/tmpoknzuj14.d(29): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoknzuj14.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto &kv : dict) {\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpxe5c22ix.d(24): Error: basic type expected, not `&`\n/tmp/tmpxe5c22ix.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpxe5c22ix.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpxe5c22ix.d(58): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpxe5c22ix.d(59): Error: found `{` when expecting `)`\n/tmp/tmpxe5c22ix.d(70): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxe5c22ix.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (std::isupper(kv.first[0])) return false;\n        if (std::islower(kv.first[0])) return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpf11c6r_9.d(24): Error: basic type expected, not `&`\n/tmp/tmpf11c6r_9.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpf11c6r_9.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpf11c6r_9.d(25): Error: found `:` when expecting `)`\n/tmp/tmpf11c6r_9.d(25): Error: found `:` instead of statement\n/tmp/tmpf11c6r_9.d(26): Error: found `:` when expecting `)`\n/tmp/tmpf11c6r_9.d(26): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf11c6r_9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto &kv : dict) {\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpb8q0h3ok.d(24): Error: basic type expected, not `&`\n/tmp/tmpb8q0h3ok.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpb8q0h3ok.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpb8q0h3ok.d(58): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpb8q0h3ok.d(59): Error: found `{` when expecting `)`\n/tmp/tmpb8q0h3ok.d(70): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb8q0h3ok.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& k : dict) {\n        if (std::isupper(k.first[0])) return false;\n        if (std::islower(k.first[0])) return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmp1wk3s_ad.d(24): Error: basic type expected, not `&`\n/tmp/tmp1wk3s_ad.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmp1wk3s_ad.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmp1wk3s_ad.d(25): Error: found `:` when expecting `)`\n/tmp/tmp1wk3s_ad.d(25): Error: found `:` instead of statement\n/tmp/tmp1wk3s_ad.d(26): Error: found `:` when expecting `)`\n/tmp/tmp1wk3s_ad.d(26): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1wk3s_ad.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict)\n        if (std::isupper(kv.first[0]))\n            return false;\n    for (auto& kv : dict)\n        if (std::islower(kv.first[0]))\n            return false;\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmp_pz2ryqq.d(25): Error: basic type expected, not `&`\n/tmp/tmp_pz2ryqq.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmp_pz2ryqq.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmp_pz2ryqq.d(26): Error: found `:` when expecting `)`\n/tmp/tmp_pz2ryqq.d(26): Error: found `:` instead of statement\n/tmp/tmp_pz2ryqq.d(28): Error: basic type expected, not `&`\n/tmp/tmp_pz2ryqq.d(28): Error: no identifier for declarator `_error_`\n/tmp/tmp_pz2ryqq.d(28): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmp_pz2ryqq.d(29): Error: found `:` when expecting `)`\n/tmp/tmp_pz2ryqq.d(29): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_pz2ryqq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto &kv : dict.nonNull())\n    {\n        if (std.typecons.isLowerCase(kv.first))\n            continue;\n        if (std.typecons.isUpperCase(kv.first))\n            continue;\n        return false;\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmptdquughd.d(25): Error: basic type expected, not `&`\n/tmp/tmptdquughd.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmptdquughd.d(25): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptdquughd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpxxeyy248.d(24): Error: basic type expected, not `&`\n/tmp/tmpxxeyy248.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpxxeyy248.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpxxeyy248.d(58): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpxxeyy248.d(59): Error: found `{` when expecting `)`\n/tmp/tmpxxeyy248.d(70): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxxeyy248.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict) {\n        if (std::isupper(kv.first[0]))\n            return false;\n        if (std::islower(kv.first[0]))\n            continue;\n        return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpe76kaeav.d(25): Error: basic type expected, not `&`\n/tmp/tmpe76kaeav.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpe76kaeav.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpe76kaeav.d(26): Error: found `:` when expecting `)`\n/tmp/tmpe76kaeav.d(26): Error: found `:` instead of statement\n/tmp/tmpe76kaeav.d(28): Error: found `:` when expecting `)`\n/tmp/tmpe76kaeav.d(28): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe76kaeav.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict) {\n        if (std::isupper(kv.first[0]))\n            return false;\n        if (std::islower(kv.first[0]))\n            return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpqpod3zkd.d(25): Error: basic type expected, not `&`\n/tmp/tmpqpod3zkd.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpqpod3zkd.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpqpod3zkd.d(26): Error: found `:` when expecting `)`\n/tmp/tmpqpod3zkd.d(26): Error: found `:` instead of statement\n/tmp/tmpqpod3zkd.d(28): Error: found `:` when expecting `)`\n/tmp/tmpqpod3zkd.d(28): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqpod3zkd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (std::isupper(kv.first[0])) return false;\n        if (std::islower(kv.first[0])) return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpf11c6r_9.d(24): Error: basic type expected, not `&`\n/tmp/tmpf11c6r_9.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpf11c6r_9.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpf11c6r_9.d(25): Error: found `:` when expecting `)`\n/tmp/tmpf11c6r_9.d(25): Error: found `:` instead of statement\n/tmp/tmpf11c6r_9.d(26): Error: found `:` when expecting `)`\n/tmp/tmpf11c6r_9.d(26): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf11c6r_9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict)\n        if (std::isupper(kv.first[0]) || std::islower(kv.first[0]))\n            return false;\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpkytsf635.d(25): Error: basic type expected, not `&`\n/tmp/tmpkytsf635.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpkytsf635.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpkytsf635.d(26): Error: found `:` when expecting `)`\n/tmp/tmpkytsf635.d(26): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkytsf635.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto &kv : dict) {\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpxe5c22ix.d(24): Error: basic type expected, not `&`\n/tmp/tmpxe5c22ix.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpxe5c22ix.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpxe5c22ix.d(58): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpxe5c22ix.d(59): Error: found `{` when expecting `)`\n/tmp/tmpxe5c22ix.d(70): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxe5c22ix.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto &kv : dict)\n    {\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpgy5wg6dc.d(25): Error: basic type expected, not `&`\n/tmp/tmpgy5wg6dc.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpgy5wg6dc.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpgy5wg6dc.d(84): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpgy5wg6dc.d(85): Error: found `{` when expecting `)`\n/tmp/tmpgy5wg6dc.d(96): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgy5wg6dc.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto &kv : dict) {\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpb8q0h3ok.d(24): Error: basic type expected, not `&`\n/tmp/tmpb8q0h3ok.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpb8q0h3ok.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpb8q0h3ok.d(58): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpb8q0h3ok.d(59): Error: found `{` when expecting `)`\n/tmp/tmpb8q0h3ok.d(70): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb8q0h3ok.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto &kv : dict) {\n        if (std.typecons.isLowerCase(kv.first)) return true;\n        if (std.typecons.isUpperCase(kv.first)) return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmp4d_7wwri.d(24): Error: basic type expected, not `&`\n/tmp/tmp4d_7wwri.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmp4d_7wwri.d(24): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4d_7wwri.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (kv.first.isNull()) return false;\n        if (kv.first.isStr()) {\n            if (kv.first.getStr() != kv.first.getStr().toLower()) return false;\n        }\n        else if (kv.first.isStr()) {\n            if (kv.first.getStr() != kv.first.getStr().toUpper()) return false;\n        }\n        else return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpp7y2p55b.d(24): Error: basic type expected, not `&`\n/tmp/tmpp7y2p55b.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpp7y2p55b.d(24): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp7y2p55b.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict)\n    {\n        if (std::isupper(kv.first[0])) return false;\n        if (std::islower(kv.first[0])) return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmp4_pofep5.d(24): Error: basic type expected, not `&`\n/tmp/tmp4_pofep5.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmp4_pofep5.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmp4_pofep5.d(26): Error: found `:` when expecting `)`\n/tmp/tmp4_pofep5.d(26): Error: found `:` instead of statement\n/tmp/tmp4_pofep5.d(27): Error: found `:` when expecting `)`\n/tmp/tmp4_pofep5.d(27): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4_pofep5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (std::isupper(kv.first[0])) return false;\n        if (std::islower(kv.first[0])) return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpf11c6r_9.d(24): Error: basic type expected, not `&`\n/tmp/tmpf11c6r_9.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpf11c6r_9.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpf11c6r_9.d(25): Error: found `:` when expecting `)`\n/tmp/tmpf11c6r_9.d(25): Error: found `:` instead of statement\n/tmp/tmpf11c6r_9.d(26): Error: found `:` when expecting `)`\n/tmp/tmpf11c6r_9.d(26): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf11c6r_9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& k : dict)\n    {\n        if (std::isupper(k.first[0]))\n            return false;\n        if (std::islower(k.first[0]))\n            return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpjtrcxkg3.d(25): Error: basic type expected, not `&`\n/tmp/tmpjtrcxkg3.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpjtrcxkg3.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpjtrcxkg3.d(27): Error: found `:` when expecting `)`\n/tmp/tmpjtrcxkg3.d(27): Error: found `:` instead of statement\n/tmp/tmpjtrcxkg3.d(29): Error: found `:` when expecting `)`\n/tmp/tmpjtrcxkg3.d(29): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjtrcxkg3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto &kv : dict) {\n        if (std.typecons.isLowerCase(kv.key))\n            continue;\n        if (std.typecons.isUpperCase(kv.key))\n            continue;\n        return false;\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmppnrsh_gr.d(25): Error: basic type expected, not `&`\n/tmp/tmppnrsh_gr.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmppnrsh_gr.d(25): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppnrsh_gr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict)\n    {\n        if (std::isupper(kv.first[0])) return false;\n        if (std::islower(kv.first[0])) return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmp4_pofep5.d(24): Error: basic type expected, not `&`\n/tmp/tmp4_pofep5.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmp4_pofep5.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmp4_pofep5.d(26): Error: found `:` when expecting `)`\n/tmp/tmp4_pofep5.d(26): Error: found `:` instead of statement\n/tmp/tmp4_pofep5.d(27): Error: found `:` when expecting `)`\n/tmp/tmp4_pofep5.d(27): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4_pofep5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict.nonNull()) {\n        if (std.isLowerCase(kv.first)) return true;\n        if (std.isUpperCase(kv.first)) return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmp818olvih.d(24): Error: basic type expected, not `&`\n/tmp/tmp818olvih.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmp818olvih.d(24): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp818olvih.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict.nonNull())\n    {\n        if (std::isupper(kv.first[0])) return false;\n        if (std::islower(kv.first[0])) return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpbdotin0b.d(24): Error: basic type expected, not `&`\n/tmp/tmpbdotin0b.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpbdotin0b.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpbdotin0b.d(26): Error: found `:` when expecting `)`\n/tmp/tmpbdotin0b.d(26): Error: found `:` instead of statement\n/tmp/tmpbdotin0b.d(27): Error: found `:` when expecting `)`\n/tmp/tmpbdotin0b.d(27): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbdotin0b.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto key : dict)\n    {\n        if (std.typecons.isLowerCase(key) != std.typecons.isUpperCase(key))\n            return false;\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpi_7g9ip6.d(25): Error: no identifier for declarator `key`\n/tmp/tmpi_7g9ip6.d(25): Error: expression expected, not `:`\n/tmp/tmpi_7g9ip6.d(25): Error: found `dict` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi_7g9ip6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto &kv : dict) {\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpd6rkslbw.d(25): Error: basic type expected, not `&`\n/tmp/tmpd6rkslbw.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpd6rkslbw.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpd6rkslbw.d(83): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpd6rkslbw.d(84): Error: found `{` when expecting `)`\n/tmp/tmpd6rkslbw.d(95): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd6rkslbw.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (std::isupper(kv.first[0])) return false;\n        if (std::islower(kv.first[0])) return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpf11c6r_9.d(24): Error: basic type expected, not `&`\n/tmp/tmpf11c6r_9.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpf11c6r_9.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpf11c6r_9.d(25): Error: found `:` when expecting `)`\n/tmp/tmpf11c6r_9.d(25): Error: found `:` instead of statement\n/tmp/tmpf11c6r_9.d(26): Error: found `:` when expecting `)`\n/tmp/tmpf11c6r_9.d(26): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf11c6r_9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (kv.first.isNull()) return false;\n        if (kv.first.is_string()) {\n            if (kv.first.as_string() != kv.first.as_string().toLower()) return false;\n        } else {\n            if (kv.first.as_string() != kv.first.as_string().toUpper()) return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpzbvfpznj.d(24): Error: basic type expected, not `&`\n/tmp/tmpzbvfpznj.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpzbvfpznj.d(24): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzbvfpznj.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpxxeyy248.d(24): Error: basic type expected, not `&`\n/tmp/tmpxxeyy248.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpxxeyy248.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpxxeyy248.d(58): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpxxeyy248.d(59): Error: found `{` when expecting `)`\n/tmp/tmpxxeyy248.d(70): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxxeyy248.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto &kv : dict)\n    {\n        if (std.typecons.isLowerCase(kv.key))\n            continue;\n        if (std.typecons.isUpperCase(kv.key))\n            continue;\n        return false;\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpnxa1t7ba.d(25): Error: basic type expected, not `&`\n/tmp/tmpnxa1t7ba.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpnxa1t7ba.d(25): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnxa1t7ba.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (kv.first.isNull()) return false;\n        if (kv.first.isString()) {\n            if (kv.first.asString().toLower() != kv.first.asString()) return false;\n        }\n        else {\n            if (kv.first.asString().toUpper() != kv.first.asString()) return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmptqi4hfgw.d(24): Error: basic type expected, not `&`\n/tmp/tmptqi4hfgw.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmptqi4hfgw.d(24): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptqi4hfgw.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& x : dict) {\n        if (x.first.isNull()) return false;\n        if (x.first.is_upper()) return false;\n        if (x.first.is_lower()) return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmph_25odxl.d(24): Error: basic type expected, not `&`\n/tmp/tmph_25odxl.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmph_25odxl.d(24): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph_25odxl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpxxeyy248.d(24): Error: basic type expected, not `&`\n/tmp/tmpxxeyy248.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpxxeyy248.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpxxeyy248.d(58): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpxxeyy248.d(59): Error: found `{` when expecting `)`\n/tmp/tmpxxeyy248.d(70): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxxeyy248.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto &kv : dict)\n    {\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpgy5wg6dc.d(25): Error: basic type expected, not `&`\n/tmp/tmpgy5wg6dc.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpgy5wg6dc.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpgy5wg6dc.d(84): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpgy5wg6dc.d(85): Error: found `{` when expecting `)`\n/tmp/tmpgy5wg6dc.d(96): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgy5wg6dc.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto &kv : dict)\n    {\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpgy5wg6dc.d(25): Error: basic type expected, not `&`\n/tmp/tmpgy5wg6dc.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpgy5wg6dc.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpgy5wg6dc.d(84): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpgy5wg6dc.d(85): Error: found `{` when expecting `)`\n/tmp/tmpgy5wg6dc.d(96): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgy5wg6dc.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict)\n    {\n        if (std::isupper(kv.first[0]))\n            return false;\n        if (std::islower(kv.first[0]))\n            continue;\n        return false;\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpte6t7q_y.d(25): Error: basic type expected, not `&`\n/tmp/tmpte6t7q_y.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpte6t7q_y.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpte6t7q_y.d(27): Error: found `:` when expecting `)`\n/tmp/tmpte6t7q_y.d(27): Error: found `:` instead of statement\n/tmp/tmpte6t7q_y.d(29): Error: found `:` when expecting `)`\n/tmp/tmpte6t7q_y.d(29): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpte6t7q_y.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpxxeyy248.d(24): Error: basic type expected, not `&`\n/tmp/tmpxxeyy248.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpxxeyy248.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpxxeyy248.d(58): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpxxeyy248.d(59): Error: found `{` when expecting `)`\n/tmp/tmpxxeyy248.d(70): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxxeyy248.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto &kv : dict) {\n        if (std::isupper(kv.first[0])) return false;\n        if (std::islower(kv.first[0])) return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpzbfmby8y.d(24): Error: basic type expected, not `&`\n/tmp/tmpzbfmby8y.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpzbfmby8y.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpzbfmby8y.d(25): Error: found `:` when expecting `)`\n/tmp/tmpzbfmby8y.d(25): Error: found `:` instead of statement\n/tmp/tmpzbfmby8y.d(26): Error: found `:` when expecting `)`\n/tmp/tmpzbfmby8y.d(26): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzbfmby8y.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict) {\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpm3evomm_.d(25): Error: basic type expected, not `&`\n/tmp/tmpm3evomm_.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpm3evomm_.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpm3evomm_.d(83): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpm3evomm_.d(84): Error: found `{` when expecting `)`\n/tmp/tmpm3evomm_.d(95): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm3evomm_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (kv.first.isNull()) return false;\n        if (kv.first.is<string>()) {\n            if (kv.first.unwrap().isLower()) continue;\n            else return false;\n        }\n        else if (kv.first.is<string>()) {\n            if (kv.first.unwrap().isUpper()) continue;\n            else return false;\n        }\n        else return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmp_d8n7m5a.d(24): Error: basic type expected, not `&`\n/tmp/tmp_d8n7m5a.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmp_d8n7m5a.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmp_d8n7m5a.d(26): Error: identifier expected following `.`, not `is`\n/tmp/tmp_d8n7m5a.d(26): Error: found `>` when expecting `)`\n/tmp/tmp_d8n7m5a.d(26): Error: expression expected, not `)`\n/tmp/tmp_d8n7m5a.d(26): Error: found `{` when expecting `;` following statement\n/tmp/tmp_d8n7m5a.d(30): Error: found `else` without a corresponding `if`, `version` or `debug` statement\n/tmp/tmp_d8n7m5a.d(32): Error: found `else` without a corresponding `if`, `version` or `debug` statement\n/tmp/tmp_d8n7m5a.d(34): Error: declaration expected, not `else`\n/tmp/tmp_d8n7m5a.d(35): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_d8n7m5a.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict) {\n        if (std::isupper(kv.first[0]))\n            return false;\n        if (std::islower(kv.first[0]))\n            continue;\n        return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpe76kaeav.d(25): Error: basic type expected, not `&`\n/tmp/tmpe76kaeav.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpe76kaeav.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpe76kaeav.d(26): Error: found `:` when expecting `)`\n/tmp/tmpe76kaeav.d(26): Error: found `:` instead of statement\n/tmp/tmpe76kaeav.d(28): Error: found `:` when expecting `)`\n/tmp/tmpe76kaeav.d(28): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe76kaeav.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull() || kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpvnvrwj74.d(25): Error: basic type expected, not `&`\n/tmp/tmpvnvrwj74.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpvnvrwj74.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpvnvrwj74.d(28): Error: basic type expected, not `&`\n/tmp/tmpvnvrwj74.d(28): Error: no identifier for declarator `_error_`\n/tmp/tmpvnvrwj74.d(28): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpvnvrwj74.d(31): Error: basic type expected, not `&`\n/tmp/tmpvnvrwj74.d(31): Error: no identifier for declarator `_error_`\n/tmp/tmpvnvrwj74.d(31): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpvnvrwj74.d(34): Error: basic type expected, not `&`\n/tmp/tmpvnvrwj74.d(34): Error: no identifier for declarator `_error_`\n/tmp/tmpvnvrwj74.d(34): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpvnvrwj74.d(37): Error: basic type expected, not `&`\n/tmp/tmpvnvrwj74.d(37): Error: no identifier for declarator `_error_`\n/tmp/tmpvnvrwj74.d(37): Error:",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict)\n    {\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isStr())\n        {\n            if (kv.first.getStr() == kv.first.getStr().toLower())\n                continue;\n            if (kv.first.getStr() == kv.first.getStr().toUpper())\n                continue;\n            return false;\n        }\n        else\n            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmprytqcnis.d(25): Error: basic type expected, not `&`\n/tmp/tmprytqcnis.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmprytqcnis.d(25): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprytqcnis.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& [k, v] : dict) {\n        if (k.isNull()) return false;\n        if (k.isString()) {\n            if (k.toString() != k.toString().toLower()) return false;\n        }\n        else {\n            if (k.toString() != k.toString().toUpper()) return false;\n        }\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmp33no8s3z.d(24): Error: basic type expected, not `&`\n/tmp/tmp33no8s3z.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmp33no8s3z.d(24): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp33no8s3z.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (std.typecons.isLowerCase(kv.key)) return true;\n        if (std.typecons.isUpperCase(kv.key)) return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpfbnuh1uw.d(24): Error: basic type expected, not `&`\n/tmp/tmpfbnuh1uw.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpfbnuh1uw.d(24): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfbnuh1uw.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto &kv : dict) {\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpb8q0h3ok.d(24): Error: basic type expected, not `&`\n/tmp/tmpb8q0h3ok.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpb8q0h3ok.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpb8q0h3ok.d(58): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpb8q0h3ok.d(59): Error: found `{` when expecting `)`\n/tmp/tmpb8q0h3ok.d(70): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb8q0h3ok.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict) {\n        if (std::isupper(kv.first[0]))\n            return false;\n        if (std::islower(kv.first[0]))\n            return true;\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmp7qanbnj8.d(25): Error: basic type expected, not `&`\n/tmp/tmp7qanbnj8.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmp7qanbnj8.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmp7qanbnj8.d(26): Error: found `:` when expecting `)`\n/tmp/tmp7qanbnj8.d(26): Error: found `:` instead of statement\n/tmp/tmp7qanbnj8.d(28): Error: found `:` when expecting `)`\n/tmp/tmp7qanbnj8.d(28): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7qanbnj8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict)\n    {\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpeuhtdspd.d(25): Error: basic type expected, not `&`\n/tmp/tmpeuhtdspd.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpeuhtdspd.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpeuhtdspd.d(84): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpeuhtdspd.d(85): Error: found `{` when expecting `)`\n/tmp/tmpeuhtdspd.d(96): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeuhtdspd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& x : dict)\n        if (x.key.isNull()) return false;\n    for (auto& x : dict)\n        if (x.key.isNull()) return false;\n    for (auto& x : dict)\n        if (x.key.isNull()) return false;\n    for (auto& x : dict)\n        if (x.key.isNull()) return false;\n    for (auto& x : dict)\n        if (x.key.isNull()) return false;\n    for (auto& x : dict)\n        if (x.key.isNull()) return false;\n    for (auto& x : dict)\n        if (x.key.isNull()) return false;\n    for (auto& x : dict)\n        if (x.key.isNull()) return false;\n    for (auto& x : dict)\n        if (x.key.isNull()) return false;\n    for (auto& x : dict)\n        if (x.key.isNull()) return false;\n    for (auto& x : dict)\n        if (x.key.isNull()) return false;\n    for (auto& x : dict)\n        if (x.key.isNull()) return false;\n    for (auto& x : dict)\n        if (x.key.isNull()) return false;\n    for (auto& x : dict)\n        if (x.key.isNull()) return false;\n    for (auto& x : dict)\n        if (x.key.isNull()) return false;\n    for (auto& x : dict)\n        if (x.key.isNull()) return false;\n    for (auto& x : dict)\n        if (x.key.isNull()) return false;\n    for (auto& x : dict)\n        if (x.key.isNull()) return false;\n    for (auto& x : dict)\n        if (x.key.isNull()) return false;\n    for (auto& x : dict)\n        if (x.key.isNull()) return false;\n    for (auto& x : dict)\n        if (x.key.is\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpi0agwawa.d(24): Error: basic type expected, not `&`\n/tmp/tmpi0agwawa.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpi0agwawa.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpi0agwawa.d(26): Error: basic type expected, not `&`\n/tmp/tmpi0agwawa.d(26): Error: no identifier for declarator `_error_`\n/tmp/tmpi0agwawa.d(26): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpi0agwawa.d(28): Error: basic type expected, not `&`\n/tmp/tmpi0agwawa.d(28): Error: no identifier for declarator `_error_`\n/tmp/tmpi0agwawa.d(28): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpi0agwawa.d(30): Error: basic type expected, not `&`\n/tmp/tmpi0agwawa.d(30): Error: no identifier for declarator `_error_`\n/tmp/tmpi0agwawa.d(30): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpi0agwawa.d(32): Error: basic type expected, not `&`\n/tmp/tmpi0agwawa.d(32): Error: no identifier for declarator `_error_`\n/tmp/tmpi0agwawa.d(32): Error:",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto &kv : dict) {\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isString()) {\n            if (kv.first.asString() != kv.first.asString().toLower())\n                return false;\n        }\n        else if (kv.first.isString()) {\n            if (kv.first.asString() != kv.first.asString().toUpper())\n                return false;\n        }\n        else\n            return false;\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpupyw0779.d(25): Error: basic type expected, not `&`\n/tmp/tmpupyw0779.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpupyw0779.d(25): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpupyw0779.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict)\n    {\n        if (std::isupper(kv.first[0]))\n            return false;\n        if (std::islower(kv.first[0]))\n            return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmp2gnungat.d(25): Error: basic type expected, not `&`\n/tmp/tmp2gnungat.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmp2gnungat.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmp2gnungat.d(27): Error: found `:` when expecting `)`\n/tmp/tmp2gnungat.d(27): Error: found `:` instead of statement\n/tmp/tmp2gnungat.d(29): Error: found `:` when expecting `)`\n/tmp/tmp2gnungat.d(29): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2gnungat.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (std.typecons.isLowerCase(kv.key)) return true;\n        if (std.typecons.isUpperCase(kv.key)) return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpfbnuh1uw.d(24): Error: basic type expected, not `&`\n/tmp/tmpfbnuh1uw.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpfbnuh1uw.d(24): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfbnuh1uw.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto &kv : dict) {\n        if (kv.first.isNull()) return false;\n        if (kv.first.isStr()) {\n            if (kv.first.getStr() != kv.first.getStr().toLower()) return false;\n        } else {\n            if (kv.first.getStr() != kv.first.getStr().toUpper()) return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmp3py37ca7.d(24): Error: basic type expected, not `&`\n/tmp/tmp3py37ca7.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmp3py37ca7.d(24): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3py37ca7.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict)\n    {\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.is<string>())\n        {\n            if (kv.first.as<string>().isUpper())\n                return false;\n        }\n        else if (kv.first.is<long>())\n        {\n            if (kv.first.as<long>() > 0)\n                return false;\n        }\n        else\n            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpkr16ihvy.d(25): Error: basic type expected, not `&`\n/tmp/tmpkr16ihvy.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpkr16ihvy.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpkr16ihvy.d(29): Error: identifier expected following `.`, not `is`\n/tmp/tmpkr16ihvy.d(29): Error: found `>` when expecting `)`\n/tmp/tmpkr16ihvy.d(29): Error: expression expected, not `)`\n/tmp/tmpkr16ihvy.d(30): Error: found `{` when expecting `;` following statement\n/tmp/tmpkr16ihvy.d(31): Error: found `>` when expecting `)`\n/tmp/tmpkr16ihvy.d(31): Error: expression expected, not `)`\n/tmp/tmpkr16ihvy.d(32): Error: found `return` when expecting `;` following statement\n/tmp/tmpkr16ihvy.d(34): Error: found `else` without a corresponding `if`, `version` or `debug` statement\n/tmp/tmpkr16ihvy.d(39): Error: declaration expected, not `else`\n/tmp/tmpkr16ihvy.d(41): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkr16ihvy.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto &kv : dict)\n    {\n        if (std.typecons.isLowerCase(kv.key))\n            continue;\n        if (std.typecons.isUpperCase(kv.key))\n            continue;\n        return false;\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpnxa1t7ba.d(25): Error: basic type expected, not `&`\n/tmp/tmpnxa1t7ba.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpnxa1t7ba.d(25): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnxa1t7ba.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto &kv : dict)\n    {\n        if (std::isupper(kv.first[0]))\n            return false;\n        if (std::islower(kv.first[0]))\n            return true;\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpvzc6xe6_.d(25): Error: basic type expected, not `&`\n/tmp/tmpvzc6xe6_.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpvzc6xe6_.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpvzc6xe6_.d(27): Error: found `:` when expecting `)`\n/tmp/tmpvzc6xe6_.d(27): Error: found `:` instead of statement\n/tmp/tmpvzc6xe6_.d(29): Error: found `:` when expecting `)`\n/tmp/tmpvzc6xe6_.d(29): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvzc6xe6_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (std.typecons.isLowerCase(kv.first)) return true;\n        if (std.typecons.isUpperCase(kv.first)) return false;\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmp6zrgc0o1.d(24): Error: basic type expected, not `&`\n/tmp/tmp6zrgc0o1.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmp6zrgc0o1.d(24): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6zrgc0o1.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull() || kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull())\n            return false;\n    for (auto &kv : dict)\n\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpvnvrwj74.d(25): Error: basic type expected, not `&`\n/tmp/tmpvnvrwj74.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpvnvrwj74.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpvnvrwj74.d(28): Error: basic type expected, not `&`\n/tmp/tmpvnvrwj74.d(28): Error: no identifier for declarator `_error_`\n/tmp/tmpvnvrwj74.d(28): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpvnvrwj74.d(31): Error: basic type expected, not `&`\n/tmp/tmpvnvrwj74.d(31): Error: no identifier for declarator `_error_`\n/tmp/tmpvnvrwj74.d(31): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpvnvrwj74.d(34): Error: basic type expected, not `&`\n/tmp/tmpvnvrwj74.d(34): Error: no identifier for declarator `_error_`\n/tmp/tmpvnvrwj74.d(34): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpvnvrwj74.d(37): Error: basic type expected, not `&`\n/tmp/tmpvnvrwj74.d(37): Error: no identifier for declarator `_error_`\n/tmp/tmpvnvrwj74.d(37): Error:",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& key : dict)\n    {\n        if (std::isupper(key.first[0]))\n            return false;\n        if (std::islower(key.first[0]))\n            return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmp49174_2c.d(25): Error: basic type expected, not `&`\n/tmp/tmp49174_2c.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmp49174_2c.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmp49174_2c.d(27): Error: found `:` when expecting `)`\n/tmp/tmp49174_2c.d(27): Error: found `:` instead of statement\n/tmp/tmp49174_2c.d(29): Error: found `:` when expecting `)`\n/tmp/tmp49174_2c.d(29): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp49174_2c.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto &kv : dict)\n    {\n        if (std.typecons.isLowerCase(kv.key))\n            continue;\n        if (std.typecons.isUpperCase(kv.key))\n            continue;\n        return false;\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpnxa1t7ba.d(25): Error: basic type expected, not `&`\n/tmp/tmpnxa1t7ba.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpnxa1t7ba.d(25): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnxa1t7ba.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpxxeyy248.d(24): Error: basic type expected, not `&`\n/tmp/tmpxxeyy248.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpxxeyy248.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpxxeyy248.d(58): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpxxeyy248.d(59): Error: found `{` when expecting `)`\n/tmp/tmpxxeyy248.d(70): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxxeyy248.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& k : dict.get())\n        if (std::isupper(k.first[0]) || std::islower(k.first[0]))\n            return false;\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpxpff_wio.d(25): Error: basic type expected, not `&`\n/tmp/tmpxpff_wio.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpxpff_wio.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpxpff_wio.d(26): Error: found `:` when expecting `)`\n/tmp/tmpxpff_wio.d(26): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxpff_wio.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict) {\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpm3evomm_.d(25): Error: basic type expected, not `&`\n/tmp/tmpm3evomm_.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpm3evomm_.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpm3evomm_.d(83): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpm3evomm_.d(84): Error: found `{` when expecting `)`\n/tmp/tmpm3evomm_.d(95): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm3evomm_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (std::isupper(kv.first[0])) return false;\n        if (std::islower(kv.first[0])) return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpf11c6r_9.d(24): Error: basic type expected, not `&`\n/tmp/tmpf11c6r_9.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpf11c6r_9.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpf11c6r_9.d(25): Error: found `:` when expecting `)`\n/tmp/tmpf11c6r_9.d(25): Error: found `:` instead of statement\n/tmp/tmpf11c6r_9.d(26): Error: found `:` when expecting `)`\n/tmp/tmpf11c6r_9.d(26): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf11c6r_9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (std::isupper(kv.first[0])) return false;\n        if (std::islower(kv.first[0])) return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpf11c6r_9.d(24): Error: basic type expected, not `&`\n/tmp/tmpf11c6r_9.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpf11c6r_9.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpf11c6r_9.d(25): Error: found `:` when expecting `)`\n/tmp/tmpf11c6r_9.d(25): Error: found `:` instead of statement\n/tmp/tmpf11c6r_9.d(26): Error: found `:` when expecting `)`\n/tmp/tmpf11c6r_9.d(26): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf11c6r_9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& key : dict)\n    {\n        if (key.isNull())\n            return false;\n        if (key.isString())\n        {\n            if (key.toString().toLower() != key.toString().toUpper())\n                return false;\n        }\n        else\n            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmplauy2_gs.d(25): Error: basic type expected, not `&`\n/tmp/tmplauy2_gs.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmplauy2_gs.d(25): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplauy2_gs.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict) {\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpm3evomm_.d(25): Error: basic type expected, not `&`\n/tmp/tmpm3evomm_.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpm3evomm_.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpm3evomm_.d(83): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpm3evomm_.d(84): Error: found `{` when expecting `)`\n/tmp/tmpm3evomm_.d(95): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm3evomm_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto &kv : dict)\n        if (kv.first.length() != kv.second.length())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.length() != kv.second.length())\n            return false;\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpeziogeej.d(25): Error: basic type expected, not `&`\n/tmp/tmpeziogeej.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpeziogeej.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpeziogeej.d(28): Error: basic type expected, not `&`\n/tmp/tmpeziogeej.d(28): Error: no identifier for declarator `_error_`\n/tmp/tmpeziogeej.d(28): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeziogeej.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict) {\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpm3evomm_.d(25): Error: basic type expected, not `&`\n/tmp/tmpm3evomm_.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpm3evomm_.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpm3evomm_.d(83): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpm3evomm_.d(84): Error: found `{` when expecting `)`\n/tmp/tmpm3evomm_.d(95): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm3evomm_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto &kv : dict) {\n        if (kv.first.isNull()) return false;\n        if (kv.first.is<string>()) {\n            if (kv.first.unbox<string>() == kv.first.unbox<string>().toLower()) return true;\n            else return false;\n        }\n        else if (kv.first.is<string>()) {\n            if (kv.first.unbox<string>() == kv.first.unbox<string>().toUpper()) return true;\n            else return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpke6g9igu.d(24): Error: basic type expected, not `&`\n/tmp/tmpke6g9igu.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpke6g9igu.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpke6g9igu.d(26): Error: identifier expected following `.`, not `is`\n/tmp/tmpke6g9igu.d(26): Error: found `>` when expecting `)`\n/tmp/tmpke6g9igu.d(26): Error: expression expected, not `)`\n/tmp/tmpke6g9igu.d(26): Error: found `{` when expecting `;` following statement\n/tmp/tmpke6g9igu.d(27): Error: found `>` when expecting `)`\n/tmp/tmpke6g9igu.d(27): Error: expression expected, not `)`\n/tmp/tmpke6g9igu.d(27): Error: found `<` when expecting `)`\n/tmp/tmpke6g9igu.d(27): Error: found `string` when expecting `;` following statement\n/tmp/tmpke6g9igu.d(27): Error: found `>` instead of statement\n/tmp/tmpke6g9igu.d(28): Error: found `else` without a corresponding `if`, `version` or `debug` statement\n/tmp/tmpke6g9igu.d(30): Error: found `else` without a corresponding `if`, `version` or `debug` statem",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto &kv : dict) {\n        if (std.typecons.isLowerCase(kv.first)) return true;\n        if (std.typecons.isUpperCase(kv.first)) return false;\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpp95ouujm.d(24): Error: basic type expected, not `&`\n/tmp/tmpp95ouujm.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpp95ouujm.d(24): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp95ouujm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto key : dict.keys())\n        if (key.isNull())\n            return false;\n    for (auto key : dict.keys())\n        if (key.isNull())\n            return false;\n    for (auto key : dict.keys())\n        if (key.isNull())\n            return false;\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpxzs4koy3.d(25): Error: no identifier for declarator `key`\n/tmp/tmpxzs4koy3.d(25): Error: expression expected, not `:`\n/tmp/tmpxzs4koy3.d(25): Error: found `dict` when expecting `;` following `for` condition\n/tmp/tmpxzs4koy3.d(28): Error: no identifier for declarator `key`\n/tmp/tmpxzs4koy3.d(28): Error: expression expected, not `:`\n/tmp/tmpxzs4koy3.d(28): Error: found `dict` when expecting `;` following `for` condition\n/tmp/tmpxzs4koy3.d(31): Error: no identifier for declarator `key`\n/tmp/tmpxzs4koy3.d(31): Error: expression expected, not `:`\n/tmp/tmpxzs4koy3.d(31): Error: found `dict` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxzs4koy3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict) {\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpm3evomm_.d(25): Error: basic type expected, not `&`\n/tmp/tmpm3evomm_.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpm3evomm_.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpm3evomm_.d(83): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpm3evomm_.d(84): Error: found `{` when expecting `)`\n/tmp/tmpm3evomm_.d(95): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm3evomm_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (kv.key.isNull()) return false;\n        if (kv.key.isStr()) {\n            if (kv.key.toStr().toLower() != kv.key.toStr().toUpper()) return false;\n        }\n        else return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmp1_ski4ab.d(24): Error: basic type expected, not `&`\n/tmp/tmp1_ski4ab.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmp1_ski4ab.d(24): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1_ski4ab.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto &kv : dict)\n    {\n        if (std::isupper(kv.first[0]))\n            return false;\n        if (std::islower(kv.first[0]))\n            return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmp_6_u5_hv.d(25): Error: basic type expected, not `&`\n/tmp/tmp_6_u5_hv.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmp_6_u5_hv.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmp_6_u5_hv.d(27): Error: found `:` when expecting `)`\n/tmp/tmp_6_u5_hv.d(27): Error: found `:` instead of statement\n/tmp/tmp_6_u5_hv.d(29): Error: found `:` when expecting `)`\n/tmp/tmp_6_u5_hv.d(29): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_6_u5_hv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict)\n    {\n        if (kv.first.isNull()) return false;\n        if (kv.first.isString())\n        {\n            if (kv.first.asString() != kv.first.asString().toLower()) return false;\n        }\n        else if (kv.first.isString())\n        {\n            if (kv.first.asString() != kv.first.asString().toUpper()) return false;\n        }\n        else return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmp2nw6tdel.d(24): Error: basic type expected, not `&`\n/tmp/tmp2nw6tdel.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmp2nw6tdel.d(24): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2nw6tdel.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto key : dict)\n        if (std.typecons.isLowerCase(key) != std.typecons.isUpperCase(key))\n            return false;\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpa8wns1x_.d(25): Error: no identifier for declarator `key`\n/tmp/tmpa8wns1x_.d(25): Error: expression expected, not `:`\n/tmp/tmpa8wns1x_.d(25): Error: found `dict` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa8wns1x_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (kv.first.isNull()) return false;\n        if (kv.first.isStr()) {\n            if (kv.first.toStr().toLower() != kv.first.toStr().toUpper()) return false;\n        }\n        else {\n            return false;\n        }\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpcnt0p8jc.d(24): Error: basic type expected, not `&`\n/tmp/tmpcnt0p8jc.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpcnt0p8jc.d(24): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcnt0p8jc.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& [key, value] : dict) {\n        if (key.isNull()) return false;\n        if (key.isLowerCase()) return true;\n        if (key.isUpperCase()) return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpnk4lmt6d.d(24): Error: basic type expected, not `&`\n/tmp/tmpnk4lmt6d.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpnk4lmt6d.d(24): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnk4lmt6d.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto &kv : dict.nonNull()) {\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpa661jfo9.d(24): Error: basic type expected, not `&`\n/tmp/tmpa661jfo9.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpa661jfo9.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpa661jfo9.d(58): Error: expression expected, not `unittest`\n/tmp/tmpa661jfo9.d(59): Error: found `{` when expecting `)`\n/tmp/tmpa661jfo9.d(70): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa661jfo9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& k : dict) {\n        if (std::isupper(k.first[0])) return false;\n        if (std::islower(k.first[0])) return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmp1wk3s_ad.d(24): Error: basic type expected, not `&`\n/tmp/tmp1wk3s_ad.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmp1wk3s_ad.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmp1wk3s_ad.d(25): Error: found `:` when expecting `)`\n/tmp/tmp1wk3s_ad.d(25): Error: found `:` instead of statement\n/tmp/tmp1wk3s_ad.d(26): Error: found `:` when expecting `)`\n/tmp/tmp1wk3s_ad.d(26): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1wk3s_ad.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (kv.first.isNull()) return false;\n        if (kv.first.isStr()) {\n            if (kv.first.getStr() != kv.first.getStr().toLower()) return false;\n        }\n        else {\n            if (kv.first.getStr() != kv.first.getStr().toUpper()) return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmp105kcf1_.d(24): Error: basic type expected, not `&`\n/tmp/tmp105kcf1_.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmp105kcf1_.d(24): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp105kcf1_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (std::isupper(kv.first[0])) return false;\n        if (std::islower(kv.first[0])) return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpf11c6r_9.d(24): Error: basic type expected, not `&`\n/tmp/tmpf11c6r_9.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpf11c6r_9.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpf11c6r_9.d(25): Error: found `:` when expecting `)`\n/tmp/tmpf11c6r_9.d(25): Error: found `:` instead of statement\n/tmp/tmpf11c6r_9.d(26): Error: found `:` when expecting `)`\n/tmp/tmpf11c6r_9.d(26): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf11c6r_9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict) {\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isString()) {\n            if (kv.first.asString() != kv.first.asString().toLower())\n                return false;\n        }\n        else {\n            if (kv.first.asString() != kv.first.asString().toUpper())\n                return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpxr6gtpo7.d(25): Error: basic type expected, not `&`\n/tmp/tmpxr6gtpo7.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpxr6gtpo7.d(25): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxr6gtpo7.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict)\n    {\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpeuhtdspd.d(25): Error: basic type expected, not `&`\n/tmp/tmpeuhtdspd.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpeuhtdspd.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpeuhtdspd.d(84): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpeuhtdspd.d(85): Error: found `{` when expecting `)`\n/tmp/tmpeuhtdspd.d(96): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeuhtdspd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (std::isupper(kv.first[0])) return false;\n        if (std::islower(kv.first[0])) return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpf11c6r_9.d(24): Error: basic type expected, not `&`\n/tmp/tmpf11c6r_9.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpf11c6r_9.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpf11c6r_9.d(25): Error: found `:` when expecting `)`\n/tmp/tmpf11c6r_9.d(25): Error: found `:` instead of statement\n/tmp/tmpf11c6r_9.d(26): Error: found `:` when expecting `)`\n/tmp/tmpf11c6r_9.d(26): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf11c6r_9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict) {\n        if (std::isupper(kv.first[0]))\n            return false;\n        if (std::islower(kv.first[0]))\n            return true;\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmp7qanbnj8.d(25): Error: basic type expected, not `&`\n/tmp/tmp7qanbnj8.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmp7qanbnj8.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmp7qanbnj8.d(26): Error: found `:` when expecting `)`\n/tmp/tmp7qanbnj8.d(26): Error: found `:` instead of statement\n/tmp/tmp7qanbnj8.d(28): Error: found `:` when expecting `)`\n/tmp/tmp7qanbnj8.d(28): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7qanbnj8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict)\n        if (kv.first.length() != kv.second.length())\n            return false;\n    for (auto& kv : dict)\n        if (kv.first.length() != kv.second.length())\n            return false;\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmp2z0z7au3.d(25): Error: basic type expected, not `&`\n/tmp/tmp2z0z7au3.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmp2z0z7au3.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmp2z0z7au3.d(28): Error: basic type expected, not `&`\n/tmp/tmp2z0z7au3.d(28): Error: no identifier for declarator `_error_`\n/tmp/tmp2z0z7au3.d(28): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2z0z7au3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict) {\n        if (kv.key.isNull())\n            return false;\n        if (kv.key.is<string>()) {\n            if (kv.key.get<string>().isLower())\n                continue;\n            else\n                return false;\n        }\n        else if (kv.key.is<string>()) {\n            if (kv.key.get<string>().isUpper())\n                continue;\n            else\n                return false;\n        }\n        else\n            return false;\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmp85hpa8cs.d(25): Error: basic type expected, not `&`\n/tmp/tmp85hpa8cs.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmp85hpa8cs.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmp85hpa8cs.d(28): Error: identifier expected following `.`, not `is`\n/tmp/tmp85hpa8cs.d(28): Error: found `>` when expecting `)`\n/tmp/tmp85hpa8cs.d(28): Error: expression expected, not `)`\n/tmp/tmp85hpa8cs.d(28): Error: found `{` when expecting `;` following statement\n/tmp/tmp85hpa8cs.d(29): Error: found `>` when expecting `)`\n/tmp/tmp85hpa8cs.d(29): Error: expression expected, not `)`\n/tmp/tmp85hpa8cs.d(30): Error: found `continue` when expecting `;` following statement\n/tmp/tmp85hpa8cs.d(30): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmp85hpa8cs.d(31): Error: found `else` without a corresponding `if`, `version` or `debug` statement\n/tmp/tmp85hpa8cs.d(34): Error: found `else` without a corresponding `if`, `version` or `debug` statement\n/tmp/tmp85hpa8cs.d(37): Error: found ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto &kv : dict) {\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpb8q0h3ok.d(24): Error: basic type expected, not `&`\n/tmp/tmpb8q0h3ok.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpb8q0h3ok.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpb8q0h3ok.d(58): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpb8q0h3ok.d(59): Error: found `{` when expecting `)`\n/tmp/tmpb8q0h3ok.d(70): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb8q0h3ok.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull() || kv.first.isEmpty())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull() || kv.first.isEmpty())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull() || kv.first.isEmpty())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull() || kv.first.isEmpty())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull() || kv.first.isEmpty())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull() || kv.first.isEmpty())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull() || kv.first.isEmpty())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull() || kv.first.isEmpty())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull() || kv.first.isEmpty())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull() || kv.first.isEmpty())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull() || kv.first.isEmpty())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull() || kv.first.isEmpty())\n            return false;\n    for (auto &kv : dict)\n        if (kv.first.isNull() || kv.first.isEmpty())\n            return false;\n    for (auto &kv : dict)\n        if (k\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmprqv6fzgf.d(25): Error: basic type expected, not `&`\n/tmp/tmprqv6fzgf.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmprqv6fzgf.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmprqv6fzgf.d(28): Error: basic type expected, not `&`\n/tmp/tmprqv6fzgf.d(28): Error: no identifier for declarator `_error_`\n/tmp/tmprqv6fzgf.d(28): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmprqv6fzgf.d(31): Error: basic type expected, not `&`\n/tmp/tmprqv6fzgf.d(31): Error: no identifier for declarator `_error_`\n/tmp/tmprqv6fzgf.d(31): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmprqv6fzgf.d(34): Error: basic type expected, not `&`\n/tmp/tmprqv6fzgf.d(34): Error: no identifier for declarator `_error_`\n/tmp/tmprqv6fzgf.d(34): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmprqv6fzgf.d(37): Error: basic type expected, not `&`\n/tmp/tmprqv6fzgf.d(37): Error: no identifier for declarator `_error_`\n/tmp/tmprqv6fzgf.d(37): Error:",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict) {\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpm3evomm_.d(25): Error: basic type expected, not `&`\n/tmp/tmpm3evomm_.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpm3evomm_.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpm3evomm_.d(83): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpm3evomm_.d(84): Error: found `{` when expecting `)`\n/tmp/tmpm3evomm_.d(95): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm3evomm_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict)\n    {\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpeuhtdspd.d(25): Error: basic type expected, not `&`\n/tmp/tmpeuhtdspd.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpeuhtdspd.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpeuhtdspd.d(84): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpeuhtdspd.d(85): Error: found `{` when expecting `)`\n/tmp/tmpeuhtdspd.d(96): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeuhtdspd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict)\n    {\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpeuhtdspd.d(25): Error: basic type expected, not `&`\n/tmp/tmpeuhtdspd.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpeuhtdspd.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpeuhtdspd.d(84): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpeuhtdspd.d(85): Error: found `{` when expecting `)`\n/tmp/tmpeuhtdspd.d(96): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeuhtdspd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (kv.first.isNull()) return false;\n        if (kv.first.isString()) {\n            if (kv.first.asString() != kv.first.asString().toLower()) return false;\n        }\n        else {\n            if (kv.first.asString() != kv.first.asString().toUpper()) return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpmpxswkvg.d(24): Error: basic type expected, not `&`\n/tmp/tmpmpxswkvg.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpmpxswkvg.d(24): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmpxswkvg.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& k : dict)\n    {\n        if (k.isNull())\n            return false;\n        if (k.isString())\n        {\n            if (k.asString() != k.asString().toLower() && k.asString() != k.asString().toUpper())\n                return false;\n        }\n        else\n            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpyx6kctl7.d(25): Error: basic type expected, not `&`\n/tmp/tmpyx6kctl7.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpyx6kctl7.d(25): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyx6kctl7.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& x : dict) {\n        if (x.isNull()) return false;\n        if (x.isNull()) return false;\n        if (x.isNull()) return false;\n        if (x.isNull()) return false;\n        if (x.isNull()) return false;\n        if (x.isNull()) return false;\n        if (x.isNull()) return false;\n        if (x.isNull()) return false;\n        if (x.isNull()) return false;\n        if (x.isNull()) return false;\n        if (x.isNull()) return false;\n        if (x.isNull()) return false;\n        if (x.isNull()) return false;\n        if (x.isNull()) return false;\n        if (x.isNull()) return false;\n        if (x.isNull()) return false;\n        if (x.isNull()) return false;\n        if (x.isNull()) return false;\n        if (x.isNull()) return false;\n        if (x.isNull()) return false;\n        if (x.isNull()) return false;\n        if (x.isNull()) return false;\n        if (x.isNull()) return false;\n        if (x.isNull()) return false;\n        if (x.isNull()) return false;\n        if (x.isNull()) return false;\n        if (x.isNull()) return false;\n        if (x.isNull()) return false;\n        if (x.isNull()) return false;\n        if (x.isNull()) return false;\n        if (x.isNull()) return false;\n        if (x.isNull()) return false;\n        if (x.isNull()) return false;\n        if (x.isNull()) return false;\n        if (x.isNull()) return false;\n        if (x.isNull()) return false;\n        if (x.isNull()) return false;\n        if (x.isNull()) return false;\n        if (x.isNull()) return false;\n        if (x.isNull()) return false;\n        if (x.isNull\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmp4qksht4g.d(24): Error: basic type expected, not `&`\n/tmp/tmp4qksht4g.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmp4qksht4g.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmp4qksht4g.d(66): Error: found `unittest` when expecting `)`\n/tmp/tmp4qksht4g.d(78): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp4qksht4g.d(78): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4qksht4g.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (kv.first.isNull()) return false;\n        if (kv.first.isString()) {\n            if (kv.first.asString().toLower() != kv.first.asString()) return false;\n        } else {\n            if (kv.first.asString().toUpper() != kv.first.asString()) return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpcjcjaazd.d(24): Error: basic type expected, not `&`\n/tmp/tmpcjcjaazd.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpcjcjaazd.d(24): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcjcjaazd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto &kv : dict) {\n        if (kv.first.isNull()) return false;\n        if (kv.first.is_upper()) return false;\n        if (kv.first.is_lower()) return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpy89wm3bz.d(24): Error: basic type expected, not `&`\n/tmp/tmpy89wm3bz.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpy89wm3bz.d(24): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy89wm3bz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (std::isupper(kv.key[0])) return false;\n        if (std::islower(kv.key[0])) return true;\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpueiauis_.d(24): Error: basic type expected, not `&`\n/tmp/tmpueiauis_.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpueiauis_.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpueiauis_.d(25): Error: found `:` when expecting `)`\n/tmp/tmpueiauis_.d(25): Error: found `:` instead of statement\n/tmp/tmpueiauis_.d(26): Error: found `:` when expecting `)`\n/tmp/tmpueiauis_.d(26): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpueiauis_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto &kv : dict) {\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.key.isNull()) return false;\n        if (kv.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpxe5c22ix.d(24): Error: basic type expected, not `&`\n/tmp/tmpxe5c22ix.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpxe5c22ix.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpxe5c22ix.d(58): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpxe5c22ix.d(59): Error: found `{` when expecting `)`\n/tmp/tmpxe5c22ix.d(70): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxe5c22ix.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto key : dict.keys())\n    {\n        if (std::isupper(key[0]))\n            return false;\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmppuhuvo9l.d(25): Error: no identifier for declarator `key`\n/tmp/tmppuhuvo9l.d(25): Error: expression expected, not `:`\n/tmp/tmppuhuvo9l.d(25): Error: found `dict` when expecting `;` following `for` condition\n/tmp/tmppuhuvo9l.d(27): Error: found `:` when expecting `)`\n/tmp/tmppuhuvo9l.d(27): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppuhuvo9l.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict) {\n        if (std::isupper(kv.first[0]))\n            return false;\n        if (std::islower(kv.first[0]))\n            return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpqpod3zkd.d(25): Error: basic type expected, not `&`\n/tmp/tmpqpod3zkd.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpqpod3zkd.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpqpod3zkd.d(26): Error: found `:` when expecting `)`\n/tmp/tmpqpod3zkd.d(26): Error: found `:` instead of statement\n/tmp/tmpqpod3zkd.d(28): Error: found `:` when expecting `)`\n/tmp/tmpqpod3zkd.d(28): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqpod3zkd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict) {\n        if (std::isupper(kv.first[0]))\n            return false;\n        if (std::islower(kv.first[0]))\n            return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpqpod3zkd.d(25): Error: basic type expected, not `&`\n/tmp/tmpqpod3zkd.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpqpod3zkd.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpqpod3zkd.d(26): Error: found `:` when expecting `)`\n/tmp/tmpqpod3zkd.d(26): Error: found `:` instead of statement\n/tmp/tmpqpod3zkd.d(28): Error: found `:` when expecting `)`\n/tmp/tmpqpod3zkd.d(28): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqpod3zkd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto &kv : dict) {\n        if (kv.first.isNull()) return false;\n        if (kv.first.isStr()) {\n            if (kv.first.asStr() != kv.first.asStr().toLower()) return false;\n        } else {\n            if (kv.first.asStr() != kv.first.asStr().toUpper()) return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpcdccnwt_.d(24): Error: basic type expected, not `&`\n/tmp/tmpcdccnwt_.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpcdccnwt_.d(24): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcdccnwt_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto k : dict)\n    {\n        if (std.typecons.isLowerCase(k)) return true;\n        if (std.typecons.isUpperCase(k)) return false;\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpzum231x7.d(24): Error: no identifier for declarator `k`\n/tmp/tmpzum231x7.d(24): Error: expression expected, not `:`\n/tmp/tmpzum231x7.d(24): Error: found `dict` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzum231x7.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& key : dict.nonNull())\n    {\n        if (std::isupper(key.first[0]))\n            return false;\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmp2tpry5l7.d(25): Error: basic type expected, not `&`\n/tmp/tmp2tpry5l7.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmp2tpry5l7.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmp2tpry5l7.d(27): Error: found `:` when expecting `)`\n/tmp/tmp2tpry5l7.d(27): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2tpry5l7.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpxxeyy248.d(24): Error: basic type expected, not `&`\n/tmp/tmpxxeyy248.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpxxeyy248.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpxxeyy248.d(58): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpxxeyy248.d(59): Error: found `{` when expecting `)`\n/tmp/tmpxxeyy248.d(70): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxxeyy248.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto k : dict.keys())\n    {\n        if (k.isNull()) return false;\n        if (k.isUpper()) return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmp62k7dhsu.d(24): Error: no identifier for declarator `k`\n/tmp/tmp62k7dhsu.d(24): Error: expression expected, not `:`\n/tmp/tmp62k7dhsu.d(24): Error: found `dict` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp62k7dhsu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto &kv : dict)\n    {\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpgy5wg6dc.d(25): Error: basic type expected, not `&`\n/tmp/tmpgy5wg6dc.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpgy5wg6dc.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpgy5wg6dc.d(84): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpgy5wg6dc.d(85): Error: found `{` when expecting `)`\n/tmp/tmpgy5wg6dc.d(96): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgy5wg6dc.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto &kv : dict)\n    {\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpgy5wg6dc.d(25): Error: basic type expected, not `&`\n/tmp/tmpgy5wg6dc.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpgy5wg6dc.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpgy5wg6dc.d(84): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpgy5wg6dc.d(85): Error: found `{` when expecting `)`\n/tmp/tmpgy5wg6dc.d(96): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgy5wg6dc.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (std::isupper(kv.first[0])) return false;\n        if (std::islower(kv.first[0])) return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpf11c6r_9.d(24): Error: basic type expected, not `&`\n/tmp/tmpf11c6r_9.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpf11c6r_9.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpf11c6r_9.d(25): Error: found `:` when expecting `)`\n/tmp/tmpf11c6r_9.d(25): Error: found `:` instead of statement\n/tmp/tmpf11c6r_9.d(26): Error: found `:` when expecting `)`\n/tmp/tmpf11c6r_9.d(26): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf11c6r_9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto &kv : dict) {\n        if (std.typecons.isLowerCase(kv.key)) return true;\n        if (std.typecons.isUpperCase(kv.key)) return false;\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpmu7hte_4.d(24): Error: basic type expected, not `&`\n/tmp/tmpmu7hte_4.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpmu7hte_4.d(24): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmu7hte_4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto &kv : dict.nonNull())\n    {\n        if (std.isLowerCase(kv.first))\n            continue;\n        if (std.isUpperCase(kv.first))\n            continue;\n        return false;\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmp7rf05y62.d(25): Error: basic type expected, not `&`\n/tmp/tmp7rf05y62.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmp7rf05y62.d(25): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7rf05y62.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto &kv : dict) {\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpb8q0h3ok.d(24): Error: basic type expected, not `&`\n/tmp/tmpb8q0h3ok.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpb8q0h3ok.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpb8q0h3ok.d(58): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpb8q0h3ok.d(59): Error: found `{` when expecting `)`\n/tmp/tmpb8q0h3ok.d(70): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb8q0h3ok.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto &kv : dict) {\n        if (std.typecons.isLowerCase(kv.key)) return true;\n        if (std.typecons.isUpperCase(kv.key)) return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpkglzdv1q.d(24): Error: basic type expected, not `&`\n/tmp/tmpkglzdv1q.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpkglzdv1q.d(24): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkglzdv1q.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& [k, v] : dict) {\n        if (std::isupper(k[0])) return false;\n        if (std::islower(k[0])) return true;\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpleconjj_.d(24): Error: basic type expected, not `&`\n/tmp/tmpleconjj_.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpleconjj_.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpleconjj_.d(25): Error: found `:` when expecting `)`\n/tmp/tmpleconjj_.d(25): Error: found `:` instead of statement\n/tmp/tmpleconjj_.d(26): Error: found `:` when expecting `)`\n/tmp/tmpleconjj_.d(26): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpleconjj_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict)\n    {\n        if (kv.key.isNull())\n            return false;\n        if (kv.key.isNull())\n            return false;\n        if (kv.key.isNull())\n            return false;\n        if (kv.key.isNull())\n            return false;\n        if (kv.key.isNull())\n            return false;\n        if (kv.key.isNull())\n            return false;\n        if (kv.key.isNull())\n            return false;\n        if (kv.key.isNull())\n            return false;\n        if (kv.key.isNull())\n            return false;\n        if (kv.key.isNull())\n            return false;\n        if (kv.key.isNull())\n            return false;\n        if (kv.key.isNull())\n            return false;\n        if (kv.key.isNull())\n            return false;\n        if (kv.key.isNull())\n            return false;\n        if (kv.key.isNull())\n            return false;\n        if (kv.key.isNull())\n            return false;\n        if (kv.key.isNull())\n            return false;\n        if (kv.key.isNull())\n            return false;\n        if (kv.key.isNull())\n            return false;\n        if (kv.key.isNull())\n            return false;\n        if (kv.key.isNull())\n            return false;\n        if (kv.key.isNull())\n            return false;\n        if (kv.key.isNull())\n            return false;\n        if (kv.key.isNull())\n            return false;\n        if (kv.key.isNull())\n            return false;\n        if (kv.key.isNull())\n            return false;\n        if (kv.key.isNull())\n            return false;\n        if (kv.key.isNull())\n            return false;\n        if (kv.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpr3836yix.d(25): Error: basic type expected, not `&`\n/tmp/tmpr3836yix.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpr3836yix.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpr3836yix.d(84): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpr3836yix.d(85): Error: found `{` when expecting `)`\n/tmp/tmpr3836yix.d(96): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpr3836yix.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& x : dict) {\n        if (x.first.isNull()) return false;\n        if (x.first.isString()) {\n            if (x.first.asString().toLower() != x.first.asString().toUpper()) return false;\n        } else {\n            return false;\n        }\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmp84yy67h2.d(24): Error: basic type expected, not `&`\n/tmp/tmp84yy67h2.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmp84yy67h2.d(24): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp84yy67h2.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (std::isupper(kv.first[0])) return false;\n        if (std::islower(kv.first[0])) return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpf11c6r_9.d(24): Error: basic type expected, not `&`\n/tmp/tmpf11c6r_9.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpf11c6r_9.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpf11c6r_9.d(25): Error: found `:` when expecting `)`\n/tmp/tmpf11c6r_9.d(25): Error: found `:` instead of statement\n/tmp/tmpf11c6r_9.d(26): Error: found `:` when expecting `)`\n/tmp/tmpf11c6r_9.d(26): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf11c6r_9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpxxeyy248.d(24): Error: basic type expected, not `&`\n/tmp/tmpxxeyy248.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpxxeyy248.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpxxeyy248.d(58): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpxxeyy248.d(59): Error: found `{` when expecting `)`\n/tmp/tmpxxeyy248.d(70): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxxeyy248.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (kv.first.isNull()) return false;\n        if (kv.first.is<string>()) {\n            if (kv.first.unwrap() != kv.first.unwrap().toLower()) return false;\n        } else {\n            if (kv.first.unwrap() != kv.first.unwrap().toUpper()) return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmp77cd4wha.d(24): Error: basic type expected, not `&`\n/tmp/tmp77cd4wha.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmp77cd4wha.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmp77cd4wha.d(26): Error: identifier expected following `.`, not `is`\n/tmp/tmp77cd4wha.d(26): Error: found `>` when expecting `)`\n/tmp/tmp77cd4wha.d(26): Error: expression expected, not `)`\n/tmp/tmp77cd4wha.d(26): Error: found `{` when expecting `;` following statement\n/tmp/tmp77cd4wha.d(28): Error: found `else` without a corresponding `if`, `version` or `debug` statement\n/tmp/tmp77cd4wha.d(31): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp77cd4wha.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpxxeyy248.d(24): Error: basic type expected, not `&`\n/tmp/tmpxxeyy248.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpxxeyy248.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpxxeyy248.d(58): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpxxeyy248.d(59): Error: found `{` when expecting `)`\n/tmp/tmpxxeyy248.d(70): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxxeyy248.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (std::isupper(kv.first[0])) return false;\n        if (std::islower(kv.first[0])) return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpf11c6r_9.d(24): Error: basic type expected, not `&`\n/tmp/tmpf11c6r_9.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpf11c6r_9.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpf11c6r_9.d(25): Error: found `:` when expecting `)`\n/tmp/tmpf11c6r_9.d(25): Error: found `:` instead of statement\n/tmp/tmpf11c6r_9.d(26): Error: found `:` when expecting `)`\n/tmp/tmpf11c6r_9.d(26): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf11c6r_9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpxxeyy248.d(24): Error: basic type expected, not `&`\n/tmp/tmpxxeyy248.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpxxeyy248.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpxxeyy248.d(58): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpxxeyy248.d(59): Error: found `{` when expecting `)`\n/tmp/tmpxxeyy248.d(70): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxxeyy248.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict) {\n        if (std::isupper(kv.first[0]))\n            return false;\n        if (std::islower(kv.first[0]))\n            return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpqpod3zkd.d(25): Error: basic type expected, not `&`\n/tmp/tmpqpod3zkd.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpqpod3zkd.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpqpod3zkd.d(26): Error: found `:` when expecting `)`\n/tmp/tmpqpod3zkd.d(26): Error: found `:` instead of statement\n/tmp/tmpqpod3zkd.d(28): Error: found `:` when expecting `)`\n/tmp/tmpqpod3zkd.d(28): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqpod3zkd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict.nonNull()) {\n        if (std::string(kv.first).length() != kv.second.length()) return false;\n        if (std::string(kv.first).length() != std::string(kv.first).length()) return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpaiop2_dl.d(24): Error: basic type expected, not `&`\n/tmp/tmpaiop2_dl.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpaiop2_dl.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpaiop2_dl.d(25): Error: found `:` when expecting `)`\n/tmp/tmpaiop2_dl.d(25): Error: found `:` instead of statement\n/tmp/tmpaiop2_dl.d(26): Error: found `:` when expecting `)`\n/tmp/tmpaiop2_dl.d(26): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpaiop2_dl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto &kv : dict.nonNull())\n    {\n        if (std.typecons.isLowerCase(kv.first))\n            continue;\n        if (std.typecons.isUpperCase(kv.first))\n            continue;\n        return false;\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmptdquughd.d(25): Error: basic type expected, not `&`\n/tmp/tmptdquughd.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmptdquughd.d(25): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptdquughd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto it = dict.get().begin(); it != dict.get().end(); ++it) {\n        if (std.typecons.isLowerCase(it.key())) return true;\n        if (std.typecons.isUpperCase(it.key())) return false;\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmptzdx6cl5.d(24): Error: no property `begin` for type `string[string]`\n/tmp/tmptzdx6cl5.d(24): Error: no property `end` for type `string[string]`\n/tmp/tmptzdx6cl5.d(25): Error: undefined identifier `isLowerCase` in module `std.typecons`\n/tmp/tmptzdx6cl5.d(26): Error: undefined identifier `isUpperCase` in module `std.typecons`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptzdx6cl5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (std.typecons.isLowerCase(kv.key)) return true;\n        if (std.typecons.isUpperCase(kv.key)) return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpfbnuh1uw.d(24): Error: basic type expected, not `&`\n/tmp/tmpfbnuh1uw.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpfbnuh1uw.d(24): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfbnuh1uw.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict) {\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpm3evomm_.d(25): Error: basic type expected, not `&`\n/tmp/tmpm3evomm_.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpm3evomm_.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpm3evomm_.d(83): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpm3evomm_.d(84): Error: found `{` when expecting `)`\n/tmp/tmpm3evomm_.d(95): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm3evomm_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto &kv : dict) {\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpd6rkslbw.d(25): Error: basic type expected, not `&`\n/tmp/tmpd6rkslbw.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpd6rkslbw.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpd6rkslbw.d(83): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpd6rkslbw.d(84): Error: found `{` when expecting `)`\n/tmp/tmpd6rkslbw.d(95): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd6rkslbw.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto &kv : dict)\n        if (kv.first.length() != kv.first.length())\n            return false;\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmphmwbcuvh.d(25): Error: basic type expected, not `&`\n/tmp/tmphmwbcuvh.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmphmwbcuvh.d(25): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphmwbcuvh.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& key : dict) {\n        if (std::isupper(key.first[0]))\n            return false;\n        if (std::islower(key.first[0]))\n            continue;\n        return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpjbwdyg9r.d(25): Error: basic type expected, not `&`\n/tmp/tmpjbwdyg9r.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpjbwdyg9r.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpjbwdyg9r.d(26): Error: found `:` when expecting `)`\n/tmp/tmpjbwdyg9r.d(26): Error: found `:` instead of statement\n/tmp/tmpjbwdyg9r.d(28): Error: found `:` when expecting `)`\n/tmp/tmpjbwdyg9r.d(28): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjbwdyg9r.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (std::isupper(kv.first[0])) return false;\n        if (std::islower(kv.first[0])) return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpf11c6r_9.d(24): Error: basic type expected, not `&`\n/tmp/tmpf11c6r_9.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpf11c6r_9.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpf11c6r_9.d(25): Error: found `:` when expecting `)`\n/tmp/tmpf11c6r_9.d(25): Error: found `:` instead of statement\n/tmp/tmpf11c6r_9.d(26): Error: found `:` when expecting `)`\n/tmp/tmpf11c6r_9.d(26): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf11c6r_9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (std::isupper(kv.first[0])) return false;\n        if (std::islower(kv.first[0])) return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpf11c6r_9.d(24): Error: basic type expected, not `&`\n/tmp/tmpf11c6r_9.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpf11c6r_9.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpf11c6r_9.d(25): Error: found `:` when expecting `)`\n/tmp/tmpf11c6r_9.d(25): Error: found `:` instead of statement\n/tmp/tmpf11c6r_9.d(26): Error: found `:` when expecting `)`\n/tmp/tmpf11c6r_9.d(26): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf11c6r_9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto it = dict.get().begin(); it != dict.get().end(); it++)\n    {\n        if (std::isupper(it.key()[0]))\n            return false;\n        if (std::islower(it.key()[0]))\n            return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpor8s1yxg.d(27): Error: found `:` when expecting `)`\n/tmp/tmpor8s1yxg.d(27): Error: found `:` instead of statement\n/tmp/tmpor8s1yxg.d(29): Error: found `:` when expecting `)`\n/tmp/tmpor8s1yxg.d(29): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpor8s1yxg.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto &kv : dict) {\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpb8q0h3ok.d(24): Error: basic type expected, not `&`\n/tmp/tmpb8q0h3ok.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpb8q0h3ok.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpb8q0h3ok.d(58): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpb8q0h3ok.d(59): Error: found `{` when expecting `)`\n/tmp/tmpb8q0h3ok.d(70): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb8q0h3ok.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto &kv : dict)\n    {\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isString())\n        {\n            if (kv.first.toString() != kv.first.toString().toLower() &&\n                kv.first.toString() != kv.first.toString().toUpper())\n                return false;\n        }\n        else\n            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmp3_0utpcf.d(25): Error: basic type expected, not `&`\n/tmp/tmp3_0utpcf.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmp3_0utpcf.d(25): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3_0utpcf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& [k, v] : dict) {\n        if (std::isupper(k[0]))\n            return false;\n        if (std::islower(k[0]))\n            return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmp4katkkx2.d(25): Error: basic type expected, not `&`\n/tmp/tmp4katkkx2.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmp4katkkx2.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmp4katkkx2.d(26): Error: found `:` when expecting `)`\n/tmp/tmp4katkkx2.d(26): Error: found `:` instead of statement\n/tmp/tmp4katkkx2.d(28): Error: found `:` when expecting `)`\n/tmp/tmp4katkkx2.d(28): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4katkkx2.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpxxeyy248.d(24): Error: basic type expected, not `&`\n/tmp/tmpxxeyy248.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpxxeyy248.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpxxeyy248.d(58): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpxxeyy248.d(59): Error: found `{` when expecting `)`\n/tmp/tmpxxeyy248.d(70): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxxeyy248.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (kv.first.isNull()) return false;\n        if (kv.first.is_string()) {\n            if (kv.first.as_string().toLower() != kv.first.as_string()) return false;\n        } else {\n            if (kv.first.as_string().toUpper() != kv.first.as_string()) return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmphrlx07ly.d(24): Error: basic type expected, not `&`\n/tmp/tmphrlx07ly.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmphrlx07ly.d(24): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphrlx07ly.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (kv.first.isNull()) return false;\n        if (kv.first.isString()) {\n            if (kv.first.asString().toLower() != kv.first.asString()) return false;\n        } else {\n            if (kv.first.asString().toUpper() != kv.first.asString()) return false;\n        }\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpkd9vkiqb.d(24): Error: basic type expected, not `&`\n/tmp/tmpkd9vkiqb.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpkd9vkiqb.d(24): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkd9vkiqb.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto key : dict.keys())\n        if (key.isNull())\n            return false;\n    for (auto key : dict.keys())\n        if (key.isNull())\n            return false;\n    for (auto key : dict.keys())\n        if (key.isNull())\n            return false;\n    for (auto key : dict.keys())\n        if (key.isNull())\n            return false;\n    for (auto key : dict.keys())\n        if (key.isNull())\n            return false;\n    for (auto key : dict.keys())\n        if (key.isNull())\n            return false;\n    for (auto key : dict.keys())\n        if (key.isNull())\n            return false;\n    for (auto key : dict.keys())\n        if (key.isNull())\n            return false;\n    for (auto key : dict.keys())\n        if (key.isNull())\n            return false;\n    for (auto key : dict.keys())\n        if (key.isNull())\n            return false;\n    for (auto key : dict.keys())\n        if (key.isNull())\n            return false;\n    for (auto key : dict.keys())\n        if (key.isNull())\n            return false;\n    for (auto key : dict.keys())\n        if (key.isNull())\n            return false;\n    for (auto key : dict.keys())\n        if (key.isNull())\n            return false;\n    for (auto key : dict.keys())\n        if (key.isNull())\n            return false;\n    for (auto key : dict.keys())\n        if (key.isNull())\n            return false;\n    for (auto key : dict.keys())\n        if (key.isNull())\n            return false;\n    for (auto key : dict.keys())\n        if (key.isNull())\n            return false;\n    for (auto key : dict.keys())\n        if (key.isNull())\n            return false;\n    for (auto key : dict.keys())\n        if (key.isNull())\n            \nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmps_qclt9a.d(25): Error: no identifier for declarator `key`\n/tmp/tmps_qclt9a.d(25): Error: expression expected, not `:`\n/tmp/tmps_qclt9a.d(25): Error: found `dict` when expecting `;` following `for` condition\n/tmp/tmps_qclt9a.d(28): Error: no identifier for declarator `key`\n/tmp/tmps_qclt9a.d(28): Error: expression expected, not `:`\n/tmp/tmps_qclt9a.d(28): Error: found `dict` when expecting `;` following `for` condition\n/tmp/tmps_qclt9a.d(31): Error: no identifier for declarator `key`\n/tmp/tmps_qclt9a.d(31): Error: expression expected, not `:`\n/tmp/tmps_qclt9a.d(31): Error: found `dict` when expecting `;` following `for` condition\n/tmp/tmps_qclt9a.d(34): Error: no identifier for declarator `key`\n/tmp/tmps_qclt9a.d(34): Error: expression expected, not `:`\n/tmp/tmps_qclt9a.d(34): Error: found `dict` when expecting `;` following `for` condition\n/tmp/tmps_qclt9a.d(37): Error: no identifier for declarator `key`\n/tmp/tmps_qclt9a.d(37): Error: expression expected, not `:`\n/tmp/tmps_qclt9a.d(37): Error: found `",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto &kv : dict) {\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpd6rkslbw.d(25): Error: basic type expected, not `&`\n/tmp/tmpd6rkslbw.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpd6rkslbw.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpd6rkslbw.d(83): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpd6rkslbw.d(84): Error: found `{` when expecting `)`\n/tmp/tmpd6rkslbw.d(95): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd6rkslbw.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.first.isNull()) return false;\n        if (kv.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpxxeyy248.d(24): Error: basic type expected, not `&`\n/tmp/tmpxxeyy248.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpxxeyy248.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpxxeyy248.d(58): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpxxeyy248.d(59): Error: found `{` when expecting `)`\n/tmp/tmpxxeyy248.d(70): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxxeyy248.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (std::isupper(kv.first[0])) return false;\n        if (std::islower(kv.first[0])) return true;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpf11c6r_9.d(24): Error: basic type expected, not `&`\n/tmp/tmpf11c6r_9.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpf11c6r_9.d(24): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpf11c6r_9.d(25): Error: found `:` when expecting `)`\n/tmp/tmpf11c6r_9.d(25): Error: found `:` instead of statement\n/tmp/tmpf11c6r_9.d(26): Error: found `:` when expecting `)`\n/tmp/tmpf11c6r_9.d(26): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf11c6r_9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict) {\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.isNull())\n            return false;\n        if (kv.first.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpm3evomm_.d(25): Error: basic type expected, not `&`\n/tmp/tmpm3evomm_.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpm3evomm_.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpm3evomm_.d(83): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpm3evomm_.d(84): Error: found `{` when expecting `)`\n/tmp/tmpm3evomm_.d(95): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm3evomm_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull())\n        return false;\n    for (auto& kv : dict)\n        if (kv.first.isNull() || kv.first.isNull())\n            return false;\n    for (auto& kv : dict)\n        if (kv.first.isNull() || kv.first.isNull())\n            return false;\n    for (auto& kv : dict)\n        if (kv.first.isNull() || kv.first.isNull())\n            return false;\n    for (auto& kv : dict)\n        if (kv.first.isNull() || kv.first.isNull())\n            return false;\n    for (auto& kv : dict)\n        if (kv.first.isNull() || kv.first.isNull())\n            return false;\n    for (auto& kv : dict)\n        if (kv.first.isNull() || kv.first.isNull())\n            return false;\n    for (auto& kv : dict)\n        if (kv.first.isNull() || kv.first.isNull())\n            return false;\n    for (auto& kv : dict)\n        if (kv.first.isNull() || kv.first.isNull())\n            return false;\n    for (auto& kv : dict)\n        if (kv.first.isNull() || kv.first.isNull())\n            return false;\n    for (auto& kv : dict)\n        if (kv.first.isNull() || kv.first.isNull())\n            return false;\n    for (auto& kv : dict)\n        if (kv.first.isNull() || kv.first.isNull())\n            return false;\n    for (auto& kv : dict)\n        if (kv.first.isNull() || kv.first.isNull())\n            return false;\n    for (auto& kv : dict)\n        if (kv.first.isNull() || kv.first.isNull())\n            return false;\n    for (auto& kv : dict)\n        if (k\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpku3krc07.d(25): Error: basic type expected, not `&`\n/tmp/tmpku3krc07.d(25): Error: no identifier for declarator `_error_`\n/tmp/tmpku3krc07.d(25): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpku3krc07.d(28): Error: basic type expected, not `&`\n/tmp/tmpku3krc07.d(28): Error: no identifier for declarator `_error_`\n/tmp/tmpku3krc07.d(28): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpku3krc07.d(31): Error: basic type expected, not `&`\n/tmp/tmpku3krc07.d(31): Error: no identifier for declarator `_error_`\n/tmp/tmpku3krc07.d(31): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpku3krc07.d(34): Error: basic type expected, not `&`\n/tmp/tmpku3krc07.d(34): Error: no identifier for declarator `_error_`\n/tmp/tmpku3krc07.d(34): Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpku3krc07.d(37): Error: basic type expected, not `&`\n/tmp/tmpku3krc07.d(37): Error: no identifier for declarator `_error_`\n/tmp/tmpku3krc07.d(37): Error:",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict)\n    {\n        if (std.typecons.isLowerCase(kv.first)) return true;\n        if (std.typecons.isUpperCase(kv.first)) return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpz__dn6ji.d(24): Error: basic type expected, not `&`\n/tmp/tmpz__dn6ji.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpz__dn6ji.d(24): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz__dn6ji.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto &k : dict) {\n        if (k.isNull()) return false;\n        if (k.isString()) {\n            if (k.toString() != k.toString().toLower()) return false;\n        } else {\n            if (k.toString() != k.toString().toUpper()) return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpd686aocx.d(24): Error: basic type expected, not `&`\n/tmp/tmpd686aocx.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpd686aocx.d(24): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd686aocx.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array, return true if all keys are strings in lower \n    case or all keys are strings in upper case, else return false.\n    The function should return false is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n    >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n{\n    if (dict.isNull()) return false;\n    for (auto& kv : dict) {\n        if (kv.key.isNull()) return false;\n        if (kv.key.isString()) {\n            if (kv.key.asString() == kv.key.asString().toLower()) return true;\n            if (kv.key.asString() == kv.key.asString().toUpper()) return true;\n        }\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n}\nvoid main(){}",
      "timestamp": 1664293100,
      "stdout": "",
      "stderr": "/tmp/tmpj71x60go.d(24): Error: basic type expected, not `&`\n/tmp/tmpj71x60go.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpj71x60go.d(24): Error: found `:` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj71x60go.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}