{
  "name": "HumanEval_118_get_closest_vowel",
  "language": "d",
  "prompt": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n",
  "tests": "unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "results": [
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.size() < 2) return \"\";\n    string vowels = \"aeiouAEIOU\";\n    string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int i = 0;\n    while(i < word.size() && vowels.find(word[i]) == string::npos)\n        i++;\n    if(i == word.size()) return \"\";\n    int j = word.size() - 1;\n    while(j >= 0 && consonants.find(word[j]) == string::npos)\n        j--;\n    if(j == -1) return \"\";\n    return word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' ? word[i] : word[j];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpdk331ofh.d(29): Error: found `:` when expecting `)`\n/tmp/tmpdk331ofh.d(29): Error: found `:` instead of statement\n/tmp/tmpdk331ofh.d(33): Error: found `:` when expecting `)`\n/tmp/tmpdk331ofh.d(33): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdk331ofh.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.length() < 2) return \"\";\n    int i = word.length() - 1;\n    while(i >= 0 && !is_vowel(word[i])) i--;\n    if(i < 0) return \"\";\n    int j = i + 1;\n    while(j < word.length() && !is_vowel(word[j])) j++;\n    if(j == word.length()) return \"\";\n    return word[i] + word[j];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpg15dbg_y.d(25): Error: no property `length` for type `string`\n/tmp/tmpg15dbg_y.d(26): Error: no property `length` for type `string`\n/tmp/tmpg15dbg_y.d(27): Error: undefined identifier `is_vowel`\n/tmp/tmpg15dbg_y.d(30): Error: no property `length` for type `string`\n/tmp/tmpg15dbg_y.d(30): Error: undefined identifier `is_vowel`\n/tmp/tmpg15dbg_y.d(31): Error: no property `length` for type `string`\n/tmp/tmpg15dbg_y.d(32): Error: cannot implicitly convert expression `cast(int)word[cast(ulong)i] + cast(int)word[cast(ulong)j]` of type `int` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg15dbg_y.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.length() < 2)\n        return \"\";\n    string vowels = \"aeiouAEIOU\";\n    int i = word.length() - 1;\n    while(i >= 0 && vowels.find(word[i]) == string::npos)\n        i--;\n    if(i < 0)\n        return \"\";\n    i++;\n    while(i < word.length() && vowels.find(word[i]) == string::npos)\n        i++;\n    return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpcy09m7zo.d(29): Error: found `:` when expecting `)`\n/tmp/tmpcy09m7zo.d(29): Error: found `:` instead of statement\n/tmp/tmpcy09m7zo.d(34): Error: found `:` when expecting `)`\n/tmp/tmpcy09m7zo.d(34): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcy09m7zo.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    while (i < word.length() && vowels.find(word[i]) == string::npos)\n        i++;\n    if (i == word.length())\n        return \"\";\n    int j = word.length() - 1;\n    while (j >= 0 && vowels.find(word[j]) == string::npos)\n        j--;\n    return word[i] + word[j];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp55opjydh.d(27): Error: found `:` when expecting `)`\n/tmp/tmp55opjydh.d(27): Error: found `:` instead of statement\n/tmp/tmp55opjydh.d(32): Error: found `:` when expecting `)`\n/tmp/tmp55opjydh.d(32): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp55opjydh.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if (i < 0)\n        return \"\";\n    else\n        return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp76o1iji6.d(25): Error: no property `length` for type `string`\n/tmp/tmp76o1iji6.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp76o1iji6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if (word.length() < 2) return \"\";\n    string vowels = \"aeiouAEIOU\";\n    int i = word.length() - 1;\n    while (i >= 0 && vowels.find(word[i]) == string::npos)\n        i--;\n    if (i < 0) return \"\";\n    i++;\n    while (i < word.length() && vowels.find(word[i]) == string::npos)\n        i++;\n    return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmphd327wup.d(28): Error: found `:` when expecting `)`\n/tmp/tmphd327wup.d(28): Error: found `:` instead of statement\n/tmp/tmphd327wup.d(32): Error: found `:` when expecting `)`\n/tmp/tmphd327wup.d(32): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphd327wup.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.size() < 2)\n        return \"\";\n    int i = word.size()-1;\n    while(i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' && word[i] != 'E' && word[i] != 'I' && word[i] != 'O' && word[i] != 'U')\n        i--;\n    if(i < 0)\n        return \"\";\n    i--;\n    while(i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' && word[i] != 'E' && word[i] != 'I' && word[i] != 'O' && word[i] != 'U')\n        i--;\n    if(i < 0)\n        return \"\";\n    return word[i+1];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp6y3ampho.d(25): Error: no property `size` for type `string`\n/tmp/tmp6y3ampho.d(27): Error: no property `size` for type `string`\n/tmp/tmp6y3ampho.d(37): Error: cannot implicitly convert expression `word[cast(ulong)(i + 1)]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6y3ampho.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if (i < 0)\n        return \"\";\n    else\n        return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp76o1iji6.d(25): Error: no property `length` for type `string`\n/tmp/tmp76o1iji6.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp76o1iji6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < word.length())\n    {\n        if(word[i] == ' ')\n            i++;\n        else if(word[i] == ' ')\n            i++;\n        else if(vowels.find(word[i]) != string::npos)\n        {\n            count++;\n            i++;\n        }\n        else if(count > 0)\n        {\n            count--;\n            i++;\n        }\n        else\n        {\n            i++;\n        }\n    }\n    if(count > 0)\n        return \"\";\n    else\n    {\n        count = 0;\n        i = 0;\n        j = 0;\n        while(j < word.length())\n        {\n            if(word[j] == ' ')\n                j++;\n            else if(word[j] == ' ')\n                j++;\n            else if(vowels.find(word[j]) != string::npos)\n            {\n                count++;\n                j++;\n            }\n            else if(count > 0)\n            {\n                count--;\n                j++;\n            }\n            else\n            {\n                j++;\n            }\n        }\n        return word[i];\n    }\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpvqpyvbbh.d(35): Error: found `:` when expecting `)`\n/tmp/tmpvqpyvbbh.d(35): Error: found `:` instead of statement\n/tmp/tmpvqpyvbbh.d(40): Error: found `else` without a corresponding `if`, `version` or `debug` statement\n/tmp/tmpvqpyvbbh.d(45): Error: declaration expected, not `else`\n/tmp/tmpvqpyvbbh.d(48): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvqpyvbbh.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length()-1;\n    while(i>=0 && word[i]!='a' && word[i]!='e' && word[i]!='i' && word[i]!='o' && word[i]!='u')\n        i--;\n    if(i<0)\n        return \"\";\n    else\n        return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp8y4p4m3e.d(25): Error: no property `length` for type `string`\n/tmp/tmp8y4p4m3e.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8y4p4m3e.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.size() < 2) return \"\";\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    while(i < word.size()-2)\n    {\n        if(vowels.find(word[i]) != string::npos)\n        {\n            i++;\n            continue;\n        }\n        if(vowels.find(word[i+1]) != string::npos)\n        {\n            i++;\n            continue;\n        }\n        if(vowels.find(word[i+2]) != string::npos)\n        {\n            return word[i+2];\n        }\n        i++;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmphefppa0s.d(30): Error: found `:` when expecting `)`\n/tmp/tmphefppa0s.d(30): Error: found `:` instead of statement\n/tmp/tmphefppa0s.d(35): Error: found `:` when expecting `)`\n/tmp/tmphefppa0s.d(35): Error: found `:` instead of statement\n/tmp/tmphefppa0s.d(40): Error: declaration expected, not `if`\n/tmp/tmphefppa0s.d(43): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphefppa0s.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length()-1;\n    while(i>=0 && word[i]!='a' && word[i]!='e' && word[i]!='i' && word[i]!='o' && word[i]!='u')\n        i--;\n    if(i<0)\n        return \"\";\n    else\n        return word[i];\n}\n\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpxiky26zt.d(25): Error: no property `length` for type `string`\n/tmp/tmpxiky26zt.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxiky26zt.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.empty()) return \"\";\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    while(i < word.length()-1)\n    {\n        if(vowels.find(word[i]) != string::npos)\n        {\n            if(vowels.find(word[i+1]) != string::npos)\n            {\n                return word[i+1];\n            }\n        }\n        i++;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp_7thrya1.d(30): Error: found `:` when expecting `)`\n/tmp/tmp_7thrya1.d(30): Error: found `:` instead of statement\n/tmp/tmp_7thrya1.d(37): Error: no identifier for declarator `i`\n/tmp/tmp_7thrya1.d(37): Error: declaration expected, not `++`\n/tmp/tmp_7thrya1.d(38): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_7thrya1.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if (word.size() < 2) return \"\";\n    int i = word.size() - 1;\n    while (i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if (i < 0) return \"\";\n    i--;\n    while (i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if (i < 0) return \"\";\n    return word[i];\n}\n\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpejnaijdk.d(25): Error: no property `size` for type `string`\n/tmp/tmpejnaijdk.d(26): Error: no property `size` for type `string`\n/tmp/tmpejnaijdk.d(34): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpejnaijdk.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if (word.length() < 2) return \"\";\n    \n    string vowels = \"aeiouAEIOU\";\n    \n    int i = word.length() - 1;\n    while (i >= 0 && vowels.find(word[i]) == string::npos)\n        i--;\n    \n    if (i < 0) return \"\";\n    \n    i++;\n    while (i < word.length() && vowels.find(word[i]) == string::npos)\n        i++;\n    \n    if (i == word.length()) return \"\";\n    \n    return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp5a_jkdv2.d(30): Error: found `:` when expecting `)`\n/tmp/tmp5a_jkdv2.d(30): Error: found `:` instead of statement\n/tmp/tmp5a_jkdv2.d(36): Error: found `:` when expecting `)`\n/tmp/tmp5a_jkdv2.d(36): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5a_jkdv2.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    while (i < word.length() && vowels.find(word[i]) == string::npos)\n        i++;\n    if (i == word.length())\n        return \"\";\n    int j = word.length() - 1;\n    while (j >= 0 && vowels.find(word[j]) == string::npos)\n        j--;\n    if (j == -1)\n        return \"\";\n    return word[i] + word[j];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpnsezprz1.d(27): Error: found `:` when expecting `)`\n/tmp/tmpnsezprz1.d(27): Error: found `:` instead of statement\n/tmp/tmpnsezprz1.d(32): Error: found `:` when expecting `)`\n/tmp/tmpnsezprz1.d(32): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnsezprz1.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int A = 0;\n    int B = 0;\n    int C = 0;\n    int D = 0;\n    int E = 0;\n    int F = 0;\n    int G = 0;\n    int H = 0;\n    int I = 0;\n    int J = 0;\n    int K = 0;\n    int L = 0;\n    int M = 0;\n    int N = 0;\n    int O = 0;\n    int P = 0;\n    int Q = 0;\n    int R = 0;\n    int S = 0;\n    int T = 0;\n    int U = 0;\n    int V = 0;\n    int W = 0;\n    int X = 0;\n    int Y = 0;\n    int Z = 0;\n    int _ = 0;\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpyqdsy5ac.d(97): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyqdsy5ac.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < word.length() && j < word.length()) {\n        if (vowels.find(word[i]) != string::npos) {\n            count++;\n            if (count == 1) {\n                j = i;\n            }\n        }\n        i++;\n    }\n    if (count == 0) {\n        return \"\";\n    }\n    return word[j];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpqfp3y4j7.d(30): Error: found `:` when expecting `)`\n/tmp/tmpqfp3y4j7.d(30): Error: found `:` instead of statement\n/tmp/tmpqfp3y4j7.d(38): Error: declaration expected, not `if`\n/tmp/tmpqfp3y4j7.d(40): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqfp3y4j7.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0 && !is_vowel(word[i]))\n        i--;\n    if (i < 0)\n        return \"\";\n    int j = i + 1;\n    while (j < word.length() && !is_vowel(word[j]))\n        j++;\n    return word[j];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpqpv9up7o.d(25): Error: no property `length` for type `string`\n/tmp/tmpqpv9up7o.d(26): Error: undefined identifier `is_vowel`\n/tmp/tmpqpv9up7o.d(31): Error: no property `length` for type `string`\n/tmp/tmpqpv9up7o.d(31): Error: undefined identifier `is_vowel`\n/tmp/tmpqpv9up7o.d(33): Error: cannot implicitly convert expression `word[cast(ulong)j]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqpv9up7o.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.size() < 2) return \"\";\n    string vowels = \"aeiouAEIOU\";\n    int i = word.size() - 1;\n    while(i >= 0 && vowels.find(word[i]) == string::npos)\n        i--;\n    if(i < 0) return \"\";\n    i++;\n    while(i < word.size() && vowels.find(word[i]) == string::npos)\n        i++;\n    if(i == word.size()) return \"\";\n    return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpnln15e75.d(28): Error: found `:` when expecting `)`\n/tmp/tmpnln15e75.d(28): Error: found `:` instead of statement\n/tmp/tmpnln15e75.d(32): Error: found `:` when expecting `)`\n/tmp/tmpnln15e75.d(32): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnln15e75.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length()-1;\n    while(i>=0 && word[i]!='a' && word[i]!='e' && word[i]!='i' && word[i]!='o' && word[i]!='u')\n        i--;\n    if(i<0)\n        return \"\";\n    else\n        return word[i];\n}\n\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpxiky26zt.d(25): Error: no property `length` for type `string`\n/tmp/tmpxiky26zt.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxiky26zt.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.length() < 2)\n        return \"\";\n    int i = word.length() - 1;\n    while(i >= 0)\n    {\n        if(is_vowel(word[i]))\n            return word[i];\n        i--;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpx2d_cpxc.d(25): Error: no property `length` for type `string`\n/tmp/tmpx2d_cpxc.d(27): Error: no property `length` for type `string`\n/tmp/tmpx2d_cpxc.d(30): Error: undefined identifier `is_vowel`\n/tmp/tmpx2d_cpxc.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx2d_cpxc.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = word.length() - 1;\n    while (i >= 0)\n    {\n        if (vowels.find(word[i]) != string::npos)\n            return word[i];\n        i--;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmph5u3ti_e.d(29): Error: found `:` when expecting `)`\n/tmp/tmph5u3ti_e.d(29): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph5u3ti_e.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = word.length() - 1;\n    while (i >= 0) {\n        if (vowels.find(word[i]) != string::npos) {\n            return word[i];\n        }\n        i--;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpl3pizsz5.d(28): Error: found `:` when expecting `)`\n/tmp/tmpl3pizsz5.d(28): Error: found `:` instead of statement\n/tmp/tmpl3pizsz5.d(33): Error: declaration expected, not `return`\n/tmp/tmpl3pizsz5.d(34): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl3pizsz5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length()-1;\n    while(i>=0 && !is_vowel(word[i]))\n        i--;\n    if(i<0)\n        return \"\";\n    int j = i-1;\n    while(j>=0 && !is_vowel(word[j]))\n        j--;\n    if(j<0)\n        return \"\";\n    return word[j+1];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpt3ay1wu9.d(25): Error: no property `length` for type `string`\n/tmp/tmpt3ay1wu9.d(26): Error: undefined identifier `is_vowel`\n/tmp/tmpt3ay1wu9.d(31): Error: undefined identifier `is_vowel`\n/tmp/tmpt3ay1wu9.d(35): Error: cannot implicitly convert expression `word[cast(ulong)(j + 1)]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt3ay1wu9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length()-1;\n    while(i>=0 && word[i]!='a' && word[i]!='e' && word[i]!='i' && word[i]!='o' && word[i]!='u')\n        i--;\n    if(i<0)\n        return \"\";\n    else\n        return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp8y4p4m3e.d(25): Error: no property `length` for type `string`\n/tmp/tmp8y4p4m3e.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8y4p4m3e.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if (i < 0)\n        return \"\";\n    i--;\n    while (i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if (i < 0)\n        return \"\";\n    return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpy1xznsj2.d(25): Error: no property `length` for type `string`\n/tmp/tmpy1xznsj2.d(35): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy1xznsj2.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int n = word.length();\n    while(i < n)\n    {\n        if(word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\n        {\n            j = i;\n            k = i;\n            while(j < n && vowels.find(word[j]) != string::npos)\n            {\n                j++;\n            }\n            while(k < n && vowels.find(word[k]) != string::npos)\n            {\n                k++;\n            }\n            if(j - i > 1 && k - i > 1)\n            {\n                return word.substr(i, j - i);\n            }\n        }\n        i++;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpsiyyhig8.d(36): Error: found `:` when expecting `)`\n/tmp/tmpsiyyhig8.d(36): Error: found `:` instead of statement\n/tmp/tmpsiyyhig8.d(40): Error: found `:` when expecting `)`\n/tmp/tmpsiyyhig8.d(40): Error: found `:` instead of statement\n/tmp/tmpsiyyhig8.d(49): Error: no identifier for declarator `i`\n/tmp/tmpsiyyhig8.d(49): Error: declaration expected, not `++`\n/tmp/tmpsiyyhig8.d(50): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsiyyhig8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if (i < 0)\n        return \"\";\n    else\n        return word[i];\n}\n\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpobfb5h6m.d(25): Error: no property `length` for type `string`\n/tmp/tmpobfb5h6m.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpobfb5h6m.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0) {\n        if (is_vowel(word[i]))\n            return word[i];\n        i--;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmps4hbejbf.d(25): Error: no property `length` for type `string`\n/tmp/tmps4hbejbf.d(27): Error: undefined identifier `is_vowel`\n/tmp/tmps4hbejbf.d(28): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps4hbejbf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if (i < 0)\n        return \"\";\n    else\n        return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp76o1iji6.d(25): Error: no property `length` for type `string`\n/tmp/tmp76o1iji6.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp76o1iji6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length()-1;\n    while(i>=0 && word[i]!='a' && word[i]!='e' && word[i]!='i' && word[i]!='o' && word[i]!='u')\n        i--;\n    if(i==-1)\n        return \"\";\n    else\n        return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp6e99ebwx.d(25): Error: no property `length` for type `string`\n/tmp/tmp6e99ebwx.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6e99ebwx.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = word.length() - 1;\n    while (i >= 0)\n    {\n        if (vowels.find(word[i]) != string::npos)\n            return word[i];\n        i--;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmph5u3ti_e.d(29): Error: found `:` when expecting `)`\n/tmp/tmph5u3ti_e.d(29): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph5u3ti_e.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int aa = 0;\n    int bb = 0;\n    int cc = 0;\n    int dd = 0;\n    int ee = 0;\n    int ff = 0;\n    int gg = 0;\n    int hh = 0;\n    int ii = 0;\n    int jj = 0;\n    int kk = 0;\n    int ll = 0;\n    int mm = 0;\n    int nn = 0;\n    int oo = 0;\n    int pp = 0;\n    int qq = 0;\n    int rr = 0;\n    int ss = 0;\n    int tt = 0;\n    int uu = 0;\n    int vv = 0;\n    int ww = 0;\n    int xx = 0;\n    int yy =\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpurm9nps2.d(95): Error: expression expected, not `unittest`\n/tmp/tmpurm9nps2.d(96): Error: semicolon expected, not `{`\n/tmp/tmpurm9nps2.d(113): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpurm9nps2.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.size() < 2)\n        return \"\";\n    string vowels = \"aeiouAEIOU\";\n    int i = word.size() - 1;\n    while(i >= 0 && vowels.find(word[i]) == string::npos)\n        i--;\n    if(i < 0)\n        return \"\";\n    i++;\n    while(i < word.size() && vowels.find(word[i]) == string::npos)\n        i++;\n    if(i == word.size())\n        return \"\";\n    return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp32tyvcu8.d(29): Error: found `:` when expecting `)`\n/tmp/tmp32tyvcu8.d(29): Error: found `:` instead of statement\n/tmp/tmp32tyvcu8.d(34): Error: found `:` when expecting `)`\n/tmp/tmp32tyvcu8.d(34): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp32tyvcu8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    int j = 0;\n    int n = word.length();\n    while (i < n && j < n) {\n        if (word[i] == word[j]) {\n            i++;\n            j++;\n        } else if (vowels.find(word[i]) != string::npos) {\n            return word[i];\n        } else {\n            i++;\n        }\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpzk_dczp4.d(33): Error: found `:` when expecting `)`\n/tmp/tmpzk_dczp4.d(33): Error: found `:` instead of statement\n/tmp/tmpzk_dczp4.d(35): Error: found `else` without a corresponding `if`, `version` or `debug` statement\n/tmp/tmpzk_dczp4.d(38): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzk_dczp4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length()-1;\n    while(i>=0 && word[i]!='a' && word[i]!='e' && word[i]!='i' && word[i]!='o' && word[i]!='u')\n        i--;\n    if(i<0)\n        return \"\";\n    i--;\n    while(i>=0 && word[i]!='a' && word[i]!='e' && word[i]!='i' && word[i]!='o' && word[i]!='u')\n        i--;\n    if(i<0)\n        return \"\";\n    return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp12pqg7nm.d(25): Error: no property `length` for type `string`\n/tmp/tmp12pqg7nm.d(35): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp12pqg7nm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length()-1;\n    while(i>=0 && !is_vowel(word[i]))\n        i--;\n    if(i<0)\n        return \"\";\n    else\n        return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpj4gf_zcf.d(25): Error: no property `length` for type `string`\n/tmp/tmpj4gf_zcf.d(26): Error: undefined identifier `is_vowel`\n/tmp/tmpj4gf_zcf.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj4gf_zcf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length()-1;\n    while(i>=0 && !is_vowel(word[i]))\n        i--;\n    if(i<0)\n        return \"\";\n    else\n        return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpj4gf_zcf.d(25): Error: no property `length` for type `string`\n/tmp/tmpj4gf_zcf.d(26): Error: undefined identifier `is_vowel`\n/tmp/tmpj4gf_zcf.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj4gf_zcf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0 && !is_vowel(word[i]))\n        i--;\n    if (i < 0)\n        return \"\";\n    int j = i + 1;\n    while (j < word.length() && !is_vowel(word[j]))\n        j++;\n    return word[i] + word[j];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpv6yi4yzd.d(25): Error: no property `length` for type `string`\n/tmp/tmpv6yi4yzd.d(26): Error: undefined identifier `is_vowel`\n/tmp/tmpv6yi4yzd.d(31): Error: no property `length` for type `string`\n/tmp/tmpv6yi4yzd.d(31): Error: undefined identifier `is_vowel`\n/tmp/tmpv6yi4yzd.d(33): Error: cannot implicitly convert expression `cast(int)word[cast(ulong)i] + cast(int)word[cast(ulong)j]` of type `int` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv6yi4yzd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0 && !is_vowel(word[i]))\n        --i;\n    if (i < 0)\n        return \"\";\n    int j = i + 1;\n    while (j < word.length() && !is_vowel(word[j]))\n        ++j;\n    return word[i] + word[j];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpbed_h10i.d(25): Error: no property `length` for type `string`\n/tmp/tmpbed_h10i.d(26): Error: undefined identifier `is_vowel`\n/tmp/tmpbed_h10i.d(31): Error: no property `length` for type `string`\n/tmp/tmpbed_h10i.d(31): Error: undefined identifier `is_vowel`\n/tmp/tmpbed_h10i.d(33): Error: cannot implicitly convert expression `cast(int)word[cast(ulong)i] + cast(int)word[cast(ulong)j]` of type `int` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbed_h10i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    while(i < word.length() - 1)\n    {\n        if(vowels.find(word[i]) != string::npos && vowels.find(word[i+1]) != string::npos)\n            return word[i];\n        i++;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpbldjf985.d(29): Error: found `:` when expecting `)`\n/tmp/tmpbldjf985.d(29): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbldjf985.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int aa = 0;\n    int bb = 0;\n    int cc = 0;\n    int dd = 0;\n    int ee = 0;\n    int ff = 0;\n    int gg = 0;\n    int hh = 0;\n    int ii = 0;\n    int jj = 0;\n    int kk = 0;\n    int ll = 0;\n    int mm = 0;\n    int nn = 0;\n    int oo = 0;\n    int pp = 0;\n    int qq = 0;\n    int rr = 0;\n    int ss = 0;\n    int tt = 0;\n    int uu = 0;\n    int vv = 0;\n    int ww = 0;\n    int xx = 0;\n    int yy =\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpurm9nps2.d(95): Error: expression expected, not `unittest`\n/tmp/tmpurm9nps2.d(96): Error: semicolon expected, not `{`\n/tmp/tmpurm9nps2.d(113): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpurm9nps2.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0 && !is_vowel(word[i]))\n        i--;\n    if (i < 0)\n        return \"\";\n    int j = i + 1;\n    while (j < word.length() && !is_vowel(word[j]))\n        j++;\n    return word[j];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpqpv9up7o.d(25): Error: no property `length` for type `string`\n/tmp/tmpqpv9up7o.d(26): Error: undefined identifier `is_vowel`\n/tmp/tmpqpv9up7o.d(31): Error: no property `length` for type `string`\n/tmp/tmpqpv9up7o.d(31): Error: undefined identifier `is_vowel`\n/tmp/tmpqpv9up7o.d(33): Error: cannot implicitly convert expression `word[cast(ulong)j]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqpv9up7o.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0)\n    {\n        if (is_vowel(word[i]))\n            return word[i];\n        i--;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpb5xlwyi5.d(25): Error: no property `length` for type `string`\n/tmp/tmpb5xlwyi5.d(28): Error: undefined identifier `is_vowel`\n/tmp/tmpb5xlwyi5.d(29): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb5xlwyi5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length()-1;\n    while(i>=0 && !is_vowel(word[i]))\n        i--;\n    if(i<0)\n        return \"\";\n    int j = i-1;\n    while(j>=0 && !is_vowel(word[j]))\n        j--;\n    if(j<0)\n        return \"\";\n    return word[j+1];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpt3ay1wu9.d(25): Error: no property `length` for type `string`\n/tmp/tmpt3ay1wu9.d(26): Error: undefined identifier `is_vowel`\n/tmp/tmpt3ay1wu9.d(31): Error: undefined identifier `is_vowel`\n/tmp/tmpt3ay1wu9.d(35): Error: cannot implicitly convert expression `word[cast(ulong)(j + 1)]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt3ay1wu9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if (word.length() < 2) return \"\";\n    int i = word.length() - 2;\n    while (i >= 0) {\n        if (is_vowel(word[i]) && is_vowel(word[i + 1])) {\n            return word[i];\n        }\n        i--;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpai1llg_t.d(25): Error: no property `length` for type `string`\n/tmp/tmpai1llg_t.d(26): Error: no property `length` for type `string`\n/tmp/tmpai1llg_t.d(28): Error: undefined identifier `is_vowel`\n/tmp/tmpai1llg_t.d(28): Error: undefined identifier `is_vowel`\n/tmp/tmpai1llg_t.d(29): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpai1llg_t.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0) {\n        if (is_vowel(word[i]))\n            return word[i];\n        i--;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmps4hbejbf.d(25): Error: no property `length` for type `string`\n/tmp/tmps4hbejbf.d(27): Error: undefined identifier `is_vowel`\n/tmp/tmps4hbejbf.d(28): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps4hbejbf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = word.length() - 1;\n    while (i >= 0) {\n        if (vowels.find(word[i]) != string::npos) {\n            return word[i];\n        }\n        i--;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpl3pizsz5.d(28): Error: found `:` when expecting `)`\n/tmp/tmpl3pizsz5.d(28): Error: found `:` instead of statement\n/tmp/tmpl3pizsz5.d(33): Error: declaration expected, not `return`\n/tmp/tmpl3pizsz5.d(34): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl3pizsz5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if (i == -1)\n        return \"\";\n    else\n        return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpjaictfbl.d(25): Error: no property `length` for type `string`\n/tmp/tmpjaictfbl.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjaictfbl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.size() < 2)\n        return \"\";\n    int i = word.size() - 1;\n    while(i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if(i < 0)\n        return \"\";\n    i--;\n    while(i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if(i < 0)\n        return \"\";\n    return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmplimbw1ys.d(25): Error: no property `size` for type `string`\n/tmp/tmplimbw1ys.d(27): Error: no property `size` for type `string`\n/tmp/tmplimbw1ys.d(37): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplimbw1ys.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if (word.size() < 2) return \"\";\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    while (i < word.size()-1) {\n        if (vowels.find(word[i]) != string::npos) {\n            if (vowels.find(word[i+1]) != string::npos) {\n                return word[i];\n            }\n        }\n        i++;\n    }\n    return \"\";\n}\n\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpuydowf8u.d(29): Error: found `:` when expecting `)`\n/tmp/tmpuydowf8u.d(29): Error: found `:` instead of statement\n/tmp/tmpuydowf8u.d(34): Error: no identifier for declarator `i`\n/tmp/tmpuydowf8u.d(34): Error: declaration expected, not `++`\n/tmp/tmpuydowf8u.d(35): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuydowf8u.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length()-1;\n    while(i>=0 && !is_vowel(word[i]))\n        i--;\n    if(i<0)\n        return \"\";\n    int j = i;\n    while(j>=0 && !is_vowel(word[j]))\n        j--;\n    if(j<0)\n        return \"\";\n    return word[i+1];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp_31a424e.d(25): Error: no property `length` for type `string`\n/tmp/tmp_31a424e.d(26): Error: undefined identifier `is_vowel`\n/tmp/tmp_31a424e.d(31): Error: undefined identifier `is_vowel`\n/tmp/tmp_31a424e.d(35): Error: cannot implicitly convert expression `word[cast(ulong)(i + 1)]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_31a424e.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length()-1;\n    while(i>=0 && word[i]!='a' && word[i]!='e' && word[i]!='i' && word[i]!='o' && word[i]!='u')\n        i--;\n    if(i==-1)\n        return \"\";\n    else\n        return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp6e99ebwx.d(25): Error: no property `length` for type `string`\n/tmp/tmp6e99ebwx.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6e99ebwx.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length()-1;\n    while(i>=0 && !is_vowel(word[i]))\n        i--;\n    if(i<0)\n        return \"\";\n    int j = i-1;\n    while(j>=0 && !is_vowel(word[j]))\n        j--;\n    if(j<0)\n        return \"\";\n    return word[j+1];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpt3ay1wu9.d(25): Error: no property `length` for type `string`\n/tmp/tmpt3ay1wu9.d(26): Error: undefined identifier `is_vowel`\n/tmp/tmpt3ay1wu9.d(31): Error: undefined identifier `is_vowel`\n/tmp/tmpt3ay1wu9.d(35): Error: cannot implicitly convert expression `word[cast(ulong)(j + 1)]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt3ay1wu9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.size() < 2) return \"\";\n    int i = word.size() - 1;\n    while(i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' && word[i] != 'E' && word[i] != 'I' && word[i] != 'O' && word[i] != 'U')\n        i--;\n    if(i < 0) return \"\";\n    i++;\n    while(i < word.size() && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' && word[i] != 'E' && word[i] != 'I' && word[i] != 'O' && word[i] != 'U')\n        i++;\n    if(i == word.size()) return \"\";\n    return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpwfreo2fp.d(25): Error: no property `size` for type `string`\n/tmp/tmpwfreo2fp.d(26): Error: no property `size` for type `string`\n/tmp/tmpwfreo2fp.d(31): Error: no property `size` for type `string`\n/tmp/tmpwfreo2fp.d(33): Error: no property `size` for type `string`\n/tmp/tmpwfreo2fp.d(34): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwfreo2fp.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0) {\n        if (is_vowel(word[i]))\n            return word[i];\n        i--;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmps4hbejbf.d(25): Error: no property `length` for type `string`\n/tmp/tmps4hbejbf.d(27): Error: undefined identifier `is_vowel`\n/tmp/tmps4hbejbf.d(28): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps4hbejbf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int aa = 0;\n    int bb = 0;\n    int cc = 0;\n    int dd = 0;\n    int ee = 0;\n    int ff = 0;\n    int gg = 0;\n    int hh = 0;\n    int ii = 0;\n    int jj = 0;\n    int kk = 0;\n    int ll = 0;\n    int mm = 0;\n    int nn = 0;\n    int oo = 0;\n    int pp = 0;\n    int qq = 0;\n    int rr = 0;\n    int ss = 0;\n    int tt = 0;\n    int uu = 0;\n    int vv = 0;\n    int ww = 0;\n    int xx = 0;\n    int yy =\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpurm9nps2.d(95): Error: expression expected, not `unittest`\n/tmp/tmpurm9nps2.d(96): Error: semicolon expected, not `{`\n/tmp/tmpurm9nps2.d(113): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpurm9nps2.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0 && !is_vowel(word[i]))\n        --i;\n    if (i < 0)\n        return \"\";\n    int j = i + 1;\n    while (j < word.length() && !is_vowel(word[j]))\n        ++j;\n    return word[i] == word[j] ? word[i] : word[j];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpp2xnj0gd.d(25): Error: no property `length` for type `string`\n/tmp/tmpp2xnj0gd.d(26): Error: undefined identifier `is_vowel`\n/tmp/tmpp2xnj0gd.d(31): Error: no property `length` for type `string`\n/tmp/tmpp2xnj0gd.d(31): Error: undefined identifier `is_vowel`\n/tmp/tmpp2xnj0gd.d(33): Error: cannot implicitly convert expression `cast(int)word[cast(ulong)i] == cast(int)word[cast(ulong)j] ? word[cast(ulong)i] : word[cast(ulong)j]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp2xnj0gd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    int len = word.length();\n    while(i < len)\n    {\n        if(word[i] == ' ')\n            i++;\n        else if(vowels.find(word[i]) != string::npos)\n        {\n            count++;\n            if(count == 1)\n                j = i;\n        }\n        i++;\n    }\n    if(count == 0)\n        return \"\";\n    else\n        return word[j];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp9r_uj07b.d(34): Error: found `:` when expecting `)`\n/tmp/tmp9r_uj07b.d(34): Error: found `:` instead of statement\n/tmp/tmp9r_uj07b.d(42): Error: declaration expected, not `if`\n/tmp/tmp9r_uj07b.d(44): Error: declaration expected, not `else`\n/tmp/tmp9r_uj07b.d(46): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9r_uj07b.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length()-1;\n    while(i>=0 && word[i]!='a' && word[i]!='e' && word[i]!='i' && word[i]!='o' && word[i]!='u' && word[i]!='A' && word[i]!='E' && word[i]!='I' && word[i]!='O' && word[i]!='U')\n        i--;\n    if(i<0)\n        return \"\";\n    else\n        return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpfj10owrk.d(25): Error: no property `length` for type `string`\n/tmp/tmpfj10owrk.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfj10owrk.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int A = 0;\n    int B = 0;\n    int C = 0;\n    int D = 0;\n    int E = 0;\n    int F = 0;\n    int G = 0;\n    int H = 0;\n    int I = 0;\n    int J = 0;\n    int K = 0;\n    int L = 0;\n    int M = 0;\n    int N = 0;\n    int O = 0;\n    int P = 0;\n    int Q = 0;\n    int R = 0;\n    int S = 0;\n    int T = 0;\n    int U = 0;\n    int V = 0;\n    int W = 0;\n    int X = 0;\n    int Y = 0;\n    int Z = 0;\n    int _ = 0;\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpyqdsy5ac.d(97): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyqdsy5ac.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length()-1;\n    while (i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if (i < 0)\n        return \"\";\n    i--;\n    while (i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    return word[i+1];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp9949vks_.d(25): Error: no property `length` for type `string`\n/tmp/tmp9949vks_.d(33): Error: cannot implicitly convert expression `word[cast(ulong)(i + 1)]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9949vks_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if (i < 0)\n        return \"\";\n    else\n        return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp76o1iji6.d(25): Error: no property `length` for type `string`\n/tmp/tmp76o1iji6.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp76o1iji6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.length() < 2) return \"\";\n    int i = word.length()-1;\n    while(i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if(i < 0) return \"\";\n    i--;\n    while(i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if(i < 0) return \"\";\n    return word[i+1];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpb1n6ikqj.d(25): Error: no property `length` for type `string`\n/tmp/tmpb1n6ikqj.d(26): Error: no property `length` for type `string`\n/tmp/tmpb1n6ikqj.d(34): Error: cannot implicitly convert expression `word[cast(ulong)(i + 1)]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb1n6ikqj.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.length() < 2) return \"\";\n    int i = word.length() - 1;\n    while(i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if(i < 0) return \"\";\n    i++;\n    while(i < word.length() && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i++;\n    return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpps7vpejm.d(25): Error: no property `length` for type `string`\n/tmp/tmpps7vpejm.d(26): Error: no property `length` for type `string`\n/tmp/tmpps7vpejm.d(31): Error: no property `length` for type `string`\n/tmp/tmpps7vpejm.d(33): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpps7vpejm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0) {\n        if (is_vowel(word[i]))\n            return word[i];\n        i--;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmps4hbejbf.d(25): Error: no property `length` for type `string`\n/tmp/tmps4hbejbf.d(27): Error: undefined identifier `is_vowel`\n/tmp/tmps4hbejbf.d(28): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps4hbejbf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if (word.empty()) return \"\";\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    while (i < word.size() && vowels.find(word[i]) == string::npos) i++;\n    if (i == word.size()) return \"\";\n    int j = word.size() - 1;\n    while (j >= 0 && vowels.find(word[j]) == string::npos) j--;\n    if (j == -1) return \"\";\n    return word[i] + word[j];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmperrtbrbr.d(28): Error: found `:` when expecting `)`\n/tmp/tmperrtbrbr.d(28): Error: found `:` instead of statement\n/tmp/tmperrtbrbr.d(31): Error: found `:` when expecting `)`\n/tmp/tmperrtbrbr.d(31): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmperrtbrbr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.length() < 2)\n        return \"\";\n    \n    string vowels = \"aeiouAEIOU\";\n    \n    int i = word.length() - 1;\n    while(i >= 0 && vowels.find(word[i]) == string::npos)\n        i--;\n    \n    if(i == -1)\n        return \"\";\n    \n    i++;\n    while(i < word.length() && vowels.find(word[i]) == string::npos)\n        i++;\n    \n    return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmphp71ljof.d(31): Error: found `:` when expecting `)`\n/tmp/tmphp71ljof.d(31): Error: found `:` instead of statement\n/tmp/tmphp71ljof.d(38): Error: found `:` when expecting `)`\n/tmp/tmphp71ljof.d(38): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphp71ljof.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0) {\n        if (is_vowel(word[i])) {\n            return word[i];\n        }\n        i--;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp_n05rf0u.d(25): Error: no property `length` for type `string`\n/tmp/tmp_n05rf0u.d(27): Error: undefined identifier `is_vowel`\n/tmp/tmp_n05rf0u.d(28): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_n05rf0u.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int n = word.length();\n    while (i < n) {\n        if (vowels.find(word[i]) != string::npos) {\n            j = i;\n            k = i + 1;\n            while (k < n) {\n                if (vowels.find(word[k]) != string::npos) {\n                    break;\n                }\n                k++;\n            }\n            if (k == n) {\n                return word.substr(j, 1);\n            }\n            else {\n                return word.substr(j, k - j);\n            }\n        }\n        i++;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpnc_ysmr7.d(31): Error: found `:` when expecting `)`\n/tmp/tmpnc_ysmr7.d(31): Error: found `:` instead of statement\n/tmp/tmpnc_ysmr7.d(35): Error: found `:` when expecting `)`\n/tmp/tmpnc_ysmr7.d(35): Error: found `:` instead of statement\n/tmp/tmpnc_ysmr7.d(47): Error: no identifier for declarator `i`\n/tmp/tmpnc_ysmr7.d(47): Error: declaration expected, not `++`\n/tmp/tmpnc_ysmr7.d(48): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnc_ysmr7.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int n = word.length();\n    while (i < n) {\n        if (vowels.find(word[i]) != string::npos) {\n            k = i;\n            break;\n        }\n        i++;\n    }\n    while (j < n) {\n        if (vowels.find(word[j]) != string::npos) {\n            if (k == j) {\n                return word[j];\n            }\n            else {\n                return word[k];\n            }\n        }\n        j++;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp0dhf3k3u.d(31): Error: found `:` when expecting `)`\n/tmp/tmp0dhf3k3u.d(31): Error: found `:` instead of statement\n/tmp/tmp0dhf3k3u.d(37): Error: declaration expected, not `while`\n/tmp/tmp0dhf3k3u.d(41): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0dhf3k3u.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.empty()) return \"\";\n    int i = word.size()-1;\n    while(i>=0 && !is_vowel(word[i])) i--;\n    if(i==-1) return \"\";\n    while(i>=0 && !is_vowel(word[i])) i--;\n    if(i==-1) return \"\";\n    return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpi0nr7fui.d(25): Error: no property `empty` for type `string`\n/tmp/tmpi0nr7fui.d(26): Error: no property `size` for type `string`\n/tmp/tmpi0nr7fui.d(27): Error: undefined identifier `is_vowel`\n/tmp/tmpi0nr7fui.d(29): Error: undefined identifier `is_vowel`\n/tmp/tmpi0nr7fui.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi0nr7fui.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int aa = 0;\n    int bb = 0;\n    int cc = 0;\n    int dd = 0;\n    int ee = 0;\n    int ff = 0;\n    int gg = 0;\n    int hh = 0;\n    int ii = 0;\n    int jj = 0;\n    int kk = 0;\n    int ll = 0;\n    int mm = 0;\n    int nn = 0;\n    int oo = 0;\n    int pp = 0;\n    int qq = 0;\n    int rr = 0;\n    int ss = 0;\n    int tt = 0;\n    int uu = 0;\n    int vv = 0;\n    int ww = 0;\n    int xx = 0;\n    int yy =\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpurm9nps2.d(95): Error: expression expected, not `unittest`\n/tmp/tmpurm9nps2.d(96): Error: semicolon expected, not `{`\n/tmp/tmpurm9nps2.d(113): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpurm9nps2.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if (i < 0)\n        return \"\";\n    int j = i;\n    while (j >= 0 && word[j] != 'a' && word[j] != 'e' && word[j] != 'i' && word[j] != 'o' && word[j] != 'u')\n        j--;\n    if (j < 0)\n        return \"\";\n    if (i - j == 1)\n        return word[i];\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpkjcgayiv.d(25): Error: no property `length` for type `string`\n/tmp/tmpkjcgayiv.d(36): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkjcgayiv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.length() < 2)\n        return \"\";\n    int i = word.length() - 1;\n    while(i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if(i == -1)\n        return \"\";\n    if(i == 0)\n        return \"\";\n    if(i == word.length() - 1)\n        return \"\";\n    if(word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\n        return word[i];\n    else\n        return word[i + 1];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp8cn6zh1c.d(25): Error: no property `length` for type `string`\n/tmp/tmp8cn6zh1c.d(27): Error: no property `length` for type `string`\n/tmp/tmp8cn6zh1c.d(34): Error: no property `length` for type `string`\n/tmp/tmp8cn6zh1c.d(37): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\n/tmp/tmp8cn6zh1c.d(39): Error: cannot implicitly convert expression `word[cast(ulong)(i + 1)]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8cn6zh1c.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.empty()) return \"\";\n    int i = word.length() - 1;\n    while(i >= 0 && !is_vowel(word[i])) i--;\n    if(i < 0) return \"\";\n    int j = i + 1;\n    while(j < word.length() && !is_vowel(word[j])) j++;\n    return word.substr(i, j - i);\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpwxghz78u.d(25): Error: no property `empty` for type `string`\n/tmp/tmpwxghz78u.d(26): Error: no property `length` for type `string`\n/tmp/tmpwxghz78u.d(27): Error: undefined identifier `is_vowel`\n/tmp/tmpwxghz78u.d(30): Error: no property `length` for type `string`\n/tmp/tmpwxghz78u.d(30): Error: undefined identifier `is_vowel`\n/tmp/tmpwxghz78u.d(31): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwxghz78u.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    while (i < word.length()-1) {\n        if (vowels.find(word[i]) != string::npos) {\n            if (vowels.find(word[i+1]) != string::npos) {\n                return word[i];\n            }\n        }\n        i++;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp2tfkxy3o.d(28): Error: found `:` when expecting `)`\n/tmp/tmp2tfkxy3o.d(28): Error: found `:` instead of statement\n/tmp/tmp2tfkxy3o.d(33): Error: no identifier for declarator `i`\n/tmp/tmp2tfkxy3o.d(33): Error: declaration expected, not `++`\n/tmp/tmp2tfkxy3o.d(34): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2tfkxy3o.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    while (i < word.length() - 1) {\n        if (vowels.find(word[i]) != string::npos && vowels.find(word[i+1]) != string::npos) {\n            return word[i];\n        }\n        i++;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp8k8yonh9.d(28): Error: found `:` when expecting `)`\n/tmp/tmp8k8yonh9.d(28): Error: found `:` instead of statement\n/tmp/tmp8k8yonh9.d(33): Error: declaration expected, not `return`\n/tmp/tmp8k8yonh9.d(34): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8k8yonh9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int count = 0;\n    while (i < word.length())\n    {\n        if (vowels.find(word[i]) != string::npos)\n        {\n            count++;\n            if (count == 1)\n            {\n                k = i;\n            }\n        }\n        else\n        {\n            count = 0;\n        }\n        i++;\n    }\n    if (count == 0)\n    {\n        return \"\";\n    }\n    else\n    {\n        if (count == 1)\n        {\n            return word[k];\n        }\n        else\n        {\n            for (i = word.length() - 1; i >= 0; i--)\n            {\n                if (vowels.find(word[i]) != string::npos)\n                {\n                    j = i;\n                    break;\n                }\n            }\n            return word[j];\n        }\n    }\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpvoykd4tm.d(32): Error: found `:` when expecting `)`\n/tmp/tmpvoykd4tm.d(32): Error: found `:` instead of statement\n/tmp/tmpvoykd4tm.d(40): Error: found `else` without a corresponding `if`, `version` or `debug` statement\n/tmp/tmpvoykd4tm.d(44): Error: no identifier for declarator `i`\n/tmp/tmpvoykd4tm.d(44): Error: declaration expected, not `++`\n/tmp/tmpvoykd4tm.d(45): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvoykd4tm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0) {\n        if (is_vowel(word[i])) {\n            return word[i];\n        }\n        i--;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp_n05rf0u.d(25): Error: no property `length` for type `string`\n/tmp/tmp_n05rf0u.d(27): Error: undefined identifier `is_vowel`\n/tmp/tmp_n05rf0u.d(28): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_n05rf0u.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    \n    int i = 0;\n    int j = 0;\n    int k = 0;\n    \n    while (i < word.length())\n    {\n        if (vowels.find(word[i]) != string::npos)\n        {\n            i++;\n        }\n        else if (consonants.find(word[i]) != string::npos)\n        {\n            j = i + 1;\n            while (j < word.length() && consonants.find(word[j]) != string::npos)\n            {\n                j++;\n            }\n            k = j - 1;\n            while (k >= 0 && vowels.find(word[k]) == string::npos)\n            {\n                k--;\n            }\n            if (k >= 0)\n            {\n                return word[k];\n            }\n            else\n            {\n                return \"\";\n            }\n        }\n        i++;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpxf7iok4q.d(34): Error: found `:` when expecting `)`\n/tmp/tmpxf7iok4q.d(34): Error: found `:` instead of statement\n/tmp/tmpxf7iok4q.d(38): Error: found `else` without a corresponding `if`, `version` or `debug` statement\n/tmp/tmpxf7iok4q.d(41): Error: found `:` when expecting `)`\n/tmp/tmpxf7iok4q.d(41): Error: found `:` instead of statement\n/tmp/tmpxf7iok4q.d(45): Error: no identifier for declarator `k`\n/tmp/tmpxf7iok4q.d(45): Error: declaration expected, not `=`\n/tmp/tmpxf7iok4q.d(46): Error: declaration expected, not `while`\n/tmp/tmpxf7iok4q.d(49): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxf7iok4q.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < word.length()) {\n        if (vowels.find(word[i]) != string::npos) {\n            count++;\n            if (count == 1) {\n                j = i;\n            }\n        }\n        i++;\n    }\n    if (count == 0) {\n        return \"\";\n    }\n    else {\n        return word[j];\n    }\n}\n\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpggyh6p1n.d(30): Error: found `:` when expecting `)`\n/tmp/tmpggyh6p1n.d(30): Error: found `:` instead of statement\n/tmp/tmpggyh6p1n.d(38): Error: declaration expected, not `if`\n/tmp/tmpggyh6p1n.d(40): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpggyh6p1n.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.length() < 2) return \"\";\n    int i = word.length() - 1;\n    while(i >= 0 && !is_vowel(word[i])) i--;\n    if(i < 0) return \"\";\n    int j = i + 1;\n    while(j < word.length() && !is_vowel(word[j])) j++;\n    return word.substr(i, j - i);\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpcnidg8ds.d(25): Error: no property `length` for type `string`\n/tmp/tmpcnidg8ds.d(26): Error: no property `length` for type `string`\n/tmp/tmpcnidg8ds.d(27): Error: undefined identifier `is_vowel`\n/tmp/tmpcnidg8ds.d(30): Error: no property `length` for type `string`\n/tmp/tmpcnidg8ds.d(30): Error: undefined identifier `is_vowel`\n/tmp/tmpcnidg8ds.d(31): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcnidg8ds.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'y')\n        i--;\n    if (i < 0)\n        return \"\";\n    else\n        return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpfvt9ltlq.d(25): Error: no property `length` for type `string`\n/tmp/tmpfvt9ltlq.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfvt9ltlq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.length() < 2)\n        return \"\";\n    \n    string vowels = \"aeiouAEIOU\";\n    int i = 1;\n    while(i < word.length() && vowels.find(word[i]) == string::npos)\n        i++;\n    \n    if(i == word.length())\n        return \"\";\n    \n    int j = word.length() - 1;\n    while(j >= i && vowels.find(word[j]) == string::npos)\n        j--;\n    \n    if(j == i)\n        return \"\";\n    \n    return word[i] + word[j];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpn4ttmbo0.d(30): Error: found `:` when expecting `)`\n/tmp/tmpn4ttmbo0.d(30): Error: found `:` instead of statement\n/tmp/tmpn4ttmbo0.d(37): Error: found `:` when expecting `)`\n/tmp/tmpn4ttmbo0.d(37): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn4ttmbo0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.length() < 2)\n        return \"\";\n    \n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    while(i < word.length() - 1)\n    {\n        if(vowels.find(word[i]) != string::npos)\n            break;\n        i++;\n    }\n    \n    if(i == word.length() - 1)\n        return \"\";\n    \n    int j = i + 1;\n    while(j < word.length())\n    {\n        if(vowels.find(word[j]) != string::npos)\n            return word[j];\n        j++;\n    }\n    \n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmphleg9lfo.d(32): Error: found `:` when expecting `)`\n/tmp/tmphleg9lfo.d(32): Error: found `:` instead of statement\n/tmp/tmphleg9lfo.d(43): Error: found `:` when expecting `)`\n/tmp/tmphleg9lfo.d(43): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphleg9lfo.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.length() < 2) return \"\";\n    int i = word.length() - 1;\n    while(i >= 0 && !isalpha(word[i])) i--;\n    if(i < 0) return \"\";\n    int j = i + 1;\n    while(j < word.length() && !isalpha(word[j])) j++;\n    if(j >= word.length()) return \"\";\n    return word[i] == word[j] ? word[i] : word[j];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpqoy8rzww.d(25): Error: no property `length` for type `string`\n/tmp/tmpqoy8rzww.d(26): Error: no property `length` for type `string`\n/tmp/tmpqoy8rzww.d(27): Error: undefined identifier `isalpha`\n/tmp/tmpqoy8rzww.d(30): Error: no property `length` for type `string`\n/tmp/tmpqoy8rzww.d(30): Error: undefined identifier `isalpha`\n/tmp/tmpqoy8rzww.d(31): Error: no property `length` for type `string`\n/tmp/tmpqoy8rzww.d(32): Error: cannot implicitly convert expression `cast(int)word[cast(ulong)i] == cast(int)word[cast(ulong)j] ? word[cast(ulong)i] : word[cast(ulong)j]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqoy8rzww.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpnrmao08j.d(98): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnrmao08j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.length() < 2)\n        return \"\";\n    int i = word.length() - 1;\n    while(i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if(i == -1)\n        return \"\";\n    if(i == 0)\n        return \"\";\n    if(i == word.length() - 1)\n        return \"\";\n    if(word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\n        return word[i];\n    else\n        return word[i + 1];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp8cn6zh1c.d(25): Error: no property `length` for type `string`\n/tmp/tmp8cn6zh1c.d(27): Error: no property `length` for type `string`\n/tmp/tmp8cn6zh1c.d(34): Error: no property `length` for type `string`\n/tmp/tmp8cn6zh1c.d(37): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\n/tmp/tmp8cn6zh1c.d(39): Error: cannot implicitly convert expression `word[cast(ulong)(i + 1)]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8cn6zh1c.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length()-1;\n    while(i>=0 && word[i]!='a' && word[i]!='e' && word[i]!='i' && word[i]!='o' && word[i]!='u')\n        i--;\n    if(i<0)\n        return \"\";\n    else\n        return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp8y4p4m3e.d(25): Error: no property `length` for type `string`\n/tmp/tmp8y4p4m3e.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8y4p4m3e.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while(i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if(i < 0)\n        return \"\";\n    if(i == 0)\n        return \"\";\n    if(word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\n        return word[i];\n    if(word[i] == 'y')\n        return word[i];\n    if(word[i] == 'q')\n        return word[i];\n    if(word[i] == 'x')\n        return word[i];\n    if(word[i] == 'z')\n        return word[i];\n    if(word[i] == 'h')\n        return word[i];\n    if(word[i] == 'w')\n        return word[i];\n    if(word[i] == 'r')\n        return word[i];\n    if(word[i] == 't')\n        return word[i];\n    if(word[i] == 'n')\n        return word[i];\n    if(word[i] == 'l')\n        return word[i];\n    if(word[i] == 's')\n        return word[i];\n    if(word[i] == 'g')\n        return word[i];\n    if(word[i] == 'b')\n        return word[i];\n    if(word[i] == 'd')\n        return word[i];\n    if(word[i] == 'p')\n        return word[i];\n    if(word[i] == 'm')\n        return word[i];\n    if(word[i] == 'c')\n        return word[i];\n    if(word[i] == 'v')\n        return word[i];\n    if(word[i] == 'f')\n        return word[i];\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmppk1l68tb.d(72): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppk1l68tb.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while(i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if(i == -1)\n        return \"\";\n    else\n        return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpq6hkhkmd.d(25): Error: no property `length` for type `string`\n/tmp/tmpq6hkhkmd.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq6hkhkmd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.length() < 2)\n        return \"\";\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    while(i < word.length()-1)\n    {\n        if(vowels.find(word[i]) != string::npos)\n            break;\n        i++;\n    }\n    if(i == word.length()-1)\n        return \"\";\n    int j = i+1;\n    while(j < word.length())\n    {\n        if(vowels.find(word[j]) != string::npos)\n            return word[j];\n        j++;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpmd_3bqf3.d(31): Error: found `:` when expecting `)`\n/tmp/tmpmd_3bqf3.d(31): Error: found `:` instead of statement\n/tmp/tmpmd_3bqf3.d(40): Error: found `:` when expecting `)`\n/tmp/tmpmd_3bqf3.d(40): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmd_3bqf3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    while (i < word.length() - 1) {\n        if (vowels.find(word[i]) != string::npos && vowels.find(word[i+1]) != string::npos) {\n            return word[i];\n        }\n        i++;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp8k8yonh9.d(28): Error: found `:` when expecting `)`\n/tmp/tmp8k8yonh9.d(28): Error: found `:` instead of statement\n/tmp/tmp8k8yonh9.d(33): Error: declaration expected, not `return`\n/tmp/tmp8k8yonh9.d(34): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8k8yonh9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int aa = 0;\n    int bb = 0;\n    int cc = 0;\n    int dd = 0;\n    int ee = 0;\n    int ff = 0;\n    int gg = 0;\n    int hh = 0;\n    int ii = 0;\n    int jj = 0;\n    int kk = 0;\n    int ll = 0;\n    int mm = 0;\n    int nn = 0;\n    int oo = 0;\n    int pp = 0;\n    int qq = 0;\n    int rr = 0;\n    int ss = 0;\n    int tt = 0;\n    int uu = 0;\n    int vv = 0;\n    int ww = 0;\n    int xx = 0;\n    int yy =\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpurm9nps2.d(95): Error: expression expected, not `unittest`\n/tmp/tmpurm9nps2.d(96): Error: semicolon expected, not `{`\n/tmp/tmpurm9nps2.d(113): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpurm9nps2.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if (i < 0)\n        return \"\";\n    else\n        return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp76o1iji6.d(25): Error: no property `length` for type `string`\n/tmp/tmp76o1iji6.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp76o1iji6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    int j = 0;\n    int len = word.length();\n    while (i < len)\n    {\n        if (word[i] == ' ')\n            i++;\n        else if (vowels.find(word[i]) != string::npos)\n        {\n            if (j == 0)\n                j = i;\n            else\n                return word[j] + word[i];\n        }\n        i++;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp05sh3sqo.d(33): Error: found `:` when expecting `)`\n/tmp/tmp05sh3sqo.d(33): Error: found `:` instead of statement\n/tmp/tmp05sh3sqo.d(42): Error: declaration expected, not `return`\n/tmp/tmp05sh3sqo.d(43): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp05sh3sqo.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    while(i < word.length()-1)\n    {\n        if(vowels.find(word[i]) != string::npos)\n        {\n            i++;\n            continue;\n        }\n        if(vowels.find(word[i+1]) != string::npos)\n        {\n            return word[i];\n        }\n        i++;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp332zar7a.d(29): Error: found `:` when expecting `)`\n/tmp/tmp332zar7a.d(29): Error: found `:` instead of statement\n/tmp/tmp332zar7a.d(34): Error: found `:` when expecting `)`\n/tmp/tmp332zar7a.d(34): Error: found `:` instead of statement\n/tmp/tmp332zar7a.d(38): Error: no identifier for declarator `i`\n/tmp/tmp332zar7a.d(38): Error: declaration expected, not `++`\n/tmp/tmp332zar7a.d(39): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp332zar7a.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    int j = 0;\n    while (i < word.length() && j < word.length()) {\n        if (vowels.find(word[i]) != string::npos) {\n            j = i + 1;\n        }\n        else if (vowels.find(word[j]) != string::npos) {\n            i = j + 1;\n        }\n        else {\n            i++;\n            j++;\n        }\n    }\n    if (i == word.length() || j == word.length()) {\n        return \"\";\n    }\n    else {\n        return word[i];\n    }\n}\n\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp_ekrzghn.d(29): Error: found `:` when expecting `)`\n/tmp/tmp_ekrzghn.d(29): Error: found `:` instead of statement\n/tmp/tmp_ekrzghn.d(32): Error: found `else` without a corresponding `if`, `version` or `debug` statement\n/tmp/tmp_ekrzghn.d(35): Error: declaration expected, not `else`\n/tmp/tmp_ekrzghn.d(37): Error: no identifier for declarator `j`\n/tmp/tmp_ekrzghn.d(37): Error: declaration expected, not `++`\n/tmp/tmp_ekrzghn.d(38): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_ekrzghn.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length()-1;\n    while(i>=0 && !is_vowel(word[i]))\n        i--;\n    if(i<0)\n        return \"\";\n    int j = i-1;\n    while(j>=0 && !is_vowel(word[j]))\n        j--;\n    if(j<0)\n        return \"\";\n    return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpqy4kg8bt.d(25): Error: no property `length` for type `string`\n/tmp/tmpqy4kg8bt.d(26): Error: undefined identifier `is_vowel`\n/tmp/tmpqy4kg8bt.d(31): Error: undefined identifier `is_vowel`\n/tmp/tmpqy4kg8bt.d(35): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqy4kg8bt.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length()-1;\n    while(i>=0 && word[i]!='a' && word[i]!='e' && word[i]!='i' && word[i]!='o' && word[i]!='u' && word[i]!='A' && word[i]!='E' && word[i]!='I' && word[i]!='O' && word[i]!='U')\n        i--;\n    if(i==-1)\n        return \"\";\n    else\n        return word[i];\n}\n\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpdzyevcup.d(25): Error: no property `length` for type `string`\n/tmp/tmpdzyevcup.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdzyevcup.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if (word.size() < 2) return \"\";\n    int i = word.size() - 1;\n    while (i >= 0 && !is_vowel(word[i])) i--;\n    if (i < 0) return \"\";\n    int j = i + 1;\n    while (j < word.size() && !is_vowel(word[j])) j++;\n    if (j == word.size()) return \"\";\n    return word[i+1];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmphbcoekcd.d(25): Error: no property `size` for type `string`\n/tmp/tmphbcoekcd.d(26): Error: no property `size` for type `string`\n/tmp/tmphbcoekcd.d(27): Error: undefined identifier `is_vowel`\n/tmp/tmphbcoekcd.d(30): Error: no property `size` for type `string`\n/tmp/tmphbcoekcd.d(30): Error: undefined identifier `is_vowel`\n/tmp/tmphbcoekcd.d(31): Error: no property `size` for type `string`\n/tmp/tmphbcoekcd.d(32): Error: cannot implicitly convert expression `word[cast(ulong)(i + 1)]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphbcoekcd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.empty()) return \"\";\n    int i = word.length()-1;\n    while(i>=0 && !is_vowel(word[i])) i--;\n    if(i<0) return \"\";\n    int j = i;\n    while(j>=0 && !is_vowel(word[j])) j--;\n    if(j<0) return \"\";\n    return word[j+1];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp3w7gs2vi.d(25): Error: no property `empty` for type `string`\n/tmp/tmp3w7gs2vi.d(26): Error: no property `length` for type `string`\n/tmp/tmp3w7gs2vi.d(27): Error: undefined identifier `is_vowel`\n/tmp/tmp3w7gs2vi.d(30): Error: undefined identifier `is_vowel`\n/tmp/tmp3w7gs2vi.d(32): Error: cannot implicitly convert expression `word[cast(ulong)(j + 1)]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3w7gs2vi.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length()-1;\n    while(i>=0 && word[i]!='a' && word[i]!='e' && word[i]!='i' && word[i]!='o' && word[i]!='u')\n        i--;\n    if(i<0)\n        return \"\";\n    else\n        return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp8y4p4m3e.d(25): Error: no property `length` for type `string`\n/tmp/tmp8y4p4m3e.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8y4p4m3e.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.size() < 2) return \"\";\n    string vowels = \"aeiouAEIOU\";\n    int i = 1;\n    while(i < word.size()-1)\n    {\n        if(vowels.find(word[i]) != string::npos)\n        {\n            if(vowels.find(word[i+1]) != string::npos)\n            {\n                return word[i];\n            }\n        }\n        i++;\n    }\n    return \"\";\n}\n\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpbl08yaws.d(30): Error: found `:` when expecting `)`\n/tmp/tmpbl08yaws.d(30): Error: found `:` instead of statement\n/tmp/tmpbl08yaws.d(37): Error: no identifier for declarator `i`\n/tmp/tmpbl08yaws.d(37): Error: declaration expected, not `++`\n/tmp/tmpbl08yaws.d(38): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbl08yaws.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0) {\n        if (word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\n            return word[i];\n        i--;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpn1m_ri_0.d(25): Error: no property `length` for type `string`\n/tmp/tmpn1m_ri_0.d(28): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn1m_ri_0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length()-1;\n    while(i>=0 && word[i]!='a' && word[i]!='e' && word[i]!='i' && word[i]!='o' && word[i]!='u')\n        i--;\n    if(i==-1)\n        return \"\";\n    else\n        return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp6e99ebwx.d(25): Error: no property `length` for type `string`\n/tmp/tmp6e99ebwx.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6e99ebwx.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length()-1;\n    while(i>=0 && word[i]!='a' && word[i]!='e' && word[i]!='i' && word[i]!='o' && word[i]!='u' && word[i]!='A' && word[i]!='E' && word[i]!='I' && word[i]!='O' && word[i]!='U')\n        i--;\n    if(i==-1)\n        return \"\";\n    else\n        return word[i];\n}\n\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpdzyevcup.d(25): Error: no property `length` for type `string`\n/tmp/tmpdzyevcup.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdzyevcup.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    while (i < word.length()-1) {\n        if (vowels.find(word[i]) != string::npos) {\n            i++;\n            continue;\n        }\n        if (vowels.find(word[i+1]) != string::npos) {\n            return word[i];\n        }\n        i++;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpku6hvmtf.d(28): Error: found `:` when expecting `)`\n/tmp/tmpku6hvmtf.d(28): Error: found `:` instead of statement\n/tmp/tmpku6hvmtf.d(32): Error: found `:` when expecting `)`\n/tmp/tmpku6hvmtf.d(32): Error: found `:` instead of statement\n/tmp/tmpku6hvmtf.d(35): Error: no identifier for declarator `i`\n/tmp/tmpku6hvmtf.d(35): Error: declaration expected, not `++`\n/tmp/tmpku6hvmtf.d(36): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpku6hvmtf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.length() < 2)\n        return \"\";\n    int i = word.length() - 1;\n    while(i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if(i < 0)\n        return \"\";\n    i--;\n    while(i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if(i < 0)\n        return \"\";\n    return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpoymmuaxk.d(25): Error: no property `length` for type `string`\n/tmp/tmpoymmuaxk.d(27): Error: no property `length` for type `string`\n/tmp/tmpoymmuaxk.d(37): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoymmuaxk.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.size() < 2) return \"\";\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    while(i < word.size()-1)\n    {\n        if(vowels.find(word[i]) != string::npos)\n        {\n            i++;\n            while(i < word.size()-1 && vowels.find(word[i]) == string::npos)\n            {\n                i++;\n            }\n            if(i < word.size()-1)\n            {\n                i++;\n                while(i < word.size()-1 && vowels.find(word[i]) == string::npos)\n                {\n                    i++;\n                }\n                if(i < word.size()-1)\n                {\n                    return word[i];\n                }\n            }\n        }\n        i++;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp1zkph150.d(30): Error: found `:` when expecting `)`\n/tmp/tmp1zkph150.d(30): Error: found `:` instead of statement\n/tmp/tmp1zkph150.d(33): Error: found `:` when expecting `)`\n/tmp/tmp1zkph150.d(33): Error: found `:` instead of statement\n/tmp/tmp1zkph150.d(40): Error: found `:` when expecting `)`\n/tmp/tmp1zkph150.d(40): Error: found `:` instead of statement\n/tmp/tmp1zkph150.d(49): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1zkph150.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int aa = 0;\n    int bb = 0;\n    int cc = 0;\n    int dd = 0;\n    int ee = 0;\n    int ff = 0;\n    int gg = 0;\n    int hh = 0;\n    int ii = 0;\n    int jj = 0;\n    int kk = 0;\n    int ll = 0;\n    int mm = 0;\n    int nn = 0;\n    int oo = 0;\n    int pp = 0;\n    int qq = 0;\n    int rr = 0;\n    int ss = 0;\n    int tt = 0;\n    int uu = 0;\n    int vv = 0;\n    int ww = 0;\n    int xx = 0;\n    int yy =\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpurm9nps2.d(95): Error: expression expected, not `unittest`\n/tmp/tmpurm9nps2.d(96): Error: semicolon expected, not `{`\n/tmp/tmpurm9nps2.d(113): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpurm9nps2.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length()-1;\n    while (i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' && word[i] != 'E' && word[i] != 'I' && word[i] != 'O' && word[i] != 'U')\n        i--;\n    if (i < 0)\n        return \"\";\n    else\n        return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpou7xtwzi.d(25): Error: no property `length` for type `string`\n/tmp/tmpou7xtwzi.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpou7xtwzi.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length()-1;\n    while(i>=0 && word[i]!='a' && word[i]!='e' && word[i]!='i' && word[i]!='o' && word[i]!='u')\n        i--;\n    if(i<0)\n        return \"\";\n    else\n        return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp8y4p4m3e.d(25): Error: no property `length` for type `string`\n/tmp/tmp8y4p4m3e.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8y4p4m3e.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0) {\n        if (word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\n            return word[i];\n        i--;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpn1m_ri_0.d(25): Error: no property `length` for type `string`\n/tmp/tmpn1m_ri_0.d(28): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn1m_ri_0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while(i >= 0)\n    {\n        if(is_vowel(word[i]))\n            return word[i];\n        i--;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp9owhnn9f.d(25): Error: no property `length` for type `string`\n/tmp/tmp9owhnn9f.d(28): Error: undefined identifier `is_vowel`\n/tmp/tmp9owhnn9f.d(29): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9owhnn9f.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length()-1;\n    while(i>=0 && word[i]!='a' && word[i]!='e' && word[i]!='i' && word[i]!='o' && word[i]!='u' && word[i]!='A' && word[i]!='E' && word[i]!='I' && word[i]!='O' && word[i]!='U')\n        i--;\n    if(i==-1)\n        return \"\";\n    else\n        return word[i];\n}\n\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpdzyevcup.d(25): Error: no property `length` for type `string`\n/tmp/tmpdzyevcup.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdzyevcup.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    while (i < word.length()) {\n        if (vowels.find(word[i]) != string::npos) {\n            j = i;\n            k = i + 1;\n            while (k < word.length() && vowels.find(word[k]) != string::npos) {\n                k++;\n            }\n            if (k - j > 1) {\n                return word.substr(j, k - j);\n            }\n        }\n        i++;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpmcj_ntii.d(30): Error: found `:` when expecting `)`\n/tmp/tmpmcj_ntii.d(30): Error: found `:` instead of statement\n/tmp/tmpmcj_ntii.d(33): Error: found `:` when expecting `)`\n/tmp/tmpmcj_ntii.d(33): Error: found `:` instead of statement\n/tmp/tmpmcj_ntii.d(40): Error: no identifier for declarator `i`\n/tmp/tmpmcj_ntii.d(40): Error: declaration expected, not `++`\n/tmp/tmpmcj_ntii.d(41): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmcj_ntii.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int aa = 0;\n    int bb = 0;\n    int cc = 0;\n    int dd = 0;\n    int ee = 0;\n    int ff = 0;\n    int gg = 0;\n    int hh = 0;\n    int ii = 0;\n    int jj = 0;\n    int kk = 0;\n    int ll = 0;\n    int mm = 0;\n    int nn = 0;\n    int oo = 0;\n    int pp = 0;\n    int qq = 0;\n    int rr = 0;\n    int ss = 0;\n    int tt = 0;\n    int uu = 0;\n    int vv = 0;\n    int ww = 0;\n    int xx = 0;\n    int yy =\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpurm9nps2.d(95): Error: expression expected, not `unittest`\n/tmp/tmpurm9nps2.d(96): Error: semicolon expected, not `{`\n/tmp/tmpurm9nps2.d(113): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpurm9nps2.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    \n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    \n    while (i < word.length() && j < word.length() && k < word.length() && l < word.length() && m < word.length() && n < word.length() && o < word.length() && p < word.length() && q < word.length() && r < word.length() && s < word.length() && t < word.length() && u < word.length() && v < word.length() && w < word.length() && x < word.length() && y < word.length() && z < word.length())\n    {\n        if (vowels.find(word[i]) != string::npos && vowels.find(word[j]) != string::npos && vowels.find(word[k]) != string::npos && vowels.find(word[l]) != string::npos && vowels.find(word[m]) != string::npos && vowels.find(word[n]) != string::npos && vowels.find(word[o]) != string::npos && vowels.find(word[p]) != string::npos && vowels.find(word[q]) != string::npos && vowels.find(word[r]) != string::npos && vowels.find(word[s]) != string::npos && vowels.find(word[t]) != string::npos && vowels.find(word[u]) != string::npos &&\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpu8v_9ru3.d(49): Error: found `:` when expecting `)`\n/tmp/tmpu8v_9ru3.d(49): Error: found `:` instead of statement\n/tmp/tmpu8v_9ru3.d(68): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu8v_9ru3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int aa = 0;\n    int bb = 0;\n    int cc = 0;\n    int dd = 0;\n    int ee = 0;\n    int ff = 0;\n    int gg = 0;\n    int hh = 0;\n    int ii = 0;\n    int jj = 0;\n    int kk = 0;\n    int ll = 0;\n    int mm = 0;\n    int nn = 0;\n    int oo = 0;\n    int pp = 0;\n    int qq = 0;\n    int rr = 0;\n    int ss = 0;\n    int tt = 0;\n    int uu = 0;\n    int vv = 0;\n    int ww = 0;\n    int xx = 0;\n    int yy =\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpurm9nps2.d(95): Error: expression expected, not `unittest`\n/tmp/tmpurm9nps2.d(96): Error: semicolon expected, not `{`\n/tmp/tmpurm9nps2.d(113): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpurm9nps2.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if (word.size() < 2) return \"\";\n    int i = word.size()-1;\n    while (i >= 0 && !is_vowel(word[i])) --i;\n    if (i < 0) return \"\";\n    while (i >= 0 && !is_vowel(word[i])) --i;\n    return word[i+1];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpuoh9m1c5.d(25): Error: no property `size` for type `string`\n/tmp/tmpuoh9m1c5.d(26): Error: no property `size` for type `string`\n/tmp/tmpuoh9m1c5.d(27): Error: undefined identifier `is_vowel`\n/tmp/tmpuoh9m1c5.d(29): Error: undefined identifier `is_vowel`\n/tmp/tmpuoh9m1c5.d(30): Error: cannot implicitly convert expression `word[cast(ulong)(i + 1)]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuoh9m1c5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.length() < 2) return \"\";\n    string vowels = \"aeiouAEIOU\";\n    string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int i = 0;\n    while(i < word.length() - 1)\n    {\n        if(vowels.find(word[i]) != string::npos)\n        {\n            if(consonants.find(word[i+1]) != string::npos)\n            {\n                return word[i];\n            }\n        }\n        i++;\n    }\n    return \"\";\n}\n\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpi0yl7pz9.d(31): Error: found `:` when expecting `)`\n/tmp/tmpi0yl7pz9.d(31): Error: found `:` instead of statement\n/tmp/tmpi0yl7pz9.d(38): Error: no identifier for declarator `i`\n/tmp/tmpi0yl7pz9.d(38): Error: declaration expected, not `++`\n/tmp/tmpi0yl7pz9.d(39): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi0yl7pz9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if (i < 0)\n        return \"\";\n    else\n        return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp76o1iji6.d(25): Error: no property `length` for type `string`\n/tmp/tmp76o1iji6.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp76o1iji6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    while (i < word.length() - 1) {\n        if (vowels.find(word[i]) != string::npos && vowels.find(word[i+1]) != string::npos) {\n            return word[i];\n        }\n        i++;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp8k8yonh9.d(28): Error: found `:` when expecting `)`\n/tmp/tmp8k8yonh9.d(28): Error: found `:` instead of statement\n/tmp/tmp8k8yonh9.d(33): Error: declaration expected, not `return`\n/tmp/tmp8k8yonh9.d(34): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8k8yonh9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    while(i < word.length()-1)\n    {\n        if(vowels.find(word[i]) != string::npos)\n        {\n            if(vowels.find(word[i+1]) != string::npos)\n            {\n                return word[i+1];\n            }\n        }\n        i++;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpqzz1vle5.d(29): Error: found `:` when expecting `)`\n/tmp/tmpqzz1vle5.d(29): Error: found `:` instead of statement\n/tmp/tmpqzz1vle5.d(36): Error: no identifier for declarator `i`\n/tmp/tmpqzz1vle5.d(36): Error: declaration expected, not `++`\n/tmp/tmpqzz1vle5.d(37): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqzz1vle5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int A = 0;\n    int B = 0;\n    int C = 0;\n    int D = 0;\n    int E = 0;\n    int F = 0;\n    int G = 0;\n    int H = 0;\n    int I = 0;\n    int J = 0;\n    int K = 0;\n    int L = 0;\n    int M = 0;\n    int N = 0;\n    int O = 0;\n    int P = 0;\n    int Q = 0;\n    int R = 0;\n    int S = 0;\n    int T = 0;\n    int U = 0;\n    int V = 0;\n    int W = 0;\n    int X = 0;\n    int Y = 0;\n    int Z = 0;\n    int _ = 0;\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpyqdsy5ac.d(97): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyqdsy5ac.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    int j = 0;\n    int len = word.length();\n    while(i < len)\n    {\n        if(word[i] == ' ')\n            i++;\n        else if(vowels.find(word[i]) != string::npos)\n            j = i;\n        i++;\n    }\n    if(j == 0)\n        return \"\";\n    else\n        return word[j];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp9lprjnhq.d(33): Error: found `:` when expecting `)`\n/tmp/tmp9lprjnhq.d(33): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9lprjnhq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0) {\n        if (is_vowel(word[i])) {\n            return word[i];\n        }\n        i--;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp_n05rf0u.d(25): Error: no property `length` for type `string`\n/tmp/tmp_n05rf0u.d(27): Error: undefined identifier `is_vowel`\n/tmp/tmp_n05rf0u.d(28): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_n05rf0u.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < word.length() && j < word.length())\n    {\n        if(vowels.find(word[i]) != string::npos)\n        {\n            count++;\n            if(count == 1)\n            {\n                j = i;\n            }\n        }\n        else\n        {\n            if(count == 0)\n            {\n                j = i;\n            }\n            count = 0;\n        }\n        i++;\n    }\n    if(count == 0)\n    {\n        return \"\";\n    }\n    else\n    {\n        return word[j];\n    }\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpw0_ybg1l.d(31): Error: found `:` when expecting `)`\n/tmp/tmpw0_ybg1l.d(31): Error: found `:` instead of statement\n/tmp/tmpw0_ybg1l.d(39): Error: found `else` without a corresponding `if`, `version` or `debug` statement\n/tmp/tmpw0_ybg1l.d(45): Error: no identifier for declarator `count`\n/tmp/tmpw0_ybg1l.d(45): Error: declaration expected, not `=`\n/tmp/tmpw0_ybg1l.d(46): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw0_ybg1l.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0 && !is_vowel(word[i]))\n        i--;\n    if (i < 0)\n        return \"\";\n    int j = i + 1;\n    while (j < word.length() && !is_vowel(word[j]))\n        j++;\n    return word[j];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpqpv9up7o.d(25): Error: no property `length` for type `string`\n/tmp/tmpqpv9up7o.d(26): Error: undefined identifier `is_vowel`\n/tmp/tmpqpv9up7o.d(31): Error: no property `length` for type `string`\n/tmp/tmpqpv9up7o.d(31): Error: undefined identifier `is_vowel`\n/tmp/tmpqpv9up7o.d(33): Error: cannot implicitly convert expression `word[cast(ulong)j]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqpv9up7o.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length()-1;\n    while (i >= 0)\n    {\n        if (is_vowel(word[i]))\n            return word[i];\n        i--;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpm6x0dnrt.d(25): Error: no property `length` for type `string`\n/tmp/tmpm6x0dnrt.d(28): Error: undefined identifier `is_vowel`\n/tmp/tmpm6x0dnrt.d(29): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm6x0dnrt.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if (word.length() < 2) return \"\";\n    string vowels = \"aeiouAEIOU\";\n    int i = 1;\n    while (i < word.length() && vowels.find(word[i]) == string::npos)\n        i++;\n    if (i == word.length()) return \"\";\n    int j = word.length() - 1;\n    while (j >= 0 && vowels.find(word[j]) == string::npos)\n        j--;\n    if (j == -1) return \"\";\n    return word[i] + word[j];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpgw5iisgj.d(28): Error: found `:` when expecting `)`\n/tmp/tmpgw5iisgj.d(28): Error: found `:` instead of statement\n/tmp/tmpgw5iisgj.d(32): Error: found `:` when expecting `)`\n/tmp/tmpgw5iisgj.d(32): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgw5iisgj.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int n = word.length();\n    while(i < n && j < n && k < n)\n    {\n        if(word[i] == word[j] && word[j] == word[k])\n        {\n            if(vowels.find(word[i]) != string::npos)\n                return word[i];\n            i++;\n            j++;\n            k++;\n        }\n        else if(word[i] == word[j])\n        {\n            if(vowels.find(word[i]) != string::npos)\n                return word[i];\n            i++;\n            j++;\n        }\n        else if(word[j] == word[k])\n        {\n            if(vowels.find(word[j]) != string::npos)\n                return word[j];\n            j++;\n            k++;\n        }\n        else if(word[i] == word[k])\n        {\n            if(vowels.find(word[i]) != string::npos)\n                return word[i];\n            i++;\n            k++;\n        }\n        else if(word[j] == word[k])\n        {\n            if(vowels.find(word[j]) != string::npos)\n                return word[j];\n            j++;\n            k++;\n        }\n        else if(word[i] == word[k])\n        {\n            if(vowels.find(word[i]) != string::npos)\n                return word[i];\n            i++;\n            k++;\n        }\n        else if(word[j] == word[i])\n        {\n            if(vowels.find(word[j]) != string::npos)\n                return word[j];\n            j++;\n            i++;\n        }\n        else if(word[k] == word[i])\n        {\n            if(vowels.find(word[k]) != string::npos)\n                return word[k];\n            k++;\n            \nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp5ami98rd.d(34): Error: found `:` when expecting `)`\n/tmp/tmp5ami98rd.d(34): Error: found `:` instead of statement\n/tmp/tmp5ami98rd.d(42): Error: found `:` when expecting `)`\n/tmp/tmp5ami98rd.d(42): Error: found `:` instead of statement\n/tmp/tmp5ami98rd.d(49): Error: found `:` when expecting `)`\n/tmp/tmp5ami98rd.d(49): Error: found `:` instead of statement\n/tmp/tmp5ami98rd.d(56): Error: found `:` when expecting `)`\n/tmp/tmp5ami98rd.d(56): Error: found `:` instead of statement\n/tmp/tmp5ami98rd.d(63): Error: found `:` when expecting `)`\n/tmp/tmp5ami98rd.d(63): Error: found `:` instead of statement\n/tmp/tmp5ami98rd.d(70): Error: found `:` when expecting `)`\n/tmp/tmp5ami98rd.d(70): Error: found `:` instead of statement\n/tmp/tmp5ami98rd.d(77): Error: found `:` when expecting `)`\n/tmp/tmp5ami98rd.d(77): Error: found `:` instead of statement\n/tmp/tmp5ami98rd.d(84): Error: found `:` when expecting `)`\n/tmp/tmp5ami98rd.d(84): Error: found `:` instead of statement\n/tmp/tmp5ami98rd.d(88): Error: found `unittest` ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.length() < 2)\n        return \"\";\n    int i = word.length() - 1;\n    while(i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if(i < 0)\n        return \"\";\n    if(i == 0)\n        return \"\";\n    if(i == 1)\n        return word[i];\n    if(word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\n        return word[i];\n    return word[i - 1];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp49mq4b4h.d(25): Error: no property `length` for type `string`\n/tmp/tmp49mq4b4h.d(27): Error: no property `length` for type `string`\n/tmp/tmp49mq4b4h.d(35): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\n/tmp/tmp49mq4b4h.d(37): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\n/tmp/tmp49mq4b4h.d(38): Error: cannot implicitly convert expression `word[cast(ulong)(i - 1)]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp49mq4b4h.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    while (i < word.length() && vowels.find(word[i]) == string::npos)\n        i++;\n    if (i == word.length())\n        return \"\";\n    int j = word.length() - 1;\n    while (j >= 0 && vowels.find(word[j]) == string::npos)\n        j--;\n    if (j == -1)\n        return \"\";\n    return word[i] + word[j];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpnsezprz1.d(27): Error: found `:` when expecting `)`\n/tmp/tmpnsezprz1.d(27): Error: found `:` instead of statement\n/tmp/tmpnsezprz1.d(32): Error: found `:` when expecting `)`\n/tmp/tmpnsezprz1.d(32): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnsezprz1.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0 && !is_vowel(word[i]))\n        i--;\n    if (i < 0)\n        return \"\";\n    int j = i + 1;\n    while (j < word.length() && !is_vowel(word[j]))\n        j++;\n    return word[j];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpqpv9up7o.d(25): Error: no property `length` for type `string`\n/tmp/tmpqpv9up7o.d(26): Error: undefined identifier `is_vowel`\n/tmp/tmpqpv9up7o.d(31): Error: no property `length` for type `string`\n/tmp/tmpqpv9up7o.d(31): Error: undefined identifier `is_vowel`\n/tmp/tmpqpv9up7o.d(33): Error: cannot implicitly convert expression `word[cast(ulong)j]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqpv9up7o.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.length() < 2)\n        return \"\";\n    int i = word.length() - 1;\n    while(i >= 0 && !is_vowel(word[i]))\n        i--;\n    if(i < 0)\n        return \"\";\n    int j = i + 1;\n    while(j < word.length() && !is_vowel(word[j]))\n        j++;\n    if(j >= word.length())\n        return \"\";\n    return word[i] + word[j];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpbkmsfm7w.d(25): Error: no property `length` for type `string`\n/tmp/tmpbkmsfm7w.d(27): Error: no property `length` for type `string`\n/tmp/tmpbkmsfm7w.d(28): Error: undefined identifier `is_vowel`\n/tmp/tmpbkmsfm7w.d(33): Error: no property `length` for type `string`\n/tmp/tmpbkmsfm7w.d(33): Error: undefined identifier `is_vowel`\n/tmp/tmpbkmsfm7w.d(35): Error: no property `length` for type `string`\n/tmp/tmpbkmsfm7w.d(37): Error: cannot implicitly convert expression `cast(int)word[cast(ulong)i] + cast(int)word[cast(ulong)j]` of type `int` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbkmsfm7w.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if (word.empty()) return \"\";\n    int i = word.length() - 1;\n    while (i >= 0 && !is_vowel(word[i])) i--;\n    if (i < 0) return \"\";\n    i++;\n    while (i < word.length() && !is_vowel(word[i])) i++;\n    return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpbmz2fofq.d(25): Error: no property `empty` for type `string`\n/tmp/tmpbmz2fofq.d(26): Error: no property `length` for type `string`\n/tmp/tmpbmz2fofq.d(27): Error: undefined identifier `is_vowel`\n/tmp/tmpbmz2fofq.d(30): Error: no property `length` for type `string`\n/tmp/tmpbmz2fofq.d(30): Error: undefined identifier `is_vowel`\n/tmp/tmpbmz2fofq.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbmz2fofq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int A = 0;\n    int B = 0;\n    int C = 0;\n    int D = 0;\n    int E = 0;\n    int F = 0;\n    int G = 0;\n    int H = 0;\n    int I = 0;\n    int J = 0;\n    int K = 0;\n    int L = 0;\n    int M = 0;\n    int N = 0;\n    int O = 0;\n    int P = 0;\n    int Q = 0;\n    int R = 0;\n    int S = 0;\n    int T = 0;\n    int U = 0;\n    int V = 0;\n    int W = 0;\n    int X = 0;\n    int Y = 0;\n    int Z = 0;\n    int _ = 0;\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpyqdsy5ac.d(97): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyqdsy5ac.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if (i < 0)\n        return \"\";\n    i--;\n    while (i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if (i < 0)\n        return \"\";\n    return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpy1xznsj2.d(25): Error: no property `length` for type `string`\n/tmp/tmpy1xznsj2.d(35): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy1xznsj2.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.size() < 2) return \"\";\n    string vowels = \"aeiouAEIOU\";\n    int i = word.size()-1;\n    while(i >= 0 && vowels.find(word[i]) == string::npos)\n        i--;\n    if(i < 0) return \"\";\n    i++;\n    while(i < word.size() && vowels.find(word[i]) == string::npos)\n        i++;\n    return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp5blco_o9.d(28): Error: found `:` when expecting `)`\n/tmp/tmp5blco_o9.d(28): Error: found `:` instead of statement\n/tmp/tmp5blco_o9.d(32): Error: found `:` when expecting `)`\n/tmp/tmp5blco_o9.d(32): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5blco_o9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length()-1;\n    while(i>=0 && word[i]!='a' && word[i]!='e' && word[i]!='i' && word[i]!='o' && word[i]!='u')\n        i--;\n    if(i==-1)\n        return \"\";\n    i--;\n    while(i>=0 && word[i]!='c' && word[i]!='g' && word[i]!='l' && word[i]!='m' && word[i]!='n' && word[i]!='r' && word[i]!='s' && word[i]!='t' && word[i]!='w' && word[i]!='y')\n        i--;\n    return word[i+1];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpi_wl0ahp.d(25): Error: no property `length` for type `string`\n/tmp/tmpi_wl0ahp.d(33): Error: cannot implicitly convert expression `word[cast(ulong)(i + 1)]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi_wl0ahp.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    \n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    \n    while (i < word.length()) {\n        if (vowels.find(word[i]) != string::npos) {\n            i++;\n            continue;\n        }\n        \n        if (consonants.find(word[i]) != string::npos) {\n            j = i + 1;\n            while (j < word.length() && consonants.find(word[j]) != string::npos) {\n                j++;\n            }\n            \n            if (j - i > 1) {\n                k = j - 1;\n                while (k > i && vowels.find(word[k]) == string::npos) {\n                    k--;\n                }\n                \n                if (k - i > 1) {\n                    l = k - 1;\n                    while (l > i && vowels.find(word[l]) == string::npos) {\n                        l--;\n                    }\n                    \n                    if (l - i > 1) {\n                        m = l - 1;\n                        while (m > i && vowels.find(word[m]) == string::npos) {\n                            m--;\n                        }\n                        \n                        if (m - i > 1) {\n                            n = m - 1;\n                            while (n > i && vowels.find(word[n]) == string::npos) {\n                                n--;\n                            }\n                            \n                            if (n - i > 1)\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp98_2tsfe.d(48): Error: found `:` when expecting `)`\n/tmp/tmp98_2tsfe.d(48): Error: found `:` instead of statement\n/tmp/tmp98_2tsfe.d(53): Error: found `:` when expecting `)`\n/tmp/tmp98_2tsfe.d(53): Error: found `:` instead of statement\n/tmp/tmp98_2tsfe.d(55): Error: found `:` when expecting `)`\n/tmp/tmp98_2tsfe.d(55): Error: found `:` instead of statement\n/tmp/tmp98_2tsfe.d(59): Error: declaration expected, not `if`\n/tmp/tmp98_2tsfe.d(61): Error: declaration expected, not `while`\n/tmp/tmp98_2tsfe.d(63): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp98_2tsfe.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    while(i < word.length()-1)\n    {\n        if(vowels.find(word[i]) != string::npos)\n        {\n            i++;\n        }\n        else\n        {\n            break;\n        }\n    }\n    if(i == word.length()-1)\n    {\n        return \"\";\n    }\n    else\n    {\n        return word[i];\n    }\n}\n\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp98oc0e0h.d(29): Error: found `:` when expecting `)`\n/tmp/tmp98oc0e0h.d(29): Error: found `:` instead of statement\n/tmp/tmp98oc0e0h.d(33): Error: found `else` without a corresponding `if`, `version` or `debug` statement\n/tmp/tmp98oc0e0h.d(37): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp98oc0e0h.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length()-1;\n    while(i>=0 && !is_vowel(word[i]))\n        i--;\n    if(i<0)\n        return \"\";\n    int j = i;\n    while(j>=0 && !is_vowel(word[j]))\n        j--;\n    if(j<0)\n        return \"\";\n    return word[j+1];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpilq6ey46.d(25): Error: no property `length` for type `string`\n/tmp/tmpilq6ey46.d(26): Error: undefined identifier `is_vowel`\n/tmp/tmpilq6ey46.d(31): Error: undefined identifier `is_vowel`\n/tmp/tmpilq6ey46.d(35): Error: cannot implicitly convert expression `word[cast(ulong)(j + 1)]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpilq6ey46.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.size() < 2)\n        return \"\";\n    int i = word.size()-1;\n    while(i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if(i < 0)\n        return \"\";\n    if(i == 0)\n        return \"\";\n    if(i == 1)\n        return word[i];\n    if(word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\n        return word[i];\n    return word[i-1];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpe1yjmm60.d(25): Error: no property `size` for type `string`\n/tmp/tmpe1yjmm60.d(27): Error: no property `size` for type `string`\n/tmp/tmpe1yjmm60.d(35): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\n/tmp/tmpe1yjmm60.d(37): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\n/tmp/tmpe1yjmm60.d(38): Error: cannot implicitly convert expression `word[cast(ulong)(i - 1)]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe1yjmm60.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if (i < 0)\n        return \"\";\n    else\n        return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp76o1iji6.d(25): Error: no property `length` for type `string`\n/tmp/tmp76o1iji6.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp76o1iji6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.size() < 2)\n        return \"\";\n    int i = word.size() - 1;\n    while(i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' && word[i] != 'E' && word[i] != 'I' && word[i] != 'O' && word[i] != 'U')\n        i--;\n    if(i == -1)\n        return \"\";\n    if(i == 0)\n        return \"\";\n    if(i == word.size() - 1)\n        return \"\";\n    if(word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' || word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U')\n        return word[i];\n    return word[i + 1];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp3oo5xphy.d(25): Error: no property `size` for type `string`\n/tmp/tmp3oo5xphy.d(27): Error: no property `size` for type `string`\n/tmp/tmp3oo5xphy.d(34): Error: no property `size` for type `string`\n/tmp/tmp3oo5xphy.d(37): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\n/tmp/tmp3oo5xphy.d(38): Error: cannot implicitly convert expression `word[cast(ulong)(i + 1)]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3oo5xphy.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.length() < 2)\n        return \"\";\n    \n    int i = word.length() - 1;\n    while(i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    \n    if(i < 0)\n        return \"\";\n    \n    i--;\n    while(i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    \n    if(i < 0)\n        return \"\";\n    \n    return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpxqxw0yfd.d(25): Error: no property `length` for type `string`\n/tmp/tmpxqxw0yfd.d(28): Error: no property `length` for type `string`\n/tmp/tmpxqxw0yfd.d(42): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxqxw0yfd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if (word.size() < 2) return \"\";\n    string vowels = \"aeiouAEIOU\";\n    int i = word.size() - 1;\n    while (i >= 0) {\n        if (vowels.find(word[i]) != string::npos) {\n            return word[i];\n        }\n        i--;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp2tr3ecz1.d(29): Error: found `:` when expecting `)`\n/tmp/tmp2tr3ecz1.d(29): Error: found `:` instead of statement\n/tmp/tmp2tr3ecz1.d(34): Error: declaration expected, not `return`\n/tmp/tmp2tr3ecz1.d(35): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2tr3ecz1.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0) {\n        if (is_vowel(word[i]))\n            return word[i];\n        i--;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmps4hbejbf.d(25): Error: no property `length` for type `string`\n/tmp/tmps4hbejbf.d(27): Error: undefined identifier `is_vowel`\n/tmp/tmps4hbejbf.d(28): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps4hbejbf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if (i < 0)\n        return \"\";\n    else\n        return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp76o1iji6.d(25): Error: no property `length` for type `string`\n/tmp/tmp76o1iji6.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp76o1iji6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    while (i < word.length() && vowels.find(word[i]) == string::npos)\n        i++;\n    if (i == word.length())\n        return \"\";\n    int j = word.length() - 1;\n    while (j >= 0 && vowels.find(word[j]) == string::npos)\n        j--;\n    return word[i++];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpisg5r4k3.d(27): Error: found `:` when expecting `)`\n/tmp/tmpisg5r4k3.d(27): Error: found `:` instead of statement\n/tmp/tmpisg5r4k3.d(32): Error: found `:` when expecting `)`\n/tmp/tmpisg5r4k3.d(32): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpisg5r4k3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length()-1;\n    while(i>=0 && !is_vowel(word[i]))\n        i--;\n    if(i<0)\n        return \"\";\n    int j = i;\n    while(j>=0 && !is_vowel(word[j]))\n        j--;\n    if(j<0)\n        return \"\";\n    return word[j+1];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpilq6ey46.d(25): Error: no property `length` for type `string`\n/tmp/tmpilq6ey46.d(26): Error: undefined identifier `is_vowel`\n/tmp/tmpilq6ey46.d(31): Error: undefined identifier `is_vowel`\n/tmp/tmpilq6ey46.d(35): Error: cannot implicitly convert expression `word[cast(ulong)(j + 1)]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpilq6ey46.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = word.length() - 1;\n    while (i >= 0 && !vowels.find(word[i]) != string::npos)\n        i--;\n    if (i < 0)\n        return \"\";\n    else\n        return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpklzwxich.d(27): Error: found `:` when expecting `)`\n/tmp/tmpklzwxich.d(27): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpklzwxich.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    int j = word.length() - 1;\n    while (i < j) {\n        if (vowels.find(word[i]) != string::npos && vowels.find(word[j]) != string::npos) {\n            return word[i];\n        }\n        i++;\n        j--;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp_tx0iybe.d(29): Error: found `:` when expecting `)`\n/tmp/tmp_tx0iybe.d(29): Error: found `:` instead of statement\n/tmp/tmp_tx0iybe.d(35): Error: declaration expected, not `return`\n/tmp/tmp_tx0iybe.d(36): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_tx0iybe.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if (i < 0)\n        return \"\";\n    else\n        return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp76o1iji6.d(25): Error: no property `length` for type `string`\n/tmp/tmp76o1iji6.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp76o1iji6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length()-1;\n    while(i>=0 && word[i]!='a' && word[i]!='e' && word[i]!='i' && word[i]!='o' && word[i]!='u')\n        i--;\n    if(i==-1)\n        return \"\";\n    else\n        return word[i];\n}\n\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp64i661f_.d(25): Error: no property `length` for type `string`\n/tmp/tmp64i661f_.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp64i661f_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.length() < 2)\n        return \"\";\n    int i = word.length() - 1;\n    while(i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if(i < 0)\n        return \"\";\n    int j = i + 1;\n    while(j < word.length() && word[j] != 'a' && word[j] != 'e' && word[j] != 'i' && word[j] != 'o' && word[j] != 'u')\n        j++;\n    if(j == word.length())\n        return \"\";\n    return word[i] + word[j];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpt1tr983y.d(25): Error: no property `length` for type `string`\n/tmp/tmpt1tr983y.d(27): Error: no property `length` for type `string`\n/tmp/tmpt1tr983y.d(33): Error: no property `length` for type `string`\n/tmp/tmpt1tr983y.d(35): Error: no property `length` for type `string`\n/tmp/tmpt1tr983y.d(37): Error: cannot implicitly convert expression `cast(int)word[cast(ulong)i] + cast(int)word[cast(ulong)j]` of type `int` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt1tr983y.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if (i < 0)\n        return \"\";\n    if (word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\n        return word[i];\n    return word[i + 1];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmprqy0zbf4.d(25): Error: no property `length` for type `string`\n/tmp/tmprqy0zbf4.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\n/tmp/tmprqy0zbf4.d(32): Error: cannot implicitly convert expression `word[cast(ulong)(i + 1)]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprqy0zbf4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length()-1;\n    while(i>=0 && word[i]!='a' && word[i]!='e' && word[i]!='i' && word[i]!='o' && word[i]!='u' && word[i]!='A' && word[i]!='E' && word[i]!='I' && word[i]!='O' && word[i]!='U')\n        i--;\n    if(i==-1)\n        return \"\";\n    else\n        return word[i];\n}\n\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpdzyevcup.d(25): Error: no property `length` for type `string`\n/tmp/tmpdzyevcup.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdzyevcup.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0) {\n        if (is_vowel(word[i]))\n            return word[i];\n        i--;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmps4hbejbf.d(25): Error: no property `length` for type `string`\n/tmp/tmps4hbejbf.d(27): Error: undefined identifier `is_vowel`\n/tmp/tmps4hbejbf.d(28): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps4hbejbf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if (word.length() < 2) return \"\";\n    int i = word.length() - 1;\n    while (i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if (i < 0) return \"\";\n    i++;\n    while (i < word.length() && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i++;\n    if (i == word.length()) return \"\";\n    return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp6zq905y1.d(25): Error: no property `length` for type `string`\n/tmp/tmp6zq905y1.d(26): Error: no property `length` for type `string`\n/tmp/tmp6zq905y1.d(31): Error: no property `length` for type `string`\n/tmp/tmp6zq905y1.d(33): Error: no property `length` for type `string`\n/tmp/tmp6zq905y1.d(34): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6zq905y1.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0) {\n        if (is_vowel(word[i])) {\n            return word[i];\n        }\n        i--;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp_n05rf0u.d(25): Error: no property `length` for type `string`\n/tmp/tmp_n05rf0u.d(27): Error: undefined identifier `is_vowel`\n/tmp/tmp_n05rf0u.d(28): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_n05rf0u.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int aa = 0;\n    int bb = 0;\n    int cc = 0;\n    int dd = 0;\n    int ee = 0;\n    int ff = 0;\n    int gg = 0;\n    int hh = 0;\n    int ii = 0;\n    int jj = 0;\n    int kk = 0;\n    int ll = 0;\n    int mm = 0;\n    int nn = 0;\n    int oo = 0;\n    int pp = 0;\n    int qq = 0;\n    int rr = 0;\n    int ss = 0;\n    int tt = 0;\n    int uu = 0;\n    int vv = 0;\n    int ww = 0;\n    int xx = 0;\n    int yy =\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpurm9nps2.d(95): Error: expression expected, not `unittest`\n/tmp/tmpurm9nps2.d(96): Error: semicolon expected, not `{`\n/tmp/tmpurm9nps2.d(113): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpurm9nps2.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while(i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if(i < 0)\n        return \"\";\n    i--;\n    while(i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if(i < 0)\n        return \"\";\n    return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp2wr5xrsh.d(25): Error: no property `length` for type `string`\n/tmp/tmp2wr5xrsh.d(35): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2wr5xrsh.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if (i < 0)\n        return \"\";\n    else\n        return word[i];\n}\n\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpobfb5h6m.d(25): Error: no property `length` for type `string`\n/tmp/tmpobfb5h6m.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpobfb5h6m.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.size() < 2)\n        return \"\";\n    string vowels = \"aeiouAEIOU\";\n    int i = word.size()-1;\n    while(i >= 0 && vowels.find(word[i]) == string::npos)\n        i--;\n    if(i < 0)\n        return \"\";\n    i++;\n    while(i < word.size() && vowels.find(word[i]) == string::npos)\n        i++;\n    if(i == word.size())\n        return \"\";\n    return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpq94sqg1e.d(29): Error: found `:` when expecting `)`\n/tmp/tmpq94sqg1e.d(29): Error: found `:` instead of statement\n/tmp/tmpq94sqg1e.d(34): Error: found `:` when expecting `)`\n/tmp/tmpq94sqg1e.d(34): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq94sqg1e.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.length() < 2) return \"\";\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    while(i < word.length() - 1)\n    {\n        if(vowels.find(word[i]) != string::npos)\n        {\n            if(vowels.find(word[i+1]) != string::npos)\n            {\n                return word[i];\n            }\n        }\n        i++;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpuquak5gs.d(30): Error: found `:` when expecting `)`\n/tmp/tmpuquak5gs.d(30): Error: found `:` instead of statement\n/tmp/tmpuquak5gs.d(37): Error: no identifier for declarator `i`\n/tmp/tmpuquak5gs.d(37): Error: declaration expected, not `++`\n/tmp/tmpuquak5gs.d(38): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuquak5gs.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    int j = 0;\n    int len = word.length();\n    string res = \"\";\n    while (i < len)\n    {\n        if (word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\n        {\n            j = i + 1;\n            while (j < len && vowels.find(word[j]) != string::npos)\n            {\n                j++;\n            }\n            if (j - i > 1)\n            {\n                res = word[i + 1];\n                break;\n            }\n        }\n        i++;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpzc_yb3pa.d(35): Error: found `:` when expecting `)`\n/tmp/tmpzc_yb3pa.d(35): Error: found `:` instead of statement\n/tmp/tmpzc_yb3pa.d(47): Error: declaration expected, not `return`\n/tmp/tmpzc_yb3pa.d(48): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzc_yb3pa.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    while (i < word.size() && j < word.size() && k < word.size()) {\n        if (vowels.find(word[i]) != string::npos) {\n            if (j == 0 || vowels.find(word[j]) != string::npos) {\n                if (k == 0 || vowels.find(word[k]) != string::npos) {\n                    return word[i];\n                }\n            }\n        }\n        i++;\n        j++;\n        k++;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpvmgyqxgz.d(30): Error: found `:` when expecting `)`\n/tmp/tmpvmgyqxgz.d(30): Error: found `:` instead of statement\n/tmp/tmpvmgyqxgz.d(36): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvmgyqxgz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.size() < 2)\n        return \"\";\n    int i = word.size() - 1;\n    while(i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if(i < 0)\n        return \"\";\n    i--;\n    while(i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if(i < 0)\n        return \"\";\n    return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmplimbw1ys.d(25): Error: no property `size` for type `string`\n/tmp/tmplimbw1ys.d(27): Error: no property `size` for type `string`\n/tmp/tmplimbw1ys.d(37): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplimbw1ys.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    while (i < word.length() - 1)\n    {\n        if (vowels.find(word[i]) != string::npos && vowels.find(word[i + 1]) != string::npos)\n            return word[i];\n        i++;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpt3mfbs88.d(29): Error: found `:` when expecting `)`\n/tmp/tmpt3mfbs88.d(29): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt3mfbs88.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.length() < 2)\n        return \"\";\n    string vowels = \"aeiouAEIOU\";\n    int i = word.length() - 1;\n    while(i >= 0 && vowels.find(word[i]) == string::npos)\n        i--;\n    if(i < 0)\n        return \"\";\n    int j = i + 1;\n    while(j < word.length() && vowels.find(word[j]) == string::npos)\n        j++;\n    return word[i] + word[j];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp34mgyhw3.d(29): Error: found `:` when expecting `)`\n/tmp/tmp34mgyhw3.d(29): Error: found `:` instead of statement\n/tmp/tmp34mgyhw3.d(34): Error: found `:` when expecting `)`\n/tmp/tmp34mgyhw3.d(34): Error: found `:` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp34mgyhw3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.length() < 2) return \"\";\n    int i = word.length() - 1;\n    while(i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if(i < 0) return \"\";\n    if(i == 0) return \"\";\n    if(i == 1) return word[i];\n    if(word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\n        return word[i];\n    return word[i-1];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpraswcsgf.d(25): Error: no property `length` for type `string`\n/tmp/tmpraswcsgf.d(26): Error: no property `length` for type `string`\n/tmp/tmpraswcsgf.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\n/tmp/tmpraswcsgf.d(33): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\n/tmp/tmpraswcsgf.d(34): Error: cannot implicitly convert expression `word[cast(ulong)(i - 1)]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpraswcsgf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0) {\n        if (is_vowel(word[i])) {\n            return word[i];\n        }\n        i--;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp_n05rf0u.d(25): Error: no property `length` for type `string`\n/tmp/tmp_n05rf0u.d(27): Error: undefined identifier `is_vowel`\n/tmp/tmp_n05rf0u.d(28): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_n05rf0u.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.size() < 2) return \"\";\n    int i = word.size() - 1;\n    while(i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' && word[i] != 'E' && word[i] != 'I' && word[i] != 'O' && word[i] != 'U')\n        i--;\n    if(i < 0) return \"\";\n    i--;\n    while(i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' && word[i] != 'E' && word[i] != 'I' && word[i] != 'O' && word[i] != 'U')\n        i--;\n    if(i < 0) return \"\";\n    return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp3a06htru.d(25): Error: no property `size` for type `string`\n/tmp/tmp3a06htru.d(26): Error: no property `size` for type `string`\n/tmp/tmp3a06htru.d(34): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3a06htru.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length()-1;\n    while(i>=0 && word[i]!='a' && word[i]!='e' && word[i]!='i' && word[i]!='o' && word[i]!='u')\n        i--;\n    if(i<0)\n        return \"\";\n    else\n        return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmp8y4p4m3e.d(25): Error: no property `length` for type `string`\n/tmp/tmp8y4p4m3e.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8y4p4m3e.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    while(i < word.length()-1)\n    {\n        if(vowels.find(word[i]) != string::npos)\n        {\n            if(vowels.find(word[i+1]) != string::npos)\n            {\n                return word[i+1];\n            }\n        }\n        i++;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpqzz1vle5.d(29): Error: found `:` when expecting `)`\n/tmp/tmpqzz1vle5.d(29): Error: found `:` instead of statement\n/tmp/tmpqzz1vle5.d(36): Error: no identifier for declarator `i`\n/tmp/tmpqzz1vle5.d(36): Error: declaration expected, not `++`\n/tmp/tmpqzz1vle5.d(37): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqzz1vle5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.length() < 2) return \"\";\n    int i = word.length() - 1;\n    while(i >= 0 && !is_vowel(word[i])) i--;\n    if(i < 0) return \"\";\n    int j = i + 1;\n    while(j < word.length() && !is_vowel(word[j])) j++;\n    return word.substr(i + 1, j - i - 1);\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmprmtp10st.d(25): Error: no property `length` for type `string`\n/tmp/tmprmtp10st.d(26): Error: no property `length` for type `string`\n/tmp/tmprmtp10st.d(27): Error: undefined identifier `is_vowel`\n/tmp/tmprmtp10st.d(30): Error: no property `length` for type `string`\n/tmp/tmprmtp10st.d(30): Error: undefined identifier `is_vowel`\n/tmp/tmprmtp10st.d(31): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprmtp10st.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.length() < 2) return \"\";\n    int i = word.length()-1;\n    while(i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if(i < 0) return \"\";\n    i--;\n    while(i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if(i < 0) return \"\";\n    return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp94jpz06y.d(25): Error: no property `length` for type `string`\n/tmp/tmp94jpz06y.d(26): Error: no property `length` for type `string`\n/tmp/tmp94jpz06y.d(34): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp94jpz06y.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    while (i < word.length() && j < word.length() && k < word.length())\n    {\n        if (vowels.find(word[i]) != string::npos)\n        {\n            if (j == 0 || k == 0)\n            {\n                j = i;\n                k = i;\n            }\n            else if (i - j < k - i)\n            {\n                k = i;\n            }\n            else if (i - j > k - i)\n            {\n                j = i;\n            }\n        }\n        i++;\n    }\n    if (i == word.length() && j == word.length() && k == word.length())\n    {\n        return \"\";\n    }\n    else\n    {\n        return word[k];\n    }\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpte3sh51a.d(31): Error: found `:` when expecting `)`\n/tmp/tmpte3sh51a.d(31): Error: found `:` instead of statement\n/tmp/tmpte3sh51a.d(38): Error: found `else` without a corresponding `if`, `version` or `debug` statement\n/tmp/tmpte3sh51a.d(42): Error: declaration expected, not `else`\n/tmp/tmpte3sh51a.d(45): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpte3sh51a.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpnrmao08j.d(98): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnrmao08j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < word.size())\n    {\n        if (word[i] == ' ')\n        {\n            i++;\n            continue;\n        }\n        if (vowels.find(word[i]) != string::npos)\n        {\n            count++;\n            if (count == 1)\n            {\n                j = i;\n            }\n        }\n        else\n        {\n            if (count == 1)\n            {\n                return word.substr(j, i - j);\n            }\n            count = 0;\n        }\n        i++;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp5aaki_qm.d(36): Error: found `:` when expecting `)`\n/tmp/tmp5aaki_qm.d(36): Error: found `:` instead of statement\n/tmp/tmp5aaki_qm.d(44): Error: found `else` without a corresponding `if`, `version` or `debug` statement\n/tmp/tmp5aaki_qm.d(50): Error: no identifier for declarator `count`\n/tmp/tmp5aaki_qm.d(50): Error: declaration expected, not `=`\n/tmp/tmp5aaki_qm.d(51): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5aaki_qm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if (i >= 0)\n        return word[i];\n    return \"\";\n}\n\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpw17aabm9.d(25): Error: no property `length` for type `string`\n/tmp/tmpw17aabm9.d(29): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw17aabm9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if (word.length() < 2)\n        return \"\";\n    \n    int i = word.length() - 1;\n    while (i >= 0 && !is_vowel(word[i]))\n        --i;\n    \n    if (i < 0)\n        return \"\";\n    \n    int j = i + 1;\n    while (j < word.length() && !is_vowel(word[j]))\n        ++j;\n    \n    return word.substr(i + 1, j - i - 1);\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpip35yhp3.d(25): Error: no property `length` for type `string`\n/tmp/tmpip35yhp3.d(28): Error: no property `length` for type `string`\n/tmp/tmpip35yhp3.d(29): Error: undefined identifier `is_vowel`\n/tmp/tmpip35yhp3.d(36): Error: no property `length` for type `string`\n/tmp/tmpip35yhp3.d(36): Error: undefined identifier `is_vowel`\n/tmp/tmpip35yhp3.d(39): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpip35yhp3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < word.length() && j < word.length()) {\n        if (vowels.find(word[i]) != string::npos) {\n            count++;\n            if (count == 1) {\n                i++;\n            }\n        }\n        else if (count > 0) {\n            count--;\n            j++;\n        }\n        else {\n            i++;\n        }\n    }\n    if (count == 0) {\n        return \"\";\n    }\n    else {\n        return vowels[count];\n    }\n}\n\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpoh0h0647.d(30): Error: found `:` when expecting `)`\n/tmp/tmpoh0h0647.d(30): Error: found `:` instead of statement\n/tmp/tmpoh0h0647.d(36): Error: found `else` without a corresponding `if`, `version` or `debug` statement\n/tmp/tmpoh0h0647.d(40): Error: declaration expected, not `else`\n/tmp/tmpoh0h0647.d(42): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoh0h0647.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while(i >= 0 && !is_vowel(word[i]))\n        i--;\n    if(i < 0)\n        return \"\";\n    int j = i + 1;\n    while(j < word.length() && !is_vowel(word[j]))\n        j++;\n    return word[i] + word[j];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmptd6u6jnz.d(25): Error: no property `length` for type `string`\n/tmp/tmptd6u6jnz.d(26): Error: undefined identifier `is_vowel`\n/tmp/tmptd6u6jnz.d(31): Error: no property `length` for type `string`\n/tmp/tmptd6u6jnz.d(31): Error: undefined identifier `is_vowel`\n/tmp/tmptd6u6jnz.d(33): Error: cannot implicitly convert expression `cast(int)word[cast(ulong)i] + cast(int)word[cast(ulong)j]` of type `int` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptd6u6jnz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if (i >= 0)\n        return word[i];\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpficqk9vs.d(25): Error: no property `length` for type `string`\n/tmp/tmpficqk9vs.d(29): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpficqk9vs.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if (i < 0)\n        return \"\";\n    i--;\n    while (i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if (i < 0)\n        return \"\";\n    return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpy1xznsj2.d(25): Error: no property `length` for type `string`\n/tmp/tmpy1xznsj2.d(35): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy1xznsj2.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\n        i--;\n    if (i < 0)\n        return \"\";\n    if (word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\n        return word[i];\n    else\n        return word[i + 1];\n}\n\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmps3lyvnm4.d(25): Error: no property `length` for type `string`\n/tmp/tmps3lyvnm4.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\n/tmp/tmps3lyvnm4.d(33): Error: cannot implicitly convert expression `word[cast(ulong)(i + 1)]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps3lyvnm4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int aa = 0;\n    int bb = 0;\n    int cc = 0;\n    int dd = 0;\n    int ee = 0;\n    int ff = 0;\n    int gg = 0;\n    int hh = 0;\n    int ii = 0;\n    int jj = 0;\n    int kk = 0;\n    int ll = 0;\n    int mm = 0;\n    int nn = 0;\n    int oo = 0;\n    int pp = 0;\n    int qq = 0;\n    int rr = 0;\n    int ss = 0;\n    int tt = 0;\n    int uu = 0;\n    int vv = 0;\n    int ww = 0;\n    int xx = 0;\n    int yy =\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "/tmp/tmpurm9nps2.d(95): Error: expression expected, not `unittest`\n/tmp/tmpurm9nps2.d(96): Error: semicolon expected, not `{`\n/tmp/tmpurm9nps2.d(113): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpurm9nps2.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' && word[i] != 'E' && word[i] != 'I' && word[i] != 'O' && word[i] != 'U')\n        i--;\n    if (i < 0)\n        return \"\";\n    else\n        return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmph41b9c1k.d(25): Error: no property `length` for type `string`\n/tmp/tmph41b9c1k.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph41b9c1k.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.empty()) return \"\";\n    int i = word.length()-1;\n    while(i>=0 && !is_vowel(word[i])) i--;\n    if(i<0) return \"\";\n    int j = i;\n    while(j>=0 && !is_vowel(word[j])) j--;\n    if(j<0) return \"\";\n    return word[j+1];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp3w7gs2vi.d(25): Error: no property `empty` for type `string`\n/tmp/tmp3w7gs2vi.d(26): Error: no property `length` for type `string`\n/tmp/tmp3w7gs2vi.d(27): Error: undefined identifier `is_vowel`\n/tmp/tmp3w7gs2vi.d(30): Error: undefined identifier `is_vowel`\n/tmp/tmp3w7gs2vi.d(32): Error: cannot implicitly convert expression `word[cast(ulong)(j + 1)]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3w7gs2vi.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    while (i < word.length() && j < word.length()) {\n        if (vowels.find(word[i]) != string::npos) {\n            j = i;\n            k = i;\n            while (j < word.length() && vowels.find(word[j]) != string::npos) {\n                j++;\n            }\n            while (k < word.length() && vowels.find(word[k]) != string::npos) {\n                k++;\n            }\n            if (j - i > 1) {\n                return word.substr(i, j - i);\n            }\n            else {\n                return \"\";\n            }\n        }\n        i++;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp63lap01l.d(30): Error: found `:` when expecting `)`\n/tmp/tmp63lap01l.d(30): Error: found `:` instead of statement\n/tmp/tmp63lap01l.d(33): Error: found `:` when expecting `)`\n/tmp/tmp63lap01l.d(33): Error: found `:` instead of statement\n/tmp/tmp63lap01l.d(36): Error: found `:` when expecting `)`\n/tmp/tmp63lap01l.d(36): Error: found `:` instead of statement\n/tmp/tmp63lap01l.d(39): Error: declaration expected, not `if`\n/tmp/tmp63lap01l.d(41): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp63lap01l.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    int i = word.length() - 1;\n    while (i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'y')\n        i--;\n    if (i < 0)\n        return \"\";\n    else\n        return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpfvt9ltlq.d(25): Error: no property `length` for type `string`\n/tmp/tmpfvt9ltlq.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfvt9ltlq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.length() < 2)\n        return \"\";\n    int i = word.length() - 1;\n    while(i >= 0 && !is_vowel(word[i]))\n        i--;\n    if(i < 0)\n        return \"\";\n    int j = i + 1;\n    while(j < word.length() && !is_vowel(word[j]))\n        j++;\n    return word[j];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmptab4tddd.d(25): Error: no property `length` for type `string`\n/tmp/tmptab4tddd.d(27): Error: no property `length` for type `string`\n/tmp/tmptab4tddd.d(28): Error: undefined identifier `is_vowel`\n/tmp/tmptab4tddd.d(33): Error: no property `length` for type `string`\n/tmp/tmptab4tddd.d(33): Error: undefined identifier `is_vowel`\n/tmp/tmptab4tddd.d(35): Error: cannot implicitly convert expression `word[cast(ulong)j]` of type `immutable(char)` to `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptab4tddd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string word) \n{\n    if(word.length() < 2) return \"\";\n    string vowels = \"aeiouAEIOU\";\n    int i = 0;\n    int j = word.length() - 1;\n    while(i < j)\n    {\n        if(vowels.find(word[i]) != string::npos && vowels.find(word[j]) != string::npos)\n        {\n            return word[i];\n        }\n        else if(vowels.find(word[i]) != string::npos)\n        {\n            i++;\n        }\n        else if(vowels.find(word[j]) != string::npos)\n        {\n            j--;\n        }\n        else\n        {\n            i++;\n            j--;\n        }\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp93ikl36u.d(31): Error: found `:` when expecting `)`\n/tmp/tmp93ikl36u.d(31): Error: found `:` instead of statement\n/tmp/tmp93ikl36u.d(35): Error: found `else` without a corresponding `if`, `version` or `debug` statement\n/tmp/tmp93ikl36u.d(39): Error: declaration expected, not `else`\n/tmp/tmp93ikl36u.d(42): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp93ikl36u.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}