{
  "name": "HumanEval_132_is_nested",
  "language": "d",
  "prompt": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n",
  "tests": "unittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "results": [
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    if(string.length() == 0)\n        return false;\n    int open = 0;\n    int close = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] == '[')\n            open++;\n        else if(string[i] == ']')\n            close++;\n    }\n    if(open == close)\n        return true;\n    else\n        return false;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmph3hnn9i1.d(25): Error: no property `length` for type `string`\n/tmp/tmph3hnn9i1.d(29): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph3hnn9i1.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n            i++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n            i++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n            i++;\n        }\n        else if(string[i] == '[')\n        {\n            count++;\n            i++;\n        }\n        else\n        {\n            i++;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp6emfrmo9.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6emfrmo9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp52ulqm3x.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp52ulqm3x.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp52ulqm3x.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp52ulqm3x.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    if(string.length()==0)\n        return false;\n    int count=0;\n    for(int i=0;i<string.length();i++)\n    {\n        if(string[i]=='[')\n            count++;\n        else if(string[i]==']')\n        {\n            if(count==0)\n                return false;\n            count--;\n        }\n    }\n    return count==0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpz5vpra6m.d(25): Error: no property `length` for type `string`\n/tmp/tmpz5vpra6m.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz5vpra6m.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n        else if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp5yoqsjus.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5yoqsjus.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n            i++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n            i++;\n        }\n        else\n        {\n            i++;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpjuz4uzyo.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjuz4uzyo.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp5obhk7vp.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5obhk7vp.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp5obhk7vp.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5obhk7vp.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe7xeebe3.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe7xeebe3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        if(string[i] == ']')\n        {\n            count--;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpp3l99xtg.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp3l99xtg.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n            i++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n            i++;\n        }\n        else\n        {\n            i++;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n        if(count == 0)\n        {\n            j = i;\n        }\n    }\n    if(count == 0)\n    {\n        return true;\n    }\n    return false;\n}\n\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp_a59v7ko.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_a59v7ko.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp52ulqm3x.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp52ulqm3x.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] == '[')\n            count++;\n        else if(string[i] == ']')\n        {\n            if(count == 0)\n                return false;\n            count--;\n        }\n    }\n    return count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp9ywdm4n3.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9ywdm4n3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n            i++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n            i++;\n        }\n        else\n        {\n            i++;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmptmdqepk0.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptmdqepk0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int len = string.length();\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < len)\n    {\n        if(string[i] == '[')\n        {\n            count++;\n            i++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n            i++;\n        }\n        else\n        {\n            i++;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n        if(count == 0)\n        {\n            j = i;\n        }\n    }\n    if(count == 0)\n    {\n        return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpnmjox9qr.d(25): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnmjox9qr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n            i++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n            i++;\n        }\n        else\n        {\n            i++;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmptmdqepk0.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptmdqepk0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    if(string.length() == 0)\n        return false;\n    int i = 0;\n    int j = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            j = i;\n            while(j < string.length())\n            {\n                if(string[j] == '[')\n                {\n                    i = j;\n                    break;\n                }\n                else if(string[j] == ']')\n                {\n                    i = j;\n                    break;\n                }\n                j++;\n            }\n            if(i == j)\n                return false;\n            else\n                i = j;\n        }\n        else if(string[i] == ']')\n        {\n            j = i;\n            while(j < string.length())\n            {\n                if(string[j] == ']')\n                {\n                    i = j;\n                    break;\n                }\n                else if(string[j] == '[')\n                {\n                    i = j;\n                    break;\n                }\n                j++;\n            }\n            if(i == j)\n                return false;\n            else\n                i = j;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp8_0a__c6.d(25): Error: no property `length` for type `string`\n/tmp/tmp8_0a__c6.d(29): Error: no property `length` for type `string`\n/tmp/tmp8_0a__c6.d(34): Error: no property `length` for type `string`\n/tmp/tmp8_0a__c6.d(56): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8_0a__c6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    if(string.length() == 0)\n        return false;\n    \n    int count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] == '[')\n            count++;\n        else if(string[i] == ']')\n        {\n            if(count == 0)\n                return false;\n            count--;\n        }\n    }\n    return count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp_z1zkap3.d(25): Error: no property `length` for type `string`\n/tmp/tmp_z1zkap3.d(29): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_z1zkap3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        i++;\n    }\n    if(count == 0)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpfmv0odgf.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfmv0odgf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpklv9bgh0.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x427ecd]\n??:? void tmpklv9bgh0.__unittest_L27_C1() [0x427a4f]\n??:? void tmpklv9bgh0.__modtest() [0x427c4c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42bbf3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42aa86]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fc19]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4300c8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fba5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa5d]\n??:? runModuleUnitTests [0x42b9c9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x42831c]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        i++;\n    }\n    if(count == 0)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\n\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp3c8qukqb.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3c8qukqb.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp52ulqm3x.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp52ulqm3x.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        i++;\n    }\n    if(count == 0)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpfmv0odgf.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfmv0odgf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    if(string.length() == 0)\n        return false;\n    \n    int open = 0;\n    int close = 0;\n    \n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] == '[')\n            open++;\n        else if(string[i] == ']')\n            close++;\n    }\n    \n    if(open == close)\n        return true;\n    else\n        return false;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpidryiuea.d(25): Error: no property `length` for type `string`\n/tmp/tmpidryiuea.d(31): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpidryiuea.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int len = string.length();\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < len)\n    {\n        if(string[i] == '[')\n        {\n            count++;\n            i++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n            i++;\n        }\n        else\n        {\n            i++;\n        }\n        if(count < 0)\n            return false;\n        if(count == 0)\n        {\n            j = i;\n            while(j < len)\n            {\n                if(string[j] == '[')\n                {\n                    count++;\n                    j++;\n                }\n                else if(string[j] == ']')\n                {\n                    count--;\n                    j++;\n                }\n                else\n                {\n                    j++;\n                }\n                if(count < 0)\n                    return false;\n                if(count == 0)\n                    break;\n            }\n            if(count < 0)\n                return false;\n            if(j == len)\n                return true;\n            i = j;\n        }\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp8h6ada3k.d(25): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8h6ada3k.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n            i++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n            i++;\n        }\n        else\n        {\n            i++;\n        }\n        if(count < 0)\n            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp_e9iyflz.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_e9iyflz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp52ulqm3x.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp52ulqm3x.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        i++;\n    }\n    if(count == 0)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpfmv0odgf.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfmv0odgf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp52ulqm3x.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp52ulqm3x.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmplf95gg7z.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplf95gg7z.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n            i++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n            i++;\n        }\n        else\n        {\n            i++;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmptmdqepk0.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptmdqepk0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp5obhk7vp.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5obhk7vp.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    if(string.length() == 0)\n        return false;\n    int count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] == '[')\n            count++;\n        else if(string[i] == ']')\n        {\n            if(count == 0)\n                return false;\n            count--;\n        }\n    }\n    return count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp9qrwno20.d(25): Error: no property `length` for type `string`\n/tmp/tmp9qrwno20.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9qrwno20.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        i++;\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp6cn_dkjy.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6cn_dkjy.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp52ulqm3x.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp52ulqm3x.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n            i++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n            i++;\n        }\n        else if(count == 0)\n        {\n            j = i;\n            while(j < string.length() && string[j] != ']')\n            {\n                j++;\n            }\n            if(j < string.length() && string[j] == ']')\n            {\n                i = j + 1;\n            }\n            else\n            {\n                return false;\n            }\n        }\n        else\n        {\n            i++;\n        }\n    }\n    return count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpek634_ix.d(28): Error: no property `length` for type `string`\n/tmp/tmpek634_ix.d(43): Error: no property `length` for type `string`\n/tmp/tmpek634_ix.d(47): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpek634_ix.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp52ulqm3x.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp52ulqm3x.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n            i++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n            i++;\n        }\n        else if(count == 0)\n        {\n            j = i;\n            while(j < string.length() && string[j] != ']')\n            {\n                j++;\n            }\n            if(j == string.length())\n            {\n                return false;\n            }\n            else\n            {\n                i = j;\n            }\n        }\n        else\n        {\n            i++;\n        }\n    }\n    return count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp3erodswp.d(28): Error: no property `length` for type `string`\n/tmp/tmp3erodswp.d(43): Error: no property `length` for type `string`\n/tmp/tmp3erodswp.d(47): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3erodswp.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp5obhk7vp.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5obhk7vp.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp52ulqm3x.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp52ulqm3x.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        i++;\n    }\n    if(count == 0)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpfmv0odgf.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfmv0odgf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    if (string.length() == 0)\n        return false;\n    \n    int open_brackets = 0;\n    int close_brackets = 0;\n    \n    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[')\n            open_brackets++;\n        else if (string[i] == ']')\n            close_brackets++;\n    }\n    \n    if (open_brackets == close_brackets)\n        return true;\n    else\n        return false;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp_gicrjht.d(25): Error: no property `length` for type `string`\n/tmp/tmp_gicrjht.d(31): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_gicrjht.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int len = string.length();\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < len)\n    {\n        if(string[i] == '[')\n        {\n            count++;\n            i++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n            i++;\n        }\n        else\n        {\n            i++;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n        if(count == 0)\n        {\n            j = i;\n        }\n    }\n    if(count == 0)\n    {\n        return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpnmjox9qr.d(25): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnmjox9qr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    if(string.length() == 0)\n        return false;\n    \n    int open = 0;\n    int close = 0;\n    \n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] == '[')\n            open++;\n        else if(string[i] == ']')\n            close++;\n    }\n    \n    if(open == close)\n        return true;\n    else\n        return false;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpidryiuea.d(25): Error: no property `length` for type `string`\n/tmp/tmpidryiuea.d(31): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpidryiuea.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n            i++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n            i++;\n        }\n        else\n        {\n            i++;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmptmdqepk0.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptmdqepk0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] == '[')\n            count++;\n        else if(string[i] == ']')\n        {\n            if(count == 0)\n                return false;\n            count--;\n        }\n    }\n    return count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp9ywdm4n3.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9ywdm4n3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n            i++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n            i++;\n        }\n        else\n        {\n            i++;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmptmdqepk0.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptmdqepk0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        i++;\n    }\n    if(count == 0)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpfmv0odgf.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfmv0odgf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp5obhk7vp.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5obhk7vp.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length())\n    {\n        if (string[i] == '[')\n        {\n            count++;\n        }\n        else if (string[i] == ']')\n        {\n            count--;\n        }\n        i++;\n    }\n    if (count == 0)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp4u4a_d45.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4u4a_d45.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    if (string.length() == 0)\n        return false;\n    \n    int i = 0;\n    int j = 0;\n    int count = 0;\n    \n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n            i++;\n        }\n        else if (string[i] == ']') {\n            count--;\n            i++;\n        }\n        else {\n            i++;\n        }\n        \n        if (count < 0)\n            return false;\n        \n        if (count == 0) {\n            j = i;\n            while (j < string.length() && string[j] != ']')\n                j++;\n            \n            if (j == string.length())\n                return false;\n            \n            if (string[j] == ']')\n                j++;\n            \n            if (j == string.length())\n                return false;\n            \n            if (string[j] == '[')\n                return true;\n        }\n    }\n    \n    return false;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp_ma2g434.d(25): Error: no property `length` for type `string`\n/tmp/tmp_ma2g434.d(32): Error: no property `length` for type `string`\n/tmp/tmp_ma2g434.d(50): Error: no property `length` for type `string`\n/tmp/tmp_ma2g434.d(53): Error: no property `length` for type `string`\n/tmp/tmp_ma2g434.d(59): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_ma2g434.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n            i++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n            i++;\n        }\n        else\n        {\n            i++;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpjuz4uzyo.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjuz4uzyo.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    return true;\n}\n\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpfiolufty.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x427ecd]\n??:? void tmpfiolufty.__unittest_L28_C1() [0x427a4f]\n??:? void tmpfiolufty.__modtest() [0x427c4c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42bbf3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42aa86]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fc19]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4300c8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fba5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa5d]\n??:? runModuleUnitTests [0x42b9c9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x42831c]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        i++;\n    }\n    if(count == 0)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\n\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp3c8qukqb.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3c8qukqb.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    if(string.length()==0)\n        return false;\n    int i=0;\n    int j=0;\n    int count=0;\n    while(i<string.length())\n    {\n        if(string[i]=='[')\n        {\n            count++;\n            i++;\n        }\n        else if(string[i]==']')\n        {\n            count--;\n            i++;\n        }\n        else if(string[i]=='[')\n        {\n            count++;\n            i++;\n        }\n        else if(string[i]==']')\n        {\n            count--;\n            i++;\n        }\n        else\n        {\n            i++;\n        }\n        if(count==0)\n        {\n            j=i;\n            while(j<string.length()&&string[j]!=']')\n            {\n                if(string[j]=='[')\n                    count++;\n                else if(string[j]==']')\n                    count--;\n                j++;\n            }\n            if(count==0)\n                return true;\n        }\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpwakyiuhx.d(25): Error: no property `length` for type `string`\n/tmp/tmpwakyiuhx.d(30): Error: no property `length` for type `string`\n/tmp/tmpwakyiuhx.d(59): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwakyiuhx.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n            count++;\n        } else if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpymh690eo.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpymh690eo.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length())\n    {\n        if (string[i] == '[')\n        {\n            count++;\n        }\n        else if (string[i] == ']')\n        {\n            count--;\n        }\n        i++;\n        if (count < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpa694vryn.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa694vryn.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmplf95gg7z.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplf95gg7z.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n            i++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n            i++;\n        }\n        else\n        {\n            i++;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n        if(count == 0)\n        {\n            j = i;\n        }\n    }\n    if(count == 0)\n    {\n        return true;\n    }\n    return false;\n}\n\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp_a59v7ko.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_a59v7ko.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp52ulqm3x.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp52ulqm3x.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp52ulqm3x.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp52ulqm3x.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for(int i = 0; i < string.length(); i++) {\n        if(string[i] == '[') {\n            count++;\n        }\n        else if(string[i] == ']') {\n            count--;\n        }\n        if(count < 0) {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpgumlx2ti.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgumlx2ti.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] == '[')\n            count++;\n        else if(string[i] == ']')\n        {\n            if(count == 0)\n                return false;\n            count--;\n        }\n    }\n    return count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp9ywdm4n3.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9ywdm4n3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    if (string.length() == 0)\n        return false;\n    if (string.length() == 1)\n        return true;\n    if (string[0] == '[')\n        return is_nested(string.substr(1)) && is_nested(string.substr(0, string.length() - 1));\n    return false;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpswpglu2y.d(25): Error: no property `length` for type `string`\n/tmp/tmpswpglu2y.d(27): Error: no property `length` for type `string`\n/tmp/tmpswpglu2y.d(30): Error: no property `substr` for type `string`\n/tmp/tmpswpglu2y.d(30): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpswpglu2y.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpeazllfgx.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeazllfgx.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpio4hynw4.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpio4hynw4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        i++;\n    }\n    if(count == 0)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpfmv0odgf.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfmv0odgf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp5obhk7vp.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5obhk7vp.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp52ulqm3x.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp52ulqm3x.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        if(string[i] == ']')\n        {\n            count--;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpp3l99xtg.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp3l99xtg.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp52ulqm3x.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp52ulqm3x.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp5obhk7vp.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5obhk7vp.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n            i++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n            i++;\n        }\n        else\n        {\n            i++;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmptmdqepk0.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptmdqepk0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp52ulqm3x.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp52ulqm3x.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        i++;\n    }\n    if(count == 0)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpfmv0odgf.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfmv0odgf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n            i++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n            i++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n            i++;\n        }\n        else if(string[i] == '[')\n        {\n            count++;\n            i++;\n        }\n        else\n        {\n            i++;\n        }\n    }\n    if(count == 0)\n        return true;\n    else\n        return false;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpmlhqzblh.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmlhqzblh.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n            i++;\n        } else if (string[i] == ']') {\n            count--;\n            i++;\n        } else {\n            i++;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmptylesogy.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptylesogy.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp52ulqm3x.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp52ulqm3x.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp5obhk7vp.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5obhk7vp.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int len = string.length();\n    int count = 0;\n    for(int i = 0; i < len; i++)\n    {\n        if(string[i] == '[')\n            count++;\n        else if(string[i] == ']')\n        {\n            if(count == 0)\n                return false;\n            count--;\n        }\n    }\n    return count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmppo4ll9y2.d(25): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppo4ll9y2.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        i++;\n    }\n    if(count == 0)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\n\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp3c8qukqb.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3c8qukqb.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmphlas5ntq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphlas5ntq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length())\n    {\n        if (string[i] == '[')\n        {\n            count++;\n        }\n        else if (string[i] == ']')\n        {\n            count--;\n        }\n        i++;\n    }\n    if (count == 0)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp4u4a_d45.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4u4a_d45.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] == '[')\n            count++;\n        else if(string[i] == ']')\n        {\n            if(count == 0)\n                return false;\n            count--;\n        }\n    }\n    return count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp9ywdm4n3.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9ywdm4n3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        i++;\n    }\n    if(count == 0)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\n\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp3c8qukqb.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3c8qukqb.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp52ulqm3x.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp52ulqm3x.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int len = string.length();\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < len)\n    {\n        if(string[i] == '[')\n        {\n            count++;\n            i++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n            i++;\n        }\n        else\n        {\n            i++;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n        if(count == 0)\n        {\n            j = i;\n        }\n    }\n    if(count == 0)\n    {\n        return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpnmjox9qr.d(25): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnmjox9qr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count == -1) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmphod0ko01.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphod0ko01.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        i++;\n    }\n    if(count == 0)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpfmv0odgf.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfmv0odgf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe7xeebe3.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe7xeebe3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n            i++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n            i++;\n        }\n        else\n        {\n            i++;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmptmdqepk0.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptmdqepk0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp5obhk7vp.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5obhk7vp.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] == '[')\n            count++;\n        else if(string[i] == ']')\n        {\n            if(count == 0)\n                return false;\n            count--;\n        }\n    }\n    return count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp9ywdm4n3.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9ywdm4n3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    if(string.length() == 0)\n        return false;\n    int count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] == '[')\n            count++;\n        else if(string[i] == ']')\n        {\n            if(count == 0)\n                return false;\n            count--;\n        }\n    }\n    return count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp9qrwno20.d(25): Error: no property `length` for type `string`\n/tmp/tmp9qrwno20.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9qrwno20.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp52ulqm3x.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp52ulqm3x.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n            i++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n            i++;\n        }\n        else\n        {\n            i++;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmptmdqepk0.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptmdqepk0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp52ulqm3x.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp52ulqm3x.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        if(string[i] == ']')\n        {\n            count--;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpp3l99xtg.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp3l99xtg.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int len = string.length();\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < len)\n    {\n        if(string[i] == '[')\n        {\n            count++;\n            i++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n            i++;\n        }\n        else\n        {\n            i++;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpoj4vlyhm.d(25): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoj4vlyhm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmphlas5ntq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphlas5ntq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n            i++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n            i++;\n        }\n        else\n        {\n            i++;\n        }\n        if(count < 0)\n            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp_e9iyflz.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_e9iyflz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        i++;\n    }\n    if(count == 0)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpfmv0odgf.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfmv0odgf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int len = string.length();\n    if (len < 2)\n        return false;\n    int count = 0;\n    for (int i = 0; i < len; i++)\n    {\n        if (string[i] == '[')\n            count++;\n        else if (string[i] == ']')\n        {\n            if (count == 0)\n                return false;\n            count--;\n        }\n    }\n    return count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpnef7hi6a.d(25): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnef7hi6a.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp5obhk7vp.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5obhk7vp.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n            i++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n            i++;\n        }\n        else\n        {\n            i++;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmptmdqepk0.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptmdqepk0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp5obhk7vp.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5obhk7vp.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int len = string.length();\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < len) {\n        if (string[i] == '[') {\n            count++;\n            i++;\n        }\n        else if (string[i] == ']') {\n            count--;\n            i++;\n        }\n        else {\n            i++;\n        }\n        if (count < 0) {\n            return false;\n        }\n        if (count == 0) {\n            j = i;\n        }\n    }\n    return j != i;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpdniy0tay.d(25): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdniy0tay.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpeazllfgx.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeazllfgx.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp52ulqm3x.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp52ulqm3x.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        i++;\n        if(count == 0)\n        {\n            j = i;\n            while(j < string.length())\n            {\n                if(string[j] == '[')\n                {\n                    count++;\n                }\n                else if(string[j] == ']')\n                {\n                    count--;\n                }\n                j++;\n                if(count == 0)\n                {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpipihwout.d(28): Error: no property `length` for type `string`\n/tmp/tmpipihwout.d(42): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpipihwout.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n            i++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n            i++;\n        }\n        else\n        {\n            i++;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmptmdqepk0.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptmdqepk0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        i++;\n    }\n    if(count < 0)\n    {\n        return false;\n    }\n    i = 0;\n    j = 0;\n    count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        i++;\n        if(count == 0)\n        {\n            j = i;\n            break;\n        }\n    }\n    if(count == 0)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpz69_g36v.d(28): Error: no property `length` for type `string`\n/tmp/tmpz69_g36v.d(47): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz69_g36v.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n            i++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n            i++;\n        }\n        else\n        {\n            i++;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmptmdqepk0.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptmdqepk0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] == '[')\n            count++;\n        else if(string[i] == ']')\n        {\n            if(count == 0)\n                return false;\n            count--;\n        }\n    }\n    return count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp9ywdm4n3.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9ywdm4n3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    if (string.length() == 0) return false;\n    int open = 0;\n    int close = 0;\n    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[') open++;\n        if (string[i] == ']') close++;\n    }\n    if (open == close) return true;\n    return false;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpk7mcq_uf.d(25): Error: no property `length` for type `string`\n/tmp/tmpk7mcq_uf.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk7mcq_uf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        i++;\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp6cn_dkjy.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6cn_dkjy.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n        else if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp5497wo4k.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5497wo4k.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] == '[')\n            count++;\n        else if(string[i] == ']')\n        {\n            if(count == 0)\n                return false;\n            count--;\n        }\n    }\n    return count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp9ywdm4n3.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9ywdm4n3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        i++;\n    }\n    if(count == 0)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpfmv0odgf.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfmv0odgf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp5obhk7vp.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5obhk7vp.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        i++;\n    }\n    if(count == 0)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpfmv0odgf.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfmv0odgf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n            i++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n            i++;\n        }\n        else\n        {\n            i++;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n        if(count == 0)\n        {\n            j = i;\n        }\n    }\n    if(count == 0)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp_e7ltcq6.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_e7ltcq6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    if(string.length() == 0)\n        return false;\n    int open = 0;\n    int close = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] == '[')\n            open++;\n        if(string[i] == ']')\n            close++;\n    }\n    if(open == close)\n        return true;\n    else\n        return false;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpbvtpvhal.d(25): Error: no property `length` for type `string`\n/tmp/tmpbvtpvhal.d(29): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbvtpvhal.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length())\n    {\n        if (string[i] == '[')\n        {\n            count++;\n        }\n        else if (string[i] == ']')\n        {\n            count--;\n        }\n        if (count < 0)\n        {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmph806ohhy.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph806ohhy.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length())\n    {\n        if (string[i] == '[')\n        {\n            count++;\n        }\n        else if (string[i] == ']')\n        {\n            count--;\n        }\n        if (count < 0)\n        {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpatqd0jf_.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpatqd0jf_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp5obhk7vp.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5obhk7vp.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpeazllfgx.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeazllfgx.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp52ulqm3x.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp52ulqm3x.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length())\n    {\n        if (string[i] == '[')\n        {\n            count++;\n        }\n        else if (string[i] == ']')\n        {\n            count--;\n        }\n        i++;\n    }\n    if (count == 0)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp4u4a_d45.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4u4a_d45.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    if (string.length() == 0) return false;\n    int count = 0;\n    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmprvuk_sav.d(25): Error: no property `length` for type `string`\n/tmp/tmprvuk_sav.d(27): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprvuk_sav.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpwt0n331n.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwt0n331n.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int len = string.length();\n    int i = 0;\n    int j = 0;\n    while(i < len)\n    {\n        if(string[i] == '[')\n        {\n            j = i;\n            while(j < len && string[j] != ']')\n            {\n                j++;\n            }\n            if(j < len && string[j] == ']')\n            {\n                i = j + 1;\n            }\n        }\n        else\n        {\n            i++;\n        }\n    }\n    return i == len;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpzdtwixsb.d(25): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzdtwixsb.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    if (string.length() == 0)\n        return false;\n    int count = 0;\n    for (int i = 0; i < string.length(); i++)\n    {\n        if (string[i] == '[')\n            count++;\n        else if (string[i] == ']')\n        {\n            if (count == 0)\n                return false;\n            count--;\n        }\n    }\n    return count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpfgejlc81.d(25): Error: no property `length` for type `string`\n/tmp/tmpfgejlc81.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfgejlc81.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        if(string[i] == ']')\n        {\n            count--;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpb_thhsrb.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb_thhsrb.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        i++;\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp7j2vlmix.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7j2vlmix.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int len = string.length();\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < len)\n    {\n        if(string[i] == '[')\n        {\n            count++;\n            i++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n            i++;\n        }\n        else\n        {\n            i++;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n        if(count == 0)\n        {\n            j = i;\n        }\n    }\n    return j != 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp5fgo0ldy.d(25): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5fgo0ldy.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n        else if (string[i] == ']') {\n            count--;\n        }\n    }\n    return count > 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp91lljh6y.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp91lljh6y.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpwt0n331n.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwt0n331n.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n            j = i;\n        }\n        if (string[i] == ']') {\n            count--;\n            if (count < 0) {\n                return false;\n            }\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp0yckh1g8.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0yckh1g8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n            i++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n            i++;\n        }\n        else\n        {\n            i++;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n        if(count == 0)\n        {\n            j = i;\n        }\n    }\n    if(count == 0)\n    {\n        return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp7l2te5si.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7l2te5si.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n            i++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n            i++;\n        }\n        else\n        {\n            i++;\n        }\n        if(count < 0)\n            return false;\n        if(count > 0)\n        {\n            j = i;\n            while(j < string.length() && string[j] != ']')\n            {\n                if(string[j] == '[')\n                    count++;\n                else if(string[j] == ']')\n                    count--;\n                j++;\n            }\n            if(count < 0)\n                return false;\n            i = j;\n        }\n    }\n    return count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp8eg5j0s3.d(28): Error: no property `length` for type `string`\n/tmp/tmp8eg5j0s3.d(49): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8eg5j0s3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] == '[')\n            count++;\n        else if(string[i] == ']')\n        {\n            if(count == 0)\n                return false;\n            count--;\n        }\n    }\n    return count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp9ywdm4n3.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9ywdm4n3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int len = string.length();\n    int i = 0;\n    int j = 0;\n    while(i < len)\n    {\n        if(string[i] == '[')\n        {\n            j = i;\n            while(j < len)\n            {\n                if(string[j] == '[' && j != i)\n                {\n                    return false;\n                }\n                if(string[j] == ']' && j != i)\n                {\n                    return false;\n                }\n                j++;\n            }\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmps630_83h.d(25): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps630_83h.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        i++;\n    }\n    if(count == 0)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpfmv0odgf.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfmv0odgf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    if(string.length() == 0)\n        return false;\n    int count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] == '[')\n            count++;\n        else if(string[i] == ']')\n        {\n            if(count == 0)\n                return false;\n            count--;\n        }\n    }\n    return count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp9qrwno20.d(25): Error: no property `length` for type `string`\n/tmp/tmp9qrwno20.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9qrwno20.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int len = string.length();\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < len)\n    {\n        if(string[i] == '[')\n        {\n            count++;\n            i++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n            i++;\n        }\n        else\n        {\n            i++;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpoj4vlyhm.d(25): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoj4vlyhm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int len = string.length();\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < len)\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        i++;\n    }\n    if(count > 0)\n    {\n        return false;\n    }\n    else\n    {\n        i = 0;\n        while(i < len)\n        {\n            if(string[i] == '[')\n            {\n                j = i;\n                while(j < len)\n                {\n                    if(string[j] == ']')\n                    {\n                        if(j - i > 1)\n                        {\n                            return true;\n                        }\n                        else\n                        {\n                            return false;\n                        }\n                    }\n                    j++;\n                }\n            }\n            i++;\n        }\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpazx1y1i8.d(25): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpazx1y1i8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpe_5fjhyq.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_5fjhyq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    if (string.length() == 0)\n        return false;\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n            count++;\n        }\n        if (string[i] == ']') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp6srky80o.d(25): Error: no property `length` for type `string`\n/tmp/tmp6srky80o.d(30): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6srky80o.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int len = string.length();\n    int i = 0;\n    int j = 0;\n    while(i < len)\n    {\n        if(string[i] == '[')\n        {\n            j = i;\n            while(j < len && string[j] != ']')\n            {\n                j++;\n            }\n            if(j < len && string[j] == ']')\n            {\n                i = j + 1;\n            }\n            else\n            {\n                return false;\n            }\n        }\n        else\n        {\n            i++;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp2qcdy9zz.d(25): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2qcdy9zz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        i++;\n    }\n    if(count == 0)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpfmv0odgf.d(28): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfmv0odgf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        else if(string[i] == ']')\n        {\n            count--;\n        }\n        if(count < 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp52ulqm3x.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp52ulqm3x.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < string.length())\n    {\n        if(string[i] == '[')\n        {\n            count++;\n        }\n        if(string[i] == ']')\n        {\n            count--;\n        }\n        if(count == 0)\n        {\n            j = i;\n            while(j < string.length() && string[j] != ']')\n            {\n                j++;\n            }\n            if(j == string.length())\n            {\n                return true;\n            }\n        }\n        i++;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpxvxf_y6k.d(28): Error: no property `length` for type `string`\n/tmp/tmpxvxf_y6k.d(41): Error: no property `length` for type `string`\n/tmp/tmpxvxf_y6k.d(45): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxvxf_y6k.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"[[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"[][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string string) \n{\n    int count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] == '[')\n            count++;\n        else if(string[i] == ']')\n        {\n            if(count == 0)\n                return false;\n            count--;\n        }\n    }\n    return count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp9ywdm4n3.d(26): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9ywdm4n3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}