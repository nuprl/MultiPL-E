{
  "name": "HumanEval_109_move_one_ball",
  "language": "d",
  "prompt": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n",
  "tests": "unittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "results": [
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        else\n            i++;\n    }\n    \n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpa2rlk8m4.d(41): Range violation\n----------------\n??:? _d_arrayboundsp [0x4283e6]\n??:? bool tmpa2rlk8m4.move_one_ball(long[]) [0x427d5d]\n??:? void tmpa2rlk8m4.__unittest_L54_C1() [0x427f57]\n??:? void tmpa2rlk8m4.__modtest() [0x4280b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_ep6vgsn.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x428335]\n??:? void tmp_ep6vgsn.__unittest_L51_C1() [0x428018]\n??:? void tmp_ep6vgsn.__modtest() [0x4280b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    int N = arr.length;\n    if(N == 0) return true;\n    \n    int i = 0;\n    while(i < N)\n    {\n        int j = i+1;\n        while(j < N)\n        {\n            if(arr[i] > arr[j])\n            {\n                arr[i] = arr[i] + arr[j];\n                arr[j] = arr[i] - arr[j];\n                arr[i] = arr[i] - arr[j];\n            }\n            j++;\n        }\n        i++;\n    }\n    \n    for(i = 0; i < N; i++)\n    {\n        if(arr[i] != i) return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "/tmp/tmpcwcvxtgr.d(35): Error: cannot implicitly convert expression `arr.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcwcvxtgr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        else\n        {\n            i++;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp3evxbfnf.d(59): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmp3evxbfnf.__unittest_L53_C1() [0x427fcc]\n??:? void tmp3evxbfnf.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpskp2rj12.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmpskp2rj12.__unittest_L51_C1() [0x427fcc]\n??:? void tmpskp2rj12.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    \n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp4ofki_cu.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmp4ofki_cu.__unittest_L52_C1() [0x427fcc]\n??:? void tmp4ofki_cu.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    int j = arr.length - 1;\n    \n    while(i < j)\n    {\n        if(arr[i] > arr[j])\n        {\n            arr[i] = arr[i] - arr[j];\n            arr[j] = arr[i] + arr[j];\n            arr[i] = arr[i] - arr[j];\n        }\n        else if(arr[i] < arr[j])\n        {\n            arr[i] = arr[i] + arr[j];\n            arr[j] = arr[i] - arr[j];\n            arr[i] = arr[i] + arr[j];\n        }\n        else\n        {\n            i++;\n            j--;\n        }\n    }\n    \n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "/tmp/tmpflc00ecf.d(39): Error: cannot implicitly convert expression `arr.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpflc00ecf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length - 1)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_ufkp42v.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x428335]\n??:? void tmp_ufkp42v.__unittest_L52_C1() [0x428018]\n??:? void tmp_ufkp42v.__modtest() [0x4280b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i+1];\n            arr[i+1]=arr[i];\n            i=0;\n        }\n        else\n            i++;\n    }\n    return arr[0]<arr[1];\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp7nv5bhnk.d(55): unittest failure\n----------------\n??:? _d_unittestp [0x42829d]\n??:? void tmp7nv5bhnk.__unittest_L51_C1() [0x427eda]\n??:? void tmp7nv5bhnk.__modtest() [0x428020]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b18e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430321]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b165]\n??:? runModuleUnitTests [0x42c0d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428760]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length - 1)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_ufkp42v.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x428335]\n??:? void tmp_ufkp42v.__unittest_L52_C1() [0x428018]\n??:? void tmp_ufkp42v.__modtest() [0x4280b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        else\n            i++;\n    }\n    \n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpa2rlk8m4.d(41): Range violation\n----------------\n??:? _d_arrayboundsp [0x4283e6]\n??:? bool tmpa2rlk8m4.move_one_ball(long[]) [0x427d5d]\n??:? void tmpa2rlk8m4.__unittest_L54_C1() [0x427f57]\n??:? void tmpa2rlk8m4.__modtest() [0x4280b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    int N = arr.length;\n    if(N == 0)\n        return true;\n    \n    int i = 0;\n    while(i < N)\n    {\n        int j = i;\n        while(j < N && arr[j] < arr[j+1])\n            j++;\n        if(j == i)\n            i++;\n        else\n        {\n            long temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i = j;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "/tmp/tmpb8941_a6.d(35): Error: cannot implicitly convert expression `arr.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb8941_a6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i+1];\n            arr[i+1]=arr[i];\n            i=0;\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqprketwe.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpqprketwe.__unittest_L51_C1() [0x427f40]\n??:? void tmpqprketwe.__modtest() [0x427fdc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    \n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp75aexb1y.d(41): Range violation\n----------------\n??:? _d_arrayboundsp [0x4283de]\n??:? bool tmp75aexb1y.move_one_ball(long[]) [0x427d5d]\n??:? void tmp75aexb1y.__unittest_L53_C1() [0x427f4f]\n??:? void tmp75aexb1y.__modtest() [0x4280ac]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c38b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b21e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430860]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43033d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1f5]\n??:? runModuleUnitTests [0x42c161]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length - 1)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpru6f_4j9.d(59): unittest failure\n----------------\n??:? _d_unittestp [0x428335]\n??:? void tmpru6f_4j9.__unittest_L53_C1() [0x42801c]\n??:? void tmpru6f_4j9.__modtest() [0x4280b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length)\n    {\n        int j = i;\n        while(j < arr.length && arr[j] >= arr[j+1])\n            j++;\n        if(j == i)\n            i++;\n        else\n        {\n            long temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i = j;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpzwrogs1_.d(42): Range violation\n----------------\n??:? _d_arrayboundsp [0x428306]\n??:? bool tmpzwrogs1_.move_one_ball(long[]) [0x427d69]\n??:? void tmpzwrogs1_.__unittest_L56_C1() [0x427e77]\n??:? void tmpzwrogs1_.__modtest() [0x427fd4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2b3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b146]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302d9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430788]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430265]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b11d]\n??:? runModuleUnitTests [0x42c089]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length-1)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            long temp = arr[i];\n            arr[i] = arr[i+1];\n            arr[i+1] = temp;\n        }\n        i++;\n    }\n    \n    return i == arr.length-1;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpo5shu7mc.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x42824d]\n??:? void tmpo5shu7mc.__unittest_L52_C1() [0x427f34]\n??:? void tmpo5shu7mc.__modtest() [0x427fd0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b13e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302d1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430780]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43025d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b115]\n??:? runModuleUnitTests [0x42c081]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428710]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    \n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        else\n        {\n            i++;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmphf25e4z2.d(60): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmphf25e4z2.__unittest_L54_C1() [0x427fcc]\n??:? void tmphf25e4z2.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpebduf682.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmpebduf682.__unittest_L50_C1() [0x427fc8]\n??:? void tmpebduf682.__modtest() [0x428064]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpskp2rj12.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmpskp2rj12.__unittest_L51_C1() [0x427fcc]\n??:? void tmpskp2rj12.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i+1];\n            arr[i+1]=arr[i];\n            i=0;\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqprketwe.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpqprketwe.__unittest_L51_C1() [0x427f40]\n??:? void tmpqprketwe.__modtest() [0x427fdc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    int i = 0;\n    while(i < arr.length)\n    {\n        int j = i + 1;\n        while(j < arr.length)\n        {\n            if(arr[i] > arr[j])\n            {\n                arr[i] = arr[i] - arr[j];\n                arr[j] = arr[i] + arr[j];\n                arr[i] = arr[i] - arr[j];\n            }\n            j++;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpvoyk14nm.d(61): unittest failure\n----------------\n??:? _d_unittestp [0x4282f5]\n??:? void tmpvoyk14nm.__unittest_L55_C1() [0x427fd8]\n??:? void tmpvoyk14nm.__modtest() [0x428074]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c353]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1e6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430379]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430828]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430305]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1bd]\n??:? runModuleUnitTests [0x42c129]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287b8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        else\n            i++;\n    }\n    \n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpa2rlk8m4.d(41): Range violation\n----------------\n??:? _d_arrayboundsp [0x4283e6]\n??:? bool tmpa2rlk8m4.move_one_ball(long[]) [0x427d5d]\n??:? void tmpa2rlk8m4.__unittest_L54_C1() [0x427f57]\n??:? void tmpa2rlk8m4.__modtest() [0x4280b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    int j = arr.length - 1;\n    while(i < j)\n    {\n        if(arr[i] > arr[j])\n        {\n            arr[i] = arr[i] - arr[j];\n            arr[j] = arr[i] + arr[j];\n            arr[i] = arr[i] - arr[j];\n        }\n        else if(arr[i] < arr[j])\n        {\n            arr[i] = arr[i] + arr[j];\n            arr[j] = arr[i] - arr[j];\n            arr[i] = arr[i] + arr[j];\n        }\n        else\n        {\n            i++;\n            j--;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "/tmp/tmpqwbj5ka5.d(39): Error: cannot implicitly convert expression `arr.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqwbj5ka5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    int j = arr.length - 1;\n    while(i < j)\n    {\n        if(arr[i] > arr[j])\n        {\n            arr[i] = arr[i] - arr[j];\n            arr[j] = arr[i] + arr[j];\n            arr[i] = arr[i] - arr[j];\n        }\n        else\n        {\n            arr[i] = arr[i] + arr[j];\n            arr[j] = arr[i] - arr[j];\n            arr[i] = arr[i] + arr[j];\n        }\n        i++;\n        j--;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "/tmp/tmpcr6p9g3s.d(39): Error: cannot implicitly convert expression `arr.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcr6p9g3s.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpskp2rj12.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmpskp2rj12.__unittest_L51_C1() [0x427fcc]\n??:? void tmpskp2rj12.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    int N = arr.length;\n    if(N == 0) return true;\n    \n    int i = 0;\n    while(i < N)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "/tmp/tmpbr0xnge4.d(35): Error: cannot implicitly convert expression `arr.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbr0xnge4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpskp2rj12.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmpskp2rj12.__unittest_L51_C1() [0x427fcc]\n??:? void tmpskp2rj12.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp8fbe180x.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x428335]\n??:? void tmp8fbe180x.__unittest_L52_C1() [0x42801c]\n??:? void tmp8fbe180x.__modtest() [0x4280b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    \n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpzj5j2zun.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x428335]\n??:? void tmpzj5j2zun.__unittest_L52_C1() [0x428018]\n??:? void tmpzj5j2zun.__modtest() [0x4280b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i+1];\n            arr[i+1]=arr[i];\n            i=0;\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqprketwe.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpqprketwe.__unittest_L51_C1() [0x427f40]\n??:? void tmpqprketwe.__modtest() [0x427fdc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpskp2rj12.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmpskp2rj12.__unittest_L51_C1() [0x427fcc]\n??:? void tmpskp2rj12.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length)\n    {\n        if(arr[i] > arr[i+1])\n            return false;\n        \n        if(arr[i] < arr[i+1])\n            break;\n        \n        arr[i] = arr[i+1];\n        arr[i+1] = arr[i];\n        i++;\n    }\n    \n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpfvrcd4_z.d(61): unittest failure\n----------------\n??:? _d_unittestp [0x42827d]\n??:? void tmpfvrcd4_z.__unittest_L54_C1() [0x427fb9]\n??:? void tmpfvrcd4_z.__modtest() [0x428000]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2db]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b16e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430301]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307b0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43028d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b145]\n??:? runModuleUnitTests [0x42c0b1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428740]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    int i = 0;\n    while(i < arr.length)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpogsgz7zq.d(40): Range violation\n----------------\n??:? _d_arrayboundsp [0x4283de]\n??:? bool tmpogsgz7zq.move_one_ball(long[]) [0x427d5d]\n??:? void tmpogsgz7zq.__unittest_L51_C1() [0x427f4f]\n??:? void tmpogsgz7zq.__modtest() [0x4280ac]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c38b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b21e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430860]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43033d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1f5]\n??:? runModuleUnitTests [0x42c161]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpskp2rj12.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmpskp2rj12.__unittest_L51_C1() [0x427fcc]\n??:? void tmpskp2rj12.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_ep6vgsn.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x428335]\n??:? void tmp_ep6vgsn.__unittest_L51_C1() [0x428018]\n??:? void tmp_ep6vgsn.__modtest() [0x4280b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    \n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i+1];\n            arr[i+1]=arr[i];\n        }\n        else\n            i++;\n    }\n    return arr[0]<arr[1];\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpb7h0mmg6.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x428295]\n??:? void tmpb7h0mmg6.__unittest_L51_C1() [0x427fd1]\n??:? void tmpb7h0mmg6.__modtest() [0x428018]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2f3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b186]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430319]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307c8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302a5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b15d]\n??:? runModuleUnitTests [0x42c0c9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428758]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    \n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        else\n        {\n            i++;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmphf25e4z2.d(60): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmphf25e4z2.__unittest_L54_C1() [0x427fcc]\n??:? void tmphf25e4z2.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]--;\n            arr[i+1]++;\n        }\n        else\n            i++;\n    }\n    return arr[0]<=arr[1];\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpyv9unds4.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x42823d]\n??:? void tmpyv9unds4.__unittest_L50_C1() [0x427f79]\n??:? void tmpyv9unds4.__modtest() [0x427fc0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c29b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b12e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302c1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430770]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43024d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b105]\n??:? runModuleUnitTests [0x42c071]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428700]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i+1];\n            arr[i+1]=arr[i];\n            i=0;\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqprketwe.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpqprketwe.__unittest_L51_C1() [0x427f40]\n??:? void tmpqprketwe.__modtest() [0x427fdc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpskp2rj12.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmpskp2rj12.__unittest_L51_C1() [0x427fcc]\n??:? void tmpskp2rj12.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i+1];\n            arr[i+1]=arr[i];\n            i++;\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpak0dwo3h.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x428255]\n??:? void tmpak0dwo3h.__unittest_L51_C1() [0x427f3c]\n??:? void tmpak0dwo3h.__modtest() [0x427fd8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2b3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b146]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302d9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430788]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430265]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b11d]\n??:? runModuleUnitTests [0x42c089]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428718]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    int N = arr.length;\n    if(N == 0) return true;\n    \n    int i = 0;\n    while(i < N)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "/tmp/tmpbr0xnge4.d(35): Error: cannot implicitly convert expression `arr.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbr0xnge4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i+1];\n            arr[i+1]=arr[i];\n            i=0;\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqprketwe.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpqprketwe.__unittest_L51_C1() [0x427f40]\n??:? void tmpqprketwe.__modtest() [0x427fdc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i+1];\n            arr[i+1]=arr[i];\n            i=0;\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqprketwe.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpqprketwe.__unittest_L51_C1() [0x427f40]\n??:? void tmpqprketwe.__modtest() [0x427fdc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]^arr[i+1];\n            arr[i+1]=arr[i]^arr[i+1];\n            arr[i]=arr[i]^arr[i+1];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmplb6q00rq.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmplb6q00rq.__unittest_L51_C1() [0x427fcc]\n??:? void tmplb6q00rq.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    int n = arr.length;\n    if(n==0) return true;\n    if(n==1) return true;\n    if(n==2) return true;\n    if(n==3) return true;\n    if(n==4) return true;\n    if(n==5) return true;\n    if(n==6) return true;\n    if(n==7) return true;\n    if(n==8) return true;\n    if(n==9) return true;\n    if(n==10) return true;\n    if(n==11) return true;\n    if(n==12) return true;\n    if(n==13) return true;\n    if(n==14) return true;\n    if(n==15) return true;\n    if(n==16) return true;\n    if(n==17) return true;\n    if(n==18) return true;\n    if(n==19) return true;\n    if(n==20) return true;\n    if(n==21) return true;\n    if(n==22) return true;\n    if(n==23) return true;\n    if(n==24) return true;\n    if(n==25) return true;\n    if(n==26) return true;\n    if(n==27) return true;\n    if(n==28) return true;\n    if(n==29) return true;\n    if(n==30) return true;\n    if(n==31) return true;\n    if(n==32) return true;\n    if(n==33) return true;\n    if(n==34) return true;\n    if(n==35) return true;\n    if(n==36) return true;\n    if(n==37) return true;\n    if(n==38) return true;\n    if(n==39) return true;\n    if(n==40) return true;\n    if(n==41) return true;\n    if(n==42) return true;\n    if(n==43) return true;\n    if(n==44) return true;\n    if(n==45\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "/tmp/tmp3f0kiuwc.d(82): Error: found `unittest` when expecting `)`\n/tmp/tmp3f0kiuwc.d(92): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3f0kiuwc.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpebduf682.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmpebduf682.__unittest_L50_C1() [0x427fc8]\n??:? void tmpebduf682.__modtest() [0x428064]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpskp2rj12.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmpskp2rj12.__unittest_L51_C1() [0x427fcc]\n??:? void tmpskp2rj12.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i+1];\n            arr[i+1]=arr[i];\n            i=0;\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqprketwe.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpqprketwe.__unittest_L51_C1() [0x427f40]\n??:? void tmpqprketwe.__modtest() [0x427fdc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length - 1)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_ufkp42v.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x428335]\n??:? void tmp_ufkp42v.__unittest_L52_C1() [0x428018]\n??:? void tmp_ufkp42v.__modtest() [0x4280b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp8fbe180x.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x428335]\n??:? void tmp8fbe180x.__unittest_L52_C1() [0x42801c]\n??:? void tmp8fbe180x.__modtest() [0x4280b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    int j = arr.length - 1;\n    while(i < j)\n    {\n        if(arr[i] > arr[j])\n        {\n            arr[i] = arr[i] - arr[j];\n            arr[j] = arr[i] + arr[j];\n            arr[i] = arr[i] - arr[j];\n        }\n        else if(arr[i] < arr[j])\n        {\n            arr[i] = arr[i] + arr[j];\n            arr[j] = arr[i] - arr[j];\n            arr[i] = arr[i] + arr[j];\n        }\n        else\n            i++;\n        j--;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "/tmp/tmpe_8rivga.d(39): Error: cannot implicitly convert expression `arr.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_8rivga.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i+1];\n            arr[i+1]=arr[i];\n        }\n        i++;\n    }\n    return arr[0]<arr[1];\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpdzn0gz92.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x428295]\n??:? void tmpdzn0gz92.__unittest_L49_C1() [0x427fcd]\n??:? void tmpdzn0gz92.__modtest() [0x428014]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2f3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b186]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430319]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307c8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302a5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b15d]\n??:? runModuleUnitTests [0x42c0c9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428758]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    int N = arr.length;\n    if(N == 0)\n        return true;\n    \n    int i = 0;\n    while(i < N-1)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "/tmp/tmple6tnrj4.d(35): Error: cannot implicitly convert expression `arr.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmple6tnrj4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]--;\n            arr[i+1]++;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpkyt987wp.d(55): unittest failure\n----------------\n??:? _d_unittestp [0x4281f5]\n??:? void tmpkyt987wp.__unittest_L49_C1() [0x427edc]\n??:? void tmpkyt987wp.__modtest() [0x427f78]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c253]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b0e6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430279]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430728]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430205]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b0bd]\n??:? runModuleUnitTests [0x42c029]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4286b8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    int N = arr.length;\n    if(N==0) return true;\n    int i=0;\n    while(i<N-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "/tmp/tmplzdtp_r4.d(35): Error: cannot implicitly convert expression `arr.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplzdtp_r4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    int j = arr.length - 1;\n    while(i < j)\n    {\n        if(arr[i] > arr[j])\n        {\n            arr[i] = arr[i] - arr[j];\n            arr[j] = arr[i] + arr[j];\n            arr[i] = arr[i] - arr[j];\n        }\n        else\n        {\n            i++;\n        }\n    }\n    \n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "/tmp/tmpprq6x8x4.d(39): Error: cannot implicitly convert expression `arr.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpprq6x8x4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        else if(arr[i]==arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        else\n        {\n            arr[i+1]=arr[i+1]+arr[i];\n            arr[i]=arr[i]-arr[i+1];\n            arr[i+1]=arr[i+1]-arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp0s7yom4i.d(68): unittest failure\n----------------\n??:? _d_unittestp [0x4285c5]\n??:? void tmp0s7yom4i.__unittest_L62_C1() [0x4282ac]\n??:? void tmp0s7yom4i.__modtest() [0x428348]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c623]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b4b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430649]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430af8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b48d]\n??:? runModuleUnitTests [0x42c3f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428a88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp8fbe180x.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x428335]\n??:? void tmp8fbe180x.__unittest_L52_C1() [0x42801c]\n??:? void tmp8fbe180x.__modtest() [0x4280b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    int N = arr.length;\n    if(N==0) return true;\n    int i=0;\n    while(i<N)\n    {\n        int j=i+1;\n        while(j<N)\n        {\n            if(arr[i]>arr[j])\n            {\n                arr[i]=arr[i]+arr[j];\n                arr[j]=arr[i]-arr[j];\n                arr[i]=arr[i]-arr[j];\n            }\n            j++;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "/tmp/tmpa71cmhxj.d(35): Error: cannot implicitly convert expression `arr.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa71cmhxj.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]^arr[i+1];\n            arr[i+1]=arr[i]^arr[i+1];\n            arr[i]=arr[i]^arr[i+1];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmplb6q00rq.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmplb6q00rq.__unittest_L51_C1() [0x427fcc]\n??:? void tmplb6q00rq.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    int j = arr.length - 1;\n    while(i < j)\n    {\n        if(arr[i] > arr[j])\n        {\n            arr[i] = arr[i] - arr[j];\n            arr[j] = arr[i] + arr[j];\n            arr[i] = arr[i] - arr[j];\n        }\n        else\n        {\n            arr[i] = arr[i] + arr[j];\n            arr[j] = arr[i] - arr[j];\n            arr[i] = arr[i] + arr[j];\n        }\n        i++;\n        j--;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "/tmp/tmpcr6p9g3s.d(39): Error: cannot implicitly convert expression `arr.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcr6p9g3s.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i+1];\n            arr[i+1]=arr[i];\n            i++;\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpak0dwo3h.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x428255]\n??:? void tmpak0dwo3h.__unittest_L51_C1() [0x427f3c]\n??:? void tmpak0dwo3h.__modtest() [0x427fd8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2b3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b146]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302d9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430788]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430265]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b11d]\n??:? runModuleUnitTests [0x42c089]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428718]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    int i = 0;\n    while(i < arr.length - 1)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpwx1uccqv.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x428335]\n??:? void tmpwx1uccqv.__unittest_L51_C1() [0x428018]\n??:? void tmpwx1uccqv.__modtest() [0x4280b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpskp2rj12.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmpskp2rj12.__unittest_L51_C1() [0x427fcc]\n??:? void tmpskp2rj12.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpskp2rj12.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmpskp2rj12.__unittest_L51_C1() [0x427fcc]\n??:? void tmpskp2rj12.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp8fbe180x.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x428335]\n??:? void tmp8fbe180x.__unittest_L52_C1() [0x42801c]\n??:? void tmp8fbe180x.__modtest() [0x4280b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i+1];\n            arr[i+1]=arr[i];\n            i++;\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpak0dwo3h.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x428255]\n??:? void tmpak0dwo3h.__unittest_L51_C1() [0x427f3c]\n??:? void tmpak0dwo3h.__modtest() [0x427fd8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2b3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b146]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302d9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430788]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430265]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b11d]\n??:? runModuleUnitTests [0x42c089]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428718]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    \n    return arr[0] == 0;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp8ue26g9b.d(41): Range violation\n----------------\n??:? _d_arrayboundsp [0x428406]\n??:? bool tmp8ue26g9b.move_one_ball(long[]) [0x427d5d]\n??:? void tmp8ue26g9b.__unittest_L53_C1() [0x427f77]\n??:? void tmp8ue26g9b.__modtest() [0x4280d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3b3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b246]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303d9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430888]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430365]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b21d]\n??:? runModuleUnitTests [0x42c189]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i+1];\n            arr[i+1]=arr[i];\n            i=0;\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqprketwe.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpqprketwe.__unittest_L51_C1() [0x427f40]\n??:? void tmpqprketwe.__modtest() [0x427fdc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    \n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpzj5j2zun.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x428335]\n??:? void tmpzj5j2zun.__unittest_L52_C1() [0x428018]\n??:? void tmpzj5j2zun.__modtest() [0x4280b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    \n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i+1];\n            arr[i+1]=arr[i];\n            i=0;\n        }\n        else\n            i++;\n    }\n    \n    if(arr[i]>arr[0])\n        return true;\n    else\n        return false;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpsmv6i708.d(62): unittest failure\n----------------\n??:? _d_unittestp [0x4282ad]\n??:? void tmpsmv6i708.__unittest_L56_C1() [0x427f90]\n??:? void tmpsmv6i708.__modtest() [0x42802c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c30b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b19e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430331]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307e0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302bd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b175]\n??:? runModuleUnitTests [0x42c0e1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428770]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    int N = arr.length;\n    if(N==0) return true;\n    \n    int i=0;\n    while(i<N-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "/tmp/tmpl251v2pa.d(35): Error: cannot implicitly convert expression `arr.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl251v2pa.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpskp2rj12.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmpskp2rj12.__unittest_L51_C1() [0x427fcc]\n??:? void tmpskp2rj12.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i+1];\n            arr[i+1]=arr[i];\n            i=0;\n        }\n        else\n            i++;\n    }\n    return arr[0]<arr[1];\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp7nv5bhnk.d(55): unittest failure\n----------------\n??:? _d_unittestp [0x42829d]\n??:? void tmp7nv5bhnk.__unittest_L51_C1() [0x427eda]\n??:? void tmp7nv5bhnk.__modtest() [0x428020]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b18e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430321]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b165]\n??:? runModuleUnitTests [0x42c0d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428760]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    \n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpm0bvnzki.d(59): unittest failure\n----------------\n??:? _d_unittestp [0x428335]\n??:? void tmpm0bvnzki.__unittest_L53_C1() [0x42801c]\n??:? void tmpm0bvnzki.__modtest() [0x4280b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    int N = arr.length;\n    if(N == 0) return true;\n    int i = 0;\n    while(i < N)\n    {\n        int j = i + 1;\n        while(j < N && arr[j] < arr[i])\n        {\n            arr[j] = arr[j] + arr[j-1];\n            j++;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "/tmp/tmptuhg71yl.d(35): Error: cannot implicitly convert expression `arr.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptuhg71yl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    int i = 0;\n    while(i < arr.length)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpogsgz7zq.d(40): Range violation\n----------------\n??:? _d_arrayboundsp [0x4283de]\n??:? bool tmpogsgz7zq.move_one_ball(long[]) [0x427d5d]\n??:? void tmpogsgz7zq.__unittest_L51_C1() [0x427f4f]\n??:? void tmpogsgz7zq.__modtest() [0x4280ac]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c38b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b21e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430860]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43033d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1f5]\n??:? runModuleUnitTests [0x42c161]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    \n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]--;\n            arr[i+1]++;\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpnup3h4db.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x4281fd]\n??:? void tmpnup3h4db.__unittest_L51_C1() [0x427ee0]\n??:? void tmpnup3h4db.__modtest() [0x427f7c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c25b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b0ee]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430281]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430730]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43020d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b0c5]\n??:? runModuleUnitTests [0x42c031]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4286c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    \n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp4ofki_cu.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmp4ofki_cu.__unittest_L52_C1() [0x427fcc]\n??:? void tmp4ofki_cu.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length)\n    {\n        if(arr[i] > arr[i+1])\n            return false;\n        \n        if(arr[i] < arr[i+1])\n            arr[i] = arr[i+1];\n        \n        arr[i+1] = arr[i];\n        i++;\n    }\n    \n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpnnyw28il.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x428295]\n??:? void tmpnnyw28il.__unittest_L53_C1() [0x427ed2]\n??:? void tmpnnyw28il.__modtest() [0x428018]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2f3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b186]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430319]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307c8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302a5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b15d]\n??:? runModuleUnitTests [0x42c0c9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428758]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        else\n            i++;\n    }\n    \n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpa2rlk8m4.d(41): Range violation\n----------------\n??:? _d_arrayboundsp [0x4283e6]\n??:? bool tmpa2rlk8m4.move_one_ball(long[]) [0x427d5d]\n??:? void tmpa2rlk8m4.__unittest_L54_C1() [0x427f57]\n??:? void tmpa2rlk8m4.__modtest() [0x4280b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length - 1)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_ufkp42v.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x428335]\n??:? void tmp_ufkp42v.__unittest_L52_C1() [0x428018]\n??:? void tmp_ufkp42v.__modtest() [0x4280b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length - 1)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_ufkp42v.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x428335]\n??:? void tmp_ufkp42v.__unittest_L52_C1() [0x428018]\n??:? void tmp_ufkp42v.__modtest() [0x4280b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i+1];\n            arr[i+1]=arr[i];\n            i++;\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpak0dwo3h.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x428255]\n??:? void tmpak0dwo3h.__unittest_L51_C1() [0x427f3c]\n??:? void tmpak0dwo3h.__modtest() [0x427fd8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2b3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b146]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302d9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430788]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430265]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b11d]\n??:? runModuleUnitTests [0x42c089]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428718]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    \n    int i=0;\n    int j=arr.length-1;\n    while(i<j)\n    {\n        if(arr[i]>arr[j])\n        {\n            arr[i] = arr[i] + arr[j];\n            arr[j] = arr[i] - arr[j];\n            arr[i] = arr[i] - arr[j];\n        }\n        else\n        {\n            i++;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "/tmp/tmpq5jvl3_g.d(39): Error: cannot implicitly convert expression `arr.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq5jvl3_g.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length - 1)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpru6f_4j9.d(59): unittest failure\n----------------\n??:? _d_unittestp [0x428335]\n??:? void tmpru6f_4j9.__unittest_L53_C1() [0x42801c]\n??:? void tmpru6f_4j9.__modtest() [0x4280b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length - 1)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_ufkp42v.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x428335]\n??:? void tmp_ufkp42v.__unittest_L52_C1() [0x428018]\n??:? void tmp_ufkp42v.__modtest() [0x4280b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp8fbe180x.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x428335]\n??:? void tmp8fbe180x.__unittest_L52_C1() [0x42801c]\n??:? void tmp8fbe180x.__modtest() [0x4280b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    int j = arr.length - 1;\n    \n    while(i < j)\n    {\n        if(arr[i] > arr[j])\n        {\n            arr[i] = arr[i] - arr[j];\n            arr[j] = arr[i] + arr[j];\n            arr[i] = arr[i] - arr[j];\n        }\n        else if(arr[i] < arr[j])\n        {\n            arr[i] = arr[i] + arr[j];\n            arr[j] = arr[i] - arr[j];\n            arr[i] = arr[i] + arr[j];\n        }\n        else\n        {\n            i++;\n            j--;\n        }\n    }\n    \n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "/tmp/tmpflc00ecf.d(39): Error: cannot implicitly convert expression `arr.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpflc00ecf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpskp2rj12.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmpskp2rj12.__unittest_L51_C1() [0x427fcc]\n??:? void tmpskp2rj12.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    \n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            i=0;\n        }\n        else\n            i++;\n    }\n    return arr[0]<arr[1];\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpemjp2vjr.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x4282dd]\n??:? void tmpemjp2vjr.__unittest_L52_C1() [0x427f1a]\n??:? void tmpemjp2vjr.__modtest() [0x428060]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c33b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ce]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430361]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430810]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302ed]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1a5]\n??:? runModuleUnitTests [0x42c111]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    \n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]^arr[i+1];\n            arr[i+1]=arr[i]^arr[i+1];\n            arr[i]=arr[i]^arr[i+1];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpa6gd934i.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmpa6gd934i.__unittest_L52_C1() [0x427fcc]\n??:? void tmpa6gd934i.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i+1];\n            arr[i+1]=arr[i];\n        }\n        else\n            i++;\n    }\n    return arr[0]<arr[1];\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpkw55vvw2.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x428295]\n??:? void tmpkw55vvw2.__unittest_L50_C1() [0x427fd1]\n??:? void tmpkw55vvw2.__modtest() [0x428018]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2f3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b186]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430319]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307c8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302a5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b15d]\n??:? runModuleUnitTests [0x42c0c9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428758]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpskp2rj12.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmpskp2rj12.__unittest_L51_C1() [0x427fcc]\n??:? void tmpskp2rj12.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    int N = arr.length;\n    if(N==0) return true;\n    \n    int i=0;\n    while(i<N-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "/tmp/tmpl251v2pa.d(35): Error: cannot implicitly convert expression `arr.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl251v2pa.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp8fbe180x.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x428335]\n??:? void tmp8fbe180x.__unittest_L52_C1() [0x42801c]\n??:? void tmp8fbe180x.__modtest() [0x4280b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpskp2rj12.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmpskp2rj12.__unittest_L51_C1() [0x427fcc]\n??:? void tmpskp2rj12.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length-1)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        else\n            i++;\n    }\n    \n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpa_2blqbg.d(60): unittest failure\n----------------\n??:? _d_unittestp [0x428335]\n??:? void tmpa_2blqbg.__unittest_L54_C1() [0x42801c]\n??:? void tmpa_2blqbg.__modtest() [0x4280b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        else\n            i++;\n    }\n    \n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpa2rlk8m4.d(41): Range violation\n----------------\n??:? _d_arrayboundsp [0x4283e6]\n??:? bool tmpa2rlk8m4.move_one_ball(long[]) [0x427d5d]\n??:? void tmpa2rlk8m4.__unittest_L54_C1() [0x427f57]\n??:? void tmpa2rlk8m4.__modtest() [0x4280b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    int N = arr.length;\n    if(N == 0) return true;\n    \n    int i = 0;\n    while(i < N)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        else\n        {\n            i++;\n        }\n    }\n    \n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "/tmp/tmp5bw8pxe3.d(35): Error: cannot implicitly convert expression `arr.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5bw8pxe3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpebduf682.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmpebduf682.__unittest_L50_C1() [0x427fc8]\n??:? void tmpebduf682.__modtest() [0x428064]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i+1];\n            arr[i+1]=arr[i];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_zjq32fx.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x428255]\n??:? void tmp_zjq32fx.__unittest_L50_C1() [0x427f3c]\n??:? void tmp_zjq32fx.__modtest() [0x427fd8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2b3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b146]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302d9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430788]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430265]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b11d]\n??:? runModuleUnitTests [0x42c089]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428718]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpskp2rj12.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmpskp2rj12.__unittest_L51_C1() [0x427fcc]\n??:? void tmpskp2rj12.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i+1];\n            arr[i+1]=arr[i];\n            i=0;\n        }\n        else\n            i++;\n    }\n    return arr[0]<arr[i];\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp65mcp069.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x4282a5]\n??:? void tmp65mcp069.__unittest_L51_C1() [0x427f88]\n??:? void tmp65mcp069.__modtest() [0x428024]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c303]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b196]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430329]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b16d]\n??:? runModuleUnitTests [0x42c0d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428768]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpebduf682.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmpebduf682.__unittest_L50_C1() [0x427fc8]\n??:? void tmpebduf682.__modtest() [0x428064]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length - 1)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpru6f_4j9.d(59): unittest failure\n----------------\n??:? _d_unittestp [0x428335]\n??:? void tmpru6f_4j9.__unittest_L53_C1() [0x42801c]\n??:? void tmpru6f_4j9.__modtest() [0x4280b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length - 1)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return arr[0] <= arr[1];\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmps3tdj142.d(59): unittest failure\n----------------\n??:? _d_unittestp [0x428375]\n??:? void tmps3tdj142.__unittest_L52_C1() [0x4280b1]\n??:? void tmps3tdj142.__modtest() [0x4280f8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3d3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b266]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308a8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b23d]\n??:? runModuleUnitTests [0x42c1a9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428838]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i+1];\n            arr[i+1]=arr[i];\n            i=0;\n        }\n        else\n            i++;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpyia4qnly.d(55): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpyia4qnly.__unittest_L51_C1() [0x427e96]\n??:? void tmpyia4qnly.__modtest() [0x427fdc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    int N = arr.length;\n    if(N == 0) return true;\n    if(N == 1) return false;\n    \n    int i = 0;\n    while(i < N-1)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "/tmp/tmp9gs9o4lr.d(35): Error: cannot implicitly convert expression `arr.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9gs9o4lr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length - 1)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return arr[0] <= arr[1];\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmps3tdj142.d(59): unittest failure\n----------------\n??:? _d_unittestp [0x428375]\n??:? void tmps3tdj142.__unittest_L52_C1() [0x4280b1]\n??:? void tmps3tdj142.__modtest() [0x4280f8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3d3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b266]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308a8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b23d]\n??:? runModuleUnitTests [0x42c1a9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428838]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    int i = 0;\n    while(i < arr.length - 1)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgrpsnabk.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x428335]\n??:? void tmpgrpsnabk.__unittest_L52_C1() [0x42801c]\n??:? void tmpgrpsnabk.__modtest() [0x4280b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpskp2rj12.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmpskp2rj12.__unittest_L51_C1() [0x427fcc]\n??:? void tmpskp2rj12.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpebduf682.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmpebduf682.__unittest_L50_C1() [0x427fc8]\n??:? void tmpebduf682.__modtest() [0x428064]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    int N = arr.length;\n    if(N == 0) return true;\n    int i = 0;\n    while(i < N)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        else\n        {\n            i++;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "/tmp/tmpjkos3otb.d(35): Error: cannot implicitly convert expression `arr.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjkos3otb.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpskp2rj12.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmpskp2rj12.__unittest_L51_C1() [0x427fcc]\n??:? void tmpskp2rj12.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i+1];\n            arr[i+1]=arr[i];\n        }\n        i++;\n    }\n    return arr[0]<arr[1];\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpdzn0gz92.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x428295]\n??:? void tmpdzn0gz92.__unittest_L49_C1() [0x427fcd]\n??:? void tmpdzn0gz92.__modtest() [0x428014]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2f3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b186]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430319]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307c8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302a5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b15d]\n??:? runModuleUnitTests [0x42c0c9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428758]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    int i = 0;\n    while(i < arr.length - 1)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpwx1uccqv.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x428335]\n??:? void tmpwx1uccqv.__unittest_L51_C1() [0x428018]\n??:? void tmpwx1uccqv.__modtest() [0x4280b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length - 1)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_ufkp42v.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x428335]\n??:? void tmp_ufkp42v.__unittest_L52_C1() [0x428018]\n??:? void tmp_ufkp42v.__modtest() [0x4280b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    int j = arr.length - 1;\n    while(i < j)\n    {\n        if(arr[i] > arr[j])\n        {\n            arr[i] = arr[i] - arr[j];\n            arr[j] = arr[i] + arr[j];\n            arr[i] = arr[i] - arr[j];\n        }\n        else\n        {\n            arr[i] = arr[i] + arr[j];\n            arr[j] = arr[i] - arr[j];\n            arr[i] = arr[i] + arr[j];\n        }\n        i++;\n        j--;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "/tmp/tmpcr6p9g3s.d(39): Error: cannot implicitly convert expression `arr.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcr6p9g3s.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i+1];\n            arr[i+1]=arr[i];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_zjq32fx.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x428255]\n??:? void tmp_zjq32fx.__unittest_L50_C1() [0x427f3c]\n??:? void tmp_zjq32fx.__modtest() [0x427fd8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2b3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b146]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302d9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430788]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430265]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b11d]\n??:? runModuleUnitTests [0x42c089]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428718]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    int N = arr.length;\n    if(N == 0) return true;\n    \n    int i = 0;\n    while(i < N)\n    {\n        int j = i+1;\n        while(j < N)\n        {\n            if(arr[i] > arr[j])\n            {\n                arr[i] = arr[i] + arr[j];\n                arr[j] = arr[i] - arr[j];\n                arr[i] = arr[i] - arr[j];\n            }\n            j++;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "/tmp/tmp6w0r6eiv.d(35): Error: cannot implicitly convert expression `arr.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6w0r6eiv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    int i = 0;\n    while(i < arr.length - 1)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpwx1uccqv.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x428335]\n??:? void tmpwx1uccqv.__unittest_L51_C1() [0x428018]\n??:? void tmpwx1uccqv.__modtest() [0x4280b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    int i = 0;\n    while(i < arr.length - 1)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpwx1uccqv.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x428335]\n??:? void tmpwx1uccqv.__unittest_L51_C1() [0x428018]\n??:? void tmpwx1uccqv.__modtest() [0x4280b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i+1];\n            arr[i+1]=arr[i];\n            i=0;\n        }\n        else\n            i++;\n    }\n    return arr[0]<arr[1];\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp7nv5bhnk.d(55): unittest failure\n----------------\n??:? _d_unittestp [0x42829d]\n??:? void tmp7nv5bhnk.__unittest_L51_C1() [0x427eda]\n??:? void tmp7nv5bhnk.__modtest() [0x428020]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b18e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430321]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b165]\n??:? runModuleUnitTests [0x42c0d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428760]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]^arr[i+1];\n            arr[i+1]=arr[i]^arr[i+1];\n            arr[i]=arr[i]^arr[i+1];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmplb6q00rq.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmplb6q00rq.__unittest_L51_C1() [0x427fcc]\n??:? void tmplb6q00rq.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    int N = arr.length;\n    if(N == 0)\n        return true;\n    \n    int i = 0;\n    while(i < N)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    \n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "/tmp/tmp62h5z2zy.d(35): Error: cannot implicitly convert expression `arr.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp62h5z2zy.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpskp2rj12.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmpskp2rj12.__unittest_L51_C1() [0x427fcc]\n??:? void tmpskp2rj12.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    int N = arr.length;\n    if(N == 0) return true;\n    \n    int i = 0;\n    while(i < N)\n    {\n        int j = i + 1;\n        while(j < N && arr[j] >= arr[i])\n        {\n            if(arr[j] == arr[i])\n            {\n                arr[j] = arr[N-1];\n                arr[N-1] = arr[i];\n                arr[i] = arr[N-2];\n                arr[N-2] = arr[j];\n                arr[j] = arr[N-3];\n                arr[N-3] = arr[i];\n                arr[i] = arr[N-4];\n                arr[N-4] = arr[j];\n                arr[j] = arr[N-5];\n                arr[N-5] = arr[i];\n                arr[i] = arr[N-6];\n                arr[N-6] = arr[j];\n                arr[j] = arr[N-7];\n                arr[N-7] = arr[i];\n                arr[i] = arr[N-8];\n                arr[N-8] = arr[j];\n                arr[j] = arr[N-9];\n                arr[N-9] = arr[i];\n                arr[i] = arr[N-10];\n                arr[N-10] = arr[j];\n                arr[j] = arr[N-11];\n                arr[N-11] = arr[i];\n                arr[i] = arr[N-12];\n                arr[N-12] = arr[j];\n                arr[j] = arr[N-13];\n                arr[N-13] = arr[i];\n                arr[i] = arr[N-14];\n                arr[N-14] = arr[j];\n                arr[j] = arr[N-15];\n                arr[N-15] = arr[i];\n                arr[i] = arr[N-16];\n                arr[N-16] = arr[j];\n                arr[j] = arr[N\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "/tmp/tmpkvwwoj74.d(79): Error: found `unittest` when expecting `,`\n/tmp/tmpkvwwoj74.d(89): Error: found `void` when expecting `,`\n/tmp/tmpkvwwoj74.d(89): Error: found `{` when expecting `,`\n/tmp/tmpkvwwoj74.d(89): Error: expression expected, not `}`\n/tmp/tmpkvwwoj74.d(89): Error: found `End of File` when expecting `,`\n/tmp/tmpkvwwoj74.d(89): Error: found `End of File` when expecting `]`\n/tmp/tmpkvwwoj74.d(89): Error: found `End of File` when expecting `;` following statement\n/tmp/tmpkvwwoj74.d(89): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpkvwwoj74.d(89): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpkvwwoj74.d(89): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpkvwwoj74.d(89): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkvwwoj74.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length - 1)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_ufkp42v.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x428335]\n??:? void tmp_ufkp42v.__unittest_L52_C1() [0x428018]\n??:? void tmp_ufkp42v.__modtest() [0x4280b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    \n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i+1];\n            arr[i+1]=arr[i];\n        }\n        else\n            i++;\n    }\n    return arr[0]<arr[1];\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpb7h0mmg6.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x428295]\n??:? void tmpb7h0mmg6.__unittest_L51_C1() [0x427fd1]\n??:? void tmpb7h0mmg6.__modtest() [0x428018]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2f3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b186]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430319]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307c8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302a5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b15d]\n??:? runModuleUnitTests [0x42c0c9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428758]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    \n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp4ofki_cu.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmp4ofki_cu.__unittest_L52_C1() [0x427fcc]\n??:? void tmp4ofki_cu.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    int j = arr.length - 1;\n    while(i < j)\n    {\n        if(arr[i] > arr[j])\n        {\n            arr[i] = arr[i] - arr[j];\n            arr[j] = arr[i] + arr[j];\n            arr[i] = arr[i] - arr[j];\n        }\n        else if(arr[i] < arr[j])\n        {\n            arr[i] = arr[i] + arr[j];\n            arr[j] = arr[i] - arr[j];\n            arr[i] = arr[i] + arr[j];\n        }\n        else\n        {\n            i++;\n            j--;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "/tmp/tmpqwbj5ka5.d(39): Error: cannot implicitly convert expression `arr.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqwbj5ka5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpskp2rj12.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmpskp2rj12.__unittest_L51_C1() [0x427fcc]\n??:? void tmpskp2rj12.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    int j = arr.length - 1;\n    \n    while(i < j)\n    {\n        if(arr[i] > arr[j])\n        {\n            arr[i] = arr[i] - arr[j];\n            arr[j] = arr[i] + arr[j];\n            arr[i] = arr[i] - arr[j];\n        }\n        else\n        {\n            i++;\n        }\n    }\n    \n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "/tmp/tmp59l0v9b4.d(39): Error: cannot implicitly convert expression `arr.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp59l0v9b4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    int N = arr.length;\n    if(N == 0)\n        return true;\n    int i = 0;\n    while(i < N-1)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "/tmp/tmpx_ovtr8f.d(35): Error: cannot implicitly convert expression `arr.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx_ovtr8f.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length - 1)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_ufkp42v.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x428335]\n??:? void tmp_ufkp42v.__unittest_L52_C1() [0x428018]\n??:? void tmp_ufkp42v.__modtest() [0x4280b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpebduf682.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmpebduf682.__unittest_L50_C1() [0x427fc8]\n??:? void tmpebduf682.__modtest() [0x428064]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    int N = arr.length;\n    if(N == 0)\n        return true;\n    int i = 0;\n    while(i < N)\n    {\n        if(arr[i] > arr[i+1])\n            return false;\n        arr[i] = arr[i] + arr[i+1];\n        arr[i+1] = arr[i] - arr[i+1];\n        arr[i] = arr[i] - arr[i+1];\n        i = i + 2;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "/tmp/tmpnkzqjt6o.d(35): Error: cannot implicitly convert expression `arr.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnkzqjt6o.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    \n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp4ofki_cu.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmp4ofki_cu.__unittest_L52_C1() [0x427fcc]\n??:? void tmp4ofki_cu.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    \n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp4ofki_cu.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmp4ofki_cu.__unittest_L52_C1() [0x427fcc]\n??:? void tmp4ofki_cu.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    \n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        else\n        {\n            i++;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmphf25e4z2.d(60): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmphf25e4z2.__unittest_L54_C1() [0x427fcc]\n??:? void tmphf25e4z2.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length - 1)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_ufkp42v.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x428335]\n??:? void tmp_ufkp42v.__unittest_L52_C1() [0x428018]\n??:? void tmp_ufkp42v.__modtest() [0x4280b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpskp2rj12.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmpskp2rj12.__unittest_L51_C1() [0x427fcc]\n??:? void tmpskp2rj12.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    \n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp4ofki_cu.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmp4ofki_cu.__unittest_L52_C1() [0x427fcc]\n??:? void tmp4ofki_cu.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_ep6vgsn.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x428335]\n??:? void tmp_ep6vgsn.__unittest_L51_C1() [0x428018]\n??:? void tmp_ep6vgsn.__modtest() [0x4280b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    int j = arr.length - 1;\n    \n    while(i < j)\n    {\n        if(arr[i] > arr[j])\n        {\n            arr[i] = arr[i] - arr[j];\n            arr[j] = arr[i] + arr[j];\n            arr[i] = arr[i] + arr[j];\n        }\n        else\n        {\n            i++;\n        }\n    }\n    \n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "/tmp/tmph5xz0fjx.d(39): Error: cannot implicitly convert expression `arr.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph5xz0fjx.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i+1];\n            arr[i+1]=arr[i];\n            i=0;\n        }\n        else\n            i++;\n    }\n    return arr[0]<arr[1];\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp7nv5bhnk.d(55): unittest failure\n----------------\n??:? _d_unittestp [0x42829d]\n??:? void tmp7nv5bhnk.__unittest_L51_C1() [0x427eda]\n??:? void tmp7nv5bhnk.__modtest() [0x428020]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b18e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430321]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b165]\n??:? runModuleUnitTests [0x42c0d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428760]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpskp2rj12.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmpskp2rj12.__unittest_L51_C1() [0x427fcc]\n??:? void tmpskp2rj12.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_ep6vgsn.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x428335]\n??:? void tmp_ep6vgsn.__unittest_L51_C1() [0x428018]\n??:? void tmp_ep6vgsn.__modtest() [0x4280b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i+1];\n            arr[i+1]=arr[i];\n            i=0;\n        }\n        else\n            i++;\n    }\n    return arr[0]<arr[1];\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp7nv5bhnk.d(55): unittest failure\n----------------\n??:? _d_unittestp [0x42829d]\n??:? void tmp7nv5bhnk.__unittest_L51_C1() [0x427eda]\n??:? void tmp7nv5bhnk.__modtest() [0x428020]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b18e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430321]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b165]\n??:? runModuleUnitTests [0x42c0d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428760]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    \n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp4ofki_cu.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmp4ofki_cu.__unittest_L52_C1() [0x427fcc]\n??:? void tmp4ofki_cu.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    int N = arr.length;\n    if(N==0) return true;\n    int i=0;\n    while(i<N-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "/tmp/tmplzdtp_r4.d(35): Error: cannot implicitly convert expression `arr.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplzdtp_r4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length-1)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp1eg9vjc9.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x428335]\n??:? void tmp1eg9vjc9.__unittest_L52_C1() [0x428018]\n??:? void tmp1eg9vjc9.__modtest() [0x4280b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    \n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp4ofki_cu.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmp4ofki_cu.__unittest_L52_C1() [0x427fcc]\n??:? void tmp4ofki_cu.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length - 1)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_ufkp42v.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x428335]\n??:? void tmp_ufkp42v.__unittest_L52_C1() [0x428018]\n??:? void tmp_ufkp42v.__modtest() [0x4280b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length)\n    {\n        int j = i;\n        while(j < arr.length && arr[j] < arr[j+1])\n            j++;\n        if(j == i)\n            i++;\n        else\n        {\n            long temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i = j;\n        }\n    }\n    \n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp8gru4f2z.d(42): Range violation\n----------------\n??:? _d_arrayboundsp [0x428306]\n??:? bool tmp8gru4f2z.move_one_ball(long[]) [0x427d69]\n??:? void tmp8gru4f2z.__unittest_L57_C1() [0x427e77]\n??:? void tmp8gru4f2z.__modtest() [0x427fd4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2b3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b146]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302d9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430788]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430265]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b11d]\n??:? runModuleUnitTests [0x42c089]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    \n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp75aexb1y.d(41): Range violation\n----------------\n??:? _d_arrayboundsp [0x4283de]\n??:? bool tmp75aexb1y.move_one_ball(long[]) [0x427d5d]\n??:? void tmp75aexb1y.__unittest_L53_C1() [0x427f4f]\n??:? void tmp75aexb1y.__modtest() [0x4280ac]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c38b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b21e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430860]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43033d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1f5]\n??:? runModuleUnitTests [0x42c161]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length - 1)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_ufkp42v.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x428335]\n??:? void tmp_ufkp42v.__unittest_L52_C1() [0x428018]\n??:? void tmp_ufkp42v.__modtest() [0x4280b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]^arr[i+1];\n            arr[i+1]=arr[i]^arr[i+1];\n            arr[i]=arr[i]^arr[i+1];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmplb6q00rq.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmplb6q00rq.__unittest_L51_C1() [0x427fcc]\n??:? void tmplb6q00rq.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        else\n        {\n            i++;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp3evxbfnf.d(59): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmp3evxbfnf.__unittest_L53_C1() [0x427fcc]\n??:? void tmp3evxbfnf.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i+1];\n            arr[i+1]=arr[i];\n            i=0;\n        }\n        else\n            i++;\n    }\n    return arr[0]<arr[1];\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp7nv5bhnk.d(55): unittest failure\n----------------\n??:? _d_unittestp [0x42829d]\n??:? void tmp7nv5bhnk.__unittest_L51_C1() [0x427eda]\n??:? void tmp7nv5bhnk.__modtest() [0x428020]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b18e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430321]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b165]\n??:? runModuleUnitTests [0x42c0d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428760]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length - 1)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_ufkp42v.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x428335]\n??:? void tmp_ufkp42v.__unittest_L52_C1() [0x428018]\n??:? void tmp_ufkp42v.__modtest() [0x4280b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i+1];\n            arr[i+1]=arr[i];\n            i=0;\n        }\n        else\n            i++;\n    }\n    return arr[0]<arr[1];\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp7nv5bhnk.d(55): unittest failure\n----------------\n??:? _d_unittestp [0x42829d]\n??:? void tmp7nv5bhnk.__unittest_L51_C1() [0x427eda]\n??:? void tmp7nv5bhnk.__modtest() [0x428020]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b18e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430321]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b165]\n??:? runModuleUnitTests [0x42c0d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428760]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        else\n            i++;\n    }\n    \n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpa2rlk8m4.d(41): Range violation\n----------------\n??:? _d_arrayboundsp [0x4283e6]\n??:? bool tmpa2rlk8m4.move_one_ball(long[]) [0x427d5d]\n??:? void tmpa2rlk8m4.__unittest_L54_C1() [0x427f57]\n??:? void tmpa2rlk8m4.__modtest() [0x4280b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    \n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i+1];\n            arr[i+1]=arr[i];\n            i++;\n        }\n        else\n            i++;\n    }\n    return arr[0]<arr[1];\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpa1v48llc.d(59): unittest failure\n----------------\n??:? _d_unittestp [0x42829d]\n??:? void tmpa1v48llc.__unittest_L52_C1() [0x427fd5]\n??:? void tmpa1v48llc.__modtest() [0x42801c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b18e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430321]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b165]\n??:? runModuleUnitTests [0x42c0d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428760]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0) return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i+1];\n            arr[i+1]=arr[i];\n            i=0;\n        }\n        else\n            i++;\n    }\n    return arr[0]<arr[1];\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmps1oa83km.d(54): unittest failure\n----------------\n??:? _d_unittestp [0x42829d]\n??:? void tmps1oa83km.__unittest_L50_C1() [0x427eda]\n??:? void tmps1oa83km.__modtest() [0x428020]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b18e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430321]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b165]\n??:? runModuleUnitTests [0x42c0d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428760]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i+1];\n            arr[i+1]=arr[i];\n            i=0;\n        }\n        else\n            i++;\n    }\n    return arr[0]<arr[1];\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp7nv5bhnk.d(55): unittest failure\n----------------\n??:? _d_unittestp [0x42829d]\n??:? void tmp7nv5bhnk.__unittest_L51_C1() [0x427eda]\n??:? void tmp7nv5bhnk.__modtest() [0x428020]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b18e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430321]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b165]\n??:? runModuleUnitTests [0x42c0d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428760]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    \n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp75aexb1y.d(41): Range violation\n----------------\n??:? _d_arrayboundsp [0x4283de]\n??:? bool tmp75aexb1y.move_one_ball(long[]) [0x427d5d]\n??:? void tmp75aexb1y.__unittest_L53_C1() [0x427f4f]\n??:? void tmp75aexb1y.__modtest() [0x4280ac]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c38b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b21e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430860]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43033d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1f5]\n??:? runModuleUnitTests [0x42c161]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpebduf682.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmpebduf682.__unittest_L50_C1() [0x427fc8]\n??:? void tmpebduf682.__modtest() [0x428064]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i+1];\n            arr[i+1]=arr[i];\n        }\n        else\n            i++;\n    }\n    return arr[0]<arr[i];\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp120n7790.d(54): unittest failure\n----------------\n??:? _d_unittestp [0x42829d]\n??:? void tmp120n7790.__unittest_L50_C1() [0x427ed6]\n??:? void tmp120n7790.__modtest() [0x42801c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b18e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430321]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b165]\n??:? runModuleUnitTests [0x42c0d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428760]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length)\n    {\n        int j = i + 1;\n        while(j < arr.length)\n        {\n            if(arr[i] > arr[j])\n            {\n                arr[i] = arr[i] - arr[j];\n                arr[j] = arr[i] + arr[j];\n                arr[i] = arr[i] - arr[j];\n            }\n            j++;\n        }\n        i++;\n    }\n    \n    for(i = 0; i < arr.length; i++)\n        if(arr[i] != i)\n            return false;\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpwefsz3_q.d(64): unittest failure\n----------------\n??:? _d_unittestp [0x42833d]\n??:? void tmpwefsz3_q.__unittest_L60_C1() [0x427f7a]\n??:? void tmpwefsz3_q.__modtest() [0x4280c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c39b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b22e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303c1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430870]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43034d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b205]\n??:? runModuleUnitTests [0x42c171]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428800]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    int N = arr.length;\n    if(N == 0) return true;\n    int i = 0;\n    while(i < N)\n    {\n        int j = i + 1;\n        while(j < N)\n        {\n            if(arr[i] > arr[j])\n            {\n                arr[i] = arr[i] + arr[j];\n                arr[j] = arr[i] - arr[j];\n                arr[i] = arr[i] - arr[j];\n            }\n            j++;\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "/tmp/tmp8xro2m4l.d(35): Error: cannot implicitly convert expression `arr.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8xro2m4l.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length - 1)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_ufkp42v.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x428335]\n??:? void tmp_ufkp42v.__unittest_L52_C1() [0x428018]\n??:? void tmp_ufkp42v.__modtest() [0x4280b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    int N = arr.length;\n    if(N == 0)\n        return true;\n    int i = 0;\n    while(i < N)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        else\n        {\n            i++;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "/tmp/tmp17_qj3ij.d(35): Error: cannot implicitly convert expression `arr.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp17_qj3ij.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    int N = arr.length;\n    if(N == 0) return true;\n    int i = 0;\n    while(i < N)\n    {\n        int j = i + 1;\n        while(j < N && arr[j] >= arr[i])\n        {\n            if(arr[j] == arr[i])\n            {\n                arr[j] = arr[N - 1];\n                arr[N - 1] = arr[i];\n                arr[i] = arr[N - 1];\n                arr[N - 1] = arr[j];\n                arr[j] = arr[N - 1];\n                arr[N - 1] = arr[i];\n                arr[i] = arr[N - 1];\n                arr[N - 1] = arr[j];\n                arr[j] = arr[N - 1];\n                arr[N - 1] = arr[i];\n                arr[i] = arr[N - 1];\n                arr[N - 1] = arr[j];\n                arr[j] = arr[N - 1];\n                arr[N - 1] = arr[i];\n                arr[i] = arr[N - 1];\n                arr[N - 1] = arr[j];\n                arr[j] = arr[N - 1];\n                arr[N - 1] = arr[i];\n                arr[i] = arr[N - 1];\n                arr[N - 1] = arr[j];\n                arr[j] = arr[N - 1];\n                arr[N - 1] = arr[i];\n                arr[i] = arr[N - 1];\n                arr[N - 1] = arr[j];\n                arr[j] = arr[N - 1];\n                arr[N - 1] = arr[i];\n                arr[i] = arr[N - 1];\n                arr[N - 1] = arr[j];\n                arr[j] = arr[N - 1];\n                arr[N - 1] = arr[i];\n                arr[i] = arr[N - 1];\n                arr[N - 1] = arr[j];\n                arr[j] = arr[N - 1\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "/tmp/tmp3zspszgp.d(78): Error: found `unittest` when expecting `,`\n/tmp/tmp3zspszgp.d(88): Error: found `void` when expecting `,`\n/tmp/tmp3zspszgp.d(88): Error: found `{` when expecting `,`\n/tmp/tmp3zspszgp.d(88): Error: expression expected, not `}`\n/tmp/tmp3zspszgp.d(88): Error: found `End of File` when expecting `,`\n/tmp/tmp3zspszgp.d(88): Error: found `End of File` when expecting `]`\n/tmp/tmp3zspszgp.d(88): Error: found `End of File` when expecting `;` following statement\n/tmp/tmp3zspszgp.d(88): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp3zspszgp.d(88): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp3zspszgp.d(88): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp3zspszgp.d(88): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3zspszgp.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpskp2rj12.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmpskp2rj12.__unittest_L51_C1() [0x427fcc]\n??:? void tmpskp2rj12.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpri5scjpi.d(41): Range violation\n----------------\n??:? _d_arrayboundsp [0x4283e6]\n??:? bool tmpri5scjpi.move_one_ball(long[]) [0x427d5d]\n??:? void tmpri5scjpi.__unittest_L53_C1() [0x427f57]\n??:? void tmpri5scjpi.__modtest() [0x4280b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length)\n    {\n        if(arr[i] > arr[i+1])\n            return false;\n        \n        arr[i] = arr[i] + arr[i+1];\n        arr[i+1] = arr[i] - arr[i+1];\n        arr[i] = arr[i] - arr[i+1];\n        \n        i++;\n    }\n    \n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpyo_gh6s8.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x4282dd]\n??:? void tmpyo_gh6s8.__unittest_L53_C1() [0x427f1a]\n??:? void tmpyo_gh6s8.__modtest() [0x428060]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c33b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ce]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430361]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430810]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302ed]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1a5]\n??:? runModuleUnitTests [0x42c111]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpskp2rj12.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmpskp2rj12.__unittest_L51_C1() [0x427fcc]\n??:? void tmpskp2rj12.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length)\n    {\n        if(arr[i] > arr[i+1])\n            return false;\n        \n        if(arr[i] < arr[i+1])\n            break;\n        \n        arr[i] = arr[i+1];\n        i++;\n    }\n    arr[i] = arr[0];\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpew3_zg76.d(60): unittest failure\n----------------\n??:? _d_unittestp [0x428285]\n??:? void tmpew3_zg76.__unittest_L53_C1() [0x427fc1]\n??:? void tmpew3_zg76.__modtest() [0x428008]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2e3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b176]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430309]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307b8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430295]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b14d]\n??:? runModuleUnitTests [0x42c0b9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428748]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i+1];\n            arr[i+1]=arr[i];\n            i=0;\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqprketwe.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpqprketwe.__unittest_L51_C1() [0x427f40]\n??:? void tmpqprketwe.__modtest() [0x427fdc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        else\n            i++;\n    }\n    \n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpa2rlk8m4.d(41): Range violation\n----------------\n??:? _d_arrayboundsp [0x4283e6]\n??:? bool tmpa2rlk8m4.move_one_ball(long[]) [0x427d5d]\n??:? void tmpa2rlk8m4.__unittest_L54_C1() [0x427f57]\n??:? void tmpa2rlk8m4.__modtest() [0x4280b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    \n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp75aexb1y.d(41): Range violation\n----------------\n??:? _d_arrayboundsp [0x4283de]\n??:? bool tmp75aexb1y.move_one_ball(long[]) [0x427d5d]\n??:? void tmp75aexb1y.__unittest_L53_C1() [0x427f4f]\n??:? void tmp75aexb1y.__modtest() [0x4280ac]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c38b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b21e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430860]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43033d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1f5]\n??:? runModuleUnitTests [0x42c161]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpskp2rj12.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmpskp2rj12.__unittest_L51_C1() [0x427fcc]\n??:? void tmpskp2rj12.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpskp2rj12.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmpskp2rj12.__unittest_L51_C1() [0x427fcc]\n??:? void tmpskp2rj12.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i+1];\n            arr[i+1]=arr[i];\n            i=0;\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqprketwe.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpqprketwe.__unittest_L51_C1() [0x427f40]\n??:? void tmpqprketwe.__modtest() [0x427fdc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length - 1)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_ufkp42v.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x428335]\n??:? void tmp_ufkp42v.__unittest_L52_C1() [0x428018]\n??:? void tmp_ufkp42v.__modtest() [0x4280b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i+1];\n            arr[i+1]=arr[i];\n            i=0;\n        }\n        else\n            i++;\n    }\n    return arr[0]<arr[1];\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp7nv5bhnk.d(55): unittest failure\n----------------\n??:? _d_unittestp [0x42829d]\n??:? void tmp7nv5bhnk.__unittest_L51_C1() [0x427eda]\n??:? void tmp7nv5bhnk.__modtest() [0x428020]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b18e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430321]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b165]\n??:? runModuleUnitTests [0x42c0d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428760]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    \n    int i = 0;\n    while(i < arr.length)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpri5scjpi.d(41): Range violation\n----------------\n??:? _d_arrayboundsp [0x4283e6]\n??:? bool tmpri5scjpi.move_one_ball(long[]) [0x427d5d]\n??:? void tmpri5scjpi.__unittest_L53_C1() [0x427f57]\n??:? void tmpri5scjpi.__modtest() [0x4280b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpebduf682.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmpebduf682.__unittest_L50_C1() [0x427fc8]\n??:? void tmpebduf682.__modtest() [0x428064]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]^arr[i+1];\n            arr[i+1]=arr[i]^arr[i+1];\n            arr[i]=arr[i]^arr[i+1];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpluygykvg.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmpluygykvg.__unittest_L50_C1() [0x427fc8]\n??:? void tmpluygykvg.__modtest() [0x428064]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpskp2rj12.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmpskp2rj12.__unittest_L51_C1() [0x427fcc]\n??:? void tmpskp2rj12.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length == 0)\n        return true;\n    int i = 0;\n    while(i < arr.length-1)\n    {\n        if(arr[i] > arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp5lnegtz9.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x428335]\n??:? void tmp5lnegtz9.__unittest_L51_C1() [0x428018]\n??:? void tmp5lnegtz9.__modtest() [0x4280b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    int N = arr.length;\n    if(N == 0)\n        return true;\n    \n    int i = 0;\n    while(i < N)\n    {\n        int j = i+1;\n        while(j < N)\n        {\n            if(arr[i] > arr[j])\n            {\n                arr[i] = arr[i] + arr[j];\n                arr[j] = arr[i] - arr[j];\n                arr[i] = arr[i] - arr[j];\n            }\n            j++;\n        }\n        i++;\n    }\n    return arr[0] >= 0;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "/tmp/tmpixv5dzxg.d(35): Error: cannot implicitly convert expression `arr.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpixv5dzxg.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpebduf682.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmpebduf682.__unittest_L50_C1() [0x427fc8]\n??:? void tmpebduf682.__modtest() [0x428064]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    \n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i]+arr[i+1];\n            arr[i+1]=arr[i]-arr[i+1];\n            arr[i]=arr[i]-arr[i+1];\n        }\n        else\n            i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp4ofki_cu.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmp4ofki_cu.__unittest_L52_C1() [0x427fcc]\n??:? void tmp4ofki_cu.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i] = arr[i] - arr[i+1];\n            arr[i+1] = arr[i+1] + arr[i];\n            arr[i] = arr[i] + arr[i+1];\n            arr[i+1] = arr[i+1] - arr[i];\n        }\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_ep6vgsn.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x428335]\n??:? void tmp_ep6vgsn.__unittest_L51_C1() [0x428018]\n??:? void tmp_ep6vgsn.__modtest() [0x4280b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c393]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b226]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430345]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1fd]\n??:? runModuleUnitTests [0x42c169]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return false.\n    If the given array is empty then return true.\n\n    Note: The given array is guaranteed to have unique elements.\n\n    For Example:\n    \n    >>> move_one_ball([3L, 4L, 5L, 1L, 2L])\n    true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    >>> move_one_ball([3L, 5L, 4L, 1L, 2L])\n    false\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \n*/\nbool move_one_ball(long[] arr) \n{\n    if(arr.length==0)\n        return true;\n    \n    int i=0;\n    while(i<arr.length-1)\n    {\n        if(arr[i]>arr[i+1])\n        {\n            arr[i]=arr[i+1];\n            arr[i+1]=arr[i];\n            i=0;\n        }\n        else\n            i++;\n    }\n    return arr[0]<arr[1];\n}\nunittest\n{\n    alias candidate = move_one_ball;\n\n    assert(candidate([3L, 4L, 5L, 1L, 2L]) == true);\n    assert(candidate([3L, 5L, 10L, 1L, 2L]) == true);\n    assert(candidate([4L, 3L, 1L, 2L]) == false);\n    assert(candidate([3L, 5L, 4L, 1L, 2L]) == false);\n    assert(candidate([]) == true);\n}\nvoid main(){}",
      "timestamp": 1664292756,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpb8ixyxf3.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x42829d]\n??:? void tmpb8ixyxf3.__unittest_L52_C1() [0x427eda]\n??:? void tmpb8ixyxf3.__modtest() [0x428020]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b18e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430321]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b165]\n??:? runModuleUnitTests [0x42c0d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428760]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}