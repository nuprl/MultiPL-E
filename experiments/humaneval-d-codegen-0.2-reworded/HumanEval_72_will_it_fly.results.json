{
  "name": "HumanEval_72_will_it_fly",
  "language": "d",
  "prompt": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n",
  "tests": "unittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "results": [
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    \n    long max_weight = w - (q.length - 1) * q[0];\n    if (q[0] > max_weight) return false;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    return sum <= max_weight;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_e__q25f.d(44): unittest failure\n----------------\n??:? _d_unittestp [0x42829d]\n??:? void tmp_e__q25f.__unittest_L40_C1() [0x427ea4]\n??:? void tmp_e__q25f.__modtest() [0x42801c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b18e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430321]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b165]\n??:? runModuleUnitTests [0x42c0d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428760]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length % 2 == 0)\n    {\n        long sum = 0;\n        for (int i = 0; i < q.length; i += 2)\n            sum += q[i];\n        return sum <= w;\n    }\n    else\n    {\n        long sum = 0;\n        for (int i = 1; i < q.length; i += 2)\n            sum += q[i];\n        return sum <= w;\n    }\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpo7bsxjm8.d(54): unittest failure\n----------------\n??:? _d_unittestp [0x4282a5]\n??:? void tmpo7bsxjm8.__unittest_L49_C1() [0x427ef4]\n??:? void tmpo7bsxjm8.__modtest() [0x428024]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c303]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b196]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430329]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b16d]\n??:? runModuleUnitTests [0x42c0d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428768]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length % 2 == 0)\n        return q[0] + q[1] + q[q.length - 2] + q[q.length - 1] <= w;\n    return q[0] + q[1] + q[q.length - 1] <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpc2t1_dkh.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x4282f5]\n??:? void tmpc2t1_dkh.__unittest_L38_C1() [0x427f44]\n??:? void tmpc2t1_dkh.__modtest() [0x428074]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c353]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1e6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430379]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430828]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430305]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1bd]\n??:? runModuleUnitTests [0x42c129]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287b8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    return q.length == 0 || q.length == 1 || (q.length % 2 == 0 && sum(q) <= w);\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292669,
      "stdout": "",
      "stderr": "/tmp/tmpz2k1x_9t.d(28): Error: undefined identifier `sum`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz2k1x_9t.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    \n    long max = 0;\n    for (int i = 0; i < q.length; i++) {\n        max += q[i];\n    }\n    if (max > w) return false;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++) {\n        sum += q[i];\n    }\n    \n    if (sum <= w) return true;\n    \n    return false;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_muo4pnh.d(52): unittest failure\n----------------\n??:? _d_unittestp [0x428295]\n??:? void tmp_muo4pnh.__unittest_L47_C1() [0x427ee8]\n??:? void tmp_muo4pnh.__modtest() [0x428018]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2f3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b186]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430319]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307c8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302a5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b15d]\n??:? runModuleUnitTests [0x42c0c9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428758]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length % 2 == 1)\n        return q[q.length / 2] <= w;\n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp4gg27a7r.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x42827d]\n??:? void tmp4gg27a7r.__unittest_L41_C1() [0x427ed0]\n??:? void tmp4gg27a7r.__modtest() [0x428000]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2db]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b16e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430301]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307b0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43028d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b145]\n??:? runModuleUnitTests [0x42c0b1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428740]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    if (sum > w)\n        return false;\n    \n    if (sum == w)\n        return true;\n    \n    if (sum < w)\n        return false;\n    \n    return is_balanced(q);\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292669,
      "stdout": "",
      "stderr": "/tmp/tmprdbqa0j9.d(44): Error: undefined identifier `is_balanced`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprdbqa0j9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length % 2 == 0)\n        return q[0] + q[1] + q[q.length - 1] <= w;\n    return q[0] + q[1] + q[q.length - 1] + q[q.length - 2] <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpo3u8bb5m.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x4282f5]\n??:? void tmpo3u8bb5m.__unittest_L38_C1() [0x427efc]\n??:? void tmpo3u8bb5m.__modtest() [0x428074]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c353]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1e6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430379]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430828]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430305]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1bd]\n??:? runModuleUnitTests [0x42c129]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287b8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    \n    long max_weight = w;\n    long sum = 0;\n    for (int i = 0; i < q.length; i++) {\n        sum += q[i];\n        if (sum > max_weight) return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpro004x1r.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x42823d]\n??:? void tmpro004x1r.__unittest_L40_C1() [0x427e90]\n??:? void tmpro004x1r.__modtest() [0x427fc0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c29b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b12e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302c1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430770]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43024d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b105]\n??:? runModuleUnitTests [0x42c071]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428700]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    \n    long max_weight = w;\n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n    {\n        sum += q[i];\n        if (sum > max_weight)\n            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgzvimcop.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x42823d]\n??:? void tmpgzvimcop.__unittest_L45_C1() [0x427e90]\n??:? void tmpgzvimcop.__modtest() [0x427fc0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c29b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b12e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302c1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430770]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43024d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b105]\n??:? runModuleUnitTests [0x42c071]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428700]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    if (q.length == 1)\n        return q[0] <= w;\n    \n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpv1k82vwa.d(48): unittest failure\n----------------\n??:? _d_unittestp [0x428235]\n??:? void tmpv1k82vwa.__unittest_L43_C1() [0x427e84]\n??:? void tmpv1k82vwa.__modtest() [0x427fb4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c293]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b126]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430768]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430245]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b0fd]\n??:? runModuleUnitTests [0x42c069]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4286f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if(q.length == 0)\n        return true;\n    \n    if(q.length == 1)\n        return q[0] <= w;\n    \n    if(q.length == 2)\n        return q[0] + q[1] <= w;\n    \n    long max = 0;\n    for(int i = 0; i < q.length; i++)\n        max = std.math.max(max, q[i]);\n    \n    if(max <= w)\n        return true;\n    \n    return false;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292669,
      "stdout": "",
      "stderr": "/tmp/tmprzmgfd70.d(39): Error: undefined identifier `max` in module `std.math`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprzmgfd70.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    \n    long max_weight = w - q[0];\n    for (int i = 1; i < q.length; i++)\n    {\n        if (q[i] > max_weight) return false;\n        max_weight += q[i];\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpxol4bi1w.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x428285]\n??:? void tmpxol4bi1w.__unittest_L40_C1() [0x427ed8]\n??:? void tmpxol4bi1w.__modtest() [0x428008]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2e3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b176]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430309]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307b8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430295]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b14d]\n??:? runModuleUnitTests [0x42c0b9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428748]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    if (q.length == 3) return q[0] + q[1] + q[2] <= w;\n    if (q.length == 4) return q[0] + q[1] + q[2] + q[3] <= w;\n    if (q.length == 5) return q[0] + q[1] + q[2] + q[3] + q[4] <= w;\n    if (q.length == 6) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] <= w;\n    if (q.length == 7) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] <= w;\n    if (q.length == 8) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] <= w;\n    if (q.length == 9) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] <= w;\n    if (q.length == 10) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] + q[9] <= w;\n    if (q.length == 11) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] + q[9] + q[10] <= w;\n    if (q.length == 12) return q[0] + q[1] + q[2]\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292669,
      "stdout": "",
      "stderr": "/tmp/tmpae818htn.d(41): Error: found `unittest` when expecting `;` following `return` statement\n/tmp/tmpae818htn.d(52): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpae818htn.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    \n    long max_weight = w - (q.length - 1);\n    \n    if (q[0] + q[q.length - 1] > max_weight)\n        return false;\n    \n    for (int i = 1; i < q.length - 1; i++)\n        if (q[i] + q[q.length - 1 - i] > max_weight)\n            return false;\n    \n    return true;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpejj7fclb.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x4282bd]\n??:? void tmpejj7fclb.__unittest_L46_C1() [0x427f10]\n??:? void tmpejj7fclb.__modtest() [0x428040]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c31b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430341]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302cd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b185]\n??:? runModuleUnitTests [0x42c0f1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428780]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 1)\n        return q[0] <= w;\n    \n    if (q.length % 2 == 1)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmphujtz1v6.d(44): unittest failure\n----------------\n??:? _d_unittestp [0x4281e5]\n??:? void tmphujtz1v6.__unittest_L40_C1() [0x427df0]\n??:? void tmphujtz1v6.__modtest() [0x427f68]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c243]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b0d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430269]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430718]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4301f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b0ad]\n??:? runModuleUnitTests [0x42c019]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4286a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    \n    long max_weight = w;\n    long sum = 0;\n    for (int i = 0; i < q.length; i++) {\n        sum += q[i];\n        if (sum > max_weight) return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpro004x1r.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x42823d]\n??:? void tmpro004x1r.__unittest_L40_C1() [0x427e90]\n??:? void tmpro004x1r.__modtest() [0x427fc0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c29b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b12e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302c1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430770]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43024d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b105]\n??:? runModuleUnitTests [0x42c071]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428700]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length % 2 == 0)\n    {\n        long sum = 0;\n        for (int i = 0; i < q.length; i += 2)\n            sum += q[i];\n        return sum <= w;\n    }\n    else\n    {\n        long sum = 0;\n        for (int i = 1; i < q.length; i += 2)\n            sum += q[i];\n        return sum <= w;\n    }\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpo7bsxjm8.d(54): unittest failure\n----------------\n??:? _d_unittestp [0x4282a5]\n??:? void tmpo7bsxjm8.__unittest_L49_C1() [0x427ef4]\n??:? void tmpo7bsxjm8.__modtest() [0x428024]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c303]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b196]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430329]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b16d]\n??:? runModuleUnitTests [0x42c0d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428768]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    if (sum > w)\n        return false;\n    \n    if (q.length % 2 == 0)\n    {\n        for (int i = 0; i < q.length; i += 2)\n        {\n            if (q[i] != q[i + 1])\n                return false;\n        }\n        return true;\n    }\n    else\n    {\n        for (int i = 0; i < q.length; i += 2)\n        {\n            if (q[i] != q[i + 1])\n                return false;\n        }\n        return true;\n    }\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpaq_unry8.d(61): unittest failure\n----------------\n??:? _d_unittestp [0x4282bd]\n??:? void tmpaq_unry8.__unittest_L57_C1() [0x427ec4]\n??:? void tmpaq_unry8.__modtest() [0x42803c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c31b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430341]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302cd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b185]\n??:? runModuleUnitTests [0x42c0f1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428780]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length % 2 == 0)\n        return q[0] + q[1] + q[q.length - 2] + q[q.length - 1] <= w;\n    return q[0] + q[1] + q[q.length - 1] <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpc2t1_dkh.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x4282f5]\n??:? void tmpc2t1_dkh.__unittest_L38_C1() [0x427f44]\n??:? void tmpc2t1_dkh.__modtest() [0x428074]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c353]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1e6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430379]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430828]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430305]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1bd]\n??:? runModuleUnitTests [0x42c129]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287b8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    return sum <= w && is_balanced(q);\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292669,
      "stdout": "",
      "stderr": "/tmp/tmppyw0b7_5.d(35): Error: undefined identifier `is_balanced`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppyw0b7_5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if(q.length == 0)\n        return true;\n    if(q.length == 1)\n        return q[0] <= w;\n    if(q.length == 2)\n        return q[0] + q[1] <= w;\n    \n    long max_weight = 0;\n    for(int i = 0; i < q.length; i++)\n        max_weight += q[i];\n    \n    if(max_weight > w)\n        return false;\n    \n    if(q.length % 2 == 0)\n    {\n        for(int i = 0; i < q.length / 2; i++)\n        {\n            if(q[i] != q[q.length - i - 1])\n                return false;\n        }\n        return true;\n    }\n    else\n    {\n        for(int i = 0; i < q.length / 2; i++)\n        {\n            if(q[i] != q[q.length - i - 1])\n                return false;\n        }\n        return true;\n    }\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmplhyg00us.d(66): unittest failure\n----------------\n??:? _d_unittestp [0x42833d]\n??:? void tmplhyg00us.__unittest_L61_C1() [0x427f90]\n??:? void tmplhyg00us.__modtest() [0x4280c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c39b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b22e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303c1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430870]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43034d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b205]\n??:? runModuleUnitTests [0x42c171]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428800]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    if (q.length == 1)\n        return q[0] <= w;\n    \n    if (q.length % 2 == 1)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpu5s38mvq.d(47): unittest failure\n----------------\n??:? _d_unittestp [0x4281fd]\n??:? void tmpu5s38mvq.__unittest_L43_C1() [0x427e04]\n??:? void tmpu5s38mvq.__modtest() [0x427f7c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c25b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b0ee]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430281]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430730]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43020d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b0c5]\n??:? runModuleUnitTests [0x42c031]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4286c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    if (q.length == 3) return q[0] + q[1] + q[2] <= w;\n    if (q.length == 4) return q[0] + q[1] + q[2] + q[3] <= w;\n    if (q.length == 5) return q[0] + q[1] + q[2] + q[3] + q[4] <= w;\n    if (q.length == 6) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] <= w;\n    if (q.length == 7) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] <= w;\n    if (q.length == 8) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] <= w;\n    if (q.length == 9) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] <= w;\n    if (q.length == 10) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] + q[9] <= w;\n    if (q.length == 11) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] + q[9] + q[10] <= w;\n    if (q.length == 12) return q[0] + q[1] + q[2]\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292669,
      "stdout": "",
      "stderr": "/tmp/tmpae818htn.d(41): Error: found `unittest` when expecting `;` following `return` statement\n/tmp/tmpae818htn.d(52): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpae818htn.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    if (q.length == 1)\n        return q[0] <= w;\n    \n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    \n    long max = 0;\n    for (int i = 0; i < q.length; i++)\n        max = std.math.max(max, q[i]);\n    \n    if (max > w)\n        return false;\n    \n    if (q.length % 2 == 1)\n        return q[q.length / 2] <= w;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292669,
      "stdout": "",
      "stderr": "/tmp/tmp0gtmwthr.d(39): Error: undefined identifier `max` in module `std.math`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0gtmwthr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length % 2 == 1)\n        return q[0] + q[q.length - 1] <= w;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpndmb922b.d(47): unittest failure\n----------------\n??:? _d_unittestp [0x42829d]\n??:? void tmpndmb922b.__unittest_L42_C1() [0x427ef0]\n??:? void tmpndmb922b.__modtest() [0x428020]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b18e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430321]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b165]\n??:? runModuleUnitTests [0x42c0d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428760]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length % 2 == 0)\n    {\n        long sum = 0;\n        for (int i = 0; i < q.length; i += 2)\n            sum += q[i];\n        return sum <= w;\n    }\n    else\n    {\n        long sum = 0;\n        for (int i = 1; i < q.length; i += 2)\n            sum += q[i];\n        return sum <= w;\n    }\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpo7bsxjm8.d(54): unittest failure\n----------------\n??:? _d_unittestp [0x4282a5]\n??:? void tmpo7bsxjm8.__unittest_L49_C1() [0x427ef4]\n??:? void tmpo7bsxjm8.__modtest() [0x428024]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c303]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b196]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430329]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b16d]\n??:? runModuleUnitTests [0x42c0d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428768]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return false;\n    long sum = 0;\n    for (int i = 0; i < q.length; i++) {\n        sum += q[i];\n    }\n    return sum <= w && is_balanced(q);\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292669,
      "stdout": "",
      "stderr": "/tmp/tmp9k6asus0.d(33): Error: undefined identifier `is_balanced`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9k6asus0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    if (q.length == 1)\n        return q[0] <= w;\n    \n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpv1k82vwa.d(48): unittest failure\n----------------\n??:? _d_unittestp [0x428235]\n??:? void tmpv1k82vwa.__unittest_L43_C1() [0x427e84]\n??:? void tmpv1k82vwa.__modtest() [0x427fb4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c293]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b126]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430768]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430245]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b0fd]\n??:? runModuleUnitTests [0x42c069]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4286f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    \n    long max = 0;\n    for (int i = 0; i < q.length; i++) {\n        max += q[i];\n    }\n    if (max > w) return false;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++) {\n        sum += q[i];\n    }\n    \n    if (sum < w) return true;\n    \n    return is_balanced(q);\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292669,
      "stdout": "",
      "stderr": "/tmp/tmpv2_g2oxz.d(45): Error: undefined identifier `is_balanced`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv2_g2oxz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length % 2 == 0)\n        return q[0] + q[1] + q[q.length - 2] + q[q.length - 1] <= w;\n    else\n        return q[0] + q[1] + q[q.length - 1] <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpd2pe4cmm.d(44): unittest failure\n----------------\n??:? _d_unittestp [0x4282f5]\n??:? void tmpd2pe4cmm.__unittest_L39_C1() [0x427f44]\n??:? void tmpd2pe4cmm.__modtest() [0x428074]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c353]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1e6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430379]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430828]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430305]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1bd]\n??:? runModuleUnitTests [0x42c129]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287b8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    if (sum <= w) return true;\n    \n    return false;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpsm0s1sw0.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x42823d]\n??:? void tmpsm0s1sw0.__unittest_L40_C1() [0x427e90]\n??:? void tmpsm0s1sw0.__modtest() [0x427fc0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c29b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b12e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302c1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430770]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43024d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b105]\n??:? runModuleUnitTests [0x42c071]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428700]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length == 3)\n        return q[0] + q[1] + q[2] <= w;\n    if (q.length == 4)\n        return q[0] + q[1] + q[2] + q[3] <= w;\n    if (q.length == 5)\n        return q[0] + q[1] + q[2] + q[3] + q[4] <= w;\n    if (q.length == 6)\n        return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] <= w;\n    if (q.length == 7)\n        return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] <= w;\n    if (q.length == 8)\n        return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] <= w;\n    if (q.length == 9)\n        return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] <= w;\n    if (q.length == 10)\n        return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] + q[9] <= w;\n    if (q.length == 11)\n        return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] + q[9] + q[10] <= w;\n\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292669,
      "stdout": "",
      "stderr": "/tmp/tmptypmfhfr.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptypmfhfr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    if (q.length % 2 == 1)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpo4vr0xwn.d(44): unittest failure\n----------------\n??:? _d_unittestp [0x4281c5]\n??:? void tmpo4vr0xwn.__unittest_L40_C1() [0x427dd0]\n??:? void tmpo4vr0xwn.__modtest() [0x427f48]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c223]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b0b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430249]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4306f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4301d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b08d]\n??:? runModuleUnitTests [0x42bff9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428688]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if(q.length == 0)\n        return true;\n    if(q.length == 1)\n        return q[0] <= w;\n    if(q.length == 2)\n        return q[0] + q[1] <= w;\n    if(q.length == 3)\n        return q[0] + q[1] + q[2] <= w;\n    if(q.length == 4)\n        return q[0] + q[1] + q[2] + q[3] <= w;\n    if(q.length == 5)\n        return q[0] + q[1] + q[2] + q[3] + q[4] <= w;\n    if(q.length == 6)\n        return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] <= w;\n    if(q.length == 7)\n        return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] <= w;\n    if(q.length == 8)\n        return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] <= w;\n    if(q.length == 9)\n        return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] <= w;\n    if(q.length == 10)\n        return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] + q[9] <= w;\n    if(q.length == 11)\n        return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] + q[9] + q[10] <= w;\n\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292669,
      "stdout": "",
      "stderr": "/tmp/tmpkrae4tcn.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkrae4tcn.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    if (sum <= w)\n        return true;\n    \n    return false;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpn3pb7kzx.d(49): unittest failure\n----------------\n??:? _d_unittestp [0x42823d]\n??:? void tmpn3pb7kzx.__unittest_L44_C1() [0x427e90]\n??:? void tmpn3pb7kzx.__modtest() [0x427fc0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c29b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b12e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302c1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430770]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43024d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b105]\n??:? runModuleUnitTests [0x42c071]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428700]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    if (sum > w) return false;\n    \n    return is_balanced(q);\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292669,
      "stdout": "",
      "stderr": "/tmp/tmp9076g7r6.d(38): Error: undefined identifier `is_balanced`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9076g7r6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    return sum <= w && is_balanced(q);\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292669,
      "stdout": "",
      "stderr": "/tmp/tmpqpesq63j.d(35): Error: undefined identifier `is_balanced`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqpesq63j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length % 2 == 0)\n        return false;\n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpi0_oif_y.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428245]\n??:? void tmpi0_oif_y.__unittest_L41_C1() [0x427e98]\n??:? void tmpi0_oif_y.__modtest() [0x427fc8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b136]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430778]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430255]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b10d]\n??:? runModuleUnitTests [0x42c079]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428708]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length % 2 == 1)\n        return q[q.length / 2] <= w;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpq3hpk35a.d(47): unittest failure\n----------------\n??:? _d_unittestp [0x42827d]\n??:? void tmpq3hpk35a.__unittest_L42_C1() [0x427ed0]\n??:? void tmpq3hpk35a.__modtest() [0x428000]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2db]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b16e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430301]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307b0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43028d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b145]\n??:? runModuleUnitTests [0x42c0b1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428740]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length % 2 == 0)\n        return q[0] + q[1] + q[q.length - 2] + q[q.length - 1] <= w;\n    return q[0] + q[1] + q[q.length - 1] <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpc2t1_dkh.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x4282f5]\n??:? void tmpc2t1_dkh.__unittest_L38_C1() [0x427f44]\n??:? void tmpc2t1_dkh.__modtest() [0x428074]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c353]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1e6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430379]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430828]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430305]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1bd]\n??:? runModuleUnitTests [0x42c129]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287b8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    if (sum > w) return false;\n    \n    return is_balanced(q);\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292669,
      "stdout": "",
      "stderr": "/tmp/tmp9076g7r6.d(38): Error: undefined identifier `is_balanced`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9076g7r6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++) {\n        sum += q[i];\n    }\n    \n    if (sum > w) return false;\n    \n    return is_balanced(q);\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "/tmp/tmp38oizcyy.d(38): Error: undefined identifier `is_balanced`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp38oizcyy.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    if (q.length % 2 == 1)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    if (sum > w)\n        return false;\n    \n    return is_balanced(q);\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "/tmp/tmpk_m0lcrp.d(41): Error: undefined identifier `is_balanced`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk_m0lcrp.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    if (sum > w)\n        return false;\n    \n    if (sum == w)\n        return true;\n    \n    if (sum < w)\n        return false;\n    \n    if (q.length % 2 == 1)\n        return false;\n    \n    for (int i = 0; i < q.length; i++)\n        if (q[i] != q[q.length - 1 - i])\n            return false;\n    \n    return true;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpmjfg6ib5.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x428265]\n??:? void tmpmjfg6ib5.__unittest_L53_C1() [0x427e70]\n??:? void tmpmjfg6ib5.__modtest() [0x427fe8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2c3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b156]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430798]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430275]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b12d]\n??:? runModuleUnitTests [0x42c099]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428728]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length % 2 == 0)\n    {\n        long sum = 0;\n        for (int i = 0; i < q.length; i += 2)\n            sum += q[i];\n        return sum <= w;\n    }\n    else\n    {\n        long sum = 0;\n        for (int i = 1; i < q.length; i += 2)\n            sum += q[i];\n        return sum <= w;\n    }\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpo7bsxjm8.d(54): unittest failure\n----------------\n??:? _d_unittestp [0x4282a5]\n??:? void tmpo7bsxjm8.__unittest_L49_C1() [0x427ef4]\n??:? void tmpo7bsxjm8.__modtest() [0x428024]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c303]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b196]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430329]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b16d]\n??:? runModuleUnitTests [0x42c0d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428768]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length % 2 == 0)\n        return q[0] + q[1] + q[q.length - 1] + q[q.length - 2] <= w;\n    return q[0] + q[1] + q[q.length - 1] <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpoc12elwj.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x4282f5]\n??:? void tmpoc12elwj.__unittest_L38_C1() [0x427f44]\n??:? void tmpoc12elwj.__modtest() [0x428074]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c353]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1e6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430379]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430828]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430305]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1bd]\n??:? runModuleUnitTests [0x42c129]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287b8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    if (q.length % 2 == 1)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    if (sum > w)\n        return false;\n    \n    return is_balanced(q);\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "/tmp/tmpk_m0lcrp.d(41): Error: undefined identifier `is_balanced`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk_m0lcrp.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    if (q.length == 1)\n        return q[0] <= w;\n    \n    if (q.length % 2 == 1)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpu5s38mvq.d(47): unittest failure\n----------------\n??:? _d_unittestp [0x4281fd]\n??:? void tmpu5s38mvq.__unittest_L43_C1() [0x427e04]\n??:? void tmpu5s38mvq.__modtest() [0x427f7c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c25b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b0ee]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430281]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430730]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43020d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b0c5]\n??:? runModuleUnitTests [0x42c031]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4286c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    if (sum > w) return false;\n    \n    if (q.length % 2 == 0)\n    {\n        for (int i = 0; i < q.length; i += 2)\n        {\n            if (q[i] + q[i + 1] > w) return false;\n        }\n    }\n    else\n    {\n        for (int i = 0; i < q.length; i += 2)\n        {\n            if (q[i] + q[i + 1] > w) return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp7c_vmnyf.d(49): Range violation\n----------------\n??:? _d_arrayboundsp [0x4283fe]\n??:? bool tmp7c_vmnyf.will_it_fly(long[], long) [0x427ed6]\n??:? void tmp7c_vmnyf.__unittest_L54_C1() [0x427f3d]\n??:? void tmp7c_vmnyf.__modtest() [0x4280cc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b23e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303d1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430880]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43035d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b215]\n??:? runModuleUnitTests [0x42c181]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int funct",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    \n    long max_weight = w;\n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n    {\n        sum += q[i];\n        if (sum > max_weight)\n            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgzvimcop.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x42823d]\n??:? void tmpgzvimcop.__unittest_L45_C1() [0x427e90]\n??:? void tmpgzvimcop.__modtest() [0x427fc0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c29b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b12e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302c1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430770]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43024d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b105]\n??:? runModuleUnitTests [0x42c071]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428700]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    if (sum > w)\n        return false;\n    \n    if (sum == w)\n        return true;\n    \n    if (sum < w)\n        return false;\n    \n    if (q.length % 2 == 0)\n    {\n        for (int i = 0; i < q.length / 2; i++)\n        {\n            if (q[i] != q[q.length - 1 - i])\n                return false;\n        }\n        return true;\n    }\n    else\n    {\n        for (int i = 0; i < q.length / 2; i++)\n        {\n            if (q[i] != q[q.length - 1 - i])\n                return false;\n        }\n        return true;\n    }\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcmijnsy6.d(67): unittest failure\n----------------\n??:? _d_unittestp [0x4282dd]\n??:? void tmpcmijnsy6.__unittest_L63_C1() [0x427ee4]\n??:? void tmpcmijnsy6.__modtest() [0x42805c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c33b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ce]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430361]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430810]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302ed]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1a5]\n??:? runModuleUnitTests [0x42c111]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    if (q.length % 2 == 1) return q[0] + q[q.length - 1] <= w;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp0tz2pyyf.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x42829d]\n??:? void tmp0tz2pyyf.__unittest_L38_C1() [0x427ef0]\n??:? void tmp0tz2pyyf.__modtest() [0x428020]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b18e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430321]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b165]\n??:? runModuleUnitTests [0x42c0d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428760]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    return sum <= w && is_balanced(q);\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "/tmp/tmpegthdk_3.d(36): Error: undefined identifier `is_balanced`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpegthdk_3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    \n    long max_weight = w - q[0];\n    \n    for (int i = 1; i < q.length; i++)\n    {\n        if (q[i] > max_weight)\n        {\n            return false;\n        }\n        max_weight += q[i];\n    }\n    \n    return true;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmprc5gjfgl.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x428285]\n??:? void tmprc5gjfgl.__unittest_L45_C1() [0x427ed8]\n??:? void tmprc5gjfgl.__modtest() [0x428008]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2e3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b176]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430309]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307b8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430295]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b14d]\n??:? runModuleUnitTests [0x42c0b9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428748]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if(q.length == 0)\n        return true;\n    if(q.length == 1)\n        return q[0] <= w;\n    if(q.length == 2)\n        return q[0] + q[1] <= w;\n    if(q.length % 2 == 0)\n    {\n        long sum = 0;\n        for(int i = 0; i < q.length; i += 2)\n            sum += q[i];\n        return sum <= w;\n    }\n    else\n    {\n        long sum = 0;\n        for(int i = 1; i < q.length; i += 2)\n            sum += q[i];\n        return sum <= w;\n    }\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpb2x2ozxo.d(54): unittest failure\n----------------\n??:? _d_unittestp [0x4282a5]\n??:? void tmpb2x2ozxo.__unittest_L49_C1() [0x427ef4]\n??:? void tmpb2x2ozxo.__modtest() [0x428024]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c303]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b196]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430329]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b16d]\n??:? runModuleUnitTests [0x42c0d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428768]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    if (q.length == 3) return q[0] + q[1] + q[2] <= w;\n    if (q.length == 4) return q[0] + q[1] + q[2] + q[3] <= w;\n    if (q.length == 5) return q[0] + q[1] + q[2] + q[3] + q[4] <= w;\n    if (q.length == 6) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] <= w;\n    if (q.length == 7) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] <= w;\n    if (q.length == 8) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] <= w;\n    if (q.length == 9) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] <= w;\n    if (q.length == 10) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] + q[9] <= w;\n    if (q.length == 11) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] + q[9] + q[10] <= w;\n    if (q.length == 12) return q[0] + q[1] + q[2]\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292669,
      "stdout": "",
      "stderr": "/tmp/tmpae818htn.d(41): Error: found `unittest` when expecting `;` following `return` statement\n/tmp/tmpae818htn.d(52): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpae818htn.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length % 2 == 0)\n        return q[0] + q[1] + q[2] <= w;\n    return q[0] + q[1] + q[2] + q[3] <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpbvx389b5.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42838e]\n??:? bool tmpbvx389b5.will_it_fly(long[], long) [0x427e7d]\n??:? void tmpbvx389b5.__unittest_L38_C1() [0x427ecd]\n??:? void tmpbvx389b5.__modtest() [0x42805c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c33b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ce]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430361]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430810]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302ed]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1a5]\n??:? runModuleUnitTests [0x42c111]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int funct",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    if (q.length % 2 == 1) return q[q.length/2] <= w;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++) {\n        sum += q[i];\n    }\n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmppcvj_r0m.d(44): unittest failure\n----------------\n??:? _d_unittestp [0x42827d]\n??:? void tmppcvj_r0m.__unittest_L39_C1() [0x427ed0]\n??:? void tmppcvj_r0m.__modtest() [0x428000]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2db]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b16e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430301]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307b0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43028d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b145]\n??:? runModuleUnitTests [0x42c0b1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428740]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if(q.length == 0)\n        return true;\n    if(q.length == 1)\n        return q[0] <= w;\n    if(q.length == 2)\n        return q[0] + q[1] <= w;\n    if(q.length == 3)\n        return q[0] + q[1] + q[2] <= w;\n    if(q.length == 4)\n        return q[0] + q[1] + q[2] + q[3] <= w;\n    if(q.length == 5)\n        return q[0] + q[1] + q[2] + q[3] + q[4] <= w;\n    if(q.length == 6)\n        return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] <= w;\n    if(q.length == 7)\n        return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] <= w;\n    if(q.length == 8)\n        return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] <= w;\n    if(q.length == 9)\n        return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] <= w;\n    if(q.length == 10)\n        return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] + q[9] <= w;\n    if(q.length == 11)\n        return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] + q[9] + q[10] <= w;\n\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292669,
      "stdout": "",
      "stderr": "/tmp/tmpkrae4tcn.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkrae4tcn.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    return q.length == 0 || (q.length == 1 && q[0] <= w) || (q.length > 1 && q.length % 2 == 1 && sum(q) <= w);\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "/tmp/tmpwnkkt884.d(28): Error: undefined identifier `sum`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwnkkt884.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    if (q.length % 2 == 0) return false;\n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n    {\n        sum += q[i];\n    }\n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_0rlv1jh.d(44): unittest failure\n----------------\n??:? _d_unittestp [0x428245]\n??:? void tmp_0rlv1jh.__unittest_L39_C1() [0x427e98]\n??:? void tmp_0rlv1jh.__modtest() [0x427fc8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b136]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430778]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430255]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b10d]\n??:? runModuleUnitTests [0x42c079]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428708]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    if (q.length % 2 == 0) return false;\n    long sum = 0;\n    for (int i = 0; i < q.length; i++) {\n        sum += q[i];\n    }\n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpbqh3suzq.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x428245]\n??:? void tmpbqh3suzq.__unittest_L38_C1() [0x427e98]\n??:? void tmpbqh3suzq.__modtest() [0x427fc8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b136]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430778]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430255]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b10d]\n??:? runModuleUnitTests [0x42c079]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428708]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    if (sum > w)\n        return false;\n    \n    if (sum == w)\n        return true;\n    \n    if (q.length % 2 == 1)\n        return false;\n    \n    long max = q.length / 2;\n    for (int i = 0; i < max; i++)\n        if (q[i] != q[q.length - i - 1])\n            return false;\n    \n    return true;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_q6amvpu.d(55): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmp_q6amvpu.__unittest_L51_C1() [0x427e64]\n??:? void tmp_q6amvpu.__modtest() [0x427fdc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length % 2 == 0)\n        return false;\n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpi0_oif_y.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428245]\n??:? void tmpi0_oif_y.__unittest_L41_C1() [0x427e98]\n??:? void tmpi0_oif_y.__modtest() [0x427fc8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b136]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430778]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430255]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b10d]\n??:? runModuleUnitTests [0x42c079]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428708]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length % 2 == 0)\n        return false;\n    long max = 0;\n    for (int i = 0; i < q.length; i++)\n        max = std.math.max(max, q[i]);\n    return max <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "/tmp/tmpkvyqjis0.d(38): Error: undefined identifier `max` in module `std.math`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkvyqjis0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length % 2 == 0)\n        return q[0] + q[1] + q[q.length - 1] <= w;\n    else\n        return q[0] + q[1] + q[q.length - 2] <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpvx1rd4mf.d(44): unittest failure\n----------------\n??:? _d_unittestp [0x4282cd]\n??:? void tmpvx1rd4mf.__unittest_L39_C1() [0x427f20]\n??:? void tmpvx1rd4mf.__modtest() [0x428050]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c32b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1be]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430351]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430800]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b195]\n??:? runModuleUnitTests [0x42c101]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428790]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    if (q.length == 1)\n        return q[0] <= w;\n    \n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    \n    long max_weight = w - (q.length - 1) * q[0];\n    \n    if (q[0] > max_weight)\n        return false;\n    \n    for (int i = 1; i < q.length; i++)\n    {\n        if (q[i] > max_weight)\n            return false;\n        \n        if (q[i] + q[i - 1] > max_weight)\n            return false;\n    }\n    \n    return true;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp2h_5f3g3.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmp2h_5f3g3.__unittest_L53_C1() [0x427f04]\n??:? void tmp2h_5f3g3.__modtest() [0x42807c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c35b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ee]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430381]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430830]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43030d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c5]\n??:? runModuleUnitTests [0x42c131]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if(q.length == 0)\n        return true;\n    if(q.length == 1)\n        return q[0] <= w;\n    if(q.length == 2)\n        return q[0] + q[1] <= w;\n    if(q.length % 2 == 0)\n    {\n        long sum = 0;\n        for(int i = 0; i < q.length; i += 2)\n            sum += q[i];\n        return sum <= w;\n    }\n    else\n    {\n        long sum = 0;\n        for(int i = 1; i < q.length; i += 2)\n            sum += q[i];\n        return sum <= w;\n    }\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpb2x2ozxo.d(54): unittest failure\n----------------\n??:? _d_unittestp [0x4282a5]\n??:? void tmpb2x2ozxo.__unittest_L49_C1() [0x427ef4]\n??:? void tmpb2x2ozxo.__modtest() [0x428024]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c303]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b196]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430329]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b16d]\n??:? runModuleUnitTests [0x42c0d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428768]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length == 3)\n        return q[0] + q[1] + q[2] <= w;\n    if (q.length % 2 == 0)\n        return false;\n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpdye4qn9e.d(48): unittest failure\n----------------\n??:? _d_unittestp [0x4282bd]\n??:? void tmpdye4qn9e.__unittest_L43_C1() [0x427f0c]\n??:? void tmpdye4qn9e.__modtest() [0x42803c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c31b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430341]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302cd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b185]\n??:? runModuleUnitTests [0x42c0f1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428780]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length % 2 == 0)\n    {\n        long sum = 0;\n        for (int i = 0; i < q.length; i += 2)\n            sum += q[i];\n        return sum <= w;\n    }\n    else\n    {\n        long sum = 0;\n        for (int i = 1; i < q.length; i += 2)\n            sum += q[i];\n        return sum <= w;\n    }\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpo7bsxjm8.d(54): unittest failure\n----------------\n??:? _d_unittestp [0x4282a5]\n??:? void tmpo7bsxjm8.__unittest_L49_C1() [0x427ef4]\n??:? void tmpo7bsxjm8.__modtest() [0x428024]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c303]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b196]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430329]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b16d]\n??:? runModuleUnitTests [0x42c0d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428768]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length == 3)\n        return q[0] + q[1] + q[2] <= w;\n    if (q.length == 4)\n        return q[0] + q[1] + q[2] + q[3] <= w;\n    if (q.length == 5)\n        return q[0] + q[1] + q[2] + q[3] + q[4] <= w;\n    if (q.length == 6)\n        return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] <= w;\n    if (q.length == 7)\n        return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] <= w;\n    if (q.length == 8)\n        return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] <= w;\n    if (q.length == 9)\n        return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] <= w;\n    if (q.length == 10)\n        return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] + q[9] <= w;\n    if (q.length == 11)\n        return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] + q[9] + q[10] <= w;\n\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292669,
      "stdout": "",
      "stderr": "/tmp/tmptypmfhfr.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptypmfhfr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    \n    long max_weight = w;\n    for (int i = 0; i < q.length; i++)\n        max_weight = std.math.max(max_weight, q[i]);\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    return sum <= max_weight;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "/tmp/tmpnfoza4zy.d(34): Error: undefined identifier `max` in module `std.math`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnfoza4zy.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length % 2 == 0)\n    {\n        long sum = 0;\n        for (int i = 0; i < q.length; i += 2)\n            sum += q[i];\n        return sum <= w;\n    }\n    else\n    {\n        long sum = 0;\n        for (int i = 1; i < q.length; i += 2)\n            sum += q[i];\n        return sum <= w;\n    }\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpo7bsxjm8.d(54): unittest failure\n----------------\n??:? _d_unittestp [0x4282a5]\n??:? void tmpo7bsxjm8.__unittest_L49_C1() [0x427ef4]\n??:? void tmpo7bsxjm8.__modtest() [0x428024]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c303]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b196]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430329]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b16d]\n??:? runModuleUnitTests [0x42c0d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428768]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return false;\n    \n    if (q.length == 1)\n        return q[0] <= w;\n    \n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpxxloqf3c.d(48): unittest failure\n----------------\n??:? _d_unittestp [0x428235]\n??:? void tmpxxloqf3c.__unittest_L43_C1() [0x427e84]\n??:? void tmpxxloqf3c.__modtest() [0x427fb4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c293]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b126]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430768]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430245]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b0fd]\n??:? runModuleUnitTests [0x42c069]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4286f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    if (q.length % 2 == 0) return false;\n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp7ghc4tqj.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x428245]\n??:? void tmp7ghc4tqj.__unittest_L37_C1() [0x427e98]\n??:? void tmp7ghc4tqj.__modtest() [0x427fc8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b136]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430778]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430255]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b10d]\n??:? runModuleUnitTests [0x42c079]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428708]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    if (sum > w)\n        return false;\n    \n    if (is_balanced(q))\n        return true;\n    \n    return false;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "/tmp/tmp1ji1ejbg.d(40): Error: undefined identifier `is_balanced`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1ji1ejbg.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    if (sum <= w) return true;\n    \n    return false;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpsm0s1sw0.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x42823d]\n??:? void tmpsm0s1sw0.__unittest_L40_C1() [0x427e90]\n??:? void tmpsm0s1sw0.__modtest() [0x427fc0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c29b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b12e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302c1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430770]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43024d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b105]\n??:? runModuleUnitTests [0x42c071]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428700]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if(q.length == 0)\n        return true;\n    if(q.length == 1)\n        return q[0] <= w;\n    if(q.length == 2)\n        return q[0] + q[1] <= w;\n    if(q.length % 2 == 0)\n    {\n        long sum = 0;\n        for(int i = 0; i < q.length; i += 2)\n            sum += q[i];\n        return sum <= w;\n    }\n    else\n    {\n        long sum = 0;\n        for(int i = 1; i < q.length; i += 2)\n            sum += q[i];\n        return sum <= w;\n    }\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpb2x2ozxo.d(54): unittest failure\n----------------\n??:? _d_unittestp [0x4282a5]\n??:? void tmpb2x2ozxo.__unittest_L49_C1() [0x427ef4]\n??:? void tmpb2x2ozxo.__modtest() [0x428024]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c303]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b196]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430329]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b16d]\n??:? runModuleUnitTests [0x42c0d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428768]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length % 2 == 0)\n    {\n        long sum = 0;\n        for (int i = 0; i < q.length; i += 2)\n            sum += q[i];\n        return sum <= w;\n    }\n    else\n    {\n        long sum = 0;\n        for (int i = 1; i < q.length; i += 2)\n            sum += q[i];\n        return sum <= w;\n    }\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpo7bsxjm8.d(54): unittest failure\n----------------\n??:? _d_unittestp [0x4282a5]\n??:? void tmpo7bsxjm8.__unittest_L49_C1() [0x427ef4]\n??:? void tmpo7bsxjm8.__modtest() [0x428024]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c303]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b196]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430329]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b16d]\n??:? runModuleUnitTests [0x42c0d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428768]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    if (q.length % 2 == 1)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    if (sum > w)\n        return false;\n    \n    return is_balanced(q);\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "/tmp/tmpk_m0lcrp.d(41): Error: undefined identifier `is_balanced`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk_m0lcrp.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    return sum <= w && is_balanced(q);\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "/tmp/tmpwe49sdk6.d(37): Error: undefined identifier `is_balanced`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwe49sdk6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    if (q.length % 2 == 0) return false;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpmrv180mh.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x428245]\n??:? void tmpmrv180mh.__unittest_L38_C1() [0x427e98]\n??:? void tmpmrv180mh.__modtest() [0x427fc8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b136]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430778]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430255]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b10d]\n??:? runModuleUnitTests [0x42c079]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428708]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    if (q.length == 1)\n        return q[0] <= w;\n    \n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    \n    if (q.length == 3)\n        return q[0] + q[1] + q[2] <= w;\n    \n    if (q.length % 2 == 0)\n    {\n        long sum = 0;\n        for (int i = 0; i < q.length; i += 2)\n            sum += q[i];\n        return sum <= w;\n    }\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpy6nyn9bw.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x428315]\n??:? void tmpy6nyn9bw.__unittest_L53_C1() [0x427f64]\n??:? void tmpy6nyn9bw.__modtest() [0x428094]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c373]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b206]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430399]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430848]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430325]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1dd]\n??:? runModuleUnitTests [0x42c149]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287d8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    if (sum > w)\n        return false;\n    \n    if (sum == w)\n        return true;\n    \n    if (sum < w)\n        return false;\n    \n    if (q.length % 2 == 0)\n        return false;\n    \n    for (int i = 0; i < q.length; i++)\n        if (q[i] != q[q.length - 1 - i])\n            return false;\n    \n    return true;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpr96bfh9w.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpr96bfh9w.__unittest_L53_C1() [0x427e64]\n??:? void tmpr96bfh9w.__modtest() [0x427fdc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length % 2 == 0)\n    {\n        long sum = 0;\n        for (int i = 0; i < q.length; i += 2)\n        {\n            sum += q[i];\n        }\n        return sum <= w;\n    }\n    else\n    {\n        long sum = 0;\n        for (int i = 1; i < q.length; i += 2)\n        {\n            sum += q[i];\n        }\n        return sum <= w;\n    }\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmppgr9hku_.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x4282a5]\n??:? void tmppgr9hku_.__unittest_L53_C1() [0x427ef4]\n??:? void tmppgr9hku_.__modtest() [0x428024]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c303]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b196]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430329]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b16d]\n??:? runModuleUnitTests [0x42c0d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428768]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if(q.length == 0)\n        return true;\n    if(q.length == 1)\n        return q[0] <= w;\n    if(q.length == 2)\n        return q[0] + q[1] <= w;\n    if(q.length % 2 == 0)\n        return q[0] + q[1] + q[q.length - 1] <= w;\n    return q[0] + q[1] + q[q.length - 1] + q[q.length - 2] <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmphkcdk3ez.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x4282f5]\n??:? void tmphkcdk3ez.__unittest_L38_C1() [0x427efc]\n??:? void tmphkcdk3ez.__modtest() [0x428074]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c353]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1e6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430379]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430828]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430305]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1bd]\n??:? runModuleUnitTests [0x42c129]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287b8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length == 3)\n        return q[0] + q[1] + q[2] <= w;\n    if (q.length % 2 == 0)\n    {\n        long sum = 0;\n        for (int i = 0; i < q.length; i += 2)\n            sum += q[i];\n        return sum <= w;\n    }\n    else\n    {\n        long sum = 0;\n        for (int i = 0; i < q.length; i += 2)\n            sum += q[i];\n        return sum <= w;\n    }\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpxtb2jhof.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x428315]\n??:? void tmpxtb2jhof.__unittest_L51_C1() [0x427f68]\n??:? void tmpxtb2jhof.__modtest() [0x428098]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c373]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b206]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430399]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430848]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430325]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1dd]\n??:? runModuleUnitTests [0x42c149]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287d8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length == 3)\n        return q[0] + q[1] + q[2] <= w;\n    if (q.length % 2 == 0)\n    {\n        long sum = 0;\n        for (int i = 0; i < q.length; i++)\n            sum += q[i];\n        return sum <= w;\n    }\n    else\n    {\n        long sum = 0;\n        for (int i = 0; i < q.length; i++)\n            sum += q[i];\n        return sum <= w;\n    }\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpf7d6rncs.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x42830d]\n??:? void tmpf7d6rncs.__unittest_L51_C1() [0x427f5c]\n??:? void tmpf7d6rncs.__modtest() [0x42808c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c36b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1fe]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430391]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430840]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43031d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1d5]\n??:? runModuleUnitTests [0x42c141]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287d0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    if (sum <= w) return true;\n    \n    return false;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpsm0s1sw0.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x42823d]\n??:? void tmpsm0s1sw0.__unittest_L40_C1() [0x427e90]\n??:? void tmpsm0s1sw0.__modtest() [0x427fc0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c29b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b12e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302c1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430770]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43024d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b105]\n??:? runModuleUnitTests [0x42c071]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428700]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    if (q.length == 1)\n        return q[0] <= w;\n    \n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    \n    if (q.length % 2 == 1)\n        return q[q.length / 2] <= w;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp2vaqa20x.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x42827d]\n??:? void tmp2vaqa20x.__unittest_L46_C1() [0x427ed0]\n??:? void tmp2vaqa20x.__modtest() [0x428000]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2db]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b16e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430301]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307b0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43028d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b145]\n??:? runModuleUnitTests [0x42c0b1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428740]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    return sum <= w && is_balanced(q);\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "/tmp/tmpegthdk_3.d(36): Error: undefined identifier `is_balanced`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpegthdk_3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    if (q.length == 3) return q[0] + q[1] + q[2] <= w;\n    if (q.length == 4) return q[0] + q[1] + q[2] + q[3] <= w;\n    if (q.length == 5) return q[0] + q[1] + q[2] + q[3] + q[4] <= w;\n    if (q.length == 6) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] <= w;\n    if (q.length == 7) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] <= w;\n    if (q.length == 8) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] <= w;\n    if (q.length == 9) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] <= w;\n    if (q.length == 10) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] + q[9] <= w;\n    if (q.length == 11) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] + q[9] + q[10] <= w;\n    if (q.length == 12) return q[0] + q[1] + q[2]\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292669,
      "stdout": "",
      "stderr": "/tmp/tmpae818htn.d(41): Error: found `unittest` when expecting `;` following `return` statement\n/tmp/tmpae818htn.d(52): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpae818htn.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    if (q.length == 1)\n        return q[0] <= w;\n    \n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    \n    long max_weight = (long) math.pow(10, q.length);\n    \n    if (q[0] + q[q.length - 1] > max_weight)\n        return false;\n    \n    for (int i = 1; i < q.length - 1; i++)\n    {\n        if (q[i] + q[q.length - i - 1] > max_weight)\n            return false;\n    }\n    \n    return true;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "/tmp/tmps5xu7hfj.d(37): Error: C style cast illegal, use `cast(long)math.pow(10, q.length)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps5xu7hfj.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    if (sum > w)\n        return false;\n    \n    if (q.length % 2 == 0)\n    {\n        for (int i = 0; i < q.length; i += 2)\n        {\n            if (q[i] != q[i + 1])\n                return false;\n        }\n        return true;\n    }\n    else\n    {\n        for (int i = 0; i < q.length; i++)\n        {\n            if (q[i] != q[q.length - 1 - i])\n                return false;\n        }\n        return true;\n    }\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    if (sum > w)\n        return false;\n    \n    return is_balanced(q);\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "/tmp/tmpe6f9ub2e.d(38): Error: undefined identifier `is_balanced`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe6f9ub2e.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    if (sum > w)\n        return false;\n    \n    if (sum == w)\n        return true;\n    \n    if (q.length % 2 == 1)\n        return false;\n    \n    long max_weight = q.length * (q.length - 1) / 2;\n    \n    if (sum < max_weight)\n        return false;\n    \n    long sum_left = 0;\n    long sum_right = 0;\n    for (int i = 0; i < q.length; i += 2)\n    {\n        sum_left += q[i];\n        sum_right += q[i + 1];\n    }\n    \n    if (sum_left > w || sum_right > w)\n        return false;\n    \n    return true;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpneyd2pdr.d(66): unittest failure\n----------------\n??:? _d_unittestp [0x428295]\n??:? void tmpneyd2pdr.__unittest_L62_C1() [0x427e9c]\n??:? void tmpneyd2pdr.__modtest() [0x428014]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2f3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b186]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430319]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307c8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302a5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b15d]\n??:? runModuleUnitTests [0x42c0c9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428758]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    if (q.length % 2 == 0) return q[0] + q[1] + q[q.length - 1] <= w;\n    return q[0] + q[1] + q[q.length - 1] + q[q.length - 2] <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpa1kcyxi5.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x4282f5]\n??:? void tmpa1kcyxi5.__unittest_L34_C1() [0x427efc]\n??:? void tmpa1kcyxi5.__modtest() [0x428074]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c353]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1e6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430379]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430828]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430305]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1bd]\n??:? runModuleUnitTests [0x42c129]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287b8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    if (sum > w) return false;\n    \n    return is_balanced(q);\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "/tmp/tmp9fbr2imb.d(36): Error: undefined identifier `is_balanced`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9fbr2imb.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    if (q.length % 2 == 0) return false;\n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp7ghc4tqj.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x428245]\n??:? void tmp7ghc4tqj.__unittest_L37_C1() [0x427e98]\n??:? void tmp7ghc4tqj.__modtest() [0x427fc8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b136]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430778]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430255]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b10d]\n??:? runModuleUnitTests [0x42c079]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428708]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    return sum <= w && is_balanced(q);\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "/tmp/tmpegthdk_3.d(36): Error: undefined identifier `is_balanced`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpegthdk_3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    if (q.length == 1)\n        return q[0] <= w;\n    \n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    \n    long max_weight = (long) math.pow(10, q.length);\n    \n    if (q[0] + q[q.length - 1] > max_weight)\n        return false;\n    \n    for (int i = 1; i < q.length - 1; i++)\n    {\n        if (q[i] + q[q.length - 1 - i] > max_weight)\n            return false;\n    }\n    \n    return true;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "/tmp/tmp14i54825.d(37): Error: C style cast illegal, use `cast(long)math.pow(10, q.length)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp14i54825.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    return sum <= w && is_balanced(q);\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "/tmp/tmpegthdk_3.d(36): Error: undefined identifier `is_balanced`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpegthdk_3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length % 2 == 1)\n        return false;\n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpzvadg642.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x4281fd]\n??:? void tmpzvadg642.__unittest_L39_C1() [0x427e04]\n??:? void tmpzvadg642.__modtest() [0x427f7c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c25b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b0ee]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430281]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430730]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43020d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b0c5]\n??:? runModuleUnitTests [0x42c031]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4286c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if(q.length == 0)\n        return true;\n    \n    if(q.length == 1)\n        return q[0] <= w;\n    \n    if(q.length == 2)\n        return q[0] + q[1] <= w;\n    \n    if(q.length % 2 == 0)\n    {\n        long sum = 0;\n        for(int i = 0; i < q.length; i += 2)\n        {\n            sum += q[i];\n        }\n        return sum <= w;\n    }\n    else\n    {\n        long sum = 0;\n        for(int i = 0; i < q.length; i += 2)\n        {\n            sum += q[i];\n        }\n        return sum + q[q.length - 1] <= w;\n    }\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgn8ei902.d(61): unittest failure\n----------------\n??:? _d_unittestp [0x4282dd]\n??:? void tmpgn8ei902.__unittest_L56_C1() [0x427f2c]\n??:? void tmpgn8ei902.__modtest() [0x42805c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c33b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ce]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430361]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430810]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302ed]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1a5]\n??:? runModuleUnitTests [0x42c111]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    if (q.length == 1)\n        return q[0] <= w;\n    \n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    \n    long max_weight = w - (q.length - 1) * q[0];\n    \n    for (int i = 0; i < q.length; i++)\n        if (q[i] > max_weight)\n            return false;\n    \n    return true;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpr807kwe8.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x428265]\n??:? void tmpr807kwe8.__unittest_L45_C1() [0x427eb8]\n??:? void tmpr807kwe8.__modtest() [0x427fe8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2c3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b156]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430798]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430275]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b12d]\n??:? runModuleUnitTests [0x42c099]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428728]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    if (q.length % 2 == 1) return q[0] + q[q.length-1] <= w;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++) {\n        sum += q[i];\n    }\n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp2ub42vfd.d(44): unittest failure\n----------------\n??:? _d_unittestp [0x42829d]\n??:? void tmp2ub42vfd.__unittest_L39_C1() [0x427ef0]\n??:? void tmp2ub42vfd.__modtest() [0x428020]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b18e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430321]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b165]\n??:? runModuleUnitTests [0x42c0d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428760]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    if (q.length % 2 == 0) return false;\n    long sum = 0;\n    for (int i = 0; i < q.length; i++) {\n        sum += q[i];\n    }\n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpbqh3suzq.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x428245]\n??:? void tmpbqh3suzq.__unittest_L38_C1() [0x427e98]\n??:? void tmpbqh3suzq.__modtest() [0x427fc8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b136]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430778]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430255]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b10d]\n??:? runModuleUnitTests [0x42c079]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428708]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    if (q.length == 3) return q[0] + q[1] + q[2] <= w;\n    \n    long max_weight = 0;\n    for (int i = 0; i < q.length; i++)\n        max_weight += q[i];\n    \n    if (max_weight > w) return false;\n    \n    for (int i = 0; i < q.length; i++)\n        if (q[i] != q[q.length - 1 - i]) return false;\n    \n    return true;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpvdav70dy.d(49): unittest failure\n----------------\n??:? _d_unittestp [0x428325]\n??:? void tmpvdav70dy.__unittest_L44_C1() [0x427f74]\n??:? void tmpvdav70dy.__modtest() [0x4280a4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c383]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b216]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430858]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430335]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ed]\n??:? runModuleUnitTests [0x42c159]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if(q.length == 0)\n        return true;\n    if(q.length == 1)\n        return q[0] <= w;\n    long sum = 0;\n    for(int i = 0; i < q.length; i++)\n        sum += q[i];\n    return sum <= w && is_balanced(q);\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "/tmp/tmp2cr0tcb6.d(35): Error: undefined identifier `is_balanced`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2cr0tcb6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    if (sum > w)\n        return false;\n    \n    if (sum == w)\n        return true;\n    \n    if (q.length % 2 == 0)\n    {\n        for (int i = 0; i < q.length / 2; i++)\n        {\n            if (q[i] != q[q.length - i - 1])\n                return false;\n        }\n        return true;\n    }\n    else\n    {\n        for (int i = 0; i < q.length / 2; i++)\n        {\n            if (q[i] != q[q.length - i - 1])\n                return false;\n        }\n        return true;\n    }\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp547fy6lo.d(68): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmp547fy6lo.__unittest_L60_C1() [0x427ff1]\n??:? void tmp547fy6lo.__modtest() [0x428044]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    return sum <= w && is_balanced(q);\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "/tmp/tmpegthdk_3.d(36): Error: undefined identifier `is_balanced`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpegthdk_3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    if (sum > w)\n        return false;\n    \n    return is_balanced(q);\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "/tmp/tmpe6f9ub2e.d(38): Error: undefined identifier `is_balanced`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe6f9ub2e.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    \n    long max = 0;\n    for (int i = 0; i < q.length; i++)\n        max = std.math.max(max, q[i]);\n    \n    if (max > w) return false;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "/tmp/tmp8996iyme.d(34): Error: undefined identifier `max` in module `std.math`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8996iyme.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length % 2 == 0)\n    {\n        long sum = 0;\n        for (int i = 0; i < q.length; i += 2)\n            sum += q[i];\n        return sum <= w;\n    }\n    else\n    {\n        long sum = 0;\n        for (int i = 1; i < q.length; i += 2)\n            sum += q[i];\n        return sum <= w;\n    }\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpo7bsxjm8.d(54): unittest failure\n----------------\n??:? _d_unittestp [0x4282a5]\n??:? void tmpo7bsxjm8.__unittest_L49_C1() [0x427ef4]\n??:? void tmpo7bsxjm8.__modtest() [0x428024]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c303]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b196]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430329]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b16d]\n??:? runModuleUnitTests [0x42c0d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428768]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return false;\n    long sum = 0;\n    for (int i = 0; i < q.length; i++) {\n        sum += q[i];\n    }\n    return sum <= w && is_balanced(q);\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292669,
      "stdout": "",
      "stderr": "/tmp/tmp9k6asus0.d(33): Error: undefined identifier `is_balanced`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9k6asus0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    return sum <= w && is_balanced(q);\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292669,
      "stdout": "",
      "stderr": "/tmp/tmppyw0b7_5.d(35): Error: undefined identifier `is_balanced`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppyw0b7_5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    if (q.length == 1)\n        return q[0] <= w;\n    \n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    if (sum > w)\n        return false;\n    \n    return is_balanced(q);\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "/tmp/tmp9h5n5aju.d(44): Error: undefined identifier `is_balanced`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9h5n5aju.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    \n    long max_weight = w - q[0];\n    for (int i = 1; i < q.length; i++)\n    {\n        if (q[i] > max_weight) return false;\n        max_weight += q[i];\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpxol4bi1w.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x428285]\n??:? void tmpxol4bi1w.__unittest_L40_C1() [0x427ed8]\n??:? void tmpxol4bi1w.__modtest() [0x428008]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2e3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b176]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430309]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307b8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430295]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b14d]\n??:? runModuleUnitTests [0x42c0b9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428748]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    if (q.length == 3) return q[0] + q[1] + q[2] <= w;\n    if (q.length == 4) return q[0] + q[1] + q[2] + q[3] <= w;\n    if (q.length == 5) return q[0] + q[1] + q[2] + q[3] + q[4] <= w;\n    if (q.length == 6) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] <= w;\n    if (q.length == 7) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] <= w;\n    if (q.length == 8) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] <= w;\n    if (q.length == 9) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] <= w;\n    if (q.length == 10) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] + q[9] <= w;\n    if (q.length == 11) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] + q[9] + q[10] <= w;\n    if (q.length == 12) return q[0] + q[1] + q[2]\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292669,
      "stdout": "",
      "stderr": "/tmp/tmpae818htn.d(41): Error: found `unittest` when expecting `;` following `return` statement\n/tmp/tmpae818htn.d(52): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpae818htn.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    if (q.length % 2 == 1) return q[0] + q[q.length - 1] <= w;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp0tz2pyyf.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x42829d]\n??:? void tmp0tz2pyyf.__unittest_L38_C1() [0x427ef0]\n??:? void tmp0tz2pyyf.__modtest() [0x428020]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b18e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430321]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b165]\n??:? runModuleUnitTests [0x42c0d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428760]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    if (q.length == 3) return q[0] + q[1] + q[2] <= w;\n    if (q.length == 4) return q[0] + q[1] + q[2] + q[3] <= w;\n    if (q.length == 5) return q[0] + q[1] + q[2] + q[3] + q[4] <= w;\n    if (q.length == 6) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] <= w;\n    if (q.length == 7) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] <= w;\n    if (q.length == 8) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] <= w;\n    if (q.length == 9) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] <= w;\n    if (q.length == 10) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] + q[9] <= w;\n    if (q.length == 11) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] + q[9] + q[10] <= w;\n    if (q.length == 12) return q[0] + q[1] + q[2]\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292669,
      "stdout": "",
      "stderr": "/tmp/tmpae818htn.d(41): Error: found `unittest` when expecting `;` following `return` statement\n/tmp/tmpae818htn.d(52): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpae818htn.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    if (q.length % 2 == 0) return false;\n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp7ghc4tqj.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x428245]\n??:? void tmp7ghc4tqj.__unittest_L37_C1() [0x427e98]\n??:? void tmp7ghc4tqj.__modtest() [0x427fc8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b136]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430778]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430255]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b10d]\n??:? runModuleUnitTests [0x42c079]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428708]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    if (q.length % 2 == 0) return false;\n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp7ghc4tqj.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x428245]\n??:? void tmp7ghc4tqj.__unittest_L37_C1() [0x427e98]\n??:? void tmp7ghc4tqj.__modtest() [0x427fc8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b136]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430778]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430255]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b10d]\n??:? runModuleUnitTests [0x42c079]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428708]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    if (q.length % 2 == 1) return q[0] + q[q.length - 1] <= w;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgvoe4kj3.d(44): unittest failure\n----------------\n??:? _d_unittestp [0x42829d]\n??:? void tmpgvoe4kj3.__unittest_L39_C1() [0x427ef0]\n??:? void tmpgvoe4kj3.__modtest() [0x428020]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b18e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430321]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b165]\n??:? runModuleUnitTests [0x42c0d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428760]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if(q.length == 0)\n        return true;\n    \n    long sum = 0;\n    for(int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    if(sum > w)\n        return false;\n    \n    if(q.length == 1)\n        return true;\n    \n    if(q.length % 2 == 1)\n        return false;\n    \n    for(int i = 0; i < q.length; i++)\n        if(q[i] != q[q.length - 1 - i])\n            return false;\n    \n    return true;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpy21k5nl2.d(54): unittest failure\n----------------\n??:? _d_unittestp [0x42824d]\n??:? void tmpy21k5nl2.__unittest_L50_C1() [0x427e58]\n??:? void tmpy21k5nl2.__modtest() [0x427fd0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b13e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302d1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430780]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43025d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b115]\n??:? runModuleUnitTests [0x42c081]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428710]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    if (q.length == 1)\n        return q[0] <= w;\n    \n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    \n    if (q.length % 2 == 1)\n        return q[0] + q[q.length - 1] <= w;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp0yje27si.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x42829d]\n??:? void tmp0yje27si.__unittest_L46_C1() [0x427ef0]\n??:? void tmp0yje27si.__modtest() [0x428020]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b18e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430321]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b165]\n??:? runModuleUnitTests [0x42c0d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428760]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if(q.length == 0) return true;\n    if(q.length == 1) return q[0] <= w;\n    if(q.length == 2) return q[0] + q[1] <= w;\n    \n    long max_weight = w;\n    for(int i = 0; i < q.length; i++)\n        max_weight = std.math.max(max_weight, q[i]);\n    \n    if(q.length % 2 == 1)\n    {\n        long sum = 0;\n        for(int i = 0; i < q.length; i++)\n            sum += q[i];\n        return sum <= max_weight;\n    }\n    else\n    {\n        long sum = 0;\n        for(int i = 0; i < q.length; i += 2)\n            sum += q[i] + q[i + 1];\n        return sum <= max_weight;\n    }\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "/tmp/tmpkffyt89y.d(34): Error: undefined identifier `max` in module `std.math`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkffyt89y.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length % 2 == 0)\n        return q[0] + q[1] + q[q.length - 1] <= w;\n    return q[0] + q[1] + q[q.length - 1] + q[q.length - 2] <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpo3u8bb5m.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x4282f5]\n??:? void tmpo3u8bb5m.__unittest_L38_C1() [0x427efc]\n??:? void tmpo3u8bb5m.__modtest() [0x428074]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c353]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1e6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430379]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430828]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430305]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1bd]\n??:? runModuleUnitTests [0x42c129]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287b8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    if (sum > w)\n        return false;\n    \n    long max = 0;\n    for (int i = 0; i < q.length; i++)\n        max = std.math.max(max, q[i]);\n    \n    if (sum == max)\n        return true;\n    \n    return false;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "/tmp/tmpbghnho7m.d(43): Error: undefined identifier `max` in module `std.math`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbghnho7m.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    \n    long max_weight = w - q[0];\n    for (int i = 1; i < q.length; i++)\n        max_weight = std.math.max(max_weight, w - q[i]);\n    \n    if (q.length % 2 == 1)\n        return q[q.length / 2] <= max_weight;\n    else\n        return q[q.length / 2] + q[q.length / 2 - 1] <= max_weight;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "/tmp/tmps47opf27.d(34): Error: undefined identifier `max` in module `std.math`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps47opf27.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if(q.length == 0)\n        return true;\n    \n    long sum = 0;\n    for(int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    if(sum > w)\n        return false;\n    \n    if(q.length % 2 == 0)\n    {\n        for(int i = 0; i < q.length; i++)\n        {\n            if(q[i] != q[q.length - 1 - i])\n                return false;\n        }\n        return true;\n    }\n    else\n    {\n        for(int i = 0; i < q.length; i++)\n        {\n            if(q[i] != q[(q.length - 1) - i])\n                return false;\n        }\n        return true;\n    }\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    return (q.length == 0 || q.length == 1) || (q.length % 2 == 0 && sum(q) <= w);\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "/tmp/tmp7244k2g7.d(28): Error: undefined identifier `sum`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7244k2g7.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length == 3)\n        return q[0] + q[1] + q[2] <= w;\n    if (q.length == 4)\n        return q[0] + q[1] + q[2] + q[3] <= w;\n    if (q.length == 5)\n        return q[0] + q[1] + q[2] + q[3] + q[4] <= w;\n    if (q.length == 6)\n        return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] <= w;\n    if (q.length == 7)\n        return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] <= w;\n    if (q.length == 8)\n        return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] <= w;\n    if (q.length == 9)\n        return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] <= w;\n    if (q.length == 10)\n        return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] + q[9] <= w;\n    if (q.length == 11)\n        return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] + q[9] + q[10] <= w;\n\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292669,
      "stdout": "",
      "stderr": "/tmp/tmptypmfhfr.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptypmfhfr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++) {\n        sum += q[i];\n    }\n    \n    if (sum > w) return false;\n    \n    if (q.length % 2 == 1) {\n        return q[q.length/2] <= w;\n    }\n    \n    long max_weight = q.length * (q.length - 1) / 2;\n    return sum <= max_weight;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp8r76krzr.d(53): unittest failure\n----------------\n??:? _d_unittestp [0x42824d]\n??:? void tmp8r76krzr.__unittest_L45_C1() [0x427f79]\n??:? void tmp8r76krzr.__modtest() [0x427fcc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b13e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302d1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430780]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43025d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b115]\n??:? runModuleUnitTests [0x42c081]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428710]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    return sum <= w && is_balanced(q);\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "/tmp/tmpegthdk_3.d(36): Error: undefined identifier `is_balanced`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpegthdk_3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    if (sum > w) return false;\n    \n    if (q.length % 2 == 0)\n    {\n        long max = q[0];\n        for (int i = 1; i < q.length; i += 2)\n            max = std.math.max(max, q[i]);\n        \n        if (sum + max <= w) return true;\n    }\n    \n    return false;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "/tmp/tmpq87_zbjd.d(42): Error: undefined identifier `max` in module `std.math`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq87_zbjd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length % 2 == 1)\n        return q[q.length / 2] + q[q.length / 2 - 1] <= w;\n    else\n        return q[q.length / 2] + q[q.length / 2] <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpaumlldcy.d(44): unittest failure\n----------------\n??:? _d_unittestp [0x4282a5]\n??:? void tmpaumlldcy.__unittest_L39_C1() [0x427ef8]\n??:? void tmpaumlldcy.__modtest() [0x428028]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c303]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b196]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430329]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b16d]\n??:? runModuleUnitTests [0x42c0d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428768]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length % 2 == 0)\n        return q[0] + q[1] + q[q.length - 2] + q[q.length - 1] <= w;\n    return q[0] + q[1] + q[q.length - 1] <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpc2t1_dkh.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x4282f5]\n??:? void tmpc2t1_dkh.__unittest_L38_C1() [0x427f44]\n??:? void tmpc2t1_dkh.__modtest() [0x428074]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c353]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1e6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430379]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430828]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430305]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1bd]\n??:? runModuleUnitTests [0x42c129]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287b8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if(q.length == 0)\n        return true;\n    if(q.length == 1)\n        return q[0] <= w;\n    if(q.length == 2)\n        return q[0] + q[1] <= w;\n    if(q.length % 2 == 0)\n        return q[0] + q[1] + q[q.length - 1] + q[q.length - 2] <= w;\n    else\n        return q[0] + q[1] + q[q.length - 1] <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpov5eziqv.d(44): unittest failure\n----------------\n??:? _d_unittestp [0x4282f5]\n??:? void tmpov5eziqv.__unittest_L39_C1() [0x427f44]\n??:? void tmpov5eziqv.__modtest() [0x428074]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c353]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1e6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430379]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430828]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430305]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1bd]\n??:? runModuleUnitTests [0x42c129]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287b8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length % 2 == 0)\n    {\n        long sum = 0;\n        for (int i = 0; i < q.length; i += 2)\n            sum += q[i];\n        return sum <= w;\n    }\n    else\n    {\n        long sum = 0;\n        for (int i = 1; i < q.length; i += 2)\n            sum += q[i];\n        return sum <= w;\n    }\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpo7bsxjm8.d(54): unittest failure\n----------------\n??:? _d_unittestp [0x4282a5]\n??:? void tmpo7bsxjm8.__unittest_L49_C1() [0x427ef4]\n??:? void tmpo7bsxjm8.__modtest() [0x428024]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c303]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b196]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430329]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b16d]\n??:? runModuleUnitTests [0x42c0d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428768]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return false;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length % 2 == 0)\n        return false;\n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpwl11h835.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428245]\n??:? void tmpwl11h835.__unittest_L41_C1() [0x427e98]\n??:? void tmpwl11h835.__modtest() [0x427fc8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b136]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430778]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430255]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b10d]\n??:? runModuleUnitTests [0x42c079]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428708]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    if (q.length == 1)\n        return q[0] <= w;\n    \n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    \n    long max_weight = w - (q.length - 1) * q[0];\n    \n    if (q[0] > max_weight)\n        return false;\n    \n    for (int i = 1; i < q.length; i++)\n    {\n        if (q[i] > max_weight)\n            return false;\n        \n        if (q[i] + q[i - 1] > max_weight)\n            return false;\n    }\n    \n    return true;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp2h_5f3g3.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmp2h_5f3g3.__unittest_L53_C1() [0x427f04]\n??:? void tmp2h_5f3g3.__modtest() [0x42807c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c35b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ee]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430381]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430830]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43030d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c5]\n??:? runModuleUnitTests [0x42c131]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length % 2 == 1)\n        return q[q.length / 2] + q[q.length / 2 - 1] <= w;\n    else\n        return q[q.length / 2] + q[q.length / 2 - 1] <= w && is_balanced(q);\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "/tmp/tmp7qphyix4.d(37): Error: undefined identifier `is_balanced`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7qphyix4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    if (q.length == 1)\n        return q[0] <= w;\n    \n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    \n    if (q.length % 2 == 0)\n    {\n        long sum = 0;\n        for (int i = 0; i < q.length; i += 2)\n            sum += q[i];\n        return sum <= w;\n    }\n    else\n    {\n        long sum = 0;\n        for (int i = 0; i < q.length; i += 2)\n            sum += q[i];\n        return sum <= w && q[q.length - 1] == q[q.length - 2];\n    }\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpzgpdwjn3.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpzgpdwjn3.__unittest_L52_C1() [0x427f08]\n??:? void tmpzgpdwjn3.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c35b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ee]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430381]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430830]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43030d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c5]\n??:? runModuleUnitTests [0x42c131]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    if (q.length == 3) return q[0] + q[1] + q[2] <= w;\n    if (q.length == 4) return q[0] + q[1] + q[2] + q[3] <= w;\n    if (q.length == 5) return q[0] + q[1] + q[2] + q[3] + q[4] <= w;\n    if (q.length == 6) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] <= w;\n    if (q.length == 7) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] <= w;\n    if (q.length == 8) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] <= w;\n    if (q.length == 9) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] <= w;\n    if (q.length == 10) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] + q[9] <= w;\n    if (q.length == 11) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] + q[9] + q[10] <= w;\n    if (q.length == 12) return q[0] + q[1] + q[2]\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292669,
      "stdout": "",
      "stderr": "/tmp/tmpae818htn.d(41): Error: found `unittest` when expecting `;` following `return` statement\n/tmp/tmpae818htn.d(52): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpae818htn.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    if (sum > w)\n        return false;\n    \n    return is_balanced(q);\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "/tmp/tmpe6f9ub2e.d(38): Error: undefined identifier `is_balanced`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe6f9ub2e.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if(q.length == 0)\n        return true;\n    \n    long sum = 0;\n    for(int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    if(sum > w)\n        return false;\n    \n    if(sum == w)\n        return true;\n    \n    if(q.length % 2 == 0)\n    {\n        long max = 0;\n        for(int i = 0; i < q.length; i += 2)\n        {\n            max = std.math.max(max, q[i] + q[i + 1]);\n        }\n        \n        if(sum <= max)\n            return true;\n    }\n    \n    return false;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "/tmp/tmphg7tptmc.d(46): Error: undefined identifier `max` in module `std.math`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphg7tptmc.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if(q.length == 0) return true;\n    if(q.length == 1) return q[0] <= w;\n    if(q.length == 2) return q[0] + q[1] <= w;\n    if(q.length == 3) return q[0] + q[1] + q[2] <= w;\n    if(q.length == 4) return q[0] + q[1] + q[2] + q[3] <= w;\n    if(q.length == 5) return q[0] + q[1] + q[2] + q[3] + q[4] <= w;\n    if(q.length == 6) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] <= w;\n    if(q.length == 7) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] <= w;\n    if(q.length == 8) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] <= w;\n    if(q.length == 9) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] <= w;\n    if(q.length == 10) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] + q[9] <= w;\n    if(q.length == 11) return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] + q[9] + q[10] <= w;\n    if(q.length == 12) return q[0] + q[1] + q[2]\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "/tmp/tmpnjqflh31.d(41): Error: found `unittest` when expecting `;` following `return` statement\n/tmp/tmpnjqflh31.d(52): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnjqflh31.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    \n    long max_weight = 0;\n    for (int i = 0; i < q.length; i++) {\n        max_weight += q[i];\n    }\n    \n    if (max_weight > w) return false;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++) {\n        sum += q[i];\n    }\n    \n    if (sum <= w) return true;\n    \n    return false;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpy0_fxprs.d(53): unittest failure\n----------------\n??:? _d_unittestp [0x428295]\n??:? void tmpy0_fxprs.__unittest_L48_C1() [0x427ee8]\n??:? void tmpy0_fxprs.__modtest() [0x428018]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2f3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b186]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430319]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307c8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302a5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b15d]\n??:? runModuleUnitTests [0x42c0c9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428758]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length % 2 == 0)\n    {\n        long sum = 0;\n        for (int i = 0; i < q.length; i += 2)\n            sum += q[i];\n        return sum <= w;\n    }\n    else\n    {\n        long sum = 0;\n        for (int i = 0; i < q.length; i += 2)\n            sum += q[i];\n        return sum + q[q.length - 1] <= w;\n    }\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp07adpqw0.d(54): unittest failure\n----------------\n??:? _d_unittestp [0x4282dd]\n??:? void tmp07adpqw0.__unittest_L49_C1() [0x427f2c]\n??:? void tmp07adpqw0.__modtest() [0x42805c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c33b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ce]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430361]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430810]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302ed]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1a5]\n??:? runModuleUnitTests [0x42c111]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    return sum <= w && is_balanced(q);\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292669,
      "stdout": "",
      "stderr": "/tmp/tmppyw0b7_5.d(35): Error: undefined identifier `is_balanced`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppyw0b7_5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    if (sum > w)\n        return false;\n    \n    if (sum == w)\n        return true;\n    \n    if (q.length % 2 == 0)\n    {\n        for (int i = 0; i < q.length / 2; i++)\n        {\n            if (q[i] != q[q.length - 1 - i])\n                return false;\n        }\n        return true;\n    }\n    else\n    {\n        for (int i = 0; i < q.length / 2; i++)\n        {\n            if (q[i] != q[q.length - 1 - i])\n                return false;\n        }\n        return true;\n    }\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpz5zn__1f.d(68): unittest failure\n----------------\n??:? _d_unittestp [0x4282cd]\n??:? void tmpz5zn__1f.__unittest_L60_C1() [0x427ff9]\n??:? void tmpz5zn__1f.__modtest() [0x42804c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c32b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1be]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430351]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430800]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b195]\n??:? runModuleUnitTests [0x42c101]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428790]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    \n    if (q.length % 2 == 1) return false;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n    {\n        sum += q[i];\n    }\n    \n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpyx1m5m0f.d(44): unittest failure\n----------------\n??:? _d_unittestp [0x4281c5]\n??:? void tmpyx1m5m0f.__unittest_L40_C1() [0x427dd0]\n??:? void tmpyx1m5m0f.__modtest() [0x427f48]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c223]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b0b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430249]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4306f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4301d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b08d]\n??:? runModuleUnitTests [0x42bff9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428688]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length % 2 == 0)\n    {\n        long sum = 0;\n        for (int i = 0; i < q.length; i += 2)\n        {\n            sum += q[i];\n        }\n        return sum <= w;\n    }\n    else\n    {\n        long sum = 0;\n        for (int i = 1; i < q.length; i += 2)\n        {\n            sum += q[i];\n        }\n        return sum <= w;\n    }\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmppgr9hku_.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x4282a5]\n??:? void tmppgr9hku_.__unittest_L53_C1() [0x427ef4]\n??:? void tmppgr9hku_.__modtest() [0x428024]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c303]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b196]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430329]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b16d]\n??:? runModuleUnitTests [0x42c0d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428768]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    if (sum > w)\n        return false;\n    \n    if (q.length == 1)\n        return true;\n    \n    if (q.length % 2 == 0)\n        return false;\n    \n    for (int i = 0; i < q.length; i++)\n        if (q[i] != q[q.length - 1 - i])\n            return false;\n    \n    return true;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length % 2 == 1)\n        return q[0] + q[q.length - 1] <= w;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpndmb922b.d(47): unittest failure\n----------------\n??:? _d_unittestp [0x42829d]\n??:? void tmpndmb922b.__unittest_L42_C1() [0x427ef0]\n??:? void tmpndmb922b.__modtest() [0x428020]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b18e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430321]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b165]\n??:? runModuleUnitTests [0x42c0d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428760]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    if (q.length == 1)\n        return q[0] <= w;\n    \n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    \n    long max_weight = w - q[0];\n    \n    for (int i = 1; i < q.length; i++)\n    {\n        if (q[i] > max_weight)\n            return false;\n        \n        max_weight += q[i];\n    }\n    \n    return true;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp83q6ma6b.d(54): unittest failure\n----------------\n??:? _d_unittestp [0x428285]\n??:? void tmp83q6ma6b.__unittest_L49_C1() [0x427ed8]\n??:? void tmp83q6ma6b.__modtest() [0x428008]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2e3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b176]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430309]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307b8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430295]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b14d]\n??:? runModuleUnitTests [0x42c0b9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428748]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    if (sum > w)\n        return false;\n    \n    if (sum == w)\n        return true;\n    \n    if (q.length % 2 == 0)\n    {\n        for (int i = 0; i < q.length / 2; i++)\n        {\n            if (q[i] != q[q.length - 1 - i])\n                return false;\n        }\n        return true;\n    }\n    \n    return false;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp8ck1lmlf.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x428255]\n??:? void tmp8ck1lmlf.__unittest_L53_C1() [0x427e5c]\n??:? void tmp8ck1lmlf.__modtest() [0x427fd4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2b3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b146]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302d9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430788]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430265]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b11d]\n??:? runModuleUnitTests [0x42c089]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428718]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    \n    long max_weight = w - q[0];\n    for (int i = 1; i < q.length; i++)\n        max_weight = std.math.max(max_weight, q[i] + q[i-1]);\n    \n    return max_weight <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "/tmp/tmp2qwmymjt.d(37): Error: undefined identifier `max` in module `std.math`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2qwmymjt.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length % 2 == 0)\n        return false;\n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpi0_oif_y.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428245]\n??:? void tmpi0_oif_y.__unittest_L41_C1() [0x427e98]\n??:? void tmpi0_oif_y.__modtest() [0x427fc8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b136]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430778]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430255]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b10d]\n??:? runModuleUnitTests [0x42c079]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428708]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    return q.length == 0 || q.length == 1 || q.length == 2 || q.length == 3 || q.length == 4 || q.length == 5 || q.length == 6 || q.length == 7 || q.length == 8 || q.length == 9 || q.length == 10 || q.length == 11 || q.length == 12 || q.length == 13 || q.length == 14 || q.length == 15 || q.length == 16 || q.length == 17 || q.length == 18 || q.length == 19 || q.length == 20 || q.length == 21 || q.length == 22 || q.length == 23 || q.length == 24 || q.length == 25 || q.length == 26 || q.length == 27 || q.length == 28 || q.length == 29 || q.length == 30 || q.length == 31 || q.length == 32 || q.length == 33 || q.length == 34 || q.length == 35 || q.length == 36 || q.length == 37 || q.length == 38 || q.length == 39 || q.length == 40 || q.length == 41 || q.length == 42 || q.length == 43 || q.length == 44 || q.length == 45 || q.length == 46 || q.length == 47 || q.length == 48 || q.length == 49 || q.length == 50 || q.length == 51 || q.length == 52 || q.length == 53 || q.length == 54 || q.length == 55 || q.length == 56 || q.length == 57 || q.length == 58 || q.length == 59 || q.length == 60 || q.length == 61 || q.length == 62 || q.length == 63 || q.length == 64 || q.length == 65 || q.length == 66 || q.length == 67 || q.length == 68 || q.length == 69 || q.length == 70 || q.length == 71 || q.length == 72 || q.length == 73 || q.length == 74 || q.length == 75 || q.length == 76 || q.length == 77 || q.length == 78 || q.length == 79 || q.length == 80 || q.length == 81 || q.length == 82 || q.length == 83 || q.length ==\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "/tmp/tmp9qthp5gd.d(29): Error: expression expected, not `unittest`\n/tmp/tmp9qthp5gd.d(30): Error: found `{` when expecting `;` following `return` statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9qthp5gd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length % 2 == 0)\n        return false;\n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpi0_oif_y.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428245]\n??:? void tmpi0_oif_y.__unittest_L41_C1() [0x427e98]\n??:? void tmpi0_oif_y.__modtest() [0x427fc8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b136]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430778]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430255]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b10d]\n??:? runModuleUnitTests [0x42c079]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428708]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    \n    long max_weight = 0;\n    for (int i = 0; i < q.length; i++)\n        max_weight += q[i];\n    \n    if (max_weight > w) return false;\n    \n    if (q.length % 2 == 0)\n    {\n        long sum = 0;\n        for (int i = 0; i < q.length; i += 2)\n        {\n            sum += q[i];\n            sum += q[i + 1];\n        }\n        return sum <= w;\n    }\n    else\n    {\n        long sum = 0;\n        for (int i = 0; i < q.length; i++)\n        {\n            sum += q[i];\n        }\n        return sum <= w;\n    }\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpsibr_dza.d(63): unittest failure\n----------------\n??:? _d_unittestp [0x42832d]\n??:? void tmpsibr_dza.__unittest_L58_C1() [0x427f7c]\n??:? void tmpsibr_dza.__modtest() [0x4280ac]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c38b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b21e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430860]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43033d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1f5]\n??:? runModuleUnitTests [0x42c161]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++) {\n        sum += q[i];\n    }\n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpyebujaho.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x428235]\n??:? void tmpyebujaho.__unittest_L38_C1() [0x427e84]\n??:? void tmpyebujaho.__modtest() [0x427fb4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c293]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b126]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430768]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430245]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b0fd]\n??:? runModuleUnitTests [0x42c069]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4286f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if(q.length == 0)\n        return true;\n    \n    if(q.length == 1)\n        return q[0] <= w;\n    \n    if(q.length == 2)\n        return q[0] + q[1] <= w;\n    \n    long max_weight = w - q[0];\n    \n    for(int i = 1; i < q.length; i++)\n    {\n        if(q[i] > max_weight)\n            return false;\n        \n        max_weight += q[i];\n    }\n    \n    return true;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmplynzzxic.d(54): unittest failure\n----------------\n??:? _d_unittestp [0x428285]\n??:? void tmplynzzxic.__unittest_L49_C1() [0x427ed8]\n??:? void tmplynzzxic.__modtest() [0x428008]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2e3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b176]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430309]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307b8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430295]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b14d]\n??:? runModuleUnitTests [0x42c0b9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428748]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    if (sum > w)\n        return false;\n    \n    if (sum == w)\n        return true;\n    \n    if (sum < w)\n        return false;\n    \n    if (q.length % 2 == 0)\n        return false;\n    \n    long max = q.length / 2;\n    \n    for (int i = 0; i < max; i++)\n        if (q[i] != q[q.length - i - 1])\n            return false;\n    \n    return true;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmppo1x46yc.d(59): unittest failure\n----------------\n??:? _d_unittestp [0x428265]\n??:? void tmppo1x46yc.__unittest_L55_C1() [0x427e6c]\n??:? void tmppo1x46yc.__modtest() [0x427fe4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2c3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b156]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430798]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430275]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b12d]\n??:? runModuleUnitTests [0x42c099]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428728]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length % 2 == 0)\n        return false;\n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpi0_oif_y.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428245]\n??:? void tmpi0_oif_y.__unittest_L41_C1() [0x427e98]\n??:? void tmpi0_oif_y.__modtest() [0x427fc8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b136]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430778]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430255]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b10d]\n??:? runModuleUnitTests [0x42c079]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428708]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    if (q.length == 1)\n        return q[0] <= w;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    if (sum > w)\n        return false;\n    \n    return is_balanced(q);\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "/tmp/tmpv5ho0x1l.d(41): Error: undefined identifier `is_balanced`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv5ho0x1l.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp9mbktb94.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x428235]\n??:? void tmp9mbktb94.__unittest_L40_C1() [0x427e84]\n??:? void tmp9mbktb94.__modtest() [0x427fb4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c293]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b126]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430768]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430245]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b0fd]\n??:? runModuleUnitTests [0x42c069]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4286f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    \n    long max_weight = 0;\n    for (int i = 0; i < q.length; i++)\n        max_weight = max(max_weight, q[i]);\n    \n    if (q.length % 2 == 0)\n    {\n        long sum = 0;\n        for (int i = 0; i < q.length; i++)\n            sum += q[i];\n        return sum <= max_weight;\n    }\n    else\n    {\n        long sum = 0;\n        for (int i = 0; i < q.length; i++)\n            sum += q[i];\n        return sum <= max_weight;\n    }\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "/tmp/tmpcx6x7iwj.d(34): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcx6x7iwj.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    \n    long max_weight = 0;\n    for (int i = 0; i < q.length; i++)\n        max_weight = std.math.max(max_weight, q[i]);\n    \n    if (q.length % 2 == 1)\n    {\n        long sum = 0;\n        for (int i = 0; i < q.length; i++)\n            sum += q[i];\n        return sum <= max_weight;\n    }\n    else\n    {\n        long sum = 0;\n        for (int i = 0; i < q.length; i += 2)\n            sum += q[i] + q[i+1];\n        return sum <= max_weight;\n    }\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "/tmp/tmpyw9fbuj1.d(34): Error: undefined identifier `max` in module `std.math`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyw9fbuj1.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length % 2 == 1)\n        return q[q.length / 2] <= w;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpq3hpk35a.d(47): unittest failure\n----------------\n??:? _d_unittestp [0x42827d]\n??:? void tmpq3hpk35a.__unittest_L42_C1() [0x427ed0]\n??:? void tmpq3hpk35a.__modtest() [0x428000]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2db]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b16e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430301]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307b0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43028d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b145]\n??:? runModuleUnitTests [0x42c0b1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428740]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    \n    long max = 0;\n    for (int i = 0; i < q.length; i++)\n        max = std.math.max(max, q[i]);\n    \n    if (max > w)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "/tmp/tmpfd2siba4.d(37): Error: undefined identifier `max` in module `std.math`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfd2siba4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length == 3)\n        return q[0] + q[1] + q[2] <= w;\n    if (q.length % 2 == 0)\n    {\n        long sum = 0;\n        for (int i = 0; i < q.length; i += 2)\n        {\n            sum += q[i];\n        }\n        return sum <= w;\n    }\n    else\n    {\n        long sum = 0;\n        for (int i = 1; i < q.length; i += 2)\n        {\n            sum += q[i];\n        }\n        return sum <= w;\n    }\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpvg34i_m1.d(60): unittest failure\n----------------\n??:? _d_unittestp [0x428315]\n??:? void tmpvg34i_m1.__unittest_L55_C1() [0x427f68]\n??:? void tmpvg34i_m1.__modtest() [0x428098]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c373]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b206]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430399]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430848]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430325]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1dd]\n??:? runModuleUnitTests [0x42c149]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287d8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    if (sum > w)\n        return false;\n    \n    if (sum == w)\n        return true;\n    \n    if (q.length % 2 == 0)\n    {\n        for (int i = 0; i < q.length / 2; i++)\n        {\n            if (q[i] != q[q.length - 1 - i])\n                return false;\n        }\n        return true;\n    }\n    \n    return false;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp8ck1lmlf.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x428255]\n??:? void tmp8ck1lmlf.__unittest_L53_C1() [0x427e5c]\n??:? void tmp8ck1lmlf.__modtest() [0x427fd4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2b3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b146]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302d9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430788]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430265]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b11d]\n??:? runModuleUnitTests [0x42c089]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428718]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    \n    long max_weight = w - (q.length - 1);\n    if (q[0] > max_weight) return false;\n    if (q[q.length - 1] > max_weight) return false;\n    \n    for (int i = 1; i < q.length - 1; i++)\n    {\n        if (q[i] + q[i - 1] > max_weight) return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp0bheqmxe.d(47): unittest failure\n----------------\n??:? _d_unittestp [0x4282d5]\n??:? void tmp0bheqmxe.__unittest_L42_C1() [0x427f24]\n??:? void tmp0bheqmxe.__modtest() [0x428054]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c333]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1c6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430359]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430808]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302e5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b19d]\n??:? runModuleUnitTests [0x42c109]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428798]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++) {\n        sum += q[i];\n    }\n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpyebujaho.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x428235]\n??:? void tmpyebujaho.__unittest_L38_C1() [0x427e84]\n??:? void tmpyebujaho.__modtest() [0x427fb4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c293]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b126]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430768]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430245]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b0fd]\n??:? runModuleUnitTests [0x42c069]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4286f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length == 3)\n        return q[0] + q[1] + q[2] <= w;\n    if (q.length % 2 == 0)\n    {\n        long sum = 0;\n        for (int i = 0; i < q.length; i += 2)\n            sum += q[i];\n        return sum <= w;\n    }\n    else\n    {\n        long sum = 0;\n        for (int i = 0; i < q.length; i += 2)\n            sum += q[i];\n        return sum + q[q.length - 1] <= w;\n    }\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpo79hgjm3.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x42834d]\n??:? void tmpo79hgjm3.__unittest_L51_C1() [0x427fa0]\n??:? void tmpo79hgjm3.__modtest() [0x4280d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b23e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303d1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430880]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43035d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b215]\n??:? runModuleUnitTests [0x42c181]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428810]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    \n    long max = 0;\n    for (int i = 0; i < q.length; i++) {\n        if (q[i] > max) max = q[i];\n    }\n    \n    if (max > w) return false;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++) {\n        sum += q[i];\n    }\n    \n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp125try75.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x4282bd]\n??:? void tmp125try75.__unittest_L46_C1() [0x427f0c]\n??:? void tmp125try75.__modtest() [0x42803c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c31b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430341]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302cd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b185]\n??:? runModuleUnitTests [0x42c0f1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428780]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    if (q.length % 2 == 1) return q[0] + q[q.length-1] <= w;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpkargyiu3.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x42829d]\n??:? void tmpkargyiu3.__unittest_L38_C1() [0x427ef0]\n??:? void tmpkargyiu3.__modtest() [0x428020]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b18e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430321]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b165]\n??:? runModuleUnitTests [0x42c0d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428760]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    \n    long max_weight = 0;\n    for (int i = 0; i < q.length; i++)\n    {\n        max_weight = max(max_weight, q[i]);\n    }\n    \n    if (q.length % 2 == 0)\n    {\n        long sum = 0;\n        for (int i = 0; i < q.length; i++)\n        {\n            sum += q[i];\n        }\n        return sum <= max_weight;\n    }\n    else\n    {\n        long sum = 0;\n        for (int i = 0; i < q.length; i++)\n        {\n            sum += q[i];\n        }\n        return sum <= max_weight;\n    }\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "/tmp/tmpst4x_r62.d(35): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpst4x_r62.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    \n    long max_weight = 0;\n    for (int i = 0; i < q.length; i++)\n        max_weight = max(max_weight, q[i]);\n    \n    if (q.length % 2 == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    return sum <= max_weight;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "/tmp/tmpf22abxiy.d(37): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf22abxiy.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length % 2 == 0)\n        return false;\n    long sum = 0;\n    for (int i = 0; i < q.length; i += 2)\n        sum += q[i];\n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmps0gf5uiy.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x42824d]\n??:? void tmps0gf5uiy.__unittest_L41_C1() [0x427e9c]\n??:? void tmps0gf5uiy.__modtest() [0x427fcc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b13e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302d1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430780]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43025d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b115]\n??:? runModuleUnitTests [0x42c081]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428710]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    if (q.length % 2 == 0) return false;\n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp7ghc4tqj.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x428245]\n??:? void tmp7ghc4tqj.__unittest_L37_C1() [0x427e98]\n??:? void tmp7ghc4tqj.__modtest() [0x427fc8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b136]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430778]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430255]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b10d]\n??:? runModuleUnitTests [0x42c079]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428708]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    if (q.length == 1)\n        return q[0] <= w;\n    \n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    \n    if (q.length % 2 == 0)\n    {\n        long sum = 0;\n        for (int i = 0; i < q.length; i += 2)\n            sum += q[i];\n        return sum <= w;\n    }\n    else\n    {\n        long sum = 0;\n        for (int i = 0; i < q.length; i += 2)\n            sum += q[i];\n        return sum <= w;\n    }\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpjsboypky.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x4282a5]\n??:? void tmpjsboypky.__unittest_L52_C1() [0x427ef4]\n??:? void tmpjsboypky.__modtest() [0x428024]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c303]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b196]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430329]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b16d]\n??:? runModuleUnitTests [0x42c0d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428768]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    if (q.length == 1)\n        return q[0] <= w;\n    \n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    \n    long max_weight = w - (q.length - 1);\n    \n    if (q[0] + q[q.length - 1] > max_weight)\n        return false;\n    \n    for (int i = 1; i < q.length - 1; i++)\n    {\n        if (q[i] + q[q.length - i - 1] > max_weight)\n            return false;\n    }\n    \n    return true;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpugqssmx1.d(55): unittest failure\n----------------\n??:? _d_unittestp [0x4282bd]\n??:? void tmpugqssmx1.__unittest_L50_C1() [0x427f0c]\n??:? void tmpugqssmx1.__modtest() [0x42803c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c31b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430341]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302cd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b185]\n??:? runModuleUnitTests [0x42c0f1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428780]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++) {\n        sum += q[i];\n    }\n    \n    if (sum <= w) return true;\n    \n    return false;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp9uoqa444.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x42823d]\n??:? void tmp9uoqa444.__unittest_L41_C1() [0x427e90]\n??:? void tmp9uoqa444.__modtest() [0x427fc0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c29b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b12e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302c1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430770]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43024d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b105]\n??:? runModuleUnitTests [0x42c071]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428700]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    if (q.length == 1)\n        return q[0] <= w;\n    \n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    \n    if (q.length % 2 == 0)\n    {\n        long sum = 0;\n        for (int i = 0; i < q.length; i += 2)\n            sum += q[i];\n        return sum <= w;\n    }\n    else\n    {\n        long sum = 0;\n        for (int i = 1; i < q.length; i += 2)\n            sum += q[i];\n        return sum <= w;\n    }\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292672,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmplecgulwt.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x4282a5]\n??:? void tmplecgulwt.__unittest_L52_C1() [0x427ef4]\n??:? void tmplecgulwt.__modtest() [0x428024]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c303]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b196]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430329]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b16d]\n??:? runModuleUnitTests [0x42c0d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428768]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length % 2 == 0)\n        return false;\n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpi0_oif_y.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428245]\n??:? void tmpi0_oif_y.__unittest_L41_C1() [0x427e98]\n??:? void tmpi0_oif_y.__modtest() [0x427fc8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b136]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430778]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430255]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b10d]\n??:? runModuleUnitTests [0x42c079]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428708]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return false;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length == 3)\n        return q[0] + q[1] + q[2] <= w;\n    if (q.length == 4)\n        return q[0] + q[1] + q[2] + q[3] <= w;\n    if (q.length == 5)\n        return q[0] + q[1] + q[2] + q[3] + q[4] <= w;\n    if (q.length == 6)\n        return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] <= w;\n    if (q.length == 7)\n        return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] <= w;\n    if (q.length == 8)\n        return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] <= w;\n    if (q.length == 9)\n        return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] <= w;\n    if (q.length == 10)\n        return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] + q[9] <= w;\n    if (q.length == 11)\n        return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] + q[9] + q[10] <= w;\n\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "/tmp/tmp4wdlbswf.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4wdlbswf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length % 2 == 0)\n        return q[0] + q[1] + q[q.length - 2] + q[q.length - 1] <= w;\n    else\n        return q[0] + q[1] + q[q.length - 1] <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpd2pe4cmm.d(44): unittest failure\n----------------\n??:? _d_unittestp [0x4282f5]\n??:? void tmpd2pe4cmm.__unittest_L39_C1() [0x427f44]\n??:? void tmpd2pe4cmm.__modtest() [0x428074]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c353]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1e6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430379]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430828]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430305]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1bd]\n??:? runModuleUnitTests [0x42c129]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287b8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    if (q.length % 2 == 0) return false;\n    long max_weight = (q.length - 1) * q[0] + q[q.length - 1];\n    return max_weight <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292672,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp6jt0v0zo.d(40): unittest failure\n----------------\n??:? _d_unittestp [0x42824d]\n??:? void tmp6jt0v0zo.__unittest_L35_C1() [0x427ea0]\n??:? void tmp6jt0v0zo.__modtest() [0x427fd0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b13e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302d1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430780]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43025d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b115]\n??:? runModuleUnitTests [0x42c081]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428710]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    if (q.length % 2 == 1) return q[q.length/2] <= w;\n    \n    long max_weight = q[0] + q[1] + q[2];\n    for (int i = 3; i < q.length; i += 2)\n    {\n        max_weight += q[i];\n    }\n    return max_weight <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292672,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpkz2tvsa3.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmpkz2tvsa3.__unittest_L40_C1() [0x427f34]\n??:? void tmpkz2tvsa3.__modtest() [0x428064]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c343]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430369]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430818]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ad]\n??:? runModuleUnitTests [0x42c119]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    \n    if (q.length == 1)\n        return q[0] <= w;\n    \n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    \n    if (q.length % 2 == 0)\n    {\n        long sum = 0;\n        for (int i = 0; i < q.length; i += 2)\n            sum += q[i];\n        return sum <= w;\n    }\n    else\n    {\n        long sum = 0;\n        for (int i = 0; i < q.length; i += 2)\n            sum += q[i];\n        return sum + q[q.length - 1] <= w;\n    }\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292672,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpjcc4u7pd.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x4282dd]\n??:? void tmpjcc4u7pd.__unittest_L52_C1() [0x427f2c]\n??:? void tmpjcc4u7pd.__modtest() [0x42805c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c33b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ce]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430361]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430810]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302ed]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1a5]\n??:? runModuleUnitTests [0x42c111]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n    {\n        sum += q[i];\n    }\n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292672,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmprrq6ev2k.d(44): unittest failure\n----------------\n??:? _d_unittestp [0x428235]\n??:? void tmprrq6ev2k.__unittest_L39_C1() [0x427e84]\n??:? void tmprrq6ev2k.__modtest() [0x427fb4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c293]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b126]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430768]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430245]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b0fd]\n??:? runModuleUnitTests [0x42c069]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4286f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0) return true;\n    if (q.length == 1) return q[0] <= w;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    \n    if (sum <= w) return true;\n    \n    return false;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpsm0s1sw0.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x42823d]\n??:? void tmpsm0s1sw0.__unittest_L40_C1() [0x427e90]\n??:? void tmpsm0s1sw0.__modtest() [0x427fc0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c29b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b12e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302c1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430770]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43024d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b105]\n??:? runModuleUnitTests [0x42c071]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428700]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length % 2 == 0)\n        return false;\n    long sum = 0;\n    for (int i = 0; i < q.length; i++)\n        sum += q[i];\n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292670,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpi0_oif_y.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428245]\n??:? void tmpi0_oif_y.__unittest_L41_C1() [0x427e98]\n??:? void tmpi0_oif_y.__modtest() [0x427fc8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b136]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430778]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430255]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b10d]\n??:? runModuleUnitTests [0x42c079]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428708]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 0)\n        return true;\n    if (q.length == 1)\n        return q[0] <= w;\n    if (q.length == 2)\n        return q[0] + q[1] <= w;\n    if (q.length == 3)\n        return q[0] + q[1] + q[2] <= w;\n    if (q.length == 4)\n        return q[0] + q[1] + q[2] + q[3] <= w;\n    if (q.length == 5)\n        return q[0] + q[1] + q[2] + q[3] + q[4] <= w;\n    if (q.length == 6)\n        return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] <= w;\n    if (q.length == 7)\n        return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] <= w;\n    if (q.length == 8)\n        return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] <= w;\n    if (q.length == 9)\n        return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] <= w;\n    if (q.length == 10)\n        return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] + q[9] <= w;\n    if (q.length == 11)\n        return q[0] + q[1] + q[2] + q[3] + q[4] + q[5] + q[6] + q[7] + q[8] + q[9] + q[10] <= w;\n\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292669,
      "stdout": "",
      "stderr": "/tmp/tmptypmfhfr.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptypmfhfr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that returns true if the object q will fly, and false otherwise.\n    The object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    >>> will_it_fly([1L, 2L], 5L)\n    false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    >>> will_it_fly([3L, 2L, 3L], 1L)\n    false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    >>> will_it_fly([3L, 2L, 3L], 9L)\n    true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    >>> will_it_fly([3L], 5L)\n    true\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[] q, long w) \n{\n    if (q.length == 1) return true;\n    if (q.length == 2) return q[0] + q[1] <= w;\n    if (q.length % 2 == 1) return false;\n    \n    long sum = 0;\n    for (int i = 0; i < q.length; i += 2) {\n        sum += q[i];\n    }\n    return sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}",
      "timestamp": 1664292671,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmphpx2gkny.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x42821d]\n??:? void tmphpx2gkny.__unittest_L38_C1() [0x427e24]\n??:? void tmphpx2gkny.__modtest() [0x427f9c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c27b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b10e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302a1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430750]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43022d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b0e5]\n??:? runModuleUnitTests [0x42c051]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4286e0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}