{
  "name": "HumanEval_145_order_by_points",
  "language": "d",
  "prompt": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n",
  "tests": "unittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "results": [
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n        long sum = 0;\n        for (int j = 0; j < nums[i] < 0 ? nums[i] * -1 : nums[i]; j++) {\n            sum += Math.abs(nums[i] % 10);\n        }\n        result[i] = sum;\n    }\n    \n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (result[i] == result[j]) {\n                result[i] = nums[i];\n                result[j] = nums[j];\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmp0ww70e4z.d(22): Error: found `<` when expecting `;` following `for` condition\n/tmp/tmp0ww70e4z.d(22): Error: found `;` when expecting `)`\n/tmp/tmp0ww70e4z.d(22): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0ww70e4z.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    for (int i = 0; i < nums.length; i++) {\n        long sum = 0;\n        for (int j = 0; j < nums[i] != 0; j++) {\n            sum += nums[i] % 10;\n            nums[i] /= 10;\n        }\n        result[i] = sum;\n    }\n    \n    java.util.Arrays.sort(result);\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmpo9tsl36n.d(22): Error: found `!=` when expecting `;` following `for` condition\n/tmp/tmpo9tsl36n.d(22): Error: found `;` when expecting `)`\n/tmp/tmpo9tsl36n.d(22): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo9tsl36n.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    int[] sum_digits = new int[10];\n    for (int i = 0; i < nums.length; i++) {\n        sum_digits[nums[i] % 10]++;\n    }\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < sum_digits[i]; j++) {\n            result[j] = i;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp9kkqx7uo.d(22): Range violation\n----------------\n??:? _d_arrayboundsp [0x428b96]\n??:? long[] tmp9kkqx7uo.order_by_points(long[]) [0x42816c]\n??:? void tmp9kkqx7uo.__unittest_L31_C1() [0x428268]\n??:? void tmp9kkqx7uo.__modtest() [0x428868]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cda7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bc3a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ec5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431374]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430e51]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bc11]\n??:? runModuleUnitTests [0x42cb7d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int funct",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    \n    for (int i = 0; i < nums.length; i++) {\n        long sum = 0;\n        for (int j = 0; j < nums[i] != 0; j++) {\n            sum += nums[i] % 10;\n            nums[i] /= 10;\n        }\n        \n        for (int j = 0; j < nums.length; j++) {\n            if (nums[j] == sum) {\n                result[i] = nums[j];\n                nums[j] = 0;\n                break;\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmpuvagqu_v.d(23): Error: found `!=` when expecting `;` following `for` condition\n/tmp/tmpuvagqu_v.d(23): Error: found `;` when expecting `)`\n/tmp/tmpuvagqu_v.d(23): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuvagqu_v.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n        result[i] = nums[i];\n    }\n    \n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (nums[i] + nums[j] == nums[i] + nums[j]) {\n                result[i] = nums[i];\n                result[j] = nums[j];\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpzohrpicm.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x42893d]\n??:? void tmpzohrpicm.__unittest_L35_C1() [0x428131]\n??:? void tmpzohrpicm.__modtest() [0x4286bc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca1b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8ae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b39]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fe8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ac5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b885]\n??:? runModuleUnitTests [0x42c7f1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e00]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    int len = nums.length;\n    for (int i = 0; i < len; i++) {\n        long sum = 0;\n        for (int j = 0; j < len; j++) {\n            sum += nums[j];\n        }\n        int index = i;\n        for (int j = i + 1; j < len; j++) {\n            if (sum > sum_of_digits(nums[j])) {\n                index = j;\n            }\n        }\n        if (index != i) {\n            long temp = nums[i];\n            nums[i] = nums[index];\n            nums[index] = temp;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmpc88u0t91.d(19): Error: no property `clone` for type `long[]`\n/tmp/tmpc88u0t91.d(20): Error: cannot implicitly convert expression `nums.length` of type `ulong` to `int`\n/tmp/tmpc88u0t91.d(28): Error: undefined identifier `sum_of_digits`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc88u0t91.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    long[] sorted = new long[nums.length];\n    int[] index = new int[nums.length];\n    int[] sum = new int[nums.length];\n    int i = 0;\n    for(long n : nums)\n    {\n        sum[i] = n % 10;\n        i++;\n    }\n    \n    for(i = 0; i < nums.length; i++)\n    {\n        index[i] = i;\n    }\n    \n    for(i = 0; i < nums.length; i++)\n    {\n        for(int j = i + 1; j < nums.length; j++)\n        {\n            if(sum[i] == sum[j])\n            {\n                if(index[i] < index[j])\n                {\n                    index[i]++;\n                }\n                else\n                {\n                    index[j]++;\n                }\n            }\n        }\n    }\n    \n    for(i = 0; i < nums.length; i++)\n    {\n        sorted[index[i]] = result[i];\n    }\n    \n    return sorted;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmp0wdqgbuw.d(24): Error: semicolon expected, not `:`\n/tmp/tmp0wdqgbuw.d(24): Error: expression expected, not `:`\n/tmp/tmp0wdqgbuw.d(24): Error: found `nums` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0wdqgbuw.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    for (int i = 0; i < result.length; i++) {\n        for (int j = i + 1; j < result.length; j++) {\n            if (result[i] + result[j] == 0) {\n                long temp = result[i];\n                result[i] = result[j];\n                result[j] = temp;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmpe_cjpj5_.d(19): Error: no property `clone` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_cjpj5_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    long[] sums = new long[10];\n    for (int i = 0; i < nums.length; i++) {\n        sums[nums[i] % 10] += nums[i];\n    }\n    for (int i = 0; i < sums.length; i++) {\n        for (int j = 0; j < nums.length; j++) {\n            if (sums[i] == nums[j]) {\n                result[j] = nums[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpz_wktjul.d(22): Range violation\n----------------\n??:? _d_arrayboundsp [0x42898e]\n??:? long[] tmpz_wktjul.order_by_points(long[]) [0x427ed2]\n??:? void tmpz_wktjul.__unittest_L34_C1() [0x42805c]\n??:? void tmpz_wktjul.__modtest() [0x42865c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b84e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ad9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f88]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a65]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b825]\n??:? runModuleUnitTests [0x42c791]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int funct",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    int[] indexes = new int[nums.length];\n    int[] sums = new int[10];\n    for (int i = 0; i < nums.length; i++) {\n        sums[nums[i] % 10]++;\n    }\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < sums[i]; j++) {\n            result[indexes[i]++] = i;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp1_aeqnah.d(23): Range violation\n----------------\n??:? _d_arrayboundsp [0x428bde]\n??:? long[] tmp1_aeqnah.order_by_points(long[]) [0x428184]\n??:? void tmp1_aeqnah.__unittest_L32_C1() [0x4282b0]\n??:? void tmp1_aeqnah.__modtest() [0x4288b0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cdef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bc82]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430f0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4313bc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430e99]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bc59]\n??:? runModuleUnitTests [0x42cbc5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int funct",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] sorted = nums.clone();\n    sort(sorted, (a, b) -> {\n        int sum_a = 0, sum_b = 0;\n        for (int i = 0; i < a.length(); i++) {\n            sum_a += a.charAt(i) - '0';\n        }\n        for (int i = 0; i < b.length(); i++) {\n            sum_b += b.charAt(i) - '0';\n        }\n        return sum_a - sum_b;\n    });\n    return sorted;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmpy8u7a_na.d(20): Error: expression expected, not `>`\n/tmp/tmpy8u7a_na.d(20): Error: found `{` when expecting `,`\n/tmp/tmpy8u7a_na.d(21): Error: found `sum_a` when expecting `.` following int\n/tmp/tmpy8u7a_na.d(21): Error: found `=` when expecting identifier following `int`.\n/tmp/tmpy8u7a_na.d(21): Error: found `0` when expecting `,`\n/tmp/tmpy8u7a_na.d(21): Error: expression expected, not `,`\n/tmp/tmpy8u7a_na.d(21): Error: found `sum_b` when expecting `,`\n/tmp/tmpy8u7a_na.d(21): Error: expression expected, not `=`\n/tmp/tmpy8u7a_na.d(21): Error: found `0` when expecting `,`\n/tmp/tmpy8u7a_na.d(21): Error: expression expected, not `;`\n/tmp/tmpy8u7a_na.d(22): Error: found `for` when expecting `,`\n/tmp/tmpy8u7a_na.d(22): Error: found `i` when expecting `.` following int\n/tmp/tmpy8u7a_na.d(22): Error: found `=` when expecting identifier following `int`.\n/tmp/tmpy8u7a_na.d(22): Error: found `0` when expecting `)`\n/tmp/tmpy8u7a_na.d(22): Error: found `;` when expecting `,`\n/tmp/tmpy8u7a_na.d(22): Error: found `",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    \n    for (int i = 0; i < nums.length; i++) {\n        long sum = 0;\n        for (int j = 0; j < nums[i] < 0 ? nums[i] * -1 : nums[i]; j++) {\n            sum += nums[i] % 10;\n        }\n        result[i] = sum;\n    }\n    \n    java.util.Arrays.sort(result);\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmp_jck09qh.d(23): Error: found `<` when expecting `;` following `for` condition\n/tmp/tmp_jck09qh.d(23): Error: found `;` when expecting `)`\n/tmp/tmp_jck09qh.d(23): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_jck09qh.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    \n    for(int i = 0; i < result.length; i++)\n    {\n        for(int j = i+1; j < result.length; j++)\n        {\n            if(result[i] + result[j] == 0)\n            {\n                long temp = result[i];\n                result[i] = result[j];\n                result[j] = temp;\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmpwpuaizu0.d(19): Error: no property `clone` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwpuaizu0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    int[] sums = new int[10];\n    for(int i = 0; i < nums.length; i++)\n    {\n        int sum = 0;\n        while(nums[i] != 0)\n        {\n            sum += nums[i] % 10;\n            nums[i] /= 10;\n        }\n        sums[sum]++;\n    }\n    for(int i = 0; i < 10; i++)\n    {\n        for(int j = 0; j < sums[i]; j++)\n        {\n            result[j] = i;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpk9woa8c6.d(29): Range violation\n----------------\n??:? _d_arrayboundsp [0x428c16]\n??:? long[] tmpk9woa8c6.order_by_points(long[]) [0x4281e0]\n??:? void tmpk9woa8c6.__unittest_L40_C1() [0x4282e4]\n??:? void tmpk9woa8c6.__modtest() [0x4288e4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ce27]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bcba]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430f45]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4313f4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ed1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bc91]\n??:? runModuleUnitTests [0x42cbfd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int funct",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n        result[i] = nums[i];\n    }\n    \n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (nums[i] + nums[j] == nums[i] + nums[j]) {\n                result[i] = nums[i];\n                result[j] = nums[j];\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpzohrpicm.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x42893d]\n??:? void tmpzohrpicm.__unittest_L35_C1() [0x428131]\n??:? void tmpzohrpicm.__modtest() [0x4286bc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca1b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8ae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b39]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fe8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ac5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b885]\n??:? runModuleUnitTests [0x42c7f1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e00]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    \n    for (int i = 0; i < result.length; i++) {\n        long sum = 0;\n        for (int j = 0; j < result[i].toString().length(); j++) {\n            sum += Math.pow(10, j) * result[i].toString().charAt(j) - Math.pow(10, j);\n        }\n        result[i] = sum;\n    }\n    \n    for (int i = 0; i < result.length; i++) {\n        for (int j = i + 1; j < result.length; j++) {\n            if (result[i] > result[j]) {\n                long temp = result[i];\n                result[i] = result[j];\n                result[j] = temp;\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmp5hpcv8yl.d(19): Error: no property `clone` for type `long[]`\n/tmp/tmp5hpcv8yl.d(23): Error: no property `toString` for type `long`\n/tmp/tmp5hpcv8yl.d(24): Error: undefined identifier `Math`\n/tmp/tmp5hpcv8yl.d(24): Error: no property `toString` for type `long`\n/tmp/tmp5hpcv8yl.d(24): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5hpcv8yl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    int[] indexes = new int[nums.length];\n    int[] sums = new int[10];\n    for(int i = 0; i < nums.length; i++)\n    {\n        sums[nums[i] % 10]++;\n    }\n    for(int i = 0; i < 10; i++)\n    {\n        for(int j = 0; j < sums[i]; j++)\n        {\n            result[indexes[i]++] = i;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp4qrmahal.d(24): Range violation\n----------------\n??:? _d_arrayboundsp [0x428bde]\n??:? long[] tmp4qrmahal.order_by_points(long[]) [0x428184]\n??:? void tmp4qrmahal.__unittest_L35_C1() [0x4282b0]\n??:? void tmp4qrmahal.__modtest() [0x4288b0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cdef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bc82]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430f0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4313bc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430e99]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bc59]\n??:? runModuleUnitTests [0x42cbc5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int funct",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    int[] indexes = new int[nums.length];\n    int[] sums = new int[10];\n    for (int i = 0; i < nums.length; i++) {\n        sums[nums[i] % 10]++;\n    }\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < sums[i]; j++) {\n            result[indexes[i]++] = i;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp1_aeqnah.d(23): Range violation\n----------------\n??:? _d_arrayboundsp [0x428bde]\n??:? long[] tmp1_aeqnah.order_by_points(long[]) [0x428184]\n??:? void tmp1_aeqnah.__unittest_L32_C1() [0x4282b0]\n??:? void tmp1_aeqnah.__modtest() [0x4288b0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cdef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bc82]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430f0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4313bc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430e99]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bc59]\n??:? runModuleUnitTests [0x42cbc5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int funct",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    int[] sums = new int[10];\n    for(int i = 0; i < nums.length; i++)\n    {\n        int sum = 0;\n        while(nums[i] != 0)\n        {\n            sum += nums[i] % 10;\n            nums[i] /= 10;\n        }\n        sums[sum]++;\n    }\n    for(int i = 0; i < 10; i++)\n    {\n        for(int j = 0; j < sums[i]; j++)\n        {\n            result[j] = i * 10 + j;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmptykdwton.d(29): Range violation\n----------------\n??:? _d_arrayboundsp [0x428c26]\n??:? long[] tmptykdwton.order_by_points(long[]) [0x4281e0]\n??:? void tmptykdwton.__unittest_L40_C1() [0x4282f4]\n??:? void tmptykdwton.__modtest() [0x4288f4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ce37]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bcca]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430f55]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431404]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ee1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bca1]\n??:? runModuleUnitTests [0x42cc0d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int funct",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n        result[i] = nums[i];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmppwdbdw4b.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x4287ad]\n??:? void tmppwdbdw4b.__unittest_L26_C1() [0x427fa1]\n??:? void tmppwdbdw4b.__modtest() [0x42852c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c88b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b71e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4309a9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430e58]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430935]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b6f5]\n??:? runModuleUnitTests [0x42c661]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428c70]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] sorted = new long[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n        long sum = 0;\n        for (int j = 0; j < nums[i].toString().length(); j++) {\n            sum += nums[i].toString().charAt(j) - '0';\n        }\n        sorted[i] = sum;\n    }\n    java.util.Arrays.sort(sorted);\n    return sorted;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmpwv1mh7ln.d(22): Error: no property `toString` for type `long`\n/tmp/tmpwv1mh7ln.d(23): Error: no property `toString` for type `long`\n/tmp/tmpwv1mh7ln.d(27): Error: undefined identifier `java`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwv1mh7ln.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    int n = nums.length;\n    for (int i = 0; i < n; i++) {\n        int sum = 0;\n        for (int j = 0; j < nums[i] != 0; j++) {\n            sum += nums[i] % 10;\n            nums[i] /= 10;\n        }\n        result[i] = sum;\n    }\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (result[i] == result[j]) {\n                long temp = result[i];\n                result[i] = result[j];\n                result[j] = temp;\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmpt5crct69.d(23): Error: found `!=` when expecting `;` following `for` condition\n/tmp/tmpt5crct69.d(23): Error: found `;` when expecting `)`\n/tmp/tmpt5crct69.d(23): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt5crct69.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    int n = nums.length;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (nums[i] + nums[j] == nums[i] * 10 + nums[j]) {\n                long temp = nums[i];\n                nums[i] = nums[j];\n                nums[j] = temp;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmpf92ka__w.d(19): Error: no property `clone` for type `long[]`\n/tmp/tmpf92ka__w.d(20): Error: cannot implicitly convert expression `nums.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf92ka__w.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    long[] sums = new long[10];\n    for (int i = 0; i < nums.length; i++) {\n        sums[nums[i] % 10] += nums[i];\n    }\n    for (int i = 0; i < sums.length; i++) {\n        for (int j = 0; j < nums.length; j++) {\n            if (sums[i] == nums[j]) {\n                result[j] = nums[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpz_wktjul.d(22): Range violation\n----------------\n??:? _d_arrayboundsp [0x42898e]\n??:? long[] tmpz_wktjul.order_by_points(long[]) [0x427ed2]\n??:? void tmpz_wktjul.__unittest_L34_C1() [0x42805c]\n??:? void tmpz_wktjul.__modtest() [0x42865c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b84e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ad9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f88]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a65]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b825]\n??:? runModuleUnitTests [0x42c791]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int funct",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n        result[i] = nums[i];\n    }\n    \n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (nums[i] + nums[j] == nums[i] * 10 + nums[j]) {\n                result[i] = nums[i];\n                result[j] = nums[j];\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpltp3p3aa.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x428945]\n??:? void tmpltp3p3aa.__unittest_L35_C1() [0x428139]\n??:? void tmpltp3p3aa.__modtest() [0x4286c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca23]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b41]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ff0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430acd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b88d]\n??:? runModuleUnitTests [0x42c7f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] sorted_nums = nums.clone();\n    \n    // sort the array by sum of digits\n    sort(sorted_nums, (a, b) -> \n        {\n            long sum_a = 0;\n            long sum_b = 0;\n            for (int i = 0; i < a.length(); i++)\n            {\n                sum_a += a.charAt(i) - '0';\n            }\n            for (int i = 0; i < b.length(); i++)\n            {\n                sum_b += b.charAt(i) - '0';\n            }\n            return sum_a - sum_b;\n        });\n    \n    return sorted_nums;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmp5yknh9td.d(22): Error: expression expected, not `>`\n/tmp/tmp5yknh9td.d(23): Error: found `{` when expecting `,`\n/tmp/tmp5yknh9td.d(24): Error: found `sum_a` when expecting `.` following long\n/tmp/tmp5yknh9td.d(24): Error: found `=` when expecting identifier following `long`.\n/tmp/tmp5yknh9td.d(24): Error: found `0` when expecting `,`\n/tmp/tmp5yknh9td.d(24): Error: expression expected, not `;`\n/tmp/tmp5yknh9td.d(25): Error: found `long` when expecting `,`\n/tmp/tmp5yknh9td.d(25): Error: found `;` when expecting `,`\n/tmp/tmp5yknh9td.d(26): Error: expression expected, not `for`\n/tmp/tmp5yknh9td.d(26): Error: found `i` when expecting `.` following int\n/tmp/tmp5yknh9td.d(26): Error: found `=` when expecting identifier following `int`.\n/tmp/tmp5yknh9td.d(26): Error: found `0` when expecting `,`\n/tmp/tmp5yknh9td.d(26): Error: expression expected, not `;`\n/tmp/tmp5yknh9td.d(26): Error: found `i` when expecting `,`\n/tmp/tmp5yknh9td.d(26): Error: expression expected, not `<`\n/tmp/tmp5yknh9td.d(26): Error: found ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (nums[i] + nums[j] == nums[i] * 10 + nums[j]) {\n                long temp = nums[i];\n                nums[i] = nums[j];\n                nums[j] = temp;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmpk7cjcufd.d(19): Error: no property `clone` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk7cjcufd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    for (int i = 0; i < result.length; i++) {\n        for (int j = i + 1; j < result.length; j++) {\n            if (result[i] + result[j] == 0) {\n                long temp = result[i];\n                result[i] = result[j];\n                result[j] = temp;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmpe_cjpj5_.d(19): Error: no property `clone` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_cjpj5_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] sorted = nums.clone();\n    sort(sorted, (a, b) -> {\n        int a_sum = 0;\n        int b_sum = 0;\n        for (int i = 0; i < a.length(); i++) {\n            a_sum += a.charAt(i) - '0';\n        }\n        for (int i = 0; i < b.length(); i++) {\n            b_sum += b.charAt(i) - '0';\n        }\n        return a_sum - b_sum;\n    });\n    return sorted;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmpysw0h_2e.d(20): Error: expression expected, not `>`\n/tmp/tmpysw0h_2e.d(20): Error: found `{` when expecting `,`\n/tmp/tmpysw0h_2e.d(21): Error: found `a_sum` when expecting `.` following int\n/tmp/tmpysw0h_2e.d(21): Error: found `=` when expecting identifier following `int`.\n/tmp/tmpysw0h_2e.d(21): Error: found `0` when expecting `,`\n/tmp/tmpysw0h_2e.d(21): Error: expression expected, not `;`\n/tmp/tmpysw0h_2e.d(22): Error: found `int` when expecting `,`\n/tmp/tmpysw0h_2e.d(22): Error: found `;` when expecting `,`\n/tmp/tmpysw0h_2e.d(23): Error: expression expected, not `for`\n/tmp/tmpysw0h_2e.d(23): Error: found `i` when expecting `.` following int\n/tmp/tmpysw0h_2e.d(23): Error: found `=` when expecting identifier following `int`.\n/tmp/tmpysw0h_2e.d(23): Error: found `0` when expecting `,`\n/tmp/tmpysw0h_2e.d(23): Error: expression expected, not `;`\n/tmp/tmpysw0h_2e.d(23): Error: found `i` when expecting `,`\n/tmp/tmpysw0h_2e.d(23): Error: expression expected, not `<`\n/tmp/tmpysw0h_2e.d(23): Error: found `a`",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    for (int i = 0; i < nums.length; i++) {\n        long sum = 0;\n        for (int j = 0; j < nums[i] < 0 ? nums[i] * -1 : nums[i]; j++) {\n            sum += Math.abs(nums[i] % 10);\n        }\n        result[i] = sum;\n    }\n    java.util.Arrays.sort(result);\n    return result;\n}\n\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmphe7g6de_.d(22): Error: found `<` when expecting `;` following `for` condition\n/tmp/tmphe7g6de_.d(22): Error: found `;` when expecting `)`\n/tmp/tmphe7g6de_.d(22): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphe7g6de_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] sorted = new long[nums.length];\n    int i = 0;\n    for (long n : nums) {\n        long sum = 0;\n        while (n > 0) {\n            sum += n % 10;\n            n /= 10;\n        }\n        sorted[i++] = sum;\n    }\n    Arrays.sort(sorted);\n    return sorted;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmp46p90wpd.d(21): Error: semicolon expected, not `:`\n/tmp/tmp46p90wpd.d(21): Error: expression expected, not `:`\n/tmp/tmp46p90wpd.d(21): Error: found `nums` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp46p90wpd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    int[] sorted = new int[nums.length];\n    int[] count = new int[10];\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    for(i = 0; i < nums.length; i++)\n    {\n        count[nums[i]%10]++;\n    }\n    for(i = 0; i < 10; i++)\n    {\n        for(j = 0; j < count[i]; j++)\n        {\n            result[k++] = i;\n        }\n    }\n    for(i = 0; i < nums.length; i++)\n    {\n        sorted[i] = result[nums[i]];\n    }\n    return sorted;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmpb_xycq_1.d(38): Error: cannot implicitly convert expression `result[cast(ulong)nums[cast(ulong)i]]` of type `long` to `int`\n/tmp/tmpb_xycq_1.d(40): Error: cannot implicitly convert expression `sorted` of type `int[]` to `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb_xycq_1.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] sorted = nums.clone();\n    sort(sorted, (a, b) -> {\n        long sum_a = 0;\n        long sum_b = 0;\n        for (int i = 0; i < Math.min(a.length(), b.length()); i++) {\n            sum_a += Math.abs(a[i] - '0');\n            sum_b += Math.abs(b[i] - '0');\n        }\n        return sum_a - sum_b;\n    });\n    return sorted;\n}\n\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmpwfqwf_le.d(20): Error: expression expected, not `>`\n/tmp/tmpwfqwf_le.d(20): Error: found `{` when expecting `,`\n/tmp/tmpwfqwf_le.d(21): Error: found `sum_a` when expecting `.` following long\n/tmp/tmpwfqwf_le.d(21): Error: found `=` when expecting identifier following `long`.\n/tmp/tmpwfqwf_le.d(21): Error: found `0` when expecting `,`\n/tmp/tmpwfqwf_le.d(21): Error: expression expected, not `;`\n/tmp/tmpwfqwf_le.d(22): Error: found `long` when expecting `,`\n/tmp/tmpwfqwf_le.d(22): Error: found `;` when expecting `,`\n/tmp/tmpwfqwf_le.d(23): Error: expression expected, not `for`\n/tmp/tmpwfqwf_le.d(23): Error: found `i` when expecting `.` following int\n/tmp/tmpwfqwf_le.d(23): Error: found `=` when expecting identifier following `int`.\n/tmp/tmpwfqwf_le.d(23): Error: found `0` when expecting `,`\n/tmp/tmpwfqwf_le.d(23): Error: expression expected, not `;`\n/tmp/tmpwfqwf_le.d(23): Error: found `i` when expecting `,`\n/tmp/tmpwfqwf_le.d(23): Error: expression expected, not `<`\n/tmp/tmpwfqwf_le.d(23): Error: found ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n        long sum = 0;\n        for (int j = 0; j < nums[i] != 0; j++) {\n            sum += nums[i] % 10;\n            nums[i] /= 10;\n        }\n        result[i] = sum;\n    }\n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (result[i] == result[j]) {\n                result[i] = nums[i];\n                result[j] = nums[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmpbkoe3gy_.d(22): Error: found `!=` when expecting `;` following `for` condition\n/tmp/tmpbkoe3gy_.d(22): Error: found `;` when expecting `)`\n/tmp/tmpbkoe3gy_.d(22): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbkoe3gy_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    int[] sums = new int[10];\n    for (int i = 0; i < nums.length; i++) {\n        sums[nums[i] % 10]++;\n    }\n    for (int i = 0; i < sums.length; i++) {\n        for (int j = 0; j < sums[i]; j++) {\n            result[j + i * sums[i]] = nums[j + i * sums[i]];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp1jygifgn.d(22): Range violation\n----------------\n??:? _d_arrayboundsp [0x428c26]\n??:? long[] tmp1jygifgn.order_by_points(long[]) [0x42816c]\n??:? void tmp1jygifgn.__unittest_L31_C1() [0x4282f8]\n??:? void tmp1jygifgn.__modtest() [0x4288f8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ce37]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bcca]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430f55]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431404]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ee1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bca1]\n??:? runModuleUnitTests [0x42cc0d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int funct",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    for (int i = 0; i < nums.length; i++) {\n        long sum = 0;\n        for (int j = 0; j < nums[i] < 0 ? nums.length - 1 : nums.length; j++) {\n            sum += nums[j];\n        }\n        result[i] = sum;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmple33eza8.d(22): Error: found `<` when expecting `;` following `for` condition\n/tmp/tmple33eza8.d(22): Error: found `;` when expecting `)`\n/tmp/tmple33eza8.d(22): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmple33eza8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    int[] sums = new int[10];\n    for (int i = 0; i < nums.length; i++) {\n        sums[nums[i] % 10]++;\n    }\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < sums[i]; j++) {\n            result[j] = i;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpwlf4ggfu.d(22): Range violation\n----------------\n??:? _d_arrayboundsp [0x428b96]\n??:? long[] tmpwlf4ggfu.order_by_points(long[]) [0x42816c]\n??:? void tmpwlf4ggfu.__unittest_L31_C1() [0x428268]\n??:? void tmpwlf4ggfu.__modtest() [0x428868]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cda7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bc3a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ec5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431374]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430e51]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bc11]\n??:? runModuleUnitTests [0x42cb7d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428fa8]\n??:? void rt.dmain2._d_run_main(int, char**, e",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] sorted = nums.clone();\n    \n    for(int i = 0; i < sorted.length; i++)\n    {\n        long sum = 0;\n        for(int j = 0; j < sorted[i].length(); j++)\n        {\n            sum += sorted[i].charAt(j) - '0';\n        }\n        \n        for(int j = 0; j < sorted.length; j++)\n        {\n            if(sum == 0 && j != i)\n            {\n                long temp = sorted[i];\n                sorted[i] = sorted[j];\n                sorted[j] = temp;\n            }\n        }\n    }\n    \n    return sorted;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmpjdccv914.d(19): Error: no property `clone` for type `long[]`\n/tmp/tmpjdccv914.d(24): Error: no property `length` for type `long`\n/tmp/tmpjdccv914.d(26): Error: no property `charAt` for type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjdccv914.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    \n    for(int i = 0; i < nums.length; i++)\n    {\n        long sum = 0;\n        for(int j = 0; j < nums[i] != 0; j++)\n            sum += nums[i] % 10;\n        \n        for(int j = 0; j < nums.length; j++)\n        {\n            if(nums[j] == 0)\n                continue;\n            \n            if(sum == 0)\n            {\n                if(nums[i] < nums[j])\n                    result[i] = nums[i];\n                else\n                    result[i] = nums[j];\n                break;\n            }\n            \n            if(sum < 0)\n            {\n                if(nums[i] < nums[j])\n                    result[i] = nums[i];\n                else\n                    result[i] = nums[j];\n                break;\n            }\n            \n            if(sum > 0)\n            {\n                if(nums[i] < nums[j])\n                    result[i] = nums[i];\n                else\n                    result[i] = nums[j];\n                break;\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmp5wfn9r7c.d(24): Error: found `!=` when expecting `;` following `for` condition\n/tmp/tmp5wfn9r7c.d(24): Error: found `;` when expecting `)`\n/tmp/tmp5wfn9r7c.d(24): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5wfn9r7c.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    long[] sorted = new long[nums.length];\n    long[] temp = new long[nums.length];\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmpqn69y4w1.d(89): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqn69y4w1.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    long[] sorted = new long[nums.length];\n    int i = 0;\n    int j = 0;\n    long sum = 0;\n    for (i = 0; i < nums.length; i++) {\n        sum += nums[i];\n    }\n    for (i = 0; i < nums.length; i++) {\n        for (j = 0; j < nums.length; j++) {\n            if (nums[j] == nums[i]) {\n                result[i] = nums[i];\n                sorted[i] = nums[j];\n                break;\n            }\n        }\n    }\n    for (i = 0; i < nums.length; i++) {\n        for (j = 0; j < nums.length; j++) {\n            if (nums[j] == result[i]) {\n                result[i] = sorted[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpnufcu8ut.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x4289bd]\n??:? void tmpnufcu8ut.__unittest_L46_C1() [0x4281b5]\n??:? void tmpnufcu8ut.__modtest() [0x428740]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca9b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b92e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430bb9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431068]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430b45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b905]\n??:? runModuleUnitTests [0x42c871]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e80]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] sorted = nums.clone();\n    sort(sorted, (a, b) -> a - b);\n    return sorted;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmpajqv4yga.d(20): Error: expression expected, not `>`\n/tmp/tmpajqv4yga.d(20): Error: found `a` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpajqv4yga.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n        result[i] = nums[i];\n    }\n    \n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (nums[i] + nums[j] == nums[j] + nums[i]) {\n                result[i] = nums[i];\n                result[j] = nums[j];\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpuzy_ska8.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x42893d]\n??:? void tmpuzy_ska8.__unittest_L35_C1() [0x428131]\n??:? void tmpuzy_ska8.__modtest() [0x4286bc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca1b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8ae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b39]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fe8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ac5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b885]\n??:? runModuleUnitTests [0x42c7f1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e00]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n        result[i] = nums[i];\n    }\n    \n    for (int i = 0; i < nums.length - 1; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (nums[i] + nums[j] == nums[i] + nums[j]) {\n                result[i] = nums[i];\n                result[j] = nums[j];\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpau8o95ar.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x42894d]\n??:? void tmpau8o95ar.__unittest_L35_C1() [0x428141]\n??:? void tmpau8o95ar.__modtest() [0x4286cc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca2b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8be]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b49]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ff8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ad5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b895]\n??:? runModuleUnitTests [0x42c801]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e10]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    \n    for (int i = 0; i < result.length; i++) {\n        long sum = 0;\n        for (int j = 0; j < result[i].intValue(); j++) {\n            sum += Math.pow(10, j);\n        }\n        result[i] = sum;\n    }\n    \n    java.util.Arrays.sort(result);\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmpom01v1l_.d(19): Error: no property `clone` for type `long[]`\n/tmp/tmpom01v1l_.d(23): Error: no property `intValue` for type `long`\n/tmp/tmpom01v1l_.d(24): Error: undefined identifier `Math`\n/tmp/tmpom01v1l_.d(29): Error: undefined identifier `java`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpom01v1l_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    int n = nums.length;\n    \n    for(int i = 0; i < n; i++)\n    {\n        int sum = 0;\n        for(int j = 0; j < nums[i] != 0; j++)\n            sum += nums[i] % 10;\n        \n        for(int j = 0; j < n; j++)\n        {\n            if(sum == result[j])\n            {\n                result[i] = result[j];\n                result[j] = nums[i];\n                break;\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmpl5381x6b.d(25): Error: found `!=` when expecting `;` following `for` condition\n/tmp/tmpl5381x6b.d(25): Error: found `;` when expecting `)`\n/tmp/tmpl5381x6b.d(25): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl5381x6b.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n        result[i] = nums[i];\n    }\n    \n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (nums[i] + nums[j] == nums[i] + nums[j]) {\n                result[i] = nums[i];\n                result[j] = nums[j];\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpzohrpicm.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x42893d]\n??:? void tmpzohrpicm.__unittest_L35_C1() [0x428131]\n??:? void tmpzohrpicm.__modtest() [0x4286bc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca1b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8ae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b39]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fe8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ac5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b885]\n??:? runModuleUnitTests [0x42c7f1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e00]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n        result[i] = nums[i];\n    }\n    \n    for (int i = 0; i < nums.length - 1; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (nums[i] + nums[j] == nums[i] + nums[j]) {\n                result[i] = nums[i];\n                result[j] = nums[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp8_0fk5ta.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x42894d]\n??:? void tmp8_0fk5ta.__unittest_L34_C1() [0x428141]\n??:? void tmp8_0fk5ta.__modtest() [0x4286cc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca2b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8be]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b49]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ff8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ad5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b895]\n??:? runModuleUnitTests [0x42c801]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e10]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] sorted = nums.clone();\n    int n = nums.length;\n    for (int i = 0; i < n; i++) {\n        long sum = 0;\n        for (int j = 0; j < nums[i] * 10; j++) {\n            sum += Math.abs(j);\n        }\n        int index = i;\n        for (int j = i + 1; j < n; j++) {\n            if (sum < sum_of_digits(sorted[j])) {\n                index = j;\n            }\n        }\n        if (index != i) {\n            long temp = sorted[i];\n            sorted[i] = sorted[index];\n            sorted[index] = temp;\n        }\n    }\n    return sorted;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmptipmg8bu.d(19): Error: no property `clone` for type `long[]`\n/tmp/tmptipmg8bu.d(20): Error: cannot implicitly convert expression `nums.length` of type `ulong` to `int`\n/tmp/tmptipmg8bu.d(24): Error: undefined identifier `Math`\n/tmp/tmptipmg8bu.d(28): Error: undefined identifier `sum_of_digits`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptipmg8bu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    int[] sums = new int[10];\n    for(int i = 0; i < nums.length; i++)\n    {\n        sums[nums[i] % 10]++;\n    }\n    for(int i = 0; i < 10; i++)\n    {\n        for(int j = 0; j < sums[i]; j++)\n        {\n            result[j] = nums[j];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpd0gjao99.d(23): Range violation\n----------------\n??:? _d_arrayboundsp [0x428bce]\n??:? long[] tmpd0gjao99.order_by_points(long[]) [0x42816c]\n??:? void tmpd0gjao99.__unittest_L34_C1() [0x42829c]\n??:? void tmpd0gjao99.__modtest() [0x42889c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cddf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bc72]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430efd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4313ac]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430e89]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bc49]\n??:? runModuleUnitTests [0x42cbb5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int funct",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    long[] sums = new long[10];\n    for(int i = 0; i < nums.length; i++)\n    {\n        sums[nums[i] % 10] += nums[i];\n    }\n    for(int i = 0; i < sums.length; i++)\n    {\n        for(int j = 0; j < nums.length; j++)\n        {\n            if(sums[i] == nums[j])\n            {\n                result[j] = nums[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp5k_npl3t.d(23): Range violation\n----------------\n??:? _d_arrayboundsp [0x42898e]\n??:? long[] tmp5k_npl3t.order_by_points(long[]) [0x427ed2]\n??:? void tmp5k_npl3t.__unittest_L38_C1() [0x42805c]\n??:? void tmp5k_npl3t.__modtest() [0x42865c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b84e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ad9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f88]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a65]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b825]\n??:? runModuleUnitTests [0x42c791]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int funct",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    \n    for (int i = 0; i < result.length; i++) {\n        for (int j = i + 1; j < result.length; j++) {\n            if (result[i] + result[j] == 0) {\n                long temp = result[i];\n                result[i] = result[j];\n                result[j] = temp;\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmpyx606vcr.d(19): Error: no property `clone` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyx606vcr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    int[] index = new int[nums.length];\n    int[] sum = new int[nums.length];\n    \n    for (int i = 0; i < nums.length; i++) {\n        sum[i] = nums[i] % 10;\n        index[i] = i;\n    }\n    \n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (sum[i] == sum[j]) {\n                if (index[i] < index[j]) {\n                    result[i] = nums[i];\n                    result[j] = nums[j];\n                    index[i] = i;\n                    index[j] = j;\n                }\n            }\n        }\n    }\n    \n    for (int i = 0; i < nums.length; i++) {\n        result[index[i]] = nums[i];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpsfq2566u.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428d25]\n??:? void tmpsfq2566u.__unittest_L47_C1() [0x42851d]\n??:? void tmpsfq2566u.__modtest() [0x428aa8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cfe7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42be7a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x431105]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4315b4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431091]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42be51]\n??:? runModuleUnitTests [0x42cdbd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4291e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] sorted = nums.clone();\n    \n    for (int i = 0; i < sorted.length; i++) {\n        for (int j = i + 1; j < sorted.length; j++) {\n            if (sorted[i] + sorted[j] == sorted[i] * 10 + sorted[j]) {\n                long temp = sorted[i];\n                sorted[i] = sorted[j];\n                sorted[j] = temp;\n            }\n        }\n    }\n    \n    return sorted;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmp3kdiusbt.d(19): Error: no property `clone` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3kdiusbt.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    \n    for (int i = 0; i < result.length; i++) {\n        for (int j = i + 1; j < result.length; j++) {\n            if (result[i] + result[j] == 0) {\n                long temp = result[i];\n                result[i] = result[j];\n                result[j] = temp;\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmpyx606vcr.d(19): Error: no property `clone` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyx606vcr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n        long sum = 0;\n        for (int j = 0; j < nums[i] < 0 ? nums[i] * -1 : nums[i]; j++) {\n            sum += nums[i] % 10;\n        }\n        result[i] = sum;\n    }\n    \n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (result[i] == result[j]) {\n                result[i] = nums[i];\n                result[j] = nums[j];\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmpf07x60h4.d(22): Error: found `<` when expecting `;` following `for` condition\n/tmp/tmpf07x60h4.d(22): Error: found `;` when expecting `)`\n/tmp/tmpf07x60h4.d(22): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf07x60h4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    long[] sorted = new long[nums.length];\n    int[] index = new int[nums.length];\n    int[] sum = new int[nums.length];\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmpepnfl40j.d(88): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpepnfl40j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    for (int i = 0; i < nums.length; i++) {\n        long sum = 0;\n        for (int j = 0; j < nums[i] > 0; j++) {\n            sum += nums[i] % 10;\n            nums[i] /= 10;\n        }\n        if (sum > 0) {\n            for (int j = 0; j < nums.length; j++) {\n                if (nums[j] == sum) {\n                    result[i] = j;\n                    break;\n                }\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmph98byclp.d(22): Error: found `>` when expecting `;` following `for` condition\n/tmp/tmph98byclp.d(22): Error: found `;` when expecting `)`\n/tmp/tmph98byclp.d(22): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph98byclp.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    int[] count = new int[10];\n    for (int i = 0; i < nums.length; i++) {\n        count[nums[i] % 10]++;\n    }\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < count[i]; j++) {\n            result[j] = i;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpab2vcoq1.d(22): Range violation\n----------------\n??:? _d_arrayboundsp [0x428b96]\n??:? long[] tmpab2vcoq1.order_by_points(long[]) [0x42816c]\n??:? void tmpab2vcoq1.__unittest_L31_C1() [0x428268]\n??:? void tmpab2vcoq1.__modtest() [0x428868]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cda7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bc3a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ec5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431374]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430e51]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bc11]\n??:? runModuleUnitTests [0x42cb7d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int funct",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    int[] index = new int[nums.length];\n    int[] sum = new int[nums.length];\n    int i = 0;\n    for(long n : nums)\n    {\n        sum[i] = n % 10;\n        index[i] = i;\n        i++;\n    }\n    \n    for(int j = 0; j < nums.length; j++)\n    {\n        for(int k = j + 1; k < nums.length; k++)\n        {\n            if(sum[k] < sum[j])\n            {\n                long temp = nums[k];\n                nums[k] = nums[j];\n                nums[j] = temp;\n                int temp_index = index[k];\n                index[k] = index[j];\n                index[j] = temp_index;\n            }\n        }\n    }\n    \n    for(int j = 0; j < nums.length; j++)\n    {\n        result[index[j]] = nums[j];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmppo2vok4a.d(23): Error: semicolon expected, not `:`\n/tmp/tmppo2vok4a.d(23): Error: expression expected, not `:`\n/tmp/tmppo2vok4a.d(23): Error: found `nums` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppo2vok4a.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    int[] sums = new int[10];\n    for (int i = 0; i < nums.length; i++) {\n        sums[nums[i] % 10]++;\n    }\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < sums[i]; j++) {\n            result[j] = i;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpwlf4ggfu.d(22): Range violation\n----------------\n??:? _d_arrayboundsp [0x428b96]\n??:? long[] tmpwlf4ggfu.order_by_points(long[]) [0x42816c]\n??:? void tmpwlf4ggfu.__unittest_L31_C1() [0x428268]\n??:? void tmpwlf4ggfu.__modtest() [0x428868]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cda7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bc3a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ec5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431374]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430e51]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bc11]\n??:? runModuleUnitTests [0x42cb7d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428fa8]\n??:? void rt.dmain2._d_run_main(int, char**, e",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    int n = result.length;\n    int[] sums = new int[n];\n    for (int i = 0; i < n; i++) {\n        sums[i] = nums[i] % 10;\n        sums[i] += nums[i] / 10;\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (sums[i] == sums[j]) {\n                long temp = result[i];\n                result[i] = result[j];\n                result[j] = temp;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpo3zigqi0.d(19): Error: no property `clone` for type `long[]`\n/tmp/tmpo3zigqi0.d(20): Error: cannot implicitly convert expression `result.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo3zigqi0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    \n    for (int i = 0; i < nums.length; i++) {\n        int sum = 0;\n        for (int j = 0; j < nums[i] != 0; j++) {\n            sum += nums[i] % 10;\n            nums[i] /= 10;\n        }\n        result[i] = sum;\n    }\n    \n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (result[i] == result[j]) {\n                if (i < j) {\n                    long temp = result[i];\n                    result[i] = result[j];\n                    result[j] = temp;\n                }\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmpzuiji32u.d(23): Error: found `!=` when expecting `;` following `for` condition\n/tmp/tmpzuiji32u.d(23): Error: found `;` when expecting `)`\n/tmp/tmpzuiji32u.d(23): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzuiji32u.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    int[] sum = new int[10];\n    for (int i = 0; i < nums.length; i++) {\n        sum[nums[i] % 10]++;\n    }\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < sum[i]; j++) {\n            result[j] = i;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpe6kr4oez.d(22): Range violation\n----------------\n??:? _d_arrayboundsp [0x428b96]\n??:? long[] tmpe6kr4oez.order_by_points(long[]) [0x42816c]\n??:? void tmpe6kr4oez.__unittest_L31_C1() [0x428268]\n??:? void tmpe6kr4oez.__modtest() [0x428868]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cda7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bc3a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ec5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431374]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430e51]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bc11]\n??:? runModuleUnitTests [0x42cb7d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int funct",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    int n = nums.length;\n    for (int i = 0; i < n; i++) {\n        int sum = 0;\n        for (int j = 0; j < nums[i] < 0 ? nums[i] * -1 : nums[i]; j++) {\n            sum += nums[i] % 10;\n        }\n        for (int j = 0; j < n; j++) {\n            if (sum == result[j]) {\n                result[i] = nums[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmp2s7cuskd.d(23): Error: found `<` when expecting `;` following `for` condition\n/tmp/tmp2s7cuskd.d(23): Error: found `;` when expecting `)`\n/tmp/tmp2s7cuskd.d(23): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2s7cuskd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    long sum = 0;\n    for(int i = 0; i < nums.length; i++)\n    {\n        sum += nums[i];\n    }\n    for(int i = 0; i < nums.length; i++)\n    {\n        result[i] = nums[i];\n        for(int j = i + 1; j < nums.length; j++)\n        {\n            if(sum - nums[i] == sum - nums[j])\n            {\n                result[i] = nums[j];\n                break;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp7ry541fb.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x4288c5]\n??:? void tmp7ry541fb.__unittest_L39_C1() [0x4280bd]\n??:? void tmp7ry541fb.__modtest() [0x428648]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b836]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ac1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f70]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a4d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b80d]\n??:? runModuleUnitTests [0x42c779]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    int[] sorted = new int[nums.length];\n    int[] count = new int[10];\n    for (int i = 0; i < nums.length; i++) {\n        count[nums[i] % 10]++;\n    }\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < count[i]; j++) {\n            result[sorted[j]++] = i;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp0ldom7nd.d(23): Range violation\n----------------\n??:? _d_arrayboundsp [0x428bde]\n??:? long[] tmp0ldom7nd.order_by_points(long[]) [0x428184]\n??:? void tmp0ldom7nd.__unittest_L32_C1() [0x4282b0]\n??:? void tmp0ldom7nd.__modtest() [0x4288b0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cdef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bc82]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430f0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4313bc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430e99]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bc59]\n??:? runModuleUnitTests [0x42cbc5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int funct",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n        result[i] = nums[i];\n    }\n    \n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (nums[i] + nums[j] == nums[i] + nums[j]) {\n                result[i] = nums[i];\n                result[j] = nums[j];\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpzohrpicm.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x42893d]\n??:? void tmpzohrpicm.__unittest_L35_C1() [0x428131]\n??:? void tmpzohrpicm.__modtest() [0x4286bc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca1b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8ae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b39]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fe8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ac5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b885]\n??:? runModuleUnitTests [0x42c7f1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e00]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    int[] sums = new int[10];\n    for (int i = 0; i < nums.length; i++) {\n        sums[nums[i] % 10]++;\n    }\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < sums[i]; j++) {\n            result[j] = i;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpwlf4ggfu.d(22): Range violation\n----------------\n??:? _d_arrayboundsp [0x428b96]\n??:? long[] tmpwlf4ggfu.order_by_points(long[]) [0x42816c]\n??:? void tmpwlf4ggfu.__unittest_L31_C1() [0x428268]\n??:? void tmpwlf4ggfu.__modtest() [0x428868]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cda7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bc3a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ec5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431374]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430e51]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bc11]\n??:? runModuleUnitTests [0x42cb7d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428fa8]\n??:? void rt.dmain2._d_run_main(int, char**, e",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n        long sum = 0;\n        for (int j = 0; j < nums[i] < 0 ? nums[i] * -1 : nums[i]; j++) {\n            sum += nums[i] % 10;\n        }\n        result[i] = sum;\n    }\n    \n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (result[i] == result[j]) {\n                result[i] = nums[i];\n                result[j] = nums[j];\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmpf07x60h4.d(22): Error: found `<` when expecting `;` following `for` condition\n/tmp/tmpf07x60h4.d(22): Error: found `;` when expecting `)`\n/tmp/tmpf07x60h4.d(22): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf07x60h4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    \n    for (int i = 0; i < result.length; i++) {\n        for (int j = i + 1; j < result.length; j++) {\n            if (result[i] + result[j] == 0) {\n                long temp = result[i];\n                result[i] = result[j];\n                result[j] = temp;\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmpyx606vcr.d(19): Error: no property `clone` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyx606vcr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    int[] count = new int[10];\n    for (int i = 0; i < nums.length; i++) {\n        count[nums[i] % 10]++;\n    }\n    for (int i = 0; i < count.length; i++) {\n        for (int j = 0; j < count[i]; j++) {\n            result[j] = i;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpgmpn2_5p.d(22): Range violation\n----------------\n??:? _d_arrayboundsp [0x428b9e]\n??:? long[] tmpgmpn2_5p.order_by_points(long[]) [0x42816c]\n??:? void tmpgmpn2_5p.__unittest_L31_C1() [0x42826c]\n??:? void tmpgmpn2_5p.__modtest() [0x42886c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cdaf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bc42]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ecd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43137c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430e59]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bc19]\n??:? runModuleUnitTests [0x42cb85]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int funct",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    int[] index = new int[nums.length];\n    int[] sum = new int[nums.length];\n    int[] count = new int[nums.length];\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int sum_index = 0;\n    int sum_count = 0;\n    int sum_count_index = 0;\n    int sum_count_count = 0;\n    int sum_count_count_index = 0;\n    int sum_count_count_count = 0;\n    int sum_count_count_count_index = 0;\n    int sum_count_count_count_count = 0;\n    int sum_count_count_count_count_index = 0;\n    int sum_count_count_count_count_count = 0;\n    int sum_count_count_count_count_count_index = 0;\n    int sum_count_count_count_count_count_count = 0;\n    int sum_count_count_count_count_count_count_index = 0;\n    int sum_count_count_count_count_count_count_count = 0;\n    int sum_count_count_count_count_count_count_count_index = 0;\n    int sum_count_count_count_count_count_count_count_count = 0;\n    int sum_count_count_count_count_count_count_count_count_index = 0;\n    int sum_count_count_count_count_count_count_count_count_count = 0;\n    int sum_count_count_count_count_count_count_count_count_count_index = 0;\n    int sum_count_count_count_count_count_count_count_count_count_count = 0;\n    int sum_count_count_count_count_count_count_count_count_count_count_index = 0;\n    int sum_count_count_count_count_count_count_count_count_count_count_count = 0;\n    int sum_count_count_count_count_count_count\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpcmd9ocn8.d(49): Error: semicolon expected, not `unittest`\n/tmp/tmpcmd9ocn8.d(49): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcmd9ocn8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    \n    for (int i = 0; i < nums.length; i++)\n    {\n        long sum = 0;\n        for (int j = 0; j < nums[i] < 0 ? nums.length - 1 : 0; j++)\n        {\n            sum += nums[j];\n        }\n        \n        int index = i;\n        for (int j = i + 1; j < nums.length; j++)\n        {\n            if (sum == 0)\n            {\n                index = j;\n                break;\n            }\n            \n            if (sum < 0)\n            {\n                sum = sum * 10 + nums[j];\n            }\n            else\n            {\n                sum = sum - nums[j];\n            }\n        }\n        \n        if (index != i)\n        {\n            long temp = result[i];\n            result[i] = result[index];\n            result[index] = temp;\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpvpq99vp8.d(24): Error: found `<` when expecting `;` following `for` condition\n/tmp/tmpvpq99vp8.d(24): Error: found `;` when expecting `)`\n/tmp/tmpvpq99vp8.d(24): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvpq99vp8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    long[] temp = new long[nums.length];\n    int[] count = new int[10];\n    int[] index = new int[nums.length];\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int sum = 0;\n    for (i = 0; i < nums.length; i++) {\n        sum = 0;\n        for (j = 0; j < nums[i] && j < 10; j++) {\n            sum += nums[i] % 10;\n        }\n        count[sum]++;\n        index[i] = i;\n    }\n    for (i = 0; i < 10; i++) {\n        for (j = 0; j < count[i]; j++) {\n            temp[k++] = nums[index[j]];\n        }\n    }\n    for (i = 0; i < nums.length; i++) {\n        result[i] = temp[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpsnlslviv.d(32): Range violation\n----------------\n??:? _d_arrayboundsp [0x428d2e]\n??:? long[] tmpsnlslviv.order_by_points(long[]) [0x428201]\n??:? void tmpsnlslviv.__unittest_L45_C1() [0x4283fc]\n??:? void tmpsnlslviv.__modtest() [0x4289fc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cf3f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bdd2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43105d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43150c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430fe9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bda9]\n??:? runModuleUnitTests [0x42cd15]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int funct",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n        result[i] = nums[i];\n    }\n    \n    for (int i = 0; i < nums.length - 1; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (nums[i] + nums[j] == nums[i] + nums[j]) {\n                result[i] = nums[i];\n                result[j] = nums[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp8_0fk5ta.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x42894d]\n??:? void tmp8_0fk5ta.__unittest_L34_C1() [0x428141]\n??:? void tmp8_0fk5ta.__modtest() [0x4286cc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca2b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8be]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b49]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ff8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ad5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b895]\n??:? runModuleUnitTests [0x42c801]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e10]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    \n    for (int i = 0; i < result.length; i++)\n    {\n        long sum = 0;\n        for (int j = 0; j < result[i].toString().length(); j++)\n        {\n            sum += Math.pow(10, j) * result[i].toString().charAt(j) - Math.pow(10, j);\n        }\n        \n        for (int j = 0; j < result.length; j++)\n        {\n            if (sum == 0 && result[j] == 0)\n            {\n                result[i] = result[j];\n                break;\n            }\n            else if (sum < 0 && result[j] > 0)\n            {\n                result[i] = result[j];\n                break;\n            }\n            else if (sum > 0 && result[j] < 0)\n            {\n                result[i] = result[j];\n                break;\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmp18uqhh1c.d(19): Error: no property `clone` for type `long[]`\n/tmp/tmp18uqhh1c.d(24): Error: no property `toString` for type `long`\n/tmp/tmp18uqhh1c.d(26): Error: undefined identifier `Math`\n/tmp/tmp18uqhh1c.d(26): Error: no property `toString` for type `long`\n/tmp/tmp18uqhh1c.d(26): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp18uqhh1c.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n        long sum = 0;\n        for (int j = 0; j < nums[i] < 0 ? nums[i] * -1 : nums[i]; j++) {\n            sum += nums[i] % 10;\n        }\n        result[i] = sum;\n    }\n    \n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (result[i] == result[j]) {\n                result[i] = nums[i];\n                result[j] = nums[j];\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmpf07x60h4.d(22): Error: found `<` when expecting `;` following `for` condition\n/tmp/tmpf07x60h4.d(22): Error: found `;` when expecting `)`\n/tmp/tmpf07x60h4.d(22): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf07x60h4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    int[] index = new int[nums.length];\n    int[] sum = new int[nums.length];\n    \n    for(int i = 0; i < nums.length; i++)\n    {\n        sum[i] = nums[i] % 10;\n        index[i] = i;\n    }\n    \n    for(int i = 0; i < nums.length; i++)\n    {\n        for(int j = i + 1; j < nums.length; j++)\n        {\n            if(sum[i] == sum[j])\n            {\n                if(index[i] < index[j])\n                {\n                    long temp = nums[i];\n                    nums[i] = nums[j];\n                    nums[j] = temp;\n                }\n            }\n        }\n    }\n    \n    for(int i = 0; i < nums.length; i++)\n    {\n        result[i] = nums[i];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp3_i831bm.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x428cad]\n??:? void tmp3_i831bm.__unittest_L52_C1() [0x4284a5]\n??:? void tmp3_i831bm.__modtest() [0x428a30]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cf6f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42be02]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43108d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43153c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431019]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bdd9]\n??:? runModuleUnitTests [0x42cd45]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429170]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    \n    for (int i = 0; i < result.length; i++) {\n        for (int j = i + 1; j < result.length; j++) {\n            if (sum_of_digits(result[i]) > sum_of_digits(result[j])) {\n                long temp = result[i];\n                result[i] = result[j];\n                result[j] = temp;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpyayl9onh.d(19): Error: no property `clone` for type `long[]`\n/tmp/tmpyayl9onh.d(23): Error: undefined identifier `sum_of_digits`\n/tmp/tmpyayl9onh.d(23): Error: undefined identifier `sum_of_digits`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyayl9onh.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] sorted = nums.clone();\n    sort(sorted, (a, b) -> {\n        long sum_a = 0;\n        long sum_b = 0;\n        for (int i = 0; i < Math.min(a.length(), b.length()); i++) {\n            sum_a += a[i] * Math.pow(10, a.length() - i - 1);\n            sum_b += b[i] * Math.pow(10, b.length() - i - 1);\n        }\n        return sum_a - sum_b;\n    });\n    return sorted;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpo3ymzv3k.d(20): Error: expression expected, not `>`\n/tmp/tmpo3ymzv3k.d(20): Error: found `{` when expecting `,`\n/tmp/tmpo3ymzv3k.d(21): Error: found `sum_a` when expecting `.` following long\n/tmp/tmpo3ymzv3k.d(21): Error: found `=` when expecting identifier following `long`.\n/tmp/tmpo3ymzv3k.d(21): Error: found `0` when expecting `,`\n/tmp/tmpo3ymzv3k.d(21): Error: expression expected, not `;`\n/tmp/tmpo3ymzv3k.d(22): Error: found `long` when expecting `,`\n/tmp/tmpo3ymzv3k.d(22): Error: found `;` when expecting `,`\n/tmp/tmpo3ymzv3k.d(23): Error: expression expected, not `for`\n/tmp/tmpo3ymzv3k.d(23): Error: found `i` when expecting `.` following int\n/tmp/tmpo3ymzv3k.d(23): Error: found `=` when expecting identifier following `int`.\n/tmp/tmpo3ymzv3k.d(23): Error: found `0` when expecting `,`\n/tmp/tmpo3ymzv3k.d(23): Error: expression expected, not `;`\n/tmp/tmpo3ymzv3k.d(23): Error: found `i` when expecting `,`\n/tmp/tmpo3ymzv3k.d(23): Error: expression expected, not `<`\n/tmp/tmpo3ymzv3k.d(23): Error: found ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n        int sum = 0;\n        for (int j = 0; j < nums[i] < 0 ? nums[i] * -1 : nums[i]; j++) {\n            sum += nums[i] % 10;\n        }\n        result[i] = sum;\n    }\n    \n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (result[i] == result[j]) {\n                if (nums[i] < 0) {\n                    result[i] = -1;\n                } else {\n                    result[i] = 1;\n                }\n                result[j] = 0;\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmprooh229w.d(22): Error: found `<` when expecting `;` following `for` condition\n/tmp/tmprooh229w.d(22): Error: found `;` when expecting `)`\n/tmp/tmprooh229w.d(22): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprooh229w.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    \n    for (int i = 0; i < result.length; i++) {\n        for (int j = i + 1; j < result.length; j++) {\n            if (result[i] + result[j] == 0) {\n                long temp = result[i];\n                result[i] = result[j];\n                result[j] = temp;\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmpyx606vcr.d(19): Error: no property `clone` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyx606vcr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    for (int i = 0; i < result.length; i++) {\n        for (int j = i + 1; j < result.length; j++) {\n            if (result[i] + result[j] == result[i] + result[j]) {\n                long temp = result[i];\n                result[i] = result[j];\n                result[j] = temp;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpx29e17m_.d(19): Error: no property `clone` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx29e17m_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    int[] map = new int[10];\n    for(int i = 0; i < 10; i++)\n        map[i] = 0;\n    for(int i = 0; i < nums.length; i++)\n    {\n        int sum = 0;\n        while(nums[i] != 0)\n        {\n            sum += nums[i] % 10;\n            nums[i] /= 10;\n        }\n        if(map[sum] == 0)\n            map[sum] = i;\n        else\n            map[sum] = i;\n    }\n    for(int i = 0; i < nums.length; i++)\n        result[i] = nums[map[i]];\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpkfwmsvk6.d(31): Range violation\n----------------\n??:? _d_arrayboundsp [0x428cce]\n??:? long[] tmpkfwmsvk6.order_by_points(long[]) [0x42821f]\n??:? void tmpkfwmsvk6.__unittest_L40_C1() [0x42839c]\n??:? void tmpkfwmsvk6.__modtest() [0x42899c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cedf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bd72]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ffd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4314ac]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430f89]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bd49]\n??:? runModuleUnitTests [0x42ccb5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int funct",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (nums[i] + nums[j] == nums[i] + nums[j]) {\n                long temp = nums[i];\n                nums[i] = nums[j];\n                nums[j] = temp;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmp76s993ya.d(19): Error: no property `clone` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp76s993ya.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    int n = nums.length;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (nums[i] + nums[j] == nums[i] + nums[j]) {\n                long temp = nums[i];\n                nums[i] = nums[j];\n                nums[j] = temp;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmp4jklutch.d(19): Error: no property `clone` for type `long[]`\n/tmp/tmp4jklutch.d(20): Error: cannot implicitly convert expression `nums.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4jklutch.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    long[] temp = new long[nums.length];\n    int[] count = new int[10];\n    int[] sum = new int[10];\n    int i = 0;\n    for(long num : nums)\n    {\n        count[(int)Math.floor(num/10)]++;\n        sum[(int)Math.floor(num/10)] += num;\n    }\n    for(int j = 0; j < 10; j++)\n    {\n        for(int k = 0; k < count[j]; k++)\n        {\n            temp[i++] = sum[j];\n        }\n    }\n    for(int l = 0; l < nums.length; l++)\n    {\n        result[l] = temp[l];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpkxdll5im.d(24): Error: semicolon expected, not `:`\n/tmp/tmpkxdll5im.d(24): Error: expression expected, not `:`\n/tmp/tmpkxdll5im.d(24): Error: found `nums` when expecting `;` following `for` condition\n/tmp/tmpkxdll5im.d(26): Error: C style cast illegal, use `cast(int)Math.floor(num / 10)`\n/tmp/tmpkxdll5im.d(27): Error: C style cast illegal, use `cast(int)Math.floor(num / 10)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkxdll5im.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    for (int i = 0; i < result.length; i++) {\n        for (int j = i + 1; j < result.length; j++) {\n            if (result[i] + result[j] == 0) {\n                long temp = result[i];\n                result[i] = result[j];\n                result[j] = temp;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmpe_cjpj5_.d(19): Error: no property `clone` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_cjpj5_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    for (int i = 0; i < result.length; i++) {\n        for (int j = i + 1; j < result.length; j++) {\n            if (result[i] + result[j] == 0) {\n                long temp = result[i];\n                result[i] = result[j];\n                result[j] = temp;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmpe_cjpj5_.d(19): Error: no property `clone` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_cjpj5_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n        result[i] = nums[i];\n    }\n    \n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (nums[i] + nums[j] == nums[i] + nums[j]) {\n                result[i] = nums[i];\n                result[j] = nums[j];\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpzohrpicm.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x42893d]\n??:? void tmpzohrpicm.__unittest_L35_C1() [0x428131]\n??:? void tmpzohrpicm.__modtest() [0x4286bc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca1b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8ae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b39]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fe8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ac5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b885]\n??:? runModuleUnitTests [0x42c7f1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e00]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n        result[i] = nums[i];\n    }\n    \n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (nums[i] + nums[j] == nums[i] + nums[j]) {\n                result[i] = nums[i];\n                result[j] = nums[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpms6omf7s.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x42893d]\n??:? void tmpms6omf7s.__unittest_L34_C1() [0x428131]\n??:? void tmpms6omf7s.__modtest() [0x4286bc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca1b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8ae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b39]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fe8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ac5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b885]\n??:? runModuleUnitTests [0x42c7f1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e00]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int sum = 0;\n    while (i < nums.length) {\n        sum = 0;\n        while (i < nums.length && sum < 10) {\n            sum += nums[i];\n            i++;\n        }\n        if (j < k) {\n            result[j] = nums[k];\n            k++;\n        }\n        else if (j > k) {\n            result[k] = nums[j];\n            j++;\n        }\n        else {\n            result[k] = nums[i];\n            k++;\n            i++;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp3_0r_638.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x4288c5]\n??:? void tmp3_0r_638.__unittest_L46_C1() [0x4280b9]\n??:? void tmp3_0r_638.__modtest() [0x428644]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b836]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ac1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f70]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a4d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b80d]\n??:? runModuleUnitTests [0x42c779]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    for (int i = 0; i < result.length; i++) {\n        for (int j = i + 1; j < result.length; j++) {\n            if (sum_of_digits(result[i]) == sum_of_digits(result[j])) {\n                result[i] = -1L;\n                result[j] = -1L;\n            }\n        }\n    }\n    for (int i = 0; i < result.length; i++) {\n        if (result[i] == -1L) {\n            result[i] = -1L;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpdqq3_lty.d(19): Error: no property `clone` for type `long[]`\n/tmp/tmpdqq3_lty.d(22): Error: undefined identifier `sum_of_digits`\n/tmp/tmpdqq3_lty.d(22): Error: undefined identifier `sum_of_digits`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdqq3_lty.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] sorted = nums.clone();\n    sort(sorted, (a, b) -> {\n        long sum_a = 0;\n        long sum_b = 0;\n        for (int i = 0; i < a.length(); i++) {\n            sum_a += a.charAt(i) - '0';\n        }\n        for (int i = 0; i < b.length(); i++) {\n            sum_b += b.charAt(i) - '0';\n        }\n        return sum_a - sum_b;\n    });\n    return sorted;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpb_mjriyu.d(20): Error: expression expected, not `>`\n/tmp/tmpb_mjriyu.d(20): Error: found `{` when expecting `,`\n/tmp/tmpb_mjriyu.d(21): Error: found `sum_a` when expecting `.` following long\n/tmp/tmpb_mjriyu.d(21): Error: found `=` when expecting identifier following `long`.\n/tmp/tmpb_mjriyu.d(21): Error: found `0` when expecting `,`\n/tmp/tmpb_mjriyu.d(21): Error: expression expected, not `;`\n/tmp/tmpb_mjriyu.d(22): Error: found `long` when expecting `,`\n/tmp/tmpb_mjriyu.d(22): Error: found `;` when expecting `,`\n/tmp/tmpb_mjriyu.d(23): Error: expression expected, not `for`\n/tmp/tmpb_mjriyu.d(23): Error: found `i` when expecting `.` following int\n/tmp/tmpb_mjriyu.d(23): Error: found `=` when expecting identifier following `int`.\n/tmp/tmpb_mjriyu.d(23): Error: found `0` when expecting `,`\n/tmp/tmpb_mjriyu.d(23): Error: expression expected, not `;`\n/tmp/tmpb_mjriyu.d(23): Error: found `i` when expecting `,`\n/tmp/tmpb_mjriyu.d(23): Error: expression expected, not `<`\n/tmp/tmpb_mjriyu.d(23): Error: found ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    for (int i = 0; i < result.length; i++) {\n        for (int j = i + 1; j < result.length; j++) {\n            if (result[i] + result[j] == result[i] + result[j]) {\n                long temp = result[i];\n                result[i] = result[j];\n                result[j] = temp;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpx29e17m_.d(19): Error: no property `clone` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx29e17m_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    \n    for(int i = 0; i < result.length; i++)\n    {\n        for(int j = i + 1; j < result.length; j++)\n        {\n            if(sum_of_digits(result[i]) < sum_of_digits(result[j]))\n            {\n                long temp = result[i];\n                result[i] = result[j];\n                result[j] = temp;\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpc6pdbs3i.d(19): Error: no property `clone` for type `long[]`\n/tmp/tmpc6pdbs3i.d(25): Error: undefined identifier `sum_of_digits`\n/tmp/tmpc6pdbs3i.d(25): Error: undefined identifier `sum_of_digits`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc6pdbs3i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    for (int i = 0; i < result.length; i++) {\n        for (int j = i + 1; j < result.length; j++) {\n            if (sum_of_digits(result[i]) > sum_of_digits(result[j])) {\n                long temp = result[i];\n                result[i] = result[j];\n                result[j] = temp;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmp6w5c_eyl.d(19): Error: no property `clone` for type `long[]`\n/tmp/tmp6w5c_eyl.d(22): Error: undefined identifier `sum_of_digits`\n/tmp/tmp6w5c_eyl.d(22): Error: undefined identifier `sum_of_digits`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6w5c_eyl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    for (int i = 0; i < result.length; i++) {\n        for (int j = i + 1; j < result.length; j++) {\n            if (result[i] + result[j] == 0) {\n                long temp = result[i];\n                result[i] = result[j];\n                result[j] = temp;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmpe_cjpj5_.d(19): Error: no property `clone` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_cjpj5_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] sorted = new long[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n        sorted[i] = nums[i];\n    }\n    \n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (nums[i] + nums[j] == nums[i] + nums[j]) {\n                sorted[i] = nums[i];\n                sorted[j] = nums[j];\n            }\n        }\n    }\n    \n    return sorted;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmplii_xmwp.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x42893d]\n??:? void tmplii_xmwp.__unittest_L35_C1() [0x428131]\n??:? void tmplii_xmwp.__modtest() [0x4286bc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca1b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8ae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b39]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fe8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ac5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b885]\n??:? runModuleUnitTests [0x42c7f1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e00]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] sorted_nums = new long[nums.length];\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int sum = 0;\n    while (i < nums.length) {\n        sum = 0;\n        while (i < nums.length && nums[i] != 0) {\n            sum += nums[i];\n            i++;\n        }\n        if (i < nums.length) {\n            sum += nums[i];\n            i++;\n        }\n        if (j < k) {\n            if (sum < sorted_nums[j]) {\n                j++;\n                sorted_nums[j] = sum;\n            }\n        } else {\n            sorted_nums[j] = sum;\n            j++;\n        }\n        k++;\n    }\n    return sorted_nums;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpx0mkpu1v.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x4288ad]\n??:? void tmpx0mkpu1v.__unittest_L47_C1() [0x4280a5]\n??:? void tmpx0mkpu1v.__modtest() [0x428630]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c98b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b81e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430aa9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f58]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a35]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7f5]\n??:? runModuleUnitTests [0x42c761]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d70]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] sorted = nums.clone();\n    \n    for (int i = 0; i < sorted.length; i++) {\n        int sum = 0;\n        for (int j = 0; j < sorted[i].toString().length(); j++) {\n            sum += Math.pow(10, j) * (sorted[i] % 10);\n        }\n        \n        for (int j = 0; j < sorted.length; j++) {\n            if (sum == Math.pow(10, j) * (sorted[j] % 10)) {\n                long temp = sorted[i];\n                sorted[i] = sorted[j];\n                sorted[j] = temp;\n            }\n        }\n    }\n    \n    return sorted;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpcduxzkp4.d(19): Error: no property `clone` for type `long[]`\n/tmp/tmpcduxzkp4.d(23): Error: no property `toString` for type `long`\n/tmp/tmpcduxzkp4.d(24): Error: undefined identifier `Math`\n/tmp/tmpcduxzkp4.d(28): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcduxzkp4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    for (int i = 0; i < result.length; i++) {\n        for (int j = i + 1; j < result.length; j++) {\n            if (result[i] + result[j] == result[i] + result[j]) {\n                long temp = result[i];\n                result[i] = result[j];\n                result[j] = temp;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpx29e17m_.d(19): Error: no property `clone` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx29e17m_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n        long sum = 0;\n        for (int j = 0; j < nums[i] != 0; j++) {\n            sum += nums[i] % 10;\n            nums[i] /= 10;\n        }\n        result[i] = sum;\n    }\n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (result[i] == result[j]) {\n                long temp = nums[i];\n                nums[i] = nums[j];\n                nums[j] = temp;\n            }\n        }\n    }\n    return nums;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmporpsosmm.d(22): Error: found `!=` when expecting `;` following `for` condition\n/tmp/tmporpsosmm.d(22): Error: found `;` when expecting `)`\n/tmp/tmporpsosmm.d(22): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmporpsosmm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    long[] sorted = new long[nums.length];\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int sum = 0;\n    while (i < nums.length) {\n        sum = 0;\n        while (i < nums.length && nums[i] != 0) {\n            sum += nums[i];\n            i++;\n        }\n        if (sum == 0) {\n            result[k] = 0;\n            k++;\n        }\n        else {\n            while (j < i) {\n                sum -= nums[j];\n                if (sum == 0) {\n                    result[k] = nums[j];\n                    k++;\n                    break;\n                }\n                j++;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp2bih3kt0.d(53): unittest failure\n----------------\n??:? _d_unittestp [0x4288bd]\n??:? void tmp2bih3kt0.__unittest_L49_C1() [0x4280b1]\n??:? void tmp2bih3kt0.__modtest() [0x42863c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c99b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b82e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b805]\n??:? runModuleUnitTests [0x42c771]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d80]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    long sum = 0;\n    for(int i = 0; i < nums.length; i++)\n    {\n        sum += nums[i];\n    }\n    for(int i = 0; i < nums.length; i++)\n    {\n        result[i] = nums[i];\n        for(int j = i + 1; j < nums.length; j++)\n        {\n            if(sum - nums[i] == sum - nums[j])\n            {\n                result[i] = nums[j];\n                break;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp7ry541fb.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x4288c5]\n??:? void tmp7ry541fb.__unittest_L39_C1() [0x4280bd]\n??:? void tmp7ry541fb.__modtest() [0x428648]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b836]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ac1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f70]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a4d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b80d]\n??:? runModuleUnitTests [0x42c779]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n        long sum = 0;\n        for (int j = 0; j < nums[i].toString().length(); j++) {\n            sum += nums[i].toString().charAt(j) - '0';\n        }\n        result[i] = sum;\n    }\n    \n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (result[i] == result[j]) {\n                result[i] = nums[i];\n                result[j] = nums[j];\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmptk2xd_y9.d(22): Error: no property `toString` for type `long`\n/tmp/tmptk2xd_y9.d(23): Error: no property `toString` for type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptk2xd_y9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    int[] sum = new int[10];\n    for(int i = 0; i < nums.length; i++)\n        sum[nums[i] % 10]++;\n    for(int i = 0; i < 10; i++)\n        for(int j = 0; j < sum[i]; j++)\n            result[j] = i;\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp9qvhb600.d(22): Range violation\n----------------\n??:? _d_arrayboundsp [0x428b96]\n??:? long[] tmp9qvhb600.order_by_points(long[]) [0x42816c]\n??:? void tmp9qvhb600.__unittest_L28_C1() [0x428268]\n??:? void tmp9qvhb600.__modtest() [0x428868]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cda7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bc3a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ec5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431374]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430e51]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bc11]\n??:? runModuleUnitTests [0x42cb7d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int funct",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    int[] index = new int[nums.length];\n    int[] sum = new int[nums.length];\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int sum_index = 0;\n    int sum_value = 0;\n    int sum_value_index = 0;\n    while (i < nums.length) {\n        sum[i] = nums[i];\n        i++;\n    }\n    while (j < nums.length) {\n        sum_value = 0;\n        sum_value_index = 0;\n        while (k < nums.length) {\n            sum_value += nums[k];\n            k++;\n        }\n        if (sum_value_index < sum_value) {\n            sum_value_index = sum_value;\n            sum_index = j;\n        }\n        j++;\n    }\n    for (i = 0; i < nums.length; i++) {\n        result[i] = nums[i];\n        index[i] = i;\n    }\n    for (i = 0; i < nums.length; i++) {\n        if (sum_index == i) {\n            result[i] = nums[i];\n            index[i] = i;\n        }\n    }\n    for (i = 0; i < nums.length; i++) {\n        if (index[i] != i) {\n            long temp = result[i];\n            result[i] = result[index[i]];\n            result[index[i]] = temp;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpn5kdipq6.d(29): Error: cannot implicitly convert expression `nums[cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn5kdipq6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    int[] indexes = new int[nums.length];\n    int[] sums = new int[nums.length];\n    \n    for(int i = 0; i < nums.length; i++)\n    {\n        sums[i] = nums[i] % 10;\n        sums[i] += nums[i] / 10;\n    }\n    \n    for(int i = 0; i < nums.length; i++)\n    {\n        for(int j = 0; j < nums.length; j++)\n        {\n            if(sums[i] == sums[j])\n            {\n                indexes[i] = j;\n                break;\n            }\n        }\n    }\n    \n    for(int i = 0; i < nums.length; i++)\n    {\n        result[indexes[i]] = nums[i];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp31kx8nmt.d(52): unittest failure\n----------------\n??:? _d_unittestp [0x428c45]\n??:? void tmp31kx8nmt.__unittest_L48_C1() [0x428439]\n??:? void tmp31kx8nmt.__modtest() [0x4289c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cf07]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bd9a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x431025]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4314d4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430fb1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bd71]\n??:? runModuleUnitTests [0x42ccdd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429108]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n        result[i] = nums[i];\n    }\n    \n    for (int i = 0; i < nums.length - 1; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (nums[i] + nums[j] == nums[i] + nums[j]) {\n                result[i] = nums[i];\n                result[j] = nums[j];\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpau8o95ar.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x42894d]\n??:? void tmpau8o95ar.__unittest_L35_C1() [0x428141]\n??:? void tmpau8o95ar.__modtest() [0x4286cc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca2b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8be]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b49]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ff8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ad5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b895]\n??:? runModuleUnitTests [0x42c801]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e10]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    int[] index = new int[nums.length];\n    int[] sum = new int[nums.length];\n    \n    for(int i = 0; i < nums.length; i++)\n    {\n        sum[i] = nums[i] % 10;\n        index[i] = i;\n    }\n    \n    for(int i = 0; i < nums.length; i++)\n    {\n        for(int j = i + 1; j < nums.length; j++)\n        {\n            if(sum[i] == sum[j])\n            {\n                if(index[i] < index[j])\n                {\n                    long temp = nums[i];\n                    nums[i] = nums[j];\n                    nums[j] = temp;\n                }\n            }\n        }\n    }\n    \n    for(int i = 0; i < nums.length; i++)\n    {\n        result[i] = nums[i];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp3_i831bm.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x428cad]\n??:? void tmp3_i831bm.__unittest_L52_C1() [0x4284a5]\n??:? void tmp3_i831bm.__modtest() [0x428a30]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cf6f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42be02]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43108d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43153c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431019]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bdd9]\n??:? runModuleUnitTests [0x42cd45]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429170]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] sorted = new long[nums.length];\n    int i = 0;\n    for (long num : nums) {\n        long sum = 0;\n        while (num != 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        sorted[i++] = sum;\n    }\n    Arrays.sort(sorted);\n    return sorted;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpdw7qi36e.d(21): Error: semicolon expected, not `:`\n/tmp/tmpdw7qi36e.d(21): Error: expression expected, not `:`\n/tmp/tmpdw7qi36e.d(21): Error: found `nums` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdw7qi36e.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n        long sum = 0;\n        for (int j = 0; j < nums[i].toString().length(); j++) {\n            sum += nums[i].toString().charAt(j) - '0';\n        }\n        result[i] = sum;\n    }\n    \n    java.util.Arrays.sort(result);\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmp5hv0cdbu.d(22): Error: no property `toString` for type `long`\n/tmp/tmp5hv0cdbu.d(23): Error: no property `toString` for type `long`\n/tmp/tmp5hv0cdbu.d(28): Error: undefined identifier `java`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5hv0cdbu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] sorted = nums.clone();\n    sort(sorted, (a, b) -> {\n        long sum_a = 0;\n        long sum_b = 0;\n        for (int i = 0; i < Math.min(a.length(), b.length()); i++) {\n            sum_a += Math.abs(a[i] % 10);\n            sum_b += Math.abs(b[i] % 10);\n        }\n        return sum_a - sum_b;\n    });\n    return sorted;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpe3_65m0i.d(20): Error: expression expected, not `>`\n/tmp/tmpe3_65m0i.d(20): Error: found `{` when expecting `,`\n/tmp/tmpe3_65m0i.d(21): Error: found `sum_a` when expecting `.` following long\n/tmp/tmpe3_65m0i.d(21): Error: found `=` when expecting identifier following `long`.\n/tmp/tmpe3_65m0i.d(21): Error: found `0` when expecting `,`\n/tmp/tmpe3_65m0i.d(21): Error: expression expected, not `;`\n/tmp/tmpe3_65m0i.d(22): Error: found `long` when expecting `,`\n/tmp/tmpe3_65m0i.d(22): Error: found `;` when expecting `,`\n/tmp/tmpe3_65m0i.d(23): Error: expression expected, not `for`\n/tmp/tmpe3_65m0i.d(23): Error: found `i` when expecting `.` following int\n/tmp/tmpe3_65m0i.d(23): Error: found `=` when expecting identifier following `int`.\n/tmp/tmpe3_65m0i.d(23): Error: found `0` when expecting `,`\n/tmp/tmpe3_65m0i.d(23): Error: expression expected, not `;`\n/tmp/tmpe3_65m0i.d(23): Error: found `i` when expecting `,`\n/tmp/tmpe3_65m0i.d(23): Error: expression expected, not `<`\n/tmp/tmpe3_65m0i.d(23): Error: found ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    for(int i = 0; i < nums.length; i++)\n    {\n        result[i] = nums[i];\n    }\n    \n    for(int i = 0; i < nums.length; i++)\n    {\n        for(int j = i + 1; j < nums.length; j++)\n        {\n            if(nums[i] + nums[j] == nums[i] + nums[j])\n            {\n                result[i] = nums[i];\n                result[j] = nums[j];\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpz0v1fbru.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x42893d]\n??:? void tmpz0v1fbru.__unittest_L39_C1() [0x428131]\n??:? void tmpz0v1fbru.__modtest() [0x4286bc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca1b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8ae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b39]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fe8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ac5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b885]\n??:? runModuleUnitTests [0x42c7f1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e00]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    long[] sums = new long[10];\n    for (int i = 0; i < nums.length; i++) {\n        sums[nums[i] % 10] += nums[i];\n    }\n    for (int i = 0; i < sums.length; i++) {\n        for (int j = 0; j < nums.length; j++) {\n            if (sums[i] == nums[j]) {\n                result[j] = nums[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpz_wktjul.d(22): Range violation\n----------------\n??:? _d_arrayboundsp [0x42898e]\n??:? long[] tmpz_wktjul.order_by_points(long[]) [0x427ed2]\n??:? void tmpz_wktjul.__unittest_L34_C1() [0x42805c]\n??:? void tmpz_wktjul.__modtest() [0x42865c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b84e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ad9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f88]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a65]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b825]\n??:? runModuleUnitTests [0x42c791]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int funct",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] sorted_nums = new long[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n        long sum = 0;\n        for (int j = 0; j < nums[i].toString().length(); j++) {\n            sum += nums[i].toString().charAt(j) - '0';\n        }\n        sorted_nums[i] = nums[i];\n        for (int j = i + 1; j < nums.length; j++) {\n            if (sum == 0) {\n                sorted_nums[i] = nums[j];\n                break;\n            }\n            if (sum < 0) {\n                sum = sum * 10 + nums[j].toString().charAt(0) - '0';\n            } else {\n                sum = sum * 10 + nums[j].toString().charAt(1) - '0';\n            }\n        }\n    }\n    return sorted_nums;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmp4uxtraqs.d(22): Error: no property `toString` for type `long`\n/tmp/tmp4uxtraqs.d(23): Error: no property `toString` for type `long`\n/tmp/tmp4uxtraqs.d(32): Error: no property `toString` for type `long`\n/tmp/tmp4uxtraqs.d(34): Error: no property `toString` for type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4uxtraqs.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    int[] indexes = new int[nums.length];\n    int[] sums = new int[nums.length];\n    \n    for (int i = 0; i < nums.length; i++) {\n        sums[i] = nums[i] % 10;\n        sums[i] += nums[i] / 10;\n    }\n    \n    for (int i = 0; i < nums.length; i++) {\n        indexes[i] = i;\n    }\n    \n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (sums[i] == sums[j]) {\n                if (indexes[i] < indexes[j]) {\n                    indexes[i] = indexes[j];\n                }\n            }\n        }\n    }\n    \n    for (int i = 0; i < nums.length; i++) {\n        result[indexes[i]] = nums[i];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp10xkcd03.d(52): unittest failure\n----------------\n??:? _d_unittestp [0x428ced]\n??:? void tmp10xkcd03.__unittest_L48_C1() [0x4284e1]\n??:? void tmp10xkcd03.__modtest() [0x428a6c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cfaf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42be42]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4310cd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43157c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431059]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42be19]\n??:? runModuleUnitTests [0x42cd85]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4291b0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    int[] sums = new int[10];\n    for (int i = 0; i < nums.length; i++) {\n        sums[nums[i] % 10]++;\n    }\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < sums[i]; j++) {\n            result[j] = i;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpwlf4ggfu.d(22): Range violation\n----------------\n??:? _d_arrayboundsp [0x428b96]\n??:? long[] tmpwlf4ggfu.order_by_points(long[]) [0x42816c]\n??:? void tmpwlf4ggfu.__unittest_L31_C1() [0x428268]\n??:? void tmpwlf4ggfu.__modtest() [0x428868]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cda7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bc3a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ec5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431374]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430e51]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bc11]\n??:? runModuleUnitTests [0x42cb7d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428fa8]\n??:? void rt.dmain2._d_run_main(int, char**, e",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] sorted = nums.clone();\n    sort(sorted, (a, b) -> {\n        long sum_a = 0;\n        long sum_b = 0;\n        for (int i = 0; i < a.length(); i++) {\n            sum_a += a.charAt(i) - '0';\n        }\n        for (int i = 0; i < b.length(); i++) {\n            sum_b += b.charAt(i) - '0';\n        }\n        return sum_a - sum_b;\n    });\n    return sorted;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpb_mjriyu.d(20): Error: expression expected, not `>`\n/tmp/tmpb_mjriyu.d(20): Error: found `{` when expecting `,`\n/tmp/tmpb_mjriyu.d(21): Error: found `sum_a` when expecting `.` following long\n/tmp/tmpb_mjriyu.d(21): Error: found `=` when expecting identifier following `long`.\n/tmp/tmpb_mjriyu.d(21): Error: found `0` when expecting `,`\n/tmp/tmpb_mjriyu.d(21): Error: expression expected, not `;`\n/tmp/tmpb_mjriyu.d(22): Error: found `long` when expecting `,`\n/tmp/tmpb_mjriyu.d(22): Error: found `;` when expecting `,`\n/tmp/tmpb_mjriyu.d(23): Error: expression expected, not `for`\n/tmp/tmpb_mjriyu.d(23): Error: found `i` when expecting `.` following int\n/tmp/tmpb_mjriyu.d(23): Error: found `=` when expecting identifier following `int`.\n/tmp/tmpb_mjriyu.d(23): Error: found `0` when expecting `,`\n/tmp/tmpb_mjriyu.d(23): Error: expression expected, not `;`\n/tmp/tmpb_mjriyu.d(23): Error: found `i` when expecting `,`\n/tmp/tmpb_mjriyu.d(23): Error: expression expected, not `<`\n/tmp/tmpb_mjriyu.d(23): Error: found ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    for (int i = 0; i < result.length; i++) {\n        long sum = 0;\n        for (int j = 0; j < result[i].toString().length(); j++) {\n            sum += Math.pow(10, j) * result[i].toString().charAt(j) - \n                Math.pow(10, j) * result[i].toString().charAt(j);\n        }\n        for (int j = 0; j < result.length; j++) {\n            if (sum == 0 && result[j] == 0) {\n                result[i] = result[j];\n                break;\n            }\n            if (sum < 0 && result[j] > 0) {\n                result[i] = result[j];\n                break;\n            }\n            if (sum > 0 && result[j] < 0) {\n                result[i] = result[j];\n                break;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpi3032lw4.d(19): Error: no property `clone` for type `long[]`\n/tmp/tmpi3032lw4.d(22): Error: no property `toString` for type `long`\n/tmp/tmpi3032lw4.d(23): Error: undefined identifier `Math`\n/tmp/tmpi3032lw4.d(23): Error: no property `toString` for type `long`\n/tmp/tmpi3032lw4.d(24): Error: undefined identifier `Math`\n/tmp/tmpi3032lw4.d(24): Error: no property `toString` for type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi3032lw4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    int n = nums.length;\n    for (int i = 0; i < n; i++) {\n        long sum = 0;\n        for (int j = 0; j < nums[i] * 10; j++) {\n            sum += j;\n        }\n        for (int j = 0; j < n; j++) {\n            if (sum == nums[j]) {\n                result[i] = nums[j];\n                nums[j] = -1;\n                break;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpevf751oz.d(19): Error: no property `clone` for type `long[]`\n/tmp/tmpevf751oz.d(20): Error: cannot implicitly convert expression `nums.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpevf751oz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    int[] map = new int[10];\n    for (int i = 0; i < nums.length; i++) {\n        int sum = 0;\n        while (nums[i] != 0) {\n            sum += nums[i] % 10;\n            nums[i] /= 10;\n        }\n        if (sum >= 0 && sum < 10) {\n            map[sum]++;\n        }\n    }\n    for (int i = 0; i < map.length; i++) {\n        for (int j = 0; j < map[i]; j++) {\n            result[map[i] + j] = i;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmp_bemrph1.d(19): Error: no property `clone` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_bemrph1.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    int[] sum_digits = new int[10];\n    for (int i = 0; i < nums.length; i++) {\n        sum_digits[nums[i] % 10]++;\n    }\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < sum_digits[i]; j++) {\n            result[j] = i;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp9kkqx7uo.d(22): Range violation\n----------------\n??:? _d_arrayboundsp [0x428b96]\n??:? long[] tmp9kkqx7uo.order_by_points(long[]) [0x42816c]\n??:? void tmp9kkqx7uo.__unittest_L31_C1() [0x428268]\n??:? void tmp9kkqx7uo.__modtest() [0x428868]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cda7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bc3a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ec5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431374]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430e51]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bc11]\n??:? runModuleUnitTests [0x42cb7d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int funct",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    int len = nums.length;\n    for (int i = 0; i < len; i++) {\n        for (int j = i + 1; j < len; j++) {\n            if (nums[i] + nums[j] == nums[i] * 10 + nums[j]) {\n                long temp = nums[i];\n                nums[i] = nums[j];\n                nums[j] = temp;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpailn5pr8.d(19): Error: no property `clone` for type `long[]`\n/tmp/tmpailn5pr8.d(20): Error: cannot implicitly convert expression `nums.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpailn5pr8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n        result[i] = nums[i];\n    }\n    \n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (nums[i] + nums[j] == nums[i] + nums[j]) {\n                result[i] = nums[i];\n                result[j] = nums[j];\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpzohrpicm.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x42893d]\n??:? void tmpzohrpicm.__unittest_L35_C1() [0x428131]\n??:? void tmpzohrpicm.__modtest() [0x4286bc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca1b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8ae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b39]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fe8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ac5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b885]\n??:? runModuleUnitTests [0x42c7f1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e00]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] sorted = new long[nums.length];\n    int i = 0;\n    for(long n : nums)\n    {\n        int sum = 0;\n        while(n > 0)\n        {\n            sum += n % 10;\n            n /= 10;\n        }\n        sorted[i++] = sum;\n    }\n    \n    java.util.Arrays.sort(sorted);\n    return sorted;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmp97apyi3s.d(21): Error: semicolon expected, not `:`\n/tmp/tmp97apyi3s.d(21): Error: expression expected, not `:`\n/tmp/tmp97apyi3s.d(21): Error: found `nums` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp97apyi3s.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    for(int i = 0; i < nums.length; i++)\n    {\n        long sum = 0;\n        for(int j = 0; j < nums[i] < 0 ? nums[i] * -1 : nums[i]; j++)\n            sum += nums[i] % 10;\n        result[i] = sum;\n    }\n    \n    for(int i = 0; i < nums.length; i++)\n        for(int j = i + 1; j < nums.length; j++)\n            if(result[i] == result[j])\n                if(nums[i] < 0)\n                    result[i] = nums[i] * -1;\n                else\n                    result[i] = nums[i];\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpxvkclq4h.d(23): Error: found `<` when expecting `;` following `for` condition\n/tmp/tmpxvkclq4h.d(23): Error: found `;` when expecting `)`\n/tmp/tmpxvkclq4h.d(23): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxvkclq4h.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n        long sum = 0;\n        for (int j = 0; j < nums[i].toString().length(); j++) {\n            sum += nums[i].toString().charAt(j) - '0';\n        }\n        result[i] = sum;\n    }\n    \n    java.util.Arrays.sort(result);\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmp5hv0cdbu.d(22): Error: no property `toString` for type `long`\n/tmp/tmp5hv0cdbu.d(23): Error: no property `toString` for type `long`\n/tmp/tmp5hv0cdbu.d(28): Error: undefined identifier `java`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5hv0cdbu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    long[] sorted = new long[nums.length];\n    long sum = 0;\n    int i = 0;\n    for(long n : nums)\n    {\n        sum += n;\n        sorted[i++] = n;\n    }\n    \n    for(int j = 0; j < nums.length; j++)\n    {\n        for(int k = 0; k < nums.length; k++)\n        {\n            if(sorted[k] == nums[j])\n            {\n                result[j] = sorted[k];\n                break;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpeol4gpyf.d(23): Error: semicolon expected, not `:`\n/tmp/tmpeol4gpyf.d(23): Error: expression expected, not `:`\n/tmp/tmpeol4gpyf.d(23): Error: found `nums` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeol4gpyf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    \n    for (int i = 0; i < nums.length; i++) {\n        long sum = 0;\n        for (int j = 0; j < nums[i] < 0 ? nums.length - 1 : 0; j++) {\n            sum += nums[j];\n        }\n        result[i] = sum;\n    }\n    \n    java.util.Arrays.sort(result);\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmp3kya0dj_.d(23): Error: found `<` when expecting `;` following `for` condition\n/tmp/tmp3kya0dj_.d(23): Error: found `;` when expecting `)`\n/tmp/tmp3kya0dj_.d(23): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3kya0dj_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    for (int i = 0; i < result.length; i++) {\n        for (int j = i + 1; j < result.length; j++) {\n            if (sum_of_digits(result[i]) < sum_of_digits(result[j])) {\n                long temp = result[i];\n                result[i] = result[j];\n                result[j] = temp;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpgdof6kdx.d(19): Error: no property `clone` for type `long[]`\n/tmp/tmpgdof6kdx.d(22): Error: undefined identifier `sum_of_digits`\n/tmp/tmpgdof6kdx.d(22): Error: undefined identifier `sum_of_digits`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgdof6kdx.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums;\n    \n    for (int i = 0; i < nums.length; i++)\n    {\n        long sum = 0;\n        for (int j = 0; j < nums[i] < 0 ? nums.length - 1 : 0; j++)\n        {\n            sum += nums[j];\n        }\n        \n        if (sum > 0)\n        {\n            result[i] = sum;\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmprftcfmaw.d(24): Error: found `<` when expecting `;` following `for` condition\n/tmp/tmprftcfmaw.d(24): Error: found `;` when expecting `)`\n/tmp/tmprftcfmaw.d(24): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprftcfmaw.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    for(int i = 0; i < nums.length; i++)\n    {\n        long sum = 0;\n        for(int j = 0; j < nums[i] * 10; j++)\n            sum += Math.pow(10, j);\n        result[i] = sum;\n    }\n    \n    java.util.Arrays.sort(result);\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpa8lzocf5.d(24): Error: undefined identifier `Math`\n/tmp/tmpa8lzocf5.d(28): Error: undefined identifier `java`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa8lzocf5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n        long sum = 0;\n        for (int j = 0; j < nums[i] < 0 ? nums[i] * -1 : nums[i]; j++) {\n            sum += nums[i] % 10;\n        }\n        result[i] = sum;\n    }\n    \n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (result[i] == result[j]) {\n                result[i] = nums[i];\n                result[j] = nums[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpb5wjpcjq.d(22): Error: found `<` when expecting `;` following `for` condition\n/tmp/tmpb5wjpcjq.d(22): Error: found `;` when expecting `)`\n/tmp/tmpb5wjpcjq.d(22): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb5wjpcjq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    long[] sums = new long[10];\n    for (int i = 0; i < nums.length; i++) {\n        sums[nums[i] % 10] += nums[i];\n    }\n    for (int i = 0; i < sums.length; i++) {\n        for (int j = 0; j < nums.length; j++) {\n            if (sums[i] == nums[j]) {\n                result[j] = nums[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpz_wktjul.d(22): Range violation\n----------------\n??:? _d_arrayboundsp [0x42898e]\n??:? long[] tmpz_wktjul.order_by_points(long[]) [0x427ed2]\n??:? void tmpz_wktjul.__unittest_L34_C1() [0x42805c]\n??:? void tmpz_wktjul.__modtest() [0x42865c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b84e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ad9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f88]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a65]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b825]\n??:? runModuleUnitTests [0x42c791]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int funct",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    int[] sums = new int[10];\n    for (int i = 0; i < nums.length; i++) {\n        sums[nums[i] % 10]++;\n    }\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < sums[i]; j++) {\n            result[j] = i;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpwlf4ggfu.d(22): Range violation\n----------------\n??:? _d_arrayboundsp [0x428b96]\n??:? long[] tmpwlf4ggfu.order_by_points(long[]) [0x42816c]\n??:? void tmpwlf4ggfu.__unittest_L31_C1() [0x428268]\n??:? void tmpwlf4ggfu.__modtest() [0x428868]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cda7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bc3a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ec5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431374]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430e51]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bc11]\n??:? runModuleUnitTests [0x42cb7d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428fa8]\n??:? void rt.dmain2._d_run_main(int, char**, e",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    for (int i = 0; i < result.length; i++) {\n        for (int j = i + 1; j < result.length; j++) {\n            if (result[i] + result[j] == 0) {\n                long temp = result[i];\n                result[i] = result[j];\n                result[j] = temp;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmpe_cjpj5_.d(19): Error: no property `clone` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_cjpj5_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    long[] sorted = new long[nums.length];\n    int[] count = new int[10];\n    int[] index = new int[10];\n    for (int i = 0; i < nums.length; i++) {\n        count[nums[i] % 10]++;\n    }\n    for (int i = 0; i < 10; i++) {\n        index[i] = 0;\n    }\n    for (int i = 0; i < nums.length; i++) {\n        index[nums[i] % 10]++;\n    }\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < count[i]; j++) {\n            sorted[index[i] + j] = nums[i];\n        }\n    }\n    for (int i = 0; i < nums.length; i++) {\n        result[i] = sorted[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293471,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpblxqoj0p.d(24): Range violation\n----------------\n??:? _d_arrayboundsp [0x428d3e]\n??:? long[] tmpblxqoj0p.order_by_points(long[]) [0x4281a3]\n??:? void tmpblxqoj0p.__unittest_L42_C1() [0x42840c]\n??:? void tmpblxqoj0p.__modtest() [0x428a0c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cf4f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bde2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43106d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43151c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ff9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bdb9]\n??:? runModuleUnitTests [0x42cd25]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int funct",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums;\n    \n    for (int i = 0; i < nums.length; i++)\n    {\n        long sum = 0;\n        for (int j = 0; j < nums[i].toString().length(); j++)\n        {\n            sum += nums[i].toString().charAt(j) - '0';\n        }\n        \n        for (int j = 0; j < nums.length; j++)\n        {\n            if (sum == nums[j].toString().length())\n            {\n                result[i] = nums[j];\n                break;\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpf7bjijq_.d(24): Error: no property `toString` for type `long`\n/tmp/tmpf7bjijq_.d(26): Error: no property `toString` for type `long`\n/tmp/tmpf7bjijq_.d(31): Error: no property `toString` for type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf7bjijq_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    int[] sorted_index = new int[nums.length];\n    int[] sorted_sum = new int[nums.length];\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int sum = 0;\n    for (i = 0; i < nums.length; i++) {\n        sum = 0;\n        for (j = 0; j < nums[i] < 0 ? nums[i] * -1 : nums[i]; j++) {\n            sum += Math.abs(j);\n        }\n        sorted_index[k] = i;\n        sorted_sum[k] = sum;\n        k++;\n    }\n    for (i = 0; i < nums.length; i++) {\n        for (j = 0; j < nums.length; j++) {\n            if (sorted_sum[j] == sorted_sum[i]) {\n                result[i] = nums[sorted_index[j]];\n                break;\n            }\n        }\n    }\n    return result;\n}\n\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpm7591s0g.d(28): Error: found `<` when expecting `;` following `for` condition\n/tmp/tmpm7591s0g.d(28): Error: found `;` when expecting `)`\n/tmp/tmpm7591s0g.d(28): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm7591s0g.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    int[] indexes = new int[nums.length];\n    int[] sums = new int[10];\n    for (int i = 0; i < nums.length; i++) {\n        sums[nums[i] % 10]++;\n    }\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < sums[i]; j++) {\n            result[indexes[i]++] = i;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp1_aeqnah.d(23): Range violation\n----------------\n??:? _d_arrayboundsp [0x428bde]\n??:? long[] tmp1_aeqnah.order_by_points(long[]) [0x428184]\n??:? void tmp1_aeqnah.__unittest_L32_C1() [0x4282b0]\n??:? void tmp1_aeqnah.__modtest() [0x4288b0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cdef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bc82]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430f0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4313bc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430e99]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bc59]\n??:? runModuleUnitTests [0x42cbc5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int funct",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    \n    for (int i = 0; i < nums.length; i++) {\n        int sum = 0;\n        for (int j = 0; j < nums[i] != 0; j++) {\n            sum += nums[i] % 10;\n            nums[i] /= 10;\n        }\n        result[i] = sum;\n    }\n    \n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (result[i] == result[j]) {\n                long temp = nums[i];\n                nums[i] = nums[j];\n                nums[j] = temp;\n            }\n        }\n    }\n    \n    return nums;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpytbw1pr3.d(23): Error: found `!=` when expecting `;` following `for` condition\n/tmp/tmpytbw1pr3.d(23): Error: found `;` when expecting `)`\n/tmp/tmpytbw1pr3.d(23): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpytbw1pr3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    long[] temp = new long[nums.length];\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmps4098_wg.d(90): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps4098_wg.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    \n    for (int i = 0; i < result.length; i++) {\n        for (int j = i + 1; j < result.length; j++) {\n            if (result[i] + result[j] == 0) {\n                long temp = result[i];\n                result[i] = result[j];\n                result[j] = temp;\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmpyx606vcr.d(19): Error: no property `clone` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyx606vcr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] sorted = new long[nums.length];\n    int[] sum_digits = new int[10];\n    for (int i = 0; i < nums.length; i++) {\n        sum_digits[nums[i] % 10]++;\n    }\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < sum_digits[i]; j++) {\n            sorted[j] = i;\n        }\n    }\n    return sorted;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293471,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpr45s898a.d(22): Range violation\n----------------\n??:? _d_arrayboundsp [0x428b96]\n??:? long[] tmpr45s898a.order_by_points(long[]) [0x42816c]\n??:? void tmpr45s898a.__unittest_L31_C1() [0x428268]\n??:? void tmpr45s898a.__modtest() [0x428868]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cda7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bc3a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ec5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431374]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430e51]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bc11]\n??:? runModuleUnitTests [0x42cb7d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int funct",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    int[] indexes = new int[nums.length];\n    int[] sums = new int[10];\n    for (int i = 0; i < nums.length; i++) {\n        sums[nums[i] % 10]++;\n    }\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < sums[i]; j++) {\n            result[indexes[i]++] = i;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp1_aeqnah.d(23): Range violation\n----------------\n??:? _d_arrayboundsp [0x428bde]\n??:? long[] tmp1_aeqnah.order_by_points(long[]) [0x428184]\n??:? void tmp1_aeqnah.__unittest_L32_C1() [0x4282b0]\n??:? void tmp1_aeqnah.__modtest() [0x4288b0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cdef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bc82]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430f0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4313bc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430e99]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bc59]\n??:? runModuleUnitTests [0x42cbc5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int funct",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    long[] sorted = nums.clone();\n    sort(sorted);\n    for (int i = 0; i < nums.length; i++) {\n        long sum = 0;\n        for (int j = 0; j < nums[i].toString().length(); j++) {\n            sum += nums[i].toString().charAt(j) - '0';\n        }\n        result[i] = sorted[i] + sum;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmp86zj0myg.d(20): Error: no property `clone` for type `long[]`\n/tmp/tmp86zj0myg.d(21): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmp86zj0myg.d(24): Error: no property `toString` for type `long`\n/tmp/tmp86zj0myg.d(25): Error: no property `toString` for type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp86zj0myg.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] sorted = nums.clone();\n    for (int i = 0; i < sorted.length; i++) {\n        for (int j = i + 1; j < sorted.length; j++) {\n            if (sorted[i] + sorted[j] == sorted[i] + sorted[j]) {\n                long temp = sorted[i];\n                sorted[i] = sorted[j];\n                sorted[j] = temp;\n            }\n        }\n    }\n    return sorted;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpa81zptrb.d(19): Error: no property `clone` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa81zptrb.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] sorted = nums.clone();\n    sort(sorted, (a, b) -> {\n        long sum_a = 0;\n        long sum_b = 0;\n        for (int i = 0; i < a.length(); i++) {\n            sum_a += a.charAt(i) - '0';\n        }\n        for (int i = 0; i < b.length(); i++) {\n            sum_b += b.charAt(i) - '0';\n        }\n        return sum_a - sum_b;\n    });\n    return sorted;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpb_mjriyu.d(20): Error: expression expected, not `>`\n/tmp/tmpb_mjriyu.d(20): Error: found `{` when expecting `,`\n/tmp/tmpb_mjriyu.d(21): Error: found `sum_a` when expecting `.` following long\n/tmp/tmpb_mjriyu.d(21): Error: found `=` when expecting identifier following `long`.\n/tmp/tmpb_mjriyu.d(21): Error: found `0` when expecting `,`\n/tmp/tmpb_mjriyu.d(21): Error: expression expected, not `;`\n/tmp/tmpb_mjriyu.d(22): Error: found `long` when expecting `,`\n/tmp/tmpb_mjriyu.d(22): Error: found `;` when expecting `,`\n/tmp/tmpb_mjriyu.d(23): Error: expression expected, not `for`\n/tmp/tmpb_mjriyu.d(23): Error: found `i` when expecting `.` following int\n/tmp/tmpb_mjriyu.d(23): Error: found `=` when expecting identifier following `int`.\n/tmp/tmpb_mjriyu.d(23): Error: found `0` when expecting `,`\n/tmp/tmpb_mjriyu.d(23): Error: expression expected, not `;`\n/tmp/tmpb_mjriyu.d(23): Error: found `i` when expecting `,`\n/tmp/tmpb_mjriyu.d(23): Error: expression expected, not `<`\n/tmp/tmpb_mjriyu.d(23): Error: found ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n        result[i] = nums[i];\n    }\n    \n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (nums[i] + nums[j] == nums[j] + nums[i]) {\n                result[i] = nums[i];\n                result[j] = nums[j];\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpuzy_ska8.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x42893d]\n??:? void tmpuzy_ska8.__unittest_L35_C1() [0x428131]\n??:? void tmpuzy_ska8.__modtest() [0x4286bc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca1b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8ae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b39]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fe8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ac5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b885]\n??:? runModuleUnitTests [0x42c7f1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e00]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] sorted = nums.clone();\n    for (int i = 0; i < sorted.length; i++) {\n        for (int j = i + 1; j < sorted.length; j++) {\n            if (sorted[i] + sorted[j] == sorted[i] + sorted[j]) {\n                long temp = sorted[i];\n                sorted[i] = sorted[j];\n                sorted[j] = temp;\n            }\n        }\n    }\n    return sorted;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpa81zptrb.d(19): Error: no property `clone` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa81zptrb.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] sorted = nums.clone();\n    for (int i = 0; i < sorted.length; i++) {\n        long sum = 0;\n        for (int j = 0; j < sorted[i].toString().length(); j++) {\n            sum += Math.pow(10, j) * sorted[i].toString().charAt(j) - 1;\n        }\n        for (int j = 0; j < sorted.length; j++) {\n            if (sum == 0 && sorted[j] == 0) {\n                sorted[i] = sorted[j];\n                sorted[j] = 0;\n                break;\n            }\n            if (sorted[i] == 0 && sorted[j] != 0) {\n                sorted[i] = sorted[j];\n                sorted[j] = 0;\n                break;\n            }\n            if (sorted[i] != 0 && sorted[j] != 0) {\n                if (sum > 0 && sorted[i] > 0 && sorted[j] > 0) {\n                    if (sum > 0 && sorted[i] > 0 && sorted[j] > 0) {\n                        if (sum > 0 && sorted[i] > 0 && sorted[j] > 0) {\n                            if (sum > 0 && sorted[i] > 0 && sorted[j] > 0) {\n                                if (sum > 0 && sorted[i] > 0 && sorted[j] > 0) {\n                                    if (sum > 0 && sorted[i] > 0 && sorted[j] > 0) {\n                                        if (sum > 0 && sorted[i] > 0 && sorted[j] > 0) {\n                                            if (sum > 0 && sorted[i] > 0 && sorted[j] > 0) {\n                                                if (sum > 0 && sorted[i] > 0 && sorted[j] > 0) {\n                                                    if (sum > 0 && sorted[i] > 0 && sorted[j] > 0) {\n                                                        if (sum > 0 && sorted[i] > 0 && sorted[j] > 0) {\n                                                            if (sum\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmplpbvbcm5.d(49): Error: found `unittest` when expecting `)`\n/tmp/tmplpbvbcm5.d(60): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmplpbvbcm5.d(60): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmplpbvbcm5.d(60): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmplpbvbcm5.d(60): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmplpbvbcm5.d(60): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmplpbvbcm5.d(60): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmplpbvbcm5.d(60): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmplpbvbcm5.d(60): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmplpbvbcm5.d(60): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmplpbvbcm5.d(60): Error: found `End of File` when expecting ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    long[] sorted = new long[nums.length];\n    long sum = 0;\n    int i = 0;\n    for(long n : nums)\n    {\n        sum += n;\n        sorted[i] = n;\n        i++;\n    }\n    \n    for(i = 0; i < nums.length; i++)\n    {\n        for(int j = 0; j < nums.length; j++)\n        {\n            if(sorted[j] == nums[i])\n            {\n                result[i] = j;\n                break;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpxi8zwbox.d(23): Error: semicolon expected, not `:`\n/tmp/tmpxi8zwbox.d(23): Error: expression expected, not `:`\n/tmp/tmpxi8zwbox.d(23): Error: found `nums` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxi8zwbox.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    for (int i = 0; i < result.length; i++) {\n        int sum = 0;\n        while (sum < 10 && result[i] > 0) {\n            sum += result[i] % 10;\n            result[i] /= 10;\n        }\n        if (sum == 0) {\n            result[i] = -1;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpmr2o2y4_.d(19): Error: no property `clone` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmr2o2y4_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    int[] sums = new int[10];\n    for (int i = 0; i < nums.length; i++) {\n        sums[nums[i] % 10]++;\n    }\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < sums[i]; j++) {\n            result[j] = i;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpwlf4ggfu.d(22): Range violation\n----------------\n??:? _d_arrayboundsp [0x428b96]\n??:? long[] tmpwlf4ggfu.order_by_points(long[]) [0x42816c]\n??:? void tmpwlf4ggfu.__unittest_L31_C1() [0x428268]\n??:? void tmpwlf4ggfu.__modtest() [0x428868]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cda7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bc3a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ec5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431374]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430e51]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bc11]\n??:? runModuleUnitTests [0x42cb7d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428fa8]\n??:? void rt.dmain2._d_run_main(int, char**, e",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n        long sum = 0;\n        for (int j = 0; j < nums[i] != 0; j++) {\n            sum += nums[i] % 10;\n            nums[i] /= 10;\n        }\n        result[i] = sum;\n    }\n    \n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (result[i] == result[j]) {\n                result[i] = nums[i];\n                result[j] = nums[j];\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpvvweds7s.d(22): Error: found `!=` when expecting `;` following `for` condition\n/tmp/tmpvvweds7s.d(22): Error: found `;` when expecting `)`\n/tmp/tmpvvweds7s.d(22): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvvweds7s.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n        long sum = 0;\n        for (int j = 0; j < nums[i] < 0 ? nums[i] * -1 : nums[i]; j++) {\n            sum += nums[i] % 10;\n        }\n        result[i] = sum;\n    }\n    \n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (result[i] == result[j]) {\n                result[i] = nums[i];\n                result[j] = nums[j];\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmpf07x60h4.d(22): Error: found `<` when expecting `;` following `for` condition\n/tmp/tmpf07x60h4.d(22): Error: found `;` when expecting `)`\n/tmp/tmpf07x60h4.d(22): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf07x60h4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n        long sum = 0;\n        for (int j = 0; j < nums[i] < 0 ? nums[i] * -1 : nums[i]; j++) {\n            sum += nums[i] % 10;\n        }\n        result[i] = sum;\n    }\n    \n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (result[i] == result[j]) {\n                result[i] = nums[i];\n                result[j] = nums[j];\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmpf07x60h4.d(22): Error: found `<` when expecting `;` following `for` condition\n/tmp/tmpf07x60h4.d(22): Error: found `;` when expecting `)`\n/tmp/tmpf07x60h4.d(22): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf07x60h4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    int i = 0;\n    int j = 0;\n    int sum = 0;\n    while (i < nums.length) {\n        sum = 0;\n        while (i < nums.length && nums[i] != 0) {\n            sum += nums[i];\n            i++;\n        }\n        if (j < i) {\n            result[j] = nums[i - 1];\n            j++;\n        }\n        if (sum != 0) {\n            result[i - 1] = nums[i - 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293471,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpiq93wj4_.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x42888d]\n??:? void tmpiq93wj4_.__unittest_L39_C1() [0x428085]\n??:? void tmpiq93wj4_.__modtest() [0x428610]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c96b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7fe]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a89]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f38]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a15]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7d5]\n??:? runModuleUnitTests [0x42c741]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d50]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] sorted = nums.clone();\n    sort(sorted, new Comparator<Long>() {\n        public int compare(Long a, Long b) {\n            long sum_a = 0;\n            long sum_b = 0;\n            for (int i = 0; i < a.intValue(); i++) {\n                sum_a += a.intValue() % 10;\n            }\n            for (int i = 0; i < b.intValue(); i++) {\n                sum_b += b.intValue() % 10;\n            }\n            return sum_a - sum_b;\n        }\n    });\n    return sorted;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpca8lxwoo.d(20): Error: found `>` when expecting `,`\n/tmp/tmpca8lxwoo.d(21): Error: found `public` instead of statement\n/tmp/tmpca8lxwoo.d(32): Error: found `}` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpca8lxwoo.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] sorted = new long[nums.length];\n    int i = 0;\n    for (long num : nums) {\n        long sum = 0;\n        while (num != 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        sorted[i++] = sum;\n    }\n    \n    java.util.Arrays.sort(sorted);\n    \n    return sorted;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmphg4294yl.d(21): Error: semicolon expected, not `:`\n/tmp/tmphg4294yl.d(21): Error: expression expected, not `:`\n/tmp/tmphg4294yl.d(21): Error: found `nums` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphg4294yl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    long[] sorted = new long[nums.length];\n    int[] index = new int[nums.length];\n    int[] sum = new int[nums.length];\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmpepnfl40j.d(88): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpepnfl40j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    int n = nums.length;\n    for (int i = 0; i < n; i++) {\n        int sum = 0;\n        for (int j = 0; j < nums[i] < 0 ? nums[i] * -1 : nums[i]; j++) {\n            sum += nums[i] % 10;\n        }\n        for (int j = 0; j < nums[i] < 0 ? nums[i] * -1 : nums[i]; j++) {\n            sum -= nums[i] % 10;\n        }\n        for (int j = 0; j < nums[i] < 0 ? nums[i] * -1 : nums[i]; j++) {\n            sum += nums[i] % 10;\n        }\n        for (int j = 0; j < nums[i] < 0 ? nums[i] * -1 : nums[i]; j++) {\n            sum -= nums[i] % 10;\n        }\n        if (sum > 0) {\n            for (int j = 0; j < nums[i] < 0 ? nums[i] * -1 : nums[i]; j++) {\n                sum -= nums[i] % 10;\n            }\n            for (int j = 0; j < nums[i] < 0 ? nums[i] * -1 : nums[i]; j++) {\n                sum += nums[i] % 10;\n            }\n            for (int j = 0; j < nums[i] < 0 ? nums[i] * -1 : nums[i]; j++) {\n                sum -= nums[i] % 10;\n            }\n            for (int j = 0; j < nums[i] < 0 ? nums[i] * -1 : nums[i]; j++) {\n                sum += nums[i] % 10;\n            }\n        }\n        if (sum == 0) {\n            result[i] = -1L;\n        }\n        else if (sum < 0) {\n            result[i] = -1L;\n        }\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpjdcmcalc.d(23): Error: found `<` when expecting `;` following `for` condition\n/tmp/tmpjdcmcalc.d(23): Error: found `;` when expecting `)`\n/tmp/tmpjdcmcalc.d(23): Error: found `)` when expecting `;` following statement\n/tmp/tmpjdcmcalc.d(26): Error: found `<` when expecting `;` following `for` condition\n/tmp/tmpjdcmcalc.d(26): Error: found `;` when expecting `)`\n/tmp/tmpjdcmcalc.d(26): Error: found `)` when expecting `;` following statement\n/tmp/tmpjdcmcalc.d(29): Error: found `<` when expecting `;` following `for` condition\n/tmp/tmpjdcmcalc.d(29): Error: found `;` when expecting `)`\n/tmp/tmpjdcmcalc.d(29): Error: found `)` when expecting `;` following statement\n/tmp/tmpjdcmcalc.d(32): Error: found `<` when expecting `;` following `for` condition\n/tmp/tmpjdcmcalc.d(32): Error: found `;` when expecting `)`\n/tmp/tmpjdcmcalc.d(32): Error: found `)` when expecting `;` following statement\n/tmp/tmpjdcmcalc.d(36): Error: found `<` when expecting `;` following `for` condition\n/tmp/tmpjdcmcalc.d(36): Error: fou",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    long[] sorted = nums.clone();\n    \n    for (int i = 0; i < nums.length; i++) {\n        long sum = 0;\n        for (int j = 0; j < nums[i] * 10; j++) {\n            sum += j;\n        }\n        \n        int index = i;\n        for (int j = i + 1; j < nums.length; j++) {\n            if (sum < sum_of_digits(nums[j])) {\n                index = j;\n            }\n        }\n        \n        if (index != i) {\n            long temp = result[i];\n            result[i] = result[index];\n            result[index] = temp;\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmp6sb3iu1o.d(19): Error: no property `clone` for type `long[]`\n/tmp/tmp6sb3iu1o.d(20): Error: no property `clone` for type `long[]`\n/tmp/tmp6sb3iu1o.d(30): Error: undefined identifier `sum_of_digits`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6sb3iu1o.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n        long sum = 0;\n        for (int j = 0; j < nums[i] < 0 ? nums[i] * -1 : nums[i]; j++) {\n            sum += Math.abs(nums[i] % 10);\n        }\n        result[i] = sum;\n    }\n    \n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (result[i] == result[j]) {\n                result[i] = nums[i];\n                result[j] = nums[j];\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmp0ww70e4z.d(22): Error: found `<` when expecting `;` following `for` condition\n/tmp/tmp0ww70e4z.d(22): Error: found `;` when expecting `)`\n/tmp/tmp0ww70e4z.d(22): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0ww70e4z.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n        long sum = 0;\n        for (int j = 0; j < nums[i] != 0; j++) {\n            sum += nums[i] % 10;\n            nums[i] /= 10;\n        }\n        result[i] = sum;\n    }\n    \n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (result[i] == result[j]) {\n                long temp = nums[i];\n                nums[i] = nums[j];\n                nums[j] = temp;\n            }\n        }\n    }\n    \n    return nums;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpcya9riyr.d(22): Error: found `!=` when expecting `;` following `for` condition\n/tmp/tmpcya9riyr.d(22): Error: found `;` when expecting `)`\n/tmp/tmpcya9riyr.d(22): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcya9riyr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    int[] sums = new int[10];\n    for (int i = 0; i < nums.length; i++) {\n        sums[nums[i] % 10]++;\n    }\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < sums[i]; j++) {\n            result[j] = i;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpwlf4ggfu.d(22): Range violation\n----------------\n??:? _d_arrayboundsp [0x428b96]\n??:? long[] tmpwlf4ggfu.order_by_points(long[]) [0x42816c]\n??:? void tmpwlf4ggfu.__unittest_L31_C1() [0x428268]\n??:? void tmpwlf4ggfu.__modtest() [0x428868]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cda7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bc3a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ec5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431374]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430e51]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bc11]\n??:? runModuleUnitTests [0x42cb7d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428fa8]\n??:? void rt.dmain2._d_run_main(int, char**, e",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] sorted = nums.clone();\n    \n    for (int i = 0; i < sorted.length; i++) {\n        int sum = 0;\n        while (sorted[i] != 0) {\n            sum += sorted[i] % 10;\n            sorted[i] /= 10;\n        }\n        \n        int j = i;\n        while (j < sorted.length && sorted[j] == 0) {\n            j++;\n        }\n        \n        if (j < sorted.length && sum == sorted[j]) {\n            long tmp = sorted[i];\n            sorted[i] = sorted[j];\n            sorted[j] = tmp;\n        }\n    }\n    \n    return sorted;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpggwr46aq.d(19): Error: no property `clone` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpggwr46aq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    long[] sorted = nums.clone();\n    \n    for (int i = 0; i < nums.length; i++) {\n        long sum = 0;\n        for (int j = 0; j < nums[i] * 10; j++) {\n            sum += j;\n        }\n        \n        int index = i;\n        for (int j = i + 1; j < nums.length; j++) {\n            if (sum == 0) {\n                index = j;\n                break;\n            }\n            \n            if (sum < 0) {\n                sum = sum * 10 + nums[j];\n            } else {\n                sum = sum * 10 + nums[j] * 10;\n            }\n        }\n        \n        if (index != i) {\n            long temp = result[i];\n            result[i] = result[index];\n            result[index] = temp;\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpo409lotq.d(19): Error: no property `clone` for type `long[]`\n/tmp/tmpo409lotq.d(20): Error: no property `clone` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo409lotq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    \n    for (int i = 0; i < result.length; i++)\n    {\n        for (int j = i + 1; j < result.length; j++)\n        {\n            if (result[i] + result[j] == 0)\n            {\n                long temp = result[i];\n                result[i] = result[j];\n                result[j] = temp;\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpuvut1wd6.d(19): Error: no property `clone` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuvut1wd6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n        long sum = 0;\n        for (int j = 0; j < nums[i] != 0; j++) {\n            sum += nums[i] % 10;\n            nums[i] /= 10;\n        }\n        result[i] = sum;\n    }\n    \n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (result[i] == result[j]) {\n                long temp = nums[i];\n                nums[i] = nums[j];\n                nums[j] = temp;\n            }\n        }\n    }\n    \n    return nums;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpcya9riyr.d(22): Error: found `!=` when expecting `;` following `for` condition\n/tmp/tmpcya9riyr.d(22): Error: found `;` when expecting `)`\n/tmp/tmpcya9riyr.d(22): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcya9riyr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    \n    for (int i = 0; i < result.length; i++) {\n        long sum = 0;\n        for (int j = 0; j < result[i].toString().length(); j++) {\n            sum += Math.pow(10, j) * result[i].toString().charAt(j) - Math.pow(10, j);\n        }\n        result[i] = sum;\n    }\n    \n    for (int i = 0; i < result.length; i++) {\n        for (int j = i + 1; j < result.length; j++) {\n            if (result[i] == result[j]) {\n                result[i] = j;\n                break;\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293471,
      "stdout": "",
      "stderr": "/tmp/tmpcvgvxt2t.d(19): Error: no property `clone` for type `long[]`\n/tmp/tmpcvgvxt2t.d(23): Error: no property `toString` for type `long`\n/tmp/tmpcvgvxt2t.d(24): Error: undefined identifier `Math`\n/tmp/tmpcvgvxt2t.d(24): Error: no property `toString` for type `long`\n/tmp/tmpcvgvxt2t.d(24): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcvgvxt2t.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    int n = nums.length;\n    for (int i = 0; i < n; i++) {\n        long sum = 0;\n        for (int j = 0; j < nums[i] < 0 ? nums[i] * -1 : nums[i]; j++) {\n            sum += nums[i] % 10;\n        }\n        result[i] = sum;\n    }\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (result[i] == result[j]) {\n                long temp = result[i];\n                result[i] = result[j];\n                result[j] = temp;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmplokqvdze.d(23): Error: found `<` when expecting `;` following `for` condition\n/tmp/tmplokqvdze.d(23): Error: found `;` when expecting `)`\n/tmp/tmplokqvdze.d(23): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplokqvdze.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    int[] sorted = new int[nums.length];\n    for(int i = 0; i < nums.length; i++)\n    {\n        sorted[i] = i;\n    }\n    \n    for(int i = 0; i < nums.length; i++)\n    {\n        long sum = 0;\n        for(int j = 0; j < nums[i]/10; j++)\n        {\n            sum += nums[i]%10;\n        }\n        for(int j = 0; j < nums.length; j++)\n        {\n            if(nums[j] == nums[i])\n            {\n                result[sorted[i]] = nums[i];\n                sorted[i] = j;\n                break;\n            }\n            if(nums[j] == sum)\n            {\n                result[sorted[i]] = nums[i];\n                sorted[i] = j;\n                break;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293471,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmprbviw9vy.d(55): unittest failure\n----------------\n??:? _d_unittestp [0x428cd5]\n??:? void tmprbviw9vy.__unittest_L51_C1() [0x4284c9]\n??:? void tmprbviw9vy.__modtest() [0x428a54]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cf97]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42be2a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4310b5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431564]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431041]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42be01]\n??:? runModuleUnitTests [0x42cd6d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429198]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] sorted = nums.clone();\n    sort(sorted, (a, b) -> {\n        long sum_a = 0;\n        long sum_b = 0;\n        for (int i = 0; i < a.length(); i++) {\n            sum_a += a.charAt(i) - '0';\n        }\n        for (int i = 0; i < b.length(); i++) {\n            sum_b += b.charAt(i) - '0';\n        }\n        return sum_a - sum_b;\n    });\n    return sorted;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpb_mjriyu.d(20): Error: expression expected, not `>`\n/tmp/tmpb_mjriyu.d(20): Error: found `{` when expecting `,`\n/tmp/tmpb_mjriyu.d(21): Error: found `sum_a` when expecting `.` following long\n/tmp/tmpb_mjriyu.d(21): Error: found `=` when expecting identifier following `long`.\n/tmp/tmpb_mjriyu.d(21): Error: found `0` when expecting `,`\n/tmp/tmpb_mjriyu.d(21): Error: expression expected, not `;`\n/tmp/tmpb_mjriyu.d(22): Error: found `long` when expecting `,`\n/tmp/tmpb_mjriyu.d(22): Error: found `;` when expecting `,`\n/tmp/tmpb_mjriyu.d(23): Error: expression expected, not `for`\n/tmp/tmpb_mjriyu.d(23): Error: found `i` when expecting `.` following int\n/tmp/tmpb_mjriyu.d(23): Error: found `=` when expecting identifier following `int`.\n/tmp/tmpb_mjriyu.d(23): Error: found `0` when expecting `,`\n/tmp/tmpb_mjriyu.d(23): Error: expression expected, not `;`\n/tmp/tmpb_mjriyu.d(23): Error: found `i` when expecting `,`\n/tmp/tmpb_mjriyu.d(23): Error: expression expected, not `<`\n/tmp/tmpb_mjriyu.d(23): Error: found ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n        result[i] = nums[i];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmppwdbdw4b.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x4287ad]\n??:? void tmppwdbdw4b.__unittest_L26_C1() [0x427fa1]\n??:? void tmppwdbdw4b.__modtest() [0x42852c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c88b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b71e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4309a9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430e58]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430935]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b6f5]\n??:? runModuleUnitTests [0x42c661]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428c70]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    long[] sorted = new long[nums.length];\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    while (i < nums.length) {\n        long sum = 0;\n        while (i < nums.length && nums[i] != 0) {\n            sum += nums[i];\n            i++;\n        }\n        if (i < nums.length) {\n            sum += nums[i];\n            i++;\n        }\n        while (j < k && sorted[j] < sum) {\n            j++;\n        }\n        if (j < k) {\n            sorted[j] = result[k];\n            k++;\n        } else {\n            sorted[j] = result[i];\n            i++;\n            j++;\n        }\n    }\n    return sorted;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293471,
      "stdout": "",
      "stderr": "/tmp/tmp5mgr0o4m.d(19): Error: no property `clone` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5mgr0o4m.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    int[] index = new int[nums.length];\n    int[] sum = new int[nums.length];\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int sum_index = 0;\n    int sum_count = 0;\n    int sum_count_index = 0;\n    int sum_count_count = 0;\n    while (i < nums.length) {\n        sum[i] = nums[i] % 10;\n        index[i] = i;\n        i++;\n    }\n    while (j < nums.length) {\n        sum_count = 0;\n        sum_count_index = 0;\n        sum_count_count = 0;\n        while (k < nums.length) {\n            if (sum[k] == sum_count) {\n                sum_count_count++;\n                sum_count_index = k;\n            }\n            k++;\n        }\n        if (sum_count_count == 1) {\n            result[sum_index] = nums[sum_count_index];\n            sum_index++;\n        }\n        sum_count = 0;\n        k = 0;\n        while (k < nums.length) {\n            if (sum[k] == sum_count) {\n                sum_count++;\n            }\n            k++;\n        }\n        if (sum_count == 1) {\n            result[sum_index] = nums[index[sum_count_index]];\n            sum_index++;\n        }\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293471,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmposp0wb70.d(69): unittest failure\n----------------\n??:? _d_unittestp [0x428c65]\n??:? void tmposp0wb70.__unittest_L65_C1() [0x42845d]\n??:? void tmposp0wb70.__modtest() [0x4289e8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cf27]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bdba]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x431045]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4314f4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430fd1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bd91]\n??:? runModuleUnitTests [0x42ccfd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429128]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    long[] sorted = nums.clone();\n    for (int i = 0; i < nums.length; i++) {\n        long sum = 0;\n        for (int j = 0; j < nums[i] && j < 10; j++) {\n            sum += nums[i] % 10;\n        }\n        result[i] = sum;\n    }\n    \n    java.util.Arrays.sort(result);\n    java.util.Arrays.sort(sorted);\n    \n    for (int i = 0; i < result.length; i++) {\n        if (result[i] != sorted[i]) {\n            return sorted;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293471,
      "stdout": "",
      "stderr": "/tmp/tmp7z0hyl0o.d(20): Error: no property `clone` for type `long[]`\n/tmp/tmp7z0hyl0o.d(29): Error: undefined identifier `java`\n/tmp/tmp7z0hyl0o.d(30): Error: undefined identifier `java`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7z0hyl0o.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n        result[i] = nums[i];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmppwdbdw4b.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x4287ad]\n??:? void tmppwdbdw4b.__unittest_L26_C1() [0x427fa1]\n??:? void tmppwdbdw4b.__modtest() [0x42852c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c88b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b71e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4309a9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430e58]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430935]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b6f5]\n??:? runModuleUnitTests [0x42c661]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428c70]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] sorted_nums = new long[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n        long sum = 0;\n        for (int j = 0; j < nums[i].length(); j++) {\n            sum += nums[i].charAt(j) - '0';\n        }\n        sorted_nums[i] = sum;\n    }\n    java.util.Arrays.sort(sorted_nums);\n    return sorted_nums;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293471,
      "stdout": "",
      "stderr": "/tmp/tmpzrl27jq5.d(22): Error: no property `length` for type `long`\n/tmp/tmpzrl27jq5.d(23): Error: no property `charAt` for type `long`\n/tmp/tmpzrl27jq5.d(27): Error: undefined identifier `java`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzrl27jq5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    \n    for (int i = 0; i < nums.length; i++) {\n        long sum = 0;\n        for (int j = 0; j < nums[i] * 10; j++) {\n            sum += j;\n        }\n        result[i] = sum;\n    }\n    \n    java.util.Arrays.sort(result);\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293471,
      "stdout": "",
      "stderr": "/tmp/tmpajqp99e9.d(19): Error: no property `clone` for type `long[]`\n/tmp/tmpajqp99e9.d(29): Error: undefined identifier `java`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpajqp99e9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    int len = nums.length;\n    \n    for (int i = 0; i < len; i++) {\n        int sum = 0;\n        for (int j = 0; j < len; j++) {\n            sum += nums[j];\n        }\n        \n        int index = i;\n        for (int j = i + 1; j < len; j++) {\n            if (sum - nums[j] < sum - nums[index]) {\n                index = j;\n            }\n        }\n        \n        if (index != i) {\n            long temp = result[i];\n            result[i] = result[index];\n            result[index] = temp;\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293471,
      "stdout": "",
      "stderr": "/tmp/tmpo2yde902.d(19): Error: no property `clone` for type `long[]`\n/tmp/tmpo2yde902.d(20): Error: cannot implicitly convert expression `nums.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo2yde902.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    int[] sums = new int[10];\n    for(int i = 0; i < nums.length; i++)\n    {\n        sums[nums[i] % 10]++;\n    }\n    for(int i = 0; i < 10; i++)\n    {\n        for(int j = 0; j < sums[i]; j++)\n        {\n            result[j] = i;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293471,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp1v69s1tn.d(23): Range violation\n----------------\n??:? _d_arrayboundsp [0x428b96]\n??:? long[] tmp1v69s1tn.order_by_points(long[]) [0x42816c]\n??:? void tmp1v69s1tn.__unittest_L34_C1() [0x428268]\n??:? void tmp1v69s1tn.__modtest() [0x428868]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cda7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bc3a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ec5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431374]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430e51]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bc11]\n??:? runModuleUnitTests [0x42cb7d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int funct",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    int n = nums.length;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (nums[i] + nums[j] == nums[i] * 10 + nums[j]) {\n                long temp = nums[i];\n                nums[i] = nums[j];\n                nums[j] = temp;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293469,
      "stdout": "",
      "stderr": "/tmp/tmpf92ka__w.d(19): Error: no property `clone` for type `long[]`\n/tmp/tmpf92ka__w.d(20): Error: cannot implicitly convert expression `nums.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf92ka__w.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    int n = nums.length;\n    for (int i = 0; i < n; i++) {\n        int sum = 0;\n        for (int j = 0; j < nums[i] < 0 ? nums[i] * -1 : nums[i]; j++) {\n            sum += nums[i] % 10;\n        }\n        for (int j = 0; j < nums[i] < 0 ? nums[i] * -1 : nums[i]; j++) {\n            sum -= nums[i] % 10;\n        }\n        for (int j = 0; j < nums[i] < 0 ? nums[i] * -1 : nums[i]; j++) {\n            sum += nums[i] % 10;\n        }\n        for (int j = 0; j < nums[i] < 0 ? nums[i] * -1 : nums[i]; j++) {\n            sum -= nums[i] % 10;\n        }\n        result[i] = sum;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpcnjzdnca.d(23): Error: found `<` when expecting `;` following `for` condition\n/tmp/tmpcnjzdnca.d(23): Error: found `;` when expecting `)`\n/tmp/tmpcnjzdnca.d(23): Error: found `)` when expecting `;` following statement\n/tmp/tmpcnjzdnca.d(26): Error: found `<` when expecting `;` following `for` condition\n/tmp/tmpcnjzdnca.d(26): Error: found `;` when expecting `)`\n/tmp/tmpcnjzdnca.d(26): Error: found `)` when expecting `;` following statement\n/tmp/tmpcnjzdnca.d(29): Error: found `<` when expecting `;` following `for` condition\n/tmp/tmpcnjzdnca.d(29): Error: found `;` when expecting `)`\n/tmp/tmpcnjzdnca.d(29): Error: found `)` when expecting `;` following statement\n/tmp/tmpcnjzdnca.d(32): Error: found `<` when expecting `;` following `for` condition\n/tmp/tmpcnjzdnca.d(32): Error: found `;` when expecting `)`\n/tmp/tmpcnjzdnca.d(32): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcnjzdnca.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    int[] indexes = new int[nums.length];\n    long sum = 0;\n    for (int i = 0; i < nums.length; i++) {\n        sum += nums[i];\n    }\n    for (int i = 0; i < nums.length; i++) {\n        indexes[i] = i;\n    }\n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (sum - nums[i] == sum - nums[j]) {\n                indexes[i] = j;\n                indexes[j] = i;\n            }\n        }\n    }\n    for (int i = 0; i < nums.length; i++) {\n        result[i] = nums[indexes[i]];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293471,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp4ir9cv4c.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x428c15]\n??:? void tmp4ir9cv4c.__unittest_L41_C1() [0x428409]\n??:? void tmp4ir9cv4c.__modtest() [0x428994]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ced7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bd6a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ff5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4314a4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430f81]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bd41]\n??:? runModuleUnitTests [0x42ccad]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4290d8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums;\n    long sum = 0;\n    for(int i = 0; i < nums.length; i++)\n    {\n        sum += nums[i];\n    }\n    \n    for(int i = 0; i < nums.length; i++)\n    {\n        for(int j = i + 1; j < nums.length; j++)\n        {\n            if(nums[i] + nums[j] == sum && nums[i] != nums[j])\n            {\n                long temp = nums[i];\n                nums[i] = nums[j];\n                nums[j] = temp;\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293471,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmppwdlwbl9.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x4288e5]\n??:? void tmppwdlwbl9.__unittest_L41_C1() [0x4280dd]\n??:? void tmppwdlwbl9.__modtest() [0x428668]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c967]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7fa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43098d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430e3c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430919]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7d1]\n??:? runModuleUnitTests [0x42c73d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428da8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    for (int i = 0; i < result.length; i++) {\n        for (int j = i + 1; j < result.length; j++) {\n            if (sum_of_digits(result[i]) == sum_of_digits(result[j])) {\n                long temp = result[i];\n                result[i] = result[j];\n                result[j] = temp;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293471,
      "stdout": "",
      "stderr": "/tmp/tmp6tvyjja8.d(19): Error: no property `clone` for type `long[]`\n/tmp/tmp6tvyjja8.d(22): Error: undefined identifier `sum_of_digits`\n/tmp/tmp6tvyjja8.d(22): Error: undefined identifier `sum_of_digits`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6tvyjja8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n        long sum = 0;\n        for (int j = 0; j < nums[i] < 0 ? nums[i] * -1 : nums[i]; j++) {\n            sum += nums[i] % 10;\n        }\n        result[i] = sum;\n    }\n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (result[i] == result[j]) {\n                result[i] = nums[i];\n                result[j] = nums[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "/tmp/tmpudm6lrhy.d(22): Error: found `<` when expecting `;` following `for` condition\n/tmp/tmpudm6lrhy.d(22): Error: found `;` when expecting `)`\n/tmp/tmpudm6lrhy.d(22): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpudm6lrhy.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    int len = nums.length;\n    for (int i = 0; i < len; i++) {\n        for (int j = i + 1; j < len; j++) {\n            if (nums[i] + nums[j] == nums[i] + nums[j]) {\n                long temp = nums[i];\n                nums[i] = nums[j];\n                nums[j] = temp;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293471,
      "stdout": "",
      "stderr": "/tmp/tmpg0we9xia.d(19): Error: no property `clone` for type `long[]`\n/tmp/tmpg0we9xia.d(20): Error: cannot implicitly convert expression `nums.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg0we9xia.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    \n    for (int i = 0; i < nums.length; i++) {\n        long sum = 0;\n        for (int j = 0; j < nums[i] < 0 ? nums[i] * -1 : nums[i]; j++) {\n            sum += nums[i] % 10;\n        }\n        result[i] = sum;\n    }\n    \n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (result[i] == result[j]) {\n                result[i] = nums[i];\n                result[j] = nums[j];\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293471,
      "stdout": "",
      "stderr": "/tmp/tmpvnblcn8r.d(23): Error: found `<` when expecting `;` following `for` condition\n/tmp/tmpvnblcn8r.d(23): Error: found `;` when expecting `)`\n/tmp/tmpvnblcn8r.d(23): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvnblcn8r.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] sorted = nums.clone();\n    sort(sorted, (a, b) -> {\n        long sum_a = 0, sum_b = 0;\n        for (int i = 0; i < Math.min(a.length(), b.length()); i++) {\n            sum_a += a[i] * Math.pow(10, i);\n            sum_b += b[i] * Math.pow(10, i);\n        }\n        return sum_a - sum_b;\n    });\n    return sorted;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293471,
      "stdout": "",
      "stderr": "/tmp/tmppixbrssw.d(20): Error: expression expected, not `>`\n/tmp/tmppixbrssw.d(20): Error: found `{` when expecting `,`\n/tmp/tmppixbrssw.d(21): Error: found `sum_a` when expecting `.` following long\n/tmp/tmppixbrssw.d(21): Error: found `=` when expecting identifier following `long`.\n/tmp/tmppixbrssw.d(21): Error: found `0` when expecting `,`\n/tmp/tmppixbrssw.d(21): Error: expression expected, not `,`\n/tmp/tmppixbrssw.d(21): Error: found `sum_b` when expecting `,`\n/tmp/tmppixbrssw.d(21): Error: expression expected, not `=`\n/tmp/tmppixbrssw.d(21): Error: found `0` when expecting `,`\n/tmp/tmppixbrssw.d(21): Error: expression expected, not `;`\n/tmp/tmppixbrssw.d(22): Error: found `for` when expecting `,`\n/tmp/tmppixbrssw.d(22): Error: found `i` when expecting `.` following int\n/tmp/tmppixbrssw.d(22): Error: found `=` when expecting identifier following `int`.\n/tmp/tmppixbrssw.d(22): Error: found `0` when expecting `)`\n/tmp/tmppixbrssw.d(22): Error: found `;` when expecting `,`\n/tmp/tmppixbrssw.d(22): Error: found",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    for(int i = 0; i < nums.length; i++)\n    {\n        long sum = 0;\n        for(int j = 0; j < nums[i] != 0; j++)\n        {\n            sum += nums[i] % 10;\n            nums[i] /= 10;\n        }\n        result[i] = sum;\n    }\n    \n    for(int i = 0; i < nums.length; i++)\n    {\n        for(int j = i + 1; j < nums.length; j++)\n        {\n            if(result[i] == result[j])\n            {\n                result[i] = nums[i];\n                result[j] = nums[j];\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293471,
      "stdout": "",
      "stderr": "/tmp/tmpv_al4esu.d(23): Error: found `!=` when expecting `;` following `for` condition\n/tmp/tmpv_al4esu.d(23): Error: found `;` when expecting `)`\n/tmp/tmpv_al4esu.d(23): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv_al4esu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    \n    for(int i = 0; i < result.length; i++)\n    {\n        long sum = 0;\n        for(int j = 0; j < result[i].toString().length(); j++)\n        {\n            sum += Math.pow(10, j) * result[i].toString().charAt(j) - Math.pow(10, j);\n        }\n        \n        for(int j = 0; j < result.length; j++)\n        {\n            if(sum == 0 && result[j] == 0)\n            {\n                result[i] = result[j];\n                break;\n            }\n            else if(sum < 0 && result[j] > 0)\n            {\n                result[i] = result[j];\n                break;\n            }\n            else if(sum > 0 && result[j] < 0)\n            {\n                result[i] = result[j];\n                break;\n            }\n            else if(sum > 0 && result[j] > 0)\n            {\n                if(result[i] < result[j])\n                {\n                    result[i] = result[j];\n                }\n                break;\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293471,
      "stdout": "",
      "stderr": "/tmp/tmp6e_1qial.d(19): Error: no property `clone` for type `long[]`\n/tmp/tmp6e_1qial.d(24): Error: no property `toString` for type `long`\n/tmp/tmp6e_1qial.d(26): Error: undefined identifier `Math`\n/tmp/tmp6e_1qial.d(26): Error: no property `toString` for type `long`\n/tmp/tmp6e_1qial.d(26): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6e_1qial.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = new long[nums.length];\n    int[] sums = new int[10];\n    for (int i = 0; i < nums.length; i++) {\n        sums[nums[i] % 10]++;\n    }\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < sums[i]; j++) {\n            result[j] = i;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293470,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpwlf4ggfu.d(22): Range violation\n----------------\n??:? _d_arrayboundsp [0x428b96]\n??:? long[] tmpwlf4ggfu.order_by_points(long[]) [0x42816c]\n??:? void tmpwlf4ggfu.__unittest_L31_C1() [0x428268]\n??:? void tmpwlf4ggfu.__modtest() [0x428868]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cda7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bc3a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ec5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431374]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430e51]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bc11]\n??:? runModuleUnitTests [0x42cb7d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428fa8]\n??:? void rt.dmain2._d_run_main(int, char**, e",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] sorted = new long[nums.length];\n    int i = 0;\n    for (long n : nums) {\n        sorted[i++] = n;\n    }\n    \n    for (int j = 0; j < sorted.length - 1; j++) {\n        for (int k = j + 1; k < sorted.length; k++) {\n            if (sorted[j] + sorted[k] == sorted[k] + sorted[j]) {\n                long temp = sorted[j];\n                sorted[j] = sorted[k];\n                sorted[k] = temp;\n            }\n        }\n    }\n    \n    return sorted;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293471,
      "stdout": "",
      "stderr": "/tmp/tmpvgfjp4sr.d(21): Error: semicolon expected, not `:`\n/tmp/tmpvgfjp4sr.d(21): Error: expression expected, not `:`\n/tmp/tmpvgfjp4sr.d(21): Error: found `nums` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvgfjp4sr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which sorts the given array of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original array.\n\n    For example:\n    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L, 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[] nums) \n{\n    long[] result = nums.clone();\n    \n    for (int i = 0; i < result.length; i++) {\n        long sum = 0;\n        for (int j = 0; j < result[i].toString().length(); j++) {\n            sum += Math.pow(10, j) * result[i].toString().charAt(j) - (result[i].toString().charAt(j) - '0');\n        }\n        \n        for (int j = 0; j < result.length; j++) {\n            if (sum == 0 && result[j] == 0) {\n                result[i] = result[j];\n                result[j] = 0;\n                break;\n            }\n            \n            if (sum < 0 && result[j] > 0) {\n                result[i] = result[j];\n                result[j] = 0;\n                break;\n            }\n            \n            if (sum > 0 && result[j] < 0) {\n                result[i] = result[j];\n                result[j] = 0;\n                break;\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L, 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L, 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L, 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L, -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L, -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}",
      "timestamp": 1664293471,
      "stdout": "",
      "stderr": "/tmp/tmp4ls89mr3.d(19): Error: no property `clone` for type `long[]`\n/tmp/tmp4ls89mr3.d(23): Error: no property `toString` for type `long`\n/tmp/tmp4ls89mr3.d(24): Error: undefined identifier `Math`\n/tmp/tmp4ls89mr3.d(24): Error: no property `toString` for type `long`\n/tmp/tmp4ls89mr3.d(24): Error: no property `toString` for type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4ls89mr3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}