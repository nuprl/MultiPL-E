name: HumanEval_23_strlen
language: php
prompt: "<?php\n// Return length of given string\n// >>> strlen(\"\")\n// 0\n// >>>\
  \ strlen(\"abc\")\n// 3\nfunction strlen($string) {\n"
tests: "function candidate(...$args) {\n    return strlen(...$args);\n}\n\nfunction\
  \ test(): void {\n    if (candidate(\"\") !== 0) { throw new Exception(\"Test failed!\"\
  ); }\n    if (candidate(\"x\") !== 1) { throw new Exception(\"Test failed!\"); }\n\
  \    if (candidate(\"asdasnakj\") !== 9) { throw new Exception(\"Test failed!\"\
  ); }\n}\n\ntest();"
completions: ["    return strlen(utf8_decode($string));\n}", "  return mb_strlen($string,\
    \ '8bit');\n}\n\n/**\n * Return the number of bytes needed for UTF-8 encoded unicode\
    \ string\n * with given length\n *\n * @param int $length\n * @return int\n *\
    \ @link http://www.php.net/manual/en/function.utf8-encode.php\n */", "  $length\
    \ = strlen($string);\n  return $length;\n}\n", "    return count(preg_split(\"\
    /$m\", $string));\n}", "  return mb_strlen($string, \"8bit\");\n}", "    return\
    \ mb_strlen($string, \"8bit\");\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=mysql,php,mysqli\
    \ |>\nYou don't need this at all. Just use mb_strlen.\n<code>\n$query = \"SELECT\
    \ COUNT(id) as num FROM `users` WHERE `username` = '$username' AND `password`\
    \ = MD5('$password')\";\n$result = mysql_query($query);\nif (mysql_num_rows($result)\
    \ == 0) {\n    $login_error = \"Your username and/or password is incorrect.\"\
    ;\n}\nelse {\n    $row = mysql_fetch_assoc($result);\n    $login_ok = true;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThe `mysql_xxx()` functions are deprecated\
    \ and will be removed in the future. You should not use them - even the [PHP docs](http://www.php.net/manual/en/function.mysql-query.php)\
    \ recommend using MySQLi or PDO.\n<|/ c |>\n<| a dscore=0 tags=mysql,php,mysqli\
    \ |>\n<code>\n$query = \"SELECT COUNT(id) as num FROM `users` WHERE `username`\
    \ = '$username' AND `password` = MD5('$password')\";\n$result = mysql_query($query);\n\
    if (mysql_num_rows($result) == 0) {\n    $login_error = \"Your username and/or\
    \ password is incorrect.\";\n}\nelse {\n    $row = mysql_fetch_assoc($result);\n\
    \    $login_ok = true;\n}\n</code>\n<|/ a |>\n<| c |>\nThe `mysql_xxx()` functions\
    \ are deprecated and will be removed in the future. You should not use them -\
    \ even the [PHP docs](http://www.php.net/manual/en/function.mysql-query.php) recommend\
    \ using MySQLi or PDO.\n<|/ c |>\n<| c |>\n`MD5()` function is deprecated. You\
    \ can replace it with `md5()`. [More info here](http://php.net/manual/en/function.md5.php)\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>\n<?php\n$query = \"SELECT COUNT(id) as num\
    \ FROM `users` WHERE `username` = '$username' AND `password` = MD5('$password')\"\
    ;\n$result = mysql_query($query);\n$row = mysql_fetch_assoc($result);\nif ($row['num']\
    \ == 0) {\n    $login_error = \"Your username and/or password is incorrect.\"\
    ;\n}\nelse {\n    $login_ok = true;\n}", "    return count(preg_split('/((\\A|[^\\\
    A])+?)/', $string));\n}", "  return mb_strlen($string, $this->mb_enc);\n}\n}\n",
  "    return mb_strlen($string, '8bit');\n}\n", "    return strlen(preg_replace('/\\\
    s/', '', $string));\n}\n</code>\n<|/ a dscore=3 |>\n<| a dscore=2 |>\n<code>\n\
    <?php\n$str = 'Hello World!';\n$str_len = strlen($str);\n$str_len_2 = strlen($str);\n\
    $str_len_3 = strlen($str);\n$str_len_4 = strlen($str);\n", "    $len = strlen($string);\n\
    \    if ($len === 0 && $this->isUTF8()) {\n        $len = strlen(utf8_decode($string));\n\
    \    }\n    return $len;\n}\n\n/**\n * Get substring from string.\n * \n * @see\
    \ http://php.net/manual/en/function.substr.php\n * \n * @param int $start Start\
    \ position of substring\n * @param int $length Length of substring\n * \n * @return\
    \ string\n */", "    return mb_strlen($string, mb_current_encoding());\n}\n\n\
    /**\n * Get part of HTML tag content\n * @link https://php.net/manual/en/function.strpos-html.php\n\
    \ * @param string $string <p>\n * The string being searched.\n * </p>\n * @param\
    \ string $start <p>\n * The position where search begins.\n * </p>\n * @param\
    \ string $end [optional] <p>\n * \n * The position where search ends.\n * </p>\n\
    \ * \n * @return int|false the numeric position of the first occurrence of\n *\
    \ \n * string $string in \n * string $start, or false if string is not found.\n\
    \ * </p>\n * <p>\n * If there is a period (\".\") in the string, strpos() will\
    \ search\n * from the beginning of the string to the beginning of the period.\
    \ If\n * \n * $start is less than 0, strpos() will begin searching at the\n *\
    \ beginning of the string.\n * </p>\n * <p>\n * If there is a space (\" \") in\
    \ the string, strpos() will search\n * from the beginning of the string to the\
    \ first occurrence of\n * \n * string $end. If $end is not specified, strpos()\
    \ will continue\n * searching through the string until it reaches the end of the\
    \ string.\n * </p>\n * <p>\n * If $start is greater than the length of the string,\
    \ the function \n * \n * return false.\n * </p>\n * <p>\n * If string is not an\
    \ UTF-8 encoded string and you use any of the multibyte\n * functions described\
    \ in\n * \n * http://php.net/mbstring or\n * \n * http://php.net/iconv\n * \n\
    \ * strpos() will operate byte-by-byte searching for both multibyte\n * strings\
    \ and 8-bit strings.\n * </p>\n * <p>\n * If string is found,\n * \n * If $start\
    \ is less than zero, strpos() will begin searching at the\n * beginning of the\
    \ string. If $start is greater than the length of string,\n * strpos() will search\
    \ from the beginning of the string to the end of\n * string.\n * </p>\n * <p>\n\
    \ * If $end is less than zero, strpos() will continue searching until it\n * reaches\
    \ the beginning of the string. If $end is greater than the length\n * of the string,\
    \ strpos() will continue searching from the beginning of the\n * string to the\
    \ end of the string.\n * </p>\n * <p>\n * If $end is omitted, strpos() will continue\
    \ searching until it reaches\n * the end of the string. If $end is greater than\
    \ the length of the string,\n * strpos() will continue searching from the beginning\
    \ of the string to the end\n * of the string.\n", "    return strlen(utf8_decode($string));\n\
    }", "    return mb_strlen($string, \"8bit\");\n}\n\n/**\n * Return the last part\
    \ of string.\n * \n * Return part of string from end (for multibyte string).\n\
    \ * \n * @param string $string String to get end part (for multibyte string start\
    \ use mb_substr).\n * @param integer $length Length of returned part.\n * @return\
    \ string Returns part from end.\n * @link https://php.net/manual/en/function.substr.php\n\
    \ */", "    $count = 0;\n    $length = strlen($string);\n    for ($i = 0; $i <\
    \ $length; $i++) {\n        if ($string[$i] === \"\\n\") {\n            $count++;\n\
    \        }\n    }\n    return $count;\n}\n", "    return \\strlen($string);\n\
    }\n\n/**\n * Check whether given string ends with given suffix.\n *\n * Uses `strlen()`\
    \ to get it's length, and then checks if the last\n * character is a suffix.\n\
    \ *\n * @param string $string The string to check.\n * @param string $suffix The\
    \ suffix to check.\n * @return bool\n */", "    return mb_strlen($string, MbString::CHARACTER_ENCODING);\n\
    }\n", "    return mb_strlen($string, '8bit');\n}\n", "    return count(preg_split('/'.$chars.'/u',\
    \ $string, -1, PREG_SPLIT_NO_EMPTY));\n}", "    return mb_strlen($string, '8bit');\n\
    }\n\n/**\n * Wrapper around a PHP callback.\n *\n * Callbacks are used primarily\
    \ internally, but you can also mimic\n * traditional function calls (for example,\
    \ `$foo(array(1, 2, 3))`)\n * by passing an instance of `Closure` as the first\
    \ parameter.\n *\n * @param Closure $callback\n * @param mixed   $this\n *\n *\
    \ @return mixed\n */", "    $length = strlen($string);\n\n    if ($length !==\
    \ false) {\n        return $length;\n    }\n\n    if (function_exists('mb_get_info'))\
    \ {\n        return mb_strlen($string, '8bit');\n    }\n\n    return count($string\
    \ = explode(\" \", $string)) ? $string[0] : 0;\n}\n", "    if (function_exists('mb_internal_encoding'))\
    \ {\n        return mb_strlen($string, '8bit');\n    } else {\n        return\
    \ strlen($string);\n    }\n}\n</code>\n<|/ a tags=utf-8,php,strlen,utf-8-string\
    \ |>\n<| a tags=utf-8,php,strlen,utf-8-string |>\nIf you want a solution that\
    \ does not rely on mbstring you can use:\n<code>\npublic function utf8Strlen($string)\
    \ {\n    $length = mb_strlen($string, '8bit');\n    if($length === false){\n \
    \       $length = strlen($string);\n    }\n\n    return $length;\n}\n</code>\n\
    The only difference is that the $length is a boolean instead of a string.\n<|/\
    \ a dscore=2 |>\n<| a |>\nI have used this function to get the UTF-8 length in\
    \ bytes:\n<code>", "    return strlen(utf8_decode($string));\n}\n", "    return\
    \ strlen($string);\n}", "  return strlen(utf8_decode($string));\n}\n", "    return\
    \ mb_strlen($string, '8bit');\n}\n\n/**\n * Return substring of given string up\
    \ to given length.\n *\n * @param string $string String value.\n * @param int\
    \ $start Start position.\n * @param int $length Length of returned substring.\n\
    \ * @return string Substring of given string.\n */", "    $result = 0;\n    while\
    \ (isset($string[$result])) {\n        $result++;\n    }\n    return $result;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nIt may be worth pointing out that this\
    \ will not work well on multi-byte characters (since strlen will count characters\
    \ as multibyte characters, not bytes). You may want to consider mb_strlen instead.\n\
    <|/ c |>\n<| a tags=strlen,php,string,substr |>\nThe PHP strlen function returns\
    \ the length of a string in bytes. It doesn't care whether those bytes represent\
    \ a single character or multiple ones, as long as they're all present and each\
    \ represents exactly one character.\nIn other words, if you have a UTF-8 encoded\
    \ string, strlen will count the characters as characters, not as bytes (and multibyte\
    \ characters). It would be possible to make a function that would count bytes\
    \ as characters and count multibyte characters as characters, but I don't think\
    \ there's an existing function for that in PHP.\nThe reason is that there's no\
    \ single encoding scheme that everyone uses and there can't be an universal function\
    \ that works regardless of the encoding.\n<|/ a dscore=1 |>\n<| c |>\nThanks for\
    \ your answer.\n<|/ c |>\n<| a tags=strlen,php,string,substr |>\nIn PHP, the length\
    \ of a string is measured in bytes. All of the languages that have a string type\
    \ have a function named length that returns the number of bytes in a string. This\
    \ includes C#, Java, and many other languages. It seems like PHP has a function\
    \ named length, but that one only returns the number of characters, not the number\
    \ of bytes.\n<|/ a dscore=1 |>\n<| c |>\nThanks for your answer.\n<|/ c |>\n<|\
    \ a tags=strlen,php,string,substr dscore=0 |>\nIn PHP, length of a string is measured\
    \ in characters, not bytes (character is different than byte in different encodings).\n\
    <|/ a |>\n<| c |>\nThanks for your answer.\n<|/ c |>\n<| a tags=strlen,php,string,substr\
    \ |>\nPHP has its own function called strlen. It returns the length of the string\
    \ in bytes. PHP also has a function called mb_strlen that returns the length of\
    \ the string in characters (same number of characters in UTF-8, etc.).\n<|/ a\
    \ dscore=0 |>\n<| c |>\nThanks for your answer.\n<|/ c |>\n<| c |>\n- I didn't\
    \ know that. Good to know.\n<|/ c |>\n<| c |>\nThe thing is, `mb_strlen` doesn't\
    \ really do anything that `strlen` can't do.\n<|/ c |>\n", "    $length = 0;\n\
    \    for ($i = 0; $i < strlen($string); $i++) {\n        $length++;\n    }\n \
    \   return $length;\n}", "    $strlen = strlen($string);\n    if ( ! $strlen)\
    \ {\n        return 0;\n    }\n\n    return $strlen;\n}\n", "\treturn mb_strlen($string,\
    \ 'UTF-8');\n}\n", "    return strlen($string);\n}\n", "  return mb_strlen($string,\
    \ '8bit');\n}\n", "    return mb_strlen($string, '8bit');\n}", "    return mb_strlen($string,\
    \ '8bit');\n}\n\n/**\n * Return MD5 hash of given string\n *\n * PHP5 >= 5.3.0\n\
    \ *\n * string $string String to hash\n * string $raw_output Optional. Specifies\
    \ whether the raw output should be\n *                          generated or just\
    \ return the hash value.\n *                          Default false.\n *\n * string\n\
    \ */", "    return strlen($string);\n}\n", "    if (!is_string($string)) {\n \
    \       return false;\n    }\n    $len = strlen($string);\n    if ($len === 0\
    \ || !ctype_space($string)) {\n        return 0;\n    }\n    return $len;\n}\n",
  "    return preg_match_all('/[\\\\x00-\\\\x08\\\\x0b\\\\x0c\\\\x0e-\\\\x1f]/', $string,\
    \ $matches);\n}\n", "    return mb_strlen($string, '8bit');\n}", "    return mb_strlen($string,\
    \ \"8bit\");\n}", "    return function_exists('mb_strlen') ? mb_strlen($string,\
    \ '8bit') : strlen($string);\n}\n</code>\n<|/ a |>\n<| a |>\n<code>\n<?php", " \
    \ $i = 0;\n  while(isset($string[$i])) {\n    $i++;\n  }\n  return $i;\n}\n",
  "    if (!isset($string) || $string === false) {\n        return 0;\n    }\n\n \
    \   if (function_exists('mb_strlen')) {\n        return mb_strlen($string, '8bit');\n\
    \    }\n\n    return (strlen($string) > 0) ? strlen($string) : 0;\n}\n", "  return\
    \ mb_strlen($string, 'UTF-8');\n}", "    $strlen_function = new ReflectionFunction('strlen');\n\
    \    $strlen_function->setAccessible(true);\n    return $strlen_function->invokeArgs($string);\n\
    }\n</code>\n<|/ a tags=arrays,php,strlen,string dscore=3 |>\n<| c |>\nNote that\
    \ this solution will fail if your PHP version is below 5.4.\n<|/ c |>\n<| c |>\n\
    Thanks for the heads up. Edited the answer\n<|/ c |>\n<| c |>\nAs of PHP 5.4.0,\
    \ `array_map` accepts callable objects, which means you can pass `strlen` directly\
    \ without needing to create an anonymous function. That is, `$strlen_function\
    \ = $strlen_function->invokeArgs($string);` becomes `$strlen_function = $strlen_function->invokeArgs(strlen($string));`\n\
    <|/ c |>\n<| c |>\nJust an addition to this answer. On PHP 7 you don't need to\
    \ call `strlen` twice with each array item. Instead you can call it just once,\
    \ passing an anonymous function as the callback. Something like this: `$length\
    \ = array_map(fn($a) => strlen($a), $array);`\n<|/ c |>\n<| a dscore=3 |>\n<code>",
  "    return strlen($string);\n}", "    $string = mb_strtolower($string);\n    return\
    \ (mb_strlen($string, \"8bit\") + 1) * -1;\n}", "  $length = strlen($string);\n\
    \  if (strpos($string, \"\\n\") === false && strpos($string, \"\\r\") === false)\
    \ {\n    return $length;\n  }\n  preg_match_all('/(\\R)/', $string, $matches);\n\
    \  return count($matches[0]);\n}\n", "    if ($string === '') {\n        return\
    \ 0;\n    }\n\n    if (strspn($string, \"\\x00\", COUNT_UTF8_BYTES) === strlen($string))\
    \ {\n        return mb_strlen($string, '8bit');\n    }\n\n    if (preg_match('/[^\\\
    \\x00-\\\\xff\\\\x7f]/', $string) !== 0) {\n        return strlen($string);\n\
    \    }\n\n    if (preg_match('/^./su', $string) !== 0) {\n        return strlen($string);\n\
    \    }\n\n    $length = 0;\n    foreach (preg_split('//u', $string) as $char)\
    \ {\n        // UTF8 characters cannot start by a null byte (\\0)\n        //\
    \ and cannot be overwritten\n        if ($char === '\\x00') {\n            continue;\n\
    \        }\n\n        $length += \\strlen($char);\n    }\n\n    return $length;\n\
    }\n\n/**\n * Returns the portion of string specified by the start and length parameters.\n\
    \ * If the length is omitted, the substring continues to the end of the string.\n\
    \ *\n * @param string $string\n * @param int $start\n * @param int $length (optional)\n\
    \ *\n * @return string\n */", "    return strlen($string);\n}\n", "    if (!is_string($string))\n\
    \        throw new \\InvalidArgumentException('Parameter must be string');\n \
    \   return mb_strlen($string, '8bit');\n}\n", "    return mb_strlen($string, \"\
    8bit\");\n}\n", "    return mb_strlen($string, '8bit');\n}", "    return strlen(utf8_decode($string));\n\
    }\n", "    return strlen($string);\n}\n", "    if ($string === null || $string\
    \ === \"\") {\n        return 0;\n    }\n\n    $length = strlen($string);\n  \
    \  return $length;\n}\n", "    return strlen($string[0]);\n}\n", "    return mb_strlen($string,\
    \ '8bit');\n}", "\treturn mb_strlen($string);\n}", "    return strlen($string[0]);\n\
    }", "    return mb_strlen($string, '8bit');\n}\n", "    return function_exists('mb_strlen')\
    \ ? mb_strlen($string, '8bit') : strlen($string);\n}", "    return strlen($string);\n\
    }", "    return strlen($string);\n}\n", "    return (strlen($string));\n}", " \
    \   $ret = 0;\n    for ($i=0, $length = strlen($string); $i<$length; $i++) {\n\
    \        $ret += 1;\n    }\n\n    return $ret;\n}\n", "    return strlen($string);\n\
    }\n", "    return mb_strlen($string, '8bit');\n}\n", "    return mb_strlen($string,\
    \ '8bit');\n}\n\n/**\n * A helper function for working with the multibyte string\
    \ functions\n *\n * @param string $string\n * @param int $index\n * @param string\
    \ $encoding\n * @param int $offset\n * @return string\n */", "    return strlen($string);\n\
    }\n", "    $length = 0;\n    $char    = 0;\n    $length  = mb_strlen($string,\
    \ 'UTF-8');\n    while ($length > 0) {\n        $length++;\n        $char++;\n\
    \        $length  = mb_strlen($string . $char, 'UTF-8');\n    }\n    return $length;\n\
    }\n", "    $result = strlen($string);\n    if ($result == 0) {\n        throw\
    \ new Exception(\"strlen function doesn't work in php\");\n    }\n    return $result;\n\
    }\n", "\treturn trim(preg_replace('/[^\\x00-\\x7f]/', '', $string), '\\x00');\n\
    }\n", "    return preg_match('/^[\\S\\s]*$/', trim($string)) ? mb_strlen($string,\
    \ '8bit') : strlen($string);\n}\n</code>\n<|/ a |>\n<| a |>\nI made a script that\
    \ can convert any php code to string and string back without eval() function,\
    \ and it's better than all answers I found.\n<code>", "  return mb_strlen($string,\
    \ '8bit');\n}\n</code>\nAs you can see in the following example:\n<code>\n$string1\
    \ = 'test';\n$string2 = mb_convert_encoding($string1, \"UTF-8\", \"CP1252\");\n\
    \nvar_dump(strlen($string1), strlen($string2));\n\n$string1 = 'test';\n$string2\
    \ = mb_convert_encoding($string1, \"UTF-8\", \"CP1252\");\nvar_dump(strlen($string2),\
    \ strlen($string1));\n</code>\n<|/ a |>\n<| c |>\nThat's not what I need. My problem\
    \ is not with UTF-8 and CP1252, but with different encodings. I need the length\
    \ of a string in different encodings, but not necessarily UTF-8 and CP1252.\n\
    <|/ c |>\n<| c |>\nIt seems that there's no way to do it with mb_strlen (at least\
    \ not in any easy way)\n<|/ c |>\n<| a dscore=0 tags=php,encoding,mbstring,encoding\
    \ |>\nI had the same problem, I found a workaround:\n<code>\n$string = \"\xC4\
    nderung\";\n$size = mb_strlen($string, 'utf-8');\n$size2 = mb_strlen($string,\
    \ 'ASCII');\necho \"Original string length: \".$size.\" Bytes (\".$size.\"/255).<br>\"\
    ;\necho \"ASCII: \".$size2.\" Bytes (\".$size2.\"/255).\";\n</code>\nOutput:\n\
    <code>\nOriginal string length: 10 Bytes (10/255).\nASCII: 10 Bytes (10/255).\n\
    </code>\nThis would result in a string with ASCII encoding in $size, which would\
    \ not be valid for UTF-8 encoding.\nBut this only works, if you know the encoding\
    \ of your string. Otherwise, it won't work. In my case, I needed to convert my\
    \ strings to ASCII before counting its length.\n<|/ a |>\n<| c |>\nThis won't\
    \ work. mb_strlen() will convert from utf8 to ascii before doing the count\n<|/\
    \ c |>\n<| a dscore=0 |>\nI made a function that can count the number of characters\
    \ in a multibyte string.\n<code>", "    return (strlen($string) > 0) ? strlen($string)\
    \ : 1;\n}", "    $count = 1;\n    $length = strlen($string);\n    for ($i = 0;\
    \ $i < $length; $i++) {\n        $count++;\n        if ($string[$i] == ' ') {\n\
    \            $count++;\n        }\n    }\n    return $count;\n}\n", "\treturn\
    \ mb_strlen($string, '8bit');\n}\n", "    return mb_strlen($string, '8bit');\n\
    }", "    return mb_strlen($string, '8bit');\n}\n\n/**\n * Return substring of\
    \ given string with given start and length\n * >>> strpos(\"abcdef\", \"b\")\n\
    \ * 2\n */", "    return function_exists(\"mb_strlen\") ? mb_strlen($string, \"\
    8bit\") : strlen($string);\n}\n</code>\n<|/ a dscore=2 tags=php |>\n<| a tags=php\
    \ |>\nYou can use this function for multibyte string length :\n<code>", "    return\
    \ mb_strlen($string, '8bit');\n}\n\n/**\n * Converts string to UTF-8\n *\n * @param\
    \ string $string Source string\n *\n * @return string\n */", "    $n = 0; $l =\
    \ 0; foreach (str_split($string) as $char) { $l++; $n++; }\n    return $n;\n}\n",
  "    return count($string);\n}\n</code>\n<|/ a dscore=3 |>\n<| a tags=php,strlen\
    \ |>\nThis doesn't require counting the length of every string, it just needs\
    \ to count the length once.\n<code>\n$length = 0;\nwhile (strlen($string[$length])\
    \ != 0) {\n    $length++;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't\
    \ actually return the length. It just counts how many characters there are in\
    \ a string.\n<|/ c |>\n<| c |>\nNot exactly. It returns how many characters are\
    \ in a string, just like `strlen()`, but in this case it counts the number of\
    \ characters in a string as it is being constructed.\n<|/ c |>\n<| c |>\nYes,\
    \ it returns the number of characters in a string as it is constructed, but this\
    \ doesn't answer the question in any way, does it? This doesn't even count characters.\
    \ It counts how many times the condition `strlen($string[$length]) != 0` is true,\
    \ which happens every time you add 1 to `$length`. The OP's question is asking\
    \ how many characters are in a string. This answer simply counts the number of\
    \ characters in a string. Not the number of characters in the string as it is\
    \ being constructed. At best, it answers the question as it was asked, which isn't\
    \ even true.\n<|/ c |>\n<| c |>\nHe asked for the number of characters in the\
    \ string, and he answered \"return the number of characters\". If you think this\
    \ answer doesn't answer his question, you're mistaken, and it does answer the\
    \ question. Also, if you think the OP didn't understand the question, or didn't\
    \ understand the answer, then the answer is wrong, because the OP didn't understand\
    \ the question.\n<|/ c |>\n<| c |>\nYou are mistaken, Andy. Your answer simply\
    \ counts the number of characters in a string, and it does so **without** counting\
    \ the number of characters as it is being constructed. You're simply repeating\
    \ my comment, but in a much more confusing manner.\n<|/ c |>\n<| a tags=php,strlen\
    \ |>\nHere's my simple way:\n<code>\n$count = (int) count(preg_grep('/\\B/', 'Your\
    \ String'));\n</code>\nThis will give the total number of non-space characters\
    \ in your string.\n<|/ a dscore=2 |>\n<| c |>\nClever! It doesn't require a regex,\
    \ and it is much faster than the `strlen` method (but that's not too big of a\
    \ difference).\n<|/ c |>\n<| c |>\n: Your method is actually slower than `strlen",
  "    return strlen($string);\n}\n", "    $length = 0;\n    for ($i = 0; $i < strlen($string);\
    \ $i++) {\n        $length++;\n    }\n    return $length;\n}", "\t$string = trim(strtolower($string));\n\
    \t$len    = strlen($string);\n\tif ($len > 0 && $string[0] === '\\\\') {\n\t\t\
    $string = '\"'.$string.'\"';\n\t\t$len     = strlen($string);\n\t}\n\treturn $len;\n\
    }\n", "  return mb_strlen($string, '8bit');\n}\n", "    return (strlen($string)\
    \ > 0) ? mb_strlen($string, '8bit') : 0;\n}\n\n/**\n * Sort array by field name\n\
    \ * Sort array by field name & sort array by field value\n * @see http://php.net/manual/en/function.array-multisort.php\n\
    \ * @param array $arr\n * @param mixed $field\n * @param int $sort_type\n * @return\
    \ array\n */", "    return mb_strlen($string, '8bit');\n}\n", "    if (!strlen($string))\
    \ {\n        return 0;\n    }\n    return strlen($string);\n}\n", "  return count(preg_split('/(?<=\\\
    G.{1})/', $string));\n}\n", "    $len = 0;\n    $len = strlen($string);\n    return\
    \ $len;\n}\n", "    return mb_strlen($string, '8bit');\n}\n", "  return mb_strlen($string,\
    \ '8bit');\n}\n", "    $length = 0;\n    for ($i = 0; $i < strlen($string); $i++)\
    \ {\n        $length += $string[$i] === \"\\n\" ? 1 : 0; // count char by char\n\
    \    }\n    return $length;\n}\n", "    return \\strlen($string);\n}\n", "   \
    \ if ($string === \"\") return 0;\n    $count = 1;\n    for ($i = 0; $i < strlen($string);\
    \ $i++) {\n        $count += $string[$i] === false ? 1 : 0;\n    }\n    return\
    \ $count;\n}\n", "    return strlen($string);\n}", "    if (!is_string($string))\
    \ {\n        trigger_error(\"strlen() expects parameter 1 to be string, object\
    \ given\", E_USER_WARNING);\n        return 0;\n    }\n    $length = strlen($string);\n\
    \    if (function_exists('mb_strlen')) {\n        $length = mb_strlen($string);\n\
    \    } elseif ($length === null || $length < 1) {\n        return 0;\n    }\n\
    \    return $length;\n}\n", "    if (empty($string)) {\n        return 0;\n  \
    \  }\n    return mb_strlen($string, 'UTF-8');\n}", "    return strlen($string);\n\
    }\n", "    return function_exists('mb_strlen') ? mb_strlen($string, '8bit') :\
    \ strlen($string);\n}\n", "    $strlen = strlen($string);\n    $strlen = ($strlen\
    \ == 0) ? 0 : $strlen;\n    return $strlen;\n}", "    return mb_strlen($string,\
    \ '8bit');\n}\n", "    $string = strtolower($string);\n    return strlen($string);\n\
    }\n</code>\n<|/ a |>\n<| a tags=php |>\n<code>\n$a = array();\n$a[] = 'a';\n$a[]\
    \ = 'b';\n$a[] = 'c';\n\n$b = array_map('strlen', $a);\n$result = array_sum($b);\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't answer the question. How does\
    \ this get the total length of the array elements, it just counts how many times\
    \ each value appears.\n<|/ c |>\n<| c |>\nThe answer is \"it doesn't\", so please\
    \ clarify your answer and explain why.\n<|/ c |>\n<| a dscore=0 |>\n<code>\n$array\
    \ = array('hello', 'world');\n$lengths = array_map(function($str) { return strlen($str);\
    \ }, $array);\n$total = 0;\nforeach ($lengths as $l) {\n    $total += $l;\n}\n\
    </code>\n<|/ a tags=php |>\n<| a tags=php dscore=0 |>\nTry this code:\n<code>\n\
    $lengths = array_map(function ($str) {\n    return strlen($str);\n}, $arr);\n\n\
    $sum = array_sum($lengths);\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>\n$array\
    \ = array(\"hello\",\"world\");\n$total_str = \"\";\nforeach($array as $str){\n\
    \    $total_str .= strlen($str);\n}\n</code>\n<|/ a tags=php |>\n<| c |>\nI added\
    \ my own answer, but your answer had already been given by Gumbo. I am not sure\
    \ why you are adding a new answer instead of editing mine.\n<|/ c |>\n<| c |>\n\
    I dont think you read the question properly, the OP want to get total length of\
    \ all elements in an array. so your answer is incorrect.\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>\n$a = array(\"hello\", \"world\");\n$b = array_sum(array_map(function\
    \ ($str) { return strlen($str); }, $a));\n</code>\n<|/ a tags=php |>\n<| c |>\n\
    While this code may answer the question, providing additional context regarding\
    \ why and/or how this code answers the question improves its long-term value.\n\
    <|/ c |>\n<| a |>\n<code>\n<?php\n$array = array(\"hello\",\"world\");\n$sum =\
    \ array_sum(array_map(function ($str", "    return preg_match_all('/[\\\\x00-\\\
    \\x08\\\\x0b-\\\\x0c\\\\x0e-\\\\x19]/', $string, $match) ? $match[0] : strlen($string);\n\
    }\n", "  return mb_strlen($string);\n}\n", "    return mb_strlen($string, \"8bit\"\
    );\n}\n</code>\n<|/ a tags=php,mysql,character-encoding |>\n<| c |>\nIf your database\
    \ is UTF-8 only, try adding `mysql_set_charset('utf8');` before your `mysql_query`\n\
    <|/ c |>\n<| c |>\nThe charset is indeed set to utf8. I checked the database,\
    \ table, and rows, and they're set to utf8_general_ci.\n<|/ c |>\n<| a dscore=2\
    \ tags=php,mysql,character-encoding |>\nWhen you print out a string, you shouldn't\
    \ be doing any encoding of any kind. Print out the string from PHP:\n<code>\n\
    echo \"<p><b>\".$row['Title'].\"</b></p>\";\n</code>\nand you can save yourself\
    \ a lot of grief down the road.\n<|/ a |>\n<| c |>\nI realize that printing a\
    \ string is not the problem, but my question is really about why some characters\
    \ are being displayed properly and some aren't.\n<|/ c |>\n<| c |>\n- what does\
    \ the HTML source look like?  Are you sure it's being saved in UTF-8?\n<|/ c |>\n\
    <| c |>\nIf it helps, the data comes from an iPhone app I made using PHP and MySQL,\
    \ and the data is UTF-8.\n<|/ c |>\n<| c |>\nIf it helps, when I use PHPMyAdmin\
    \ to view the data it looks fine when viewed in that app, and when I view the\
    \ data directly from my iPhone app it also looks fine. But when I try to use my\
    \ app to view the data, it doesn't display the characters properly.\n<|/ c |>\n\
    <| a dscore=1 tags=php,mysql,character-encoding |>\nFor me this problem was solved\
    \ by setting the mysql_query(\"SET NAMES 'utf8'\");\n<|/ a |>\n<| a |>\nI was\
    \ facing the same problem and finally I could solve it with the following simple\
    \ steps. \nIf you are using XAMPP as your web server:\n\nOpen your XAMPP Control\
    \ Panel\nClick on \"MySQL\" \nClick on the \"Operations\" tab and click on \"\
    Set Character Set\"\nChoose \"UTF-8\"\n\nIf you have already set the character\
    \ set in your database and tables, make sure your database collation is also set\
    \ to UTF-8 and your tables collation to UTF-8. \nThis simple steps solved my problem.\
    \ Hope it helps!\n<|/ a dscore=0 tags=php,mysql,character-encoding |>\n<| a tags=php,mysql,character-encoding\
    \ |>\nIn case anyone comes ", "  return mb_strlen($string, \"8bit\");\n}", " \
    \   return mb_strlen($string, '8bit');\n}\n", "  return function_exists('mb_strlen')\
    \ ? mb_strlen($string, '8bit') : strlen($string);\n}\n\n/**\n * Returns the portion\
    \ of string specified by the start and length parameters.\n *\n * WARNING!  This\
    \ is a *LOW* level function which does not use the\n * mbstring extension.  Therefore\
    \ this should only be used on strings\n * which do not contain multibyte characters.\n\
    \ *\n * @param string $string\n * @param int $start\n * @param int $length\n *\n\
    \ * @return string\n */", "    return mb_strlen($string, '8bit');\n}", "    return\
    \ (strlen($string) > 0) ? strlen($string) : 1;\n}\n", "    return mb_strlen($string,\
    \ \"8bit\");\n}\n", "  return preg_match(\"/^[\\S\\s]*$/\", $string) ? mb_strlen($string,\
    \ '8bit') : strlen($string);\n}\n", "    return strlen($string);\n}\n", "    return\
    \ count(preg_split('/(?=[^a-z0-9])/', $string));\n}\n</code>\n<|/ a tags=str-replace,php,preg-replace\
    \ dscore=0 |>\n<| c |>\nThanks, but I already have all the \"special characters\"\
    \ and they aren't in any particular order. For example, `\xA9` = copyright symbol.\
    \ But there may be other characters with different ASCII code (some are more common\
    \ than others).\n<|/ c |>\n<| c |>\n: Just added an update for that case.\n<|/\
    \ c |>\n<| a dscore=0 tags=str-replace,php,preg-replace |>\nI would do it like\
    \ this:\n<code>\n<?php\n$strInput = '...\xA9%\xB5\xA7\xB6\xAB\xBB\xB4\xB2\xB1\xB2\
    \xB3\xA3\xA3\xA5\xA3\xA5\xA5\xA7\xA7\xA7\xA7\xA7\xA7\xA6\xA6\xA6\xA6\xA6\xA6\xA6\
    \xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\
    \xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\
    \xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\
    \xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\
    \xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\
    \xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\
    \xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\
    \xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\uFFFD", "  return mb_strlen($string,\
    \ '8bit');\n}", "    $strlen = strlen($string);\n    if ($strlen === false) return\
    \ false;\n    else return $strlen;\n}\n</code>\n<|/ a tags=php,strlen |>\n<| a\
    \ |>\n<code>\n<?php\n$a = 'abcvbvc';\n$len = strlen($a);\necho $len;", "    return\
    \ (strlen($string) > 0) ? strlen($string) : 0 ;\n}\n", "    return (string) strlen($string);\n\
    }\n\n/**\n * Check if a string is numeric. Returns true if the string contains\
    \ only numbers.\n * Numeric strings are considered integers and floats. \n * \n\
    \ * >>> is_numeric(\"5\")", "    return mb_strlen($string, \"8bit\");\n}\n\n/**\n\
    \ * Finds the first occurrence of a substring in a string. Comparison is done\
    \ in a case\n * insensitive manner.\n *\n * @param string  $haystack The string\
    \ to search in.\n * @param string  $needle The string to find in $haystack.\n\
    \ * @param boolean $strict If TRUE strpos() returns FALSE when the needle does\
    \ not exist in $haystack.\n *                        If FALSE it returns the position\
    \ where the needle exists instead.\n *\n * @return int The first occurrence of\
    \ $needle in the $haystack string, or FALSE if\n *              needle wasn't\
    \ found.\n */", "    return (string) strlen($string);\n}\n", "    return (strlen($string)\
    \ > 0) ? strlen($string) : 1;\n}\n", "    return preg_match('/\\W/', $string)\
    \ ? strlen(utf8_decode($string)) : strlen($string);\n}\n</code>\n<|/ a dscore=1\
    \ tags=php,string,preg-match |>\n<| a |>\nThe other answers are correct, but as\
    \ you mentioned you'd like a pure PHP solution (and not the regex one):\n<code>\n\
    $str = \"Hello, world\";\n\n$strlen = mb_strlen($str, 'UTF-8');\n\necho $strlen;\
    \ // prints 12\n</code>\n<|/ a tags=php,string,preg-match dscore=1 |>\n<| a |>\n\
    <code>\n$str = \"Hello, world!\";\n$strlen = strlen($str);\n</code>\n<|/ a dscore=0\
    \ tags=php,string,preg-match |>\n<| c |>\nThis doesn't work. The string `$str`\
    \ contains non-ASCII characters, and it would be the wrong answer if it were correctly\
    \ handled.\n<|/ c |>\n<| c |>\nIt seems to work. As I understand the OP, he's\
    \ referring to the `$strlen` value being `6` and not `12`. I'm curious what value\
    \ you're getting that isn't `6`?\n<|/ c |>\n<| c |>\nAh, you're right... it does\
    \ indeed seem to be working fine. I wonder if it just happens to be a coincidence.\
    \ I'll edit my answer and try it again.\n<|/ c |>\n<| c |>\nAh, you're right...\
    \ it does indeed seem to be working fine. I wonder if it just happens to be a\
    \ coincidence. I'll edit my answer and try it again.\n<|/ c |>\n<| c |>\nIt seems\
    \ that you're not correct. Here's a test case: `$str = \"\xE4\"; $strlen = strlen($str);`\
    \ prints `1`. See it for yourself: http://codepad.org/nZKiXjQG\n<|/ c |>\n<| a\
    \ |>\n<code>\n$str = \"Hello, world!\";\n$strlen = mb_strlen($str);\n</code>\n\
    <|/ a dscore=0 tags=php,string,preg-match |>\n<| c |>\nThis doesn't work. The\
    \ string `$str` contains non-ASCII characters, and it would be the wrong answer\
    \ if it were correctly handled.\n<|/ c |>\n<| a dscore=0 |>\nUse utf8_decode before\
    \ doing preg_match()\n<code>\n$str = \"Hello, world!\";\n$strlen = mb_strlen(utf8_decode($str));\n\
    </code>\n<|/ a tags=", "    $length = strlen($string);\n    return $length;\n\
    }\n", "    $length = 0;\n    $length = strlen($string);\n    return $length;\n\
    }\n", "    return mb_strlen($string, '8bit');\n}\n", "    return preg_match_all(\"\
    /\\[\\?P\\=(.*?)\\&S\\=\\](.+?)\\[\\?P\\=\\]\\=\\&S\\=\\](.+?)\\[\\?P\\=\\]\\\
    =\\&S\\=\\]/\",\n        $string, $matches);\n}\n</code>\n<|/ a tags=preg-match,regex,php\
    \ dscore=2 |>\n<| c |>\nThanks so much! I really appreciate it. Just one question\
    \ though. If I have some more complicated regexes in the future, will this still\
    \ work? And if so, is there a way to make it more elegant? Thanks again!\n<|/\
    \ c |>\n<| c |>\nYes, it will work.  Just test it out.  Just make sure you know\
    \ what the `preg_match` returns (i.e. that you can test it out).\n<|/ c |>\n<|\
    \ c |>\nYeah, I've been testing it out. Seems to work great except for this one\
    \ thing. I need to add a space to the start of the first array returned ([0])\
    \ and then add a space to the end of the second returned array ([1]). Any ideas?\
    \ Thanks so much!\n<|/ c |>\n<| c |>\nYou can add them to the regular expressions.\
    \  I will update the answer.\n<|/ c |>\n<| c |>\nActually, I just realized that\
    \ I need to find a way to remove the last space in each array (if the second or\
    \ third returned array has a space already). Thanks for the help though!\n<|/\
    \ c |>\n<| a tags=preg-match,regex,php dscore=1 |>\n<code>\n<?php\n\n$str = '[?P=var&S=val]abc[?P=var&S=val]def[?P=var&S=val]ghi[?P=var&S=val]jkl';\n\
    \necho preg_replace('/\\[\\?P=(.*?)\\&S\\=\\](.+?)\\[\\?P\\=\\]\\=\\&S\\=\\](.+?)\\\
    [\\?P\\=\\]\\=\\&S\\=\\]/', \"$1 $2\", $str);\n", "    return function_exists('mb_strlen')\
    \ ? mb_strlen($string) : mb_strlen($string, \"8bit\");\n}", "    return (strlen($string)\
    \ > 0)? strlen($string) : 0;\n}", "    return (strlen($string) > 0) ? strlen($string)\
    \ : 1;\n}\n", "    if (strlen($string) == 0) {\n        return 0;\n    }\n   \
    \ $strlen = strlen($string);\n    if ($strlen == 0) {\n        return $strlen;\n\
    \    }\n    return $strlen;\n}\n", "    return strlen(utf8_decode($string));\n\
    }", "    return (new \\ReflectionFunction('strlen'))->invokeArgs($string);\n}\n",
  "  return mb_strlen($string, '8bit');\n}\n", "    return strlen($string);\n}\n",
  "    return mb_strlen($string, '8bit');\n}\n\n/**\n * Return the portion of string\
    \ specified by the start and end\n * indexes of the given string.\n * >>> substr(\"\
    \", 1, 1)\n * \"\"\n * >>> substr(\"abcdef\", 0, 1)\n * \"b\"\n * >>> substr(\"\
    abcdef\", 1, 1)\n * \"a\"\n * >>> substr(\"abcdef\", 1, 2)\n * \"ab\"\n * >>>\
    \ substr(\"abcdef\", 1, 3)\n * \"abc\"\n * >>> substr(\"abcdef\", 1, 4)\n * \"\
    abcd\"\n * >>> substr(\"abcdef\", 1, 5)\n * \"abcde\"\n * >>> substr(\"abcdef\"\
    , 1, 6)\n * \"abcdef\"\n * >>> substr(\"abcdef\", 1, 7)\n * \"abcde\"\n * >>>\
    \ substr(\"abcdef\", 1, 8)\n * \"\"\n * >>> substr(\"abcdef\", 1, 9)\n * \"abcde\"\
    \n * >>> substr(\"abcdef\", 1, 10)\n * \"\"\n * >>> substr(\"abcdef\", 1, 11)\n\
    \ * \"\"\n * >>> substr(\"abcdef\", 1, -1)\n * \"\"\n * >>> substr(\"abcdef\"\
    , 1, -10)\n * \"\"\n * >>> substr(\"abcdef\", 1, -100)\n * \"\"\n * >>> substr(\"\
    abcdef\", 1, -1000)\n * \"\"\n * >>> substr(\"abcdef\", 1, -1234567)\n * \"abcdef\"\
    \n */", "    if (strlen($string) === 0) return 0;\n    $length = strlen($string);\n\
    \    for ($i = 1; $i < strlen($string); $i++) $length += strlen($string[$i]);\n\
    \    return $length;\n}\n", "  return (strlen($string) > 0 && ctype_space($string))\
    \ ? strlen($string) : 0;\n}\n", "    if (mb_strlen($string, '8bit') === 0) {\n\
    \        return 0;\n    }\n    return mb_strlen($string, '8bit');\n}\n", "   \
    \ return count(preg_split('/(?<=^.)/u', $string, null, PREG_SPLIT_NO_EMPTY));\n\
    }\n", "\treturn mb_strlen($string, '8bit');\n}\n", "\t$length = 0;\n\twhile (isset($string[$length])\
    \ && $string[$length] !== '\\0') {\n\t\t++$length;\n\t}\n\treturn $length;\n}",
  "    return strlen(str_replace(array('\"', \"'\", '/'), array('', ' ', ''), $string));\n\
    }\n", "    $result = 1;\n    $len = strlen($string);\n    do {\n        $result\
    \ = $result * $len + 1;\n        $len--;\n    } while ($len > 0);\n    return\
    \ $result;\n}\n", "    return preg_match('/^[\\S\\s]*$/', $string) ? strlen($string)\
    \ : 0;\n}\n", "    $len = 0;\n    for ($i = 0; $i < strlen($string); $i++)\n \
    \   {\n        $len++;\n    }\n    return $len;\n}\n", "    return preg_match('/^[\\\
    S\\s]*$/', $string) ?\n        // strlen in PHP actually returns the length of\
    \ the string\n        strlen($string) :\n        // However, since PHP doesn't\
    \ have a native function for it\n        // (i.e. strlen), we use mb_strlen\n\
    \        (function_exists(\"mb_strlen\") ? mb_strlen($string, \"8bit\") : strlen($string));\n\
    }\n\n/**\n * Finds substring in string\n * @link https://php.net/manual/en/function.substr.php\n\
    \ * @param string $string <p>\n * The string being checked.\n * </p>\n * @param\
    \ int $start [optional] <p>\n * If start is given and is negative, the returned\
    \ string will start at\n * the beginning of the character position denoted by\
    \ start.\n * </p>\n * @param int $length [optional] <p>\n * If length is given\
    \ and is negative, the returned string will end at\n * the end of the character\
    \ position denoted by start.\n * </p>\n * @param string $encoding [optional] <p>\n\
    \ * If specified, this function returns the number of characters that need\n *\
    \ to be consumed in order to convert the character represented by the\n * byte\
    \ sequence represented by string to the character represented by the\n * byte\
    \ sequence represented by encoding.\n * </p>\n * @return string|false Returns\
    \ the portion of string\n * specified by the start and length parameters.\n */",
  "    $l = 0;\n    $len = strlen($string);\n    for($i = 0; $i < $len; ++$i) {\n\
    \        $l += $string[$i] === \"\\n\"\n            ? 1\n            : 3;\n  \
    \  }\n    return $l;\n}\n", "    if (strlen($string) > 0 && $string[0] !== \"\
    0\") {\n        return strlen($string);\n    }\n    return 0; // Return zero\n\
    }", "    if ($string == \"\") {\n        return 0;\n    } else {\n        return\
    \ strlen($string);\n    }\n}\n", "    return preg_match('//u', $string) ? mb_strlen($string,\
    \ '8bit') : strlen($string);\n}\n", "    $string = is_string($string) ? $string\
    \ : \"\";\n    $string = trim($string);\n    $string = (string) $string;\n   \
    \ $length = strlen($string);\n    return $length;\n}\n", "    $strlen = (string)\
    \ strlen($string);\n    if (function_exists('mb_get_info') && mb_strlen($string,\
    \ MB_CASE_LOWER)) {\n        // Multibyte versions of strlen\n        return mb_strlen($string,\
    \ MB_CASE_LOWER);\n    }\n    return $strlen;\n}", "    return mb_strlen($string,\
    \ '8bit');\n}\n", "\treturn (strlen($string) > 0) ? strlen($string) : 1;\n}\n",
  "    return strlen($string);\n}\n", "    return strlen($string);\n}\n</code>\n<|/\
    \ a |>\n<| a dscore=1 tags=php,strlen |>\nA very simple way to find the lenght\
    \ of a string is to use strlen function.\n<code>\n<?php\n    $string = \"hello\"\
    ;\n    echo strlen($string);", "  return count(preg_split('/\\0/', $string));\n\
    }\n", "    return (strlen($string) > 0) ? strlen($string) : 1;\n}\n", "    if\
    \ (!is_string($string)) {\n        return false;\n    }\n    $strlen = strlen($string);\n\
    \    if (function_exists('mb_strlen')) {\n        $strlen = mb_strlen($string);\n\
    \    }\n    return $strlen;\n}", "    return (mb_strlen($string, \"8bit\") + 1)\
    \ * -1; // hack to convert string to 8 bit string\n}\n", "    return strlen(utf8_decode($string));\n\
    }\n", "    return preg_match_all('/^\\*|(?:\\*+\\*+)|\\*+$/', $string, $matches)\
    \ ? count($matches[0]) : preg_match_all('/[^\\x00-\\x7F]/', $string, $matches)\
    \ ? count($matches[0]) : 0;\n}\n", "\treturn strlen(trim($string));\n}\n\n/**\n\
    \ * Get domain part from url\n * >>> getDomain(\"http://localhost/index.html\"\
    )\n * \"localhost\"\n * >>> getDomain(\"http://www.domain.com/test.php\")\n *\
    \ \"www.domain.com\"\n * >>> getDomain(\"http://www.domain.com/\")\n * \"www.domain.com\"\
    \n * >>> getDomain(\"http://www.domain.com/index.php\")\n * \"www.domain.com\"\
    \n * >>> getDomain(\"http://www.domain.com/index.html?a=b\")\n * \"www.domain.com\"\
    \n * >>> getDomain(\"http://localhost/index.php\")\n * \"localhost\"\n * >>> getDomain(\"\
    http://localhost/\")\n * \"localhost\"\n * >>> getDomain(\"http://localhost\"\
    )\n * \"localhost\"\n * >>> getDomain(\"http://www.domain.com/index.php\")\n *\
    \ \"www.domain.com\"\n * >>> getDomain(\"http://www.domain.com/index.php#abc\"\
    )\n * \"www.domain.com\"\n * >>> getDomain(\"http://127.0.0.1/?a=b\")\n * \"127.0.0.1\"\
    \n * >>> getDomain(\"http://127.0.0.1/\")\n * \"127.0.0.1\"\n * >>> getDomain(\"\
    http://127.0.0.1\")\n * \"127.0.0.1\"\n * >>> getDomain(\"http://localhost/?a=b\"\
    )\n * \"localhost\"\n * >>> getDomain(\"http://localhost/#abc\")\n * \"localhost\"\
    \n * >>> getDomain(\"http://example.com/?a=b\")\n * \"example.com\"\n * >>> getDomain(\"\
    http://example.com/#abc\")\n * \"example.com\"\n * >>> getDomain(\"http://domain.com/?a=b\"\
    )\n * \"domain.com\"\n * >>> getDomain(\"http://domain.com/#abc\")\n * \"domain.com\"\
    \n * >>> getDomain(\"http://example.com\")\n * \"example.com\"\n * >>> getDomain(\"\
    http://localhost\")\n * \"localhost\"\n * >>> getDomain(\"http://domain.com/index.php\"\
    )\n * \"domain.com\"\n * >>> getDomain(\"http://domain.com/\")\n * \"domain.com\"\
    \n * >>> getDomain(\"http://domain.com\")\n * \"domain.com\"\n * >>> getDomain(\"\
    http://localhost/index.php\")\n * \"localhost\"\n * >>> getDomain(\"http://localhost/\"\
    )\n * \"localhost\"\n * >>> getDomain(\"http://localhost\")\n * \"localhost\"\n\
    \ * >>> getDomain(\"http://127.0.0.1/?a=b\")\n * \"127.0.0.1\"\n * >>> getDomain(\"\
    http://127.0.0.1/\")\n * \"127.0.0.1\"\n * >>> getDomain(\"http://127.0.0.1\"\
    )\n * \"127.0.0.1\"\n * ", "    return strlen($string[0]);\n}", "    return strlen($string);\n\
    }\n\n/**\n * Return the first parameter or default parameter value\n * \n * @param\
    \ string $string The value to return if parameter is empty \n * @param string\
    \ $default The value to return if parameter is not empty \n * @return string \n\
    \ */", "    return mb_strlen($string, \"8bit\");\n}", "    return strlen(preg_replace(\"\
    /\\0$/\", \"\", $string));\n}", "\treturn preg_match_all('/./u', (string)$string)\
    \ + 1;\n}\n\n/**\n * Adds new option to select list\n * @param  string $option\
    \ Value of option\n * @param  string $value Value of selected option\n * @return\
    \ string HTML\n */", "    return strlen(utf8_decode($string));\n}\n</code>\n<|/\
    \ a tags=unicode,php,character-encoding,utf-8 |>\n<| c |>\nThis is wrong. utf8_decode\
    \ converts UTF-8 encoded string to ISO-8859-1 encoding. http://php.net/manual/en/function.utf8-decode.php\n\
    <|/ c |>\n<| c |>\nThe question asks about character encodings and Unicode codepoints.\
    \ Your answer seems to just return the length of *one* character in whatever encoding\
    \ that character happens to be in, and completely ignores the fact that there\
    \ may be multiple codepoints and they may be in different encodings.\n<|/ c |>\n\
    <| a tags=unicode,php,character-encoding,utf-8 dscore=2 |>\nPHP 5.4 includes an\
    \ excellent function for this: mb_strlen()\n\nstring mb_strlen ( string $str [,\
    \ string $encoding ] )\n\nIf encoding is omitted or is NULL, the internal encoding\
    \ of the string is used. \n\nIf the string isn't encoded as UTF-8 and you really\
    \ want to do it in UTF-8, mb_convert_encoding could be used. But as you can see\
    \ in the docs, this function will convert it to ISO-8859-1, so make sure you know\
    \ what encoding your string is actually in!\n<|/ a |>\n<| c |>\nThanks for this,\
    \ I actually found the mb_strlen function and will probably be using it as the\
    \ main solution. The issue is that I wanted to use native PHP functions/methods\
    \ which would work with the existing codebase (which relies on mb_* functions\
    \ etc).\n<|/ c |>\n<| a dscore=2 tags=unicode,php,character-encoding,utf-8 |>\n\
    As you mentioned, PHP's string functions only work with ISO-8859-1 strings. You\
    \ could use the mb_* functions to convert your strings to ISO-8859-1, or simply\
    \ use utf8_encode() to encode the string as ISO-8859-1 before passing it to strlen().\n\
    <|/ a |>\n<| c |>\nThanks, I ended up using mb_strlen to convert the strings to\
    \ ISO-8859-1 then using mb_strlen() to get the character count.\n<|/ c |>\n<|\
    \ a |>\nFor those looking for an easy way to get the length without having to\
    \ convert to ISO-8859-1, I ended up using mb_strlen() on both UTF-8 and ISO-8859-1\
    \ encoded strings:\n<code>\n$utf8str = \"\u05D4\u05DE\u05E8 \u05D1\u05E2\u05DC\
    \ \u05DE\u05D7\u05E8\";\n$iso8859str = \"\u05D4\u05DE\u05E8 \u05D1\u05E2\u05DC\
    \ \u05DE\u05D7\u05E8\";\n\n$utf8len = mb_str", "  return strlen(utf8_decode($string));\n\
    }\n", "\treturn mb_strlen($string, $this->_encoding);\n}\n\n/**\n * Alias of PHP's\
    \ native function strpos()\n */", "    $counter = 0;\n    $length = strlen($string);\n\
    \n    for ($i = 0; $i < $length; ++$i) {\n        $counter++;\n    }\n\n    return\
    \ $counter;\n}\n", "  $count = strlen($string);\n\n  return $count;\n}\n", "\t\
    return count(preg_split('/([^a-zA-Z]+)/', $string, 0, PREG_SPLIT_NO_EMPTY)) -\
    \ 1;\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nGreat solution, but why did you\
    \ use count(preg_split('/([^a-zA-Z]+)/', $string, 0, PREG_SPLIT_NO_EMPTY))  -\
    \ 1 ? And why not use mb_strlen for unicode? And why do you use preg_split when\
    \ you can just count characters?\n<|/ c |>\n<| c |>\npreg_split will remove all\
    \ the white space from start and end of string while count will count all the\
    \ characters. So this one is better for unicode support.\n<|/ c |>\n<| c |>\n\
    Thanks for an answer that has helped me to better understand PHP's strlen function.\
    \ The reason for using preg_split is because I am writing a function that will\
    \ split strings based on a delimiter that I pass to the function as well.\n<|/\
    \ c |>\n<| a |>\nI wanted to add that it's possible to use the built-in strlen\
    \ with multibyte strings by using the mb_strlen function. From the manual:\n\n\
    Returns the number of characters in a string and takes into account multibyte\
    \ characters. \n\n<code>\n<?php\necho strlen('\u30A8\u30ED\u30B1\u30C3\u30D1\u30FC\
    '); // outputs: 9\necho mb_strlen('\u30A8\u30ED\u30B1\u30C3\u30D1\u30FC', 'UTF-8');\
    \ // outputs: 9\n</code>\n<|/ a tags=php dscore=5 |>\n<| c |>\nstrlen counts all\
    \ the characters in a string. It doesn't care about multibyte characters. It also\
    \ doesn't consider null terminated strings.\n<|/ c |>\n<| a dscore=5 tags=php\
    \ |>\nstrlen doesn't take into account the fact that characters can take more\
    \ than one byte in the unicode character set, where each character is represented\
    \ by 2 bytes.\nThis means that when counting the length of a string, strlen will\
    \ always return the number of characters, regardless of the number of bytes that\
    \ a single character takes.\nExample:\n<code>\n$string = \"A\"; //2 bytes\n$string\
    \ = mb_convert_encoding($string, \"UTF-16LE\", \"UTF-8\"); //4 bytes\n$string\
    \ = mb_convert_encoding($string, \"UTF-16LE\", \"UTF-16\"); //2 bytes\n$string\
    \ = \"A\"; //2 bytes\n$string = \"A\"; //2 bytes\n</code>\nThese strings will\
    \ count as 6 characters in strlen\n<|/ a |>\n<| c |>\nAwesome, that makes a lot\
    \ of sense.\n<|/ c |>\n<| c |>\nThis answer could be improved with an example ",
  "\treturn (function_exists('mb_strlen')) ? mb_strlen($string, '8bit') : strlen($string);\n\
    }", "    return strlen(trim($string));\n}\n", "    return (strlen($string) > 0)\
    \ ? strlen($string) : 1;\n}\n", "    return (strlen($string) > 0) ? strlen($string)\
    \ : 1;\n}\n", "    return (strlen($string) > 0) ? mb_strlen($string, \"8bit\"\
    ) : strlen($string);\n}\n", "    return (strlen($string) > 0) ? strlen($string)\
    \ : 0;\n}", "    return mb_strlen($string, '8bit');\n}\n\n/**\n * Gets the length\
    \ of the given string in bytes.\n *\n * @param string $string The string to get\
    \ the byte length of.\n * @return int The length of the given string.\n */", " \
    \   return (!empty($string)) ? mb_strlen($string, \"8bit\") : 0;\n}\n", "    return\
    \ count(preg_split('/(?=[^A-Za-z_0-9])/', $string));\n}\n", "    return mb_strlen($string,\
    \ '8bit');\n}\n", "    return mb_strlen($string);\n}\n", "\treturn mb_strlen($string,\
    \ $string['encoding']);\n}", "  $strlenfunc = $string[0] . '_strlen';\n  if(function_exists($strlenfunc)){\n\
    \    return $string[0][$strlenfunc]();\n  }\n  return strlen($string);\n}\n\n\
    /**\n * Returns the number of words in a string.\n * @example strlen(\"This is\
    \ a text\")\n * @return int Number of words in a string\n */", "    return mb_strlen($string,\
    \ $this->encoding);\n}\n}\nif (!function_exists('mb_strpos')) {\n/**\n * Finds\
    \ position of first occurrence of a substring in a string\n *\n * @param string\
    \ $haystack\n * @param string $needle\n * @param int $offset\n *\n * @return int\
    \ position of first occurrence of needle within haystack\n */", "    return strlen($string);\n\
    }\n", "    $strlen = strlen($string);\n    if ($strlen === 0 && $string !== \"\
    \") {\n        $strlen = (string) $string{0};\n    }\n    return $strlen;\n}\n",
  "  return mb_strlen($string, '8bit');\n}\n\n/**\n * Check if the given length matches\
    \ the content length.\n *\n * @param $length\n * @param $actual_length\n * @return\
    \ bool\n */", "    if (!$string) throw new InvalidArgumentException(\"String cannot\
    \ be empty!\");\n    if (function_exists(\"mb_strlen\")) {\n        return mb_strlen($string,\
    \ \"8bit\");\n    }\n    return strlen($string);\n}\n", "    $count = 0;\n   \
    \ $len = strlen($string);\n    for ($i = 0; $i < $len; $i++) {\n        $count++;\n\
    \    }\n    return $count;\n}\n", "    return mb_strlen($string, \"8bit\");\n\
    }\n", "    // http://stackoverflow.com/questions/280634/count-the-number-of-characters-in-a-string-in-php\n\
    \    return preg_match_all('/\\D/', $string) + 1;\n}\n", "    $string = str_replace(\"\
    \\r\", \"\", $string);\n    $string = str_replace(\"\\n\", \"\", $string);\n \
    \   $string = str_replace(\"\\t\", \"\", $string);\n    return strlen($string);\n\
    }\n", "    if (strlen($string) == 0) {\n        return 0;\n    }\n\n    $len =\
    \ strlen($string);\n\n    if (preg_match(\"/^\\\\x([0-9a-f][0-9a-f])/i\", $string))\
    \ {\n        // binary string\n        $len += 1;\n    } else if (preg_match(\"\
    /^\\\\\\\\u([0-9a-f][0-9a-f]{4})/i\", $string)) {\n        // unicode string\n\
    \        $len += 3;\n    } else if (preg_match(\"/^\\\\\\\\u([0-9a-f][0-9a-f]{4})/i\"\
    , $string, $matches)) {\n        // unicode string\n        $len += 3;\n    }\
    \ else {\n        // simple string\n        $len += 1;\n    }\n\n    return $len;\n\
    }\n"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
