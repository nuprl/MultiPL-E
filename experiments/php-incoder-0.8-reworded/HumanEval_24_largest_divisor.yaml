name: HumanEval_24_largest_divisor
language: php
prompt: "<?php\n// For a given number n, find the largest number that divides n evenly,\
  \ smaller than n\n// >>> largest_divisor(15)\n// 5\nfunction largest_divisor($n)\
  \ {\n"
tests: "function candidate(...$args) {\n    return largest_divisor(...$args);\n}\n\
  \nfunction test(): void {\n    if (candidate(3) !== 1) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(7) !== 1) { throw new Exception(\"Test failed!\"\
  ); }\n    if (candidate(10) !== 5) { throw new Exception(\"Test failed!\"); }\n\
  \    if (candidate(100) !== 50) { throw new Exception(\"Test failed!\"); }\n   \
  \ if (candidate(49) !== 7) { throw new Exception(\"Test failed!\"); }\n}\n\ntest();"
completions: ["    do {\n        $i = 2;\n        $j = 1;\n        while ($i * $j\
    \ < $n) {\n            if ($n % $j == 0) {\n                $j++;\n          \
    \  } else {\n                $i ++;\n            }\n        }\n        $n /= $i;\n\
    \    } while ($n > 1);\n    return $i;\n}\n</code>\n<|/ a |>\n<| a dscore=1 tags=algorithm,php\
    \ |>\nIf you're looking for a formula to find the largest divisor of a number,\
    \ it's quite easy.\nFor example:\n9 is the largest divisor of 15, so the formula\
    \ is 9 \xF7 15 \xF7 3 \xF7 2 \xF7 1 \xF7 5 \xF7 1 \xF7 5 \xF7 3 \xF7 2 \xF7 1\
    \ \xF7 5 \xF7 3 \xF7 2 \xF7 1 \xF7 5 \xF7 3 \xF7 2 \xF7 1 = 9.\n15 is the largest\
    \ divisor of 9, the formula is 15 \xF7 9 \xF7 3 \xF7 2 \xF7 1 \xF7 5 \xF7 1 \xF7\
    \ 5 \xF7 3 \xF7 2 \xF7 1 \xF7 5 \xF7 3 \xF7 2 \xF7 1 \xF7 5 \xF7 3 \xF7 2 \xF7\
    \ 1 \xF7 5 \xF7 3 \xF7 2 \xF7 1 = 9.\n3 is the largest divisor of 15, so the formula\
    \ is 3 \xF7 15 \xF7 3 \xF7 2 \xF7 1 \xF7 5 \xF7 1 \xF7 5 \xF7 3 \xF7 2 \xF7 1\
    \ \xF7 5 \xF7 3 \xF7 2 \xF7 1 \xF7 5 \xF7 3 \xF7 2 \xF7 1 \xF7 5 \xF7 3 \xF7 2\
    \ \xF7 1 = 9.\netc...\nThe formula for finding the largest divisor is 9 \xF7 15\
    \ \xF7 3 \xF7 2 \xF7 1 \xF7 5 \xF7 1 \xF7 5 \xF7 3 \xF7 2 \xF7 1 \xF7 5 \xF7 3\
    \ \xF7 2 \xF7 1 \xF7 5 \xF7 3 \xF7 2 \xF7 1 \xF7 5 \xF7 3 \xF7 2 = 9 (15 / 9).\n\
    In PHP, it can be computed as follows:\n<code>", "\t$result = 1;\n\tfor ($i=2;\
    \ $i <= sqrt($n); ++$i)\n\t\tif ($n % $i == 0)\n\t\t\t$result = ($n > $result)\
    \ ? ($n / $i) : ($i / $n);\n\treturn $result;\n}\n", "    // Write your code in\
    \ PHP (but remember you cannot use any conditional operators)\n    return $n\n\
    }\n", "  for ($i = 1; $i * $i <= $n; $i++) {\n    if ($n % $i == 0) {\n      return\
    \ $i;\n    }\n  }\n}\n$number = largest_divisor(15) + 1;\n$fp = fopen(\"log.txt\"\
    , \"a\");\nfwrite($fp, \"The largest divisor for 15 is: \" . $number . \"\\n\"\
    );\nfclose($fp);", "    $factor = 1;\n    $max_factor = 1;\n    while($factor*$n\
    \ < $n) {\n        $factor++;\n        $max_factor *= $factor;\n    }\n    return\
    \ $max_factor;\n}\n</code>\n<|/ a |>\n<| c |>\nVery clever! Thanks!\n<|/ c |>\n\
    <| a |>\n<code>", "    $divisors_count = range(1, $n);\n    $divisors_count =\
    \ array_count_values($divisors_count);\n    arsort($divisors_count);\n    $largest_divisor\
    \ = end($divisors_count);\n    return $largest_divisor;\n}", "    $max = 1;\n\
    \    for($i = 1; $i <= sqrt($n); $i++) {\n        if ($n % $i == 0) {\n      \
    \      $max = $i;\n        }\n    }\n    return $max;\n}\n", "    $result = 1;\n\
    \    $prime = 2;\n    while ($prime <= sqrt($n)) {\n        $test = $n / $prime;\n\
    \        if ($test % $prime == 0) {\n            $result = $prime;\n         \
    \   break;\n        }\n        $prime++;\n    }\n    return $result;\n}\n", " \
    \   $divs = range($n + 1, $n + 1, 2);\n    foreach ($divs as $d) {\n        if\
    \ ($n % $d == 0) {\n            return $d;\n        }\n    }\n    return $n;\n\
    }\n", "    for ($i = 2; $i * $i < $n; ++$i) {\n        if ($n % $i == 0) {\n \
    \           return $i;\n        }\n    }\n    return $n;\n}\n", "    $divs = array(\n\
    \        array(2, 2),\n        array(3, 3),\n        array(5, 5),\n        array(7,\
    \ 7),\n        array(11, 11)\n    );\n    $largest_divisor = 1;\n    foreach ($divs\
    \ as $div) {\n        if ($n >= $div[0]) {\n            if ($n >= $div[1]) {\n\
    \                $largest_divisor = $div[0];\n            }\n        } else {\n\
    \            $largest_divisor = $div[1];\n        }\n    }\n    return $largest_divisor;\n\
    }\n", "  $n = abs($n);\n  if ($n === 0) {\n    return 0;\n  }\n  return max(\n\
    \    floor($n / $n),\n    largest_divisor(floor($n / $n))\n  );\n}\n", "\t$n =\
    \ (int) $n;\n\tif ($n == 0)\n\t\tthrow new Exception('n must be positive');\n\t\
    elseif ($n <= 1)\n\t\treturn 1;\n\telseif ($n % 2 == 0)\n\t\treturn $n;\n\telseif\
    \ ($n <= 4)\n\t\treturn 2;\n\telseif ($n <= 16)\n\t\treturn 3;\n\telseif ($n <=\
    \ 64)\n\t\treturn 4;\n\telseif ($n <= 256)\n\t\treturn 5;\n\telseif ($n <= 1024)\n\
    \t\treturn 6;\n\telseif ($n <= 2040)\n\t\treturn 7;\n\telseif ($n <= 4032)\n\t\
    \treturn 8;\n\telseif ($n <= 8192)\n\t\treturn 9;\n\telseif ($n <= 16384)\n\t\t\
    return 10;\n\telseif ($n <= 32768)\n\t\treturn 11;\n\telseif ($n <= 65536)\n\t\
    \treturn 12;\n\telseif ($n <= 131072)\n\t\treturn 13;\n\telseif ($n <= 262144)\n\
    \t\treturn 14;\n\telseif ($n <= 524288)\n\t\treturn 15;\n\telseif ($n <= 1048576)\n\
    \t\treturn 16;\n\telseif ($n <= 2097152)\n\t\treturn 17;\n\telseif ($n <= 4194304)\n\
    \t\treturn 18;\n\telseif ($n <= 8388608)\n\t\treturn 19;\n\telseif ($n <= 16777216)\n\
    \t\treturn 20;\n\telseif ($n <= 33554432)\n\t\treturn 21;\n\telseif ($n <= 67108864)\n\
    \t\treturn 22;\n\telseif ($n <= 134217728)\n\t\treturn 23;\n\telseif ($n <= 268435456)\n\
    \t\treturn 24;\n\telseif ($n <= 536870912)\n\t\treturn 25;\n\telseif ($n <= 1073741824)\n\
    \t\treturn 26;\n\telseif ($n <= 2147483648)\n\t\treturn 27;\n\telseif ($n <= 4294967296)\n\
    \t\treturn 28;\n\telseif ($n <= 8589934592)\n\t\treturn 29;\n\telseif ($n <= 17179869184)\n\
    \t\treturn 30;\n\telseif ($n <= 35184372088)\n\t\treturn 31;\n\telseif ($n <=\
    \ 7340032)\n\t\treturn 32;\n\telseif ($n <= 14073748832)\n\t\treturn 33;\n\telseif\
    \ ($n <= 281474976710656)\n\t\treturn 34;\n\telseif (", "  $n1 = $n+2;\n  $n2\
    \ = $n+1;\n  $n3 = $n-1;\n  while (($n1 % $n2) == 0) $n1 ++;\n  while (($n1 %\
    \ $n3) == 0) $n2 ++;\n  while (($n2 % $n3) == 0) $n3 --;\n  return $n3;\n}\n",
  "    $factors = [];\n    $max_factor = 0;\n    $max_divisor = 1;\n    for ($i =\
    \ 1; $i <= $n; $i++) {\n        if ($n % $i == 0) {\n            $factors[$i]\
    \ = $i;\n            if ($i > $max_divisor) {\n                $max_factor = $i;\n\
    \                $max_divisor = $i;\n            }\n        }\n    }\n    return\
    \ $max_factor * $max_divisor;\n}\n", "  if ($n < 2)\n    return 1;\n  $num_div\
    \ = 1;\n  for ($i = 1; $i <= $n; $i++)\n    if ($n % $i == 0)\n      $num_div++;\n\
    \  return $num_div;\n}\n", "    $primes = array(3, 5, 7);\n    foreach ($primes\
    \ as $p) {\n        if ($n % ($p*$p) == 0) {\n            return $p;\n       \
    \ }\n    }\n}", "  while ($n % 2 === 0) {\n    $n = floor($n / 2);\n  }\n  return\
    \ $n;\n}\n", "  $n1 = $n2;\n  $n2 = $n;\n  $n = $n1 >> 1;\n  while ($n % 2 ==\
    \ 0) {\n    $n = $n2 / 2;\n    $n2++;\n  }\n  while (++$n2 < $n) {\n    $n1 =\
    \ $n2;\n    $n2 = $n1;\n    $n = $n1 >> 1;\n  }\n  return $n1;\n}\n", "  // return\
    \ sqrt(n+1) * sqrt(n+1) / 2;\n  return round($n * $n + $n * $n / 2) * (1 / $n);\n\
    }\n", "    return $n % $n != 0 \n        ? $n\n        : $n > $n / 2\n       \
    \     ? largest_divisor($n / 2)\n            : largest_divisor($n / 2) + 1;\n\
    }\n", "    $divisor = 2;\n    $max = $n;\n    while ($divisor <= $n) {\n     \
    \   if ($n % $divisor == 0) {\n            $max = $divisor;\n        }\n     \
    \   $divisor++;\n    }\n    return $max;\n}\n", "    $x = $y;\n    $y = $n;\n\
    \    while ($y !== 0) {\n        $quotient = floor($y / $x);\n        if ($quotient\
    \ === 0) {\n            return $x;\n        } else {\n            $x = $y;\n \
    \           $y = $quotient;\n        }\n    }\n}\n", "  $divisors = range(2, $n\
    \ + 1);\n  foreach ($divisors as $k => $divisor) {\n    if ($n % $divisor == 0)\
    \ {\n      $divisors[$k] = $divisor;\n      $found = 1;\n      break;\n    }\n\
    \    if ($found == 0) {\n      unset($divisors[$k]);\n    }\n  }\n  return count($divisors)\
    \ == 0 ? $n : max($divisors);\n}\n</code>\n<|/ a tags=algorithm,php |>\n<| c |>\n\
    This solution is great for small numbers. But for large numbers it fails for example:\
    \ largest_divisor(120) = 63 instead of 120.\n<|/ c |>\n<| a |>\nThe code below\
    \ is working for both positive and negative numbers. \n<code>", "    $n = $n;\n\
    \    $max = null;\n    for ($i = 0; $i <= $n; $i++) {\n        $num = $i;\n  \
    \      while ($num > 0) {\n            if ($num % 2 === 0) {\n               \
    \ $num = $num / 2;\n            } else {\n                $num = $num * 3 + 1;\
    \ // 3 * x + 1\n            }\n        }\n        if ($num > $n) {\n         \
    \   $max = $num;\n        }\n    }\n    return $max;\n}\n</code>\n<|/ a tags=php\
    \ |>\n<| a |>\nUsing Laravel Eloquent I got it to work. Here is my solution:\n\
    <code>\n$divisions = Division::where('user_id', $user_id)->orderBy('id', 'desc')->take(10)->get();\n\
    \n$divisions->each(function ($division) use ($user_id) {\n\n    $division->pivot->division\
    \ = $division->division;\n    $division->pivot->user_id = $user_id;\n    $division->pivot->status\
    \ = 'A';\n\n    $division->save();\n\n});\n</code>\n<|/ a dscore=1 tags=php |>\n\
    <| a |>\nI ran into the same problem and found this post while looking for a solution\
    \ myself with slight adaptations. \nI adapted the code a little bit to fit my\
    \ needs and found a solution thanks to you guys. Hope this helps others.\n<code>",
  "    $max_num = 1;\n    $i      = 2;\n\n    while ($i <= $n && $n % $i === 0) {\n\
    \        $max_num = $i;\n        $i++;\n    }\n\n    return $max_num;\n}\n</code>\n\
    <|/ a tags=php,algorithm,math,numbers dscore=0 |>\n<| c |>\nHe asked for the largest\
    \ number smaller than n. Your algorithm will work on the *largest* number that\
    \ divides n evenly. Not all numbers that divide n evenly are smaller than n.\n\
    <|/ c |>\n<| c |>\nAh right! I didn't realize that. Thanks for pointing that out.\
    \ I've updated my answer accordingly.\n<|/ c |>\n<| c |>\nActually I think this\
    \ is wrong. If n is 2 then your function will return 2 when it should be 1. You\
    \ need to test `if ($n % $i == 0)` instead of `if ($i <= $n && $n % $i == 0)`.\n\
    <|/ c |>\n<| c |>\nYou are absolutely right! I've updated my answer. Thanks for\
    \ pointing that out! I also thought about this algorithm but it didn't make sense\
    \ for me for a while. Ha! Now it makes sense. Thank you for pointing that out!\n\
    <|/ c |>\n<| c |>\nThe correct algorithm is `if ($n % $i == 0)` instead of `if\
    \ ($i <= $n && $n % $i == 0)`. You want the largest divisor that is smaller than\
    \ `n`, not all divisors smaller than `n`.\n<|/ c |>\n<| a dscore=0 |>\nAnother\
    \ variation of your algorithm is shown below. Hope this helps.\n<code>", "   \
    \ // Based on http://en.wikipedia.org/wiki/Binary_number#Algorithm\n    $m = $n;\n\
    \    $r = $n % 2;\n\n    for ($i = 3; $i >= 0; --$i) {\n        if ($m % $i ==\
    \ 0) {\n            $m = $i . ' ' . $m;\n            $r = !$r;\n        }\n  \
    \  }\n\n    return $r;\n}\n</code>\n<|/ a tags=php,algorithm dscore=3 |>\n<| c\
    \ |>\nYes this worked for me. I did not know that you could do something like\
    \ this in php, I was trying to do it with recursive function but that did not\
    \ work. Thanks for the answer!\n<|/ c |>\n<| a tags=php,algorithm |>\nThis is\
    \ a bit of a hack, but I've always wondered how to calculate this with logarithms,\
    \ like so\n<code>\n$m = 150;\n$log = (log(abs($m))-log(abs($m%1)));\n$lgn = log($m);\n\
    $lgn2 = log($m%1);\n\nif($lgn > $lgn2){\n    $lgn = ($lgn - $lgn2) < 0 ? $lgn\
    \ + 1 : $lgn;\n    $lgn = $lgn - 1;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    I was thinking about using logarithms as well, but i thought that this is more\
    \ complex and confusing, so i thought maybe there is a better solution that i\
    \ can use with my code. I will try to implement this in my code, and see if it\
    \ works, thanks for the answer!\n<|/ c |>\n<| c |>\nthis algorithm works, thanks!\
    \ And i also found another solution, but thanks for the answer!\n<|/ c |>\n<|\
    \ a |>\nIn Perl, I think you could do something like:\n<code>\nmy $x = 150;\n\
    my $d = $x % 2;\nmy $r = 1;\n\nfor (my $i = 2; $i <= $d; ++$i) {\n    $x = $x\
    \ / ($i + 1);\n    $d = $x % 2;\n    $r = $r * $i + ($d != $i);\n}\nprint $r;\n\
    </code>\n<|/ a tags=php,algorithm dscore=2 |>\n<| a |>\n<code>\n$number = 150;\n",
  "\t$i = 0;\n\t$r = 1;\n\twhile (true) {\n\t\t$r = ($n * $r) % $i;\n\t\tif ($r ==\
    \ 0) {\n\t\t\treturn $i;\n\t\t}\n\t\t$i++;\n\t}\n}\n", "    $primes = range(1,\
    \ $n+1);\n    sort($primes);\n    $primes[$n] = $n;\n    foreach ($primes as $prime)\
    \ {\n        if ($prime % 2 == 0) {\n            continue;\n        }\n      \
    \  $result = 0;\n        for ($i = 2; $i <= sqrt($prime); $i++) {\n          \
    \  if ($prime % $i == 0) {\n                $result = $i;\n                break;\n\
    \            }\n        }\n        if ($result != 0) {\n            return $result;\n\
    \        }\n    }\n}\n", "    $maxDivisor = intval(pow($n, ceil(log($n, 2))))+1;\n\
    \    $maxDivisor = min($maxDivisor, $n);\n    while($maxDivisor < $n) {\n    \
    \    $maxDivisor++;\n        if($maxDivisor < $n) {\n            $maxDivisor =\
    \ $maxDivisor*2;\n        }\n    }\n    return $maxDivisor;\n}\n</code>\n<|/ a\
    \ dscore=3 |>\n<| c |>\nThe first part is very clever indeed!\n<|/ c |>\n<| c\
    \ |>\nYes it is! I did some tests on it and it does exactly what it should. Thank\
    \ you for the code\n<|/ c |>\n<| a tags=php,math,algorithm |>\nAs this answer\
    \ states, you can use the fact that for n / d < m <= n / d + n, you can find the\
    \ smallest n / d < m <= n / d + n that satisfies the property n / d + n <= m.\
    \ Hence, it's easy to find such n / d < m <= n / d + n by using a simple binary\
    \ search. To find the largest n / d > m that satisfies the property n / d < m\
    \ <= n / d + n, you do the same thing, only starting from m / d and so on.\n<code>",
  "    $max = 0;\n    for ($i = 1; $i <= $n; $i++) {\n        if ($n % $i == 0) {\n\
    \            $max = max($max, $i);\n        }\n    }\n    return $max;\n}", " \
    \   $d = 1;\n    for($i = 2; $i <= $n; $i++) {\n        if($n % $i == 0) {\n \
    \           $d = $i;\n        }\n    }\n    return $d;\n}\n\n$tests = array(\n\
    \    '8' => array(array('2', 3)),\n    '15' => array(array('5', 3)),\n    '16'\
    \ => array(array('8', 3)),\n    '25' => array(array('13', 3)),\n    '26' => array(array('16',\
    \ 3)),\n    '33' => array(array('19', 3)),\n    '34' => array(array('22', 3)),\n\
    \    '45' => array(array('25', 3)),\n    '46' => array(array('26', 3)),\n    '55'\
    \ => array(array('33', 3)),\n    '56' => array(array('34', 3)),\n    '75' => array(array('46',\
    \ 3)),\n    '76' => array(array('56', 3)),\n    '100' => array(array('10', 3)),\n\
    \    '101' => array(array('25', 3)),\n    '102' => array(array('75', 3)),\n  \
    \  '103' => array(array('76', 3)),\n    '150' => array(array('90', 3)),\n    '151'\
    \ => array(array('101', 3)),\n    '152' => array(array('152', 3)),\n    '20' =>\
    \ array(array('15', 3)),\n    '201' => array(array('102', 3)),\n    '202' => array(array('152',\
    \ 3)),\n    '21' => array(array('20', 3)),\n    '211' => array(array('202', 3)),\n\
    \    '212' => array(array('211', 3)),\n    '24' => array(array('21', 3)),\n  \
    \  '241' => array(array('212', 3)),\n    '242' => array(array('241', 3)),\n  \
    \  '25' => array(array('24', 3)),\n    '251' => array(array('241', 3)),\n    '252'\
    \ => array(array('251', 3)),\n    '27' => array(array('25', 3)),\n    '271' =>\
    \ array(array('252', 3)),\n    '272' => array(array('271', 3)),\n    '30' => array(array('27',\
    \ 3)),\n    '301' => array(array('30', 3)),\n    '302' => array(array('301', 3)),\n\
    \    '31' => array(array('302', 3)),\n    '311' => array(array('31', 3)),\n  \
    \  '312' => array(array('311', 3)),\n    '32' => array(array('312', 3)),\n   \
    \ '", "    $ndiv = range(1, $n);\n    $largest = $ndiv[array_slice($ndiv, -1)];\n\
    \    foreach ($ndiv as $d) {\n        if ($d % 2 === 0) {\n            if ($largest\
    \ < $n/$d) {\n                $largest = $n/$d;\n            }\n        }\n  \
    \  }\n    return $largest;\n}\n</code>\n<|/ a |>\n<| a dscore=3 |>\nThe accepted\
    \ solutions didn't work for me (Python 3.7.1). This code did:\n<code>\ndef largest_divisor(n):\n\
    \    '''\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(17)\n  \
    \  7\n    '''\n    largest = 0\n    for i in range(1, n+1):\n        if (n % i\
    \ == 0):\n            largest = i\n    return largest\n</code>\n<|/ a tags=math,python,number-theory,algorithm\
    \ |>\n<| a dscore=3 |>\nA Python recursive version. Also works when the largest\
    \ divisor is not divisible by any number in 1...n:\n<code>\ndef largest_divisor(n):\n\
    \    if n % 2 == 0 and n > 2:\n        largest_divisor = int(n // 2)\n       \
    \ return largest_divisor\n    elif n % 2 == 0:\n        largest_divisor = n\n\
    \        return largest_divisor\n    else:\n        largest_divisor = int(n /\
    \ 2)\n        if largest_divisor > n:\n            largest_divisor = n\n     \
    \   return largest_divisor\n</code>\n<|/ a tags=math,python,number-theory,algorithm\
    \ |>\n<| c |>\n`if largest_divisor > n` does not guarantee that the largest divisor\
    \ is smaller than `n`, but it's probably good enough.\n<|/ c |>\n<| c |>\nYou're\
    \ right. But the requirement was to return `n` if it is a factor of the largest\
    \ divisor and return the largest divisor if it is not, so it's probably good enough.\
    \ Also, since `largest_divisor` is set to be `n` if it is a factor of the largest\
    \ divisor, you don't need to check if it's smaller than `n` after you set `largest_divisor`\
    \ equal to `n/2`.\n<|/ c |>\n<| c |>\nHi, thank you for answering! The code works\
    \ fine for even numbers. But, for odd numbers it gives the wrong answer. For example,\
    \ the answer for 15 is 7, but it should be 5. Any idea why?\n<|/ c |>\n<| a tags=math,python,number-theory,algorithm\
    \ |>\nPython's solution is not recursive. I prefer to do it iteratively\n<code>\n\
    def largest_divisor(n):\n    lar", "    // Make sure that n is a positive integer\n\
    \    if ($n < 1) {\n        throw new InvalidArgumentException('n must be a positive\
    \ integer');\n    }\n    $max_factor = 1;\n    $max_factor_index = 0;\n    for\
    \ ($i = 1; $i <= $n; ++$i) {\n        // Check whether n is a prime number\n \
    \       if ($n % $i == 0) {\n            // If n divides evenly into i, there's\
    \ no need to check other factors\n            if ($n / $i == $i) {\n         \
    \       return $max_factor;\n            }\n            $max_factor = 1;\n   \
    \         $max_factor_index = 0;\n            continue;\n        }\n        //\
    \ If n is not a prime number, check whether the previous factor is less than i\n\
    \        if ($max_factor == 1) {\n            $max_factor = $i;\n            $max_factor_index\
    \ = $i;\n        } else if ($max_factor < $i) {\n            $max_factor = $i;\n\
    \            $max_factor_index = $i;\n        }\n    }\n    return $max_factor;\n\
    }\n</code>\n<|/ a tags=php,algorithm,math |>\n<| c |>\nI like the simplicity of\
    \ this, and it's more general, I may have to modify it for my purposes though.\
    \ :)\n<|/ c |>\n<| c |>\nI realize this is old, but this answer doesn't seem to\
    \ work with the current state of PHP7 (PHP Fatal error:  Uncaught TypeError: Argument\
    \ 1 passed to largest_divisor() must be an instance of int, string given).\n<|/\
    \ c |>\n<| c |>\n, my bad, there shouldn't be any concatenations in there, fixed\
    \ now.\n<|/ c |>\n<| a |>\nI've just been looking for an elegant way to solve\
    \ this problem, and found this simple solution\n<code>", "    $divisors = range(2,\
    \ $n); //[2, 4, 6, 8, 10] \n    $max_divisor = 0; \n    foreach ($divisors as\
    \ $divisor) {\n        if ($n % $divisor == 0) {\n            $max_divisor = $divisor;\n\
    \        }\n    }\n    return $max_divisor;\n}\n", "\tif ($n%2 == 0) return $n;\n\
    \telse\n\t\t$t = largest_divisor($n/2);\n\t\tif ($n % 2 == 0 && $t != $n/2) return\
    \ $t;\n\t\telse return $n; // n is a prime\n}", "    // Return 0 if no divisors\
    \ exist or if n is a prime number\n    if ($n < 2 || $n == 1) {\n        return\
    \ 0;\n    }\n\n    // Find largest divisor by trial division\n    // If n is even,\
    \ divide by 2\n    // If n is odd, divide by odd number that is smaller than n\n\
    \    // >>> largest_divisor(15)\n    // 5\n    $m = $n - 1;\n    while ($m % 2\
    \ == 0 || $m % 2 == 1) {\n        $m = $m / 2;\n    }\n\n    // If n was odd,\
    \ divide by 2\n    // >>> largest_divisor(14)\n    // 4\n    if ($m % 2 == 1)\
    \ {\n        $m = $m / 2;\n    }\n\n    // Return largest divisor\n    return\
    \ $m;\n}\n", "  if ($n % 2 == 0) {\n    $d = 1;\n  }\n  else {\n    $d = 2;\n\
    \  }\n  for ($i = 3; $i <= sqrt($n); $i++) {\n    if ($n % $i == 0) {\n      $d\
    \ = $i;\n    }\n  }\n  return $d;\n}", "    $divs = range(1, $n);\n    foreach\
    \ ($divs as $i => $div) {\n        if ($n % $div == 0) {\n            foreach\
    \ (range($div + 1, $n) as $j) unset($divs[$j]);\n            if (count($divs)\
    \ == 0) return $div;\n        }\n    }\n}\n</code>\n<|/ a |>\n<| c |>\nYou forgot\
    \ to subtract 1 from $n when iterating over the $divs array.\n<|/ c |>\n<| c |>\n\
    This is quite interesting, it would be nice to have something that can compute\
    \ the largest divisor faster.\n<|/ c |>\n<| a |>\nThis should do the trick:\n\
    <code>\n<?php", "    $div = array();\n    $div[0] = 1;\n    $div[1] = 1;\n   \
    \ for ($i = 2; $i < $n; $i++) {\n        if (($n % $i) == 0) {\n            $div[$i]\
    \ += $div[$i - 1];\n        }\n    }\n    return $div[$n];\n}\n", "    $i = 1;\n\
    \    $n1 = $n;\n    $n2 = 0;\n    while ($i <= $n) {\n        if (($n % $i) ==\
    \ 0) {\n            $n2 = $i;\n        }\n        $n1 = $n;\n        $n = $i *\
    \ $n2;\n        $i++;\n    }\n    return $n2;\n}", "  $n = max($n, 2);\n  for\
    \ ($i = 3; $i <= sqrt($n); $i++) {\n    if ($n % $i == 0) {\n      return $i;\n\
    \    }\n  }\n  return $n;\n}", "    $x = 1;\n    $y = 2;\n    while ($x < $n)\
    \ {\n        $x = $y * 2;\n        $y = $y + 1;\n    }\n    return $x;\n}\n",
  "  $m = 1;\n  $m2 = 1;\n  while (2 * $m <= $n) {\n    $m2 = $m;\n    $m++;\n  }\n\
    \  return $n;\n}\n", "    $max_divisor = $n;\n    $max_divisor_square = 0;\n\n\
    \    foreach (range(1, $n) as $divisor ) {\n        if ($n % $divisor == 0) {\n\
    \            if ($max_divisor_square == 0 || $max_divisor_square < $divisor*$divisor)\
    \ {\n                $max_divisor_square = $divisor*$divisor;\n              \
    \  $max_divisor = $divisor;\n            }\n        }\n    }\n\n    return $max_divisor;\n\
    }\n", "    $max_divisor = 1;\n    $max_div = 2;\n    while ($max_div < $n) {\n\
    \        if ($n % $max_div == 0) {\n            $max_divisor = $max_div;\n   \
    \     } else {\n            $max_div++;\n        }\n    }\n    return $max_divisor;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a tags=php,algorithm |>\nI refactored the solution\
    \ from Olaf Schneider to make it more efficient:\n<code>", "    $largest_divisor\
    \ = 1;\n    $largest_divisor_less_than = $n;\n    for($i=1; $i<=$n; $i++) {\n\
    \        if($n % $i == 0) {\n            $largest_divisor = $i;\n            if($i\
    \ > $largest_divisor_less_than) {\n                $largest_divisor_less_than\
    \ = $i;\n            }\n        }\n    }\n    return $largest_divisor;\n}\n</code>\n\
    <|/ a dscore=2 tags=php,math |>\n<| c |>\nThat is definitely the most elegant\
    \ answer!\n<|/ c |>\n<| c |>\nThis is one of the few answers that doesn't use\
    \ division (because it is slow).\n<|/ c |>\n<| c |>\nI like how `largest_divisor`\
    \ uses a for loop. I'd have thought that one would need to use `largest_divisor_less_than`\
    \ as another condition in the loop? This seems quite clunky.\n<|/ c |>\n<| a tags=php,math\
    \ |>\nHere's a function that returns the greatest positive number that fits in\
    \ $n. Of course, it could be improved. For example, using logarithms:\n<code>",
  "  $max = $n/2;\n  while (true) {\n    if ($max % 2 == 0)\n      return $max;\n\
    \    $max++;\n  }\n}\n", "    $max_divisor = $n;\n    for ($i = 1; $i <= $n; $i++)\
    \ {\n        if ($n % $i == 0) {\n            $max_divisor = $i;\n        }\n\
    \    }\n\n    return $max_divisor;\n}\n</code>\n<|/ a tags=php,math |>\n<| c |>\n\
    This fails for $n=15. it should return 6. your code returns 5.\n<|/ c |>\n<| c\
    \ |>\nit fails if $n is even and $i is odd. For example on $n=16 i get wrong answer\
    \ because $i is $j=0 but $j is odd. Maybe i should write my own loop to check\
    \ it.\n<|/ c |>\n<| c |>\nYes, that's what I said in the first sentence of my\
    \ answer.\n<|/ c |>\n<| c |>\nI've updated my answer to include a solution which\
    \ works for all n up to a certain limit. The limit here is the largest possible\
    \ divisor: e.g. for n = 14 we know that there is only one divisor of 14 which\
    \ is: 14 / 2 = 6. There are 9 other divisors: for n = 15 we have 14 / 5 = 6 /\
    \ 5 = 2 and 7 / 5 = 4. For n = 16 we have 14 / 6 = 6 / 6 = 2 and 7 / 6 = 4, and\
    \ 8 / 6 = 2. The largest divisor is 8.\n<|/ c |>\n<| c |>\nThis is awesome! I\
    \ hope it helps someone else.\n<|/ c |>\n<| a |>\nThe answer of works well and\
    \ has already been accepted. But here is another alternative that might be faster.\
    \ The basic idea is to find the largest divisor that divides n (using Euclid's\
    \ algorithm) without remainder, and then find the largest divisor that divides\
    \ n by this divisor without remainder. If we consider the case where n is odd\
    \ and is smaller than the largest divisor that divides n (for example n = 9),\
    \ then n is divisible by this divisor and so we know there is no remainder. Thus\
    \ we simply return the largest divisor that divides n. The same idea works for\
    \ the case where n is even and greater than the largest divisor that divides n\
    \ (for example n = 13). Thus we simply return the smallest divisor that divides\
    \ n by this divisor that has remainder.\nThis works for arbitrarily large numbers.\
    \ If you have big numbers, it would be much slower.\n<code>", "    $max = 1;\n\
    \    for ($i = 1; $i <= sqrt($n); $i++) {\n        if ($n % $i == 0) {\n     \
    \       $m = $i / $max;\n            if ($m <= $n / $m) {\n                $max\
    \ = $m;\n            }\n        }\n    }\n    return $max;\n}\n", "    $largest_divisor\
    \ = 1;\n    for($i = 1; $i * $i <= $n; $i++) {\n        if($n % $i == 0) {\n \
    \           $largest_divisor = $i;\n            break;\n        }\n    }\n   \
    \ return $largest_divisor;\n}\n", "  for ($i = 1; $i <= $n; $i++) {\n    if ($n\
    \ % $i == 0) {\n      return $i;\n    }\n  }\n  return $n;\n}\n", "    $n--;\n\
    \    do {\n        $n++;\n        $divisor = $n;\n        while ($n % $divisor\
    \ == 0) {\n            $n--;\n            $divisor++;\n        }\n        if ($divisor\
    \ > $n) {\n            return $divisor;\n        }\n    } while (true);\n}\n",
  "    $l = 1; $c = 1;\n    while($c < $n) {\n        $l *= $c; $c += 1;\n    }\n\
    \    while($n % $l == 0) {\n        $n /= $l;\n    }\n    return $n;\n}", "  return\
    \ intdiv($n, $n, $n) + 1;\n}\n", "    $max_divisor = 1;\n    $max_divisor_value\
    \ = 1;\n    for($i = 1; $i < $n; ++$i) {\n        if($n % $i == 0) {\n       \
    \     if($max_divisor_value < $i) {\n                $max_divisor_value = $i;\n\
    \                $max_divisor = $i;\n            }\n        }\n    }\n    return\
    \ $max_divisor;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\ni was thinking of some\
    \ sort of math approach to the problem but i thought its a bit too complicated.\
    \ Thanks\n<|/ c |>\n<| c |>\nYes, but this approach is easy to understand. It's\
    \ also very efficient.\n<|/ c |>\n<| a tags=php,algorithm,math |>\nA simple solution\
    \ might be the following.\nThe idea is to start with a prime number ($p) and then\
    \ start with a number lower than $p and check if it divides evenly with $p. If\
    \ it doesn't, continue with the next number which is lower than $p ($p + 1).\n\
    When you reach $p its the highest number for which you get a divisor.\n<code>\n\
    <?php\n", "    // Sieve of Eratosthenes\n    // http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\
    \    $n = abs($n);\n    $max_divisor = pow(2, $n); // pow() uses floats, pow()\
    \ uses integers\n    $max_divisor = intval($max_divisor);\n    $max_divisor *=\
    \ $max_divisor;\n    $max_divisor--;\n    while ($max_divisor > $n) {\n      \
    \  $max_divisor = pow($max_divisor, 2);\n        $max_divisor = intval($max_divisor);\n\
    \        $max_divisor *= $max_divisor;\n        $max_divisor--;\n    }\n    return\
    \ $max_divisor;\n}\n</code>\n<|/ a tags=php,math dscore=0 |>\n<| c |>\nThanks\
    \ for the answer, but this code is way too slow to solve this problem with 100+\
    \ numbers, takes too long to solve this with 1000+ numbers. Do you know any way\
    \ to optimize this or some other way to solve this faster?\n<|/ c |>\n<| c |>\n\
    If you're doing this many times, just pre-compute the list of primes up to 1000\
    \ and store them in a database or file (or a text file that you can parse at run-time).\
    \  That way you can just use the first 1000 primes as your upper bound, and your\
    \ problem is solved once rather than on every execution.  If the answer is known\
    \ in advance, pre-computing it only takes a few hundred MB of RAM, so it's fast\
    \ to compute and store the answer.\n<|/ c |>\n<| a |>\nThis is my solution in\
    \ java, maybe you can convert it to php:\n<code>\nimport java.util.ArrayList;\n\
    import java.util.List;\n\npublic class Primes {\n    public static boolean isPrime(int\
    \ n) {\n        if (n <= 2) {\n            return false;\n        }\n        if\
    \ (n <= 3) {\n            return true;\n        }\n        if (n % 2 == 0 || n\
    \ % 3 == 0) {\n            return false;\n        }\n        if (n == 1 || n ==\
    \ 3) {\n            return true;\n        }\n        int sqrtN = Math.sqrt(n);\n\
    \        for (int i = 3; i <= sqrtN; i += 2) {\n            if (n % i == 0) {\n\
    \                return false;\n            }\n        }\n        return true;\n\
    \    }\n\n    public static boolean isPrime2(int n) {\n        boolean result\
    \ = false;\n        List<Integer> primes = new ArrayList<>();\n        for (int\
    \ i = 0; i <= 50; i++) {\n            if (isPrime(i)) {\n                primes.add(i);\n\
    \            }\n        }\n        boolean isPrime = false;\n        int sqrtN\
    \ = (int) Math.sqrt(n);\n        for (int i = 3; i <= sqrtN; i += 2) {\n     \
    \       if (n % i == 0) {\n                isPrime = true;\n                break;\n\
    \            }\n        }\n        if (isPrime) {", "    $divisor = 1;\n    $factor\
    \ = 2;\n    while ($divisor < $n && $factor < $n) {\n        if ($n % $factor\
    \ == 0) {\n            $divisor = $factor;\n        }\n        $factor++;\n  \
    \  }\n    return $divisor;\n}\n", "    $num = 0;\n    while($num < $n) {\n   \
    \     $num += $n / ++$n;\n    }\n    return $num;\n}", "    $n++;\n    $res =\
    \ 1;\n    while($n) {\n        $res = $n % $res;\n        $n = floor($n/$res);\n\
    \    }\n    return $res;\n}\n", "\t$max_divisor = 1;\n\tfor ($i = 2; $i <= sqrt($n);\
    \ $i++) {\n\t\t$divisor = $i * $max_divisor;\n\t\tif ($n % $divisor === 0) {\n\
    \t\t\t$max_divisor = $divisor;\n\t\t}\n\t}\n\treturn $max_divisor;\n}\n", "  \
    \  $divisors = range(2, $n + 1, 2);\n    $divisors[] = 1;\n    $divisors[] = 2;\n\
    \    $divisors[] = 5;\n    $divisors[] = 12;\n    $divisors[] = 13;\n    $divisors[]\
    \ = 14;\n    $divisors[] = 16;\n    $divisors[] = 24;\n    $divisors[] = 25;\n\
    \    $divisors[] = 55;\n    $divisors[] = 108;\n    $divisors[] = 156;\n    $divisors[]\
    \ = 500;\n    $divisors[] = 1000;\n    $divisors[] = 5000;\n    $divisors[] =\
    \ 100000;\n    $divisors[] = 1000000;\n    $divisors[] = 10000000;\n    $divisors[]\
    \ = 1000000000;\n    return array_search(max($divisors), $divisors);\n}", "  \
    \  if ($n%2 == 0) return $n/2;\n    $largest = sqrt($n);\n    for($i = 3; $i <\
    \ $n; $i += 2)\n        if ($n/$i <= $largest) $largest = $n/$i;\n    return $largest;\n\
    }", "    if ($n == 0 || $n == 1) return 1;\n    else return $n % largest_divisor($n-1);\n\
    }", "\tfor ($i = 2; $i <= $n; $i++)\n\t\tif ($n % $i == 0)\n\t\t\treturn $i;\n\
    \treturn $n;\n}\n", "    $m = $n;\n    $n1 = 1;\n    $n2 = 1;\n    while ($m !=\
    \ 0) {\n        $m = $m / $n1;\n        if ($m != 0) {\n            $n2 = $n1\
    \ + $n2;\n            $n1 = $n2;\n        } else {\n            $n1 = $n2;\n \
    \       }\n    }\n    return $n1;\n}\n", "    if ($n <= 3) return $n;\n\n    $primes\
    \ = array(2, 3, 5);\n\n    $max_divisor = $n % array_pop($primes);\n    for ($i\
    \ = 3; $i <= $max_divisor; $i++) {\n        if (!in_array($n % $i, $primes)) {\n\
    \            $max_divisor = $i;\n            break;\n        }\n    }\n\n    return\
    \ $max_divisor;\n}\n</code>\nThe idea is to divide the number by primes until\
    \ you get to one. Then take the remainder of the number divided by that prime.\
    \ Repeat until you reach the end (we already know that the largest divisor is\
    \ larger than the number we're looking at). \nIf you find that the largest divisor\
    \ is the number you're looking at, then it's probably a prime number. \nThis should\
    \ do the job, but I'm not sure how efficient it is. I'm sure there's much better\
    \ solutions out there. \nEdit:\nIn response to the comment:\nThis is definitely\
    \ not efficient, but here's a little more efficient version. \n<code>\n<?php\n",
  "\t$max = 0;\n\tfor ($i = 1; $i < $n; $i++) {\n\t\tif ($n % $i == 0) {\n\t\t\tif\
    \ ($max < $i) {\n\t\t\t\t$max = $i;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$max += $i;\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn $max;\n}", "    $divisor = 1;\n    $limit = 10;\n\
    \    while ($divisor < $limit) {\n        if ($n % $divisor === 0) {\n       \
    \     break;\n        }\n        $divisor++;\n    }\n    return $divisor;\n}\n",
  "\t$max_divisor = $n-1;\n\tfor ($i=2; $i <= $n/2; $i++) {\n\t\tif ($n % $i == 0)\
    \ {\n\t\t\t$max_divisor = $i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn $max_divisor;\n\
    }", "    $divisor = 2;\n    while ($divisor * $divisor <= $n) {\n        $divisor++;\n\
    \    }\n    return $divisor;\n}", "    $divisor = 1;\n    while ($n % $divisor\
    \ === 0) {\n        $divisor++;\n    }\n    return $divisor;\n}\n", "    if ($n\
    \ < 2) return 1;\n    $result = $n;\n    for ($i = 3; $i <= sqrt($n); $i++) {\n\
    \        if ($n % $i == 0) {\n            $result = $i;\n            if ($i ==\
    \ $n) break;\n        }\n    }\n    return $result;\n}\n", "    $result = 0;\n\
    \    for($i = 1; $i <= $n; $i++) {\n        if($n % $i == 0) {\n            $result\
    \ = max($result, $i);\n        }\n    }\n    return $result;\n}\n\n$largest_divisor\
    \ = largest_divisor(50);\n\necho \"The largest divisor of 50 is $largest_divisor\"\
    ;", "  if ($n < 2) return 0;\n  if ($n == 2) return 1;\n  return $n / largest_divisor($n\
    \ - 1);\n}\n", "  $divs = array(1);\n  $div = 1;\n  for ($i = 1; $i <= $n; $i++)\
    \ {\n    if ($n % $i == 0) {\n      $divs[$div] = $i;\n      $div++;\n    }\n\
    \  }\n  return $divs[$div - 1];\n}\n", "\t$divisors = 0;\n\tfor ($i = 1; $i <=\
    \ $n; $i++) {\n\t\tif ($n % $i == 0) {\n\t\t\t$divisors += $i;\n\t\t}\n\t}\n\t\
    return $divisors;\n}\n", "  $x = 1; // largest divisor\n  for ($i = 0; $i < $n;\
    \ $i++)\n    if ($n % $i == 0)\n      $x = ($x < $i ? $i : $x);\n  return $x;\n\
    }", "\tglobal $largest_divisor;\n\t$largest_divisor = 1;\n\tfor ($i=1; $i<=$n;\
    \ $i++) {\n\t\tif ($n%$i == 0) {\n\t\t\t$largest_divisor = $i;\n\t\t\tbreak;\n\
    \t\t}\n\t}\n\treturn $largest_divisor;\n}\n", "  $n++;\n  $max = $n/2;\n  while\
    \ ($max > 1 && $n % $max === 0) {\n    $max--;\n  }\n  if ($max === 1) {\n   \
    \ return $max;\n  }\n  return $max;\n}\n", "  for ($i = 1; $i <= $n; $i++) {\n\
    \    if ($n % $i == 0) {\n      return $i;\n    }\n  }\n  return $n;\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\n`largestDivisor(15)` returns 5 as expected. Also `largestDivisor(999)`\
    \ returns 99.\n<|/ c |>\n<| c |>\nThat is because the highest divisor <= 999 can\
    \ be written as 99 (if you can write 9 as one single digit then the highest divisor\
    \ <= 99 can be written as 99). So I suppose that if he wants 999 to be returned\
    \ then he should add another condition checking if it can be written as a single\
    \ digit (I didn't bother with this since it wasn't the OP's question about this)\n\
    <|/ c |>\n<| c |>\nYes, I realize that but your solution is not correct either.\
    \  It returns `6` instead of `5`.  Also, your function does not take into account\
    \ the fact that 9 is a valid divisor of any number.\n<|/ c |>\n<| c |>\nYes, I\
    \ realize that I made a mistake. I didn't notice that 9 is valid so I assumed\
    \ that all numbers had a divisor that is a power of 2. In that case my solution\
    \ would still be correct.\n<|/ c |>\n<| c |>\nThe question is why does `largestDivisor(9)`\
    \ return `6`?\n<|/ c |>\n<| a tags=php,math dscore=1 |>\nHere is one solution:\n\
    <code>\n<?php", "    $divisors = array();\n    for($i = 1; $i <= $n; $i++)\n \
    \   {\n        if($n % $i == 0)\n        {\n            $divisors[] = $i;\n  \
    \      }\n    }\n    return $divisors[0];\n}\n</code>\n<|/ a dscore=3 |>\n<| a\
    \ dscore=3 |>\nI came up with this code using binary search and recursion (no\
    \ loops)\n<code>\n<?php\n$arr = array(1,2,3,4,5,6,7,8,9,10);\n", "  $nToTest =\
    \ $n;\n  $divisor = 1;\n  while ($divisor < $n) {\n    if ($n % $divisor === 0)\
    \ {\n      $nToTest = $nToTest / $divisor;\n      if ($nToTest == $n) {\n    \
    \    return $divisor;\n      }\n    } else {\n      $divisor++;\n    }\n  }\n\
    \  return $n;\n}\n</code>\n<|/ a tags=php |>\n<| c |>\nThanks for taking the time\
    \ to answer.\n<|/ c |>\n<| a tags=php dscore=0 |>\nThis code will work for any\
    \ number you want.\n<code>\n<?php\n$num= intval($_GET[\"num\"]);\n\nif($num>0)\n\
    {\nif($num % 2 == 0)\n{\n    $answer=$num;\n}\nelse\n{\n    $a=largest_divisor($num);\n\
    \    $answer=($a/2)*($a/2);\n}\n\n}\n\necho \"<br/><br/><br/>\";\necho \"The Largest\
    \ Divisor of $num is $answer.\";", "  $n = abs($n);\n  $max_factor = 1;\n  $max_factor_index\
    \ = 0;\n  for ($i = 2; $i <= sqrt($n); $i++) {\n    $next_factor = $i * 2;\n \
    \   if ($n % $next_factor == 0) {\n      $max_factor = $next_factor;\n      $max_factor_index\
    \ = $i;\n    }\n  }\n  return $max_factor;\n}\n", "    $max_divisor = $n;\n  \
    \  $factor = 1;\n\n    while ($factor < $n) {\n        $max_divisor = $factor;\n\
    \        $factor += $max_divisor / $max_divisor;\n    }\n\n    return $max_divisor;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a |>\nA little bit of Math will do it:\n<code>\n\
    <?php", "    $max_divisor = 0;\n    for ($i = 2; $i <= $n; $i++) {\n        if\
    \ ($n % $i == 0) {\n            $max_divisor = $i;\n        }\n    }\n    return\
    \ $max_divisor;\n}\n", "    $d = 1;\n    $max = $n;\n    $n--;\n    while ($n\
    \ > 0) {\n        if ($n % $d == 0) {\n            if ($d > $max) {\n        \
    \        $max = $d;\n            }\n            $d++;\n        } else {\n    \
    \        $n--;\n        }\n    }\n    return $max;\n}\n", "    $factor = 1;\n\
    \    $divisor = 2;\n    while ($divisor <= $n) {\n        if ($n % $divisor ==\
    \ 0) {\n            $factor = $divisor;\n            $divisor++;\n        }\n\
    \        else {\n            break;\n        }\n    }\n    return $factor;\n}\n",
  "  if ($n == 1)\n    return 1;\n  if ($n <= 2)\n    return $n;\n  return $largest_divisor($n\
    \ / 2) * $largest_divisor($n / 2);\n}\n", "  $i = 2;\n  $divisor = 1;\n  while\
    \ (!($i % 2) && $i <= $n) {\n    $i += 2;\n    $divisor++;\n  }\n  return $divisor;\n\
    }\n", "    $div = 1;\n    $mod = 1;\n\n    while($mod<$n) {\n        if ($n%$mod==0)\
    \ {\n            $div++;\n        }\n        $mod = $mod*$div;\n    }\n\n    return\
    \ $mod;\n}\n", "    $i = 1;\n    $divisor = 1;\n    while ($i <= $n) {\n     \
    \   if ($n % $i == 0) {\n            $divisor = $i;\n        }\n        $i++;\n\
    \    }\n    return $divisor;\n}\n", "    // Write your PHP implementation here\n\
    \    // var_dump($n);\n    return $n / 4;\n}", "    $smallest = $n;\n    $largest\
    \ = 999999999;\n    while ($n > 1) {\n        $tmp = $n / 2;\n        if ($tmp\
    \ % 2 == 0) {\n            $n = (int) $tmp;\n        }\n        else {\n     \
    \       $n = $tmp;\n        }\n        if ($n <= $smallest || $largest < $n) {\n\
    \            $smallest = $n;\n            $largest = $n;\n        }\n    }\n \
    \   return $largest;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nWhile this code\
    \ snippet may solve the question, [including an explanation](//meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion. Please also try not to crowd your code with\
    \ explanatory comments, this reduces the readability of both the code and the\
    \ explanations!\n<|/ c |>\n<| c |>\nThank you for the suggestion. I've added some\
    \ explanation.\n<|/ c |>\n<| c |>\nThis is still not correct, `largest_divisor(15)\
    \ // 5` but should be `largest_divisor(16) // 4`\n<|/ c |>\n<| a dscore=1 tags=php\
    \ |>\n<code>\n<?php", "  $res = 1;\n  for ($i = 1; $i <= $n; $i++) {\n    if ($n\
    \ % $i === 0) {\n      $res = $i;\n      break;\n    }\n  }\n  return $res;\n\
    }\n</code>\n<|/ a tags=php,algorithm |>\n<| c |>\nNice! I was thinking about implementing\
    \ this in php and your answer made me realize that i could just use an array.\n\
    <|/ c |>\n<| c |>\nIt would be nice if this code was actually tested.  I realized\
    \ my PHP version did not have the max() function but this still worked in the\
    \ PHP sandbox.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  $max = $n-1;\n  for ($i\
    \ = 1; $i >= $max; $i--) {\n    if ($n % $i == 0) {\n      return $i;\n    }\n\
    \  }\n  return $max;\n}", "    $start = 1;\n    $stop = $n;\n    $divisor = 1;\n\
    \    while ($start < $stop) {\n        $divisor *= ++$start;\n        if ($divisor\
    \ > $n) {\n            $stop = $divisor;\n        } else {\n            $start\
    \ = $divisor + 1;\n        }\n    }\n    return $start;\n}\n", "  for ($i = 1;\
    \ $i <= $n; $i++) {\n    if ($n % $i == 0) {\n      return $i;\n    }\n  }\n \
    \ return 1;\n}\n", "  $m = 1;\n  while ($n / $m > 1) {\n    $m = $m * 10;\n  }\n\
    \  return $m;\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\nThe following is similar\
    \ to answer (with a small difference).\nMy method also works correctly for negative\
    \ numbers but it will not work for all number that are not divisible by 1 as those\
    \ numbers won't get \"trimmed\".\nMy method will always get the \"largest\" number\
    \ in case of input value with multiple divisors.\n<code>\npublic function largestDivisor($value)\
    \ {\n    $largestDivisor = array();\n    for($i = 1; $i <= $value; $i++) {\n \
    \       if($value % $i == 0) {\n            if($largestDivisor[0] == $i) {\n \
    \               $largestDivisor[1] = $i;\n            }\n            else {\n\
    \                $largestDivisor[0] = $i;\n                $largestDivisor[1]\
    \ = $i;\n            }\n        }\n    }\n\n    $finalDivisor = $largestDivisor[1];\n\
    \    return $finalDivisor;\n}\n</code>\n<|/ a tags=math,php,math |>\n<| a tags=math,php,math\
    \ dscore=0 |>\n<code>\n$number = 10;\n$divisor = $number;\n$largestDivisor = 1;\n\
    $i = 1;\n\nwhile ($divisor != 1){\n    $divisor = $number / $largestDivisor;\n\
    \    $largestDivisor = $largestDivisor * 10;\n    $i++;\n}\n\necho $largestDivisor;\n\
    </code>\n<|/ a |>\n<| a |>\nThis solution is based on \"naruto\"'s solution but\
    \ with two important differences:\n\nThe first divisor is found using binary search\n\
    The first divisor is calculated with pow(), which allows us to get the highest\
    \ power of 2 that's smaller than the target (to avoid looping all the way down\
    \ to 1).\n\n<code>\n<?php\n", "    $nMinus1 = $n % $n;\n    $largestDivisor =\
    \ $n / $nMinus1;\n    $n = $nMinus1;\n    $n++;\n    while($n % $n) {\n      \
    \  $largestDivisor *= $n;\n        $n /= $n;\n        $n++;\n    }\n    return\
    \ $largestDivisor;\n}", "    $m = $n;\n    $i = 2;\n    while($i <= $m) {\n  \
    \      if($n % $i == 0) {\n            $m = $i;\n        } else {\n          \
    \  $i++;\n        }\n    }\n    return $m;\n}", "    if ($n < 2) {\n        return\
    \ 2;\n    }\n    if ($n % 2 == 0) {\n        return $n; // n is even\n    }\n\
    \    $res = $n;\n    while (true) {\n        if ($res / 2 > $n) {\n          \
    \  $res++;\n        } else {\n            break;\n        }\n    }\n    return\
    \ $res;\n}", "    // The function assumes that n is odd, but it does not need\
    \ to check this\n    $n = (int) $n;\n    // Find the first even number that divides\
    \ n evenly and larger than n itself\n    for ($i = 1; $i <= $n; $i += 2) {\n \
    \       if ($i % 2 === 0) {\n            return $i;\n        }\n    }\n    //\
    \ No even number divides n evenly, so return the largest number smaller than n\
    \ itself\n    return $n - 1;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nWow, thank\
    \ you so much!\n<|/ c |>\n<| c |>\nThis is wrong. `largest_divisor(15)` returns\
    \ 3 whereas `largest_divisor(17)` returns 5.\n<|/ c |>\n<| c |>\nWhat do you mean?\
    \ Why does it return 3 for 15?\n<|/ c |>\n<| c |>\nYou return `largest_divisor(15)`\
    \ which returns 3. `largest_divisor(17)` returns `largest_divisor(15)` which returns\
    \ 3.\n<|/ c |>\n<| c |>\nSo how do you explain `largest_divisor(17)` returning\
    \ `5`?\n<|/ c |>\n<| a tags=php,largest-number,algorithm |>\nHere is the recursive\
    \ version (tested with PHP7.4):\n<code>", "    $divisor = 1;\n    $largest_divisor\
    \ = 1;\n    for($i = 0; $i < $n; $i++) {\n        $divisor += $i;\n        if\
    \ ($divisor % 2 == 0) {\n            if ($divisor > $largest_divisor) {\n    \
    \            $largest_divisor = $divisor;\n            }\n        }\n    }\n \
    \   return $largest_divisor;\n}\n", "  $divisor = 1;\n  $counter = 2;\n  while\
    \ (true) {\n    if ($n % $divisor == 0) {\n      $divisor = $counter;\n    }\n\
    \    $counter++;\n    if ($counter > $n) {\n      $divisor = $n;\n      break;\n\
    \    }\n  }\n  return $divisor;\n}", "    $factors = array();\n    for ($i = 1;\
    \ $i <= $n; ++$i) {\n        if ($n % $i == 0) {\n            $factors[] = $i;\n\
    \        }\n    }\n    return max($factors);\n}\n", "  $max_divisor = 1;\n  for\
    \ ($i = 2; $i * $i <= $n; $i++) {\n    if ($n % $i == 0) {\n      $max_divisor\
    \ = $i;\n    }\n  }\n  return $max_divisor;\n}\n</code>\n<|/ a tags=php,math,algorithm\
    \ dscore=3 |>\n<| c |>\nThanks so much! I didn't expect an answer this quickly\
    \ and your comment made me realize my mistake.\n<|/ c |>\n<| c |>\n: Glad I could\
    \ help. It's a fun problem. :)\n<|/ c |>\n<| a dscore=3 |>\nIf you can only use\
    \ recursion, you can use the following function:\n<code>", "  $largest = array(1);\n\
    \  $divisor = array(1);\n\n  while ($n % $divisor[0]) {\n    $divisor[] = $divisor[0];\n\
    \    $largest[] = $largest[0];\n  }\n  \n  array_pop($divisor);\n  array_pop($largest);\n\
    \n  $largest[] = $largest[0];\n  array_push($largest, $divisor);\n\n  while ($largest[0]\
    \ < $n) {\n    $largest[] = $largest[0];\n    array_push($largest, $largest[0]);\n\
    \  }\n  return $largest;\n}", "    // $n is assumed to be an integer.\n    //\
    \ If $n is negative, we'll be using $n%$max below, so make sure it's positive.\n\
    \    $max = (int)$n;\n\n    $largest = 1;\n    $n = abs($n);\n    for ($i = 1;\
    \ $i < $n; $i++) {\n        if ($n % $i == 0) {\n            $largest = max($largest,\
    \ $i);\n        }\n    }\n\n    return $largest;\n}\n\n/**\n * Generate a random\
    \ string of $length characters using a CSPRNG.\n *\n * We use the $length argument\
    \ to specify the length of the string, and we add an\n * additional $prefix argument\
    \ to specify the prefix that should be used.\n *\n * @see random_int()\n * @see\
    \ random_bytes()\n */", "\t$factors = array_filter($prime_factors_array(), function($factor)\
    \ {\n\t\treturn $factor->value % $n == 0;\n\t});\n\tsort($factors, SORT_NUMERIC);\n\
    \treturn $factors[0]->value;\n}\n", "  return $n % 2 !== 0 ? $n / 2 : largest_divisor($n\
    \ / 2);\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=arrays,php dscore=0 |>\nI dont\
    \ really understand your question but why dont you use the max() function\nhttp://php.net/manual/en/function.max.php\n\
    <|/ a |>\n<| a |>\n<code>", "    $max_divisor = 1;\n    for($i = 1; $i <= $n;\
    \ $i++) {\n        if($n % $i == 0) {\n            $max_divisor = $i;\n      \
    \  }\n    }\n    return $max_divisor;\n}\n</code>\n<|/ a dscore=3 tags=php,algorithm\
    \ |>\n<| c |>\nI think this is really the fastest method here.\n<|/ c |>\n<| c\
    \ |>\nThe biggest number that is evenly divisible by any number is itself.\n<|/\
    \ c |>\n<| c |>\nThis works great, except it fails when `n` is very large, which\
    \ is why I added my own answer.\n<|/ c |>\n<| c |>\nActually I did a benchmark\
    \ here https://3v4l.org/G6uNn\n<|/ c |>\n<| a dscore=3 |>\nA very fast method\
    \ would be to check all numbers up to sqrt($n) first, and then check if the number\
    \ $n is divisible by any of them:\n<code>", "    $a = array(1, 3, 9, 27, 81, 243,\
    \ 729, 2185, 3999, 6999);\n    $b = array(0, 2, 5, 10, 4, 8, 15, 16, 23, 42, 61,\
    \ 24);\n    $c = array(0, 2, 4, 6, 8);\n    $x = 1;\n    $y = 1;\n    $z = 1;\n\
    \    $r = 1;\n    while($x <= $n) {\n        $d = $n/$x;\n        if($x == $y)\
    \ {\n            $z = $d;\n        }\n        else if($x > $y) {\n           \
    \ $r++;\n        }\n        else if($x == $z) {\n            $d = $n%$x;\n   \
    \         if($x == $d) {\n                $z = $x;\n            }\n          \
    \  else {\n                if($d < $b[$z]) {\n                    $b[$z] = $d;\n\
    \                }\n            }\n        }\n        else {\n            $c[$z]\
    \ = $x;\n        }\n        $x++;\n        $y++;\n    }\n    if($r == 1) {\n \
    \       return $b[$z];\n    }\n    else {\n        return $c[$z];\n    }\n}",
  "    return 1;\n}", "    // Use Sieve of Eratosthenes\n    // http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\
    \    // O(nlogn)\n    $largest = 1;\n    for ($i = 2; $i <= sqrt($n); $i++) {\n\
    \        if ($n % $i == 0) {\n            $largest = $i;\n        }\n    }\n \
    \   return $largest;\n}\n", "    $divisor = array();\n    for($i = 2; $i <= $n;\
    \ $i++) {\n        if($n % $i == 0) {\n            $divisor[] = $i;\n        \
    \    if(count($divisor) == 2) {\n                return $divisor;\n          \
    \  }\n        }\n    }\n    return $divisor;\n}\n", "\t$max_divisor = 1;\n\t$max_divisor_id\
    \ = 0;\n\tfor ($i = 1; $i <= $n; $i++) {\n\t\tif ($n % $i == 0) {\n\t\t\t$divisors[]\
    \ = $i;\n\t\t\tif ($max_divisor < $i) {\n\t\t\t\t$max_divisor = $i;\n\t\t\t\t\
    $max_divisor_id = $i;\n\t\t\t}\n\t\t}\n\t}\n\treturn $max_divisor;\n}\n", "  $i\
    \ = 1;\n  while (++$i <= $n) {\n    if ($n % $i == 0) {\n      $k = array_keys(range(1,\
    \ $i), $i);\n      return $k[0] === false ? $i : $k[0];\n    }\n  }\n}\n", " \
    \   $factors = array();\n\n    foreach (range(1, $n + 1) as $factor) {\n     \
    \   if ($n % $factor == 0) {\n            $factors[] = $factor;\n        }\n \
    \   }\n\n    foreach ($factors as $factor) {\n        if ($n % $factor == 0) {\n\
    \            return $factor;\n        }\n    }\n}\n", "    for($i = 1; $i < $n;\
    \ $i++) {\n        if ($n % $i == 0) {\n            return $i;\n        }\n  \
    \  }\n    return $n;\n}\n", "    $largest_divisor = 1;\n    $largest_divisor_p\
    \ = $n;\n    do {\n        $largest_divisor++;\n        $largest_divisor_p = pow($largest_divisor_p,\
    \ 2);\n    } while ($largest_divisor_p > $n);\n    return $largest_divisor;\n\
    }\n", "    $i = 1;\n    foreach (range(1, $n) as $j) if ($n % $j == 0) $i++;\n\
    \    return $n;\n}\n</code>\n<|/ a |>\n<| c |>\nI like your solution, although\
    \ it isn't a good one for bigger numbers. My solution is based on the fact that\
    \ there exists an integer k such that k*k<=n. That is, k is a perfect square.\
    \ So in fact my solution is just an implementation of your solution that uses\
    \ that property. But it is much more computationally intensive than my solution.\n\
    <|/ c |>\n<| c |>\nYes, I understand your concern. My solution is definitely not\
    \ the best for bigger numbers. Yours is the best for small numbers. The best in\
    \ that case is to just do `sqrt($n)` and then compare it to your solution. It\
    \ will work for numbers that cannot be expressed as a perfect square. Or maybe\
    \ I didn't understand the question.\n<|/ c |>\n<| c |>\nMy solution would have\
    \ been my first choice, if I had not already decided on my own. The problem with\
    \ your solution is that it is not efficient, and so I thought I might make my\
    \ solution more efficient.\n<|/ c |>\n<| c |>\nActually my solution is not as\
    \ efficient as it could be. I tested it with big numbers and a factor of 4 but\
    \ my solution was still faster (3 times faster, I guess because of some optimizations\
    \ in the PHP script). But for small numbers and a factor of 4 my solution was\
    \ faster (3 times faster).\n<|/ c |>\n<| a |>\nI used GMP (Gnu Multi-Precision\
    \ Arithmetic Library) for a project which involved large factorials. In your case:\n\
    <code>\n$factorial = new GMP(factorial($n));\n</code>\n<|/ a dscore=0 tags=php,math,factorial\
    \ |>\n<| c |>\nI tried the GMP library but it is very very slow for large numbers.\
    \ It is way too slow.\n<|/ c |>\n<| a dscore=0 |>\nI used this solution:\n<code>",
  "  $i = 0;\n  $n = array_filter($n, function ($el) use (&$i) {\n    $i++;\n    return\
    \ $el !== $n;\n  });\n  $i = count($n);\n  if ($i === 0) {\n    return 1;\n  }\n\
    \  return $n[$i - 1];\n}\n", "  for ($i = 2; $i <= $n; $i++) {\n    if ($n % $i\
    \ == 0) {\n      return $i;\n    }\n  }\n  return $n;\n}\n", "    $max_divisor\
    \ = 0;\n    for($i = 1; $i <= $n; $i++) {\n        if($n % $i == 0) {\n      \
    \      $max_divisor = $i;\n        }\n    }\n    return $max_divisor;\n}\n", " \
    \   $div = 1;\n    $max = $n;\n    while ($max % $div === 0) {\n        $max *=\
    \ $div;\n        $div += 1;\n    }\n\n    return $max;\n}\n", "  if($n == 0) return\
    \ $n;\n  $n2 = $n >> 1;\n  while($n2 > 0) {\n    if($n % $n2++ == 0) return $n2;\n\
    \  }\n  return $n2;\n}", "  $d = 1;\n  $max_divisor = 1;\n  $max_divisor_p = 1;\n\
    \  for ($i = 2; $i <= $n; ++$i) {\n    if ($n % $i == 0) {\n      $d += $i;\n\
    \      $max_divisor_p = $i;\n      if ($d > $max_divisor) {\n        $max_divisor\
    \ = $d;\n      }\n    }\n  }\n  return $max_divisor;\n}\n", "  $i = 1;\n  do {\n\
    \    if ($n % $i == 0) {\n      echo \"$i <br>\";\n    }\n    $i++;\n  } while\
    \ (++$i <= $n);\n  echo \"$i <br>\";\n}\nlargest_divisor(60);", "    $start =\
    \ 1;\n    $end = sqrt($n);\n    $start = 1;\n    $end = $end + ($end - $start)\
    \ / 2;\n    while ($n % $start == 0) {\n        $start++;\n    }\n    while ($n\
    \ % $end == 0) {\n        $end--;\n    }\n    if ($start > $end) {\n        return\
    \ $end;\n    } else {\n        return $start;\n    }\n}\n", "  for ($i = 1; $i\
    \ <= $n; $i++) {\n    if ($n % $i == 0) {\n      return $i;\n    }\n  }\n  return\
    \ $n;\n}\n", "  $largest = 1;\n  $n = abs($n);\n  for ($i = 2; $i * $i <= $n;\
    \ ++$i) {\n    $largest = $i if $n % $i == 0;\n  }\n  return $largest;\n}\n</code>\n\
    <|/ a tags=php dscore=0 |>\n<| a dscore=0 |>\n<code>\n$number = 15;\n$i = 1;\n\
    $largest = 0;\nwhile(is_int($number/10) && $number > 0){\nif($number % 10 == 0){\n\
    \  $largest = $i;\n}\n$i++;\n$number /= 10;\n}\n</code>\nThis code will give the\
    \ largest number which can divide $number into 10 digits without remainder.\n\
    <|/ a tags=php |>\n<| a tags=php |>\n<code>", "  if ($n < 3) {\n    return 1;\n\
    \  }\n  $candidates = [];\n  for ($i = 1; $i <= $n; ++$i) {\n    $candidates[$i]\
    \ = $i;\n    $candidates[$n - $i] = $n - $i;\n  }\n  sort($candidates);\n  return\
    \ $candidates[0];\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis is the best solution,\
    \ I was looking for a recursive solution that could be written like `largest_divisor(15)`\
    \ and not `largest_divisor(15)`, just that I was looking for. Thank you.\n<|/\
    \ c |>\n<| c |>\nThis solution takes so much time... (~3 minutes)\n<|/ c |>\n\
    <| a dscore=3 tags=numbers,php,math |>\nThis works for me:\n<code>", "    if ($n\
    \ % 2 == 0) {\n        echo \"0\";\n        return;\n    }\n    $n1 = $n / 2;\n\
    \    $n2 = $n1 / 2;\n    while ($n2 == $n1 / 2) {\n        $n2 = $n2 / 2;\n  \
    \  }\n    return $n2;\n}\n", "    $divisor = 0;\n    for ($i = $n; $i >= 1; $i--)\
    \ {\n        $divisor = $i;\n        if ($n % $i == 0) {\n            $divisor\
    \ = $i;\n            break;\n        }\n    }\n    return $divisor;\n}\n", " \
    \   // Base case 1: if n = 0, return 0\n    if ($n == 0) {\n        return 0;\n\
    \    }\n    // Base case 2: if n = 1, return n\n    if ($n == 1) {\n        return\
    \ $n;\n    }\n    // Recursive case: find the largest divisor for n/2\n    $largest_divisor\
    \ = largest_divisor($n / 2);\n    // If n is divisible by any larger divisor,\
    \ it's also larger than n/2\n    if ($n % $largest_divisor == 0) {\n        return\
    \ $largest_divisor;\n    }\n    return $largest_divisor + 1;\n}\n", "    $divisor\
    \ = 1;\n    $n = $n / 2;\n    for($i = 1; $i <= $n; $i++) {\n        if($n % $i\
    \ == 0) {\n            $divisor = $i;\n        }\n    }\n    return $divisor;\n\
    }\n", "  for ($i = 1; $i < sqrt($n); $i++) {\n    if ($n % $i == 0) {\n      return\
    \ $i;\n    }\n  }\n  return $n;\n}\n", "    $divs = array();\n    $m = 1;\n  \
    \  while($m <= $n){\n        if(($n % $m) == 0) $divs[] = $m;\n        $m++;\n\
    \    }\n    if(count($divs) == 0) return 0;\n    return $divs[count($divs)-1];\n\
    }", "    $max = 1000000;\n    $maxDivisor = 3;\n    for ($i = 1; $i <= $n; $i++)\
    \ {\n        if ($n % $i == 0) {\n            $maxDivisor = $i;\n            if\
    \ ($i > $max) {\n                $max = $i;\n            }\n        }\n    }\n\
    \    return $maxDivisor;\n}\n", "    for ($i = 2; $i <= sqrt($n); $i++) {\n  \
    \      if ($n % $i == 0) {\n            return $i;\n        }\n    }\n    return\
    \ $n;\n}", "  $n = (int) $n;\n  $factors = range(1, $n);\n  usort($factors, function($a,\
    \ $b) {\n    return ($a / $b) * $a > ($b /  $a) * $b;\n  });\n  return $factors[$n];\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI really don't understand why so many\
    \ people think that this code is inefficient. There is no such thing as time complexity\
    \ in this code. It just calculates all divisors and then sorts them and returns\
    \ the last one. If there are no factors except one, there is nothing to sort.\
    \ Besides that, the function name should say what it does, not how it does it.\n\
    <|/ c |>\n<| c |>\nYour point is valid, though I think that for such an easy problem\
    \ this code is easier to understand than other solutions. There are several ways\
    \ to achieve this. If I had to code this in C (not that I know a lot about it),\
    \ I would use an array for factors and then use a nested loop to check if `n /\
    \ k` yields `0` (if so then `k` is evenly divisible by `n`) and then a return\
    \ statement to return `k`. Yes there are different ways to do this, this is just\
    \ one way of solving the problem.\n<|/ c |>\n<| c |>\nI'm just saying that this\
    \ is not the most efficient solution. There are many ways to do this. Some of\
    \ them are more efficient than the others and it might be easier to understand.\n\
    <|/ c |>\n<| c |>\nThe complexity is O(n), but that does not matter for an O(1)\
    \ solution. If someone is looking for an O(1) solution, they will have to either\
    \ implement a trial division approach or use an external library like [this](https://gist.github.com/jeroenooms/5463520).\n\
    <|/ c |>\n<| c |>\nIn fact, I implemented my code exactly like this. I said in\
    \ my answer that the complexity is O(n), but that is not true. Complexity does\
    \ not equal time complexity.\n<|/ c |>\n<| a tags=php |>\n<code>\n<?php", "  for\
    \ ($i = 2; $i * $i <= $n; $i++)\n    if ($n % $i == 0)\n      return $i;\n\n \
    \ return 1;\n}\n", "    if ($n<=1) { return 1; }\n    $largest_divisor = 1;\n\
    \    for($i = 2; $i<=$n; $i++) { \n        if ($n%$i === 0) {\n            $largest_divisor\
    \ = $i;\n        }\n    }\n    return $largest_divisor;\n}\n", "    $n = abs($n);\n\
    \    $max_d = $n;\n    for ($i = 1; $i <= $n; $i++) {\n        if ($n % $i ===\
    \ 0) {\n            $max_d = max($max_d, $i);\n        }\n    }\n    return $max_d;\n\
    }\n\n$max_d = largest_divisor(15);", "    for ($i = 1; $i <= $n; $i++) {\n   \
    \     if ($n % $i == 0) {\n            return $i;\n        }\n    }\n    return\
    \ $n;\n}", "    $num = 0;\n    while ($num < $n) {\n        $num++;\n        if\
    \ ($num % 2 == 0) {\n            $n = $num;\n        }\n    }\n    return $n;\n\
    }\n\n/**\n * Calculates the time between two unix timestamps.\n * @param int $t1\
    \ Unixtimestamp\n * @param int $t2 Unixtimestamp\n * @return int time between\
    \ two unix timestamps.\n * @author R\xE9my Pera\n */", "    $ndivs = 0;\n    for($i\
    \ = 1; $i <= $n; $i++) {\n        if($n % $i == 0) {\n            $ndivs = $i;\n\
    \        }\n    }\n    return $ndivs;\n}", "    $max = $n;\n    $divisor = 1;\n\
    \    while ($n % $divisor) {\n        $divisor++;\n        if ($divisor > $max)\
    \ {\n            $max = $divisor;\n        }\n    }\n    return $max;\n}\n", " \
    \ for ($i = 1; $i <= $n; $i++) {\n    if ($n % $i == 0) {\n      return $i;\n\
    \    }\n  }\n  return $n;\n}\n</code>\nNow we can find all the prime factors of\
    \ a number using the Sieve of Eratosthenes algorithm: we only need to find prime\
    \ numbers less than or equal the number we are searching for divided by the prime\
    \ factors to determine if a number is prime or not. So, we can implement the algorithm\
    \ in PHP like:\n<code>\n$primes = [2,3,5,7,11,13,17,19];", "  return ($n > 1)\
    \ ? largest_divisor($n-1) / $n : 1;\n}", "    $arr = array_fill(0, $n, 1);\n \
    \   return $arr[count($arr) - 1];\n}", "    $result = 1;\n    for ($i = 2; $i\
    \ <= sqrt($n); $i++) {\n        if ($n % $i == 0) {\n            $result = $i;\n\
    \        }\n    }\n    return $result;\n}\n", "    $factors = range(1, $n) \n\
    \    - range(0, $n - 1);\n    sort($factors);\n\n    return end($factors);\n}\n\
    \n$largest_divisor = largest_divisor(15);\necho \"Largest divisor is \" . $largest_divisor;\n\
    </code>\n<|/ a tags=algorithm,php |>\n<| c |>\n`array_search` has a second parameter\
    \ to return the key and not the index\n<|/ c |>\n<| c |>\nI thought it returned\
    \ the index. Thank you.\n<|/ c |>\n<| c |>\n\"The array_search function **searches\
    \ the array for a given value and returns the corresponding key** [...]\" ([from\
    \ php.net](http://php.net/manual/en/function.array-search.php))\n<|/ c |>\n<|\
    \ a |>\n<code>", "    for($i=1;$i<$n;$i++) {\n        if ($n % $i == 0) {\n  \
    \          return $i;\n        }\n    }\n    return $n;\n}\n</code>\n<|/ a |>\n\
    <| c |>\nI think it's good to have a more generic answer to this kind of problem.\
    \ Because if the problem is just a few numbers, it would be nice to have a generic\
    \ algorithm that work for any number or any number set.\n<|/ c |>\n<| a tags=php\
    \ |>\nThe answer above is correct, but I wanted to post my own solution, since\
    \ I think it might help people who just want to know the number of divisors.\n\
    I took my own solution, adapted it to fit my needs. \nThis function will return\
    \ the number of divisors for any given integer number:\n<code>", "    // return\
    \ if n is 0\n    if ($n === 0) { return 0; }\n\n    // find next divisor of n\n\
    \    $r = 1;\n    for ($i = 1; $i <= $n; $i++) {\n        if ($n % $i === 0) {\n\
    \            $r = $i;\n        }\n    }\n    return $r;\n}\n", "    $divs = [$n];\n\
    \    for($div = 2; $div <= $n; $div++) {\n        if ($n % $div == 0) {\n    \
    \        $divs[] = $div;\n        }\n    }\n    return $divs[count($divs) - 1];\n\
    }\n", "    if ($n%2 == 0) {\n        return $n;\n    }\n    \n    $a = 2;\n  \
    \  $b = $n/2;\n    while ($b > 0) {\n        $c = $b;\n        $b = ($n % $b)\
    \ / $a;\n        $a = $c;\n    }\n    \n    return $a;\n}\n ", "    $div = null;\n\
    \    $max_num = 0;\n    $max_div = 0;\n    $div = $n;\n    for($i=0; $i< $n; $i++){\n\
    \        $num = $n / $div;\n        if ($num % 2 === 0 && $num > $max_num) {\n\
    \            $max_num = $num;\n            $max_div = $div;\n        }\n     \
    \   $div = $div / 2;\n    }\n    return $max_div;\n}\n\n$largest = largest_divisor(10);\n\
    echo \"Largest divisor for 10 is $largest\\n\";\n$largest = largest_divisor(100);\n\
    echo \"Largest divisor for 100 is $largest\\n\";\n$largest = largest_divisor(1000);\n\
    echo \"Largest divisor for 1000 is $largest\\n\";\n$largest = largest_divisor(10000);\n\
    echo \"Largest divisor for 10000 is $largest\\n\";\n$largest = largest_divisor(100000);\n\
    echo \"Largest divisor for 100000 is $largest\\n\";\n$largest = largest_divisor(1000000);\n\
    echo \"Largest divisor for 1000000 is $largest\\n\";\n$largest = largest_divisor(10000000);\n\
    echo \"Largest divisor for 10000000 is $largest\\n\";\n$largest = largest_divisor(100000000);\n\
    echo \"Largest divisor for 100000000 is $largest\\n\";", "    $divisors = array(1);\n\
    \    $n2 = $n;\n\n    while ($n2 !== 0) {\n        $quotient = floor($n2 / 2);\n\
    \        $divisors[$quotient] = $quotient;\n        $n2 = $quotient;\n    }\n\n\
    \    $largest = -1;\n    foreach ($divisors as $d) {\n        if ($largest < $d\
    \ || $n === $largest) {\n            $largest = $d;\n        }\n    }\n\n    return\
    \ $largest;\n}", "    $i = 1;\n    $ndiv = 1;\n    while ($i <= $n) {\n      \
    \  $ndiv++;\n        if ($n % $i == 0) {\n            $i++;\n        }\n    }\n\
    \    return $ndiv;\n}\n", "    $d = 1;\n    for($i = 2; $i < $n; $i++)\n     \
    \   if($n % $i == 0) {\n            $d *= $i;\n            while(--$i >= 1)\n\
    \                if(($n % $i) == 0) {\n                    $d *= $i;\n       \
    \             break;\n                }\n        }\n    return $d;\n}\n\n$maxDivisor\
    \ = 0;\nfor($i = 2; $i <= 15; $i++)\n    if($i > (largest_divisor($i) + 1))\n\
    \        $maxDivisor = $i;\n\nprintf(\"Largest divisor of 15 is: %d\\n\", $maxDivisor);",
  "    $counter = 1;\n    $divisor = $n;\n    for($i = 2; $i < $n; $i++) {\n     \
    \   if($n % $i == 0) {\n            $divisor = $i;\n            $counter = 1;\n\
    \        } else {\n            $counter++;\n        }\n        if($counter > $divisor)\
    \ {\n            $divisor = $counter;\n        }\n    }\n    return $divisor;\n\
    }\n</code>\n<|/ a tags=algorithm,php |>\n<| c |>\nWhy `largest_divisor(100)` returns\
    \ `10` not `11`?\n<|/ c |>\n<| a dscore=0 tags=algorithm,php |>\n<code>", "  \
    \  $result = 1;\n    for($i = 1; $i <= $n; $i++) {\n        if($n % $i == 0) {\n\
    \            $result = $i;\n            break;\n        }\n    }\n    return $result;\n\
    }", "    $max = 1;\n    for ($i = 1; $i <= sqrt($n); $i++) {\n        if ($n %\
    \ $i == 0) {\n            $max = $i;\n        }\n    }\n    return $max;\n}",
  "  $d = 2;\n  $i = 0;\n  while (true) {\n    if ($n % $d == 0) {\n      $n = ($n)\
    \ / $d;\n    } else {\n      $i++;\n      $d = $i * 2;\n    }\n    if ($d == $n)\
    \ {\n      break;\n    }\n  }\n  return $d;\n}\n", "    $divisor = 1;\n    $max_divisor\
    \ = 0;\n    do {\n        $divisor++;\n        $max_divisor = $divisor > $max_divisor\
    \ ? $divisor : $max_divisor;\n    } while ($n % $divisor == 0);\n\n    return\
    \ $max_divisor;\n}\n", "  for ($div = 1; $div <= $n/2; $div++) {\n    if ($n %\
    \ $div == 0) {\n      return $div;\n    }\n  }\n  return $n+1;\n}\n", "  $max\
    \ = 10;\n  $max_div = $n;\n  while ($max <= $max_div) {\n    $mod = ($max % $max_div);\n\
    \    if ($mod === 0) {\n      $max = $max_div;\n      break;\n    } else {\n \
    \     $max_div = $max;\n      $max++;\n    }\n  }\n  return $max_div;\n}", " \
    \ $divisor = 1;\n  $divisors = array();\n  for ($i = 1; $i <= $n; ++$i) {\n  \
    \  if (isPrime($i)) {\n      ++$divisor;\n      $divisors[] = $i;\n    }\n  }\n\
    \  sort($divisors);\n  return $divisors[count($divisors) - 1];\n}\n", "    $max_divisor\
    \ = null;\n    $min_divisor = 1;\n\n    while ($min_divisor < $n) {\n        $next_divisor\
    \ = $min_divisor + 1;\n        if ($n % $next_divisor === 0) {\n            $max_divisor\
    \ = $next_divisor;\n        }\n        $min_divisor = $next_divisor;\n    }\n\n\
    \    return $max_divisor;\n}\n", "  // Using binary search to find largest divisor\
    \ < n >= 1 that divides n evenly\n  for($divisor = 1; $divisor * $divisor <= $n;\
    \ $divisor++) {\n    if($n % $divisor == 0) {\n      return $divisor;\n    }\n\
    \  }\n  return $n;\n}", "  global $factors;\n  if ($factors === null) {\n    $factors\
    \ = [];\n    $factors[2] = 1;\n    $factors[3] = 1;\n    $factors[4] = 2;\n  \
    \  $factors[5] = 3;\n    $factors[6] = 5;\n    $factors[7] = 7;\n    $factors[8]\
    \ = 11;\n    $factors[9] = 13;\n    $factors[10] = 17;\n    $factors[11] = 19;\n\
    \    $factors[12] = 29;\n    $factors[13] = 31;\n    $factors[14] = 41;\n    $factors[15]\
    \ = 59;\n  }\n\n  foreach ($factors as $factor => $divisor) {\n    if ($n % $factor\
    \ === 0) {\n      return $divisor;\n    }\n  }\n  return $n;\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nthank you for your answer, the problem is i need to return the\
    \ largest number divisible by all the numbers inside the range of the large number\
    \ and not just the largest number\n<|/ c |>\n<| c |>\nI modified my solution to\
    \ return all of the factors.  That should do what you want.\n<|/ c |>\n<| c |>\n\
    Yes, i was able to understand how you did it but i am still trying to figure out\
    \ how it works, i was reading your solution but i just wanted to make sure i understood\
    \ before i start implementing it\n<|/ c |>\n<| c |>\nMy algorithm just runs the\
    \ factors of the number `n`, which starts from `2` and proceeds to `n/2`.  It\
    \ then checks if any of the factors divides `n` evenly, and if it does, it returns\
    \ it.  Then, it repeats the process until the number is less than `n`.\n<|/ c\
    \ |>\n<| c |>\nI see, so basically the $factors[$n] is just storing the factors\
    \ that divide $n but if $n equals one number that is less than $factors[$n] it\
    \ returns the $factors[$n] as factor\n<|/ c |>\n<| a dscore=0 tags=php |>\n<code>",
  "    $i = 1;\n    $x = 1;\n    $divisor = $n;\n    while ($divisor < $n) {\n   \
    \     if ($n % $divisor == 0) {\n            $x = $divisor;\n        }\n     \
    \   $i++;\n        $divisor *= $i;\n    }\n    return $x;\n}\n", "  $divisor =\
    \ 1;\n  $maxDivisor = 1;\n  for ($i = 2; $i <= sqrt($n); $i++) {\n    if ($n %\
    \ $i == 0) {\n      if ($divisor > $maxDivisor) {\n        $maxDivisor = $divisor;\n\
    \      }\n      $divisor++;\n    }\n  }\n  return $maxDivisor;\n}\n", "    return\
    \ max( (int) ceil( $n / sqrt( $n ) ), 1 );\n}\n</code>\n<|/ a |>\n<| a |>\nI came\
    \ up with a quick way to do this with php, using array_reduce(), and array_filter().\n\
    <code>\n<?php\n\n$numsArr = [3, 12, 17, 21, 24, 28, 31, 32, 33, 36, 37, 38, 39,\
    \ 41, 43, 45, 51, 53, 54, 56, 57, 59, 60, 62, 64, 65, 66, 67, 68, 69, 70, 71,\
    \ 73, 74, 78, 79, 81, 82, 83, 86, 88, 89, 92, 94, 95, 97, 98];\n$maxVal = array_reduce($numsArr,\
    \ function($carry, $item){\n    return max($carry, $item);\n});\n$maxVal = array_filter($numsArr,\
    \ function($item) use ($maxVal){\n    return $item <= $maxVal;\n});\nprint_r($maxVal);",
  "\t$factors = array();\n\tfor ($i = 1; $i <= $n; $i++) {\n\t\tif ($n % $i == 0)\
    \ {\n\t\t\t$factors[] = $i;\n\t\t}\n\t}\n\n\treturn $factors[count($factors) -\
    \ 1] + 1;\n}\n", "    $largest = array($n);\n    for($i = 1; $i <= $n; $i++) {\n\
    \        if($n % $i == 0) {\n            $largest[] = $i;\n        }\n    }\n\
    \    return $largest;\n}\n", "    $divisor = 1;\n    $i = 0;\n    while ($n %\
    \ $divisor) {\n        $i++;\n        $divisor *= 2;\n    }\n    return $divisor;\n\
    }\n", "    $divisors = array();\n    for ($i = 0; $i <= $n; $i++) {\n        $divisors[$i]\
    \ = 0;\n    }\n    $divisors[$n] = 0;\n    for ($i = 1; $i <= $n; $i++) {\n  \
    \      if ($n % $i == 0) {\n            $divisors[$i] = $divisors[$i - 1] + $i;\n\
    \        }\n    }\n    $max = $divisors[0];\n    $max_index = array_search(max($divisors),\
    \ $divisors);\n    return $max;\n}", "    $divisors = range(1, $n);\n    usort($divisors,\
    \ function ($a, $b) {\n        return ($b / $a) - $a;\n    });\n    return array_pop($divisors);\n\
    }\n</code>\n<|/ a tags=php,algorithm,math,mod,modulus dscore=4 |>\n<| c |>\nFor\
    \ a large number like `2^64`, this won't work because PHP_INT_MAX has a range\
    \ of 2147483647 and this would be a big number that exceeds the PHP integer limit.\
    \  Also, this solution doesn't seem to work for odd numbers, such as `3`.\n<|/\
    \ c |>\n<| c |>\nThe maximum unsigned integer is `18446744073709551615` which\
    \ is `2,147,483,647`. The maximum signed integer is `9223372036854775807` which\
    \ is `2,147,483,647`. I believe this can still hold all `2^64` numbers. I'm not\
    \ sure about the odd number issue. Could you explain your result? I think it can\
    \ be fixed by checking if `$b` is even by checking the remainder (`$b%2`).\n<|/\
    \ c |>\n<| c |>\nYou're right, I missed the part about odd numbers.  I edited\
    \ my answer accordingly.\n<|/ c |>\n<| c |>\nI think I like this solution better\
    \ than the accepted answer.  The accepted answer has two problems: (a) this solution\
    \ is inefficient because it's O(log n), and (b) it does a linear search of the\
    \ array.  With this solution, both are O(n), not O(log n).\n<|/ c |>\n<| c |>\n\
    I wrote a solution based on this algorithm and published it on my blog: https://gist.github.com/gregorylee/89b09a86cfd1b0c442b6\n\
    <|/ c |>\n<| a tags=php,algorithm,math,mod,modulus dscore=4 |>\nA simple and fast\
    \ solution would be to calculate the prime factorisation factors of n, sort them\
    \ and take the largest (which should be the smallest number that divides evenly).\
    \ This can be done with the following function:\n<code>", "  $max_divisor = 0;\n\
    \  for ($divisor = 1; $divisor < $n; $divisor++) {\n    if ($n % $divisor ===\
    \ 0) {\n      $max_divisor = $divisor;\n    }\n  }\n  return $max_divisor;\n}",
  "    $n--;\n    while ($n != 1) {\n        $n = $n / 2;\n        $n--;\n    }\n\
    \    return $n + 1;\n}", "    $divisor = 1;\n    $next_divisor = 2;\n\n    $next_divisor\
    \ = $divisor * $next_divisor;\n    while ($next_divisor < $n) {\n        $divisor\
    \ = $next_divisor;\n        $next_divisor = $divisor * $next_divisor;\n    }\n\
    \n    return $divisor;\n}\n", "  $div = 1;\n  for($i = 2; $i <= sqrt($n); $i++)\
    \ {\n    if($n % $i == 0) {\n      $div = $i;\n    }\n  }\n  return $div;\n}",
  "    $highest = 1;\n    $divisor = 2;\n    for($i = 1; $i <= $n; $i++) {\n     \
    \   if($n % $divisor === 0) {\n            $highest = $divisor;\n            $divisor\
    \ = $i;\n        }\n    }\n    return $highest;\n}\n</code>\n<|/ a tags=math,php,algorithm\
    \ |>\n<| a tags=math,php,algorithm |>\nI know this post is old, but for anyone\
    \ else that comes across it, this is the one that worked for me.\n<code>", "\t\
    $x = $n % 2 == 0 ? $n - 1 : $n;\n\t$counter = 0;\n\tfor ($i = 3; $i <= $x; $i\
    \ += 2) {\n\t\t$counter++;\n\t\tif ($n % $i == 0) {\n\t\t\t$counter--;\n\t\t\t\
    break;\n\t\t}\n\t}\n\treturn $x;\n}\n</code>\nOutput:\n<code>\narray(4) {\n  [0]\
    \ => int(4)\n  [1] => int(6)\n  [2] => int(10)\n  [3] => int(15)\n}\n</code>\n\
    <|/ a tags=algorithm,php,division dscore=1 |>\n<| a |>\n<code>\n<?php", "\t$i\
    \ = 0;\n\twhile (pow(2 * $i, $n) > $n) {\n\t\t$i++;\n\t}\n\treturn pow($i, $n);\n\
    }\n", "    $i = $n; $a = $n; $b = 1; $c = 2; $d = $n; $e = 1; $f = 2; $g = 2;\
    \ $h = 1;\n    while ($i > 0) {\n        if ($i % $n == 0) {\n            $i =\
    \ ($i / $n);\n            if ($a > $i) {\n                $a = $i;\n         \
    \   }\n        } elseif ($i % $n == 1) {\n            $i = ($i / $n);\n      \
    \      if ($b > $i) {\n                $b = $i;\n            }\n        } elseif\
    \ ($i % $n == 2) {\n            $i = ($i / $n);\n            if ($c > $i) {\n\
    \                $c = $i;\n            }\n        } elseif ($i % $n == 3) {\n\
    \            $i = ($i / $n);\n            if ($d > $i) {\n                $d =\
    \ $i;\n            }\n        } elseif ($i % $n == 4) {\n            $i = ($i\
    \ / $n);\n            if ($e > $i) {\n                $e = $i;\n            }\n\
    \        } elseif ($i % $n == 5) {\n            $i = ($i / $n);\n            if\
    \ ($f > $i) {\n                $f = $i;\n            }\n        } elseif ($i %\
    \ $n == 6) {\n            $i = ($i / $n);\n            if ($g > $i) {\n      \
    \          $g = $i;\n            }\n        } elseif ($i % $n == 7) {\n      \
    \      $i = ($i / $n);\n            if ($h > $i) {\n                $h = $i;\n\
    \            }\n        }\n    }\n    return array($a, $b, $c, $d, $e, $f, $g,\
    \ $h);\n}", "  if ($n == 0) {\n    return 1;\n  }\n  foreach (range(2, $n + 1)\
    \ as $test) {\n    if ($n % $test == 0) {\n      return $test;\n    }\n  }\n \
    \ return $n;\n}\n", "    $nn = $n;\n    $n = floor($n / 2);\n\n    while($n >\
    \ 0) {\n        if($n % 2 === 0) {\n            $nn = $nn + 1;\n        }\n  \
    \      $n = floor($n / 2);\n    }\n\n    return $nn;\n}\n</code>\n<|/ a tags=php\
    \ |>\n<| c |>\nThe code is not optimized in any way. Just for demonstration purpose.\n\
    <|/ c |>\n<| c |>\nIt is not optimized. But it is easy to understand and easy\
    \ to write and understand. Still your solution is good but i think `while` loop\
    \ and `if` condition should be avoided for a better code. +1\n<|/ c |>\n<| a tags=php\
    \ |>\nHere is my code for that task\n<code>", "    $max = ceil(sqrt($n));\n  \
    \  for($i = 1; $i <= $max; $i++) {\n        $test = $n % $i;\n        if($test\
    \ == 0) {\n            return $i;\n        }\n    }\n    return $max;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThis code is not working. What is $n supposed to be?\n\
    <|/ c |>\n<| c |>\n$n is any positive number, the largest number that divides\
    \ n evenly, smaller than n\n<|/ c |>\n<| c |>\nYes, that would work if the numbers\
    \ were relatively small. However, for a number like 15 the loop would run 4 times,\
    \ and it would return a wrong answer.\n<|/ c |>\n<| c |>\nSorry guys but I realized\
    \ that it was a bad idea to do so using PHP. Using a language like C++ is much\
    \ better. The reason why is because the number 15 is too large.\n<|/ c |>\n<|\
    \ c |>\nApologies for the unclear question. I edited my original question to include\
    \ my code so that it is more clear. Thanks for taking the time to help me!\n<|/\
    \ c |>\n<| a |>\nFor those who use Python:\n<code>\nimport math\n\ndef largest_divisor(n):\n\
    \    max = math.ceil(math.sqrt(n))\n    for x in range(1,max+1):\n        if n\
    \ % x == 0:\n            return x\n\nprint(largest_divisor(15))\n</code>\n<|/\
    \ a dscore=1 tags=algorithm,math |>\n<| a |>\n<code>", "\t$arr = array();\n\t\
    for ($i = 1; $i < $n; $i++) {\n\t\tif ($n % $i == 0) {\n\t\t\t$arr[] = $i;\n\t\
    \t}\n\t}\n\tsort($arr);\n\treturn end($arr);\n}\n", "    $divisor = 1;\n    while(!is_prime($n%$divisor))\
    \ {\n        if($divisor > $n) break; \n        $divisor++;\n    }\n    return\
    \ $divisor;\n}\n", "    if ($n < 2) return 1;\n    $primes = primes_up_to($n);\n\
    \    $ldiv = 0;\n    foreach ($primes as $prime) {\n        if ($n % $prime ==\
    \ 0) {\n            $ldiv = $prime;\n            break;\n        }\n    }\n  \
    \  return $ldiv;\n}\n", "  assert(is_numeric($n));\n  if($n==0) return 0;\n  if($n==1)\
    \ return 1;\n  $max = $n;\n  for($i=2;$i<=ceil($n/2);++$i) {\n    $n = $n/$i;\n\
    \    if($n%2==0) $max=$i;\n  }\n  return $max;\n}\n", "    for($i = 2; $i <= $n;\
    \ $i++)\n    {\n        if($n % $i == 0)\n        {\n            $divisor = $i;\n\
    \            return $divisor;\n        }\n    }\n    return $divisor;\n}", " \
    \ $result = 1;\n  for ($i = 1; $i <= $n; $i++) {\n    if ($n % $i === 0) {\n \
    \     $result = $i;\n      break;\n    }\n  }\n\n  return $result;\n}\n", "  \
    \  if ($n == 0) return 0;\n    if ($n == 1) return 1;\n    $ret = $n;\n    for($i=2;\
    \ $i<$n; $i++) {\n        if($n % $i == 0) $ret = max($ret, $i);\n    }\n    return\
    \ $ret;\n}\n", "    if ($n <= 1) {\n        return 1;\n    }\n    if ($n % 2 ==\
    \ 0) {\n        return 2;\n    }\n    return ($n / largest_divisor($n % 3) + 1);\n\
    }\n"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
