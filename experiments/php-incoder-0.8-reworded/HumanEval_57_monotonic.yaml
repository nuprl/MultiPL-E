name: HumanEval_57_monotonic
language: php
prompt: "<?php\n// Return true is array elements are monotonically increasing or decreasing.\n\
  // >>> monotonic(array(1, 2, 4, 20))\n// true\n// >>> monotonic(array(1, 20, 4,\
  \ 10))\n// false\n// >>> monotonic(array(4, 1, 0, -10))\n// true\nfunction monotonic($l)\
  \ {\n"
tests: "function candidate(...$args) {\n    return monotonic(...$args);\n}\n\nfunction\
  \ test(): void {\n    if (candidate(array(1, 2, 4, 10)) !== true) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(array(1, 2, 4, 20)) !== true) { throw new\
  \ Exception(\"Test failed!\"); }\n    if (candidate(array(1, 20, 4, 10)) !== false)\
  \ { throw new Exception(\"Test failed!\"); }\n    if (candidate(array(4, 1, 0, -10))\
  \ !== true) { throw new Exception(\"Test failed!\"); }\n    if (candidate(array(4,\
  \ 1, 1, 0)) !== true) { throw new Exception(\"Test failed!\"); }\n    if (candidate(array(1,\
  \ 2, 3, 2, 5, 60)) !== false) { throw new Exception(\"Test failed!\"); }\n    if\
  \ (candidate(array(1, 2, 3, 4, 5, 60)) !== true) { throw new Exception(\"Test failed!\"\
  ); }\n    if (candidate(array(9, 9, 9, 9)) !== true) { throw new Exception(\"Test\
  \ failed!\"); }\n}\n\ntest();"
completions: ["  $ln = count($l);\n  for ($i = 1; $i <= $ln; $i++) {\n    for ($j\
    \ = 1; $j <= $ln; $j++) {\n      if ($l[$i] > $l[$j] && $l[$i - 1] < $l[$j - 1])\
    \ {\n        if ($l[$j - 1] < $l[$i - 1]) {\n          return true;\n        }\n\
    \      }\n      else {\n        if ($l[$j - 1] > $l[$i - 1]) {\n          return\
    \ true;\n        }\n      }\n    }\n  }\n  return false;\n}\n", "    return $l[0]\
    \ <= $l[count($l) - 1];\n}\n", "  $l = $l ? $l : array();\n  if (count($l) ==\
    \ 0) {\n    return false;\n  }\n\n  $sorted = array_sort($l);\n  $sorted = array_reverse($sorted);\n\
    \  return $sorted[0] === $sorted[count($sorted) - 1];\n}\n</code>\n<|/ a tags=php\
    \ |>\n<| c |>\nWhile this code may answer the question, providing additional context\
    \ regarding why and/or how this code answers the question improves its long-term\
    \ value.\n<|/ c |>\n<| a dscore=4 tags=php |>\n<code>", "  if ($l == 0) return\
    \ true;\n  $l = array_reverse($l);\n  $s = $l[0] > $l[1] ? 1 : -1;\n  for ($i\
    \ = 0; $i < count($l); ++$i) {\n    $diff =\n        ($l[$i] - $l[$i - 1]) > ($l[$i]\
    \ - $l[($i + 1) % count($l)])\n            ? $s\n            : -$s;\n    if ($diff\
    \ === 0) {\n      return false;\n    }\n  }\n  return true;\n}\n", "  $s = array();\n\
    \  $n = 0;\n  foreach ($l as $k => $v) {\n    if (isset($s[$n])) {\n      if ($s[$n]\
    \ == $v) {\n        $s[$n] = $k;\n        ++$n;\n      } else {\n        return\
    \ false;\n      }\n    }\n    $s[$n] = $v;\n    $n++;\n  }\n  return $n == 2\n\
    \    ? array_keys($s)\n    : false;\n}\n", "    return count($l) === count(array_filter(\n\
    \        $l,\n        function ($item) {\n            return !is_numeric($item);\n\
    \        }\n    ));\n}\n", "    foreach ($l as $k => $v) {\n        if ($v >=\
    \ $l[($k - 1)]) {\n            return false;\n        }\n    }\n    return true;\n\
    }\n", "    if (count($l) !== count($l, COUNT_RECURSIVE)) {\n        throw new\
    \ Exception('Must have same number of array items as parameter');\n    }\n   \
    \ $n = count($l);\n    for ($i = 0; $i < $n; ++$i) {\n        for ($j = 0; $j\
    \ < $n - $i; ++$j) {\n            if ($l[$j] > $l[$j + 1]) {\n               \
    \ return false;\n            }\n        }\n    }\n    return true;\n}\n", "  \
    \  if (!is_array($l))\n        return false;\n    $sort = array_reverse($l);\n\
    \    $x = $l[0];\n    foreach ($sort as $item) {\n        $y = $item;\n      \
    \  if ($x < $y) {\n            return false;\n        }\n        $x = $y;\n  \
    \  }\n    return true;\n}\n", "  $l = array_flip($l);\n  if ($l[0] > $l[1]) {\n\
    \    return true;\n  }\n  foreach (array_slice($l, 1, NULL, TRUE) as $k => $v)\
    \ {\n    if ($v > $l[$k]) {\n      return false;\n    }\n  }\n  return true;\n\
    }\n</code>\n<|/ a tags=arrays,php,array-unique |>\n<| a |>\nI believe array_udiff\
    \ will work just fine for you, it's designed exactly for what you're trying to\
    \ do.\n<|/ a tags=arrays,php,array-unique dscore=1 |>\n<| a tags=arrays,php,array-unique\
    \ |>\nThe array_intersect_assoc function will do the trick nicely here:\n<code>\n\
    $array1 = array(\"red\",\"green\",\"blue\",\"red\");\n$array2 = array(\"green\"\
    ,\"blue\",\"red\",\"white\",\"black\",\"brown\",\"orange\");\n\n$unique1 = array_intersect_assoc($array1,$array2);\n\
    \nvar_dump($unique1);\n\narray(3) {\n  [0]=>\n  string(3) \"red\"\n  [1]=>\n \
    \ string(3) \"green\"\n  [2]=>\n  string(3) \"blue\"\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=1 tags=arrays,php,array-unique |>\nI came across this question\
    \ while searching for \"compare unique values of two arrays in PHP\". While trying\
    \ to find the unique values of an array, I came across this question from another\
    \ post. The question was about the difference between the array_unique and array_diff.\
    \ It was later found that the array_diff was returning the same output for both\
    \ the array_unique.\n<code>\n$a = ['red', 'green', 'blue'];\n$b = ['green', 'blue',\
    \ 'red'];\n$c = array_diff($a, $b);\nprint_r($c);\n</code>\nThis will return:\n\
    <code>\nArray ( [0] => green )\n</code>\nThe array_diff method returns an array\
    \ with elements from the first array that are not present in the second array.\
    \ This means if you have a small array (like 2 or 3 elements), array_diff will\
    \ return the same output as the array_unique.\nBut if you have a large array,\
    \ it will take a long time to calculate the difference. So the array_diff method\
    \ is definitely the better choice for this problem.\nBut if you need the unique\
    \ values only, there is another method that is much faster than array_diff, and\
    \ that is to use array_intersect:\n<code>\n$a = ['red', 'green', 'blue'];\n$b\
    \ = ['green', 'blue', 'red'];\n$c = array_intersect($a, $b);\nprint_r($c);\n</code>\n\
    This will return:\n<code>\nArray ", "\t$l = array_reverse($l);\n\t$s = array_slice($l,\
    \ 1, null, true);\n\tif ($l[0] > $s[0]) {\n\t\treturn false;\n\t} elseif ($l[0]\
    \ < $s[0]) {\n\t\treturn true;\n\t}\n\tforeach ($l as $key => $val) {\n\t\tif\
    \ ($val > $s[0]) {\n\t\t\treturn false;\n\t\t} elseif ($val < $s[0]) {\n\t\t\t\
    return true;\n\t\t}\n\t}\n\treturn false;\n}\n", "    if (count($l) === 0) {\n\
    \        return false;\n    }\n    sort($l);\n    return $l[0] === array_shift($l);\n\
    }\n\n/**\n * Returns the number of elements in the given array\n *\n * @param\
    \  array\n * @return int The number of elements in the given array\n */", "  \
    \  $mono = false;\n    foreach ($l as $k => $v) {\n        if (!isset($l[$k +\
    \ 1]) || $l[$k + 1] < $v)\n            $mono = true;\n    }\n    return $mono;\n\
    }", "\tforeach ($l as $k => $v) {\n\t\tif ($v != $l[$k + 1]) {\n\t\t\treturn true;\n\
    \t\t}\n\t}\n\treturn false;\n}\n", "    $l = array_filter($l);\n    if (!count($l))\
    \ {\n        return false;\n    }\n    $l = array_reverse($l);\n    $last = array_shift($l);\n\
    \    sort($l);\n    return $last <= $l;\n}", "  // Return true if the array is\
    \ monotonically increasing or decreasing.\n  // That is, return true is all elements\
    \ are either increasing or decreasing.\n  $decreasing_sorted = array_map(function\
    \ ($a) {\n    return $a[0] < $a[1];\n  }, $l);\n  $increasing_sorted = array_map(function\
    \ ($a) {\n    return $a[0] > $a[1];\n  }, $l);\n  $return = array_reduce($increasing_sorted,\
    \ function ($return, $b) {\n    return $return || $b;\n  }) || array_reduce($decreasing_sorted,\
    \ function ($return, $b) {\n    return $return || $b;\n  });\n  return $return;\n\
    }\n", "  $v = array();\n  $j = 0;\n  $k = 0;\n  $n = count($l);\n  $i = 0;\n \
    \ // find min\n  while (++$i < $n) {\n    $v = $l[$i] === $l[$j] ? 0 : 1;\n  \
    \  $j = ($j + 1) % $n;\n  }\n  // find max\n  while (++$i < $n) {\n    $v = $v\
    \ == $l[$i] ? 0 : 1;\n    $k = ($k + 1) % $n;\n  }\n  return $v == 0 ? $k : $i;\n\
    }\n", "\t$l = array_reverse($l);\n\t$min = reset($l);\n\tforeach ($l as $v) {\n\
    \t\tif ($v < $min) return false;\n\t\t$min = $v;\n\t}\n\treturn true;\n}\n", " \
    \   if ($l[0] > $l[1]) {\n        return true;\n    }\n\n    if ($l[0] < $l[1])\
    \ {\n        return false;\n    }\n\n    if ($l[0] < $l[2]) {\n        return\
    \ true;\n    }\n\n    if ($l[2] < $l[1]) {\n        return true;\n    }\n\n  \
    \  if ($l[1] < $l[0]) {\n        return false;\n    }\n\n    if ($l[0] < $l[2])\
    \ {\n        return true;\n    }\n\n    if ($l[2] < $l[1]) {\n        return false;\n\
    \    }\n\n    if ($l[1] < $l[0]) {\n        return true;\n    }\n\n    if ($l[1]\
    \ < $l[2]) {\n        return false;\n    }\n\n    return false;\n}\n", "    $s\
    \ = array_shift($l);\n    $result = true;\n    foreach ($l as $e) {\n        if\
    \ ($e <= $s) {\n            return false;\n        }\n        if ($e > $s) {\n\
    \            return true;\n        }\n        $s = $e;\n    }\n    return true;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThat's a good idea, but this would require\
    \ sorting an array once to calculate the first value, and then again to find the\
    \ second (and last) value. So it's not a pure solution, it's just one way to look\
    \ at it.\n<|/ c |>\n<| c |>\nThanks for pointing out... I fixed the bug this time\
    \ :)\n<|/ c |>\n<| a |>\nThe algorithm is quite simple. You just need to start\
    \ from the second element and see if the current value is the bigger one or the\
    \ smaller one. If the current value is bigger one, then it is the first one (it\
    \ is the smallest in the list). If the current value is smaller than one, then\
    \ it's not a first value but the last one (it's the biggest in the list).\nHere\
    \ is an example:\n<code>\npublic function isFirstAndLastInList($numbers) {\n \
    \   if (empty($numbers)) {\n        return false;\n    }\n\n    $firstNumber =\
    \ array_shift($numbers);\n    $lastNumber = end($numbers);\n\n    return ($firstNumber\
    \ == $lastNumber);\n}\n</code>\n<|/ a dscore=0 tags=php,arrays,sorting |>\n<|\
    \ c |>\nThis isn't pure for me, it is sorting an array once to find the first\
    \ value, and then again to find the second (and last) value. So it's not a pure\
    \ solution, it's just one way to look at it.\n<|/ c |>\n<| c |>\nYes, sorting\
    \ once is probably not so good idea. But if you have to, then it's pretty simple\
    \ algorithm. The time complexity is O(n) for sorting and O(1) for finding first\
    \ and last.\n<|/ c |>\n<| c |>\nYes, you can write this in pure PHP but it will\
    \ take O(n log n), which is way worse than my solution :-).\n<|/ c |>\n<| c |>\n\
    I wonder if we should use sort at all. Do you think the first element and the\
    \ last element in the array are always the same? If that is the case then I can\
    \ see a better solution that will take O(n). And if they are never going to be\
    \ the same, then sorting will take O(n) anyway. If sorting will take O(n) then\
    \ my solution will take O(n log n)\n<|/ c |>\n<| c |>\nSorting is O(nlogn), but\
    \ my solution takes O(n", "    $n = count($l);\n    if ($n <= 1) {\n        return\
    \ true;\n    }\n    for ($i = 1; $i <= $n; ++$i) {\n        if (!isset($l[$i -\
    \ 1]) || $l[$i - 1] < $l[$i]) {\n            return false;\n        }\n    }\n\
    \    return true;\n}\n", "    $i = 0;\n    $j = 1;\n    $l = array_reverse($l);\n\
    \    foreach ($l as $k => $v) {\n        if (($v - $l[$i]) <= 0) {\n         \
    \   $i = $j;\n            $j = $k + 1;\n        } else {\n            break;\n\
    \        }\n    }\n    return $j == $k;\n}\n", "    $s = array_slice($l, count($l)\
    \ / 2, -count($l) / 2);\n    $s_next = array_slice($l, 0, count($l) / 2);\n  \
    \  if ($s === $s_next) {\n        return true;\n    }\n\n    // All the elements\
    \ are increasing, so no further check required.\n    return false;\n}\n", "  $i\
    \ = 0;\n  foreach ($l as $v) {\n    if ($v > $l[$i]) {\n      $i++;\n    }\n \
    \   if ($i < count($l) && $v < $l[$i]) {\n      return false;\n    }\n  }\n  return\
    \ true;\n}", "  return count($l) === count(array_reverse($l)) &&\n         $l[0]\
    \ === array_shift($l) && $l[count($l) - 1] === array_pop($l);\n}\n", "  // return\
    \ true if all array elements are monotonically increasing or decreasing.\n  if\
    \ (!$l || !is_array($l)) {\n    return false;\n  }\n  $l = array_reverse($l);\n\
    \  $l[0] = array_pop($l);\n  return $l[0] > array_shift($l);\n}\n\n", "    return\
    \ count($l) == 1 || $l[0] < $l[count($l)-1] ? true : false;\n}", "\t$m = array();\n\
    \tfor ($i=0, $n = count($l); $i < $n; ++$i) {\n\t\t$m[$l[$i]] = isset($m[$l[$i]])\
    \ ? $m[$l[$i]] + 1 : 1;\n\t\tif ($m[$l[$i]] > 1) return false;\n\t}\n\treturn\
    \ true;\n}\n", "    foreach ($l as $i => $v) {\n        if ($v < 0) {\n      \
    \      $l[$i] = -$v;\n            $l[$i+1] = $v; // swap elements\n        } else\
    \ if ($v > 0) {\n            $l[$i] = $v;\n        }\n    }\n    return count($l)\
    \ > 1;\n}\n", "\tsort($l);\n\treturn $l[0] > $l[count($l)-1];\n}\n", "  $lo =\
    \ min($l);\n  $hi = max($l);\n\n  return $hi - $lo === 0 || $hi - $lo > 1;\n}\n\
    \n/**\n * @returns float The minimum value of the passed list of numbers.\n */",
  "    $l = array_reverse($l);\n    $l[] = $l[0];\n    return ($l[0] > $l[count($l)-1]);\n\
    }\n</code>\n<|/ a dscore=1 tags=algorithm,php,arrays |>\n<| c |>\nThanks so much\
    \ for your response! I'm having a little trouble trying to implement this. What\
    \ would this look like in PHP?\n<|/ c |>\n<| c |>\n- This works great, thanks!\
    \ I've edited your answer to include how to use it - I didn't realize you could\
    \ use it as a function.\n<|/ c |>\n<| c |>\n- Hmm, now it's returning an incorrect\
    \ result when one of the values is negative. For example, `monotonic([1, 2, 4,\
    \ -1])` is returning `true`.\n<|/ c |>\n<| c |>\nGood catch. I've fixed my answer.\
    \ It had a bug.\n<|/ c |>\n<| a dscore=1 |>\nThis should do the trick:\n<code>",
  "    $l = array_reverse($l);\n    foreach ($l as $k => $v) {\n        if ($v < $l[$k\
    \ - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\
    </code>\n<|/ a |>\n<| c |>\nI believe this can be used for any array, not just\
    \ for associative arrays.\n<|/ c |>\n<| a dscore=5 tags=php,arrays,sorting |>\n\
    The easiest and shortest solution is to call asort($arr) which sorts the array\
    \ (ascending), and then use array_reverse() to reverse the array (descending):\n\
    <code>\n$arr = [1,3,8,2,6,5,10];\n\nasort($arr);\n$arr = array_reverse($arr);\n\
    </code>\n<|/ a |>\n<| c |>\nThis doesn't answer the question - OP wants to sort\
    \ descending (largest to smallest)\n<|/ c |>\n<| c |>\nAs the array is descending\
    \ as soon as the function returns it can be reversed (descending). Unless you\
    \ mean sorting ascending (smallest to largest)\n<|/ c |>\n<| a tags=php,arrays,sorting\
    \ |>\nA quick and simple solution that works well with PHP >= 5.4 and < 5.5 that\
    \ also doesn't require an extra sorting step:\n<code>", "  $keys = array_keys($l);\n\
    \  $s = array_sum($l);\n  $isMonotonic = TRUE;\n  $m = 0;\n  foreach ($keys as\
    \ $k) {\n    $delta = $l[$k] - $m;\n    if ($delta > 0) $isMonotonic = FALSE;\n\
    \    if ($delta < 0) $isMonotonic = TRUE;\n    $m = $l[$k];\n  }\n  return $isMonotonic;\n\
    }\n", "    $i = count($l) - 1;\n    while ($i >= 0) {\n        if ($l[$i] <= $l[$i\
    \ - 1]) {\n            return false;\n        }\n        $i -= 1;\n    }\n   \
    \ return true;\n}\n</code>\n<|/ a dscore=4 tags=php,arrays |>\n<| c |>\nIt does\
    \ not work correctly with floats (returns true instead of false). Use array_diff\
    \ and array_merge instead\n<|/ c |>\n<| c |>\nThis is not very reliable.  If you\
    \ have two arrays of the same length but one is ordered and one is not, this function\
    \ will return false.  Consider array(1,3,5,7) and array(1,7,3,5), both have length\
    \ 3 but the one with 7 first is not ordered and the other is ordered.  For this\
    \ reason, it is better to use array_diff and array_merge.\n<|/ c |>\n<| c |>\n\
    I did a quick test and found that this does not work correctly with floats: https://3v4l.org/nEk0U\n\
    <|/ c |>\n<| a |>\nMy take on that:\n<code>\n$arr1 = array(10,20,30,40,50);\n\
    $arr2 = array(1,3,5,7,9,11,13,15,17,19);\n$arr3 = array(10,20,30,40,50);\n$arr4\
    \ = array(1,3,5,7,9,11,13,15,17,19);\n$arr5 = array(10,20,30,40,50);\n$arr6 =\
    \ array(1,3,5,7,9,11,13,15,17,19);\n$arr7 = array(10,20,30,40,50);\n$arr8 = array(1,3,5,7,9,11,13,15,17,19);\n\
    $arr9 = array(10,20,30,40,50);\n$arr10 = array(1,3,5,7,9,11,13,15,17,19);\n$arr11\
    \ = array(10,20,30,40,50);\n$arr12 = array(1,3,5,7,9,11,13,15,17,19);\n$arr13\
    \ = array(10,20,30,40,50);\n$arr14 = array(1,3,5,7,9,11,13,15,17,19);\n$arr15\
    \ = array(10,20,30,40,50);\n$arr16 = array(1,3,5,7,9,11,13,15,17,19);\n$arr17\
    \ = array(10,20,30,40,50);\n$arr18 = array(1,3,5,7,9,11,13,15,17,19);\n$arr19\
    \ = array(10,20,30,40,50);\n\n$arrs = array(\n    $arr1,\n    $arr2,\n    $arr3,\n\
    \    $arr4,\n    $arr5,\n    $arr6,\n    $arr7,\n    $arr8,\n    $arr9,\n    $",
  "    $v = array();\n    foreach ($l as $k => $e) {\n        if (isset($v[$e])) {\n\
    \            $v[$e] = $k;\n        } else {\n            $v[$e] = $e;\n      \
    \  }\n    }\n    $n = count($l);\n    if ($n == 1) {\n        return $v[$l[0]]\
    \ > $v[$l[0] + 1];\n    }\n    for ($i = 0; $i < $n; ++$i) {\n        $v0 = $v[$l[$i]];\n\
    \        $v1 = $v[$l[$i + 1]];\n        if ($v0 > $v1) {\n            return false;\n\
    \        } else if ($v0 < $v1) {\n            $v[$l[$i]] = $v1;\n            $v[$l[$i\
    \ + 1]] = $v0;\n            $v1 = $v0;\n        } else {\n            $v[$l[$i\
    \ + 1]] = $v1;\n            $v[$l[$i]] = $v0;\n            $v0 = $v1;\n      \
    \  }\n    }\n    return true;\n}\n\n/**\n * Converts a date in milliseconds to\
    \ a date string in the client's timezone. Accepts\n * the same parameters as the\
    \ PHP date() function, and returns the formatted string.\n * If no timezone is\
    \ provided, the function will use the client's timezone.\n *\n * Usage:\n * {{\
    \ date_ms(123456789) }}\n *\n * @param  integer $timestamp The date in milliseconds\n\
    \ * @param  string $timezone The desired timezone (e.g. America/New_York)\n *\
    \ @param  string $locale The desired locale (e.g. en_US)\n * @return string\n\
    \ */", "    return count($l) > 1 && is_array($l) && array_reduce($l, function\
    \ ($c, $a) { return $c && is_array($a) ? monotonic($a) : false; }) === true;\n\
    }", "  $count = count($l);\n  if ($count === 0) {\n    return true;\n  }\n  for\
    \ ($i = 1; $i < $count; ++$i) {\n    if ($l[$i - 1] + 1 != $l[$i]) {\n      return\
    \ false;\n    }\n  }\n  return true;\n}\n", "    $ln = count($l);\n    for ($i=0;\
    \ $i<$ln; $i++) {\n        $test = $l[$i];\n        sort($l);\n        if ($l[0]\
    \ === $test) {\n            $ln = count($l);\n        }\n    }\n    return $ln\
    \ === $ln;\n}\n", "  foreach ($l as $k => $v) {\n    if ($v != $l[$k - 1]) {\n\
    \      return false;\n    }\n  }\n  return true;\n}\n", "  if (!is_array($l))\
    \ {\n    return false;\n  }\n\n  for ($i = 0; $i < count($l); $i++) {\n    for\
    \ ($j = count($l) - 1; $j > $i; $j--) {\n      if ($l[$i] < $l[$j]) {\n      \
    \  return true;\n      }\n      if ($l[$i] > $l[$j]) {\n        return false;\n\
    \      }\n    }\n  }\n\n  return false;\n}\n\n/**\n * Returns array's max or min\
    \ value\n * @param mixed $l\n * @param string|null $k\n * @param boolean|null\
    \ $strict If true, returns strict min if $l's min\n *                        \
    \     is less than $k, else returns strict max if\n *                        \
    \     $l's min is greater than $k.\n */", "\tif (!$l)\n\t\treturn true;\n\tforeach\
    \ ($l as $key => $el) {\n\t\tif (!is_numeric($el))\n\t\t\t$l[$key] = gettype($el);\n\
    \t\tif ($el > $l[$key])\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n\n/**\n\
    \ * Sort an array of array\n * @param\tarray\t$l\n * @param\tint\t$nkeys\n * @return\t\
    array\n */", "  $monotonic = false;\n\n  $l = array_filter(\n    $l,\n    function\
    \ ($value) {\n      return $value !== null;\n    },\n    ARRAY_FILTER_USE_BOTH\n\
    \  );\n\n  // Sort by value and keep only the first element that differs\n  if\
    \ ($l && count($l)) {\n    $last = array_pop($l);\n    foreach ($l as $key =>\
    \ $value) {\n      if ($value < $last) {\n        $l[$key] = $last;\n      }\n\
    \    }\n    $monotonic = count($l) == 1;\n  }\n\n  return $monotonic;\n}\n", " \
    \   if (count($l) === 0) {\n        return true;\n    }\n    sort($l);\n    return\
    \ $l[0] > $l[count($l) - 1];\n}\n", "  return $l[0] === $l[1]\n         || $l[0]\
    \ === $l[2]\n         || $l[1] === $l[2]\n         || ($l[0] == $l[2]\n      \
    \       && $l[1] > $l[2]);\n}\n", "  $v = array_intersect_key($l, array_flip($l));\n\
    \  return $v === $l;\n}\n\n/**\n * Given a two-dimensional array or array, determines\
    \ if the array is monotonically\n * increasing or decreasing. If the array is\
    \ monotonic, false is returned.\n * If it is not monotonic, the array is immediately\
    \ reversed.\n *\n * Note: the array must be non-associative and have at least\
    \ two elements.\n *\n * @param array $a the array to test\n * @return bool true\
    \ if the array is monotonically increasing or decreasing\n */", "  if (count($l)\
    \ === 0) {\n    return false;\n  }\n  $first = array_shift($l);\n  return is_numeric($first)\
    \ && is_numeric(array_shift($l)) && $first <= array_shift($l);\n}\n", "    $keys\
    \ = array_keys($l);\n    $max = array_pop($keys);\n    $min = array_pop($keys);\n\
    \    foreach ($keys as $k => $v) {\n        if ($v <= $max) {\n            $min\
    \ = $k;\n        } else if ($v >= $min) {\n            $max = $k;\n        }\n\
    \    }\n    return ($min <= $max);\n}\n", "    foreach ($l as $element) {\n  \
    \      $l2 = array_reverse($l);\n        if ($element < array_shift($l2)) {\n\
    \            return false;\n        }\n    }\n    return true;\n}\n", "  if ($l[0]\
    \ < $l[1]) {\n    return $l[0] < $l[2] && $l[0] < $l[3];\n  }\n  if ($l[1] < $l[2])\
    \ {\n    return $l[1] < $l[3] && $l[1] < $l[0];\n  }\n  return $l[2] < $l[3];\n\
    }\n</code>\n<|/ a dscore=3 |>\n<| c |>\nWho says that arrays aren't monotonic?\
    \ See https://3v4l.org/m4S6q\n<|/ c |>\n<| c |>\nThis doesn't even work for monotonic\
    \ increasing arrays. `monotonic_increasing_array([1, 2, 3, 4])` is `[1,2,3,4]`\
    \ and `monotonic_increasing_array([3, 1, 4, 3])` is `[4,1,3,4]`\n<|/ c |>\n<|\
    \ a dscore=1 |>\nHere is a solution that will work for any type of monotonic array.\
    \ It uses two stacks: \n\nThe first stack is used to store previous values.\n\
    The second stack is used to store current values.\n\nIf the current value is smaller\
    \ than the previous value, the array is increasing. Else, the array is decreasing.\n\
    <code>", "    $l = $l ? $l : array();\n    sort($l);\n    $last = end($l);\n \
    \   return $l[0] >= $last || $l[1] < $last ? 1 : 0;\n}\n</code>\nThe function\
    \ below will create a unique ID based on the values provided in the input array.\
    \ Values are assigned a unique id based on the length of the input array. Allowed\
    \ values are: \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\".\n<code>",
  "    $l = $l ? $l : array();\n    $l = array_reverse($l);\n    return $l[0] > $l[-1];\n\
    }\n\n/**\n * Test for numeric elements in the array.\n *\n * @param   mixed  $value\n\
    \ * @return  bool\n */", "    // Return true if the array contains only monotonically\
    \ increasing or\n    // decreasing elements.\n    $m = false;\n    foreach ($l\
    \ as $elem) {\n        if ($m === true) {\n            return false;\n       \
    \ }\n        $m = ($elem < $elem);\n    }\n    return true;\n}\n", "    if (count($l)\
    \ === 0) {\n        return true;\n    }\n    return $l[0] >= $l[count($l) - 1];\n\
    }\n\n/**\n * Returns the minimum of an array of numbers.\n *\n * This is equivalent\
    \ to the PHP built-in function `min`, except that the\n * elements of the array\
    \ `must` be sorted in ascending order (see\n * [[ArrayAccess::sortByDescending()]]).\n\
    \ *\n * @param array $array the array to be filtered\n * @param string $key the\
    \ name of the array element that defines an order\n * @param bool $asArray if\
    \ true, the returned value will be an array too.\n * If false, the returned value\
    \ will be the value of the first element that\n * passes the given test.\n * @return\
    \ mixed the filtered minimum, or false if an empty array is passed or\n * there\
    \ is no such element.\n */", "    if ($l[0] < $l[1]) {\n        return true;\n\
    \    } elseif ($l[0] > $l[1]) {\n        return false;\n    }\n    if ($l[2] <\
    \ $l[3]) {\n        return true;\n    } elseif ($l[2] > $l[3]) {\n        return\
    \ false;\n    }\n    return monotonic($l[2]) || monotonic($l[3]);\n}", "  if (empty($l))\n\
    \    return false;\n\n  if ($l[0] < $l[1])\n    return true;\n\n  return false;\n\
    }", "    return ($l[0] <= $l[$l->length - 1]);\n}", "\tif ($l[0] > $l[1]) {\n\t\
    \t$l[0] = -1;\n\t\t$l[1] = -2;\n\t}\n\tif ($l[2] > $l[3]) {\n\t\t$l[2] = -1;\n\
    \t\t$l[3] = -2;\n\t}\n\tif ($l[1] > $l[3]) {\n\t\treturn false;\n\t}\n\tif ($l[1]\
    \ == $l[2]) {\n\t\treturn true;\n\t}\n\treturn ($l[3] - $l[1]) > 0;\n}\n", " \
    \   $l = array_reverse(\n        array_reverse(\n            array_reverse($l)\n\
    \        )\n    );\n    for ($i = 2; $i < count($l); $i++) {\n        if ($l[$i]\
    \ - $l[$i - 1] < 1e-12) {\n            return false;\n        }\n    }\n    return\
    \ true;\n}\n", "  $m = array();\n  foreach ($l as $key => $value) {\n    if (isset($m[$value]))\
    \ {\n      $m[$value] = $key;\n    } else {\n      $m[$value] = $key;\n    }\n\
    \  }\n  return array_keys($m) === array_values($m);\n}\n", "    return $l[0] <=\
    \ $l[1];\n}\n\nclass TimeTravelException extends Exception {}\n", "  $l = $l ?\
    \ $l : array();\n  sort($l);\n  return current($l) == end($l);\n}\n", "    return\
    \ $l[0] <= $l[count($l)-1];\n}\n", "\t$l = array_reverse($l);\n\t$d = count($l)\
    \ - 1;\n\tfor ($i = 0; $i <= $d; ++$i) {\n\t\tif ($l[$i] <= $l[$i+1]) {\n\t\t\t\
    if ($l[$i] <= $l[$i-1]) {\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn\
    \ true;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n", "    return $l[0] < $l[1]\
    \ && $l[1] < $l[2] && $l[2] < $l[3] && $l[3] < $l[4];\n}\n", "    $len = count($l);\n\
    \    for ($i = 0; $i < $len; ++$i) {\n        if ($l[$i] <= $l[($i + 1)]) {\n\
    \            return false;\n        }\n    }\n    return true;\n}\n", "\tif ($l[0]\
    \ === $l[1]) {\n\t\treturn false;\n\t}\n\tfor ($i = 1; $i < count($l); $i++) {\n\
    \t\tif ($l[$i] < $l[$i - 1]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n\
    }\n", "    if (!is_array($l)) return false;\n\n    $i = count($l);\n    $s = $l[0]\
    \ > $l[$i-1] ? 1 : -1;\n    for ($j = 1; $j < $i; ++$j) {\n        if ($l[$j]\
    \ > $l[$j-1] + $s) return false;\n        if ($l[$j] < $l[$j-1] - $s) return false;\n\
    \    }\n    return true;\n}\n", "  // Sorts the list for comparison\n  sort($l);\n\
    \  foreach ($l as $i => $n) {\n    if ($l[$i] == $n - 1) {\n      return true;\n\
    \    }\n    if ($l[$i] > $n - 1) {\n      return false;\n    }\n  }\n}\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\n+1 for the comment. I'm aware that your answer does\
    \ solve the problem. But I suspect that the solution is more elegant than using\
    \ multiple loops. That's why I was asking the question in the first place.\n<|/\
    \ c |>\n<| c |>\nSorry, I don't understand your comment. How does this not answer\
    \ your question? It has two loops, but each has two lines of code. And since it's\
    \ O(n), the efficiency is pretty much the same as looping through each array element.\
    \ The only difference between this and your solution is that your solution has\
    \ `i < $n` while the solution I gave has `i < $l[$i]`, which is more elegant.\n\
    <|/ c |>\n<| c |>\nSorry for the delay. I think I understand now.  You are correct\
    \ in that the solution you provided is more elegant and should be preferred over\
    \ mine.\n<|/ c |>\n<| a dscore=5 |>\nThis is a little complicated and doesn't\
    \ exactly answer the original question, but I thought it might be useful to post\
    \ anyway:\n<code>\n$array = array(1, 2, 4, 10);\n$array = array_flip($array);\n\
    $array = array_diff_key($array, array_fill_keys($array, null));\nvar_dump(array_keys($array));\n\
    </code>\n<|/ a tags=php,sorting,arrays |>\n<| c |>\nThis is a very elegant solution.\
    \  I would just add that it will only work if the array is monotonic and does\
    \ not have any duplicate values.\n<|/ c |>\n<| c |>\nThis is great, except that\
    \ it only works for monotonic arrays. When you try something like `[1, 2, 3, 3,\
    \ 4]`, it won't work.\n<|/ c |>\n<| c |>\nGood catch, I've corrected the example\
    \ to include 3 values which can be non-monotonic.\n<|/ c |>\n<| c |>\n, This works\
    \ for me in PHP.  I just tried it on PHP 5.2.17 and PHP 5.3.10.  What version\
    \ of PHP are you testing on?\n<|/ c |>\n<| c |>\nI believe you meant `array_flip($array)`,\
    \ not `array_diff(array_flip($array), array_fill_keys(array_flip($array), null))`. ",
  "  if (!is_array($l)) {\n    return false;\n  }\n  if (!array_filter($l, 'is_int'))\
    \ {\n    return false;\n  }\n  // Avoid sorting identical elements twice\n  $l\
    \ = array_unique(array_filter($l, 'strcmp'));\n  // Sort by key\n  array_multisort($l);\n\
    \  return count($l) > 1;\n}\n\n/**\n * Returns true if the provided value is a\
    \ valid email address.\n *\n * @param string $email The email address.\n * @return\
    \ boolean True if the provided value is a valid email address.\n */", "  $sorted\
    \ = array();\n  $i = 1;\n  while (count($l) > 0) {\n    $l = array_merge($l, $sorted);\n\
    \    if ($l[0] > $sorted[0]) {\n      $sorted = $l;\n    }\n    else {\n     \
    \ $i++;\n    }\n  }\n  return $i > 1;\n}\n", "    if (count($l) !== count(array_unique($l)))\
    \ {\n        return true;\n    }\n\n    $sorted = $l;\n    natsort($sorted);\n\
    \    $l = $sorted;\n    return $l[0] < $l[count($l) - 1];\n}\n\n/**\n * Returns\
    \ first element from multidimensional array.\n *\n * @return mixed\n */", "\t\
    $s = array_slice($l, 0, -1);\n\t$e = array_slice($l, -1);\n\t$e[0]++;\n\treturn\
    \ array_sum($e) <= array_sum($s);\n}", "    if ($l == $l) {\n        return true;\n\
    \    }\n    if ($l == array_unique($l)) {\n        return true;\n    }\n    $sorted\
    \ = sort($l);\n    foreach ($sorted as $e) {\n        if ($e == $sorted[0]) {\n\
    \            continue;\n        }\n        return false;\n    }\n    return true;\n\
    }\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI love that answer. Just what I needed.\
    \ Thanks!\n<|/ c |>\n<| a dscore=4 |>\nAs a complement to's answer (which doesn't\
    \ work for all cases, for example when one of the arrays has repeated values,\
    \ or when one of the arrays is empty or has only one value), this solution handles\
    \ all cases:\n<code>", "  if ($l == NULL) return FALSE;\n  for ($i = 0; $i < count($l);\
    \ $i++) if ($l[$i] > $l[$i + 1]) return FALSE;\n  return TRUE;\n}\n\n\n/**\n *\
    \ Makes sure that all the elements of an array are unique.\n *\n * @return array\
    \ The new array.\n */", "\tif (count($l) === 0) return false;\n\t$last = array_shift($l);\n\
    \tsort($l);\n\treturn $l[0] === $last;\n}\n", "    if (!is_array($l)) {\n    \
    \    return false;\n    }\n\n    $sorted = array_reverse($l);\n    $l2 = $l;\n\
    \    $isSorted = true;\n    foreach ($sorted as $key => $item) {\n        if (!isset($l2[$key])\
    \ || $item != $l2[$key]) {\n            $isSorted = false;\n            break;\n\
    \        }\n    }\n\n    return $isSorted;\n}\n</code>\n<|/ a |>\n<| a |>\nThis\
    \ is a variant of the code suggested by Kane in a comment\n<code>\n$numbers =\
    \ array(2, 4, 6, 8, 10, 12, 14, 16, 18);\n\n$sortedNumbers = array_reverse($numbers);\n\
    \nforeach ($sortedNumbers as $key => $value) {\n    echo $key . \" \";\n}\n</code>\n\
    <|/ a dscore=3 tags=sorting,php,arrays |>\n<| a tags=sorting,php,arrays dscore=3\
    \ |>\n<code>\n$numbers = array(2, 4, 6, 8, 10, 12, 14, 16, 18);\n\n$sortedNumbers\
    \ = array_reverse($numbers);\n\nforeach ($sortedNumbers as $key => $value) {\n\
    \    echo $key . \" \";\n}\n</code>\n<|/ a |>\n<| c |>\nI guess you meant `$numbers\
    \ = array(2, 8, 10, 12, 14, 16, 18, 4);` ?\n<|/ c |>\n<| c |>\nYes, I did mean\
    \ that.\n<|/ c |>\n<| a dscore=2 |>\n<code>\n$numbers = array(2, 4, 6, 8, 10,\
    \ 12, 14, 16, 18);\n$sorted = array_reverse($numbers);\nforeach ($sorted as $key\
    \ => $value) {\n   echo $key . \" \";\n}\n</code>\n<|/ a tags=sorting,php,arrays\
    \ |>\n<| a dscore=2 |>\nThis code sort array from highest to lowest and save it\
    \ in variable $sortedNumbers.\n<code>\n$numbers = array(2, 4, 6, 8, 10, 12, 14,\
    \ 16, 18);\n$sortedNumbers = array();\n\nforeach ($numbers as $key => $value)\
    \ {\n    $sortedNumbers[] = $value;\n}\n\narray_reverse($sortedNumbers);\n\nforeach\
    \ ($sortedNumbers as $key => $value) {\n    echo $key . \" \";\n}\n</code>\n<|/\
    \ a tags=sorting,php,arrays |>\n<| c |>\nWhy not `array_push` instead of `array_push($sortedNumbers,\
    \ $value);`? No need to declare the `$sortedNumbers` array again.\n<|/ c |>\n\
    <| c |>\nThanks for your attention, you are right :)\n<|/ ", "    if (empty($l))\
    \ {\n        return false;\n    }\n\n    $last = array_shift($l);\n    if ($last\
    \ !== $last) {\n        return false;\n    }\n\n    $last_keys = array_keys($l,\
    \ $last);\n\n    return array_keys($l) === $last_keys;\n}\n", "    $l = $l ? $l\
    \ : array();\n    $s = count($l);\n\n    for($i=0; $i<$s; $i++) {\n        $x\
    \ = $l[$i];\n        $x_last = $l[$i-1];\n        $x_diff = $x - $x_last;\n\n\
    \        if ($x_diff == 0)\n            return true;\n\n        if ($x_diff >\
    \ 0) {\n            if ($x_diff > 1)\n                return false;\n        }\
    \ else {\n            if ($x_diff < -1)\n                return false;\n     \
    \   }\n    }\n\n    return true;\n}", "\t$l = array_reverse($l);\n\t$s = $l[0];\n\
    \tfor ($i = 1; $i < count($l); $i++) {\n\t\t$e = $l[$i];\n\t\tif ($s > $e) {\n\
    \t\t\treturn true;\n\t\t} elseif ($e > $s) {\n\t\t\treturn false;\n\t\t}\n\t\t\
    $s = max($s, $e);\n\t}\n\treturn $s <= 0;\n}\n", "\t$l = array_reverse($l);\n\t\
    $cmp = $l[0] > $l[1] ? -1 : ($l[0] < $l[1] ? 1 : 0);\n\tfor ($i = 0, $j = 1; $i\
    \ < count($l); $i++, $j++) {\n\t\tif ($j === count($l) - 1 || $l[$i] !== $l[$j])\
    \ {\n\t\t\tif ($j === count($l)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ($l[$i]\
    \ < $l[$j]) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif ($l[$i] > $l[$j]) {\n\t\
    \t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn $cmp === 0;\n}\n", "\t$prev\
    \ = isset($l[0]) ? $l[0] : 0;\n\tforeach ($l as $v) {\n\t\tif ($v <= $prev) {\n\
    \t\t\treturn false;\n\t\t}\n\t\t$prev = $v;\n\t}\n\treturn true;\n}\n\n/**\n *\
    \ Converts a string into an array of characters.\n *\n * Strings containing multibyte\
    \ characters will not work correctly. Use\n * mb_convert_encoding if you have\
    \ configured your PHP to do so (preferred).\n *\n * @param string $str the string\
    \ to convert\n * @param string $charset the charset to use, defaults to UTF-8\n\
    \ * @return array\n */", "    return $l[0] <= $l[count($l) - 1]\n}\n", "    $s\
    \ = $l[0];\n    for($i = 1; $i < count($l); ++$i) {\n        $e = $l[$i];\n  \
    \      if($e < $s) {\n            return false;\n        } elseif($e > $s) {\n\
    \            return true;\n        }\n    }\n    return $l[0] > 0;\n}\n", "  if\
    \ ($l[0] < $l[1]) {\n    $l[1] = $l[0];\n  }\n  foreach ($l as $key => $value)\
    \ {\n    if ($value < $l[$key + 1]) {\n      $l[$key + 1] = $value;\n    }\n \
    \ }\n  return ($l[0] > $l[1]);\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 tags=php,arrays\
    \ |>\nHere's a simple solution using array_count_values, which counts the number\
    \ of occurrences of every value in the input array. The function returns true\
    \ if the array is monotonically increasing or decreasing.\n<code>", "\t$monotonic\
    \ = true;\n\t$l = array_keys($l);\n\tif ($l[0] > $l[1]) {\n\t\t$l = [$l[1], $l[0]];\n\
    \t}\n\tfor ($i = 2; $i < count($l); $i++) {\n\t\tif ($l[$i - 1] >= $l[$i]) {\n\
    \t\t\t$monotonic = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn $monotonic;\n}\n",
  "  global $sorts_common;\n  $l = array_reverse($l);\n  foreach ($l as $e) {\n  \
    \  $result = !$sorts_common->is_increasing($l);\n    if ($result) return $result;\n\
    \  }\n  return false;\n}\n", "\t$l = array_values($l);\n\t$l[0] = $l[1] = $l[2]\
    \ = 0;\n\tfor ($i = count($l) - 2; i >= 0; $i -= 2) {\n\t\tif ($l[$i] <= $l[$i\
    \ + 1]) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n", "    $length\
    \ = count($l);\n    for ($i = 0; $i < $length - 1; $i++) {\n        if ($l[$i]\
    \ <= $l[$i + 1]) {\n            return false;\n        }\n    }\n\n    return\
    \ true;\n}\n\n/**\n * Returns a value indicating whether a variable is undefined.\n\
    \ *\n * <code>\n * <?php\n * function test_undefined() {\n *   $a = undefined;\n\
    \ *   $b = null;\n *   $c = 1;\n *   $d = 1.2;\n *   $e = 1;\n *   $f = 'a';\n\
    \ *   $g = array();\n *   $h = array('x' => 1);\n *\n *   var_dump(defined($a));\n\
    \ *   var_dump(defined($b));\n *   var_dump(defined($c));\n *   var_dump(defined($d));\n\
    \ *   var_dump(defined($e));\n *   var_dump(defined($f));\n *   var_dump(defined($g));\n\
    \ *   var_dump(defined($h));\n * }\n * test_undefined();\n * ?>\n * </code>\n\
    \ *\n * @param mixed $var variable to be evaluated\n * @return bool true if variable\
    \ is undefined\n */", "    $l = array_reverse($l);\n    $last = $l[0];\n    foreach\
    \ ($l as $e) {\n        $delta = $e - $last;\n        if ($delta < 0) {\n    \
    \        $last = max($last, $e);\n        } else {\n            $last = min($last,\
    \ $e);\n        }\n    }\n    return $last < 0;\n}\n</code>\n<|/ a tags=sorting,arrays,php\
    \ dscore=3 |>\n<| c |>\nThis seems like the best solution until PHP comes up with\
    \ a native array sorting function!\n<|/ c |>\n<| c |>\n: I don't think there is.\
    \ You could probably create one, but probably not worth the effort.\n<|/ c |>\n\
    <| a dscore=3 |>\nI know this is an old thread, but I've found a way to do this\
    \ in PHP:\n<code>", "    $l = array_reverse($l);\n    $i = null;\n    $j = null;\n\
    \    for ($i = 0; $i < count($l); $i++) {\n        $j = $i;\n        while ($j\
    \ < count($l) && $l[$j] === $l[$j + 1]) {\n            $j++;\n        }\n    \
    \    if ($j == count($l)) {\n            return true;\n        }\n        if ($l[$i]\
    \ > $l[$j]) {\n            return false;\n        }\n    }\n    return true;\n\
    }\n\n/**\n * Test if a value is in the array\n *\n * @param mixed $value\n * @param\
    \ array $array\n * @return bool\n */", "  $l = array_reverse($l);\n  $l = array_slice($l,\
    \ -2);\n  $a = array_slice($l, -2);\n  sort($a);\n  sort($l);\n  return $a ==\
    \ $l;\n}\n</code>\n<|/ a tags=php,sorting,arrays dscore=0 |>\n<| a |>\nIf your\
    \ array is huge, you may want to avoid sorting a copy. Since arrays in PHP are\
    \ passed by reference, it is possible to compare the arrays as if they were passed\
    \ by value. To do this, you can use the SORT_FLAG_CASE option in usort as shown\
    \ in the following example:\n<code>\n<?php", "  foreach ($l as $i => $v)\n   \
    \ if ($l[$i] < $l[--$i])\n      return true;\n  return false;\n}", "    return\
    \ is_array($l) && count($l) == count(array_filter(array_keys($l), 'is_int')) &&\
    \ min(end($l)) == max($l);\n}\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work well\
    \ for arrays of objects. What I did to fix this was to return 'true' if the object\
    \ was smaller than the one on the previous index, and return 'false' otherwise.\
    \ You can probably extend it to compare objects also.\n<|/ c |>\n<| c |>\nI don't\
    \ think that would work well for objects. An object can never be smaller than\
    \ an object on the previous index.\n<|/ c |>\n<| a tags=arrays,sorting,php |>\n\
    For my money, I would say that this question is better suited for CodeReview.\
    \ I'm sure you can do better than this.\n<|/ a dscore=0 |>\n<| a |>\nThis is a\
    \ little bit brute force, but seems to work nicely:\n<code>", "    $l1 = $l[1];\n\
    \    foreach ($l as $v) {\n        if ($v != $l1) {\n            return $v < $l1;\n\
    \        }\n    }\n    return false;\n}", "    $l = $l[1];\n    $v = array_slice($l,\
    \ 1);\n    if (array_reduce($v, function($carry, $v) {\n            return $carry\
    \ || ($v < $v[0] || $v == $v[0]);\n    })) {\n        return false;\n    }\n \
    \   return true;\n}\n", "  // Return false if not monotonic increasing or decreasing.\n\
    \  // >>> monotonic([4, 1, 0, -10])\n  // false\n  // >>> monotonic([4, 1, -10,\
    \ 0])\n  // false\n  // >>> monotonic([-1, 0, 1, 2, 3])\n  // false\n  // >>>\
    \ monotonic([-1, 0, 1, 2, 3], true)\n  // true\n  if (empty($l) || $l[0] < $l[1])\
    \ {\n    return false;\n  }\n  // Find the left and right bounds of the current\
    \ interval.  If the interval is\n  // decreasing, then we want the max of the\
    \ right bound, and the min of the\n  // left bound.  If the interval is increasing,\
    \ then we want the min of the\n  // right bound, and the max of the left bound.\n\
    \  $left = $l[0];\n  $right = $l[1];\n  for ($i = 2; $i < count($l); $i++) {\n\
    \    if ($l[$i] < $left) {\n      $left = $l[$i];\n    }\n    if ($l[$i] > $right)\
    \ {\n      $right = $l[$i];\n    }\n  }\n  if ($left === $right) {\n    return\
    \ false;\n  }\n  // If left and right are equal, then the interval is monotonically\
    \ increasing.\n  if ($left === $l[$i - 1]) {\n    return true;\n  }\n  // If left\
    \ is less than right, then the interval is monotonically decreasing.\n  if ($right\
    \ === $l[$i - 1]) {\n    return false;\n  }\n  // At this point, we need to check\
    \ whether the left bound is strictly\n  // greater than or equal to the right\
    \ bound.\n  for ($i = 0; $i < count($l) - 2; $i++) {\n    if ($l[$i] < $l[$i +\
    \ 1]) {\n      // Nope, not monotonically increasing.\n      return false;\n \
    \   }\n  }\n  return true;\n}\n\n/**\n * Returns true if the passed array is empty.\n\
    \ *\n * @param array $l An array to check\n * @return bool True if the passed\
    \ array is empty\n */", "    return !$l[0] || $l[0] > $l[-1];\n}\n", "    $l =\
    \ $l ? $l : array();\n    $monotonic = false;\n    foreach ($l as $i => $item)\
    \ {\n        if ($item === $l[0]) {\n            $monotonic = true;\n        }\
    \ else {\n            $monotonic = -1;\n            break;\n        }\n    }\n\
    \    return $monotonic;\n}\n</code>\n<|/ a tags=php,arrays |>\n<| a dscore=0 |>\n\
    Try this one.\n<code>\n<?php\n", "    return $l[0] === $l[-1] ? false : true;\n\
    }", "\tif (!is_array($l)) {\n\t\treturn false;\n\t}\n\tsort($l);\n\treturn $l[0]\
    \ == $l[count($l) - 1];\n}\n\n", "  $l = array_reverse($l);\n  $l = array_filter($l,\
    \ function($element) {\n    return !($element instanceof static);\n  });\n  return\
    \ $l[0]->cmp($l[count($l) - 1]) < 0;\n}\n", "    $l = array_slice($l, 1);\n  \
    \  for ($i = count($l) - 1; $i >= 0; --$i) {\n        if ($l[$i] <= $l[$i + 1])\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\n", "  if\
    \ ($l == null) {\n    return null;\n  }\n  if (!is_array($l)) {\n    throw new\
    \ Exception(\n      pht(\n        'Monotonic function expects array parameter;\
    \ received \"%s\".',\n        strtolower(get_class($l))));\n  }\n  $count = count($l);\n\
    \  if ($count < 2) {\n    return false;\n  }\n  for ($i = 1; $i < $count; ++$i)\
    \ {\n    if ($l[$i - 1] < $l[$i]) {\n      return false;\n    }\n  }\n  return\
    \ true;\n}\n", "\tsort($l);\n\tfor ($i = 0; $i < count($l); $i++) {\n\t\tif ($l[$i]\
    \ == $l[$i - 1]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n", " \
    \ if (!is_array($l)) {\n    return false;\n  }\n  $l = array_reverse($l);\n  return\
    \ array_reduce($l, function ($r, $v) { return $r && $v > $v; }, true);\n}\n\n",
  "\tif (!is_array($l)) {\n\t\treturn false;\n\t}\n\t$lkeys = array_keys($l);\n\t\
    $lvalues = array_values($l);\n\treturn array_pop($lkeys) < array_pop($lvalues);\n\
    }\n", "  $l = array_reverse($l); \n  $i = 0; \n  $j = $l[0]; \n  while ($i < count($l))\
    \ { \n    if (($j > $l[$i]) || (!isset($l[$i + 1]))) {\n      $l[$i] = $j; \n\
    \      $i++; \n      $j = $l[$i]; \n    } elseif ($j < $l[$i + 1]) {\n      $l[$i]\
    \ = $j; \n      $i++; \n    } elseif ($l[$i] == $l[$i + 1]) { \n      $i++; \n\
    \    } elseif ($l[$i] < $l[$i + 1]) { \n      $l[$i] = $j; \n      $i++; \n  \
    \    $j = $l[$i]; \n    } \n  } \n  return $l[0] >= $l[count($l) - 1]; \n}\n",
  "    if (empty($l)) {\n        return false;\n    }\n    $last = array_pop($l);\n\
    \    if ($last < $l[0]) {\n        return false;\n    }\n    foreach ($l as $i\
    \ => $e) {\n        if ($e >= $last) {\n            return false;\n        }\n\
    \    }\n    return true;\n}\n", "    if ($l instanceof Traversable) {\n      \
    \  $l = iterator_to_array($l);\n    }\n    $keys = array_keys($l);\n    $data\
    \ = array_values($l);\n    return $data[0] <= $data[key($keys)] &&\n         \
    \  $data[key($keys)+1] <= $data[key($keys-1)];\n}\n</code>\n<|/ a tags=arrays,php\
    \ |>\n<| c |>\nI think it would be helpful if you explained what you did here;\
    \ why did you think this works?\n<|/ c |>\n<| c |>\nI have added a comment about\
    \ this. It should work now if you copy the code from the answer.\n<|/ c |>\n<|\
    \ a dscore=2 |>\nIf you have only sorted array then use below code\n<code>", " \
    \ // if an array isn't passed or is empty return false\n  if (empty($l) || $l\
    \ === true) {\n    return false;\n  }\n\n  // if the first value is not numeric,\
    \ return false\n  if (!is_numeric($l[0])) {\n    return false;\n  }\n\n  // if\
    \ the first value isn't greater than or equal to the second, return false\n  if\
    \ ($l[0] > $l[1]) {\n    return false;\n  }\n\n  // find the first value less\
    \ than the second value\n  for ($i = 0, $len = count($l); $i < $len; $i++) {\n\
    \    if ($l[$i] < $l[$i-1]) {\n      break;\n    }\n  }\n\n  // if we didn't find\
    \ any values less than the second value\n  if ($i < $len - 1) {\n    return false;\n\
    \  }\n\n  // if all the values are numeric, return true\n  for ($i = 1; $i < count($l);\
    \ $i++) {\n    if (!is_numeric($l[$i])) {\n      return false;\n    }\n  }\n\n\
    \  return true;\n}\n\n/**\n * Sort an array using the given sorter.\n *\n * Pass\
    \ an anonymous function that accepts the array item as the first and\n * second\
    \ argument. Or an array of multiple sorters. Multiple sorters will be\n * applied\
    \ in the order in which they are passed. The result will be used to\n * order\
    \ the items in the array. If an array of strings are provided, the\n * return\
    \ value will be an array of integers representing each sorter order,\n * with\
    \ the corresponding strings ordered based on the original array.\n *\n * @param\
    \ array $arr Array to be sorted.\n * @param string|array|Closure $sorters The\
    \ name of the sorter, or an array of\n *     multiple sorters. If $sorters is\
    \ an array, then the array will itself be\n *     passed as the argument to each\
    \ sorter.\n * @param Closure $closure Optional callback function for sorting each\
    \ item. Gets\n *     the item as a single argument. This callback can modify the\
    \ item and\n *     return its modified value. If the array item is modified, the\
    \ sorted\n *     array will also be modified in place and will contain the new\
    \ items.\n * @return array|bool If the array is a numeric array, an associative\
    \ array with\n *     the sorted keys is returned. False will be returned for non-arrays\
    \ and\n *     if no sorters are passed. In all other cases, an array containing\
    \ the\n *     sorted keys will be returned.\n */", "  $last = array_pop($l);\n\
    \  $next = $last;\n  for ($i = 0; $i < count($l); $i++) {\n    if ($l[$i] !==\
    \ $last) { // Decreasing\n      $next = $l[$i];\n      return false;\n    }\n\
    \  }\n  return true;\n}\n", "    if (is_array($l)) {\n        $sorted = array_values($l);\n\
    \        usort($sorted, 'monotonic');\n        $last = array_pop($sorted);\n \
    \       return $last === 0 || $sorted === $sorted;\n    }\n    return false;\n\
    }\n</code>\n<|/ a tags=arrays,php |>\n<| c |>\nThis doesn't work well if an array\
    \ has two or more duplicate values.\n<|/ c |>\n<| c |>\nThis also doesn't work\
    \ for arrays of strings. `array(\"a\", \"a\", \"b\")` returns true in most languages,\
    \ while `array(\"a\", \"b\", \"a\")` returns false in PHP. I think the solution\
    \ is to cast both of these as strings, or to ensure that there are no duplicates.\n\
    <|/ c |>\n<| c |>\nThis only works on arrays that have a unique value, as defined\
    \ by `array_unique()` or `array_values()`. So for example `array(\"a\", \"a\"\
    , \"b\")` returns `true`, even though the values are identical. `array(\"a\",\
    \ \"b\", \"c\")` returns `false`, as it does not have a unique value.\n<|/ c |>\n\
    <| a tags=arrays,php |>\nI have just found this question in Google. So, I post\
    \ my solution here. It works for any number of elements, and also for strings\
    \ and integers. It also works correctly on duplicate elements. It is based on\
    \ the assumption that the array is sorted, which may not be the case for PHP arrays.\n\
    <code>\n/**\n * Check if an array is monotonic (i.e. increasing or decreasing)\n\
    \ *\n * array $array\n * bool\n */", "    $l = array_filter($l);\n    if (count($l)\
    \ == 0) {\n        return false;\n    }\n    $last = array_shift($l);\n    $ret\
    \ = !isset($l[0]);\n    while ($l[0] <= $last) {\n        $ret = !$ret;\n    \
    \    $last = array_shift($l);\n    }\n    return $ret;\n}\n", "    $last = array_pop($l);\n\
    \    foreach ($l as $item) {\n        if ($item < $last) {\n            return\
    \ false;\n        }\n        $last = $item;\n    }\n    return true;\n}\n", " \
    \ return count($l) === count(array_filter(array_keys($l), 'is_int')) ?\n    array_reduce($l,\
    \ 'array_filter', $l) === array_reduce(array_keys($l), 'array_filter', $l) :\n\
    \    false;\n}", "  foreach ($l as $k => $v) {\n    $cmp = ($v > $l[$k]) - ($v\
    \ < $l[$k]);\n    if ($cmp) {\n      return true;\n    }\n  }\n  return false;\n\
    }\n", "    $l = array_filter($l, function($el) {\n        return is_numeric($el)\
    \ && $el >= 0;\n    });\n\n    return count($l) > 0 && $l[0] > $l[count($l) -\
    \ 1];\n}\n", "    $u = [];\n    foreach($l as $i => $v) {\n        $u[$i] = $v;\n\
    \    }\n    $u[] = end($l);\n    sort($u);\n    foreach($u as $i => $v) {\n  \
    \      if($v !== $u[$i-1]) {\n            return false;\n        }\n    }\n  \
    \  return true;\n}\n\n/*\n\n    http://tools.ietf.org/html/draft-ietf-httpbis-p5-conditional-12#section-4.5.3\n\
    \    http://tools.ietf.org/html/draft-ietf-httpbis-p5-conditional-12#section-4.5.4\n\
    \n    If-Match = \"*\" | entity-tag\n\n    */\n", "    $monoton = true;\n    $l\
    \ = array_slice($l);\n    $m = array_reduce($l, function ($a, $b) {\n        return\
    \ $a + $b;\n    });\n    if ($m === 0) {\n        foreach ($l as $k => $v) {\n\
    \            if ($v < 0) $monoton = false;\n        }\n    } else {\n        foreach\
    \ ($l as $k => $v) {\n            if ($v != $m * -1)\n                $monoton\
    \ = false;\n        }\n    }\n    return $monoton;\n}\n", "    if (!count($l))\n\
    \        return false;\n    $first = array_shift($l);\n    foreach ($l as $v)\
    \ {\n        if ($v != $first)\n            return false;\n    }\n    return true;\n\
    }\n", "  if (!is_array($l)) return false;\n  $f = array_shift($l);\n  foreach\
    \ ($l as $e) {\n    if ($e !== $f) {\n      return $e >= $f;\n    }\n  }\n  return\
    \ true;\n}\n", "  $l = $l ? $l : array();\n\n  sort($l);\n  return $l[0] >= $l[count($l)\
    \ - 1];\n}", "    return $l[0] > $l[1] && $l[0] > $l[2] && $l[0] > $l[3] &&\n\
    \        $l[1] > $l[2] && $l[1] > $l[3] && $l[2] > $l[3] &&\n        $l[3] < $l[4]\
    \ && $l[4] < $l[5] && $l[5] < $l[6] &&\n        $l[6] < $l[7] && $l[7] < $l[8]\
    \ && $l[8] < $l[9];\n}\n</code>\n<|/ a tags=algorithm,sorting,php |>\n<| c |>\n\
    this looks great, except the results are reversed.  How should I reverse the results?\n\
    <|/ c |>\n<| c |>\nIf you swap the two if conditions you will get your results\
    \ in the original order.\n<|/ c |>\n<| c |>\nThe return statement needs to be\
    \ flipped also.\n<|/ c |>\n<| c |>\n, thank you for noticing that issue.  Fixed.\n\
    <|/ c |>\n<| a dscore=2 |>\nThis should do what you want:\n<code>\n$arr = array(\n\
    \    'abc',\n    'def',\n    'ghi',\n    'jkl',\n    'mno',\n    'pqrs',\n   \
    \ 'stuv'\n);\n\nsort($arr);\n\n$arr = array_reverse($arr);\n\nsort($arr);\n\n\
    var_dump($arr);\n</code>\n<|/ a tags=algorithm,sorting,php |>\n<| c |>\nI like\
    \ this solution for its simplicity, but I ended up going with my own answer. \
    \ Thanks though!\n<|/ c |>\n<| c |>\nI like this solution too, but I wanted to\
    \ keep my solution consistent with my code.  I went with my code though because\
    \ it is cleaner, and I wanted to know if there was a way to do it with my code\
    \ in the future.  I upvoted the answer, though.  Thanks again.\n<|/ c |>\n<| a\
    \ tags=algorithm,sorting,php dscore=2 |>\n<code>", "  if (!is_array($l) || !count($l))\
    \ {\n    return false;\n  }\n\n  return !($l[0] > $l[count($l) - 1]);\n}\n", " \
    \   // http://en.wikipedia.org/wiki/Monotonic_array\n    $l = array_reverse($l);\n\
    \    for ($i = 0, $c = count($l); $i < $c; $i++) {\n        if ($l[$i] < $l[$i+1])\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n\
    \ * Returns an array containing all of the elements of this array that match a\n\
    \ * provided callback or a default value.\n *\n * ### Caveats:\n *\n * - if $key\
    \ is not provided, $value will always be returned.\n * - if $key is not provided\
    \ and the $value is null, $default will be returned.\n * - if the value returned\
    \ is not of the correct type or is malformed a TypeError will be thrown.\n *\n\
    \ * @param mixed $key\n * @param mixed $value\n * @param mixed $default\n * @return\
    \ array\n */", "    $l = is_array($l) ? $l : array();\n    sort($l);\n    return\
    \ !empty($l) && $l[0] > $l[count($l)-1];\n}\n", "  if (!$l) return true;\n  return\
    \ $l[0] <= $l[count($l) - 1];\n}\n", "    foreach ($l as $elem) {\n        if\
    \ ($elem !== $l[count($l) - 1] + 1) {\n            return false;\n        }\n\
    \    }\n    return true;\n}\n", "  return $l[0] <  $l[1] ||\n         ($l[0] ==\
    \ $l[1] && $l[2] < $l[3]) ||\n         ($l[0] == $l[1] && $l[3] == $l[2] && $l[4]\
    \ < $l[5]);\n}\n", "  $l = array_map('floatval', $l);\n  // $l = array_filter($l);\n\
    \  // $l1 = array_shift($l);\n  // $l2 = array_shift($l);\n  // return $l1 ===\
    \ $l2 || $l1 > $l2;\n  return ($l[0] === $l[1] || $l[0] > $l[1]) ? true : false;\n\
    }\n", "  if ($l[0] < $l[1]) {\n    $l[0] = max($l[0], $l[1]);\n    $l[1] = min($l[0],\
    \ $l[1]);\n    return true;\n  }\n  return false;\n}\n</code>\n<|/ a |>\n<| a\
    \ tags=php,arrays,sorting dscore=2 |>\n<code>\n$array = array(\n    '3' => array(\n\
    \        'name' => 'Three',\n        'value' => '3',\n    ),\n    '1' => array(\n\
    \        'name' => 'One',\n        'value' => '1',\n    ),\n    '2' => array(\n\
    \        'name' => 'Two',\n        'value' => '2',\n    ),\n);\n\n$sortby = $_GET['sortby'];\n",
  "  // returns true if all members of $l are monotonically\n  // increasing. Useful\
    \ for detecting data sets with no or negligible\n  // outliers.\n  foreach ($l\
    \ as $k => $v)\n    if (!isset($l[$k + 1]) || $l[$k + 1] <= $v)\n      return\
    \ false;\n  return true;\n}\n", "    foreach ($l as $key => $value) {\n      \
    \  $l[$key] = $value + ($l[$key] < $value ? 1 : -1);\n    }\n    return $l[0]\
    \ <= $l[$l[0]];\n}\n</code>\n<|/ a dscore=4 |>\n<| a dscore=3 |>\nAs has been\
    \ pointed out, this is very similar to what Python does and that question was\
    \ already answered before. The following function can be used with PHP >= 5.4.0\
    \ which supports closures.\n<code>\n/**\n * Checks whether an array contains monotonically\
    \ increasing values.\n * \n * $arr An array of values.\n * \n * bool\n */", "\t\
    $l = $l ? $l : array();\n\tsort($l);\n\t$r = array();\n\tfor ($n = count($l) -\
    \ 1; $n >= 0; $n--) {\n\t\t$r[] = $l[$n + 1];\n\t\tif ($l[$n] <= $l[$n + 1]) {\n\
    \t\t\tbreak;\n\t\t}\n\t}\n\treturn count($r) === 1 && $r[0] <= $r[$n - 1];\n}\n\
    \n/**\n * Find the smallest integer greater than or equal to a number\n *\n *\
    \ @param int|float $number Number to find the next greater or equal to\n * @return\
    \ int The next greater or equal to $number\n */", "  return $l == array_keys($l);\n\
    }\n", "    if (count($l) === 0) {\n        return false;\n    }\n    $is_increasing\
    \ = true;\n    foreach ($l as $i => $v) {\n        if ($l[$i] > $v || $is_increasing\
    \ && $l[$i] == $v) {\n            $is_increasing = false;\n        }\n    }\n\
    \    return $is_increasing;\n}\n", "    if ($l[0] === $l[1]) {\n        return\
    \ TRUE;\n    }\n    return ($l[1] < $l[0]) ? FALSE : TRUE;\n}", "  $count = count($l);\n\
    \  if ($count == 0) {\n    return false;\n  }\n  if ($count == 1) {\n    return\
    \ $l[0] >= $l[($count - 1)];\n  }\n  $prev = $l[0];\n  for ($i = 1; $i < $count;\
    \ ++$i) {\n    if ($l[$i] < $prev) {\n      return false;\n    }\n    $prev =\
    \ $l[$i];\n  }\n  return true;\n}\n", "  return $l[0] <= $l[1] && $l[2] <= $l[3];\n\
    }\n\n/**\n * Compute a running total over an array.\n *\n * This function is useful\
    \ for reducing operations over an array\n * using functions defined on an array.\n\
    \ *\n * Example:\n * <pre>\n * $sum = 0;\n * foreach ($values as $value) {\n *\
    \   $sum += $value;\n * }\n * </pre>\n *\n * @see http://php.net/array_reduce\n\
    \ *\n * @param array $arr The array over which to iterate.\n * @param callable\
    \ $fn The callback function.\n *\n * @return mixed\n */", "    $l = array_reverse($l);\n\
    \    $m = array();\n    $count = count($l);\n    for ($i = 0; $i < $count; ++$i)\
    \ {\n        $m[$i] = ($i > 0) ? max($l[$i - 1], $m[$i - 1]) : $l[$i];\n    }\n\
    \    return ($m[$i] < $l[$i]) || ($m[$i] == $l[$i] && $m[$i + 1] > $l[$i + 1]);\n\
    }\n", "  $ls = array_keys($l);\n  $min = array_shift($ls);\n  $max = array_shift($ls);\n\
    \  foreach ($ls as $key => $val) {\n    if ($val < $min) {\n      $min = $val;\n\
    \    } else if ($val > $max) {\n      $max = $val;\n    }\n  }\n  if ($min ==\
    \ $max) {\n    return $min == 0;\n  }\n  return ($min < $max) ? true : false;\n\
    }\n", "  $prev = $l[0];\n  $curr = $l[0];\n  for ($i = 1; $i < count($l); $i++)\
    \ {\n    if ($l[$i] <= $prev) {\n      return false;\n    }\n    $prev = $l[$i];\n\
    \    $curr += $l[$i];\n  }\n  return true;\n}\n", "    foreach ($l as $v) {\n\
    \        if (is_numeric($v)) {\n            if ($v > 0) {\n                return\
    \ true;\n            }\n            $t = $v < 0;\n            $v = abs($v);\n\
    \            if ($t !== ($v > 0)) {\n                return $t;\n            }\n\
    \        }\n    }\n    return false;\n}\n", "    return $l[0] <= $l[count($l)\
    \ - 1] ? true : false;\n}\n</code>\nI thought I was getting it right until I tested\
    \ my code on more complex data, and found that for reasons I don't understand\
    \ it is failing on the \"array\" element (it fails consistently on all the test\
    \ cases I tried). \nHere's the data I used: \n<code>\n$data = [\n    [\n     \
    \   \"name\" => \"Test\",\n        \"number\" => 5,\n        \"list\" => [\n \
    \           [\n                \"name\" => \"Test\",\n                \"number\"\
    \ => 3,\n                \"list\" => [\n                    [\n              \
    \          \"name\" => \"Test\",\n                        \"number\" => 3\n  \
    \                  ],\n                    [\n                        \"name\"\
    \ => \"Test\",\n                        \"number\" => 5\n                    ],\n\
    \                    [\n                        \"name\" => \"Test\",\n      \
    \                  \"number\" => 1\n                    ],\n                 \
    \   [\n                        \"name\" => \"Test\",\n                       \
    \ \"number\" => 2\n                    ],\n                    [\n           \
    \             \"name\" => \"Test\",\n                        \"number\" => 4\n\
    \                    ],\n                    [\n                        \"name\"\
    \ => \"Test\",\n                        \"number\" => 8\n                    ],\n\
    \                    [\n                        \"name\" => \"Test\",\n      \
    \                  \"number\" => 7\n                    ],\n                 \
    \   [\n                        \"name\" => \"Test\",\n                       \
    \ \"number\" => 9\n                    ],\n                    [\n           \
    \             \"name\" => \"Test\",\n                        \"number\" => 6\n\
    \                    ],\n                    [\n                        \"name\"\
    \ => \"Test\",\n                        \"number\" => 10\n                   \
    \ ],\n                    [\n                        \"name\" => \"Test\",\n \
    \                       \"number\" => 2\n                    ],\n            \
    \        [\n                        \"name\" => \"Test\",\n                  \
    \      \"number\" => 4\n                    ],\n                    [\n      \
    \                  \"name\" => \"Test\",\n                        \"number\" =>\
    \ 8\n                    ],\n                    [\n                        \"\
    name\" => \"Test\",\n                        \"number\" => 9\n               \
    \     ],\n                    [\n                        \"name\" => \"Test\"\
    ,\n                        \"number\" => 6\n                    ],\n         \
    \           [\n                        \"name\" => \"Test\",\n               \
    \         \"number\" => 10\n                    ],\n                    [\n  \
    \                      \"name\" => \"Test\",\n                        \"number\"\
    \ => 2\n                    ],\n                    [\n                      \
    \  \"name\" => \"Test\",\n                        \"number\" => 4\n          \
    \          ],\n                    [\n                        \"name\" => \"Test\"\
    ,\n                        \"number\" => 8\n                    ],\n         \
    \           [\n                        \"name\" => \"Test\",\n               \
    \         \"number\" => 9\n                    ],\n                    [\n   \
    \                     \"name\" => \"Test\",\n                        \"number\"\
    \ => 6\n                    ],\n                    [\n                      \
    \  \"name\" => \"Test\",\n                        \"number\" => ", "  // Return\
    \ false for empty or no array.\n  if (!empty($l)) {\n    // Sort array by value\
    \ to make sorting in descending order easier.\n    asort($l);\n    // If array\
    \ is monotonically increasing sort by key.\n    if (!array_search($l[0], $l) &&\
    \ array_search($l[1], $l)) {\n      return true;\n    }\n    // If array is monotonically\
    \ decreasing sort by key.\n    if (!array_search($l[0], $l) && !array_search($l[1],\
    \ $l)) {\n      return false;\n    }\n  }\n  return false;\n}\n\n/**\n * Get current\
    \ time with microseconds.\n *\n * @return int microseconds timestamp.\n */", " \
    \   $l1 = $l2 = $l3 = null;\n    foreach ($l as $v) {\n        if ($l3 == null)\
    \ {\n            $l3 = $v;\n        } else if ($l2 > $v || $l2 == null) {\n  \
    \          $l1 = $l2 = $v;\n        } else {\n            $l3 = $v;\n        }\n\
    \    }\n    return ($l3 != $l1 && $l3 != $l2);\n}\n</code>\n<|/ a dscore=3 |>\n\
    <| a dscore=2 |>\nThe easiest way is by sorting your array. Then you just need\
    \ to take the first element and check if it's smaller or bigger than the last.\n\
    <|/ a tags=arrays,sorting,php |>\n<| a dscore=2 |>\nSort the array in ascending\
    \ order and store it in a variable $a and then check if($a[$n-1]>$a[$n]){\n<|/\
    \ a tags=arrays,sorting,php |>\n<| c |>\nNo need to sort the array. Just compare\
    \ the last two items (as I understand from the question).\n<|/ c |>\n<| a dscore=1\
    \ tags=arrays,sorting,php |>\nYou need a function that sorts your array in ascending\
    \ order. After you got that, just compare your new array and the old one.\n<|/\
    \ a |>\n<| c |>\nWhat do you mean? Can you show an example? Thanks\n<|/ c |>\n\
    <| a tags=arrays,sorting,php |>\nTry this\n<code>", "    $count = count($l);\n\
    \    if ($count == 0) {\n        return false;\n    }\n    for ($i = 0; $i < $count;\
    \ ++$i) {\n        if (!isset($l[$i + 1])) {\n            return false;\n    \
    \    }\n        $v1 = $l[$i];\n        $v2 = $l[$i + 1];\n        if ($v1 < $v2)\
    \ {\n            return false;\n        }\n    }\n    return true;\n}", "    return\
    \ $l[0] <= $l[count($l) - 1];\n}\n\n/**\n * Takes a list and returns a new list\
    \ with all duplicate entries removed.\n *\n * @param  array  $list\n * @param\
    \  string $key\n * @return array\n */", "  $prev = PHP_INT_MAX;\n  foreach ($l\
    \ as $v) {\n    if ($v < $prev) {\n      return true;\n    }\n    if ($v > $prev)\
    \ {\n      return false;\n    }\n    $prev = $v;\n  }\n  return true;\n}\n", " \
    \ $l = array_reverse($l);\n  $len = count($l);\n\n  for ($i = 1; $i < $len; $i++)\
    \ {\n    if ($l[$i - 1] <= $l[$i]) {\n      return $i === $len - 1 || $l[$i +\
    \ 1] < $l[$i];\n    }\n  }\n\n  return false;\n}\n", "  return $l[0] > $l[-1];\n\
    }", "    $prev = $l[0];\n    for ($i = 1; $i < count($l); $i++) {\n        if\
    \ ($l[$i] <= $prev) {\n            return false;\n        }\n        $prev = $l[$i];\n\
    \    }\n    return true;\n}\n", "  if (empty($l)) return false;\n  $first = $l[0];\n\
    \  return $first <= $l[count($l) - 1];\n}\n", "    return $l[0] <= $l[1] || $l[1]\
    \ < $l[0] || $l[2] <= $l[3];\n}\n\n/**\n * @see array_keys\n */", "    return\
    \ ($l[0] === $l[1] && $l[1] === $l[2] && $l[2] === $l[3]);\n}\n", "    if ($l\
    \ == null) {\n        return false;\n    }\n    $n = count($l);\n    if ($n ==\
    \ 1) {\n        return true;\n    }\n    if ($n == 2) {\n        $i0 = $i1 = $i2\
    \ = $i2;\n        for ($i2 = $n - 1; $i2 >= 0; $i2--) {\n            if ($l[$i2]\
    \ > $l[$i1]) {\n                $i1 = $i2;\n            }\n        }\n       \
    \ for ($i2 = $n - 1; $i2 >= 1; $i2--) {\n            if ($l[$i2] < $l[$i1]) {\n\
    \                return false;\n            }\n        }\n        return true;\n\
    \    }\n    if ($n == 3) {\n        $i0 = $i1 = $i2 = $i2;\n        for ($i2 =\
    \ $n - 2; $i2 >= 0; $i2--) {\n            if ($l[$i2] < $l[$i1]) {\n         \
    \       $i0 = $i1;\n            }\n            if ($l[$i2] > $l[$i1]) {\n    \
    \            $i1 = $i2;\n            }\n        }\n        for ($i2 = $n - 2;\
    \ $i2 >= 1; $i2--) {\n            if ($l[$i2] < $l[$i1]) {\n                return\
    \ false;\n            }\n            if ($l[$i2] > $l[$i1]) {\n              \
    \  return false;\n            }\n        }\n        return true;\n    }\n    return\
    \ false;\n}\n", "\t$l = array_values($l);\n\tsort($l);\n\t$first = array_slice($l,\
    \ 0, 1);\n\treturn (empty($first) || $first[0] === array_pop($first)) && $l ===\
    \ $first;\n}", "    $l = array_reverse($l);\n    $l = array_diff($l, array_unique($l));\n\
    \    return !$l;\n}\n", "    if ($l === $l[0]) return true;\n    foreach ($l as\
    \ $k => $v) {\n        if ($k != 0 && $v != $l[0]) return false;\n    }\n    return\
    \ true;\n}\n", "    $l = array_reverse($l);\n    $sorted = array_diff_assoc($l,\
    \ $l);\n    return !count($sorted) || $sorted[0] > $sorted[-1];\n}\n", "  // Return\
    \ true if array is empty.\n  if (!is_array($l)) {\n    return false;\n  }\n\n\
    \  // Return 'true' if array is monotonic and sorted.\n  $monotonic = true;\n\
    \  if (count($l) === count(array_unique($l))) {\n    sort($l);\n    $monotonic\
    \ = !$l[0] <= $l[count($l) - 1];\n  }\n\n  // Return 'true' if all elements of\
    \ array are monotonically\n  // increasing or decreasing.\n  return $monotonic;\n\
    }\n\n/**\n * Returns the highest element from an array that satisfies a callback.\n\
    \ */", "\tforeach ($l as $key => $val) {\n\t\tif ($val < $l[($key + 1)]) {\n\t\
    \t\treturn false;\n\t\t}\n\t\tif ($val > $l[($key - 1)]) {\n\t\t\treturn false;\n\
    \t\t}\n\t}\n\treturn true;\n}\n", "    if (empty($l)) {\n        return true;\n\
    \    }\n    foreach ($l as $item) {\n        if (!is_numeric($item)) {\n     \
    \       return false;\n        }\n    }\n    $first = $l[0];\n    foreach ($l\
    \ as $item) {\n        if ($item > $first) {\n            return false;\n    \
    \    }\n        if ($item < $first) {\n            return true;\n        }\n \
    \   }\n    return true;\n}", "    if (!is_array($l))\n        return false;\n\
    \    $l = array_reverse($l);\n    $s = $e = null;\n    for ($i = 1; $i <= count($l);\
    \ $i++) {\n        if ($e === null) {\n            $e = $l[$i - 1];\n        \
    \    $s = $i;\n        } else {\n            $e = $l[$i] - $e;\n            if\
    \ ($e == 0) {\n                $s = $i;\n            }\n        }\n        if\
    \ ($s !== null)\n            return $s <= $i;\n    }\n    return false;\n}", " \
    \   sort($l);\n    $first_value = $l[0];\n    $last_value = $l[count($l) - 1];\n\
    \    for ($i = 0; $i < count($l); $i++) {\n        $delta = $l[$i] - $last_value;\n\
    \        if ($delta == 0) {\n            return $first_value == $last_value;\n\
    \        }\n        if ($delta > 0) {\n            return false;\n        }\n\
    \        $last_value = $l[$i];\n    }\n    return true;\n}\n", "    return $l[0]\
    \ < $l[1] && $l[2] > $l[0];\n}\n\n/**\n * Return min of array elements.\n *\n\
    \ * If all elements are equal, return min. If at least one element is equal,\n\
    \ * return that element.\n * If array elements are objects, min compares objects\
    \ alphabetically.\n *\n * @param array $array\n * @param mixed $fallback\n * @return\
    \ mixed\n */", "    $s = $l = array_reverse($l);\n    do {\n        $i = array_pop($l);\n\
    \        if ($i > $s[count($s)-1]) return false;\n        $s[] = $i;\n    } while\
    \ (!empty($l));\n    return true;\n}\n\n/**\n * Sort an array and maintain relative\
    \ ordering.\n */", "    $i = count($l);\n\n    for ($j = 1; $j < $i; ++$j) {\n\
    \        if ($l[$j] > $l[$j - 1]) {\n            return false;\n        }\n  \
    \  }\n\n    return true;\n}\n", "    // Return true is array elements are monotonically\
    \ increasing or decreasing.\n    // >>> monotonic([10, 4, 1, 20, 0])\n    // true\n\
    \    // >>> monotonic([10, 4, 20, 0, 1])\n    // false\n    // >>> monotonic([-5,\
    \ -4, -7, 0, 1])\n    // true\n    // >>> monotonic([-5, -4, -7, 1, 0])\n    //\
    \ false\n    $m = array_merge($l, $l);\n    sort($m);\n    $d = array_diff($l,\
    \ $m);\n    return count($m) <= count($d);\n}\n", "    $keys = array_keys($l);\n\
    \    $i = 1;\n    $j = 0;\n\n    for ($i = 1; $i < count($l); $i++) {\n      \
    \  if ($l[$i] < $l[$keys[$j]] || $l[$i] >= $l[$keys[$j + 1]]) {\n            //\
    \ Swap pointers.\n            $tmp = $l[$i];\n            $l[$i] = $l[$keys[$j]];\n\
    \            $l[$keys[$j]] = $tmp;\n            $tmp = $l[$keys[$j + 1]];\n  \
    \          $l[$keys[$j + 1]] = $l[$i];\n            $l[$i] = $tmp;\n        }\n\
    \n        $j++;\n    }\n    return $l[0] >= $l[count($l) - 1];\n}\n", "    $l\
    \ = array_reverse($l);\n    $last = array_pop($l);\n    return $last <= $l;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThank you!\nThis seems to be the best answer, although\
    \ it's not the only one :D\n<|/ c |>\n<| c |>\n`monotonic` is only correct for\
    \ monotonic increasing data. It's not suitable for monotonic decreasing data.\n\
    <|/ c |>\n<| a tags=arrays,php,sorting |>\nThis might not be the fastest solution,\
    \ but it's easy to read and I only needed it for testing. I'm guessing it's O(n)\
    \ at worst, but maybe it's O(n log n) if someone has a better solution.\n<code>\n\
    public static function monotonic_increasing($array){\n    if(empty($array)) return\
    \ false;\n    $first = $array[0];\n    for($i=1; $i < count($array); $i++){\n\
    \        if($array[$i] <= $first) return false;\n    }\n    return true;\n}\n\
    public static function monotonic_decreasing($array){\n    if(empty($array)) return\
    \ false;\n    $first = $array[0];\n    for($i=1; $i < count($array); $i++){\n\
    \        if($array[$i] >= $first) return false;\n    }\n    return true;\n}\n\
    </code>\n<|/ a dscore=4 |>\n<| c |>\nNice solution, though it requires PHP5.3.\n\
    <|/ c |>\n<| a tags=arrays,php,sorting dscore=4 |>\nYou can sort by first element\
    \ then by second element and so on, until the first element is not less than the\
    \ second one. \n<code>\n$array = array(10, 4, 20, 30, 2);\n", "  if (!is_array($l))\
    \ {\n    return FALSE;\n  }\n  // Sort the array numerically if numerically values\
    \ are allowed.\n  if (!array_filter($l)) {\n    sort($l);\n  }\n  $prev = null;\n\
    \  $prev_index = NULL;\n  $monotonic_found = FALSE;\n  foreach ($l as $key =>\
    \ $value) {\n    if ($prev !== null && $value < $prev) {\n      $monotonic_found\
    \ = TRUE;\n      $prev_index = $key;\n    }\n    $prev = $value;\n  }\n  return\
    \ $monotonic_found || ($prev_index !== NULL);\n}\n</code>\nThis will return TRUE\
    \ if all array values are monotonic (increasing/decreasing), or FALSE otherwise.\n\
    <|/ a dscore=5 tags=arrays,php,sorting |>\n<| c |>\nGreat answer, thank you sir.\
    \ \nAs an added benefit, you can add an argument to change what it means monotonic,\
    \ e.g. `$monotonic = FALSE` if you want it to behave as your question, `$monotonic\
    \ = TRUE` if you want it to be reversed, or whatever you like. :)\n<|/ c |>\n\
    <| c |>\nNice one, though I wouldn't suggest using a `global` if you don't need\
    \ it.\n<|/ c |>\n<| c |>\nGood point, you can make it local and use `$l` instead\
    \ of `global $l;`. I'll update the answer.\n<|/ c |>\n<| c |>\n+1 This is the\
    \ best answer I've seen. I had to do a search for this exact question, since I\
    \ wasn't sure if it existed before writing my own, but this answer really made\
    \ it all click in my head. Thank you so much! This should be the accepted answer.\n\
    <|/ c |>\n<| c |>\nYes, this should be the accepted answer as this solution is\
    \ more efficient, and it doesn't involve looping through the array twice.\n<|/\
    \ c |>\n<| a |>\nThe function below is what I use. Feel free to modify it as you\
    \ see fit. \n<code>", "\t$keys = array_keys($l);\n\t$last_key = array_pop($keys);\n\
    \t$decreasing = FALSE;\n\t$keys = array_reverse($keys);\n\tforeach($keys as $key)\
    \ {\n\t\t$current_value = $l[$key];\n\t\tif ($current_value === $last_value) {\n\
    \t\t\tcontinue;\n\t\t}\n\t\tif ($current_value > $last_value) {\n\t\t\t$l[$key]\
    \ = $last_value;\n\t\t\treturn FALSE;\n\t\t}\n\t\tif ($last_value >= 0) {\n\t\t\
    \t$l[$key] = $current_value;\n\t\t\treturn $decreasing ? FALSE : TRUE;\n\t\t}\n\
    \t\tif ($current_value < $last_value) {\n\t\t\t$decreasing = TRUE;\n\t\t}\n\t\t\
    $last_value = $current_value;\n\t}\n\tarray_unshift($keys, $last_key);\n\treturn\
    \ $decreasing ? FALSE : TRUE;\n}\n", "  $l = array_reverse($l);\n  $n = count($l);\n\
    \  for ($i = 0; $i < $n; ++$i) {\n    $current = $l[$i];\n    for ($j = $i + 1;\
    \ $j < $n; ++$j) {\n      if ($l[$j] < $current) {\n        if ($l[$i] <= $current)\
    \ {\n          return false;\n        }\n        if ($l[$j] <= $current) {\n \
    \         return true;\n        }\n      }\n    }\n  }\n  return true;\n}\n</code>\n\
    <|/ a dscore=5 tags=php,arrays |>\n<| c |>\nWorks great, but be careful! This\
    \ function doesn't work with multi dimentional arrays! It will count the arrays\
    \ as one array! You have to add another for to go through the array and check\
    \ the elements of the array!\n<|/ c |>\n<| c |>\nDoesn't work for multi-dimensional\
    \ arrays.\n<|/ c |>\n<| a dscore=5 |>\nIf you need to sort array elements and\
    \ don't need it to be in any particular order I prefer to use usort.\n<code>\n\
    <?php", "    $r = true;\n    $l = array_slice($l, 0, count($l));\n    foreach\
    \ ($l as $x) {\n        if ($x < $r) $r = false;\n    }\n    return $r;\n}\n",
  "    $l = array_slice($l);\n    sort($l);\n    return $l[0] <= $l[count($l)-1];\n\
    }\n\n/*\n * http://php.net/manual/en/function.is-sorted.php\n */", "    $l = $l\
    \ ? $l : array();\n\n    if ($l[0] > $l[1]) {\n        array_reverse($l);\n  \
    \  }\n    if ($l[0] == $l[1]) {\n        return true;\n    }\n\n    return false;\n\
    }\n", "\t$l = is_array($l) ? $l : array($l);\n\t$s = array();\n\tforeach ($l as\
    \ $k => $v) {\n\t\tif ($v > $s[$k] || $v < 0) {\n\t\t\t$s[$k] = $v;\n\t\t}\n\t\
    }\n\treturn $s[0] == $s[-1] ? 0 : ($s[0] > $s[-1] ? 1 : -1);\n}\n", "  if (!$l)\n\
    \    return true;\n\n  foreach ($l as $i => $x)\n    if (isset($l[$i - 1]) &&\
    \ isset($l[$i]))\n      if ($l[$i - 1] > $x)\n        return false;\n\n  return\
    \ true;\n}\n</code>\n<|/ a tags=php,arrays,sorting,compare |>\n<| a tags=php,arrays,sorting,compare\
    \ |>\n<code>\n$array1 = array(\n    0 => 1,\n    1 => 1,\n    2 => 2,\n    3 =>\
    \ 3,\n    4 => 4,\n    5 => 5,\n    6 => 6,\n    7 => 7,\n    8 => 7,\n    9 =>\
    \ 7,\n);\n\n$array2 = array(\n    0 => 1,\n    1 => 1,\n    2 => 2,\n    3 =>\
    \ 3,\n    4 => 4,\n    5 => 5,\n    6 => 6,\n    7 => 7,\n    8 => 7,\n    9 =>\
    \ 7,\n);\n\n$array3 = array(\n    0 => 2,\n    1 => 1,\n    2 => 2,\n    3 =>\
    \ 3,\n    4 => 4,\n    5 => 5,\n    6 => 6,\n    7 => 7,\n    8 => 7,\n    9 =>\
    \ 7,\n);\n\n$array4 = array(\n    0 => 5,\n    1 => 1,\n    2 => 2,\n    3 =>\
    \ 3,\n    4 => 4,\n    5 => 5,\n    6 => 6,\n    7 => 7,\n    8 => 7,\n    9 =>\
    \ 7,\n);\n\n$array5 = array(\n    0 => 6,\n    1 => 1,\n    2 => 2,\n    3 =>\
    \ 3,\n    4 => 4,\n    5 => 5,\n    6 => 6,\n    7 => 7,\n    8 => 7,\n    9 =>\
    \ 7,\n);\n\n$array6 = array(\n    0 => 7,\n    1 => 1,\n    2 => 2,\n    3 =>\
    \ 3,\n    4 => 4,\n    5 => 5,\n    6 => 6,\n    7 => 7,\n    8 => 7,\n    9 =>\
    \ 7,\n);\n\n$array7 = array(\n    0 => 8,\n    1 => 1,\n    2 => 2,\n    3 =>\
    \ 3,\n    4 => 4,\n    5 => 5,\n    6 => 6,\n    7 => 7,\n    8 => 7,\n    9 =>\
    \ 7,\n);\n\n$array8 = array(\n    0 => 9,\n    1 => 1,\n    2 => 2,\n    3 =>\
    \ 3,\n    4 => 4,\n    5 => ", "    $monotonic = false;\n    foreach ($l as $item)\
    \ {\n        if ($item < $l[0]) {\n            $monotonic = false;\n        }\
    \ elseif ($item > $l[count($l) - 1]) {\n            $monotonic = true;\n     \
    \   } else {\n            $monotonic = true;\n        }\n    }\n    return $monotonic;\n\
    }\n", "\t$l = is_array($l) ? $l : array($l);\n\t$s = array_shift($l);\n\tsort($l);\n\
    \treturn (array_pop($l) === $s);\n}\n", "  if (!is_array($l)) {\n    throw new\
    \ InvalidArgumentException(\n      sprintf('%s expects an array argument.', __METHOD__)\n\
    \    );\n  }\n\n  // Use the first element as a baseline.\n  $base = $l[0];\n\
    \  $base = array_shift($l);\n\n  // Check all other elements.\n  $rest = $l;\n\
    \  for ($i = 1; $i < count($l); ++$i) {\n    if ($rest[$i] < $base) {\n      return\
    \ false;\n    }\n\n    $base = $rest[$i];\n  }\n\n  return true;\n}\n", "  return\
    \ implode(':', $l) === implode(':', array_reverse($l));\n}\n\n$output = array();\n\
    foreach (explode(\" \", $argv[1]) as $sentence) {\n  $sentence = explode(\"\\\
    n\", $sentence);\n  $sentence = array_map('trim', $sentence);\n  if (count($sentence)\
    \ > 0) {\n    $output[] = $sentence;\n  }\n}\n\n$output = array_map(function($sentence)\
    \ {\n  return array_map(function($word) {\n    return strtolower(trim(strtoupper($word)));\n\
    \  }, $sentence);\n}, $output);\n\n$output = array_map(function($sentence) {\n\
    \  return array_filter($sentence, function($word) {\n    return ! in_array($word,\
    \ array(\"\\n\", \"\\r\", \"\\t\"));\n  });\n}, $output);\n", "    $l = $l ?:\
    \ array();\n    $n = count($l);\n\n    // Check for empty or null arrays.\n  \
    \  if (empty($l) || empty($l[0])) {\n        return false;\n    }\n\n    for ($i\
    \ = 0; $i < $n; ++$i) {\n        if ($l[$i] <= $l[$i - 1]) {\n            return\
    \ false;\n        }\n    }\n\n    return true;\n}\n</code>\n<|/ a tags=arrays,sorting,php\
    \ |>\n<| c |>\nthis would return false if $arr1 was null, try adding a `!empty`\
    \ before the return\n<|/ c |>\n<| c |>\n- It would return `FALSE`, which would\
    \ be the result of the `is_array` check. `$arr1` is an array, it isn't `null`.\n\
    <|/ c |>\n<| c |>\nmy bad, i meant this comment to someone else who has already\
    \ down voted my answer. my bad.\n<|/ c |>\n<| a dscore=3 tags=arrays,sorting,php\
    \ |>\nUse array_diff to find differences in array and then sort them:\n<code>\n\
    $array1 = array(1, 2, 4, 20);\n$array2 = array(1, 20, 4, 10);\n\n$diffs = array_diff($array1,\
    \ $array2);\nsort($diffs);\n</code>\n<|/ a |>\n<| c |>\n`array_diff()` is not\
    \ going to return monotonically increasing or decreasing arrays. See the example\
    \ in the question, `$diffs` will only contain one element (`20`).\n<|/ c |>\n\
    <| a tags=arrays,sorting,php |>\nYou can try this, it is simple and clean.\n<code>\n\
    $array1 = array(1, 2, 4, 20);\n$array2 = array(1, 20, 4, 10);\n\n$array3 = array_diff_usort($array1,\
    \ $array2);\n</code>\n<|/ a dscore=3 |>\n<| a tags=arrays,sorting,php |>\nYou\
    \ can use:\n<code>\n$result = $array1 + $array2;\nsort($result);\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\nThe downside of this is that it ignores the original\
    \ order.\n<|/ c |>\n<| c |>\nTrue. The OP didn't state that he needed the original\
    \ order.\n<|/ c |>\n<| c |>\nIt may or may not be relevant, but to anyone else\
    \ reading this that does care about order, you can use `array_merge` instead and\
    \ `sort()` afterwards.\n<|/ c |>\n<| a |>\n<code>\n<?php\n\n$arr1 = array(1, 2,\
    \ 4, 20);\n$arr2 = array", "    $s = array_shift($l);\n    if ($s) {\n       \
    \ do {\n            if ($s >= $l[0]) {\n                return true;\n       \
    \     }\n        } while (array_shift($l));\n    }\n    return false;\n}\n", "\t\
    $l = array_reverse($l);\n\t$first = $l[0];\n\tforeach ($l as $e) {\n\t\tif ($e\
    \ < $first) return true;\n\t\tif ($e > $first) return false;\n\t}\n\treturn false;\n\
    }\n", "    $l = $l ?: array();\n    $len = count($l);\n    $last_value = $first_value\
    \ = array_shift($l);\n    foreach ($l as $key => $value) {\n        if ($value\
    \ !== $last_value) {\n            if ($value > $last_value) {\n              \
    \  return false;\n            }\n            if ($last_value === $first_value\
    \ && $value > $value) {\n                return false;\n            }\n      \
    \  }\n        $last_value = $value;\n    }\n    return true;\n}\n", "  // Returns\
    \ true if $l is monotonically increasing,\n  // otherwise returns false. Assumes\
    \ $l is sorted.\n  return $l[0] <= $l[count($l)-1];\n}", "  $l = array_reverse($l);\n\
    \  $first = array_shift($l);\n  foreach ($l as $v) {\n    if ($v < $first) {\n\
    \      return false;\n    }\n    $first = $v;\n  }\n  return true;\n}\n", "  $l\
    \ = array_reverse($l);\n  return ($l[0] < $l[1] && $l[1] > $l[2] && $l[2] < $l[3]\
    \ && $l[3] < $l[0]);\n}", "  return is_array($l)\n         ? array_reduce($l,\
    \ function($result, $element) {\n           return is_numeric($element) ? $result\
    \ : !$result;\n         })\n         : $l != $l;\n}\n</code>\n<|/ a tags=php,arrays\
    \ |>\n<| a |>\nA quick and dirty way (without using any functions) would be to\
    \ use this:\n<code>\n$arr = array(1,2,4,20,100,200);\n$max = -1;\n$min = 100;\n\
    $n = count($arr);\n$i = 0;\nforeach($arr as $value) {\n    if ($value > $max)\
    \ {\n        $max = $value;\n    }\n    if ($value < $min) {\n        $min = $value;\n\
    \    }\n    if ($i == $n) {\n        $last = $value;\n        break;\n    }\n\
    \    $i++;\n}\nif ($i == $n) {\n    echo \"The min and max values where $min and\
    \ $max\";\n} else {\n    echo \"The min value was $min and the max value was $max\
    \ and the last value was $last\";\n}\n</code>\nThe above code will find the min\
    \ and max values of the array. If there are no values, it will return false and\
    \ if there are 2 or more values (it will return the last value).\nThis code isn't\
    \ very efficient but it will do the job.\n<|/ a dscore=0 tags=php,arrays |>\n\
    <| a |>\nMy short solution is this:\n<code>", "    if (count($l) === 0) {\n  \
    \      return false;\n    }\n    $l[] = $l[0];\n    for ($i = 1; $i < count($l);\
    \ $i++) {\n        if ($l[$i] <= $l[$i - 1]) {\n            return false;\n  \
    \      }\n    }\n    return true;\n}\n", "  return count($l) === count($l) ? true\
    \ :\n         array_reduce($l, function ($a, $b) {\n           $diff = $b - $a;\n\
    \           if ($diff > 0) {\n             return $b;\n           } else if ($diff\
    \ < 0) {\n             return $a;\n           } else {\n             return $diff\
    \ > 0 ? 1 : -1;\n           }\n         });\n}", "  $n = count($l);\n  $m = count($l)\
    \ - 1;\n  if ($n <= 1) return true;\n  for ($i = 0; $i <= $m; $i++) {\n    $v\
    \ = $l[$i];\n    if ($v <= $l[$m]) $v -= $l[$m];\n    if ($v < $l[$i]) $v += $l[$i];\n\
    \    if ($v !== $l[$i]) return false;\n  }\n  return true;\n}\n</code>\n<|/ a\
    \ dscore=4 tags=algorithm,arrays,php,sorting |>\n<| c |>\nGood answer, but I think\
    \ it misses the point of the question.  You aren't really comparing two arrays,\
    \ you are comparing two elements of the same array.  So this solution doesn't\
    \ work when the arrays are not sorted.\n<|/ c |>\n<| c |>\nThat's why I said \"\
    if the input array is sorted in ascending order.\"\n<|/ c |>\n<| c |>\nHi Jon,\
    \ can you please help me to understand what is the meaning of $a and $b. thanks\
    \ in advance\n<|/ c |>\n<| c |>\nThe variables are just temporary for comparing\
    \ against the current element in the array. The `$a` and `$b` variables are used\
    \ because the loop is being used as an iterator, which means it needs to have\
    \ a name and a value to compare against each time.\n<|/ c |>\n<| c |>\n: I got\
    \ this error Warning: sort() expects parameter 1 to be array, integer given in\
    \ /var/www/html/vacation/sortarray.php on line 8\n<|/ c |>\n<| a |>\nI think it\
    \ might be a little bit overcomplicated:\n<code>\n<?php\n$a = array(\n  'a' =>\
    \ 'foo',\n  'c' => 'bar',\n  'd' => 'qux',\n  'f' => 'rax',\n  'e' => 'moo',\n\
    \  'g' => 'oop',\n  'h' => 'ox'\n);\n\n$b = 'abcdefghijklmnopqrstuvwxyz'.str_split('a');\n\
    \n$result = array_intersect_key($a, array_flip($b));\n\nvar_dump($result);\n</code>\n\
    This also works for different sized arrays, e.g. it works on arrays of different\
    \ sizes :)\n<|/ a tags=algorithm,arrays,php,sorting dscore=3 |>\n<| c |>\nThis\
    \ doesn't work for me. Seems like it just takes the intersection of the two arrays\
    \ by index. I'm looking for an actual intersection. An array with the intersected\
    \ values from each array that have the same key.\n<|/ c |>\n", "  // http://en.wikipedia.org/wiki/Monotonic_function\n\
    \  return count($l) === count(array_filter($l, 'monotonic', ARRAY_FILTER_USE_BOTH));\n\
    }\n\n/**\n * Returns the elements of the specified array that do not exist in\
    \ any of the others.\n * Example:\n * >>> merge_unique([1, 1, 2, 2])\n * [1, 2,\
    \ 2]\n * >>> merge_unique([1, 1, 2, 2, 3, 3])\n * [1, 2, 3]\n */", "  $ln = count($l);\n\
    \  $t = 0;\n  for ($i = 0; $i < $ln; $i++) {\n    $t += ($l[$i][1] - $l[$i][0]);\n\
    \  }\n  return $t >= 0;\n}\n\n/**\n * Helper function to create submenu for breadcrumbs.\n\
    \ *\n * @param $items\n *   Array with items to build submenu for.\n * @param\
    \ $is_directory\n *   If true, items are shown as top-level items. Otherwise,\
    \ they are shown\n *   as submenus.\n */", "    if ($l instanceof Countable) {\n\
    \        $l = iterator_to_array($l);\n    }\n    $d = array_diff($l, $l[0]); //\
    \ Find increasing elements.\n    return ($d && count($d) === 1) || ($d && count($d)\
    \ === 0);\n}\n\n/**\n * Helper function for formatting log messages.  Creates\
    \ a textual list\n * of key => value pairs.\n *\n * @param array $items Items\
    \ to iterate.\n *\n * @return string A formatted string of the items.\n */", " \
    \ $l = array_values($l);\n  $diff = array_diff($l, array_unique($l));\n  if (empty($diff))\
    \ return true;\n  $count = count($diff);\n  for ($i = 0; $i < $count - 1; $i++)\
    \ {\n    $x = $diff[$i];\n    $y = $diff[$i + 1];\n    if ($x < $y) return false;\n\
    \    if ($x == $y) continue;\n    return ($x == ($y - 1));\n  }\n  return true;\n\
    }", "  if (!isset($l[0]))\n    return true;\n  $prev = reset($l);\n  if (!isset($l[-1]))\n\
    \    return false;\n  $next = end($l);\n  return $prev <= $next;\n}\n"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
