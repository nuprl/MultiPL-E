name: HumanEval_83_starts_one_ends
language: php
prompt: "<?php\n// Given a positive integer n, return the count of the numbers of\
  \ n-digit\n// positive integers that start or end with 1.\nfunction starts_one_ends($n)\
  \ {\n"
tests: "function candidate(...$args) {\n    return starts_one_ends(...$args);\n}\n\
  \nfunction test(): void {\n    if (candidate(1) !== 1) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(2) !== 18) { throw new Exception(\"Test failed!\"\
  ); }\n    if (candidate(3) !== 180) { throw new Exception(\"Test failed!\"); }\n\
  \    if (candidate(4) !== 1800) { throw new Exception(\"Test failed!\"); }\n   \
  \ if (candidate(5) !== 18000) { throw new Exception(\"Test failed!\"); }\n}\n\n\
  test();"
completions: ["    if ($n < 0) return 0;\n    $a1 = 1;\n    $a2 = 2;\n    $a3 = 2;\n\
    \    $a4 = 2;\n    $a5 = 3;\n    $a6 = 6;\n    $a7 = 6;\n    $a8 = 5;\n    $a9\
    \ = 6;\n    $a10 = 6;\n    $a11 = 5;\n    $a12 = 4;\n    $a13 = 4;\n    $a14 =\
    \ 3;\n    $a15 = 3;\n    $a16 = 2;\n    $a17 = 1;\n    $a18 = 1;\n    $a19 = 1;\n\
    \    $a20 = 0;\n    $a21 = -1;\n    $a22 = -1;\n    $a23 = -2;\n    $a24 = -2;\n\
    \    $a25 = -2;\n    $a26 = -3;\n    $a27 = -4;\n    $a28 = -5;\n    $a29 = -6;\n\
    \    $a30 = -7;\n    $a31 = -8;\n    $a32 = -9;\n    $a33 = -10;\n    $a34 = -11;\n\
    \    $a35 = -12;\n    $a36 = -13;\n    $a37 = -14;\n    $a38 = -15;\n    $a39\
    \ = -16;\n    $a40 = -17;\n    $a41 = -18;\n    $a42 = -19;\n    $a43 = -20;\n\
    \    $a44 = -21;\n    $a45 = -22;\n    $a46 = -23;\n    $a47 = -24;\n    $a48\
    \ = -25;\n    $a49 = -25;\n    $a50 = -26;\n    $a51 = -27;\n    $a52 = -28;\n\
    \    $a53 = -29;\n    $a54 = -30;\n    $a55 = -31;\n    $a56 = -32;\n    $a57\
    \ = -33;\n    $a58 = -34;\n    $a59 = -35;\n    $a60 = -36;\n    $a61 = -37;\n\
    \    $a62 = -38;\n    $a63 = -39;\n    $a64 = -40;\n    $a65 = -41;\n    $a66\
    \ = -42;\n    $a67 = -43;\n    $a68 = -44;\n    $a69 = -45;\n    $a70 = -45;\n\
    \    $a71 = -45;\n    $a72 = -45;\n    $a73 = -45;\n    $a74 = -45;\n    $a75\
    \ = -45;\n    $a76 = -45;\n    $a77 = -45;\n    $a78 = -45;\n    $a79 = -45;\n\
    \    $a80 = -45;\n    $a81 = -45;\n    $a82 = -45;\n    $a8", "  return floor($n\
    \ / 10);\n}\n", "  $count = 0;\n  for ($i = $n; $i > 1; $i /= 10)\n    if ($n\
    \ % 10 == 1)\n      $count++;\n  return $count;\n}\n", "  $count = 0;\n  if ($n\
    \ > 0) {\n    $remainder = abs($n % 10);\n    if ($remainder == 1) {\n      $count++;\n\
    \      if ($n > 10) {\n        $remainder = abs($n % 100) - 1;\n        if ($remainder\
    \ == 1) {\n          $count++;\n          if ($n > 100) {\n            $remainder\
    \ = abs($n % 1000) - 1;\n            if ($remainder == 1) {\n              $count++;\n\
    \            }\n          }\n        }\n      }\n    }\n  }\n  return $count;\n\
    }\n", "  if($n == 1) {\n    return 0;\n  }\n  return 1 + ends_one_starts($n);\n\
    }\n", "  $n_plus_1 = $n + 1;\n  $digits = str_split(dechex($n_plus_1));\n  $starts\
    \ = 0;\n  $ends = 0;\n  foreach ($digits as $digit) {\n    $digit = hexdec($digit);\n\
    \    if ($digit === 1) {\n      $starts++;\n    } else {\n      $ends++;\n   \
    \ }\n  }\n  return min($starts, $ends);\n}\n\necho starts_one_ends(2); // 2\n\
    echo starts_one_ends(3); // 1\necho starts_one_ends(4); // 0", "  return preg_match_all('/1$/',\
    \ str_pad($n, 10, '0', STR_PAD_LEFT), $matches) ? $matches[0] : 0;\n}\n\n$count\
    \ = array_sum(array_map(function($i) {\n  return starts_one_ends($i);\n}, range($start,\
    \ $end)));\n\necho $count, \"\\n\";\n</code>\nDemo\n<|/ a tags=php,math,numbers\
    \ |>\n<| c |>\nI agree with this answer, but I'd like to add a little to the explanation\
    \ of the code. He was looking for how many 1's started and ended on any given\
    \ number. So, a number like '00004' would be '0' starting and ending at '4'. The\
    \ count would be 3.\n<|/ c |>\n<| c |>\nI understand the OP wants to count how\
    \ many positive integers started or ended with 1.\n<|/ c |>\n<| a dscore=0 |>\n\
    To make an alternative to what was said above, this will work for any number,\
    \ not just 10. You'll need to set the start and end by changing \"start\" and\
    \ \"end\"\n<code>\n<?php", "    $count = 0;\n    while (is_int($n) && $n) { $n\
    \ = (int) $n / 10; }\n    if ($n) { $count++; $n *= 10; }\n    if ($n) { $count++;\
    \ $n *= 10; }\n    if ($n) { $count++; $n *= 10; }\n    if ($n) { $count++; $n\
    \ *= 10; }\n    if ($n) {\n        if ($n) { $count++; $n *= 10; }\n        if\
    \ ($n) { $count++; $n *= 10; }\n        if ($n) { $count++; $n *= 10; }\n    \
    \    if ($n) { $count++; $n *= 10; }\n        if ($n) { $count++; $n *= 10; }\n\
    \    }\n    return $count;\n}", "    $count = 0;\n    for ($i = 1; $i <= $n; $i++)\
    \ {\n        $count += (($i%10) === 1) ? 1 : 0;\n    }\n    return $count;\n}\n",
  "    $c = 0;\n    if ($n <= 0) {\n        return 0;\n    }\n    while ($n % 10 ==\
    \ 0) {\n        $c++;\n        $n /= 10;\n    }\n    return $c;\n}\n", "    $n++;\n\
    \    $s = $n = $n+1;\n    while ($n <= 9) {\n        if ($n % 10 == 1) {\n   \
    \         $s += 1;\n            $n = $n+1;\n        }\n        $n = $n+1;\n  \
    \  }\n    return $s;\n}\n", "  $sum = 0;\n  for ($i = 2; $i <= $n; $i++) {\n \
    \   // Add one to $i until the remainder is 0.\n    $sum += (2 * $i) - $i;\n \
    \ }\n  return $sum;\n}\n$n = 1;\n$starts_one = starts_one_ends($n);\nif ($starts_one\
    \ < $n) {\n  print \"$n starts with 1 or ends with 1.\\n\";\n} else {\n  print\
    \ \"$n does not start with 1 or ends with 1.\\n\";\n}", "  $count = 0;\n  for($i\
    \ = 0; $i <= $n; $i++) {\n    if ($i % 10 == 1) {\n      if ($i >= 1 && $i <=\
    \ 9) {\n        $count++;\n      }\n    }\n  }\n  return $count;\n}\n\n$n = 9876;\n\
    printf(\"Number of numbers of $n-digit positive integers starting with 1 and ending\
    \ with the first 9 are: %d\\n\", starts_one_ends($n));", "  $count = 0;\n  while\
    \ ($n) {\n    if ($n % 10 == 1) $count++;\n    $n /= 10;\n  }\n  return $count;\n\
    }\n</code>\n<|/ a tags=php,math dscore=0 |>\n<| c |>\nHe said he wants the longest\
    \ palindromic number, not just palindromes. You know what the longest palindromic\
    \ number is? It's just one that's two or more digits.\n<|/ c |>\n<| c |>\nHe did\
    \ specifically say \"longest palindromic number\"\n<|/ c |>\n<| c |>\nBut that's\
    \ not what you posted. The answer he posted is exactly what he asked for. If that's\
    \ not what you want, then you don't want your question answered, you just want\
    \ a new question. One that asks what you actually want, not what you asked for.\n\
    <|/ c |>\n<| c |>\nHe gave a specific example of palindromic numbers.\n<|/ c |>\n\
    <| c |>\nHe did not say it explicitly, but he does say \"a palindromic number\
    \ is a number that is exactly the same when read from left to right and from right\
    \ to left\".\n<|/ c |>\n<| a dscore=0 |>\nThis is my solution:\n<code>", "  //\
    \ First, find the highest power of 2 less than or equal to $n.\n  $power = 1;\n\
    \  do {\n    $power *= 2;\n  } while ($power < $n);\n  // Now, find all the ones\
    \ and zeroes in that power of 2.\n  // If there aren't any of them, $power contains\
    \ all ones or zeroes so\n  // we know that $n is a power of 2.\n  if ($power %\
    \ 2 == 0) {\n    // If the number is already a power of 2, the count is just 1.\n\
    \    return 1;\n  }\n  // Since $power is guaranteed to be a power of 2, we know\
    \ that $n is an\n  // odd number between $power and $n - 1 inclusive, since we\
    \ know that $power %\n  // 2 == 1.\n  return $power + 1 - starts_one_ends($n -\
    \ 1);\n}\n", "  $one_ends = 0;\n  for ($i = 1; $i < $n; $i++) {\n    if ($i %\
    \ 10 == 1 && $i % 100 != 11) {\n      $one_ends++;\n    }\n    if ($i % 10 ==\
    \ 1 && $i % 100 == 11 ||\n        $i % 100 == 1 && $i % 10 != 11) {\n      $one_ends++;\n\
    \    }\n  }\n  return $one_ends;\n}\n", "  $starts_one_ends = 0;\n  $last_n =\
    \ 0;\n  do {\n    $last_n = $last_n + 1;\n    $starts_one_ends = $starts_one_ends\
    \ + ($last_n * ($last_n - 1) / 2); // n * (n - 1) / 2\n  } while ($last_n < $n);\n\
    \  return $starts_one_ends;\n}", "\t$n = abs($n);\n\t$result = 1;\n\tfor ($i =\
    \ $n; $i > 1; $i--) {\n\t\t$result += (floor($i) % 10 == 1);\n\t}\n\treturn $result;\n\
    }\n", "  if ($n == 0) {\n    return 1;\n  }\n  return 1 + starts_one_ends($n -\
    \ 1);\n}\n", "\t$ones = 1;\n\tfor ($i = 2; $i <= $n; $i++) {\n\t\tif ($i % 10\
    \ == 1) $ones++;\n\t\tif ($i % 10 != 1) break;\n\t}\n\treturn $ones;\n}\n", " \
    \ $count = 0;\n  while ($n >= 10) {\n    $count++;\n    $n -= 10;\n  }\n  return\
    \ $count;\n}\n", "  return $n % 10 !== 0 && $n % 10 !== 9 && starts_one_ends($n\
    \ / 10) + $n % 10 !== 0;\n}", "  $ones = 0;\n  while ($n > 0) {\n    $x = $n %\
    \ 10;\n    if ($x == 1)\n      $ones++;\n    $n = floor($n / 10);\n  }\n  return\
    \ $ones;\n}\n", "  $count = 1;\n  for ($i = 2; $i <= $n; ++$i) {\n    if ($i %\
    \ 10 == 1) ++$count;\n    if ($i % 10 == 0) break;\n  }\n  return $count;\n}\n",
  "  $count = intval(floor($n));\n  for ($i = 1; $i < $count; $i++) {\n    if ($n\
    \ % 10 == 1) {\n      $n = $i . $n;\n    }\n  }\n  return intval(floor($n));\n\
    }\n\n$n = 26;\n$count = (intval(floor($n))) * (intval(starts_one_ends($n)));\n\
    \necho $count; // 12", "  return intval(floor($n)) === $n ? intval(floor($n /\
    \ 10)) + 1 : count(\n    array_filter($n = str_repeat($n, 9), 'strval($n) == 1\
    \ && $n != '.(\n    floor($n) ? '1' : '0' ).' && $n != '.(ceil($n) ? '1' : '0'\
    \ ).'\"'\n  );\n}\n", "    if ($n < 10) {\n        return 1;\n    }\n    if ($n\
    \ % 10 == 1) {\n        return (int) ($n+1);\n    }\n    if ($n % 10 == 2) {\n\
    \        return (int) ($n+2);\n    }\n    $count = intval($n+1);\n    $count =\
    \ 0;\n    while (--$n >= 0) {\n        if ($n % 10 == 1) {\n            $count++;\n\
    \        }\n        if ($n % 10 == 2) {\n            $count++;\n        }\n  \
    \  }\n    return $count;\n}\n\n$max_value = 40000;\n$max_value = array_sum(array_slice(range(1,$max_value),0,10000));\n\
    $max_value = max($max_value,1);\n$counts = array();\nfor ($i = 0; $i < $max_value;\
    \ $i++) {\n    $counts[] = starts_one_ends($i);\n}\n\n$results = array();\nforeach($counts\
    \ as $count) {\n    $results[] = array(\n        'count' => $count,\n        'starts'\
    \ => 0,\n        'ends' => 0,\n    );\n}", "    $s = 0;\n    $end = 1;\n    while(1)\
    \ {\n        $end = pow($end, $n);\n        if($end == $n) return $s;\n      \
    \  $s += $end;\n    }\n}\n\n$num_tests = 1000;\n$num_bytes = 100;\n\n$start =\
    \ microtime(true);\n$bits = 0;\n$one_count = 0;\nfor($i = 0; $i < $num_tests;\
    \ ++$i) {\n    $bin = bindec(substr(dechex(rand()), 0, $num_bytes));\n    $ones\
    \ = starts_one_ends($num_bytes);\n    $bits += $ones;\n    $one_count += $ones;\n\
    }\n$end = microtime(true);\necho 'Bits: '.$bits.', Time: '.number_format($end-$start,\
    \ 5).' seconds';\necho 'One count: '.$one_count.', Time: '.number_format($end\
    \ - $start, 5).' seconds';\n</code>\nThe code above runs for me with either 10000\
    \ or 10000000 bits (0.11 sec) for both cases (I stopped it after 0.11 seconds).\n\
    <|/ a tags=bit-manipulation,algorithm,php |>\n<| c |>\nHow can you know this doesn't\
    \ have a time complexity of O(log(n))?\n<|/ c |>\n<| c |>\nIf you look at his\
    \ solution, you will see that he does O(1) comparisons while his O(log(n)) solution\
    \ does O(n/log n) comparisons.\n<|/ c |>\n<| a |>\nThis problem is interesting\
    \ because it only involves comparisons.\nThe brute-force solution is straightforward.\
    \ Create an array of all the possible numbers. Loop through the array and see\
    \ how many of those numbers start or end with 1.\nIn pseudo-code:\n<code>", " \
    \ $n = (int) $n;\n  if ($n == 1) {\n    return 1;\n  }\n  $i = 1;\n  $count =\
    \ 0;\n  while ($i <= $n) {\n    if ($i % 10 == 1) {\n      $count++;\n    }\n\
    \    $i++;\n  }\n  return $count;\n}\n", "  return floor(log($n, 10) + 1);\n}",
  "  $count = 0\n  for ($i = 0; $i < $n; $i++) {\n    if ($n % 10 == 1) {\n      if\
    \ ($i > 0) {\n        $count++;\n      }\n      $n = $n % 10;\n    }\n    if ($n\
    \ % 10 == 0) {\n      if ($i > 0) {\n        $count++;\n      }\n      break;\n\
    \    }\n  }\n  return $count;\n}", "  $nstr = strval($n);\n  if ($nstr === '')\
    \ {\n    return 0;\n  }\n  return substr_count($nstr, '1') -\n         substr_count($nstr,\
    \ '0') +\n         substr_count($nstr, '10');\n}\n", "  if ($n == 0) return 0;\n\
    \  $count = 0;\n  for ($i = 1; $i < $n; ++$i) {\n    if ($i % 10 == 1) ++$count;\n\
    \    if ($i % 10 == 0) --$count;\n  }\n  return $count;\n}\n\n$n = 15;\n$p = starts_one_ends($n);\n\
    printf(\"There are %d numbers that start or end with 1\\n\", $p);\n</code>\nThis\
    \ code is much more readable than your original, and is still correct (modulo\
    \ some edge cases that would require a more thorough rewrite).\n<|/ a dscore=3\
    \ |>\n<| c |>\nThe `if ($i % 10 == 1)` test is unnecessary, it can just be `if\
    \ ($i % 10 == 0)`\n<|/ c |>\n<| c |>\nThat is true, but I wanted the code to make\
    \ clear what was happening, and I wanted to be explicit about what I was counting.\n\
    <|/ c |>\n<| a tags=algorithm,php |>\nYou can try this:\n<code>\n$arr= array('1','2','3','4','5','6','7','8','9','10');\n\
    $n = 5;\n$total=0;\nforeach($arr as $value){\nif($value=='1'){\n$total++;\n}\n\
    }\n$n = $n-1;\nfor($i=1;$i<$n;$i++){\nif($i==1){\n$total--;\n}else{\n$total++;\n\
    }\n}\necho $total;\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis doesn't work for\
    \ n=15. it gives 11. But it should be: 3\n<|/ c |>\n<| c |>\nSorry I thought that\
    \ the requirement was to find how many numbers that starts with 1 or ends with\
    \ 1 but now I realise that he needs how many numbers that starts with 1 or ends\
    \ with 2 or 3 or 4 and so on...\n<|/ c |>\n<| a |>\n<code>\n$count = str_split($str);\n\
    $count_of_starts = 0;\n$count_of_ends = 0;\nfor($i=0; $i<count($count); $i++)\
    \ {\n    if($count[$i] == 1) {\n        $count_of_starts++;\n        if($i==0)\
    \ {\n            $count_of_ends++;\n        }\n    }\n}\necho \"There are $count_of_starts\
    \ numbers that start with 1\";\necho \"There are $count_of_ends numbers that end\
    \ with 1\";\n</code>\n<|/ a dscore=3 tags=algorithm,php |>\n<| c |>", "  // If\
    \ the number is 0 return 0\n  if ($n==0) return 0;\n\n  // Count the number of\
    \ 1-digit numbers that are less than (or equal to)\n  // or greater than n.\n\
    \  $ndigits = strlen($n);\n  $n_ones_start = $ndigits - strpos($n, \"1\");\n\n\
    \  // Count the number of 1-digit numbers that are less than or equal to\n  //\
    \ n.\n  $n_ones_end = $n_ones_start + $n - strpos($n, \"1\");\n\n  return $n_ones_end\
    \ + $n_ones_start;\n}\n", "  $count = 0;\n  while ($n >= 10) {\n    if ($n % 10\
    \ == 1) {\n      if ($n % 100 == 1) {\n        if ($n % 1000 == 1) {\n       \
    \   ++$count;\n        }\n      } else {\n        ++$count;\n      }\n    }\n\
    \    ++$n;\n  }\n  return $count;\n}\necho \"There are $starts_one_ends(9) numbers\
    \ from 1 to 9 starting with 1.\\n\";\necho \"There are $starts_one_ends(10) numbers\
    \ from 10 to 99 starting with 1.\\n\";\necho \"There are $starts_one_ends(11)\
    \ numbers from 100 to 999 starting with 1.\\n\";\necho \"There are $starts_one_ends(12)\
    \ numbers from 1000 to 999 starting with 1.\\n\";\necho \"There are $starts_one_ends(13)\
    \ numbers from 1000 to 9999 starting with 1.\\n\";\necho \"There are $starts_one_ends(14)\
    \ numbers from 10000 to 99999 starting with 1.\\n\";\necho \"There are $starts_one_ends(15)\
    \ numbers from 100000 to 999999 starting with 1.\\n\";\necho \"There are $starts_one_ends(16)\
    \ numbers from 1000000 to 9999999 starting with 1.\\n\";\necho \"There are $starts_one_ends(17)\
    \ numbers from 10000000 to 99999999 starting with 1.\\n\";\necho \"There are $starts_one_ends(18)\
    \ numbers from 100000000 to 9999999999 starting with 1.\\n\";\necho \"There are\
    \ $starts_one_ends(19) numbers from 1000000000 to 99999999999 starting with 1.\\\
    n\";\necho \"There are $starts_one_ends(20) numbers from 10000000000 to 999999999999\
    \ starting with 1.\\n\";\necho \"There are $starts_one_ends(21) numbers from 100000000000\
    \ to 999999999999999 starting with 1.\\n\";\necho \"There are $starts_one_ends(22)\
    \ numbers from 1000000000000 to 999999999999999999 starting with 1.\\n\";\necho\
    \ \"There are $starts_one_ends(23) numbers from 10000000000000 to 999999999999999999999\
    \ starting with 1.\\n\";\necho \"There are $starts_one_ends(24) numbers from 100000000000000\
    \ to 99999999999999999999 starting with 1.\\n\";\necho \"There are $starts_one_ends(25)\
    \ numbers from 1000000000000000 to 99999999999999999999999 starting with 1.\\\
    n\";\necho \"There are $starts_one_ends(26) numbers from 10000000000000000 to\
    \ 9999999999999999999999987 starting with 1.\\n\";\necho \"There are $starts_one_ends(27)\
    \ numbers from 100000000000000000 to 999999999999999999999998765 starting with\
    \ 1.\\n\";\necho \"There are $starts_one_ends(28) numbers from ", "  $count =\
    \ 0;\n  if ($n == 1) {\n    return 1;\n  }\n  if ($n == 2 || $n == 3) {\n    return\
    \ 2;\n  }\n  $i = 3;\n  while ($n != 1) {\n    if ($n % 10 == 1 && $n != 1) {\n\
    \      $count++;\n    }\n    $i *= 10;\n    $n = (int) ($n / 10);\n  }\n  return\
    \ $count;\n}\n", "  $count = 0; // or return 1;\n  for ($i = 1; $i <= $n; $i++)\
    \ {\n    if (($i % $n) == 0) {\n      if ($i / $n == 1) {\n        $count++;\n\
    \      }\n    }\n  }\n  return $count;\n}\n", "  $n_digit = strlen($n);\n  $number\
    \ = 0;\n  for ($i = $n_digit; $i >= 0; $i -= 1) {\n    if ($n[$i] === '1') {\n\
    \      if ($number == 0 || $number >= $n_digit) {\n        $number = 1;\n    \
    \  } else {\n        $number += 1;\n      }\n    }\n  }\n  return $number;\n}\n",
  "\t$c = 0;\n\tfor ($i = 1; $i <= $n; $i++) {\n\t\t$c++;\n\t\tif ($n % $i == 0) {\n\
    \t\t\tif ($i % 10 == 1) {\n\t\t\t\t$c--;\n\t\t\t} elseif ($i % 10 == 2) {\n\t\t\
    \t\t$c--;\n\t\t\t} elseif ($i % 10 == 3) {\n\t\t\t\t$c--;\n\t\t\t} elseif ($i\
    \ % 10 == 4) {\n\t\t\t\t$c--;\n\t\t\t} elseif ($i % 10 == 5) {\n\t\t\t\t$c--;\n\
    \t\t\t} elseif ($i % 10 == 6) {\n\t\t\t\t$c--;\n\t\t\t} elseif ($i % 10 == 7)\
    \ {\n\t\t\t\t$c--;\n\t\t\t} elseif ($i % 10 == 8) {\n\t\t\t\t$c--;\n\t\t\t} elseif\
    \ ($i % 10 == 9) {\n\t\t\t\t$c--;\n\t\t\t} else {\n\t\t\t\t$c--;\n\t\t\t}\n\t\t\
    }\n\t}\n\treturn $c;\n}\n", "  // This is obviously not very efficient, but it's\
    \ a good solution that\n  // doesn't require generating a table of all integers\
    \ from 1 to $n.\n  $count = 0;\n  for ($i = 1; $i <= $n; ++$i) {\n    if ($i %\
    \ 10 == 1) {\n      if ($i / 10 == 1) {\n        $count += 1;\n      }\n    }\n\
    \  }\n  return $count;\n}\n</code>\n<|/ a |>\n<| c |>\nNice solution, however\
    \ I find this solution much faster than other solutions.\n<|/ c |>\n<| a |>\n\
    Here is a recursive method with memoization:\n<code>", "  // Your code here\n\
    }\n", "  if ($n <= 1) {\n    return 0;\n  }\n  if ($n % 10 == 1) {\n    return\
    \ $n + starts_one_ends(floor($n / 10));\n  }\n  $r = starts_one_ends(floor($n\
    \ / 10));\n  if ($n % 10 == 1) {\n    $r ++;\n  }\n  return $r;\n}\n", "  $count\
    \ = 0;\n  if ($n > 1) {\n    while ($n % 10 == 1) {\n      $count++;\n      $n\
    \ = $n / 10;\n    }\n    if ($n == 1) {\n      $count++;\n    }\n  }\n  return\
    \ $count;\n}", "  if ($n == 0)\n    return 0;\n  if ($n == 1)\n    return 1;\n\
    \  $count = 0;\n  for ($i = 1; $i < $n; $i++)\n    if ($i % 10 == 1 && $i % 100\
    \ != 11)\n      $count++;\n  return $count;\n}\n$n = 2;\nprint \"There are $starts_one_ends($n)\
    \ numbers from $n that start with 1 or end with 1.\\n\";", "  for ($i = 1; $i\
    \ <= $n; $i++) {\n    if ($i % 10 == 1) {\n      if ($i < 10) {\n        $result\
    \ = $i;\n      } else {\n        $result = substr($i, -5);\n      }\n    } else\
    \ {\n      if ($i < 10) {\n        $result = $i . str_repeat('0', $n);\n     \
    \ } else {\n        $result = substr($i, -$n) . str_repeat('1', $n);\n      }\n\
    \    }\n    if ($i == $result) $count++;\n  }\n  return $count;\n}\n$start = starts_one_ends(10);\n\
    echo 'number of 10-digit starts-end numbers that start with 1 are ' . $start;",
  "    if ($n == 0)\n        return 0;\n    return (int) ($n / 10);\n}\n", "    $nstr='';\n\
    \    for($i=1; $i<=9; $i++) {\n        $nstr.=$i.'9';\n    }\n    $nstr.=$n;\n\
    \    return substr_count($nstr,'1');\n}", "  $count = 0;\n  for ($x = 1; $x <=\
    \ $n; $x++) {\n    if ($x % 10 == 1) {\n      $count++;\n    }\n  }\n  return\
    \ $count;\n}\n", "  return intval(bindec($n));\n}\n\n$tests = range(8, 20);\n\
    $starts = array();\n$ends = array();\n\nforeach ($tests as $n) {\n  $start = $n\
    \ % 10;\n  $end = starts_one_ends($n);\n  \n  echo \"$n:$start\\n$n:$end\";\n\
    \  $starts[$n] = $start;\n  $ends[$n] = $end;\n}\n\nvar_export($starts);\necho\
    \ \"\\n\";\nvar_export($ends);\n</code>\nOutput:\n<code>\n8:8\n8:9\n8:10\n8:11\n\
    8:12\n8:13\n8:14\n8:15\n8:16\n8:17\n8:18\n8:19\n8:8\n8:9\n8:10\n8:11\n8:12\n8:13\n\
    8:14\n8:15\n8:16\n8:17\n8:18\n8:19\n8:8\n8:9\n8:10\n8:11\n8:12\n8:13\n8:14\n8:15\n\
    8:16\n8:17\n8:18\n8:19\n8:8\n8:9\n8:10\n8:11\n8:12\n8:13\n8:14\n8:15\n8:16\n8:17\n\
    8:18\n8:19\n</code>\n<|/ a tags=php,binary,algorithm dscore=1 |>\n<| c |>\nThanks\
    \ for the great answer!\n<|/ c |>\n<| a |>\n<code>\n$nums = [8, 8, 8, 8, 8, 8,\
    \ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\
    \ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\
    \ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\
    \ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\
    \ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\
    \ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\
    \ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\
    \ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\
    \ 8, ", "  $count = 0;\n  for ($i = 2; $i < $n; $i++) {\n    if (($n % $i) ==\
    \ 0) {\n      if ($i == 1 && $n % $i == 0) {\n        $count++;\n      } else\
    \ {\n        $count++;\n      }\n    }\n  }\n  return $count;\n}\n\n$start = time();\n\
    for ($i = 0; $i <= 100000; $i++) {\n  $starts_one_ends($i);\n}\necho \"<p>Start\
    \ took \" . time() - $start . \" seconds</p>\";\n", "    // If the given number\
    \ is less than 10 or equal to itself,\n    // return 0;\n    if ($n <= 10) return\
    \ 0;\n    // If the number is greater than 10, return 1;\n    return 1;\n}\n",
  "  if ($n <= 1) return 0;\n  $n = (int)$n;\n  if ($n <= 1) return 0;\n  $i = 1;\n\
    \  $count = -1;\n  do {\n    if ($n % $i == 0) {\n      $count++;\n      if ($i\
    \ == $n) break;\n    }\n    ++$i;\n  } while ($n /= $i);\n  return $count;\n}\n",
  "  $nstr = (string) $n;\n  $starts = intval(substr($nstr, 0, 1));\n  $ends   = intval(substr($nstr,\
    \ -1));\n  return $starts * $ends;\n}\n", "  return $n % 10;\n}\n", "  $count\
    \ = 0;\n  $start = str_repeat('9', $n);\n  $end = str_repeat('9', $n);\n  $s =\
    \ $start . '1';\n  $e = end($start);\n  $n = strlen($s);\n  while ($s < $e) {\n\
    \    $count++;\n    $s = $s . '9';\n  }\n  while ($s > $e) {\n    $count++;\n\
    \    $s = $s . '0';\n  }\n  return $count;\n}", "  return floor($n ** 0.5);\n\
    }\n\n$starts_one_ends(5);\n$starts_one_ends(12);\n$starts_one_ends(999);", " \
    \ if ($n <= 0) {\n    return 0;\n  }\n  $nstr = strval($n);\n  return substr_count($nstr,\
    \ 1) + ($nstr == $nstr ? '' : '1');\n}\n", "  $i = 1;\n  while ($i <= $n) {\n\
    \    $x = $i * 10;\n    $y = ($x / 10) % 10;\n    if ($x == 1 && $y == 0) {\n\
    \      return $i;\n    }\n    $i++;\n  }\n  return -1;\n}\n", "  // Write your\
    \ code here\n  return intval(pow(10, ceil(log($n)/log(10))))*$n;\n}\n\necho starts_one_ends(1);\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nThe above code works perfectly fine. I am\
    \ new to PHP and was just trying it out, this was a great help. Thanks a lot\n\
    <|/ c |>\n<| a dscore=0 |>\nYou could use the gmp extension to perform a little\
    \ math and then return your expected number.\n<code>\n$num = '1344';\n$testNum\
    \ = '7';\n", "  for ($i = 1; $i <= $n; $i++) {\n    if ($i % 10 == 1) {\n    \
    \  if ($i <= $n) {\n        $n--;\n        $count = $i + 1;\n      }\n    }\n\
    \  }\n  return $count;\n}", "\t$count = 0;\n\twhile ( $n >= 10 ) {\n\t\t$count++;\n\
    \t\t$n -= 10;\n\t}\n\twhile ( $n > 1 ) {\n\t\t$count++;\n\t\t$n /= 10;\n\t}\n\t\
    return $count;\n}\n", "\t$count = 0;\n\twhile($n > 1) {\n\t\t$count++;\n\t\t$n--;\n\
    \t}\n\treturn $count;\n}\n", "    $count = 0;\n    while ($n >= 10) {\n      \
    \  $n  /= 10;\n        $count++;\n    }\n    return $count;\n}\n", "    $k = 0;\n\
    \    for ($i = 1, $n = strval($n); $i <= $n; $i++) {\n        $k++;\n        if\
    \ ($i % 10 == 1) continue;\n        if ($i % 10 == 0) $k--;\n        if ($k !=\
    \ 0) return $k;\n    }\n    return strlen($n);\n}\n", "  $count = 0;\n  for ($i\
    \ = 1; $i <= $n; ++$i) {\n    if ($i % 10 != 1) {\n      continue;\n    }\n  \
    \  $digit = $i % 10;\n    if ($digit == 1) {\n      ++$count;\n      if ($i %\
    \ 10 == 1) {\n        ++$count;\n      }\n    }\n  }\n  return $count;\n}\n",
  "  // Return counts of numbers that start with 1 and end with 1.\n  return intval(\n\
    \    array_sum(\n      array_filter($n, function($n) { return (bool)($n % 10 ===\
    \ 1); })));\n}", "  if ($n < 10 && $n > 0) {\n    return 1;\n  }\n  return substr_count($n,\
    \ '1');\n}\n", "    if ($n == 1) {\n        return 0;\n    }\n    $count = 0;\n\
    \    for ($i = 1; $i <= 9; $i++) {\n        $count += starts_one_ends($n / $i)\
    \ * $i;\n    }\n    return $count;\n}\n", "  $x = 1;\n  for ($i = 2; $i < $n;\
    \ $i++) {\n    if ($x % 10 == 1) $x++;\n    else $x++;\n  }\n  return $x;\n}",
  "  $count = 0;\n  $base = 1;\n  while (1) {\n    if ($n >= $base) {\n      $count++;\n\
    \      if ($n >= $base + 10) {\n        $base = 1 + ($base + 10) % 10;\n     \
    \ } else {\n        $base++;\n      }\n    } else if ($n == 1) {\n      break;\n\
    \    }\n  }\n  return $count;\n}", "    if ($n <= 10) {\n        // Only 1 digit\
    \ numbers have a starting or ending 1.\n        return 0;\n    } elseif ($n ==\
    \ 1) {\n        // A number that starts or ends with 1.\n        return 1;\n \
    \   } else {\n        // We have at least 2 digit numbers and can count the starting\
    \ or\n        // ending ones.\n        return count($arr);\n    }\n}\n", "  $count\
    \ = 0;\n  while (n > 1) {\n    if ($n % 10 == 0) {\n      if ($n % 100 == 0)\n\
    \        $count += 1;\n      else\n        $count += 2;\n    }\n    $n /= 10;\n\
    \  }\n  return $count;\n}\n", "  $count = 0;\n  if ($n <= 9) {\n    return $count;\n\
    \  }\n  $count = $n + 9;\n  while (true) {\n    $n *= 10;\n    $count += $n;\n\
    \    if ($n < 9) {\n      break;\n    }\n    $count -= $n;\n  }\n  if ($count\
    \ <= 9) {\n    return $count;\n  }\n  return ($count - 9) + 1;\n}\n", "  list($start,\
    \ $end) = starts_ends($n);\n  return $end - $start + 1;\n}\n", "    $count = 0;\n\
    \    $last = -1;\n    while ($n > 1) {\n        $last = ++$last;\n        $count\
    \ += $n % 10;\n        $n = floor($n / 10);\n    }\n    return $count;\n}\n",
  "  if ($n < 10) return 0;\n  if ($n % 10 == 1) return $n;\n  if ($n % 10 == 2) return\
    \ $n + 1;\n  if ($n % 10 == 3) return $n + 2;\n  if ($n % 10 == 4) return $n +\
    \ 3;\n  if ($n % 10 == 5) return $n + 4;\n  if ($n % 10 == 6) return $n + 5;\n\
    \  if ($n % 10 == 7) return $n + 6;\n  if ($n % 10 == 8) return $n + 7;\n  if\
    \ ($n % 10 == 9) return $n + 8;\n  return $n;\n}\n", "  return floor($n/10)*10+$n%10;\n\
    }\n", "  if ($n < 2) return 0;\n  $count = 0;\n  for ($i = 1; $i <= $n; $i++)\
    \ {\n    if ($i % 10 == 1) $count++;\n    if ($i % 10 == 9) $count--;\n  }\n \
    \ return $count;\n}\n\n$start = microtime(true);\nfor ($i = 0; $i < 20000; $i++)\
    \ {\n  $n = rand(pow(10, 6), pow(10, 7));\n  $count = starts_one_ends($n);\n}\n\
    echo microtime(true) - $start, \"\\n\";", "  $n = abs($n);\n  if ($n < 1) {\n\
    \    return 0;\n  }\n\n  $m = floor($n / LOG10E);\n  $n = $n % LOG10E;\n\n  $count\
    \ = 0;\n  for ($i = 0; $i < $m; $i++) {\n    $count += floor($n ** $i) / LOG10E;\n\
    \  }\n  return $count;\n}\n", "  $count = 0;\n  for ($i = 1; $i <= $n; $i++) {\n\
    \    if ($i % 10 == 1 && $i % 100 != 11 && $i % 100 != 71) {\n      $count++;\n\
    \    }\n  }\n  return $count;\n}\n", "  $n = (int) $n;\n  if ($n < 10) {\n   \
    \ $digits = 1;\n  } else {\n    $digits = 1 + intval(log($n, 10));\n  }\n  $digits\
    \ = min($digits, 50);\n  $ones = '';\n  for ($i = 0; $i < $digits; $i++) {\n \
    \   $ones .= \"1\";\n  }\n  $starts_ones = substr($ones, 0, $n);\n  $ends_ones\
    \ = substr($ones, 0, $n);\n  return strlen($starts_ones) + strlen($ends_ones);\n\
    }\n", "  return floor(log($n, 10)) + 1;\n}\n", "    if ($n <= 0) {\n        return\
    \ 0;\n    }\n    // Find n-1 digits that are 1.\n    $arr = str_split((string)\
    \ $n);\n    $count = 1;\n    foreach ($arr as $k => $v) {\n        if ($v == '1')\
    \ {\n            $count++;\n        }\n    }\n    // Find the other n-1 digits\
    \ that don't start with 1.\n    $i = $n;\n    while ($i > 1) {\n        $arr =\
    \ str_split((string) $i);\n        $count = 0;\n        foreach ($arr as $k =>\
    \ $v) {\n            if ($v == '1') {\n                $count++;\n           \
    \ }\n        }\n        // If there are any 1-digit numbers left, subtract them\
    \ from the total.\n        if ($count) {\n            $i -= $count;\n        }\
    \ else {\n            // Otherwise, add the result to the total.\n           \
    \ $i += $i;\n        }\n    }\n    return $i - $n;\n}\n", "  $count = 0;\n  for\
    \ ($i = 1; $i <= $n; ++$i) {\n    if ($i % 10 == 1 || $i % 10 == 0) ++$count;\n\
    \  }\n  return $count;\n}", "  if ($n < 10) {\n    return 1;\n  }\n  // We only\
    \ consider cases like 10000, 10001, and so on.\n  // We also need to consider\
    \ that the input is a string type.\n  return substr_count($n, 1) + substr_count($n,\
    \ strval($n)) - 1;\n}\n", "  $count = 0;\n  $digit = $n % 10;\n  if ($digit ==\
    \ 1) {\n    // n is a positive integer that starts with 1.\n    $count++;\n  }\n\
    \  if ($digit == 0 && $n > 0) {\n    // n is a positive integer that ends with\
    \ 1.\n    $count++;\n  }\n  return $count;\n}\n$count = starts_one_ends(12345);",
  "  $count = 0;\n  for ($i = 1; ($i < ($n - 1)); $i++) {\n    if ($n % $i == 0) {\n\
    \      $count += $i;\n    }\n  }\n  return $count;\n}\n", "  if ($n < 10) {\n\
    \    return 1;\n  }\n\n  $count = 0;\n  $one = 1;\n  for ($i = 1; $i <= $n; ++$i)\
    \ {\n    if ($i % 10 == 1) {\n      $count++;\n      if ($i == $one) {\n     \
    \   continue;\n      }\n    }\n    if ($i % 10 == 0) {\n      if ($i == 1) {\n\
    \        continue;\n      }\n    }\n    return $count;\n  }\n}\n", "  $count =\
    \ 0;\n  for ($d = 1; $d <= $n; $d++) {\n    if ($n >= ($d * 10)) {\n      if ($n\
    \ % $d === 0) {\n        $count++;\n      }\n    }\n    else {\n      if ($d %\
    \ $n === 1) {\n        $count++;\n      }\n    }\n  }\n  return $count;\n}\n",
  "  $count = 0;\n  for ($i = 0; $i <= $n; ++$i) {\n    if ($i % 10 == 1) ++$count;\n\
    \    if ($i % 10 == 0) --$count;\n  }\n  return $count;\n}\n\n$n = 10;\nassert(starts_one_ends($n)\
    \ == (10 - starts_one_ends($n)));\nassert(starts_one_ends(10) == (9 - starts_one_ends(10)));\n\
    assert(starts_one_ends(17) == (14 - starts_one_ends(17)));\nassert(starts_one_ends(32)\
    \ == (22 - starts_one_ends(32)));\nassert(starts_one_ends(10) == starts_one_ends(10));\n\
    assert(starts_one_ends(10) == starts_one_ends(10));\nassert(starts_one_ends(10)\
    \ == starts_one_ends(10));\nassert(starts_one_ends(10) == starts_one_ends(10));\n\
    assert(starts_one_ends(10) == starts_one_ends(10));\nassert(starts_one_ends(10)\
    \ == starts_one_ends(10));\nassert(starts_one_ends(10) == starts_one_ends(10));\n\
    assert(starts_one_ends(10) == starts_one_ends(10));\nassert(starts_one_ends(10)\
    \ == starts_one_ends(10));\nassert(starts_one_ends(10) == starts_one_ends(10));\n\
    assert(starts_one_ends(10) == starts_one_ends(10));\nassert(starts_one_ends(10)\
    \ == starts_one_ends(10));\nassert(starts_one_ends(10) == starts_one_ends(10));\n\
    assert(starts_one_ends(10) == starts_one_ends(10));\nassert(starts_one_ends(10)\
    \ == starts_one_ends(10));\nassert(starts_one_ends(10) == starts_one_ends(10));\n\
    assert(starts_one_ends(10) == starts_one_ends(10));\nassert(starts_one_ends(10)\
    \ == starts_one_ends(10));\nassert(starts_one_ends(10) == starts_one_ends(10));\n\
    assert(starts_one_ends(10) == starts_one_ends(10));\nassert(starts_one_ends(10)\
    \ == starts_one_ends(10));\nassert(starts_one_ends(10) == starts_one_ends(10));\n\
    assert(starts_one_ends(10) == starts_one_ends(10));\nassert(starts_one_ends(10)\
    \ == starts_one_ends(10));\nassert(starts_one_end", "  return strlen((string)\
    \ $n) - strlen((string) $n%10) - strlen((string) $n%100) +\n         strlen((string)\
    \ $n%1000) - strlen((string) $n%10000);\n}\n", "  // Store all positive numbers\
    \ that start or end with 1.\n  $ones = range(1, 10);\n  \n  // Store all positive\
    \ numbers that are not already stored.\n  $non_ones = array();\n  \n  // Store\
    \ all positive numbers that end with 1.\n  $ends_ones = range(1, $n-1);\n  \n\
    \  // Remove the first digit from the numbers to check.\n  $start_ones = array_shift($ones);\n\
    \  \n  // Remove the first digit from any number that ends with 1.\n  foreach($ends_ones\
    \ as $k => $end_one) {\n    if ($end_one == 1) {\n      $non_ones = array_merge($non_ones,\
    \ range($start_ones, $k));\n    }\n  }\n  \n  // Remove the first digit from any\
    \ number that starts with 1.\n  foreach($ones as $k => $start_one) {\n    if ($start_one\
    \ == 1) {\n      $non_ones = array_merge($non_ones, range($k+1, $n));\n    }\n\
    \  }\n  \n  // Remove the first digit from any number that doesn't already start.\n\
    \  foreach($non_ones as $k => $non_one) {\n    if ($non_one == 1) {\n      $ends_ones\
    \ = array_merge($ends_ones, range($k+1, $n));\n    }\n  }\n  \n  return count($non_ones);\n\
    }", "    if ($n <= 3) {\n        return 0;\n    }\n\n    // Loop through the numbers\
    \ from 10 to n-1, skipping multiples of 10.\n    $i = 10; $n--;\n    while ($i\
    \ >= $n) {\n        $i += 10;\n    }\n\n    // Loop through the numbers from 10\
    \ to n-1, and increment the count\n    // if the number starts or ends with 1.\n\
    \    $i = 10; $n--;\n    while ($i >= $n) {\n        if ($n % 10 === 1) {\n  \
    \          $i++;\n        }\n        $i -= 10;\n    }\n\n    return $i;\n}", " \
    \ return intval(floor($n ** 0.5));\n}\n", "  if ($n == 0) {\n    return 0;\n \
    \ }\n\n  // Find how many digits n has left.\n  $n_digits = strlen((string) $n);\n\
    \n  $count = 0;\n  for ($i = $n_digits - 1; $i >= 0; $i--) {\n    if ($n[$i] !=\
    \ 1) {\n      break;\n    }\n    $count++;\n  }\n\n  return $count;\n}\n", " \
    \ $count = 0;\n  while ($n >= 10) {\n    $count++;\n    $n = (int)($n % 10);\n\
    \  }\n  return $count;\n}\n</code>\nIn PHP 7, you can use the range operator instead:\n\
    <code>", "  global $ends;\n  $starts = 0;\n  $ends = 0;\n  $ends[$n] = 1;\n  foreach\
    \ ($ends as $end) {\n    $starts += $end * $n;\n  }\n  return $starts;\n}\n",
  "  $ones = preg_match_all('/1[1-9]{' . ($n + 1) . '}$/', $n, $ones);\n  return $ones[0];\n\
    }\n", "  // If n is 0, then there is nothing to do:\n  if ($n < 1) {\n    return\
    \ 0;\n  }\n\n  // Otherwise, if the last digit is a 1, there are only two possibilities:\n\
    \  if ($n % 10 == 1) {\n    return 2;\n  }\n\n  // Otherwise, we return the number\
    \ of possibilities:\n  return countOnesBackwardsStartingAt($n) + countOnesForwardsEndingAt($n);\n\
    }\n", "  $count = 0;\n  while($n > 9) {\n    $count++;\n    $n--;\n  }\n  while($n\
    \ >= 9) {\n    $n--;\n  }\n  return $count;\n}\n</code>\n<|/ a tags=php,math |>\n\
    <| c |>\nI believe this one is the best answer, the accepted one is a bit misleading\
    \ and misleading as it doesn't use the fact that the number of digits in number\
    \ x is actually n / 10.\n<|/ c |>\n<| a dscore=2 |>\nI believe this one is more\
    \ elegant and shorter:\n<code>", "  for ($i = 1; $i <= $n; $i++)\n    if ($i %\
    \ 10 == 1)\n      return $i;\n  return -1;\n}\n", "    if ($n < 10)\n        return\
    \ 1;\n    if ($n < 100)\n        return ($n < 10) ? 1 : 0;\n    if ($n < 1000)\n\
    \        return ($n < 100) ? 1 : ($n < 10) ? 0 : ($n < 1000) ? 2 : ($n < 1000)\
    \ ? 3 : 1;\n    if ($n < 10000)\n        return ($n < 1000) ? 1 : ($n < 10) ?\
    \ 0 : ($n < 100) ? 2 : ($n < 1000) ? 3 : ($n < 100) ? 4 : ($n < 100) ? 5 : 1;\n\
    \    if ($n < 100000)\n        return ($n < 1000) ? 1 : ($n < 10) ? 0 : ($n <\
    \ 100) ? 2 : ($n < 1000) ? 3 : ($n < 100) ? 4 : ($n < 100) ? 5 : ($n < 100) ?\
    \ 6 : 1;\n    if ($n < 1000000)\n        return ($n < 1000) ? 1 : ($n < 10) ?\
    \ 0 : ($n < 100) ? 2 : ($n < 1000) ? 3 : ($n < 100) ? 4 : ($n < 100) ? 5 : ($n\
    \ < 100) ? 6 : ($n < 100) ? 7 : 1;\n    if ($n < 10000000)\n        return ($n\
    \ < 1000) ? 1 : ($n < 10) ? 0 : ($n < 100) ? 2 : ($n < 1000) ? 3 : ($n < 100)\
    \ ? 4 : ($n < 100) ? 5 : ($n < 100) ? 6 : ($n < 100) ? 7 : ($n < 100) ? 8 : 1;\n\
    \    if ($n < 100000000)\n        return ($n < 1000) ? 1 : ($n < 10) ? 0 : ($n\
    \ < 100) ? 2 : ($n < 1000) ? 3 : ($n < 100) ? 4 : ($n < 100) ? 5 : ($n < 100)\
    \ ? 6 : ($n < 100) ? 7 : ($n < 100) ? 8 : ($n < 100) ? 9 : 1;\n    if ($n < 1000000000)\n\
    \        return ($n < 1000) ? 1 : ($n < 10) ? 0 : ($n < 100) ? 2 : ($n < 1000)\
    \ ? 3 : ($n < 100) ? 4 : ($n < 100) ? 5 : ($n < 100) ? 6 : ($n < 100) ? 7 : ($n\
    \ < 100) ? 8 : ($n < 100) ? 9 : ($n < 1000) ? 10 : 1;\n    if ($n < 10000000000)\n\
    \        return ($n < 1000) ? 1 : ($n < 10) ? 0 : ($n < 100) ? 2 : ($n < 1000)\
    \ ? 3 : ($n < 100) ? 4 : ($n < 100) ? 5 : ($n < 100) ? 6 : ($n < 100) ? 7 : ($n\
    \ < 100) ? 8 : ($n < 100) ? 9 : ($n < 100) ? 10 : ($n < 1000) ? 11 : 1;\n    if\
    \ ($n < 100000000000)\n        return ($n < 1000) ? 1 : ($n < ", "    $a = array_fill(0,\
    \ $n, 1);\n    $a[0] = 1;\n    $b = array();\n    $result = 0;\n    foreach ($a\
    \ as $value) {\n        if ($value <= 1) {\n            $b[] = $value;\n     \
    \   } else {\n            $result = 1;\n        }\n    }\n    return $result;\n\
    }", "  return intval(is_string($n) ? strlen($n) : $n) - intval($n) + 1;\n}\n",
  "  while ($n > 1) {\n    $x = $n;\n    $n = ($n - (($x % $n) === 0)) ? $x : $n;\n\
    \  }\n  return $n;\n}", "  for ($i = 1; $i <= $n; $i++) {\n    if ($i == 10) {\n\
    \      // The number 10 is a 10-digit number; if we start counting from 1, we\n\
    \      // will count every single digit from 1 to 9.  We don't need to count\n\
    \      // anything else.\n      $has_start = 1;\n      $has_end = 1;\n    } else\
    \ {\n      if ($i % 10 == 0) {\n        // If we're not counting the last digit,\
    \ then we need to check\n        // whether each of the other digits in the number\
    \ are all 1.\n        $has_start = check1($i);\n        $has_end = check2($i);\n\
    \      } else {\n        // We don't need to check the last digit.\n        $has_start\
    \ = 1;\n        $has_end = 1;\n      }\n    }\n  }\n  return $has_start * $has_end;\n\
    }\n", "    // The formula here is incorrect, but it's the best I could come up\
    \ with.\n    // See http://en.wikipedia.org/wiki/N-th_root#Efficient_method\n\
    \    $n = 39 - 2 * $n;\n    $n = 39 - 2 * $n;\n    $n = 39 - 2 * $n;\n    $n =\
    \ 39 - 2 * $n;\n    $n = 39 - 2 * $n;\n    $n = 39 - 2 * $n;\n    $n = 39 - 2\
    \ * $n;\n    $n = 39 - 2 * $n;\n    $n = 39 - 2 * $n;\n    $n = 39 - 2 * $n;\n\
    \    $n = 39 - 2 * $n;\n    $n = 39 - 2 * $n;\n    $n = 39 - 2 * $n;\n    $n =\
    \ 39 - 2 * $n;\n    $n = 39 - 2 * $n;\n    $n = 39 - 2 * $n;\n    $n = 39 - 2\
    \ * $n;\n    $n = 39 - 2 * $n;\n    $n = 39 - 2 * $n;\n    $n = 39 - 2 * $n;\n\
    \    $n = 39 - 2 * $n;\n    $n = 39 - 2 * $n;\n    $n = 39 - 2 * $n;\n    $n =\
    \ 39 - 2 * $n;\n    $n = 39 - 2 * $n;\n    $n = 39 - 2 * $n;\n    $n = 39 - 2\
    \ * $n;\n    $n = 39 - 2 * $n;\n    $n = 39 - 2 * $n;\n    $n = 39 - 2 * $n;\n\
    \    $n = 39 - 2 * $n;\n    $n = 39 - 2 * $n;\n    $n = 39 - 2 * $n;\n    $n =\
    \ 39 - 2 * $n;\n    $n = 39 - 2 * $n;\n    $n = 39 - 2 * $n;\n    $n = 39 - 2\
    \ * $n;\n    $n = 39 - 2 * $n;\n    $n = 39 - 2 * $n;\n    $n = 39 - 2 * $n;\n\
    \    $n = 39 - 2 * $n;\n    $n = 39 - 2 * $n;\n    $n = 39 - 2 * $n;\n    $n =\
    \ 39 - 2 * $n;\n    $n = 39 - 2 * $n;\n    $n = 39 - 2 * $n;\n    $n = 39 - 2\
    \ * $n;\n    $n = 39 - 2 * $n;\n    $n = 39 - 2 * $n;\n    $n = 39 - 2 * $n;\n\
    \    $n = 39 - 2 * $n;\n    $n = 39 - 2 * $n;\n    $n = 39 - 2 * $n;\n    $n =\
    \ 39 - 2 * $n;", "  $count = 0;\n  for ($i = 0; $i < $n; ++$i) {\n    if ($i %\
    \ 10 == 1) $count++;\n    if ($i % 10 == 0) $count += 2;\n  }\n  return $count;\n\
    }\n", "  if ($n <= 0) {\n    return 0;\n  }\n  $i = 0;\n  while (++$i && $n >=\
    \ 10) {\n    if ($n % 10 != 1) {\n      break;\n    }\n    $n /= 10;\n  }\n  return\
    \ $i;\n}\n", "  $count = 0;\n  for ($i = $n; $i > 0; $i--) {\n    if ($n >= $i)\
    \ {\n      if ($n % $i == 0) {\n        $count++;\n      }\n    } else {\n   \
    \   break;\n    }\n  }\n  return $count;\n}\n", "    if ($n == 1) {\n        return\
    \ 0;\n    }\n    return count(($n / $n) % 2);\n}\n", "    $count = 0;\n    for\
    \ ($i = 1; $i <= $n; $i++) {\n        if ($i % 10 == 1) {\n            $count++;\n\
    \        }\n        if ($i % 10 == -1) {\n            $count--;\n        }\n \
    \   }\n    return $count;\n}\necho starts_one_ends(8);", "    if ($n < 2) return\
    \ 0;\n    return intval($n) / abs($n - intval($n));\n}\n", "  if ($n == 0) {\n\
    \    return 1;\n  }\n\n  if ($n < 0) {\n    return 0;\n  }\n\n  $count = 0;\n\
    \  $nstr = '';\n\n  while (!($n & 1)) {\n    $nstr .= (floor($n / 10) * 10);\n\
    \    $n = ($n % 10);\n    $count++;\n  }\n\n  return $nstr + $count;\n}", "  $count\
    \ = array();\n  for ($i = 2; $i < $n; ++$i) {\n    if (!is_int($i) || $i % 10\
    \ != 1) continue;\n    ++$count[$i];\n    if ($i > 1) {\n      if (!$count[$i]\
    \ || !$count[$i - 1]) {\n        ++$count[$i];\n      }\n    }\n  }\n  return\
    \ $count;\n}\n", "    $nstring = (string) $n;\n    $count = 0; // This is only\
    \ used while debugging\n    for($i=0; $i<strlen($nstring); $i++) {\n        if\
    \ (substr($nstring, $i, 1) == '1') {\n            $count++;\n        }\n    }\n\
    \    return $count;\n}\n", "  return 1 + ends_one_starts($n);\n}\n", "  // n is\
    \ unsigned, so test it just in case $n was negative.\n  if ($n == 0) {\n    return\
    \ 0;\n  }\n  // if n is 1, then we just have 1 1-digit positive integer.\n  if\
    \ ($n==1) {\n    return 1;\n  }\n  // if n is 2, then we have 1-digit positive\
    \ integers ending with 1, and\n  // 1-digit positive integers starting with 1.\n\
    \  if ($n==2) {\n    return 2;\n  }\n\n  $count = 0;\n\n  for ($i=1; $i<$n; $i++)\
    \ {\n    $count += $i-1;\n    if ($i%2 != 0) {\n      $count += ($i-1)/2;\n  \
    \  }\n  }\n  return $count;\n}\n", "  $count = 0;\n  $n = abs($n);\n  for ($i\
    \ = 0; $i < $n; $i++) {\n    $c = $n % 10;\n    if ($c == 1 || $c == 2)\n    \
    \  $count++;\n    $n = $n / 10;\n  }\n  return $count;\n}", "    $digits = 0;\n\
    \    while ($n != 0) {\n        $d = $n % 10;\n        if ($d == 1) {\n      \
    \      $digits++;\n        }\n        $n = floor($n / 10);\n    }\n    return\
    \ $digits;\n}", "  $count = 1;\n  if ($n > 0) {\n    $low = 1;\n    $high = $n;\n\
    \    while ($low < $high) {\n      if ($low % 10 == 1) {\n        $count++;\n\
    \      }\n      $low *= 10;\n    }\n  }\n  return $count;\n}\n$n = 50;\necho starts_one_ends($n);\n",
  "  $n = (string) $n;\n  $nlength = strlen($n);\n  $nsum = 0;\n\n  for($i = $nlength\
    \ - 1; $i >= 0; $i--) {\n    $ndigit = substr($n, $i, 1);\n    $nsum += $ndigit\
    \ == '1' ? 1 : 0;\n  }\n\n  return $nsum;\n}\n", "    // n is assumed to be positive.\n\
    \    if ($n == 0 || $n == 1) {\n        return 1;\n    }\n\n    // n is assumed\
    \ to be nonnegative.\n    $n = abs($n);\n    $count = 0;\n    while ($n != 1)\
    \ {\n        $n = 3 * $n - 2;\n        $count++;\n    }\n    return $count;\n\
    }\n", "  return (int)(log($n) / log(10))+1;\n}\n", "  $i = 1;\n  while ($i <=\
    \ $n) {\n    if (starts_one($i)) {\n      $i += 1;\n    } else if (ends_one($i))\
    \ {\n      $n -= $i - 1;\n      $i += 1;\n    }\n  }\n  return $n;\n}\n", "  for\
    \ ($i = $n; $i >= 0; $i--) {\n    if ($i % 10 == 1 || $i % 10 == 1 && $i > 9)\n\
    \      return $i;\n  }\n  return -1;\n}\n$result = starts_one_ends(183);", " \
    \ $count = 0;\n  while (1) {\n    if ($n % 10 == 1) $count++;\n    if ($n % 10\
    \ == 1) $count--;\n    if ($count == 0) break;\n    $n = $n / 10;\n  }\n  return\
    \ $count;\n}", "  // This can just be moved into the loop condition, but that\n\
    \  // changes the asymptotic running time.\n  $ones = 0;\n  $starts = false;\n\
    \  for ($i = 1; $i <= $n; $i++) {\n    $digit = intval(substr($i, -2));\n    if\
    \ ($digit == 1) {\n      $ones++;\n      $starts = $starts || $digit == 0;\n \
    \   }\n  }\n  return $ones;\n}\n", "  // Based on a recurrence relation:\n  //\
    \ F(m, k) = F(m - 1, k) + F(m, k - 1)\n  if ($n < 1) {\n    return 0;\n  }\n \
    \ return 1 + starts_one_ends(--$n);\n}\n", "  // If n < 10, then the count will\
    \ be at least 1!\n  if ($n < 10) {\n    return 1;\n  }\n\n  // If n >= 10, then\
    \ it must start or end with 1.\n  return ($n % 10 == 1) ? 1 + ends_one_ends(floor($n\
    \ / 10)) : 1;\n}", "    return (($n-1)/3) + 1;\n}\n", "  $ones = 1;\n  $i = 2;\n\
    \  while (--$i >= 0) {\n    $ones += $n / pow(10, $i);\n    if ($n % $i == 0)\
    \ {\n      $n = ($n - $ones) / pow(10, $i);\n    } else {\n      break;\n    }\n\
    \  }\n  return $ones;\n}", "  if($n < 11) {\n    return $n;\n  }\n  if($n > 10)\
    \ {\n    return starts_one_ends((int)floor($n/10)) . $n;\n  }\n  if($n == 10)\
    \ {\n    return 2;\n  }\n  if($n == 11) {\n    return 1;\n  }\n  $start = starts_one_ends($n-1);\n\
    \  $end = ends_one_starts($n);\n  if($start == 1) {\n    return $end;\n  }\n \
    \ if($end == 1) {\n    return $start;\n  }\n  return $start+$end;\n}\n", "   \
    \ $count = 1;\n    if ($n <= 0) return 0;\n    while (true) {\n        $mod =\
    \ ($n % 10);\n        if (!(is_numeric($mod) && ($mod > 0) && ($mod <= 9))) break;\n\
    \        $count += 1;\n        $n = floor($n / 10);\n    }\n    return $count;\n\
    }", "  $count = 1;\n  while ($n > 1) {\n    $count += intval($n % 10);\n    $n\
    \ = floor($n / 10);\n  }\n  return $count;\n}\n", "  return 1 + ends_one_starts($n);\n\
    }\n", "  if ($n <= 0) {\n    return 0;\n  }\n  $count = 1;\n  for ($d = 1; $d\
    \ < $n; $d++) {\n    if ($n % ($d * 10) == 0) {\n      $count += $d;\n    }\n\
    \  }\n  return $count;\n}\n", "  $count = 0 ;\n  for ($i = 1; $i <= $n; $i++)\
    \ {\n    $count = $count + $i ;\n    if ($i == 1 || $i == $n) {\n      $count++\
    \ ;\n    }\n  }\n  return $count ;\n}\n", "  if ($n < 10) {\n    return 0;\n \
    \ }\n\n  // The number of numbers that start with 1 is n - 1 and ends with 1 is\
    \ n - 2.\n  return $n - 1;\n}\n$count = starts_one_ends(10);\nprint \"$count numbers\
    \ have starting 1 ending with 1.\\n\";\n", "  $starts = 1;\n  for ($x = 2; $x\
    \ <= $n; ++$x) {\n    if ($x % 10 == 1)\n      ++$starts;\n    else\n      break;\n\
    \  }\n  return $starts;\n}\n$nums = array();\n$nums[] = 123;\n$nums[] = 120;\n\
    $nums[] = 121;\n$nums[] = 119;\n$nums[] = 118;\n$nums[] = 117;\n$nums[] = 116;\n\
    $nums[] = 115;\n$nums[] = 114;\n$nums[] = 113;\n$nums[] = 113;\n$nums[] = 113;\n\
    $nums[] = 111;\n$nums[] = 111;\n$nums[] = 110;\n$nums[] = 109;\n$nums[] = 108;\n\
    $nums[] = 108;\n$nums[] = 108;\n$nums[] = 107;\n$nums[] = 107;\n$nums[] = 107;\n\
    $nums[] = 106;\n$nums[] = 106;\n$nums[] = 106;\n$nums[] = 105;\n$nums[] = 104;\n\
    $nums[] = 104;\n$nums[] = 103;\n$nums[] = 103;\n$nums[] = 103;\n$nums[] = 102;\n\
    $nums[] = 101;\n$nums[] = 100;\n$nums[] = 100;\n$nums[] = 100;\n$nums[] = 99;\n\
    $nums[] = 99;\n$nums[] = 99;\n$nums[] = 99;\n$nums[] = 99;\n$nums[] = 99;\n$nums[]\
    \ = 99;\n$nums[] = 99;\n$nums[] = 99;\n$nums[] = 99;\n$nums[] = 99;\n$nums[] =\
    \ 99;\n$nums[] = 99;\n$nums[] = 99;\n$nums[] = 99;\n$nums[] = 99;\n$nums[] = 99;\n\
    $nums[] = 99;\n$nums[] = 99;\n$nums[] = 99;\n$nums[] = 99;\n$nums[] = 99;\n$nums[]\
    \ = 99;\n$nums[] = 99;\n$nums[] = 99;\n$nums[] = 99;\n$nums[] = 99;\n$nums[] =\
    \ 99;\n$nums[] = 99;\n$nums[] = 99;\n$nums[", "    $count = 0;\n    while ($n\
    \ >= 10) {\n        $count += ($n % 10 === 1) ? 1 : 0;\n        $n = floor($n\
    \ / 10);\n    }\n    return $count;\n}", "  if ($n < 10) {\n    return 0;\n  }\n\
    \n  $ends = $n%10;\n  if ($ends == 1) {\n    return $ends;\n  }\n\n  return $ends+starts_one_ends(10*($n-1));\n\
    }", "  return 1 + abs(starts_one_ends($n - 1));\n}\n", "  $count = 0;\n  while\
    \ ($n > 10) {\n    if ($n == 10) {\n      return $count;\n    }\n    if ($n ==\
    \ ($n % 10)) {\n      $n = ($n / 10);\n      $count++;\n    }\n  }\n  return $count;\n\
    }\n", "  if ($n < 1) return 0;\n  if ($n == 1) return 1;\n  if ($n % 10 == 1)\
    \ return $n;\n  else {\n    $last = starts_one_ends(intval($n / 10));\n    return\
    \ $n + 1 - ($last * 10 + 5) % 10;\n  }\n}", "  // Write your code here.\n}\n\n\
    $starts_one_ends_count = starts_one_ends($n); // $starts_one_ends_count should\
    \ be equal to 1", "  $count = 0;\n  for ($i = 1; $i <= $n; $i++) {\n    if ($i\
    \ % 10 === 1) {\n      $count++;\n    }\n  }\n  return $count;\n}\n", "  $sum\
    \ = 0;\n  for ($i = 1; $i <= $n; $i++) {\n    if ($i % 10 == 1) {\n      $sum++;\n\
    \    }\n  }\n  return $sum;\n}\n", "    $count = 0;\n    for ($i = 1; $i <= $n;\
    \ ++$i) {\n        $test = ($i % 10) === 1;\n        if ($test) {\n          \
    \  $count += $i - 1;\n        }\n    }\n    return $count;\n}\n", "  if ($n <\
    \ 0) {\n    return 0;\n  }\n  if ($n < 10) {\n    return 1;\n  }\n  return 1 +\
    \ starts_one_ends($n / 10);\n}", "  global $g;\n  if ($n < 1) return 0;\n  $g->starts_one_ends[$n]\
    \ = $g->starts_one_ends[$n] ?? 0;\n  $g->starts_one_ends[$n] += starts_one_ends(floor($n/10));\n\
    \  return $g->starts_one_ends[$n];\n}\n", "  $n = (int)$n;\n  if ($n <= 0) {\n\
    \    return 0;\n  }\n\n  $i = 1;\n  $j = strlen($n) - 1;\n  $ones = 0;\n  while\
    \ ($i <= $j) {\n    $ones += floor($n[$i] . $n[$j]) / $i;\n    $i++;\n    $j--;\n\
    \  }\n\n  return $ones;\n}\n", "    $ns = range(1, $n+1);\n    return count(array_filter(\n\
    \        $ns,\n        function($v) use ($n) {\n            return ($v == 1) ||\
    \ ($v == $n-1);\n        }\n    ));\n}\n", "  $count = 0;\n  for ($i = 1; $i <=\
    \ $n; $i++) {\n    if ($i % 10 == 1) {\n      if ($i / 10 == 1) {\n        $count++;\n\
    \      }\n    }\n  }\n  return $count;\n}\n", "    $count = 0;\n    while(n >\
    \ 1) {\n        if(is_prime($n)) {\n            $count++;\n            $n = $n-1;\n\
    \        }\n        else {\n            $n = $n-1;\n        }\n    }\n    return\
    \ $count;\n}", "  // Base case\n  if ($n <= 0) return 0;\n  // Divide into 10\
    \ parts, starting with the least significant\n  $parts = array();\n  for ($i =\
    \ 1; $i < 9; $i++) {\n    $parts[] = floor($n / pow(10, $i));\n    $n -= $parts[$i]\
    \ * pow(10, $i);\n  }\n  // If there are still any digits left over, return them\n\
    \  if ($n > 0) $parts[] = $n;\n  return $parts;\n}\n", "    return intval((10**$n)\
    \ <= abs($n));\n}\n", "  if ($n <= 0) return 0;\n  $n_digits = 1;\n  for ($i =\
    \ 1; $i <= $n; ++$i) {\n    if ($i % 10 == 1) $n_digits++;\n    if ($i % 10 ==\
    \ 0) $n_digits += 1;\n  }\n  return $n_digits;\n}\n", "  $x = 1;\n  $y = 1;\n\
    \  for ($i = 1; $i <= $n; $i++) {\n    $x = ($x + ($i % 10)) % 10;\n    $y = ($y\
    \ + ($x % 10)) % 10;\n  }\n  return $y;\n}\n", "  $nstrlen = strlen($n);\n  $n_starts\
    \ = 1;\n  $n_ends = 0;\n  $k = $nstrlen - 1;\n  for (; $n >= 100; $n /= 10) {\n\
    \    $n_starts++;\n  }\n  for (; $n > 0; $n /= 10) {\n    $n_ends++;\n  }\n  return\
    \ $n_starts * $n_ends;\n}\n", "  global $starts_one, $ends_one;\n  $ones = $starts_one[$n];\n\
    \  $ends = $ends_one[$n];\n  return $ones + $ends;\n}\n", "  if ($n < 10) {\n\
    \    return 1;\n  }\n  if ($n < 100) {\n    return 3;\n  }\n  if ($n < 1000) {\n\
    \    return 5;\n  }\n  if ($n < 10000) {\n    return 7;\n  }\n  if ($n < 100000)\
    \ {\n    return 9;\n  }\n  if ($n < 1000000) {\n    return 11;\n  }\n  if ($n\
    \ < 10000000) {\n    return 13;\n  }\n  if ($n < 100000000) {\n    return 15;\n\
    \  }\n  if ($n < 1000000000) {\n    return 17;\n  }\n  if ($n < 10000000000) {\n\
    \    return 19;\n  }\n  if ($n < 100000000000) {\n    return 21;\n  }\n  if ($n\
    \ < 1000000000000) {\n    return 23;\n  }\n  if ($n < 10000000000000) {\n    return\
    \ 25;\n  }\n  if ($n < 100000000000000) {\n    return 27;\n  }\n  if ($n < 1000000000000000)\
    \ {\n    return 29;\n  }\n  if ($n < 10000000000000000) {\n    return 31;\n  }\n\
    \  if ($n < 100000000000000000) {\n    return 33;\n  }\n  if ($n < 1000000000000000000)\
    \ {\n    return 35;\n  }\n  if ($n < 10000000000000000000) {\n    return 37;\n\
    \  }\n  if ($n < 100000000000000000000) {\n    return 39;\n  }\n  if ($n < 1000000000000000000000)\
    \ {\n    return 41;\n  }\n  if ($n < 10000000000000000000000) {\n    return 43;\n\
    \  }\n  if ($n < 100000000000000000000000) {\n    return 45;\n  }\n  if ($n <\
    \ 1000000000000000000000000) {\n    return 47;\n  }\n  if ($n < 10000000000000000000000000)\
    \ {\n    return 49;\n  }\n  if ($n < 100000000000000000000000000) {\n    return\
    \ 51;\n  }\n  if ($n < 1000000000000000000000000000) {\n    return 53;\n  }\n\
    \  if ($n < 10000000000000000000000000000) {\n    return 55;\n  }\n  if ($n <\
    \ 100000000000000000000000000000) {\n    return 57;\n  }\n  if ($n < 1000000000000000000000000000000)\
    \ {\n    return 59;\n  }\n  if ($n < 10000000000000000000000000000000) {\n   \
    \ return 61;\n  }\n  if ($n < 100000000000000000000000000000000) {\n    return\
    \ 63;\n  }\n  if ($n < 1000000000000000000000000000000000) {\n    return 65;\n\
    \  }\n  if ($n < 10000000000000000000000000000000000) {\n    return 67;\n  }\n\
    \  if ($n < 100000000000000000000000000000000000) {\n    return 69;\n  }\n  if\
    \ ($n < 1000000000000000000000000000000000000) {\n    return 71;\n  }\n  if ($n\
    \ < 10000000000000000000000000000000000000) {\n    return 73;\n  }\n  if ($n <\
    \ 100000000000000000000000000000000000000) {\n    return 75", "\t$count = 0;\n\
    \tfor ($i = 1; $i <= $n; $i++) {\n\t\tif (is_started_end($i)) {\n\t\t\t$count++;\n\
    \t\t}\n\t}\n\treturn $count;\n}\n", "  $count = 0;\n  while ($n > 9) {\n    if\
    \ ($n%10 == 1) ++$count;\n    $n /= 10;\n  }\n  return $count;\n}\n", "  if ($n\
    \ == 0) {\n    return 0;\n  }\n  $a = array_map(function ($k) { return pow(10,\
    \ $k); }, range(0, $n));\n  sort($a);\n  return count(array_filter(function ($v)\
    \ use ($a) {\n    return $v == 1 || ($v == $a[count($a) - 1]);\n  }));\n}", " \
    \ return (int) log10($n) + 1;\n}\n", "  $n = abs($n);\n  $digits = str_split(decbin($n));\n\
    \  $count = 0;\n  foreach ($digits as $digit) {\n    if (!isset($digit[0])) {\n\
    \      return $count;\n    }\n    if ($digit[0] == 1) {\n      $count++;\n   \
    \ }\n  }\n  return $count;\n}\n\n/**\n * Returns true if the two binary numbers\
    \ represented by the strings $a\n * and $b are equal.\n *\n * @param string $a\
    \ The first binary string.\n * @param string $b The second binary string.\n *\n\
    \ * @return bool Whether the two binary strings are equal.\n */", "\t$cnt = 0;\n\
    \tfor ($i = 1; $i <= $n; $i++)\n\t\tif ($i % 10 == 1)\n\t\t\t$cnt++;\n\treturn\
    \ $cnt;\n}\n", "  $count = 0;\n  for ($i = 2; $i <= $n; $i++) {\n    if ($i %\
    \ 10 == 1) {\n      if ($i <= $n - 11) {\n        if ($i % 100 == 1) {\n     \
    \     if ($i <= $n - 101) {\n            if ($i <= $n - 1001) {\n            \
    \  if ($i <= $n - 10001 && $i <= $n - 10000) {\n                if ($i <= $n -\
    \ 10000 && $i <= $n - 10000) {\n                  if ($i <= $n - 10000) {\n  \
    \                  $count++;\n                  }\n                }\n       \
    \       }\n            }\n          }\n        }\n      }\n    }\n  }\n  return\
    \ $count;\n}\n", "  if ($n < 1) {\n    return 0;\n  }\n  return intval(str_ireplace('1',\
    \ '', '1'.str_repeat($n, $n / 2)));\n}\n$count1 = starts_one_ends(10);\n$count2\
    \ = starts_one_ends(12);\n$count3 = starts_one_ends(16);\n$count4 = starts_one_ends(19);\n\
    $count5 = starts_one_ends(24);\n$count6 = starts_one_ends(25);\n$count7 = starts_one_ends(30);\n\
    $count8 = starts_one_ends(31);\n$count9 = starts_one_ends(34);\n$count10 = starts_one_ends(41);\n\
    $count11 = starts_one_ends(48);\n$count12 = starts_one_ends(53);\n$count13 = starts_one_ends(56);\n\
    $count14 = starts_one_ends(63);\n$count15 = starts_one_ends(67);\n$count16 = starts_one_ends(70);\n\
    $count17 = starts_one_ends(73);\n$count18 = starts_one_ends(79);\n$count19 = starts_one_ends(88);\n\
    $count20 = starts_one_ends(101);\n$count21 = starts_one_ends(105);\n$count22 =\
    \ starts_one_ends(111);\n$count23 = starts_one_ends(116);\n$count24 = starts_one_ends(121);\n\
    $count25 = starts_one_ends(126);\n$count26 = starts_one_ends(131);\n$count27 =\
    \ starts_one_ends(136);\n$count28 = starts_one_ends(143);\n$count29 = starts_one_ends(148);\n\
    $count30 = starts_one_ends(153);\n$count31 = starts_one_ends(158);\n$count32 =\
    \ starts_one_ends(163);\n$count33 = starts_one_ends(168);\n$count34 = starts_one_ends(173);\n\
    $count35 = starts_one_ends(178);\n$count36 = starts_one_ends(183);\n$count37 =\
    \ starts_one_ends(188);\n$count38 = starts_one_ends(193);\n$count39 = starts_one_ends(198);\n\
    $count40 = starts_one_ends(203);\n$count41 = starts_one_ends(208);\n$count", " \
    \ $count = 0;\n  if ($n == 1) {\n    return $count;\n  }\n  for ($i = 1; $i <=\
    \ $n; $i++) {\n    if ($i % 10 == 1 && $i % 100 != 11) {\n      // i starts with\
    \ 1 and ends with 1.\n      $count++;\n    }\n  }\n  return $count;\n}\n", " \
    \ if ($n <= 9) {\n    return $n + 1;\n  }\n  $count = 2;\n  for ($i = 0; $i <=\
    \ 9; ++$i) {\n    if ($i == $n) {\n      $count++;\n    } else {\n      if ($i\
    \ % $n == 0) {\n        $count += floor($i / $n);\n      }\n    }\n  }\n  return\
    \ $count;\n}\n", "  preg_match('/\\A1-$n\\z/', $n) === 1;\n}\n", "  $count = 0;\n\
    \  if ($n >= 1000000000000) {\n    $count++;\n    $n = round($n / 1000000000000);\n\
    \  }\n  if ($n >= 1000000000) {\n    $count++;\n    $n = round($n / 1000000000);\n\
    \  }\n  if ($n >= 1000000) {\n    $count++;\n    $n = round($n / 1000000);\n \
    \ }\n  if ($n >= 1000) {\n    $count++;\n    $n = round($n / 1000);\n  }\n  if\
    \ ($n >= 100) {\n    $count++;\n    $n = round($n / 100);\n  }\n  return $count;\n\
    }\n", "    if ($n == 1) {\n        return 0;\n    }\n    $ones = 0;\n    $tens\
    \ = 0;\n    $hundreds = 0;\n    $thousands = 0;\n    while (true) {\n        $ones++;\n\
    \        if ($n % 10 == 1) {\n            $tens++;\n        }\n        if ($n\
    \ % 100 == 1) {\n            $hundreds++;\n        }\n        if ($n % 1000 ==\
    \ 1) {\n            $thousands++;\n        }\n        if ($n % 10000 == 1) {\n\
    \            $hundreds++;\n        }\n        $n = (int) ($n / 10);\n        if\
    \ ($n == 0) {\n            return $ones + $tens + $hundreds + $thousands;\n  \
    \      }\n    }\n}\n\n$start_ones = starts_one_ends(5);\n\n$start_tens = starts_one_ends(100);\n\
    \n$start_hundreds = starts_one_ends(1000);\n\n$start_thousands = starts_one_ends(10000);\n\
    \n$start_millions = starts_one_ends(1000000);\n\n$start_billions = starts_one_ends(1000000000);\n\
    \n$start_trillions = starts_one_ends(1000000000000);\n\necho \"Starts with 1:\
    \ $start_ones\\n\";\necho \"Starts with 10: $start_tens\\n\";\necho \"Starts with\
    \ 100: $start_hundreds\\n\";\necho \"Starts with 1000: $start_thousands\\n\";\n\
    echo \"Starts with 10000: $start_millions\\n\";\necho \"Starts with 100000: $start_billions\\\
    n\";\necho \"Starts with 1000000: $start_trillions\\n\";", "    // Initialize\
    \ some variables.\n    $sum = 0;\n    $count = 0;\n\n    // Loop over each digit,\
    \ incrementing the sum.\n    for ($i = 1; $i <= $n; $i++) {\n        $sum += $i;\n\
    \        if ($sum == $n) {\n            $count++;\n        }\n    }\n\n    return\
    \ $count;\n}\n", "    return ($n % 10 == 1 && $n % 100 != 11) ? 1 : 0;\n}\n\n\
    $result = starts_one_ends(18);", "  $ones = array_filter($n, \"is_int\");\n  $starts\
    \ = 0;\n  foreach ($ones as $one) {\n    $starts += $one == 1;\n  }\n  $ends =\
    \ count($ones) - $starts;\n  return array($starts, $ends);\n}\n", "  // This function\
    \ is designed to work with positive integers only!\n  // It should work with negative\
    \ integers as well, but it doesn't.\n  // It also doesn't work with decimals!\n\
    \  $i = 0;\n  $count = 0;\n  while (pow(10, $i) < $n) {\n    if (pow(10, $i) ==\
    \ $n) {\n      $count++;\n    }\n    $i++;\n  }\n  return $count;\n}\n", "  //\
    \ Write your code here.\n}", "  $counter = count(range(1, $n, 1));\n  // Special\
    \ case for 0\n  if ($n == 0) {\n    return 0;\n  }\n  return $counter;\n}\n",
  "  if ($n < 9) {\n    return 0;\n  }\n  $x = str_split((string) $n);\n  $n = count($x);\n\
    \  $count = 0;\n  foreach ($x as $digit) {\n    if ($digit === '1') {\n      $count\
    \ += $n;\n    }\n  }\n  return $count;\n}\n", "  $count = 0;\n  while ($n >= 10)\
    \ {\n    if ($n % 10 == 1) ++$count;\n    $n /= 10;\n  }\n  return $count;\n}",
  "  $count = 1;\n  if ($n < 10) {\n    return $count;\n  }\n  while ($n % 10 != 1)\
    \ {\n    $count++;\n    $n = floor($n / 10);\n  }\n  $count++;\n  return $count;\n\
    }\n", "    $count = 0;\n    while (!($n % 10)) {\n        if ($n % 10 == 0) {\n\
    \            $count++;\n        }\n        $n++;\n    }\n    return $count;\n\
    }\n", "    $count = 0;\n    $limit = $n;\n    while($limit < 10) {\n        $limit\
    \ *= 10;\n        $count ++;\n    }\n    $result = 0;\n    while($limit > 10)\
    \ {\n        $limit /= 10;\n        $result ++;\n    }\n    return $count;\n}",
  "  for ($i = 0; $i <= $n; $i++) {\n    if ($i % 10 == 1 && $i != 0) {\n      return\
    \ $i;\n    }\n  }\n}\n", "  if ($n < 10)\n    return 0;\n  else\n    return ends_one_starts($n)\
    \ - starts_one_ends($n);\n}\n", "  $i = 1;\n  for ($x = 1; $x <= $n; $x++) {\n\
    \    if ($x % 10 == 1) {\n      $i++;\n      if ($i === $n) {\n        return\
    \ $x;\n      }\n    }\n  }\n  return -1;\n}", "    $num = pow($n, 10);\n    $starts\
    \ = 0;\n    $ends = 0;\n    do {\n        $starts += $num % 10;\n        $num\
    \ = $num / 10;\n    } while ($starts > 1);\n    do {\n        $ends += $num %\
    \ 10;\n        $num = $num / 10;\n    } while ($ends > 1);\n    return $starts\
    \ + $ends;\n}", "  if ($n <= 0) {\n    return 0;\n  }\n  list($start, $end) =\
    \ (1, 1)\n      + (int)$n * ($n / 2)\n      + ($n % 2);\n  return $start > $end\
    \ ? $start - $end : $end - $start;\n}\n", "  if ($n < 10) {\n    return 0;\n \
    \ }\n  return intval(log($n, 10));\n}", "  $ndigits = strlen($n);\n  $nstarts\
    \ = array_sum(array_slice($n, 0, $ndigits));\n  $nends = array_sum(array_slice($n,\
    \ $ndigits));\n  return $nstarts + $nends;\n}\n", "  return floor((log10(abs($n))\
    \ + 1) >> 1);\n}\n", "  if ($n < 0) {\n    return 0;\n  }\n  $start = log10($n);\n\
    \  $end = log10(10) - $start;\n  if ($n == 1) {\n    return $end;\n  }\n  $ones\
    \ = 1;\n  for ($i = 0; $i < $end; $i++) {\n    if (10 ** $i + $n - 10 ** $start\
    \ == 10) {\n      $ones++;\n    }\n  }\n  return $ones;\n}\n", "  // Initialize\
    \ variables.\n  $count = 0;\n  $n = abs($n);\n\n  // Loop through all n-digit\
    \ numbers starting with 1\n  for ($i = 1; ($i * 10) <= $n; $i++) {\n    // If\
    \ a number is divisible by 10, increment the counter\n    // and break the loop\n\
    \    if ($i % 10 == 0) {\n      $count++;\n      break;\n    }\n  }\n  return\
    \ $count;\n}\n\n$n = starts_one_ends(9);\necho $n; // Outputs 2", "  $ones = $tens\
    \ = array();\n  $ones[] = 0;\n  $tens[] = 0;\n  while ($n) {\n    $ones[] = $n;\n\
    \    $tens[] = $n / 10;\n    $n = $n % 10;\n  }\n  return $ones + $tens;\n}\n",
  "  return intval($n) - (intval($n) % 10);\n}\n\n$n = 9223372036854775808; // 9223372036854775808L\
    \ == 2**64 - 1, the largest 64-bit integer\n\n$start = microtime(true);\n$answer\
    \ = starts_one_ends($n);\n$elapsed = microtime(true) - $start;", "  $nums = array();\n\
    \  for ($i = 1; $i <= $n; ++$i) {\n    $nums[$i] = $i === 1 || $i === $n || $i\
    \ % $n === 0;\n  }\n  return count($nums);\n}\n\n$starts_one = starts_one_ends(5);\n\
    $starts_two = starts_one_ends(9);\n$starts_ten = starts_one_ends(11);\n\necho\
    \ \"starts_one: {$starts_one}\\n\";\necho \"starts_two: {$starts_two}\\n\";\n\
    echo \"starts_ten: {$starts_ten}\\n\";", "    $total = 0;\n    while ($n > 1)\
    \ {\n        $total += $n % 10;\n        $n = floor($n / 10);\n    }\n    return\
    \ $total;\n}\n"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
