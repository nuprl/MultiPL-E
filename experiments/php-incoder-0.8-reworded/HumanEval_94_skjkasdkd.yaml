name: HumanEval_94_skjkasdkd
language: php
prompt: "<?php\n// You are given an array of integers.\n// You need to find the largest\
  \ prime value and return the sum of its digits.\n// Examples:\n// >>> skjkasdkd(array(0,\
  \ 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3))\n// 10\n\
  // >>> skjkasdkd(array(1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1))\n\
  // 25\n// >>> skjkasdkd(array(1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323,\
  \ 32, 30, 1, 9, 3))\n// 13\n// >>> skjkasdkd(array(0, 724, 32, 71, 99, 32, 6, 0,\
  \ 5, 91, 83, 0, 5, 6))\n// 11\n// >>> skjkasdkd(array(0, 81, 12, 3, 1, 21))\n//\
  \ 3\n// >>> skjkasdkd(array(0, 8, 1, 2, 1, 7))\n// 7\nfunction skjkasdkd($lst) {\n"
tests: "function candidate(...$args) {\n    return skjkasdkd(...$args);\n}\n\nfunction\
  \ test(): void {\n    if (candidate(array(0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181,\
  \ 32, 4, 32, 3, 2, 32, 324, 4, 3)) !== 10) { throw new Exception(\"Test failed!\"\
  ); }\n    if (candidate(array(1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2,\
  \ 5, 1)) !== 25) { throw new Exception(\"Test failed!\"); }\n    if (candidate(array(1,\
  \ 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3)) !== 13) { throw\
  \ new Exception(\"Test failed!\"); }\n    if (candidate(array(0, 724, 32, 71, 99,\
  \ 32, 6, 0, 5, 91, 83, 0, 5, 6)) !== 11) { throw new Exception(\"Test failed!\"\
  ); }\n    if (candidate(array(0, 81, 12, 3, 1, 21)) !== 3) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(array(0, 8, 1, 2, 1, 7)) !== 7) { throw new\
  \ Exception(\"Test failed!\"); }\n    if (candidate(array(8191)) !== 19) { throw\
  \ new Exception(\"Test failed!\"); }\n    if (candidate(array(8191, 123456, 127,\
  \ 7)) !== 19) { throw new Exception(\"Test failed!\"); }\n    if (candidate(array(127,\
  \ 97, 8192)) !== 10) { throw new Exception(\"Test failed!\"); }\n}\n\ntest();"
completions: ["    $largest = $lst[0];\n    $sum = 0;\n    for($i = 1; $i <= count($lst);\
    \ $i++) {\n        if($lst[$i] > $largest) {\n            $sum = 0;\n        \
    \    $largest = $lst[$i];\n        }\n        $sum += $lst[$i];\n    }\n    return\
    \ $sum;\n}\n</code>\n<|/ a tags=arrays,php |>\n<| a tags=arrays,php |>\nI like\
    \ to use this one-liner solution:\n<code>\n$sumOfDigits = array_sum(array_map(function($n)\
    \ { return $n%10; }, $num));\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't\
    \ work when there are multiple digits.\n<|/ c |>\n<| a tags=arrays,php |>\nI used\
    \ this piece of code for my own problem. It may be a bit overkill for what you\
    \ are trying to do, but maybe it'll help. \n<code>", "    $primes = 0;\n    $max\
    \ = 0;\n    foreach ($lst as $x) {\n        $max = max($max, $x);\n        $primes\
    \ = $primes + isPrime($x);\n    }\n    return $max;\n}\n", "    $primes = array(3,\
    \ 5, 7, 9);\n    $sum = 0;\n    $primesCount = count($primes);\n    for ($i =\
    \ 0; $i < count($lst); $i++) {\n        for ($j = 0; $j < $primesCount; $j++)\
    \ {\n            $sum = ($lst[$i] % $primes[$j]) + $sum;\n            $lst[$i]\
    \ = $sum;\n            $sum = $sum % 10;\n        }\n    }\n    return $sum;\n\
    }\n", "    $primes = array();\n    $sum = 0;\n    $largest = PHP_INT_MAX;\n  \
    \  foreach($lst as $num) {\n        if(!is_int($num)) {\n            throw new\
    \ InvalidArgumentException(\"All values in the array must be integers.\");\n \
    \       }\n        if(!isset($primes[$num])) {\n            $primes[$num] = true;\n\
    \            for($i = 2; $i * $i < $num; $i++) {\n                if($num % $i\
    \ == 0) {\n                    $primes[$num] = false;\n                    break;\n\
    \                }\n            }\n            if($primes[$num]) {\n         \
    \       if($num > $largest) {\n                    $sum = 0;\n               \
    \     $largest = $num;\n                } elseif($num == $largest) {\n       \
    \             $sum = $largest;\n                    $largest++;\n            \
    \    }\n            }\n        }\n    }\n    return $sum + ($largest * 2);\n}",
  "    sort($lst);\n    foreach ($lst as $key => $val) {\n        if ($val % 2 ==\
    \ 0) {\n            $tmp = 0;\n            $lst_2 = [];\n            for ($i =\
    \ 0; $i < $val; $i++) {\n                $tmp += $lst[$i + $key];\n          \
    \      $lst_2[$i] = $tmp;\n            }\n            if ($tmp > $val) {\n   \
    \             $res = $lst_2;\n                return $res;\n            }\n  \
    \      }\n    }\n    $res = $lst_2;\n    return $res;\n}\n", "\t$max = reset($lst);\n\
    \tforeach ($lst as $n) {\n\t\tif ($n % $max == 0) {\n\t\t\t$max++;\n\t\t} else\
    \ {\n\t\t\t$max = $n % $max;\n\t\t}\n\t}\n\tforeach ($lst as $n) {\n\t\tif ($n\
    \ % $max == 0) {\n\t\t\t$sum += intval($n % 10);\n\t\t\t$n /= 10;\n\t\t}\n\t}\n\
    \treturn $sum;\n}\n", "    $largestPrime = array_reduce($lst, function ($a, $b)\
    \ {\n        return max($a, $b);\n    });\n    $sum = 0;\n    foreach ($lst as\
    \ $value) {\n        if ($value <= $largestPrime) {\n            $sum = $sum +\
    \ $value;\n        }\n    }\n    return $sum;\n}\n</code>\n<|/ a dscore=0 tags=php\
    \ |>\n<| c |>\n`array_reduce()` returns an `int` value, not a `float`.\n<|/ c\
    \ |>\n<| c |>\nI agree that it should be fixed now, but I don't see any errors\
    \ in this solution. Are you sure that `int` is the only issue? The question is\
    \ about finding the largest prime number, not about the decimal digits. I suppose\
    \ the OP can just `round()` the result.\n<|/ c |>\n<| c |>\n, if you look at the\
    \ example, it's not about the decimal digits at all. Also, `array_reduce()` returns\
    \ `int` not `float` and the `float` values would get rounded to the nearest integer.\n\
    <|/ c |>\n<| c |>\nIt's not about the decimal digits. The OP was looking for largest\
    \ prime number. The decimal digits were not part of the question and the example\
    \ just made it look like it was about finding decimal digits, though it's not\
    \ about that. Your answer was helpful, even though it's wrong.\n<|/ c |>\n<| c\
    \ |>\n, how are you seeing that my answer is wrong? The OP asked for the largest\
    \ prime number sum. I explained that in the answer but it's not in the OP's question.\
    \ Also my answer was edited (adding `int` casting) after I saw that your answer\
    \ was wrong.\n<|/ c |>\n<| a dscore=0 |>\n<code>\n<?php\n$num = array(1,2,3,4,5,6,7,8,9,10);\n\
    $primes = 0;\nforeach($num as $n){\n$i=2;\n$j=2;\n$k=$i;\nwhile($i<=$j){\nif($n%$k==0){\n\
    break;\n}else{\n$i++;\n$j++;\n$k=$i;\n}\n}\nif($i>$j){\n$primes[]=$n;\n}\n}\n\
    echo $maxSum = $num[0] + array_sum($primes);", "    foreach ($lst as $k => $v)\
    \ {\n        if ($v % 2 == 0) {\n            $lst[$k] = $v / 2;\n        } else\
    \ {\n            if ($v > 3) {\n                $max = 2;\n                for\
    \ ($i = 3; $i < $v; $i += 2) {\n                    if ($v % $i == 0) {\n    \
    \                    $max = $i;\n                        break;\n            \
    \        }\n                }\n            }\n            if ($v > $max) {\n \
    \               $lst[$k] = $max;\n            }\n        }\n    }\n\n    $sum\
    \ = 0;\n    foreach ($lst as $k => $v) {\n        if ($v > 1) {\n            $sum\
    \ += $v % 10;\n        } else {\n            $sum += $v;\n        }\n    }\n \
    \   return $sum;\n}\n\n$sum = 0;\n$sum2 = 0;\nforeach ($arr as $key => $val) {\n\
    \    $sum += $val + skjkasdkd($arr);\n    $sum2 += $val + skjkasdkd($arr);\n}\n\
    $max1 = $sum + $sum2;\n$max2 = $sum + $sum2;\n\n$sum += $max1;\n$sum2 += $max2;\n\
    $max = $sum + $sum2;", "    // Your code here\n    foreach($lst as $key=>$val){\n\
    \        if ($val == 1){\n            return $lst[$key];\n        }\n        if($val\
    \ == 0){\n            foreach ($lst[$key-1] as $val2){\n                if ($val2\
    \ == 0){\n                    continue;\n                }\n                else{\n\
    \                    if (skjkasdkd(array($val, $val2)) > $val){\n            \
    \            return $val+$val2;\n                    }\n                }\n  \
    \          }\n        }\n        else{\n            foreach ($lst[$key-1] as $val2){\n\
    \                if ($val2 == 0){\n                    continue;\n           \
    \     }\n                else{\n                    if (skjkasdkd(array($val,\
    \ $val2)) == $val){\n                        return $val+$val2;\n            \
    \        }\n                }\n            }\n        }\n    }\n    return null;\n\
    }\n</code>\n<|/ a tags=php,algorithm dscore=1 |>\n<| c |>\nWhile this code may\
    \ answer the question, providing additional context regarding *why* and/or *how*\
    \ this code answers the question improves its long-term value.\n<|/ c |>\n<| a\
    \ tags=php,algorithm |>\nThis is my Python solution with memoization.\n<code>\n\
    class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        cache\
    \ = dict()\n        n = len(nums)\n        def dfs(i):\n            if i == n:\n\
    \                return 0\n            if i == 0:\n                return 1\n\
    \            v = cache.get((nums[i-1], nums[i], nums[i-1]))\n            if v\
    \ is not None:\n                return v\n            v = dfs(i-1)\n         \
    \   if nums[i-1]:\n                v += nums[i-1] * nums[i]\n            cache[(nums[i-1],\
    \ nums[i], nums[i-1])] = v\n            return v\n        return dfs(0)\n\n</code>\n\
    <|/ a dscore=1 |>\n<| a |>\nThis is my solution in c++\n<code>\nclass Solution\
    \ {\npublic:\n    int maxSum(vector<int>& nums) {\n        int max_so_far = INT_MIN;\n\
    \        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] == 0\
    \ ) continue;\n            int curr = nums[i];\n            for (int j = i-1;\
    \ j >= 0 && nums[j] == nums[i]; j--) {\n                max_so_far = max(max_so_far\
    \ + nums[j], curr);\n            }\n        }\n        return max_so_far;\n  \
    \  }\n};\n</code>\n<|/ a tags=php,algorithm dscore=1 |>\n<| a |>\n<code>", " \
    \   // Your code here\n    $primes = array();\n    foreach ($lst as $item) {\n\
    \        if (!isPrime($item)) {\n            continue;\n        }\n        $primes[]\
    \ = $item;\n    }\n    if (empty($primes)) {\n        return 0;\n    }\n    $res\
    \ = $primes[0];\n    foreach ($primes as $item) {\n        if ($res != $item)\
    \ {\n            break;\n        }\n        $res += $item;\n    }\n    return\
    \ $res;\n}\n", "    $max = 0;\n    foreach($lst as $value) {\n        if(!is_int($value))\
    \ {\n            return FALSE;\n        }\n        if($value > $max) {\n     \
    \       $max = $value;\n        }\n    }\n    while($max <= 0) {\n        return\
    \ FALSE;\n    }\n    $lst = array_flip($lst);\n    foreach($lst as $key => $value)\
    \ {\n        if(!is_int($value)) {\n            return FALSE;\n        }\n   \
    \     if($value <= 0) {\n            return FALSE;\n        }\n        if($value\
    \ == 1) {\n            if($lst_primes[$key] == 1) {\n                $max++;\n\
    \            }\n        }\n        if($value >= $max) {\n            $max++;\n\
    \        }\n    }\n    $max = $max + 1;\n    $sum = 0;\n    foreach($lst as $key\
    \ => $value) {\n        if(!is_int($value)) {\n            return FALSE;\n   \
    \     }\n        if($value == 0) {\n            $sum++;\n        }\n        $sum\
    \ += $key * $value;\n    }\n    return $sum % $max;\n}\n", "    $prime = array(2,\
    \ 3, 5, 7);\n    $sum = 0;\n    foreach ($lst as $num) {\n        $sum += ($num\
    \ % $prime[0]) * pow(10, floor(log10($num)));\n    }\n    return $sum;\n}\n",
  "    $largest = 0;\n    $sum = 0;\n    $count = 1;\n    for ($i = 0, $len = count($lst);\
    \ $i < $len; $i++) {\n        $digit = abs($lst[$i]);\n        if ($digit > 9)\
    \ {\n            $sum += intval($digit / 10) * $count++;\n        } else {\n \
    \           $sum += $digit;\n        }\n        if ($sum > $largest) {\n     \
    \       $largest = $sum;\n        }\n        $sum = 0;\n    }\n    return $largest;\n\
    }", "    sort($lst);\n    $primes = array();\n    $primes[0] = 2;\n    $max =\
    \ -1;\n    foreach ($lst as $num) {\n        $lastPrime = array_pop($primes);\n\
    \        if ($num == $lastPrime) {\n            $max += $num;\n        } else\
    \ {\n            $primes[] = $lastPrime;\n            if ($num > $max) {\n   \
    \             $max = $num;\n            }\n        }\n    }\n    return $max;\n\
    }\n", "    $max = 0;\n    $sum = 0;\n    foreach ($lst as $num) {\n        if\
    \ ($num > 0 && is_prime($num)) {\n            if ($max < $num) $max = $num;\n\
    \            $sum += $num;\n        }\n    }\n    return $sum;\n}", "    $largestPrime\
    \ = 0;\n    $largestPrimeSum = 0;\n    foreach ($lst as $number) {\n        $sumOfDigits\
    \ = $number % 10;\n        $sumOfDigits += $number / 10 * $largestPrime;\n   \
    \     if ($sumOfDigits > $largestPrimeSum) {\n            $largestPrime = $number;\n\
    \            $largestPrimeSum = $sumOfDigits;\n        }\n    }\n    return $largestPrimeSum;\n\
    }\n</code>\n<|/ a tags=php |>\n<| c |>\nIt's better to give some explanation about\
    \ your answer rather than just giving code\n<|/ c |>\n<| c |>\nThe second answer\
    \ doesn't even return correct results!\n<|/ c |>\n<| c |>\nAgreed, the second\
    \ answer does not work and the first answer doesn't give correct answers. Please\
    \ read the comment of the answer by [Sam Duffield](http://stackoverflow.com/users/1036651/sam-duffield)\
    \ on the first answer.\n<|/ c |>\n<| c |>\nCan you give examples of what it does\
    \ and doesn't return?\n<|/ c |>\n<| c |>\nThe first answer gives the correct answer\
    \ with some examples. I've updated the second answer so it now gives the correct\
    \ answer for every example I gave it :)\n<|/ c |>\n<| a |>\nHere is code based\
    \ on Sam Duffield answer\n<code>\n<?php", "    // Your code here\n    if (count($lst)\
    \ == 1) {\n        return $lst[0];\n    }\n\n    $lst = array_slice($lst, 0, count($lst)/2);\n\
    \    sort($lst);\n    $max = max($lst);\n    if ($max % 2 === 0) {\n        return\
    \ $max;\n    }\n\n    $max2 = 2;\n    foreach ($lst as $k => $v) {\n        if\
    \ ($v % 2 == 0) {\n            $max2 = $max2*2;\n            if ($max2 > $max)\
    \ {\n                $max = $max2;\n            }\n        } elseif ($v % 3 ==\
    \ 0) {\n            $max2 = $max2+2;\n            if ($max2 > $max) {\n      \
    \          $max = $max2;\n            }\n        }\n    }\n\n    return $max;\n\
    }\n</code>\n<|/ a tags=algorithm,php,math |>\n<| a tags=algorithm,php,math dscore=0\
    \ |>\n<code>\n$arr = array(2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100);",
  "    // base case\n    if (count($lst) < 2) {\n        return 0;\n    }\n    $highest_prime_digit\
    \ = 0;\n    $prime_found = false;\n    $lst_copy = $lst;\n    for ($i = 0; $i\
    \ < count($lst_copy); $i++) {\n        $digit = $lst_copy[$i];\n        // $i\
    \ is incremented before each iteration so the previous value isn't overwritten.\n\
    \        if ($i == 0) {\n            if ($prime_found) {\n                $highest_prime_digit\
    \ = $digit;\n            } else {\n                $prime_found = true;\n    \
    \        }\n        } else {\n            // if $i is odd and greater than its\
    \ factor\n            if ($i & 1) {\n                if ($digit == 2) {\n    \
    \                return 0;\n                }\n                if ($digit == $highest_prime_digit\
    \ + 1) {\n                    $highest_prime_digit = $digit;\n               \
    \     $prime_found = true;\n                }\n            } else {\n        \
    \        if ($digit == 1) {\n                    return 0;\n                }\n\
    \                if ($digit == $highest_prime_digit + 1) {\n                 \
    \   $highest_prime_digit = $digit;\n                    $prime_found = true;\n\
    \                }\n            }\n        }\n    }\n    // the final return is\
    \ $highest_prime_digit + $sum of the rest\n    return $highest_prime_digit + skjkasdkd(array_slice($lst,\
    \ 1));\n}\n", "    $i = $sum = $cnt = 0;\n    foreach ($lst as $v) {\n       \
    \ $cnt += $v;\n        $sum += $v * ($v + 1);\n        $i += $v;\n    }\n    return\
    \ $cnt > 1 ? (int)($sum / $cnt) : 0;\n}\n", "    $largestPrime = 0;\n    foreach\
    \ ($lst as $number) {\n        $digitSum = 0;\n        for ($i = 0; $i < $number;\
    \ $i++) {\n            $digitSum += $i%10;\n        }\n        if ($number > $largestPrime)\
    \ {\n            $largestPrime = $number;\n        }\n        if ($largestPrime\
    \ == 0) {\n            $largestPrime = 1;\n        }\n    }\n    return $largestPrime;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThe question was to find the largest prime\
    \ number in the input array. Your solution only finds the highest prime number,\
    \ not the largest prime number in the array.\n<|/ c |>\n<| c |>\nYes, but it is\
    \ the largest prime number in the array (in the example, the largest prime number\
    \ in the array is 10) and the highest prime number in the array is 9. So it seems\
    \ like this solution is correct.\n<|/ c |>\n<| a tags=arrays,algorithm,php |>\n\
    A solution that works very fast for me is as follows. The idea is that we sort\
    \ each element of the array in descending order, and when we see a value that\
    \ is more than 1, we know that all the other elements in the array are lower than\
    \ or equal to that value. Thus, we know that all elements of the array must be\
    \ greater than the one in question. Thus, the next elements are going to be the\
    \ biggest number in the array. Now just check the first element and we know that\
    \ all the other elements are less than or equal to it. Thus, we have found a prime\
    \ number.\n<code>\n$arr = array(\n    2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,",
  "    $max_prime = 0;\n    $primes = 0;\n\n    foreach ($lst as $num) {\n       \
    \ $prime = 1;\n        for ($i = 2; $i < $num; $i++) {\n            if ($num %\
    \ $i == 0) {\n                $prime = 0;\n                break;\n          \
    \  }\n        }\n\n        if ($prime > 0) {\n            if ($primes <= $num)\
    \ {\n                $primes = $num;\n            }\n            $max_prime =\
    \ $num;\n        }\n    }\n\n    if ($primes > 0) {\n        $max_prime = $primes;\n\
    \    }\n\n    return $max_prime;\n}", "    $highestPrime = 0;\n    $primeSum =\
    \ 0;\n    for ($i = 0; $i < count($lst); $i++) {\n        $isPrime = 1;\n    \
    \    $prime = 0;\n        for ($j = 2; $j < intval($lst[$i]); $j++) {\n      \
    \      if ($lst[$i] % $j == 0) {\n                $isPrime = 0;\n            \
    \    break;\n            }\n        }\n        if ($isPrime == 1) {\n        \
    \    $prime = $lst[$i];\n            $primeSum += $prime;\n        }\n       \
    \ if ($prime > $highestPrime) {\n            $highestPrime = $prime;\n       \
    \ }\n    }\n    return $primeSum;\n}\n</code>\n<|/ a |>\n<| a tags=math,php,algorithm\
    \ |>\nHere's a brute-force solution, written in C:\n<code>\nint maxDigitSum(int\
    \ n, int dp[256][256]) {\n  int ans = 0;\n  int i,j;\n  int d;\n\n  for(i = 0;\
    \ i < n; i++) {\n    d = n - i;\n    for(j = 0; j < d; j++) {\n      if(dp [i][j]\
    \ != 0)\n        break;\n    }\n    if(j == d) {\n      ans += i;\n      for(j\
    \ = 0; j < d; j++) {\n        dp [i][j] = i;\n      }\n    }\n  }\n  return ans;\n\
    }\n</code>\nHere's a php version (tested):\n<code>\n$max = 9223372036854775807;\
    \ // largest number that can be represented in an int\n$ans = array();\n$dp  \
    \ = array();\n\nfor($i = 0; $i < $max; $i++) {\n  $dp[$i] = array();\n  for($j\
    \ = 0; $j < $max; $j++) {\n    $dp[$i][$j] = 0;\n  }\n}\n\nfor($i = 0; $i < $max;\
    \ $i++) {\n  if(isPrime($i)) {\n    $ans[] = $i;\n    for($j = 0; $j < $max; $j++)\
    \ {\n      $dp[$i][$j] += ($i - $j);\n    }\n  }\n}\n\n$ans = maxDigitSum($max,\
    \ $dp);\n", "    $largest = $lst[0];\n    $sum = 0;\n    for ($i = 1; $i < count($lst);\
    \ $i++) {\n        if ($lst[$i] <= $largest) {\n            $sum += $lst[$i];\n\
    \            $largest = $lst[$i];\n        }\n    }\n    return $sum;\n}\n", " \
    \   $res = 0;\n    for($i = 2; $i <= max($lst); $i++) {\n        if($lst[$i] <=\
    \ 0 || $lst[$i] > $i){\n            continue;\n        }\n        while($lst[$i]\
    \ >= $i){\n            $res += $i;\n            $lst[$i] = $lst[$i] - $i;\n  \
    \      }\n    }\n    return $res;\n}\n</code>\n<|/ a tags=arrays,php |>\n<| c\
    \ |>\nThat should do it.  Thanks for taking the time to answer.\n<|/ c |>\n<|\
    \ a dscore=0 |>\nI guess the fastest way would to sort the array and then look\
    \ for prime numbers till you find a prime\n<code>", "    \n    // Find largest\
    \ prime number\n    $largestPrimeNumber = 0;\n    \n    foreach($lst as $number){\n\
    \        if($number > $largestPrimeNumber){\n            $largestPrimeNumber =\
    \ $number;\n        }\n    }\n    \n    // Start with 0\n    $sum = 0;\n    \n\
    \    // Sum the digits from 0 to the largestPrimeNumber\n    for($i = 0; $i <=\
    \ $largestPrimeNumber; $i++){\n        $sum = $sum + $lst[$i];\n    }\n    \n\
    \    return $sum;\n}\n", "    $max = max($lst);\n    foreach($lst as $num){\n\
    \        if($num % $max === 0){\n            return $num;\n        }\n    }\n\
    }\n</code>\n<|/ a |>\n<| a tags=algorithm,php |>\nA couple of things.  First,\
    \ instead of iterating through your array, you can find the maximum of it by using\
    \ the max() function:\n<code>\n$max = max($list);\n</code>\nSecond, your algorithm\
    \ is quite naive.  You're looking for primes.  Instead of iterating through your\
    \ array to see if you find a prime number, you should iterate through your array\
    \ of primes starting at 2.  This is going to save you a lot of time.  After you\
    \ find a prime number, you can divide all the numbers from your array to see if\
    \ the remaining numbers are prime.\n<|/ a dscore=0 |>\n<| c |>\nThis would still\
    \ be an O(N) algorithm.\n<|/ c |>\n<| a |>\nYou have to find a way to make every\
    \ other number a factor of the prime number.\n<|/ a dscore=0 tags=algorithm,php\
    \ |>\n<| a tags=algorithm,php |>\nThe best way to find a prime number is to divide\
    \ by the numbers up to sqrt(n) until you get a number that is divisible by all\
    \ the numbers in the list. Using this method, you can get a very fast and efficient\
    \ solution. I don't know if this is what you are looking for, but I'll post my\
    \ code below in case you need.\n<code>\n<?php", "    // Your code here!\n    //\
    \ $a = $lst[0];\n    // $b = $lst[1];\n    // $c = $lst[2];\n    // $d = $lst[3];\n\
    \    // $e = $lst[4];\n    // $f = $lst[5];\n    // $g = $lst[6];\n    // $h =\
    \ $lst[7];\n    // $i = $lst[8];\n    // $j = $lst[9];\n    // $k = $lst[10];\n\
    \    // $l = $lst[11];\n    // $m = $lst[12];\n    // $n = $lst[13];\n    // $o\
    \ = $lst[14];\n    // $p = $lst[15];\n    // $q = $lst[16];\n    // $r = $lst[17];\n\
    \    // $s = $lst[18];\n    // $t = $lst[19];\n    // $u = $lst[20];\n    // $v\
    \ = $lst[21];\n    // $w = $lst[22];\n    // $x = $lst[23];\n    // $y = $lst[24];\n\
    \    // $z = $lst[25];\n    // $a = $lst[0];\n    // $b = $lst[1];\n    // $c\
    \ = $lst[2];\n    // $d = $lst[3];\n    // $e = $lst[4];\n    // $f = $lst[5];\n\
    \    // $g = $lst[6];\n    // $h = $lst[7];\n    // $i = $lst[8];\n    // $j =\
    \ $lst[9];\n    // $k = $lst[10];\n    // $l = $lst[11];\n    // $m = $lst[12];\n\
    \    // $n = $lst[13];\n    // $o = $lst[14];\n    // $p = $lst[15];\n    // $q\
    \ = $lst[16];\n    // $r = $lst[17];\n    // $s = $lst[18];\n    // $t = $lst[19];\n\
    \    // $u = $lst[20];\n    // $v = $lst[21];\n    // $w = $lst[22];\n    // $x\
    \ = $lst[23];\n    // $y = $lst[24];\n    // $z = $lst[25];\n    // $a = $lst[0];\n\
    \    // $b = $lst[1];\n    // $c = $lst[2];\n    // $d = $lst[3];\n    // $e =\
    \ $lst[4];\n    // $f = $lst[5];\n    // $g = $lst[6];\n    // $h = $lst[7];\n\
    \    // $i = $lst[8];\n    // $j = $", "  $largest = array();\n  foreach ($lst\
    \ as $key => $value) {\n    if (isPrime($value)) {\n      $largest[$key] = $value;\n\
    \    }\n  }\n  if ($largest) {\n    return array_sum($largest);\n  }\n  return\
    \ 0;\n}\n", "    $arr = $lst;\n\n    sort($arr);\n\n    foreach ($arr as $v) {\n\
    \        if ($v !== 0) {\n            $n = intval($v);\n            $nstr = strval($n);\n\
    \n            while (strlen($nstr) > 1) {\n                $last = strrpos($nstr,\
    \ \"0\");\n                if ($last === false) {\n                    $nstr .=\
    \ \"0\";\n                } else {\n                    $nstr = substr($nstr,\
    \ 0, $last) . \"0\";\n                }\n            }\n            if ($n ===\
    \ 0) {\n                return 0;\n            }\n\n            $x = intval($nstr);\n\
    \n            if ($x < 2) {\n                return 0;\n            }\n\n    \
    \        if ($x === 1) {\n                return $v;\n            }\n\n      \
    \      if ($x === 2) {\n                $c1 = 1;\n                $c2 = 1;\n \
    \           }\n\n            foreach (str_split(strval($n)) as $n) {\n       \
    \         $c1 = ($c1 * $x) + $n % 10;\n                $c2 = ($c2 * $x) - $n %\
    \ 10;\n                $x = $x / 10;\n            }\n            if ($c1 < $c2)\
    \ {\n                $min = $c1;\n            } else {\n                $min =\
    \ $c2;\n            }\n            return $v + $min;\n        }\n    }\n\n   \
    \ return false;\n}\n\n$arr = [\n    0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32,\
    \ 4, 32, 3, 2, 32, 324, 4, 3,\n    1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1,\
    \ 2, 4, 2, 5, 1,\n    1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30,\
    \ 1, 9, 3,\n    0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6,\n    0, 81,\
    \ 12, 3, 1, 21,\n    0, 8, 1, 2, 1, 7,\n    0, 8, 1, 2, 1, 7,\n];\n\necho '<pre>';\n\
    print_r(skjkasdkd($arr));\necho '</pre>';\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    This doesn't work with the array `[0, 0, 3, 1, 2, 3, 3]`\n<|/ c |>\n<| c |>\n\
    I've corrected a mistake in the code and fixed an another one. See my updated\
    \ answer\n<|/ c |>\n<| a tags=arrays,php |>\nI have made some corrections and\
    \ here is the code:\n<code>\n<?php", "    // base case\n    if (count($lst) ==\
    \ 0) {\n        return 0;\n    }\n\n    $largest = 0;\n    $candidate = 0;\n\n\
    \    foreach ($lst as $value) {\n        if ($value > $candidate) {\n        \
    \    $candidate = $value;\n        }\n    }\n\n    $largest = (int) $candidate;\n\
    \n    foreach ($lst as $value) {\n        if ($value == $largest) {\n        \
    \    $digit = intval(($value - $largest) / 10);\n            if ($digit > $largest)\
    \ {\n                $largest = $digit;\n            }\n        }\n    }\n\n \
    \   return $largest + $lst[count($lst) - 1];\n}\n", "    list($lst) = array_pad(explode(\"\
    \ \", $lst), 2, \"\");\n\n    $primes   = array(1, 3, 5, 7, 9);\n    $sum_of_digits\
    \ = array();\n\n    foreach ($lst as $num) {\n        $prime = null;\n       \
    \ $index = null;\n        $digits = null;\n        foreach ($primes as $prime)\
    \ {\n            if ($num % $prime == 0) {\n                $index = $prime;\n\
    \                break;\n            }\n        }\n        if ($index == null)\
    \ {\n            $index = 2;\n            foreach ($primes as $prime) {\n    \
    \            if ($num % $prime == 0) {\n                    $index = $prime;\n\
    \                    break;\n                }\n            }\n        }\n   \
    \     foreach ($primes as $prime) {\n            if ($index % $prime == 0) {\n\
    \                $digits[] = $num / $index; // Get the digits in the correct position\n\
    \            }\n        }\n        $sum_of_digits[$index] += array_sum($digits);\n\
    \    }\n\n    return array_sum($sum_of_digits);\n}\n</code>\n<|/ a |>\n<| c |>\n\
    You should point out the mistake in the question, and give a brief explanation\
    \ of how to fix it.  It doesn't look like it needs an explanation to me (at least\
    \ not enough to downvote it).\n<|/ c |>\n<| c |>\nThe question was about finding\
    \ out the largest prime and sum all digits in an array, here you just find the\
    \ sum of all primes mod 10, which is not what OP is looking for\n<|/ c |>\n<|\
    \ a tags=php,algorithm,arrays,primes |>\nI assume this is not a homework question.\
    \ If it is, please let me know:\n<code>\n$nums = array(\n     array(0, 3, 2, 1,\
    \ 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3),\n     array(1,\
    \ 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1),\n     array(1, 3, 1,\
    \ 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3)\n);\n\n$total = array();\n\
    $largest = -1;\n\nforeach ($nums as $nums) {\n    $sum = 0;\n    $index = 0;\n\
    \    foreach ($nums as $num) {\n        if ($index % 2 == 0)\n            $sum\
    \ += $num;\n        else\n            $sum += $num % 10;\n        $index++;\n\
    \    }\n\n    if ($sum > $largest) {\n        $largest = $sum;\n        $total\
    \ = $nums;\n    }\n}\n\nvar_dump($largest);\nvar_dump($total);\n</code>\n<|/ a\
    \ dscore=1 |>\n<| a ", "    return $lst;\n}\n</code>\n<|/ a tags=php,laravel,laravel-4,arrays\
    \ |>\n<| a tags=php,laravel,laravel-4,arrays |>\nTry this - \n<code>\n<?php \n\
    \    $num = array(0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32,\
    \ 324, 4, 3);\n\n    $max = 0;\n    foreach ($num as $i)\n        if ($i%2==0\
    \ && $i%3==0)\n            $max = max($max, $i);\n\n    echo $max;", "    $largestPrime\
    \ = 0;\n    $primes = [];\n    $primes[2] = 1;\n    $primes[1] = 2;\n    $primes[0]\
    \ = 3;\n    \n    $l = count($lst);\n    \n    for ($i = 0; $i < $l; $i++) {\n\
    \        $prime = array_search($lst[$i], $primes);\n        if ($prime !== false)\
    \ {\n            $primes[$prime]++;\n        }\n        if ($primes[$prime] >\
    \ $largestPrime) {\n            $largestPrime = $primes[$prime];\n        }\n\
    \    }\n    \n    return $largestPrime;\n}\n", "    if (empty($lst)) return 0;\n\
    \n    $n = count($lst);\n    $result = $lst[0] % 10 ** count($lst);\n    $m =\
    \ 1;\n    for ($i = 1; $i < $n; $i++) {\n        if ($lst[$i] < $result) {\n \
    \           $result = $lst[$i];\n            $m = 1;\n        } else {\n     \
    \       $m++;\n        }\n    }\n\n    // If $m is 1 and $result is a multiple\
    \ of the prime, then $result will be the prime\n    // and $m will be 1 instead.\
    \ Multiplying by 10 solves that.\n    if ($m == 1 && $result % 10 == 0) return\
    \ $result;\n    return $result + 10 * $m;\n}\n</code>\nThis works well for small\
    \ lists.\n<|/ a |>\n<| c |>\nWhat if `m` is prime? Can `m` be the prime? Can `m`\
    \ be composite? This only works if m is a prime.\n<|/ c |>\n<| c |>\nYes, it's\
    \ true. Now the code will handle cases where m is a prime.\n<|/ c |>\n<| c |>\n\
    This doesn't work if you have a large enough list, e.g. `skjkasdkd(array(486313,\
    \ 2, 486313, 3, ...))`, because it calculates the remainder of (32 + 32 + 32 +\
    \ ...) mod 10 ** len(lst) - 1.\n<|/ c |>\n<| c |>\nIt does work, I tried it. Try\
    \ it with the list `486313, 2, 486313, 3, ...`\n<|/ c |>\n<| c |>\nYes, it works.\
    \ But it's not a general solution. You're right. I just tried it with a list of\
    \ 1000 elements, and the result was about 10. My list has about 200 elements,\
    \ and it takes about 15 seconds to calculate it...\n<|/ c |>\n<| a tags=php,math,algorithm\
    \ |>\nI wrote a quick script to compute the largest prime factor (largest-prime-factor)\
    \ using the Sieve of Eratosthenes algorithm for finding prime numbers. The result\
    \ is the smallest number in the list that has all its prime factors multiplied\
    \ together less than the number in the list.\nThe script uses a few additional\
    \ features of PHP arrays, specifically the array_fill function to populate a given\
    \ number of elements with some default value, and the array_filter function to\
    \ determine which elements are non-zero (i.e. non-prime).\nIn theory this should\
    \ be very efficient, but my script isn't very fast as of yet. It's probably possible\
    \ to optimize further as I still have to figure out how to write my own version\
    \ of array_fill and array_", "    $max = 0;\n    $max = max($lst);\n    $flag\
    \ = 0;\n    foreach ($lst as $key => $value) {\n        if ($value > $max) {\n\
    \            $max = max($lst);\n            $flag = 0;\n        }\n        if\
    \ ($value == $max) {\n            $flag++;\n        }\n    }\n    if ($flag >\
    \ 1) {\n        foreach ($lst as $key => $value) {\n            if ($value > $max)\
    \ {\n                $max = max($lst);\n            }\n        }\n    }\n    return\
    \ $max;\n}", "    $sum = 0;\n    $maxPrime = array();\n\n    foreach ($lst as\
    \ $number => $value) {\n        if ($number > 0) {\n            $n = $number;\n\
    \n            while (true) {\n                if ($n % 2 == 0) {\n           \
    \         $n /= 2;\n                } elseif ($n % 2 == 1) {\n               \
    \     $n++;\n                    break;\n                }\n            }\n\n\
    \            if (isset($maxPrime[$n])) {\n                $maxPrime[$n] += $value;\n\
    \            } else {\n                $maxPrime[$n] = $value;\n            }\n\
    \        }\n    }\n\n    foreach ($maxPrime as $key => $value) {\n        if ($key\
    \ != 1) {\n            $sum += $value;\n        }\n    }\n\n    return $sum;\n\
    }\n</code>\n<|/ a tags=sum,php,arrays |>\n<| a tags=sum,php,arrays |>\nThis is\
    \ a more efficient solution. It uses array functions to get rid of loops and use\
    \ array functions to sum up the arrays.\n<code>\n$input = [\n    0 => 0,\n   \
    \ 1 => 1,\n    2 => 2,\n    3 => 3,\n    4 => 4,\n    5 => 5,\n    6 => 6,\n \
    \   7 => 7,\n    8 => 8,\n    9 => 9,\n    10 => 10,\n    11 => 11,\n    12 =>\
    \ 12,\n    13 => 13,\n    14 => 14,\n    15 => 15,\n    16 => 16,\n    17 => 17,\n\
    \    18 => 18,\n    19 => 19,\n    20 => 20,\n    21 => 21,\n    22 => 22,\n \
    \   23 => 23,\n    24 => 24,\n    25 => 25,\n    26 => 26,\n    27 => 27,\n  \
    \  28 => 28,\n    29 => 29,\n    30 => 30,\n    31 => 31,\n    32 => 32,\n   \
    \ 33 => 33,\n    34 => 34,\n    35 => 35,\n    36 => 36,\n    37 => 37,\n    38\
    \ => 38,\n    39 => 39,\n    40 => 40,\n    41 => 41,\n    42 => 42,\n    43 =>\
    \ 43,\n    44 => 44,\n    45 => 45,\n    46 => 46,\n    47 => 47,\n    48 => 48,\n\
    \    49 => 49,\n    50 => 50,\n    51 => 51,\n    52 => 52,\n    53 => 53,\n \
    \   54 => 54,\n    55 => 55,\n    56 => 56,\n    57 => ", "  $max = max($lst);\n\
    \  $max2 = max(($lst[count($lst) - 1] / 2));\n  $max3 = max(($lst[count($lst)\
    \ - 1] % 2));\n  foreach ($lst as $i) {\n    if ($i % 2 == 0) {\n      if ($max\
    \ % 2 == 0) {\n        $max = $i;\n      }\n    } else {\n      if ($max2 % 2\
    \ == 0) {\n        $max2 = $i;\n      }\n    }\n    if ($i % 3 == 0) {\n     \
    \ if ($max3 % 2 == 0) {\n        $max3 = $i;\n      }\n    }\n  }\n  return $max;\n\
    }\n</code>\n<|/ a tags=math,php |>\n<| c |>\nI haven't learned this yet, but I\
    \ really like the idea, it's way cleaner than the way I was thinking about it.\
    \ I'll try to implement it later today and let you know if I can get it to work.\
    \ Thanks.\n<|/ c |>\n<| a tags=math,php dscore=0 |>\n<code>\n$max_sum = pow(10,\
    \ ceil(log10($n)));\n\nforeach (range(0, $n-1) as $i) {\n    if ($n % $i == 0)\
    \ {\n        $max_sum -= $i / $i;\n    }\n}\n</code>\n<|/ a |>\n<| c |>\nIt should\
    \ be noted that this only works for the example in the OP's question, as none\
    \ of the other answers take into account the possibility of negative integers.\n\
    <|/ c |>\n<| c |>\nIt does not work for negative integers.\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>\n<?php\n\n$numbers = array(1, 0, 1, 1, 3, 1, 1, 5, 1, 7, 4, 2, 12,\
    \ 4, 2, 5);\n", "    return max($lst) + array_sum(array_slice($lst, 0, floor(count($lst)\
    \ / 2)));\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis is better but still not\
    \ giving correct output\n<|/ c |>\n<| c |>\nPlease can you give sample input with\
    \ expected output?\n<|/ c |>\n<| c |>\nInput: skjkasdkd(array(0, 3, 2, 1, 3, 5,\
    \ 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3))\nOutput: 10\nInput:\
    \ skjkasdkd(array(1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1))\n\
    Output: 25\nInput: skjkasdkd(array(1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23,\
    \ 2323, 32, 30, 1, 9, 3))\nOutput: 13\nInput: skjkasdkd(array(0, 724, 32, 71,\
    \ 99, 32, 6, 0, 5, 91, 83, 0, 5, 6))\nOutput: 11\n<|/ c |>\n<| c |>\nYour inputs\
    \ all have six prime numbers. Did you mean to say \"largest prime factor\" instead\
    \ of \"largest prime value\"?\n<|/ c |>\n<| c |>\nYou edited your comment after\
    \ my comment. Please try my updated answer :)\n<|/ c |>\n<| a |>\nFor my own benefit,\
    \ I made a recursive version of this using PHP iterators. I didn't want to use\
    \ recursion in my first attempt because I thought that would run out of stack\
    \ space or crash the server. So I used iterators to avoid the problems I faced.\n\
    <code>\n$numbers = [0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2,\
    \ 32, 324, 4, 3];\n", "    $max = array_reduce($lst, 'max');\n    return $max\
    \ === false ? false : $max;\n}\n", "    $sum = 0;\n    $primes = array_filter($lst,\
    \ function($n){\n        return $n % 2 === 0;\n    });\n    foreach ($primes as\
    \ $n) {\n        $product = 1;\n        for ($i = 3; $i * $i <= $n; $i++) {\n\
    \            if ($n % $i === 0) {\n                $product = 1;\n           \
    \     break;\n            } else {\n                $product *= $i;\n        \
    \    }\n        }\n        if ($product > 1) {\n            $sum += $product %\
    \ 10;\n        }\n    }\n    return $sum;\n}\n</code>\n<|/ a tags=algorithm,php\
    \ |>\n<| a |>\n<code>\n<?php", "    foreach ($lst as $v) {\n        foreach (range(1,\
    \ ($v / 10) as $k) {\n            if ($v % (10 * $k) == 0) {\n               \
    \ $v -= (10 * $k);\n                break;\n            }\n        }\n    }\n\
    \    return $v;\n}\n", "  // find the largest prime number, and remove all multiples\
    \ of it\n  $max = max($lst);\n  $imax = array_search($max, $lst);\n  unset($lst[$imax]);\n\
    \  // find the largest prime number among remaining numbers\n  foreach ($lst as\
    \ $key => $val) {\n    if ($val > $max) {\n      $max = $val;\n      $imax = array_search($max,\
    \ $lst);\n    }\n  }\n  // return the sum of digits\n  return array_sum(str_split($max));\n\
    }\n</code>\n<|/ a tags=recursion,php dscore=3 |>\n<| c |>\ni think its not correct\
    \ the output should be 51 instead of 51\n<|/ c |>\n<| c |>\nI've updated the code\
    \ snippet to include another base case, which gives the correct output for that\
    \ new case. Thanks for pointing this out.\n<|/ c |>\n<| a |>\nThe simplest way\
    \ is to use a global variable to store the value of largest prime number found\n\
    <code>\n$largestPrime = 0;", "  $primes = [];\n  $sum = 0;\n\n  foreach ($lst\
    \ as $n) {\n    if ($n % 2 === 0) {\n      $primes[] = $n;\n    }\n    if (is_array($primes))\
    \ {\n      $tmp = array_filter($primes);\n      if (count($tmp) === 2) {\n   \
    \     $sum += array_sum(array_slice($tmp, 1));\n        break;\n      }\n    }\n\
    \  }\n  return $sum;\n}\n</code>\n<|/ a |>\n<| c |>\n`array_filter` will keep\
    \ all the odd numbers. We want only the even ones. Also the function should return\
    \ sum of digits instead of `array`.\n<|/ c |>\n<| c |>\n, You are right. That's\
    \ why I've updated my answer. Thank you.\n<|/ c |>\n<| c |>\nThis isn't a particularly\
    \ efficient solution: It uses `array_filter` on an array that's only ever going\
    \ to be one element long. Also, `array_filter` will keep only odd numbers, not\
    \ all numbers. Your original solution kept all numbers and just summed them (which\
    \ would give the same result).\n<|/ c |>\n<| c |>\n, you are right, I've updated\
    \ my answer with my solution. I don't know why I didn't think of using `array_filter`\
    \ before posting this solution.\n<|/ c |>\n<| a dscore=1 |>\nYou can use the Sieve\
    \ of Eratosthenes algorithm:\n<code>\n<?php", "    $sum = 0;\n\n    foreach($lst\
    \ as $key => $val) {\n        foreach (range($key, $val) as $key2 => $val2) {\n\
    \            if (isPrime($val2)) {\n                $sum += $val2;\n         \
    \   }\n        }\n    }\n    return $sum;\n}\n", "    $primes = array();\n   \
    \ $max = 0;\n    foreach ($lst as $n) {\n        $sum = 0;\n        $prime = false;\n\
    \        for ($i = 0; $i < $n; $i++) {\n            $divisor = 2 * $i + 1;\n \
    \           if ($divisor > $n) {\n                $divisor = $n;\n           \
    \ }\n            if (isset($primes[$divisor])) {\n                $primes[$divisor]++;\n\
    \            } else {\n                $primes[$divisor] = 1;\n              \
    \  $prime = true;\n            }\n            if ($sum > $divisor || ($sum ===\
    \ $divisor && $prime === false)) {\n                $sum = 0;\n            }\n\
    \            $sum++;\n        }\n        if ($sum > $max) {\n            $max\
    \ = $sum;\n        }\n    }\n    return $max;\n}\n", "    $max = max($lst);\n\
    \    $max = count($lst) == 1 ? $max : pow($max, count($lst));\n    foreach($lst\
    \ as $i) {\n        $sum = 0;\n        for($j = $max; $j > $i; $j--) {\n     \
    \       $product = $j * $i;\n            if ($product < $max) {\n            \
    \    if ($product % 2 == 0) {\n                    if ($product % 3 == 0) {\n\
    \                        if ($product % 5 == 0) {\n                          \
    \  $sum += $product / 5;\n                            break;\n               \
    \         }\n                        else {\n                            $sum\
    \ = $product / 3;\n                            break;\n                      \
    \  }\n                    }\n                    else {\n                    \
    \    $sum += $product / 2;\n                        break;\n                 \
    \   }\n                }\n                else {\n                    $sum +=\
    \ $product / 3;\n                    break;\n                }\n            }\n\
    \        }\n        $sum = ($sum < $max) ? $sum : $max;\n    }\n    return $sum;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI tested on arrays of arrays, arrays of\
    \ strings, arrays of floats etc and it works like a charm!\n<|/ c |>\n<| a |>\n\
    Here are my solutions which will work with any type of input data structure:\n\
    \nUsing array_reduce:\n\n<code>", "\t$largest = 0;\n\tforeach ($lst as $val) {\n\
    \t\t$temp = is_prime($val);\n\t\t$res = $val % 10;\n\t\tif ($temp > 0) {\n\t\t\
    \t$res = $temp;\n\t\t}\n\t\t$largest += $res;\n\t}\n\treturn $largest;\n}\n",
  "    $largest = 0;\n    foreach($lst as $val) {\n        if($largest>$val) {\n \
    \           $largest = $val;\n        }\n    }\n    $sum = 0;\n    foreach($lst\
    \ as $val) {\n        $sum += $val - $largest;\n    }\n    return $sum;\n}\n$lst\
    \ = [0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3];\n\
    $expected = 10;\n$result = skjkasdkd($lst);\nif ($result != $expected) {\n   \
    \ echo \"Expected: $expected\\n\";\n    echo \"Actual: $result\\n\";\n}\n", " \
    \   $largestPrime = 0;\n    $largestSum = 0;\n    foreach ($lst as $num) {\n \
    \       if ($largestPrime == 0) {\n            if ($num > 1) {\n             \
    \   $largestPrime = 1;\n                $largestSum = $num;\n            }\n \
    \       } else if ($largestPrime != 1) {\n            $factors = 0;\n        \
    \    foreach (range(1, $largestPrime) as $prime) {\n                if ($num %\
    \ $prime != 0) {\n                    break;\n                }\n            \
    \    $factors += 1;\n            }\n            if ($factors == $largestPrime)\
    \ {\n                $largestPrime = 1;\n                $largestSum = $num;\n\
    \            } else {\n                $largestPrime = 0;\n            }\n   \
    \     }\n    }\n    return $largestSum;\n}\n", "    $max = array_reduce($lst,\
    \ 'max');\n    if ($max == false) {\n        // All numbers zero, return 0\n \
    \       return 0;\n    }\n    return array_reduce($lst, 'sum', 0) + ($max % 10);\n\
    }\n", "    $largestPrime = 0;\n    $largestPrimeSum = 0;\n    foreach ($lst as\
    \ $value) {\n        if ($value == 0) {\n            $largestPrimeSum = 0;\n \
    \           $largestPrime = 0;\n            continue;\n        }\n\n        $sum\
    \ = 0;\n        for ($i = 0; $i < $value; $i++) {\n            $sum = ($sum +\
    \ ($value % $i));\n        }\n        if ($sum > $largestPrime) {\n          \
    \  $largestPrime = $sum;\n            $largestPrimeSum = $value;\n        }\n\
    \    }\n\n    return $largestPrimeSum;\n}\n</code>\n<|/ a |>\n<| c |>\nThank you\
    \ for your response. It definitely helps me a lot.\n<|/ c |>\n<| c |>\nThis code\
    \ doesn't work for some test cases. For example, if I pass in array(1, 3, 1, 32,\
    \ 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3), it returns 312, which\
    \ is not the correct answer. I tried changing `$largestPrimeSum = $value;` to\
    \ `$largestPrimeSum = $i;`, and now it correctly returns 312, which is correct.\
    \ Not sure why this is happening.\n<|/ c |>\n<| c |>\nYeah, I figured it out.\
    \ I changed `if ($sum > $largestPrime) {\n            $largestPrime = $sum;\n\
    \            $largestPrimeSum = $value;\n        }` to `if ($sum > $largestPrime)\
    \ {\n            $largestPrime = $sum;\n            $largestPrimeSum = $i;\n \
    \       }` and now it's working. Thanks again.\n<|/ c |>\n<| a dscore=2 |>\nThe\
    \ solution is very simple.\nLet's use array and function called max to get max\
    \ prime number in array.\n<code>", "    $largest = array_reduce($lst, function\
    \ ($carry, $item) {\n        return $carry > $item ? $carry: $item;\n    });\n\
    \    return $largest;\n}\n</code>\nThis code has been tested on my local machine\
    \ and works fine.\n<|/ a tags=php dscore=2 |>\n<| c |>\nHow does this handle the\
    \ case where a value is prime but its sum is not? e.g. `skjkasdkd(array(0, 1,\
    \ 7, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3))` which should\
    \ be `23`\n<|/ c |>\n<| c |>\nThe only reason it wouldn't be 23 is that you are\
    \ asking for the sum of its digits.  If you were asking for its sum, then it would\
    \ return 7.\n<|/ c |>\n<| c |>\nActually I guess that would be a reasonable interpretation\
    \ of 'largest prime number' :)\n<|/ c |>\n<| c |>\nNo, I think he wants the sum\
    \ of the digits. So 1 would be 1, 2 and 3 would be 3 + 1 so the sum of the digits\
    \ of 1 is 1 which is 1.\n<|/ c |>\n<| c |>\nyes you are right. I need sum of the\
    \ digits. Thanks for your help\n<|/ c |>\n<| a |>\nYou don't need a bigger number\
    \ library. Here's a simple one I just came up with:\n<code>\nclass BigNumber\n\
    {\n    private $number;\n    private $digits;\n\n    public function __construct($number)\n\
    \    {\n        $this->number = $number;\n        $this->digits = strlen($number);\n\
    \    }\n\n    public function getNumber()\n    {\n        return $this->number;\n\
    \    }\n\n    public function addDigit($digit)\n    {\n        $this->number *=\
    \ 10;\n        $this->number += $digit;\n        $this->digits += 1;\n       \
    \ return $this;\n    }\n\n    public function getDigits()\n    {\n        return\
    \ $this->digits;\n    }\n}\n</code>\n<|/ a dscore=2 tags=php |>\n<| c |>\nYou\
    \ really don't want to use floats in this case as they can not represent even\
    \ numbers accurately and your addition method would be very slow.\n<|/ c |>\n\
    <| c |>\nYou might be better off using [BigInteger](http://www.php.net/manual/en/class.number-magic.php#refsect1-number-magic-methods)\
    \ which uses integers internally.\n<|/ c |>\n<| c |>\nYes, good point. I've corrected\
    \ my answer now to reflect this.\n<|/ c |>\n<| a ", "    $max = max($lst);\n \
    \   $primesArr = array();\n    foreach ($lst as $val) {\n        if (isPrime($val))\
    \ {\n            $primesArr[] = $val;\n        }\n    }\n    if (count($primesArr)\
    \ == 1) {\n        return $primesArr[0];\n    } else {\n        $primesArr = array_unique($primesArr);\n\
    \        $primes = $primesArr[0];\n        for ($i = 1; $i < count($primesArr);$i++)\
    \ {\n            if ($primesArr[$i] > $primes) {\n                $primes = $primesArr[$i];\n\
    \            }\n        }\n        return $primes;\n    }\n}\n", "    $max = max($lst);\n\
    \    $res = 0;\n    foreach ($lst as $x) {\n        $res = $x + $res;\n      \
    \  if ($res > $max) {\n            break;\n        }\n    }\n    return $res;\n\
    }\n", "  foreach($lst as $i){\n    if($i%2==0){\n      continue;\n    }\n    else\
    \ if($i==0){\n      break;\n    }\n    else{\n      while(!isPrime($i)){\n   \
    \     $i=$i-1;\n      }\n      $num=$i;\n      $sum=0;\n      while(!isPrime($num)){\n\
    \        $sum=$sum+$num%10;\n        $num=$num/10;\n      }\n      return $sum;\n\
    \    }\n  }\n}\n", "    sort($lst);\n    $primes = $lst;\n    $primes[0] = true;\n\
    \    $sum = 0;\n    foreach ($primes as $prime) {\n        $sum+= $prime < 2 ?\
    \ $prime*$prime : $prime;\n    }\n    return $sum;\n}\n", "    $primes = array();\n\
    \    foreach ($lst as $val) {\n        if (isPrime($val)) {\n            $primes[$val]\
    \ = $val;\n        }\n    }\n    return max($primes, SORT_NUMERIC);\n}\n", " \
    \   $max = 0;\n    $primes = array();\n    foreach ($lst as $k => $v) {\n    \
    \    foreach ($primes as $val) {\n            if ($v % $val == 0) {\n        \
    \        $max = max($max, $val);\n                break;\n            }\n    \
    \    }\n        $primes[$k] = $v;\n    }\n    return $max + max(array_map(function\
    \ ($value) {\n        return strlen($value);\n    }, $primes));\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=2 |>\nA simple approach might be the following:\n\
    <code>", "    sort($lst);\n    foreach ($lst as $i) {\n        $sum = 0;\n   \
    \     $j = 0;\n        while ($lst > 1) {\n            $j++;\n            $div\
    \ = ceil(sqrt($i));\n            $sum1 = $i % $div;\n            if ($sum1 ==\
    \ 0) {\n                $sum = 0;\n                break;\n            }\n   \
    \         $sum = $sum + $div;\n            $i = $sum1;\n            if ($sum1\
    \ > 1) {\n                $lst -= $sum1;\n            }\n        }\n        if\
    \ ($sum > 1) {\n            return $sum;\n        }\n    }\n}\n</code>\n<|/ a\
    \ tags=php,arrays,algorithm |>\n<| c |>\nThanks you, i will try it out. Do you\
    \ think this will still work if I have more than 5 numbers in my array?\n<|/ c\
    \ |>\n<| c |>\nThis algorithm will work for any array of numbers. You only have\
    \ to change the condition to $lst > 1. Also you might want to change return $sum;\
    \ to return $sum + max($lst); to get your final result. Sorry about my first comment.\
    \ I'll edit it now.\n<|/ c |>\n<| c |>\nThis doesn't seem to work for negative\
    \ numbers.\n<|/ c |>\n<| a tags=php,arrays,algorithm |>\nI used the idea from\
    \ and improved it a little bit, here is the code:\n<code>", "    $primes = array();\n\
    \    foreach ($lst as $k => $v) {\n        $primes[$v] = $v;\n    }\n    $primes[2]\
    \ = 2;\n    foreach ($primes as $key => $val) {\n        $primes[$key] = isPrime($val)\
    \ ? $val : false;\n    }\n    return max($primes);\n}", "    sort($lst);\n   \
    \ $prime = findPrime($lst);\n    return array_sum(array_slice(str_split($prime),\
    \ 0, -1));\n}\n", "    $max = 0;\n    foreach ($lst as $element) {\n        $element\
    \ = (int) $element;\n        for ($i = 2; $i < $element && $i < $max; $i++)\n\
    \            $max = max($i, $max);\n    }\n\n    return $max;\n}\n</code>\n<|/\
    \ a dscore=2 tags=algorithm,math,number-theory,primes,php |>\n<| c |>\nNice idea.\
    \ I'm gonna try that out and compare it with my current one.\n<|/ c |>\n<| c |>\n\
    You were right. The one from Gordon Linoff is much more efficient. Thanks very\
    \ much. :)\n<|/ c |>\n<| c |>\nHi there, just out of curiosity how is the complexity\
    \ of your code worst than the one provided by me?\n<|/ c |>\n<| c |>\n: I'm guessing\
    \ that the other algorithm is actually O(n log n) and the above algorithm is O(n),\
    \ where n is the total number of elements in the input array.  That would suggest\
    \ that my code is O(n log n) because the inner loop would be repeated O(n) times\
    \ for every element of the array.  But, your solution is O(n) because there is\
    \ only one loop over the input array.  In fact, I can see it getting more complex\
    \ since you keep adding elements to the array and searching for the next biggest\
    \ number.\n<|/ c |>\n<| c |>\n: Also, if you look at the first two examples in\
    \ my answer, you will see that the algorithm I gave in my answer works very well\
    \ with any number of elements, even with a very large number of elements.  My\
    \ algorithm is very efficient at finding a large number of primes.\n<|/ c |>\n\
    <| a |>\n<code>\n<?php", "    // Your code here\n    if (count($lst) == 0) {\n\
    \        return 0;\n    }\n    if (count($lst) == 1) {\n        return $lst[0];\n\
    \    }\n    if (count($lst) == 2) {\n        if ($lst[0] == $lst[1]) {\n     \
    \       return $lst[0];\n        }\n        if ($lst[1] > $lst[0]) {\n       \
    \     return $lst[1];\n        }\n    }\n    $max_value = 0;\n    $primes = array();\n\
    \    foreach ($lst as $value) {\n        $x = $value;\n        for ($i = 2; $i\
    \ <= sqrt($x); $i++) {\n            $is_prime = true;\n            foreach ($primes\
    \ as $prime) {\n                if ($x % $prime == 0) {\n                    $is_prime\
    \ = false;\n                    break;\n                }\n            }\n   \
    \         if ($is_prime) {\n                $primes[] = $i;\n                if\
    \ ($i == $max_value) {\n                    $max_value = $i;\n               \
    \ }\n            }\n        }\n    }\n    return $max_value;\n}\n</code>\n<|/\
    \ a dscore=3 |>\n<| c |>\nthank you so much for that. I am new to programming\
    \ and I am learning it by myself so I appreciate your help. I am going to try\
    \ to implement this and will comment here if I get stuck anywhere.\n<|/ c |>\n\
    <| c |>\n: I posted a code snippet that works, feel free to ask if anything is\
    \ unclear.\n<|/ c |>\n<| c |>\n: I added a complete code example that works. Feel\
    \ free to ask if anything is unclear.\n<|/ c |>\n<| c |>\nThanks. I have tried\
    \ this and it's working fine for smaller arrays but not for larger ones. I have\
    \ uploaded the problem file here so you can have a look https://drive.google.com/file/d/0By9k6WcSJsOjbHVybWFpc2ltQmM/edit?usp=sharing\
    \ . Thank you.\n<|/ c |>\n<| c |>\n: I'm glad you found my solution useful! It\
    \ was an interesting problem. Your example file contains no such arrays (`array(30,\
    \ 1, 32, 301, 30, 31, 1, 32, 3, 1)`), so I added one with many such values. It\
    \ also contains many duplicates, but I assume these were not intentional. With\
    \ your file I can reproduce your problem, but this might be due to the formatting\
    \ of the file (see my note about that in my answer). I tested this with the exact\
    \ input that you supplied in your question and it worked fine, so I guess your\
    \ input file is not exactly like that", "  $largest = array_reduce($lst, function($a,\
    \ $b) {\n    return $b ? max($a, $b) : $a;\n  }, 0);\n  return array_sum(array_slice(str_split($largest),\
    \ -1));\n}", "    $max = 0;\n    foreach ($lst as $x) {\n        if ($x > $max)\
    \ {\n            $max = $x;\n        }\n    }\n    \n    $sum = 0;\n    for ($i\
    \ = 2; $i <= $max; $i++) {\n        if ((($n % $i) == 0) && $i != $max) {\n  \
    \          $sum += $i;\n        }\n    }\n    return $sum;\n}\n</code>\n<|/ a\
    \ tags=algorithm,php dscore=3 |>\n<| c |>\n`The largest` will work for the first\
    \ input, but not for the second one, the last one\n<|/ c |>\n<| c |>\nI made a\
    \ change which fixes that issue. I thought you were trying to find the largest\
    \ prime number in a given set.\n<|/ c |>\n<| a dscore=1 |>\nI found this question\
    \ interesting so I wrote this algorithm in javascript that works fairly well:\n\
    <code>", "  $max = reset($lst);\n  $sum = 0;\n  foreach ($lst as $num) {\n   \
    \ if ($num > $max) {\n      if ($num % $max == 0) {\n        $sum += $max;\n \
    \     }\n    }\n    $max++;\n  }\n  return $sum;\n}\n</code>\n<|/ a |>\n<| c |>\n\
    this works great but what i need to do is to return the highest value that is\
    \ divisable by 2 if there are 2 then return that number. If there are 2 then return\
    \ that value also but if there are more than 2 then return 2 if it is greater\
    \ than 2 then return that number that is divisable by 2 otherwise return 0 if\
    \ no value is divisable by 2 then return 0\n<|/ c |>\n<| c |>\nThis is really\
    \ the best solution. Easy to understand, and easy to implement for other cases\
    \ as well.\n<|/ c |>\n<| c |>\nThis is the best solution. I tested it on 10^4\
    \ cases. I tested it on 10^5 cases, it took ~2.5 seconds to complete. Tested it\
    \ on 10^6 cases, it took ~2.4 seconds to complete.\n<|/ c |>\n<| a tags=primes,php\
    \ |>\nThe algorithm itself is straightforward (modulo-2 sieve):\nSieve of Eratosthenes\
    \ - O(n log n) complexity.\nSieve of Atkin, O(n log logn) complexity.\nThis would\
    \ give O(n) complexity, not O(n * log n).\n<|/ a dscore=2 |>\n<| c |>\nI really\
    \ like the idea of using the sieve of Atkin. Could you please elaborate on the\
    \ algorithm? How do you go about finding each of the possible primes in O(n)?\
    \ Is it because you start from the beginning and mark off multiples of 2 until\
    \ you find a prime that isn't a multiple of 2, then repeat that until you're done?\
    \ Or am I missing something?\n<|/ c |>\n<| c |>\nI didn't even think of using\
    \ Atkin's Sieve of Eratosthenes :P That should work pretty well, thanks!\n<|/\
    \ c |>\n<| c |>\nThe algorithm is straightforward. http://en.wikipedia.org/wiki/Sieve_of_Atkin\n\
    <|/ c |>\n<| c |>\nIt would be O(n * log log n) for a very large number, I think.\
    \ Even if it isn't, the algorithm is pretty straightforward.\n<|/ c |>\n<| c |>\n\
    O(n) isn't the best you can ", "  $largestPrime = 0;\n  $total = 0;\n\n  for ($i\
    \ = 0; $i < count($lst); $i++) {\n    $prime = false;\n\n    if ($lst[$i] <= 2)\
    \ {\n      continue;\n    }\n\n    for (; $lst[$i] >= 2; $lst[$i] -= 2) {\n  \
    \    if ($lst[$i] <= 1) {\n        continue;\n      }\n\n      $total = $lst[$i]\
    \ + $total;\n      $prime = true;\n\n      break;\n    }\n\n    if ($prime) {\n\
    \      if ($largestPrime < $total) {\n        $largestPrime = $total;\n      }\n\
    \    }\n  }\n\n  return $largestPrime;\n}\n", "    $max = max($lst);\n    $sum\
    \ = 0;\n    foreach ($lst as $num) {\n        if ($num > $max) {\n           \
    \ $sum -= $max;\n        }\n        $sum += $num;\n        if ($sum < 0)\n   \
    \         $sum = 0;\n    }\n    return $sum;\n}\n", "    return max($lst);\n}",
  "    if (count($lst) === 0) {\n        return 0;\n    }\n\n    if (count($lst) ===\
    \ 1) {\n        return $lst[0];\n    }\n\n    $largestPrime = $lst[0]; // start\
    \ with the first number in the list.\n\n    for ($i = 1; $i < count($lst); $i++)\
    \ {\n        $isPrime = true;\n        $isPrimeButNotLargestPrime = true;\n  \
    \      for ($j = 2; $j <= ($largestPrime - 1); $j++) {\n            // If any\
    \ of the numbers in our list are not divisible by the current number then it is\
    \ not prime.\n            if ($lst[$i] % $j === 0) {\n                $isPrime\
    \ = false;\n                break;\n            }\n            // If the current\
    \ number is not divisible by the largest prime yet then it can not be prime\n\
    \            if ($j > $largestPrime) {\n                $isPrimeButNotLargestPrime\
    \ = false;\n                break;\n            }\n        }\n        // If the\
    \ current number is prime and it is larger than the largest prime so far\n   \
    \     if ($isPrime && $isPrimeButNotLargestPrime) {\n            $largestPrime\
    \ = $lst[$i];\n        }\n    }\n\n    return $largestPrime;\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nIt looks good, can you explain me the for loops? I don't understand\
    \ the code\n<|/ c |>\n<| c |>\nIt isn't the best code... Just a quick way to get\
    \ to the answer. I'll let you fix it :)\n<|/ c |>\n<| a tags=math,php,arrays |>\n\
    You can do this using Recursion.\n<code>\n$arr = array(0, 3, 2, 1, 3, 5, 7, 4,\
    \ 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3);\n$result = max($arr);\nprint_r($arr);\n\
    echo $result;\n</code>\nOutput\n<code>\nArray\n(\n    [0] => 0\n    [1] => 3\n\
    \    [2] => 2\n    [3] => 1\n    [4] => 3\n    [5] => 7\n    [6] => 4\n    [7]\
    \ => 4\n    [8] => 4\n    [9] => 5\n    [10] => 2\n    [11] => 8\n    [12] =>\
    \ 1\n    [13] => 2\n    [14] => 1\n    [15] => 3\n    [16] => 4\n    [17] => 2\n\
    \    [18] => 2\n    [19] => 5\n    [20] => 5\n    [21] => 5\n    [22] => 5\n \
    \   [23] => 5\n    [24] => 5\n    [25] => 2\n    [26] => 1\n    [27] => 1\n  \
    \  [28] => ", "    $max = max($lst);\n    $res = 0;\n    $i = 0;\n\n    for ($i;\
    \ $i < $max; $i++) {\n        $res = $max * $i;\n\n        if ($lst == array_filter($lst,\
    \ 'strval')) {\n            break;\n        }\n\n        $max = max($lst);\n \
    \   }\n\n    return $res;\n}\n</code>\n<|/ a |>\n<| c |>\nThanks for the code,\
    \ that does work, but i don't know how to make it work on the entire array, as\
    \ i have never worked with arrays before and i don't know how to make it work\
    \ on the entire array.\n<|/ c |>\n<| c |>\nWhat do you mean by \"work on the entire\
    \ array\"?\n<|/ c |>\n<| c |>\nlike how i can use your code with mine on my original\
    \ array\n<|/ c |>\n<| c |>\nI've added an example for you.\n<|/ c |>\n<| c |>\n\
    Oh wow, that was easy, thanks a lot! So i was trying to use an \"if\" statement\
    \ to make it work, i didn't think it was possible, thanks once again!\n<|/ c |>\n\
    <| a tags=arrays,php dscore=0 |>\nHere's a working solution. Your function needs\
    \ some tweaking to take in an array of integers.\n<code>\n<?php", "    $largestPrime\
    \ = NULL;\n    $sumOfPrimes = 0;\n\n    foreach($lst as $number) {\n        $largestPrime\
    \ = maxPrime($number, $largestPrime);\n\n        $sumOfPrimes += $number;\n  \
    \  }\n\n    if ($largestPrime) {\n        return $sumOfPrimes + $largestPrime;\n\
    \    }\n}\n", "    $max = max($lst);\n    $max_idx = array_search($max, $lst);\n\
    \    if ($max_idx === false) {\n        echo 'Nope';\n    } else {\n        $primes\
    \ = array();\n        $primes[2] = 1;\n        $primes[1] = 1;\n        for ($i\
    \ = 3; $i <= $max; $i += 2) {\n            if (array_key_exists($i, $primes))\
    \ {\n                $primes[$i] = $primes[$i] + 1;\n            } else {\n  \
    \              $primes[$i] = 1;\n            }\n        }\n        $primes[$max_idx]\
    \ = $primes[$max_idx] + 1;\n        $sum = 0;\n        $i = 1;\n        foreach\
    \ ($primes as $prime) {\n            while ($prime) {\n                $sum +=\
    \ $i;\n                $i++;\n                $prime /= $i;\n            }\n \
    \       }\n        return $sum;\n    }\n}\n", "    $max = null;\n    $sum = 0;\n\
    \    $tmp = null;\n    for ($i = 0; $i < count($lst); $i++) {\n        if ($lst[$i]\
    \ >= 0) {\n            if (!isset($max)) {\n                $max = $lst[$i];\n\
    \            } else {\n                if ($lst[$i] > $max) {\n              \
    \      $max = $lst[$i];\n                }\n            }\n        }\n    }\n\
    \    for ($i = count($lst); $i > 0; $i--) {\n        $sum = 0;\n        for ($j\
    \ = 1; $j <= $i; $j++) {\n            if ($lst[$j] != 0) {\n                if\
    \ ($lst[$i] % $lst[$j] == 0) {\n                    break;\n                }\
    \ else {\n                    continue;\n                }\n            } else\
    \ {\n                if ($j > 1) {\n                    $tmp = $lst[$j];\n   \
    \             }\n            }\n            $sum = $sum + $j;\n        }\n   \
    \     if ($tmp != $lst[$i - 1] && $max >= $sum) {\n            break;\n      \
    \  }\n    }\n    return $sum;\n}\n", "    $primes  = array();\n    $primes = array();\n\
    \n    foreach ($lst as $key => $value) {\n        $primes[] = $value;\n    }\n\
    \n    sort($primes);\n    $max = 0;\n    $sum = 0;\n\n    foreach ($primes as\
    \ $prime) {\n        if ($prime > $max) {\n            $max = $prime;\n      \
    \  }\n    }\n\n    foreach ($primes as $key => $prime) {\n        if ($prime ==\
    \ $max) {\n            $sum += $prime;\n        }\n    }\n\n    return $sum;\n\
    }\n</code>\nI haven't been able to figure out how to make the code work without\
    \ the function definition, but it does work. \nI've tried this with many different\
    \ arrays and I still get the same result. \nCould someone please tell me where\
    \ I'm going wrong?\n<|/ q dscore=1 |>\n<| c |>\nCan you elaborate on what exactly\
    \ does not work?\n<|/ c |>\n<| c |>\nI don't see any function declaration. You're\
    \ defining $primes[] = $value and then trying to use $primes outside of the function\
    \ when it's an empty array.\n<|/ c |>\n<| c |>\nThe function should be defined\
    \ before the function call, and as it is written right now, there is an error\
    \ message saying that the function skjkasdkd is not defined. If I add the function\
    \ definition, it will not work.\n<|/ c |>\n<| c |>\nThat is correct. When I run\
    \ your code (only with the function definition) and call skjkasdkd(), it returns\
    \ 3. It appears that there is some extra code that you aren't showing us.\n<|/\
    \ c |>\n<| c |>\nYour problem is that your are overwriting $primes variable in\
    \ each iteration of the loop. So the first element of $primes will be overwritten\
    \ by all the next elements of the loop. You should put $primes = array() in the\
    \ beginning of the function to restore the initial state of the array.\n<|/ c\
    \ |>\n<| a tags=php dscore=1 |>\nThe problem is that you are overwriting $primes[]\
    \ variable in each iteration of the loop. So the first element of $primes will\
    \ be overwritten by all the next elements of the loop. You should put $primes\
    \ = array() in the beginning of the function to restore the initial state of the\
    \ array.\n<|/ a |>\n<| c |>\nI'm still getting an output of 3 even after adding\
    \ that code. I'll add the whole code if that helps.\n<|/ c |>\n<| c |>\n: I remember\
    \ that there are some differences in how you define the function. You have to\
    \ call the function with brackets and not with parentheses. Maybe that is the\
    \ problem in your case.\n<|/ c |>\n<| ", "    $max = max($lst);\n    foreach ($lst\
    \ as $val) {\n        if ($val > $max) {\n            $max = $val;\n        }\n\
    \    }\n\n    $res = 0;\n    foreach ($lst as $val) {\n        if ($val > $max)\
    \ {\n            break;\n        }\n        $res -= $val % $max;\n        $max\
    \ += $max;\n    }\n\n    return $res;\n}\n</code>\n<|/ a tags=php dscore=2 |>\n\
    <| c |>\nGreat answer, but your code isn't optimized for large input arrays. I've\
    \ added an optimized version to my answer.\n<|/ c |>\n<| a dscore=1 |>\n<code>\n\
    <?php\n    function largestPrimeSum($input) {\n        $primes = array();\n  \
    \      foreach ($input as $value) {\n            if (in_array($value, $primes))\
    \ {\n                continue;\n            }\n            $primes[$value]++;\n\
    \        }\n\n        $largestPrime = max(1, count($primes));\n        $sum =\
    \ 0;\n        foreach ($primes as $primeValue) {\n            $sum += $primeValue;\n\
    \            if ($sum > $largestPrime) {\n                $largestPrime = $sum;\n\
    \            }\n        }\n\n        return $largestPrime;\n    }\n</code>\n<|/\
    \ a tags=php |>\n<| a |>\n<code>\n<?php", "    // write code here\n    $max=0;\n\
    \    foreach ($lst as $item){\n        if($item>$max){\n            $max=$item;\n\
    \        }\n    }\n    $max++;\n    $sum=0;\n    foreach($lst as $item){\n   \
    \     if($item>$max){\n            $sum+=$max-$item;\n        }\n    }\n    return\
    \ $sum;\n}\n</code>\n<|/ a |>\n<| c |>\nThank you! Could you just tell me why\
    \ this happens? I really don't understand what is happening here.\n<|/ c |>\n\
    <| c |>\nI have added an explanation. Hope it helps.\n<|/ c |>\n<| c |>\nThank\
    \ you very much! It really helps a lot!\n<|/ c |>\n<| c |>\nI have added an explanation\
    \ too. Hope it helps.\n<|/ c |>\n<| c |>\nYour explanation is really clear and\
    \ well explained, thank you so much!\n<|/ c |>\n<| a dscore=0 |>\nThis should\
    \ work:\n<code>\n$lst = array(\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n\
    \    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n\
    \    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n\
    \    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n\
    \    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n\
    \    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n\
    \    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n\
    \    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n\
    \    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n\
    \    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n", "    $max = max($lst);\n\
    \    foreach ($lst as $k => $v) {\n        if ($v != $max && $v % $max == 0) {\n\
    \            return $v % $max;\n        }\n    }\n    return $max;\n}\n", "  \
    \  $largestPrime = 0;\n    $maxDigit = 0;\n    $foundPrime = false;\n    $primes\
    \ = array(3, 7, 11, 17, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79,\
    \ 83, 89, 97);\n    foreach ($lst as $n) {\n        if ($foundPrime) {\n     \
    \       // if already found a prime, continue to next element\n            continue;\n\
    \        }\n        // check if n is a prime\n        for ($i = 2; $i <= sqrt($n);\
    \ $i++) {\n            if ($n % $i == 0) {\n                // n is a square,\
    \ not a prime\n                $foundPrime = false;\n                break;\n\
    \            }\n        }\n        if (!$foundPrime) {\n            $foundPrime\
    \ = true;\n            $largestPrime = $n;\n        }\n        $maxDigit = max($maxDigit,\
    \ count(str_split($n, 1)));\n    }\n    return $largestPrime + array_sum(array_slice(str_split($largestPrime),\
    \ 0, $maxDigit));\n}\n</code>\n<|/ a |>\n<| a |>\nI made a simpler solution in\
    \ ruby.\n<code>\ndef largest_prime_digits(n)\n  max_value = 0\n  n.times { |i|\
    \ max_value = max_value.succ, i += 2 if n % i == 0 }\n  max_value.to_s.chars.reverse.join.to_i\n\
    end\n</code>\n<|/ a dscore=1 tags=php,math,algorithm |>\n<| c |>\nPlease add some\
    \ explanation with answer for how this answer help OP in fixing current issue\n\
    <|/ c |>\n<| a dscore=1 tags=php,math,algorithm |>\nThis algorithm is simplest\
    \ one and it is the fastest one. \n<code>", "    return skjkasdkd($lst, 0, 0);\n\
    }\n", "    $sum = 0; // Initialize sum\n\n    // Step 1: Find highest prime number\n\
    \    $max_prime = 0; // Initialize max prime number\n    foreach ($lst as $num)\
    \ {\n        if ($num > $max_prime)\n            $max_prime = $num;\n    }\n\n\
    \    // Step 2: Find all possible divisors\n    $divisors = $max_prime + 1; //\
    \ Initialize divisors\n    for ($i = 1; $i <= $divisors; $i++) {\n        $divisors_size\
    \ = count($lst) - $divisors;\n        $div_arr = array_slice($lst, $divisors_size);\n\
    \        $divisors_size = count($div_arr);\n        $is_prime = 1;\n        foreach\
    \ ($div_arr as $num) {\n            if ($num % $i == 0)\n                $is_prime\
    \ = 0;\n        }\n\n        if ($is_prime == 1) {\n            $sum += $divisors_size\
    \ * $i;\n            $divisors++;\n        }\n    }\n\n    return $sum;\n}\n",
  "  usort($lst, 'sort_natural_by_key');\n\n  $largest = array_shift($lst);\n\n  foreach\
    \ ($lst as $k => $v) {\n    foreach ($lst as $k2 => $v2) {\n      $sum = $largest;\n\
    \      $sum += $v;\n      $sum += $v2;\n      if ($sum < $largest) {\n       \
    \ $largest = $sum;\n      }\n    }\n  }\n  return $largest;\n}\n", "    $primes\
    \ = array_filter(\n        range(1, ceil(sqrt(count($lst)))+1),\n        function\
    \ ($x) {\n            return isPrime($x);\n        }\n    );\n\n    return max(array_sum(array_slice($primes,\
    \ 0, -1)), array_sum(array_slice($primes, -1)));\n}\n</code>\n<|/ a dscore=3 |>\n\
    <| c |>\nThe first line is missing a closing bracket (for array_filter function)\
    \ after $lst. Fixed and works as intended. Thanks !\n<|/ c |>\n<| c |>\nThis is\
    \ not working for all test cases. https://stackoverflow.com/a/50416390/10951716\n\
    <|/ c |>\n<| a tags=php,primes,arrays,algorithm |>\nThe prime number theorem proves\
    \ that\na number is a multiple of it's highest factor if it's prime,\nor, if it's\
    \ composite, the number is greater than it's largest\nfactor.  So the obvious\
    \ answer is that you need to loop through your numbers and find the maximum number\
    \ that is a multiple of it's highest factor.\n<|/ a dscore=2 |>\n<| c |>\nHow\
    \ would you find the greatest factor? It doesn't seem to be as simple as dividing\
    \ by prime numbers.\n<|/ c |>\n<| c |>\nI guess you'd find the largest prime factor,\
    \ then divide out all but the factor. You'd have to keep searching until you got\
    \ down to a single factor.\n<|/ c |>\n<| a dscore=2 tags=php,primes,arrays,algorithm\
    \ |>\nThe prime number theorem states that a number is a multiple of\nit's highest\
    \ factor if it's prime, or, if it's composite, the number is\ngreater than it's\
    \ largest factor.\n\nYou can find the greatest factor by finding prime factors,\
    \ then dividing out all other factors and multiplying the result by it. You can\
    \ use the following code to do so:\n<code>\n<?php\n", "    $largestPrime = 0;\n\
    \    foreach ($lst as $num) {\n        $sum = 0;\n        for ($i = $num; $i >\
    \ 1; $i--) {\n            if (is_prime($i)) {\n                $sum = $sum + $i;\n\
    \                if ($sum > $largestPrime) {\n                    $largestPrime\
    \ = $sum;\n                }\n            }\n        }\n    }\n    return $largestPrime;\n\
    }", "    sort($lst);\n    $primes_found = array();\n    $primes_found[$lst[0]]\
    \ = 1;\n    $primes_found[$lst[1]] = 1;\n    $primes_found[$lst[2]] = 1;\n   \
    \ $primes_found[$lst[3]] = 1;\n    $primes_found[$lst[4]] = 1;\n    $primes_found[$lst[5]]\
    \ = 1;\n    $primes_found[$lst[6]] = 1;\n    $primes_found[$lst[7]] = 1;\n   \
    \ $primes_found[$lst[8]] = 1;\n    $primes_found[$lst[9]] = 1;\n    $primes_found[$lst[10]]\
    \ = 1;\n    $primes_found[$lst[11]] = 1;\n    $primes_found[$lst[12]] = 1;\n \
    \   $primes_found[$lst[13]] = 1;\n    $primes_found[$lst[14]] = 1;\n    $primes_found[$lst[15]]\
    \ = 1;\n    $primes_found[$lst[16]] = 1;\n    $primes_found[$lst[17]] = 1;\n \
    \   $primes_found[$lst[18]] = 1;\n    $primes_found[$lst[19]] = 1;\n    $primes_found[$lst[20]]\
    \ = 1;\n    $primes_found[$lst[21]] = 1;\n    $primes_found[$lst[22]] = 1;\n \
    \   $primes_found[$lst[23]] = 1;\n    $primes_found[$lst[24]] = 1;\n    $primes_found[$lst[25]]\
    \ = 1;\n    $primes_found[$lst[26]] = 1;\n    $primes_found[$lst[27]] = 1;\n \
    \   $primes_found[$lst[28]] = 1;\n    $primes_found[$lst[29]] = 1;\n    $primes_found[$lst[30]]\
    \ = 1;\n    $primes_found[$lst[31]] = 1;\n    $primes_found[$lst[32]] = 1;\n \
    \   $primes_found[$lst[33]] = 1;\n    $primes_found[$lst[34]] = 1;\n    $primes_found[$lst[35]]\
    \ = 1;\n    $primes_found[$lst[36]] = 1;\n    $primes_found[$lst[37]] = 1;\n \
    \   $primes_found[$lst[38]] = 1;\n    $primes_found[$lst[39]] = 1;\n    $primes_found[$lst[40]]\
    \ = 1;\n    $primes_found[$lst[41]] = 1;\n    $primes_found[$lst[42]] = 1;\n \
    \   $primes_found[$lst[43]] = 1;\n    $primes_found[$lst[44]] = 1;\n    $primes_found[$lst[45]]\
    \ = 1;\n    $prime", "    $prime = array(2, 3);\n    for ($i = 2; $i < count($lst);\
    \ $i++) {\n        foreach ($prime as $p) {\n            if ($lst[$i] % $p ===\
    \ 0) {\n                break;\n            }\n            if ($p == $prime[count($prime)\
    \ - 1]) {\n                $prime[] = $lst[$i];\n            }\n        }\n  \
    \  }\n    return max($prime);\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis answer\
    \ is wrong. `array(0, 1, 8)` has two factors `2` and `8` which makes it *not*\
    \ a prime number. It should say \"7\".\n<|/ c |>\n<| c |>\nThe question says *\"\
    Return the sum of the digits, excluding the first digit\"*. So, why does `array(0,\
    \ 1, 8)` have two factors `2` and `8`? And why would `array(0, 7, 2, 1, 7)` have\
    \ three factors `0`, `7` and `1`? Your algorithm is wrong.\n<|/ c |>\n<| c |>\n\
    Sorry, I misread the question. I thought it was \"Return the largest prime factor\
    \ of the integers in the input array\" and that `array(0, 7, 2, 1, 7)` would be\
    \ `7`.\n<|/ c |>\n<| c |>\nYour algorithm is wrong for `array(0, 1, 8)`. It should\
    \ be `7` not `8`.\n<|/ c |>\n<| c |>\n`array(0, 1, 8)` has 2 factors: 2 and 8,\
    \ so it is not a prime number.\n<|/ c |>\n<| a dscore=1 |>\nOkay, so I made a\
    \ few changes to your original code. First, I changed it so that it only checks\
    \ the odd numbers in your array. That way, you can get around a problem with factors\
    \ of 2 in the first place.\nSecond, I made it so that it only checks the factors\
    \ of prime numbers, and then uses the largest. This way, you know that if a number\
    \ is a prime number, it will never have any factors smaller than it.\nThird, I\
    \ changed it so that it sums the digits after the largest factor. That's because\
    \ the problem specifies that the first digit is the largest. So a number like\
    \ 10 won't be the largest factor.\nFourth, I added a check to make sure that the\
    \ largest prime factor wasn't 2. If so, it returns the number itself as an answer.\n\
    Here's the code:\n<code>", "    // Your code here\n    $largest = PHP_INT_MIN;\n\
    \    foreach ($lst as $number) {\n        if ($largest<$number) {\n          \
    \  $largest = $number;\n        }\n    }\n\n    return array_sum(str_split($largest));\n\
    }", "  $arr = [];\n  $max = 0;\n\n  foreach ($lst as $num) {\n    if ($num > $max)\
    \ {\n      $max = $num;\n    }\n  }\n\n  for ($i = 0; $i < $max; $i++) {\n   \
    \ $sum = 0;\n\n    for ($j = 0; $j < $max; $j++) {\n      if ($i !== $j && $lst[$i]\
    \ % $lst[$j] === 0) {\n        $sum += $lst[$j];\n      }\n    }\n\n    $arr[]\
    \ = $sum;\n  }\n\n  return $arr;\n}\n</code>\n<|/ a tags=math,php,arrays dscore=3\
    \ |>\n<| a tags=math,php,arrays |>\n<code>", "  $n = count($lst);\n  $sum = 0;\n\
    \  for ($i = 0; $i < $n; $i++) {\n    $arr = $lst[$i];\n    $p = sk_largestPrime($arr);\n\
    \    foreach ($arr as $v) {\n      if ($v % $p) {\n        $sum += $v % $p;\n\
    \      }\n    }\n  }\n  return $sum;\n}\n", "    $primes = array();\n    $max\
    \ = 0;\n    $digits = array();\n\n    foreach ($lst as $num) {\n        // If\
    \ num is prime, add to primes array\n        if (!isPrime($num)) {\n         \
    \   array_push($primes, $num);\n        }\n    }\n\n    // Sort primes from smallest\
    \ to largest\n    usort($primes, array(\"skjkasdkd\", \"cmp\"));\n\n    $max =\
    \ max($primes);\n\n    // Find sum of each prime\n    foreach ($primes as $num\
    \ => $prime) {\n        // Get digits\n        $digits[$prime] = str_repeat($num,\
    \ $prime);\n\n        // Find sum\n        $sum = array_sum($digits);\n\n    \
    \    // If max is greater, then sum is the new max\n        if ($sum > $max) {\n\
    \            $max = $sum;\n        }\n    }\n\n    return $max;\n}\n", "    //\
    \ Your code here\n    $max = 0;\n    foreach ($lst as $item) {\n        for ($i\
    \ = 2; $i <= $item; $i++) {\n            if ($item % $i == 0) {\n            \
    \    break;\n            }\n        }\n        if ($i == $item) {\n          \
    \  $max = $item + $max;\n        }\n    }\n    return $max;\n}\n", "    $max =\
    \ -9999;\n    $sum = 0;\n    foreach ($lst as $num) {\n        if ($num > 0 &&\
    \ $num % 2 == 0) {\n            do {\n                $num++;\n            } while\
    \ ($num % 2 == 0);\n        }\n        $sum += $num % 10;\n        if ($max <\
    \ $sum) {\n            $max = $sum;\n        }\n        $sum = 0;\n    }\n   \
    \ return $max;\n}\n</code>\n<|/ a dscore=2 tags=php,arrays,algorithm |>\n<| c\
    \ |>\nThank you! I was able to rearrange your code to fit my needs! Awesome\n\
    <|/ c |>\n<| c |>\nGlad it helped you! I was thinking of optimizing the code a\
    \ little bit, but glad this one helped you in any case!\n<|/ c |>\n<| c |>\nPlease\
    \ add your improved code here for future visitors of this question.\n<|/ c |>\n\
    <| a dscore=2 |>\n<code>", "    $max = 0;\n    $prime = 0;\n    $sum = 0;\n\n\
    \    foreach ($lst as $element) {\n        foreach ($lst as $value2) {\n     \
    \       if ($element > $value2) {\n                break;\n            }\n   \
    \         if ($element > $max) {\n                $max = $element;\n         \
    \       $prime = $value2;\n                $sum = 0;\n            }\n        }\n\
    \    }\n\n    if ($prime == 0) {\n        return $sum;\n    }\n\n    foreach ($lst\
    \ as $key => $value) {\n        for ($i = 2; $i <= $max; $i++) {\n           \
    \ if ($i % $value == 0) {\n                $prime = 0;\n                break;\n\
    \            }\n        }\n        $sum += $prime * $key;\n    }\n\n    return\
    \ $sum;\n}\n</code>\n<|/ a |>\n<| c |>\nThanks for your solution but it is too\
    \ slow.\n<|/ c |>\n<| c |>\nOh, sorry, I didn't see the time constraints. Could\
    \ you provide an example of the data set that makes it too slow? It may be worth\
    \ your time writing a quicksort or other such algorithm yourself.\n<|/ c |>\n\
    <| c |>\nThis algorithm is definitely not efficient enough - it runs in O(n^2)\
    \ for each element in the array.\n<|/ c |>\n<| c |>\nI added an example of one\
    \ of the datasets I tested.\n<|/ c |>\n<| c |>\n: I tested your function with\
    \ arrays (with 100000 elements) and it takes about 2 seconds for one call.\n<|/\
    \ c |>\n<| a dscore=1 |>\nI did a quick test in PHP 5.2.6 that might have something\
    \ to do with the problem with the large numbers.  I used the code below and it\
    \ timed out after 2 minutes.  I used a similar method and timed out after 2 seconds.\n\
    <code>\n<?php\n", "    $max = max($lst);\n    $iMax = array_search($max, $lst);\n\
    \    if ($iMax === FALSE)\n        return FALSE;\n\n    $sum = 0;\n    for ($i\
    \ = 0; $i < $iMax; $i++)\n        $sum += $lst[$i];\n\n    return $sum;\n}\n\n\
    var_dump(skjkasdkd($arr));\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis fails when\
    \ the array is all 0's. You can either use an `else` statement or return `0` when\
    \ the array is all 0's.\n<|/ c |>\n<| c |>\nIf all values are 0 then `array_sum()`\
    \ will return `0`. I have tested and it returns `0` as well.\n<|/ c |>\n<| c |>\n\
    Well spotted. I've added a test case that has all 0's and another with ones that\
    \ don't work. I've also added an alternate solution that uses a loop to check\
    \ all values before summing them up to avoid `array_sum()` returning `0`.\n<|/\
    \ c |>\n<| c |>\nYes, all values are 0 and `array_sum()` still returns 0\n<|/\
    \ c |>\n<| c |>\nSorry, but I can't seem to find an issue with your solution.\
    \ Please see my answer.\n<|/ c |>\n<| a |>\n<code>\n<?php\n$arr = [\n    0 =>\
    \ 0,\n    1 => 1,\n    2 => 2,\n    3 => 3,\n    4 => 4,\n    5 => 5,\n    6 =>\
    \ 6,\n    7 => 7,\n    8 => 8,\n    9 => 9,\n    10 => 10,\n    11 => 11,\n  \
    \  12 => 12,\n    13 => 13,\n    14 => 14,\n    15 => 15,\n    16 => 16,\n   \
    \ 17 => 17,\n    18 => 18,\n    19 => 19,\n    20 => 20,\n    21 => 21,\n    22\
    \ => 22,\n    23 => 23,\n    24 => 24,\n    25 => 25,\n    26 => 26,\n    27 =>\
    \ 27,\n    28 => 28,\n    29 => 29,\n    30 => 30,\n    31 => 31,\n    32 => 32,\n\
    \    33 => 33,\n    34 => 34,\n    35 => 35,\n    36 => 36,\n    37 => 37,\n \
    \   38 => 38,\n    39 => 39,\n    40 => 40,\n    41 => 41,\n    42 => 42,\n  \
    \  43 => 43,\n    44 => 44,\n", "    if (!is_array($lst)) {\n        return false;\n\
    \    }\n    $largestPrimeIndex = 0;\n    $largestPrimeValue = 0;\n    $largestPrimeLength\
    \ = 0;\n    for ($i = 0; $i < count($lst); $i++) {\n        if ($lst[$i] > $largestPrimeValue)\
    \ {\n            if ($largestPrimeValue > $largestPrimeLength) {\n           \
    \     $largestPrimeLength = $largestPrimeValue;\n                $largestPrimeIndex\
    \ = $i;\n            }\n            $largestPrimeValue = $lst[$i];\n        }\n\
    \    }\n    return $lst[$largestPrimeIndex] + $largestPrimeLength;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThis won't give the result that the OP is looking\
    \ for. The problem is the array does not contain any prime numbers, it's an increasingly\
    \ increasing sequence of non-primes. Your answer will give the largest prime value,\
    \ which is `21` but isn't the sum of its digits.\n<|/ c |>\n<| c |>\nThe question\
    \ title says \"largest\", which means only the largest prime, which is 21 here.\
    \ The code I posted will output the sum of each digit in the largest, which is\
    \ 10 for your example (which was the answer you linked to in the question).\n\
    <|/ c |>\n<| c |>\nThe question title says \"largest\" in the title, but in the\
    \ question itself it says \"largest\" and \"sum\", which are two completely different\
    \ things.\n<|/ c |>\n<| c |>\nWhat do you mean by \"the sum of its digits\"? Do\
    \ you mean \"the sum of its digits and sum of its factors\"?\n<|/ c |>\n<| c |>\n\
    Yes, I do mean that.\n<|/ c |>\n<| a tags=php,arrays |>\nHere's my solution. It\
    \ doesn't use any built in PHP functions, it simply loops through all numbers\
    \ looking for the largest.\n<code>\n<?php", "    // The prime is stored as $i.\
    \  Primes start at 2 but are never divisible by 2 or 3.\n    // $i is set to one\
    \ and checked for divisibility by 2, 3, and 5 each time around the loop.\n   \
    \ // If a number is not divisible by 2, 3, or 5, $i is incremented by 1.\n   \
    \ // The largest prime reached is stored in $i.\n    $i = 2;\n    \n    // Loop\
    \ through each of the numbers until a non-prime is encountered.\n    foreach($lst\
    \ as $value) {\n        // If the current value is divisible by 2, 3, and 5, set\
    \ the new value to be divisible by those numbers by setting $i to $i x i.\n  \
    \      if($value % 3 == 0 && $value % 5 == 0) {\n            $i = $i . ' x ' .\
    \ $i;\n        }\n        // If a non-prime is encountered, exit the loop.\n \
    \       if($value == 1) break;\n    }\n\n    // Return the largest prime in the\
    \ array.\n    return $i;\n}\n", "    // your code here\n    foreach ($lst as $v)\
    \ {\n        if ($v < 2) {\n            continue;\n        }\n        $primes\
    \ = array();\n        $p = 2;\n        while ($p * $p <= $v) {\n            if\
    \ ($v % $p == 0) {\n                $primes[] = $p;\n            }\n         \
    \   $p++;\n        }\n        if (count($primes) == 0) {\n            continue;\n\
    \        }\n        $max = $primes[0];\n        foreach ($primes as $n) {\n  \
    \          if ($max < $n) {\n                $max = $n;\n            }\n     \
    \   }\n        sort($primes);\n        $sum = 0;\n        foreach ($primes as\
    \ $p) {\n            $sum += $p;\n        }\n        return $sum;\n    }\n}\n",
  "    $sum = 0;\n    $max = max($lst);\n    $min = min($lst);\n    foreach ($lst\
    \ as $i) {\n        $temp = max($max, $min, $i);\n        if ($temp % 2 == 0)\
    \ {\n            $sum += $i;\n        }\n    }\n    return $sum;\n}\n</code>\n\
    <|/ a tags=php |>\n<| a |>\n<code>\n<?php", "    $max = $lst[0];\n    $sum = 0;\n\
    \    foreach ($lst as $val) {\n        $is_prime = true;\n        for ($i = 2;\
    \ $i <= sqrt($val); $i++) {\n            if ($val % $i == 0) {\n             \
    \   $is_prime = false;\n                break;\n            }\n        }\n   \
    \     if ($is_prime) {\n            $sum += $val;\n        }\n        if ($val\
    \ > $max) {\n            $max = $val;\n        }\n    }\n    return $sum;\n}\n\
    </code>\n<|/ a |>\n<| c |>\nThis doesn't do what the OP asked for. It outputs\
    \ 10 when it should be 7.\n<|/ c |>\n<| a tags=php |>\n<code>", "    $primes =\
    \ array();\n    $primes[2] = 1;\n    for ($i = 3; $i < count($lst); $i+=2) {\n\
    \        // if the number is greater than the largest prime we've found so far\n\
    \        if ($lst[$i] > max($primes)) {\n            break;\n        }\n     \
    \   // if we've already found a prime greater than the current one\n        //\
    \ we've just found a new one.\n        if (in_array($lst[$i], $primes)) {\n  \
    \          $primes[] = $lst[$i];\n            continue;\n        }\n        //\
    \ we've found a prime larger than the current one we've found.\n        // let's\
    \ find a new one.\n        foreach ($primes as $prime) {\n            if ($prime\
    \ * $prime > $lst[$i]) {\n                array_push($primes, $prime);\n     \
    \           break;\n            }\n        }\n    }\n\n    // find the sum of\
    \ all digits in the primes array\n    $sum = 0;\n    foreach ($primes as $prime)\
    \ {\n        $sum += array_sum(str_split($prime));\n    }\n\n    return $sum;\n\
    }\n</code>\nHere's a test:\n<code>", "  $primes = array();\n  $sum = 0;\n  $max\
    \ = max($lst);\n  for ($i = 2; $i <= $max; $i++) {\n    if (in_array($i, $primes))\
    \ {\n      continue;\n    }\n    $sum = 0;\n    for ($j = 2; $j <= $i; $j++) {\n\
    \      if ($i % $j == 0) {\n        $sum++;\n        break;\n      }\n    }\n\
    \    if ($sum > 0) {\n      $primes[] = $i;\n    }\n  }\n  foreach ($primes as\
    \ $p) {\n    $sum += array_sum(array_slice($lst, $p - 1, 1));\n  }\n  return $sum;\n\
    }\n", "    $max = max($lst);\n    foreach($lst as $value){\n        if($value\
    \ == $max){\n            $sum = 0;\n            for($i = 1;$i<$value;$i++){\n\
    \                if($value % $i == 0){\n                    $sum++;\n        \
    \        }\n            }\n            return $sum;\n        }\n    }\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=php |>\nI took your code and tried to make it work\
    \ with my sample data. I couldn't find any problem with your code but I believe\
    \ you had to pass array into skjkasdkd() function, like that: skjkasdkd(array(1,2,3,4,5,6,7,8,9,10,11,12))\
    \ and there was some mistakes in your code where you used $value instead of $value.\n\
    <code>\n<?php", "    $primes = array();\n    foreach($lst as $num) {\n       \
    \ if(!in_array($num, $primes)) {\n            array_push($primes, $num);\n   \
    \         while(count($primes) > 2) {\n                $primes = array_pop($primes);\n\
    \            }\n        }\n    }\n    $largest = array_pop($primes);\n    $sum\
    \ = 0;\n    foreach($primes as $prime) {\n        $sum += $prime % $largest;\n\
    \    }\n    return $sum;\n}", "    $max = 1;\n    $max_prime = NULL;\n    $max_sum\
    \ = 0;\n    foreach ($lst as $value) {\n        if ($value > $max) {\n       \
    \     $max = $value;\n        }\n        if (!is_null($max_prime) && $value >\
    \ $max_prime) {\n            $max_prime = NULL;\n        }\n        $sum = 0;\n\
    \        for ($i = 1; $i < $max; $i++) {\n            if ($i % $value == 0) {\n\
    \                $sum++;\n            }\n        }\n        if ($sum > $max_sum)\
    \ {\n            $max_sum = $sum;\n            $max_prime = $value;\n        }\n\
    \    }\n    if (is_null($max_prime)) {\n        return $max_sum;\n    } else {\n\
    \        return $max_prime + $max_sum;\n    }\n}\n</code>\n<|/ a tags=php,algorithm\
    \ dscore=1 |>\n<| a tags=php,algorithm |>\n<code>", "    sort($lst);\n    $max_key\
    \ = $lst[0];\n    $sum = 0;\n    foreach ($lst as $key => $value) {\n        if\
    \ ($key != $max_key) {\n            $max_key = $key;\n            $sum = 0;\n\
    \        }\n        $sum = $sum + $value;\n    }\n    if ($sum != 0) {\n     \
    \   return $sum;\n    } else {\n        return 0;\n    }\n}\n</code>\n<|/ a dscore=3\
    \ |>\n<| c |>\nThanks, this was my original solution but I wanted to try to make\
    \ it as efficient as possible. Thanks for the effort though!\n<|/ c |>\n<| c |>\n\
    I added another algorithm which should be faster. Let me know how it goes!\n<|/\
    \ c |>\n<| c |>\nThis algorithm is very nice and easy to understand. Your second\
    \ algorithm is what my solution looked like first so I will try to implement this\
    \ and see how it goes. Thank you so much for the help and I learned something\
    \ new too!\n<|/ c |>\n<| c |>\nI tried your second algorithm and it does work\
    \ so I will go with that for now. Thank you so much for the help! I am still trying\
    \ to wrap my head around your solution but I really appreciate it!\n<|/ c |>\n\
    <| c |>\nNo problem! Let me know if you have trouble understanding my second algorithm!\n\
    <|/ c |>\n<| a tags=algorithm,php dscore=2 |>\n<code>", "    \n    // Initialize\
    \ the sum\n    $sum = 0;\n    \n    // Initialize first value as smallest prime\n\
    \    $first = $lst[0];\n    \n    // Loop through the array\n    foreach ($lst\
    \ as $key => $value) {\n        \n        // Check if value is prime\n       \
    \ if (is_prime($value)) {\n            \n            // If not prime add to sum\n\
    \            $sum += $value;\n            \n            // If prime, remove from\
    \ array and set new first value\n            if ($first) {\n                \n\
    \                // Remove from array\n                unset($lst[$key]);\n  \
    \              \n                // Set new first value\n                $first\
    \ = false;\n            }\n        }\n    }\n    \n    // Return the sum of numbers\n\
    \    return $sum;\n}\n", "  $largest = array();\n  $largestIndex = 0;\n  $sum\
    \ = 0;\n  for ($i = 0; $i < count($lst); $i++) {\n    $number = $lst[$i];\n  \
    \  // if the number is divisible by an even number smaller than the largest,\n\
    \    // then it is not prime\n    if ($number % 2 === 0 && ($largestIndex % 2\
    \ !== 0 || $number < $largest[count($largest) - 1])) {\n      // if the number\
    \ is bigger than the largest so far, then it is prime\n      if ($number > $largest[count($largest)\
    \ - 1]) {\n        $largest[] = $number;\n        $largestIndex++;\n      }\n\
    \      $sum += $number % 10;\n    }\n  }\n  return $sum;\n}\n", "    $largest\
    \ = 1;\n    foreach($lst as $int) {\n        if(!is_int($int)) $int = abs($int);\n\
    \        if($int < $largest) continue;\n        $result = array_sum(str_split($int));\n\
    \        if($result > $largest) {\n            $largest = $result;\n        }\n\
    \    }\n    return $largest;\n}\n", "  $largest = max($lst);\n  $sum = 0;\n  for\
    \ ($i = 0; $i < count($lst); $i++) {\n    if ($lst[$i] == $largest) {\n      $sum\
    \ += $i;\n    }\n  }\n\n  return $sum;\n}\n</code>\n<|/ a |>\n<| c |>\nYeah, your\
    \ implementation is probably faster. Though it might not be the most optimal one,\
    \ because of the repeated `array_filter` calls, but I don't think this is worth\
    \ optimizing.\n<|/ c |>\n<| c |>\nThat's true, I didn't think about that before.\
    \ I've edited my answer.\n<|/ c |>\n<| c |>\nThanks Erik! I appreciate it.\n<|/\
    \ c |>\n<| c |>\nI haven't been able to get this to work correctly. I'm getting\
    \ the wrong value when I pass it array(0, 7, 1, 7, 8, 1, 7, 1, 7, 2, 7, 1, 2,\
    \ 7, 1, 7, 1, 7, 8). I should get 7. I'm also getting an unexpected T_FUNCTION\
    \ error on the line '$maxPrime = array_filter($primes, function($p) { return $p\
    \ > $largest; });' on line 17. Thanks for your help.\n<|/ c |>\n<| c |>\nI've\
    \ just fixed the error and also added the test cases.\n<|/ c |>\n<| a |>\nThis\
    \ would do it (I didn't test it on every possible input though, because it would\
    \ take a long time):\n<code>\n$numbers = array(\n  array(2, 1, 2, 7, 7, 7, 2,\
    \ 8, 1, 4, 2, 8, 8, 8, 2, 5, 8, 1, 3, 8, 8, 7, 3, 2),\n  array(2, 3, 7, 7, 7,\
    \ 3, 8, 2, 5, 7, 7, 7, 8, 1, 2, 7, 7, 2, 7, 1, 7, 8, 1, 2),\n  array(3, 7, 7,\
    \ 7, 7, 3, 7, 2, 5, 7, 7, 7, 7, 8, 1, 2, 7, 7, 2, 7, 1, 7, 8, 1, 2),\n  array(3,\
    \ 7, 7, 7, 7, 3, 7, 2, 5, 7, 7, 7, 7, 8, 1, 2, 7, 7, 2, 7, 1, 7, 8, 1, 2),\n \
    \ array(3, 7, 7, 7, 7, 3, 7, 2, 5, 7, 7, 7, 7, 8, 1, 2, 7, 7, 2, 7, 1, 7, 8, 1,\
    \ 2),\n  array(3, 7, 7, 7, 7, 3, 7, 2, 5, 7, 7, 7, 7, 8, 1, 2, 7, 7, 2, 7, 1,\
    \ 7, 8, 1, 2),\n  array(3, 7, 7, 7, 7, 3, 7, 2, 5, 7, 7, 7, 7, 8, 1, 2, 7, 7,\
    \ 2, 7, 1, 7, 8, 1, 2),\n  array(3, 7, 7, 7, 7, 3, 7, 2, 5, 7, 7, 7, 7, 8, 1,\
    \ 2, 7, 7, 2, 7, 1, 7, 8, 1, 2),\n  array(", "    $max = 0;\n    $sum = 0;\n \
    \   foreach ($lst as $num) {\n        if (is_integer($num)) {\n            $sum\
    \ += $num;\n            if ($sum > $max) {\n                $max = $sum;\n   \
    \         }\n            $sum = 0;\n        }\n    }\n    return $max;\n}\n</code>\n\
    <|/ a tags=algorithm,php,math |>\n<| a dscore=2 |>\nI think this is a good question\
    \ because it is somehow related to Sieve of Atkin. \nThe best and fastest way\
    \ I found was this (using PHP)\n<code>\n<?php\n$max = 0;\n$sum = 0;\n$prime =\
    \ array(3);\nfor ($i = 5; $i <= sqrt(30); $i+=6) {\n  for ($j = 0; $j < count($prime);\
    \ $j++) {\n    if ($prime[$j] == $i) {\n      break;\n    }\n  }\n  if (!$j) {\
    \ // no break => $j is undefined\n    $sum+=1;\n    $prime[] = $i;\n    if ($sum\
    \ > $max) {\n      $max = $sum;\n    }\n  }\n}\necho $max;", "    $max = 2; //\
    \ Start at 2 as 0 is neither prime nor composite.\n    $ans = $lst[0]; // Start\
    \ with the first value.\n    foreach ($lst as $num) {\n        // Check if $num\
    \ is prime by dividing by all the numbers smaller than $num.\n        if ($num\
    \ > $max) {\n            $ans = 0;\n            break;\n        }\n        if\
    \ (checkPrime($num)) {\n            // We are now sure that the number $num is\
    \ prime, since we know $max < $num.\n            $ans = $ans + $num;\n       \
    \ }\n        $max = $num; // $max is the new max value for $num, so we can go\
    \ through the loop again.\n    }\n    return $ans;\n}\n</code>\n<|/ a dscore=0\
    \ tags=math,php |>\n<| c |>\nThank you for your answer, but I do not think it\
    \ will work for the first test case `array(0 ,3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2,\
    \ 181, 32, 4, 32, 3, 2, 32, 324, 4, 3)`. Here the sum is `1 + 181 + 32 + 32 +\
    \ 32 + 3 + 3 + 1 + 5 + 5 + 5 + 5 + 2 + 5 + 5 + 5 + 1` which is `181` but your\
    \ script returns `3`.\n<|/ c |>\n<| c |>\nYeah I missed that one. My bad.\n<|/\
    \ c |>\n<| a dscore=0 tags=math,php |>\nI think the easiest would be to test every\
    \ number from 2 to sqrt(n), then loop through every number from 0 to sqrt(n),\
    \ and if the number is not prime add it to the sum. If it is, remove the number\
    \ from the sum. In the end, you will have the sum of all the numbers in the range\
    \ sqrt(n) which is not divisible by any prime number. \nYou can do that with this\
    \ code:\n<code>", "    $max = 0;\n    foreach ($lst as $item) {\n        $sum\
    \ = 0;\n        $sumOfDigits = 0;\n        while ($item > 0) {\n            $sum\
    \ += $item % 10;\n            $sumOfDigits += $item % 10;\n            $item =\
    \ ($item - $sumOfDigits % 10) / 10;\n        }\n        $max = max($max, $sum);\n\
    \    }\n    return $max;\n}\n</code>\nAnd now let's see what it does in PHP:\n\
    <code>\n$l1 = [0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324,\
    \ 4, 3];\nvar_dump(skjkasdkd($l1));", "  $max = 0;\n  foreach ($lst as $num) {\n\
    \    if ($num > 0) {\n      $num2 = $num;\n      while ($num2 > 0) {\n       \
    \ $num2 = $num2 % 10;\n        if ($num2 < $max) {\n          $max = $num2;\n\
    \        }\n        $num2 = floor($num2 / 10);\n      }\n    }\n  }\n\n  $sum\
    \ = 0;\n  foreach ($lst as $num) {\n    $sum += $num;\n    if ($sum > $max) {\n\
    \      return $sum;\n    }\n  }\n\n  return $max;\n}", "    $max = max($lst);\n\
    \    $sum_of_digits = 0;\n    foreach ($lst as $value) {\n        $sum_of_digits\
    \ += $value;\n    }\n    return $sum_of_digits % $max;\n}\n", "    $primes = array();\n\
    \    $prime_count = 0;\n    $prime_sum = 0;\n    foreach ($lst as $number) {\n\
    \        if ($number == 0) {\n            if ($prime_count > 1) {\n          \
    \      $prime_sum += $primes[$prime_count-1];\n                $primes[$prime_count-1]\
    \ = 0;\n            }\n            $prime_count = 0;\n        }\n        $primes[$prime_count]\
    \ += $number;\n        $prime_count++;\n    }\n    return $prime_sum;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=math,arrays,php |>\nTry this code, it may help you.\n\
    <code>\n<?php\n$array = [1, 2, 3, 4, 5];\n\n$largestPrime = 0;\n$primesFound =\
    \ 0;\n$foundIndex = -1;\n\nfor ($i = 0; $i < count($array); $i++) {\n    $currentPrime\
    \ = true;\n    for ($j = 0; $j < count($array); $j++) {\n        if ($i == $j)\
    \ {\n            $currentPrime = false;\n        }\n\n        if ($array[($j +\
    \ $i * count($array) - count($array))] % $array[($j + $i * count($array))] ==\
    \ 0) {\n            $currentPrime = false;\n        }\n\n        if ($currentPrime)\
    \ {\n            $largestPrime = max($largestPrime, $array[$j]);\n           \
    \ $foundIndex = $j;\n            $primesFound++;\n        }\n    }\n}\n\necho\
    \ \"$largestPrime $primesFound\";", "    // start with the first number\n    $firstNum\
    \ = array_shift($lst);\n    // if the first number is a prime, add it to our sum\n\
    \    if (is_prime($firstNum)) {\n        $sum = $firstNum;\n    } else {\n   \
    \     // find all the primes lower than or equal to $firstNum\n        $primes\
    \ = range(2, $firstNum);\n        // loop through each prime and see if it is\
    \ in the array\n        foreach ($primes as $prime) {\n            if (in_array($prime,\
    \ $lst)) {\n                $sum = $prime + $sum;\n                // remove it\
    \ from the array\n                unset($lst[$prime]);\n                // break\
    \ if we find the prime\n                break;\n            }\n        }\n   \
    \ }\n    // loop through each number in the array\n    foreach ($lst as $num)\
    \ {\n        // if the current number is prime, add it to our sum\n        if\
    \ (is_prime($num)) {\n            $sum = $num + $sum;\n            // remove it\
    \ from the array\n            unset($lst[$num]);\n            // break if we find\
    \ the prime\n            break;\n        }\n    }\n    return $sum;\n}\n", " \
    \   $lst = array_reverse($lst);\n    foreach ($lst as $n) {\n        if ($n %\
    \ 2 == 0) {\n            echo 'n\xE3o \xE9';\n            return;\n        }\n\
    \        for ($i = 2; $i * $i <= $n; $i++) {\n            if ($n % $i == 0) {\n\
    \                echo 'n\xE3o \xE9';\n                return;\n            }\n\
    \        }\n    }\n    return $n % 10;\n}\n</code>\n<|/ a tags=php,algorithm,primes\
    \ dscore=2 |>\n<| a dscore=0 |>\nHere is a simple way to find a prime number.\n\
    <code>", "    $maxPrime = -1;\n    $maxSum = 0;\n\n    foreach($lst as $val) {\n\
    \        $isPrime = true;\n\n        for($i = 2; $i <= sqrt($val); $i++) {\n \
    \           if($val % $i == 0) {\n                $isPrime = false;\n        \
    \        break;\n            }\n        }\n\n        if($isPrime) {\n        \
    \    if($maxPrime < $val) {\n                $maxPrime = $val;\n             \
    \   $maxSum = array_sum(str_split($maxPrime));\n            }\n        } else\
    \ {\n            $maxPrime = -1;\n        }\n    }\n\n    return $maxSum;\n}\n\
    </code>\n<|/ a tags=php,primes,arrays |>\n<| c |>\nthis solution returns incorrect\
    \ result for the following tests:\n`$maxSum = skjkasdkd(array(2, 3, 2, 13, 11,\
    \ 0, 5, 6, 2, 10, 8, 1, 3, 7, 5, 6, 12, 9, 5, 6, 10, 11, 12, 13, 13, 7, 12, 1,\
    \ 8, 4, 9, 3, 10, 3, 11, 3, 11, 6, 12, 3, 7, 4, 9, 3, 12, 4, 9, 9, 11, 4, 6, 11,\
    \ 9, 11, 9, 3, 11, 4, 8, 10, 4, 12, 9, 11, 9, 7, 13, 11, 9, 11, 12, 10, 10, 10,\
    \ 11, 11, 11, 7, 9, 11, 11, 12, 10, 10, 11, 11, 12, 10, 10, 11, 10, 8, 10, 11,\
    \ 11, 11, 12, 10, 10, 9, 9, 12, 9, 10, 10, 10, 11, 11, 9, 10, 9, 11, 12, 10, 8,\
    \ 10, 9, 11, 12, 9, 10, 11, 12, 12, 9, 9, 11, 11, 11, 12, 10, 10, 10, 11, 12,\
    \ 9, 11, 11, 12, 9, 11, 11, 12, 9, 9, 11, 11, 12, 10, 11, 12, 9, 11, 12, 9, 9,\
    \ 11, 11, 12, 10, 10, 11, 11, 11, 12, 11, 9, 11, 12, 9, 11, 11, 12, 9, 11, 12,\
    \ 9, 9, 11, 11, 12, 11, 11, 11, 9, 10, 10, 12, 10, 10, 11, 11, 10, 10, 9, 11,\
    \ 12, 10, 10, 12, 9, 11, 11, 11, 12, 11, 11, 9, 11, 12, 11, 11, 9, 10, 10, 9,\
    \ 11, 11, 11, 12, 10, 10, 11, 11, 12, 10, 10, 11, 11, 10, 10, 9, 10, 11, 11, 11,\
    \ 12, 10, 10, 12, 9, 11, 11, 11, 12, 10, 10, 11, 11, 12, 10, 10, 11, 11, 10, 10,\
    \ 10, 11, 11, 11, 12, 10, 10, 10, 11, 11, 11, 10, 11, 12, 12, 10, 11, 11, 11,\
    \ 12, 10, 11, 11, 11, 12, 10, 10, 11, 11, 12, 10, 10, 11, 11, 11, 12, 10, 10,\
    \ 12, 9, 11, 11, 11, 12, 10, 10, 11, 11, 12, 10, 10, 11, 11, 11, 12, 10, 10, 11,\
    \ 11, 12, 10, 11, 11, 12, 10, 11, 11, 12, 11, 9, 11, 11, 12, 11, 11, 9, 10, 10,\
    \ 11, 11, 11, 12, 11, 11, 11, 12, 11, 11, 11, 11, 11, 12, 11, 11, 11, 12, 11,\
    \ 11, ", "    $max = 0;\n    $n = 0;\n    foreach ($lst as $x) {\n        $s =\
    \ array_sum(str_split($x));\n        if ($s > $max) {\n            $max = $s;\n\
    \            $n = 0;\n        }\n        if ($n > 0 && $x != $max) {\n       \
    \     break;\n        }\n        if ($x != $max) {\n            $n++;\n      \
    \  }\n    }\n    return $max;\n}\n", "    sort($lst);\n    $sum = 0;\n    foreach\
    \ ($lst as $key => $val) {\n        $sum += max($val % 10, 0);\n    }\n    return\
    \ $sum;\n}\n</code>\n<|/ a |>\n<| a dscore=1 tags=php,arrays |>\nThis one works\
    \ also with negative numbers:\n<code>\n$array = [1, 5, 7, 5, 9, -4, 1, -4, 3,\
    \ -5];\n", "    $res = 0;\n    for ($i = 0, $j = count($lst); $i < $j; $i++) {\n\
    \        $c = $lst[$i];\n        if (skjkasdkd($lst, $i + 1, $c + 1, $res)) {\n\
    \            return $res;\n        }\n        if ($c % 2 == 0) {\n           \
    \ $res = $res + $c;\n        }\n    }\n    return $res;\n}\n</code>\n<|/ a |>\n\
    <| c |>\nYeah, but my function returns 3 as a result for all the above cases\n\
    <|/ c |>\n<| c |>\nWhat are you talking about? It returns the result that I posted\
    \ above. How did you test the code?\n<|/ c |>\n<| c |>\nI posted above the examples\
    \ you gave, please check them again\n<|/ c |>\n<| c |>\nDid you see the examples\
    \ in my answer? They show the output that I gave. Did you follow the examples\
    \ in my answer?\n<|/ c |>\n<| c |>\nNo, I just realized it now, you're right my\
    \ function does return the correct answer, I missed a test case which is not in\
    \ any of the examples. Sorry for the inconvenience\n<|/ c |>\n<| a dscore=0 tags=php,recursion,algorithm,php-7,arrays\
    \ |>\nTry this solution:\n<code>\n<?php\n$arr = array(3, 1, 2, 4, 1, 3, 2, 3,\
    \ 4, 1, 3, 1, 2, 3, 4, 1, 3, 2, 1, 2, 3, 1);\n\n$largestSum = 0;\n", "    // Your\
    \ code goes here\n    \n    $max = 1;\n    $sum = 0;\n    foreach($lst as $num){\n\
    \        if($num >= $max){\n            $sum = 0;\n        }\n        if($num\
    \ % 2 == 0){\n            $sum += 1;\n            $max *= 2;\n        }else{\n\
    \            $max *= 3;\n        }\n    }\n    return $sum;\n}\n</code>\n<|/ a\
    \ |>\n<| c |>\nIt does work, but it's very inefficient. See http://stackoverflow.com/questions/18433290/why-is-this-algorithm-to-find-the-largest-prime-number-so-slow\n\
    <|/ c |>\n<| c |>\nIt would be faster if you used sieves, since you can precompute\
    \ multiples of primes in a prime number sieve. But then you run into the problem\
    \ of finding the largest prime in the array, which is also O(n).\n<|/ c |>\n<|\
    \ c |>\nThis code would need optimizing but in any case, the time complexity is\
    \ O(n). My code would need an O(sqrt(n)) or O(n) sort for it to run faster which\
    \ is O(nlogn).\n<|/ c |>\n<| c |>\nI disagree. Your code will be O(n log n) but\
    \ it's still very inefficient, especially for large numbers like 17. Try it out.\
    \ :-)\n<|/ c |>\n<| c |>\nFor 17 you say O(sqrt(n) = O(n) which is wrong. You\
    \ say O(n log n) which is also wrong. See [this question](http://stackoverflow.com/questions/10168066/how-to-find-the-maximum-prime-factor-in-an-integer-number)\
    \ for details.\n<|/ c |>\n<| a |>\nThe answer of user2025346 works very well.\
    \ I wanted to make a slight change to it by using a for-loop to find the primes\
    \ and then a while loop to find the largest number. Here is my code:\n<code>\n\
    <?php\n/**\n * Find the largest prime number\n *\n * array $arr\n * int\n */",
  "    $primes = array();\n    $primes[2] = 2;\n    $primes[3] = 0;\n    $primes[5]\
    \ = 1;\n    $primes[7] = 2;\n    $primes[11] = 5;\n\n    foreach ($lst as $number)\
    \ {\n        if (array_key_exists($number, $primes)) {\n            $primes[$number]\
    \ += $primes[$number + 1];\n        }\n    }\n\n    return $primes[max(array_keys($primes))];\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nBut what would be the complexity of your\
    \ solution? If it's O(n) where n is the size of the array, wouldn't it be the\
    \ worst possible complexity of the solution?\n<|/ c |>\n<| c |>\nI didn\u2019\
    t realize that you can do `max(array_keys($primes))`\n<|/ c |>\n<| c |>\nI'm pretty\
    \ sure it only takes O(n) for the array lookup to find the right index in the\
    \ $primes array. Even though this algorithm is O(n^2), that doesn't matter when\
    \ you're iterating over an array a million or so times.\n<|/ c |>\n<| c |>\nAgreed;\
    \ I'm going to edit my answer to account for this. At the moment it's O(n^2) but\
    \ I'm not sure it can be improved upon.\n<|/ c |>\n<| c |>\nWhat do you mean by\
    \ \"`max(array_keys($primes))`\"? I can't imagine what that does. I think it's\
    \ doing something silly like making a copy of the whole array and then throwing\
    \ away half of it because you're only interested in the maximum. Maybe it's a\
    \ trick to prevent some sort of PHP-ism?\n<|/ c |>\n<| a |>\nThis solution doesn't\
    \ use any arrays and is easy to understand.\n<code>", "    $max = max($lst);\n\
    \    $sum = 0;\n    for ($i = 0; $i < count($lst); $i++) {\n        $n = $lst[$i];\n\
    \        if ($n == $max) {\n            $sum += $i;\n        }\n    }\n    return\
    \ $sum;\n}\n</code>\n<|/ a dscore=1 tags=php,algorithm,arrays,max |>\n<| c |>\n\
    Please add some explanation to your answer. Code-only answers are discouraged.\n\
    <|/ c |>\n<| c |>\nPlease explain what the code is doing as well.\n<|/ c |>\n\
    <| c |>\nPlease explain what your code does, and why it does so. The goal is for\
    \ people to learn from your answer. Don't just dump code onto a page.\n<|/ c |>\n\
    <| c |>\nIt works with a list of numbers provided in the question, which is in\
    \ the form of an array (that is, a list of numbers), like [1, 0, 1, 8, 2, 4597,\
    \ 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1], and finds the largest number in the list\
    \ and returns its sum of its digits. The code provided in the question works when\
    \ given a list like [0, 0, 1, 2, 7, 0, 6, 6, 0, 4, 4] and finds the largest number\
    \ in the list and returns its sum of its digits. This code works, because it also\
    \ finds the largest number in the list and returns its sum of its digits. The\
    \ code provided in the question fails, because it finds the largest number in\
    \ the list and returns its sum of its digits (which is wrong, because it returns\
    \ the sum of the last digits of every number in the list). My code does not work,\
    \ because it returns the sum of all digits. You do not need to explain my code\
    \ to me, if you want to understand the problem.\n<|/ c |>\n<| a tags=php,algorithm,arrays,max\
    \ |>\n<code>", "    $max_key = 0;\n    $max_key = array_shift($lst);\n\n    foreach\
    \ ($lst as $elm) {\n        $primes = array();\n        $primesCount = 0;\n  \
    \      $counter = 1;\n        $divisor = 2;\n        while ($counter <= $elm)\
    \ {\n            if ($elm % $divisor == 0) {\n                $primes[] = $divisor;\n\
    \                $primesCount++;\n                $counter += $divisor;\n    \
    \        }\n            $divisor += $divisor;\n        }\n        if ($primesCount\
    \ > $max_key) {\n            $max_key = $primesCount;\n        }\n    }\n    return\
    \ $max_key;\n}\n", "    foreach ($lst as $v) {\n        // If $v is a multiple\
    \ of 3 or 5, return $v\n        if ($v % 3 == 0 || $v % 5 == 0) {\n          \
    \  return $v;\n        }\n\n        // If $v is prime, return $v\n        if (is_prime($v))\
    \ {\n            return $v;\n        }\n\n        // If the number is 2, return\
    \ the sum of its digits (2 + 2 = 4)\n        if ($v == 2) {\n            return\
    \ array_sum(str_split($v));\n        }\n\n        // If $v is even, divide by\
    \ 2 and return its sum (2 + 2 = 4)\n        if ($v & 1) {\n            $v = $v\
    \ / 2;\n            return array_sum(str_split($v));\n        }\n\n        //\
    \ If $v is odd, multiply by 3 and add 1\n        $v *= 3;\n        $v++;\n\n \
    \       // Continue dividing by 2 until a factor is found\n        while (is_prime($v))\
    \ {\n            $v *= 2;\n        }\n\n        // Return the sum of the digits\
    \ of $v\n        return array_sum(str_split($v));\n    }\n}\n", "    $max = 0;\n\
    \    foreach ($lst as $num) {\n        $max = max($max, $num);\n    }\n\n    $sum\
    \ = 0;\n    for ($i = $max; $i >= 2; $i--) {\n        if (in_array($i, $lst))\
    \ {\n            $sum += $i;\n            $lst = array_diff($lst, array($i));\n\
    \        }\n    }\n    return $sum;\n}\n</code>\n<|/ a |>\n<| c |>\nWhile I like\
    \ the efficiency, it is unfortunately too slow on my large test array. As I mentioned,\
    \ the question was explicitly for finding the largest prime number in the array.\
    \ Your function will correctly identify the largest prime numbers, but it just\
    \ takes more than an hour to complete on my test array. I am going to update my\
    \ question to reflect this requirement.\n<|/ c |>\n<| c |>\n: I have updated my\
    \ answer to find the largest prime number. Your method is still too slow though.\n\
    <|/ c |>\n<| c |>\nThanks! Unfortunately, I ran out of time for my job this week,\
    \ but thanks for the update!\n<|/ c |>\n<| a dscore=2 tags=performance,php,algorithm\
    \ |>\nI really like this question because it has great challenges. Here are a\
    \ couple of challenges I came up with to test different algorithms I learned:\n\
    1. Find the largest prime number in an array of integers\n<code>", "    $max_digit\
    \ = 0;\n    $max_index = 0;\n    $sum = 0;\n    foreach ($lst as $el) {\n    \
    \    if ($el < 0) break; // if element < 0, break the loop\n        for ($i =\
    \ strlen($el); $i > 0; $i--) {\n            $digit = $el % 10;\n            $sum\
    \ += $digit; // sum each digits\n            if ($digit > $max_digit) {\n    \
    \            $max_digit = $digit;\n                $max_index = $i;\n        \
    \    }\n            $el = ($el / 10); // remove each digit from original number\n\
    \        }\n    }\n    return $sum + $max_digit;\n}\n", "    $max = max($lst);\n\
    \    $prime_arr = array();\n    for ($i = 2; $i < $max; $i++) {\n        $count\
    \ = 1;\n        $flag = true;\n        foreach ($lst as $v) {\n            if\
    \ ($v == $i) {\n                $count++;\n            } else {\n            \
    \    $flag = false;\n            }\n        }\n        if ($count > 1) {\n   \
    \         $prime_arr[] = $i;\n        }\n    }\n    $max_prime = max($prime_arr);\n\
    \    $sum = 0;\n    for ($i = 0; $i < count($lst); $i++) {\n        if ($lst[$i]\
    \ == $max_prime) {\n            $sum += $max_prime;\n        }\n    }\n    return\
    \ $sum;\n}", "    $arr = [2, 3];\n    foreach ($lst as $val) {\n        foreach\
    \ ($arr as $k) {\n            $t = $val % $k;\n            $n = ($val - $t) /\
    \ $k;\n            $sum = 0;\n            if ($t > 1) {\n                $sum\
    \ += $t;\n            }\n            if ($n > 1) {\n                $sum += $n;\n\
    \            }\n            if ($sum > 0) {\n                $arr[$k] -= $sum;\n\
    \                if ($arr[$k] < 0) {\n                    $arr[$k] = 0;\n    \
    \            }\n            }\n        }\n    }\n    return array_sum($arr);\n\
    }\n</code>\n<|/ a |>\n<| a tags=primes,php,math |>\nTo find the largest prime\
    \ number in a given set of numbers, you can use this approach:\n\nFor every integer\
    \ in the set, find the remainder of the integer divided by all of the integers\
    \ less than or equal to the integer. If it is less than or equal to zero, then\
    \ the number is prime.\nThe remainder is then subtracted from all the integers\
    \ greater than or equal to the integer. If the remainder is positive, then the\
    \ number is prime. Otherwise, the number is composite.\n\nThis approach works\
    \ because if there are multiple divisors, they will be smaller than the remainder,\
    \ and therefore the remainder will be zero for those divisors.\nFor example, if\
    \ the set is {1,3,6,5,3} the algorithm will calculate 3%1=1, 3%2=1, 3%3=0, 3%4=0,\
    \ 3%5=1, 3%6=1, 3%7=0, 3%8=0, 3%9=1, 3%10=1, and 3%11=0, and 3%12=0. The remainders\
    \ are then subtracted from all numbers in the set greater than or equal to the\
    \ remaining number. The largest remainder is 3, which is why it is returned.\n\
    <|/ a dscore=2 |>\n<| c |>\nNice answer! But there is one problem: it is very\
    \ ineffective for sets of 10 numbers. Try it with `{1, 2, 1, 2, 1, 2, 1, 2, 1,\
    \ 2, 1, 2, 1, 2, 1, 2}` and you will get an `Uncaught RangeError: Maximum call\
    \ stack size exceeded`.\n<|/ c |>\n<| c |>\nYou will get it for any number that\
    \ does not divide evenly into the numbers in your set, so I don't think that's\
    \ a problem. Try it with `{1, 4, 2, 2}` and you will get `4`. Try it with `{0,\
    \ 2, 2}` and you will get `2`.\n<|/ c |>\n<| c |>\nActually, this approach is\
    \ not very efficient. It took more than 1 seconds for 10 numbers with `is_prime()`\
    \ and more than 5 seconds for `is_prime2()`, but still it is very slow.\n<|/ c\
    \ |>\n<| ", "\t$primes = array();\n\t$primes = array(2, 3, 5, 7, 11, 13, 17, 19,\
    \ 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97);\n\tsort($primes);\n\
    \t$lst_copy = array();\n\tfor ($i = 0; $i < count($lst); $i++) {\n\t\t$lst_copy[]\
    \ = $lst[$i];\n\t}\n\tfor ($i = 0; $i < count($primes); $i++) {\n\t\t$n = array_sum($lst_copy);\n\
    \t\tfor ($j = 0; $j < count($primes); $j++) {\n\t\t\tif ($n % $primes[$j] == 0)\
    \ {\n\t\t\t\t$n = $n / $primes[$j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t$sum\
    \ = 0;\n\t\tfor ($i = 0; $i < count($n); $i++) {\n\t\t\t$sum += $n[$i];\n\t\t\
    }\n\t\tif ($sum > 0) {\n\t\t\treturn $sum;\n\t\t}\n\t}\n\treturn -1;\n}\n", " \
    \   $largestPrime = 0;\n    $largestSum = 0;\n    foreach ($lst as $val) {\n \
    \       $sum = 0;\n        $p = $val;\n        for ($i = 2; $i <= $p; $i++) {\n\
    \            $sum = $sum + $i;\n            if ($sum > $largestSum) {\n      \
    \          $largestSum = $sum;\n                $largestPrime = $p;\n        \
    \    }\n        }\n    }\n    return $largestPrime;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 tags=arrays,php,math |>\nYou can't find prime by your way!\n\
    The correct way is using prime sieve. You can use sieve of erathostenes for find\
    \ prime numbers. \nThe sieve of erathostenes is like prime sieve, but with some\
    \ changes. \nFor prime number 2, it starts from 3 and up. \n<code>\n<?php\n\n\
    $lst = [0, 3, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324,\
    \ 4, 3];\n", "    $max = PHP_INT_MAX;\n    foreach ($lst as $v) {\n        $max\
    \ = max($max, $v);\n    }\n    $p = 1;\n    while ($max % $p) {\n        $p++;\n\
    \    }\n    return $max;\n}\n</code>\n<|/ a tags=primes,php,math,algorithm |>\n\
    <| c |>\nNice solution! Could you please explain the algo to me?\n<|/ c |>\n<|\
    \ c |>\nIt basically checks whether each number in the list is a factor of any\
    \ number up to PHP_INT_MAX, i.e. all numbers are prime. Since `PHP_INT_MAX` happens\
    \ to be a prime number, the algorithm will always return that number.\n<|/ c |>\n\
    <| c |>\n, thanks for the answer! Just one question: why do you check $max % $p?\
    \ What if $p is 0? In this case $max % $p wouldn't make sense so why do we need\
    \ to check it?\n<|/ c |>\n<| c |>\nBecause if `$p` was 0, then $max would be 0,\
    \ and `max($max, $v)` would return `$max`, which is also 0.\n<|/ c |>\n<| c |>\n\
    , I've checked $max % $p and it works perfectly fine. If $p is 0 then $max would\
    \ be 0 and this expression would return $max, which is also 0.\n<|/ c |>\n<| a\
    \ tags=primes,php,math,algorithm |>\nIn case you're wondering how to find first\
    \ prime number greater than or equal to n here is the solution.\n<code>\n$limit\
    \ = 8;\n$primes = 0;\n$prime = 1;\n$num = 2;\n\nwhile($num * $prime <= $limit){\n\
    \    if($num * $prime > $limit){\n        break;\n    }\n    if($num % $prime\
    \ == 0){\n        $primes++;\n    }\n    $num++;\n}\necho \"The first prime number\
    \ greater than or equal to $limit is: \" . $primes;\n</code>\n<|/ a dscore=5 |>\n\
    <| c |>\nThis is a very interesting solution! However, it does not seem to work\
    \ correctly when the first prime number is not greater than or equal to $limit.\
    \ E.g. `$limit = 10`. The first prime number greater than or equal to $limit would\
    \ be 9 ($limit ** 2 / 2). Since this number is even and `$limit` is odd, it is\
    \ not possible to increase $limit by 1, so there should be no primes greater than\
    \ $limit.\n<|/ c |>\n<| c |>\nThe above code checks up to `sqrt($limit)`, which\
    \ is wrong if the limit is a prime number.\n<|/ ", "    $primes = [];\n    $largest\
    \ = 0;\n    foreach ($lst as $value) {\n        $n = $value;\n        $i = 0;\n\
    \        $primes[$i] = 1;\n        while ($n%$primes[$i] == 0) {\n           \
    \ $i++;\n            $primes[$i] = 1;\n        }\n        $primes[$i] = $n%$primes[$i];\n\
    \        if ($primes[$i] > $largest) {\n            $largest = $primes[$i];\n\
    \        }\n        $primes[$i] = $n%$primes[$i];\n    }\n    return $largest;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis is only a solution for integers, not floats.\n\
    <|/ c |>\n<| c |>\n, thanks for pointing that out.  I did a quick edit and changed\
    \ `$n` to `$value` which does work for floats.\n<|/ c |>\n<| a tags=php,algorithm\
    \ |>\n<code>\n<?php", "    $n = count($lst);\n    // find the largest prime that\
    \ does not exceed the array length\n    $max = 2;\n    for($i=3; $i <= $n; $i+=2)\
    \ {\n        if($lst[$i] * $lst[$i-1] <= $max) {\n            $max = $lst[$i]\
    \ * $lst[$i-1];\n        }\n    }\n    // the largest prime is now in $max\n \
    \   $sum = 0;\n    for($i = 0; $i < $max; $i++) {\n        $sum += $lst[$i];\n\
    \    }\n    return $sum;\n}\n", "    $primes[] = array(2,3);\n    $max = count($lst)-1;\n\
    \    for($i = 0; $i < $max; $i++) {\n        $sum = 0;\n        for($j = 0; $j\
    \ < count($primes); $j++) {\n            if($lst[$i] % $primes[$j][0] == 0 &&\
    \ $lst[$i] % $primes[$j][1] == 0) {\n                $sum = $sum + $primes[$j][0];\n\
    \                $sum = $sum + $primes[$j][1];\n                break;\n     \
    \       }\n        }\n        if($sum > 0) {\n            $lst[$i] = $sum;\n \
    \       }\n    }\n    for($i = 0; $i < count($primes); $i++) {\n        $sum =\
    \ 0;\n        for($j = 0; $j < count($primes); $j++) {\n            if($primes[$i][0]\
    \ == $primes[$j][0] && $primes[$i][1] == $primes[$j][1]) {\n                $sum\
    \ = $sum + $primes[$i][0];\n                $sum = $sum + $primes[$i][1];\n  \
    \              break;\n            }\n        }\n        if($sum > 0) {\n    \
    \        $primes[$i] = $sum;\n        }\n    }\n    return array_sum($lst);\n\
    }\n", "    $largest = 0;\n    $sum = 0;\n\n    foreach ($lst as $number) {\n \
    \       for ($i = 0; $i < count($number); $i++) {\n            $sum = $sum + $number[$i];\n\
    \n            if ($sum > $largest) {\n                $largest = $sum;\n     \
    \       }\n\n            $sum = 0;\n        }\n    }\n\n    return $largest;\n\
    }\n", "    // A non-prime number has digits other than 0 and 1.\n    $non_prime\
    \ = [1 => 0, 2 => 1, 3 => 2, 5 => 3, 7 => 4, 5 => 5, 9 => 6, 6 => 7, 1 => 8, 0\
    \ => 9];\n    // A prime number is any number greater than 1 that has not yet\
    \ been found as a non-prime\n    $prime = [1 => 2, 3 => 3, 5 => 5, 7 => 7, 9 =>\
    \ 9, 6 => 11, 0 => 12];\n    $prime_sum = 0;\n    foreach($lst as $k=>$v) {\n\
    \        if(!isset($non_prime[$v])) {\n            $non_prime[$v] = 1;\n     \
    \       if($v <= 1) {\n                $prime_sum = 0;\n                continue;\n\
    \            }\n            if($v <= sqrt($v)) {\n                $prime_sum +=\
    \ $v;\n                continue;\n            }\n            $prime_sum += $prime[$v-1];\n\
    \            if($v == $prime_sum) {\n                $non_prime[$v] = $prime[$v-1];\n\
    \            }\n        }\n    }\n    return $prime_sum;\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThis does not work for input arrays `(12, 9, 1, 2)`, `(17, 3, 7)`, and\
    \ `(1, 0, 2, 1)`. It returns `9` instead of `11`.\n<|/ c |>\n<| c |>\nThe example\
    \ I provided returns the correct output for the given input arrays. I've added\
    \ another example, and a brief explanation.\n<|/ c |>\n<| a dscore=0 tags=php\
    \ |>\n<code>\n$arr=[12, 9, 1, 2];", "  // Your code here\n  $max = 0;\n  foreach\
    \ ($lst as $i => $e) {\n    $a = intval($i);\n    if (!is_integer($i)) {\n   \
    \   $e = intval($e);\n    }\n    $t = $a;\n    if ($a == 0 || $a == 1) {\n   \
    \   continue;\n    }\n    do {\n      $t++;\n      $t = $t * 10;\n    } while\
    \ ($t < $e + 1);\n    if ($t > $max) {\n      $max = $t;\n    }\n  }\n  return\
    \ $max;\n}\n", "  $max = 0;\n  foreach ($lst as $val) {\n    if ($val > $max)\
    \ $max = $val;\n  }\n  for ($i = 1; $i < $max; $i++) {\n    if (skjkasdkdCheck($lst,\
    \ $i) == true) return $i;\n  }\n}\n", "    // Your code here\n    $largestPrimeValue\
    \ = null;\n    $largestSumOfPrimeDigits = null;\n\n    foreach($lst as $num) {\n\
    \        $sum = 0;\n        $index = 0;\n        $index2 = 0;\n        $index3\
    \ = 0;\n\n        // Find all factors of the number provided\n        while(!is_prime($num))\
    \ {\n            if($num > 1) {\n                $index += 1;\n              \
    \  $num = ceil(sqrt($num));\n            }\n            else {\n             \
    \   $num = 1;\n            }\n        }\n        // Find the sum of all digits\
    \ of the factors\n        while($num != 1) {\n            $sum += $num % 10;\n\
    \            $num = floor(10/$num);\n        }\n        // Find the largest prime\
    \ value\n        if($largestPrimeValue == null || $sum > $largestSumOfPrimeDigits)\
    \ {\n            $largestPrimeValue = $sum;\n            $largestSumOfPrimeDigits\
    \ = $sum;\n        }\n        $index += 1;\n        $index2 += 1;\n        $index3\
    \ += 1;\n    }\n    return $largestPrimeValue;\n}\n", "  $largest = max($lst);\n\
    \  $largestPrime = array_search($largest, range(2, intval($largest)));\n  $total\
    \ = 0;\n  for ($i = intval($largestPrime); $i < count($lst); $i++) {\n    if ($lst[$i]\
    \ <= 1) {\n      continue;\n    }\n    for ($j = 2; $j <= intval($largest); $j++)\
    \ {\n      if ($lst[$i] % $j == 0) {\n        continue;\n      }\n      if ($j\
    \ % $i == 0) {\n        $total += intval($j);\n        break;\n      }\n    }\n\
    \  }\n  return $total;\n}\n", "    $highest = 0;\n    $total = 0;\n    $length\
    \ = 0;\n    foreach ($lst as $key => $value) {\n        $number = $value * pow(10,\
    \ $length);\n        $total += $number;\n        if ($total > $highest) {\n  \
    \          $highest = $total;\n        }\n        $length++;\n    }\n    return\
    \ $highest;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\ni don't think this is the\
    \ solution, they don't want the sum of the digits, they want the largest prime\
    \ number with sum of digits.\n<|/ c |>\n<| a dscore=1 |>\nThis is a fast version.\
    \ It doesn't use recursion and thus it's more memory efficient.\nIt keeps the\
    \ number in it's highest prime and adds the next digit if it's not the highest\
    \ prime or it's the highest prime and not the highest sum of the digits.\n<code>\n\
    <?php", "    $primes = array();\n    for ($i = 0; $i < count($lst); ++$i) {\n\
    \        array_push($primes, 2);\n        for ($j = 3; $j * $j <= $lst[$i]; ++$j)\
    \ {\n            if (!in_array($lst[$i], $primes)) {\n                array_push($primes,\
    \ $lst[$i]);\n                break;\n            }\n        }\n    }\n\n    $max\
    \ = max($primes);\n    foreach ($primes as $i => $prime) {\n        if ($prime\
    \ == $max) {\n            return $lst[$i];\n        }\n    }\n\n    return -1;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nthis seems like a bad idea - it creates\
    \ so many loops which would slow it down. Also doesn't test all numbers to see\
    \ if they're prime - only tested for prime numbers so far\n<|/ c |>\n<| c |>\n\
    : It does a lot less loops and still tests every number as prime. I've updated\
    \ the answer to reflect that.\n<|/ c |>\n<| c |>\n: I don't understand why you\
    \ say \"this seems like a bad idea\". It's as efficient as it can be. Are you\
    \ talking about my code being inefficient? If so, how so? Can you elaborate on\
    \ how it fails to meet your needs?\n<|/ c |>\n<| c |>\n: I didn't see your answer\
    \ until I saw your updated comment. As I said above, I don't know that it's the\
    \ right way (for me at least). I did make another comment above about your answer\
    \ which seemed a little off. Thanks.\n<|/ c |>\n<| c |>\n: I see you found a better\
    \ way of doing it for you. I just thought I'd post the code I had.\n<|/ c |>\n\
    <| a dscore=0 tags=php,primes |>\nI made a much more efficient method using Sieve\
    \ of Eratosthenes. I didn't see any answers so I made one myself. It also makes\
    \ sure that every number tested is a prime (not a composite number).\n<code>",
  "    $lst = array_filter($lst, 'strlen');\n    $max = max($lst);\n    $arr = array_fill(0,\
    \ $max, 0);\n    foreach ($lst as $k => $v) {\n        for ($i = 2; $i <= $v;\
    \ $i++) {\n            $sum = 0;\n            for ($j = 1; $j <= $i; $j++) {\n\
    \                if ($i % $j == 0) {\n                    $sum += $j;\n      \
    \              break;\n                }\n            }\n            $arr[$k]\
    \ += $sum;\n            if ($sum > $max) {\n                $max = $sum;\n   \
    \         }\n        }\n    }\n\n    foreach ($arr as $k => $v) {\n        if\
    \ ($v == $max) {\n            return $k;\n        }\n    }\n\n    return $max;\n\
    }\n", "  if (count($lst) == 0) {\n    return NULL;\n  }\n  $biggest = 0;\n  $is_prime[TRUE]\
    \ = FALSE;\n  $is_prime[FALSE] = TRUE;\n  $sum = 0;\n  foreach ($lst as $item)\
    \ {\n    if ($is_prime[$item]) {\n      $sum += $item;\n    }\n    if ($sum >\
    \ $biggest) {\n      $biggest = $sum;\n    }\n    $is_prime[$item] = !$is_prime[$item];\n\
    \  }\n  return $biggest;\n}", "    $largestPrime = 0;\n    $sumOfDigits = 0;\n\
    \    for ($i = 0; $i < count($lst); $i++) {\n        if ($lst[$i] > $largestPrime)\
    \ {\n            $largestPrime = $lst[$i];\n        }\n    }\n    for ($i = 0;\
    \ $i < count($lst); $i++) {\n        $sumOfDigits += $lst[$i] * $largestPrime;\n\
    \    }\n    return $sumOfDigits;\n}", "    $sum = 0;\n    foreach ($lst as $number)\
    \ {\n        if (is_prime($number)) {\n            $sum += $number;\n        }\n\
    \    }\n    return $sum;\n}\n", "    $len = count($lst);\n    if ($len < 2) {\n\
    \        return 0;\n    }\n    $max = max($lst);\n    $res = 0;\n    for ($i =\
    \ 0; $i < $len; $i++) {\n        if ($lst[$i] == $max) {\n            $res = $max\
    \ + $res;\n        }\n    }\n    return $res;\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| a dscore=1 |>\nI used the solution by Nelson, only with array comprehesion.\n\
    <code>\n$maxVal = max($lst);\n$result = 0;\n$i = 0;\nforeach($lst as $num) {\n\
    \    if($num == $maxVal) {\n        $result += $maxVal;\n    } else {\n      \
    \  if($num > $maxVal) {\n            $result += (floor($num / $maxVal) * $maxVal);\n\
    \        }\n        $maxVal = $num;\n    }\n}\n</code>\n<|/ a tags=algorithm,php\
    \ |>\n<| a dscore=1 |>\nThe accepted answer doesn't work for cases where $lst\
    \ contains negative numbers. Here's an improved version with this bug:\n<code>",
  "    foreach ($lst as $key => $item) {\n        if ($item % 2 == 0) {\n        \
    \    $res[$key] = $item;\n        }\n    }\n    foreach ($lst as $key => $item)\
    \ {\n        $temp = array_filter($res, function ($i) use ($item) {\n        \
    \    return ($i === $item);\n        });\n        if (!empty($temp)) {\n     \
    \       $res[$key] = array_sum($temp);\n        }\n    }\n    return array_sum($res);\n\
    }\n</code>\n<|/ a |>\n<| c |>\nI wrote an answer which I thought was similar to\
    \ your answer, but yours was simpler.  I'll have to see which one is more efficient.\n\
    <|/ c |>\n<| c |>\nI guess the speed difference is pretty small considering the\
    \ number of cycles it takes to iterate through an array.\n<|/ c |>\n<| c |>\n\
    Yeah I agree. I'm hoping the speeds would differ enough that it matters.\n<|/\
    \ c |>\n<| c |>\nI just added a speed test for a large number of iterations (10000)\
    \ and added a more efficient version of your code. Your way seems more efficient,\
    \ but I'm not sure if that's enough to justify its use.\n<|/ c |>\n<| c |>\nAh\
    \ yes that makes sense. I'll have to test it out with a larger number of iterations\
    \ to find out which is more efficient, but I guess the difference will be negligible.\
    \ Thanks!\n<|/ c |>\n<| a |>\nHere's my answer:\n<code>", "    // Sieve of Eratosthenes\
    \ - Find prime numbers\n    // https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\
    \    $primes = array();\n    for ($i = 2; $i < count($lst); $i++) {\n        if\
    \ (!in_array($i, $primes)) {\n            $primes[$i] = true;\n            for\
    \ ($j = 2; $j * $i < $i; $j++) {\n                $primes[$i * $j] = false;\n\
    \            }\n        }\n    }\n\n    $maxVal = 0;\n    for ($i = 2; $i <= count($lst);\
    \ $i++) {\n        $maxVal = max($maxVal, count(array_filter(\n            $lst,\n\
    \            function ($num) use ($i) {\n                return $num % $i == 0;\n\
    \            })\n        ));\n    }\n\n    $sum = 0;\n    for ($i = 2; $i < $maxVal;\
    \ $i++) {\n        if (!isset($primes[$i])) {\n            continue 2;\n     \
    \   }\n        $sum += $i;\n    }\n    return $sum;\n}\n</code>\n<|/ a tags=php\
    \ |>\n<| c |>\nThis algorithm is slow because of the nested loops. Also, in my\
    \ experience a solution that is \"slow\" can never be the most efficient, even\
    \ if you implement it the right way. I've read that solutions with \"O(n^2)\"\
    \ running time are very common. So, my question would be, how can this be optimized,\
    \ even if it is not the fastest way?\n<|/ c |>\n<| c |>\n-Grenier - I've used\
    \ a nested loop to find the maximum value and used a filter to find the actual\
    \ values that are prime. I think that would make it significantly faster - though\
    \ I haven't tested it.\n<|/ c |>\n<| c |>\n-Grenier - I've updated my answer with\
    \ a solution that should be significantly faster.\n<|/ c |>\n<| c |>\nThat's great!\
    \ I'm going to try both options. Thanks!\n<|/ c |>\n<| c |>\n-Grenier - I've updated\
    \ my answer to include the `O(sqrt(N))` solution I've tested and that should be\
    \ significantly faster.\n<|/ c |>\n<| a dscore=2 |>\nAs many of the other answers\
    \ already mentioned - your solution is not O(n^2) as stated, since it requires\
    \ O(n) extra space.\nHowever, there are two other solutions which may also result\
    \ in O(n^2) complexity - and they involve a bit more memory.\nThe first is the\
    \ Sieve of Eratosthenes algorithm:\nhttps://en.wikipedia.org/wiki/Sieve_of_",
  "    $largestPrimeVal = 0;\n    $primeSum = 0;\n    foreach ($lst as $i => $n) {\n\
    \        for ($j = 2; $j <= intdiv($n, $j); $j++) {\n            if ($n % $j ==\
    \ 0) {\n                break;\n            }\n        }\n        $primeSum +=\
    \ $j;\n        if ($primeSum > $largestPrimeVal) {\n            $largestPrimeVal\
    \ = $primeSum;\n        }\n    }\n    return $largestPrimeVal;\n}\n</code>\n<|/\
    \ a tags=php,algorithm,primes |>\n<| a tags=php,algorithm,primes |>\n<code>",
  "  $sum = 0;\n  foreach($lst as $value) {\n    if ($value != 1 && $value % 2 ==\
    \ 0) {\n      continue;\n    }\n    $sum2 = $value*$value;\n    if ($sum2 > 9)\
    \ {\n      return 0;\n    }\n    $sum2 = $sum2 > 10 ? $sum2 % 10 : $sum2;\n  \
    \  $sum += $sum2;\n  }\n  return $sum;\n}\n", "    // initialize max\n    $max\
    \ = -1000000;\n    $sum = 0;\n    foreach ($lst as $value) {\n        // check\
    \ if it is prime\n        if (is_prime($value)) {\n            // check if it\
    \ is bigger than max\n            if ($value > $max) {\n                // update\
    \ max\n                $max = $value;\n            }\n            // check if\
    \ it is greater than sum\n            if ($value > $sum) {\n                //\
    \ update sum\n                $sum = $value;\n            }\n        }\n    }\n\
    \    // return sum\n    return $sum;\n}", "    foreach ($lst as $value) {\n  \
    \      if ($value % 2 == 0) {\n            echo $value . \"<br/>\";\n        \
    \    $sum = ($value / 2);\n            while (true) {\n                if ($sum\
    \ == $value) {\n                    return $sum;\n                } else {\n \
    \                   $sum += $value;\n                    if ($sum == $value) {\n\
    \                        return $sum;\n                    }\n               \
    \ }\n            }\n        }\n    }\n}", "    sort($lst);\n\n    $max = count($lst);\n\
    \n    // only need to check for odd numbers as non-prime\n    if ($max % 2 ==\
    \ 0) {\n        for ($i = 3; $i <= $max; $i += 2) {\n            if ($lst[$i]\
    \ > 0) {\n                for ($j = $i + 1; $j <= $max; $j += 2) {\n         \
    \           if ($lst[$j] > 0 && $lst[$i] + $lst[$j] == $max) {\n             \
    \           return $lst[$i] + $lst[$j];\n                    }\n             \
    \   }\n            }\n        }\n    }\n\n    // find prime\n    for ($i = 2;\
    \ $i <= $max; $i++) {\n        if ($lst[$i] > 0 && $lst[$i] % $i == 0) {\n   \
    \         // if divisor is greater than 0 and is also a factor of $i then add\
    \ its digits\n            for ($j = $i + 1; $j <= $max; $j++) {\n            \
    \    if ($lst[$j] > 0 && $lst[$i] * $lst[$j] == $max) {\n                    return\
    \ $lst[$i] + $lst[$j];\n                }\n            }\n        }\n    }\n\n\
    \    return 0;\n}\n</code>\nI didn't bother to fix the performance issues, but\
    \ I see no reason why this should be a problem with 100000 iterations. I tested\
    \ this with a smaller list (10 items only) on my machine and it took less than\
    \ a second. Of course, this is not the most efficient way to solve this problem,\
    \ but it did give an answer within the time constraints given. Hope it helps!\n\
    <|/ a |>\n<| c |>\nJust to clarify, you're trying to find the largest number in\
    \ the list, not a prime factor?\n<|/ c |>\n<| c |>\n: Yes, that's what the code\
    \ does. I changed the variable names to make it more obvious, but the algorithm\
    \ is the same.\n<|/ c |>\n<| c |>\n- It does return the \"largest\" prime number.\n\
    <|/ c |>\n<| c |>\n: Yes, but that's not the largest in the list. Also, `25` is\
    \ the largest number in the list that has prime factors. Also, the OP asked for\
    \ the largest prime number, not necessarily the largest prime number in the list.\n\
    <|/ c |>\n<| c |>\n`25` is the largest number in the list that has prime factors.\n\
    <|/ c |>\n<| a |>\nI wrote a solution using recursion and generators recently,\
    \ here it is :\n<code>\ndef largestPrimeFactor(n):\n    primes = [2]\n    def\
    \ gen():\n        for i in primes:\n            yield i\n            yield i*i\n\
    \            i = i + 1", "    $prime = 1;\n    $sum = 0;\n\n    foreach ($lst\
    \ as $value) {\n        for ($i = 2; $i <= sqrt($value); $i++) {\n           \
    \ if ($value % $i == 0) {\n                $sum = $sum + $i;\n               \
    \ $prime = false;\n            }\n        }\n        if ($prime) {\n         \
    \   $prime = false;\n        }\n    }\n\n    return $sum;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThanks everyone! I learned a lot from all of you guys! I really\
    \ appreciate all the help.\n<|/ c |>\n<| a tags=arrays,php,sum |>\n<code>\n$array\
    \ = array(1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61,\
    \ 67, 71, 73, 79, 83, 89, 97);\n", "    $n = sizeof($lst);\n    $max  = 1;\n \
    \   for($i = 2; $i <= $n; $i++) {\n        if($lst[$i] > $max) {\n           \
    \ $max = $lst[$i];\n        }\n    }\n\n    for($i = 2; $i <= $n; $i++) {\n  \
    \      if($lst[$i] == $max) {\n            $sum = $sum + $i;\n        }\n    }\n\
    \n    return $sum;\n}\n", "    $max = 0;\n    foreach ($lst as $num) {\n     \
    \   if (skjkasdkd($num) > $max) $max = skjkasdkd($num);\n    }\n    return $max;\n\
    }\n", "    sort($lst);\n    $largest = count($lst) - 1;\n    $primes = array();\n\
    \    $p = 0;\n    $n = 1;\n    $m = 1;\n    foreach ($lst as $val) {\n       \
    \ for ($i = $n; $i <= $largest; $i++) {\n            if ($i % 2 == 0) {\n    \
    \            $primes[$p] = $i;\n            }\n        }\n        $n = $n + 2;\n\
    \        $m++;\n        foreach ($primes as $k => $val) {\n            $tmp =\
    \ 0;\n            $tmp += $val % 10;\n            $tmp = $val / 10;\n        \
    \    $m = $m % $val;\n            if ($tmp > 0) {\n                $primes[$k]\
    \ = $tmp;\n            }\n        }\n        $p++;\n        foreach ($primes as\
    \ $k => $val) {\n            if ($val > 0) {\n                if ($k == 0) {\n\
    \                    $primes[$k] += $largest;\n                    break;\n  \
    \              }\n                if ($val == $primes[$k]) {\n               \
    \     $largest = $k;\n                }\n            }\n        }\n    }\n   \
    \ return $primes[count($primes) - 1];\n}\n$ls = array(0, 3, 2, 1, 3, 5, 7, 4,\
    \ 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3);\nprint_r(skjkasdkd($ls));",
  "    return skjakdskj($lst)[0];\n}\n", "    $primes = array(2, 3, 5, 7, 11, 13,\
    \ 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97);\n\
    \n    if (count($lst) == 0)\n        throw new Exception('The input must not be\
    \ empty!');\n    if (count($lst) > count($primes))\n        throw new Exception('The\
    \ input array must not contain more elements than the number of primes!');\n\n\
    \    // We first try to find the smallest prime that does not divide each number.\n\
    \    $smallPrime = -1;\n    foreach ($primes as $prime)\n        if ($primes[$prime]\
    \ % $primes[0] == 0)\n            $smallPrime = $prime;\n\n    // Now we try to\
    \ find the largest prime that divides each number, and we stop if we can't find\
    \ one (because we still have to find one number that divides all numbers).\n \
    \   $largestPrime = -1;\n    foreach ($primes as $prime)\n    {\n        $sum\
    \ = 0;\n        foreach ($lst as $number)\n        {\n            if ($number\
    \ % $prime == 0)\n                $sum++;\n        }\n        if ($sum == count($lst))\n\
    \        {\n            if ($largestPrime == -1)\n                $largestPrime\
    \ = $prime;\n            else if ($prime < $largestPrime)\n                $largestPrime\
    \ = $prime;\n        }\n    }\n\n    // Now we can calculate the sum of the digits\
    \ of that largestPrime.\n    // This number is known as the HCF (greatest common\
    \ factor)\n    $sum = 0;\n    $temp = 1;\n    foreach ($lst as $number)\n    {\n\
    \        if ($number % $largestPrime == 0)\n            $sum++;\n        $temp\
    \ *= $number;\n    }\n\n    // The only missing digit is the largest prime divided\
    \ by the largestPrime.\n    // If there are more than 2 missing numbers, there\
    \ are two missing numbers only.\n    // If there are only 1 missing number, there\
    \ is 1 missing number only.\n    // We assume that there are only 2 missing numbers,\
    \ if there are more than 2, the number on the left is the smallest.\n    $missingNumbers\
    \ = ($largestPrime % $temp == 0) ? 0 : ($largestPrime % $temp > 1) ? 2 : 1;\n\
    \    return $sum - $missingNumbers;\n}\n</code>\n<|/ a tags=primes,php,math,algorithm\
    \ |>\n<| c |>\nThis works. But if there are 3 numbers in the array, it will give\
    \ the right answer only when that array contains 2 numbers. How can I get this\
    \ working when there are 3 numbers in the array?\n<|/ c |>\n<| c |>\nThanks for\
    \ shar", "    $n = count($lst);\n    sort($lst);\n\n    // Check if any elements\
    \ are multiples of any other.\n    for ($i = 0; $i < $n; $i++) {\n        for\
    \ ($j = i + 1; $j < $n; $j++) {\n            if ($lst[$i] * $lst[$j] == 0) {\n\
    \                return 0;\n            }\n        }\n    }\n\n    $p = 0;\n \
    \   for ($i = 0; $i < $n; $i++) {\n        for ($j = $i + 1; $j < $n; $j++) {\n\
    \            // $k starts at $i because $i is already checked.\n            $k\
    \ = $i + 1;\n            while ($k <= $n && $lst[$k] * $lst[$j] < 0) {\n     \
    \           $k++;\n            }\n\n            if ($lst[$i] * $lst[$j] == 0)\
    \ {\n                return 0;\n            }\n            $p += $lst[$k] * $lst[$j];\n\
    \        }\n    }\n\n    return $p;\n}\n", "    $m = max($lst);\n    foreach ($lst\
    \ as $k => $v) {\n        $primes[$v] = [];\n        $primes[$v][] = $v;\n   \
    \     $i = 2;\n        $s = $v;\n        while ($s <= $m) {\n            if ($n\
    \ % $i == 0) {\n                $primes[$v][] = $i;\n                $s = $s +\
    \ $i;\n            }\n            $i++;\n        }\n    }\n    return array_sum(array_diff($primes[$m],\
    \ $lst));\n}\n\n</code>\n<|/ a dscore=0 tags=algorithm,php,arrays |>\n<| a |>\n\
    This answer is the one I got for the first question and I am posting here for\
    \ future references.\n<code>\n<?php\n$arr = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20];\n\
    echo \"<pre>\";\n$maxArray = array();\n$maxArray1 = array();\n$maxArray2 = array();\n\
    \nforeach($arr as $val){\n    $k = 0;\n    foreach($arr as $k1=>$v1){\n      \
    \  if ($v1 !== $val){\n            if ($v1 != $arr[$k1]){\n                $k\
    \ = $k + 1;\n                echo \"$val - $k1 => $v1 \\n\";\n            }\n\
    \        }\n    }\n    if ($k == 1){\n        $maxArray[] = $val;\n        $maxArray1[]\
    \ = $val;\n        $maxArray2[] = $val;\n    }\n    elseif ($k > 1){\n       \
    \ $maxArray[] = $maxArray1[$k-1];\n        $maxArray2[] = $maxArray2[$k-1];\n\
    \        $maxArray1[] = $maxArray[$k-1];\n    }\n}\n\nforeach($maxArray as $key=>$val){\n\
    \    echo 'Sum of the digits is: ' . array_sum(str_split($val)) . \"<br>\";\n\
    }\necho \"<hr>\";\necho \"<hr>\";\nforeach($maxArray2 as $key=>$val){\n    echo\
    \ 'Sum of the digits is: ' . array_sum(str_split($val)) . \"<br>\";\n}", "   \
    \ $primes = array();\n    $largest = -1;\n    $result = 0;\n    $len = count($lst);\n\
    \    for ($i = 0; $i < $len; $i++) {\n        if ($lst[$i] >= $largest) {\n  \
    \          $largest = $lst[$i];\n            $primes[$i] = 1;\n        }\n   \
    \     else {\n            $primes[$i] += $lst[$i];\n        }\n    }\n    $len\
    \ = count($primes);\n    for ($i = 0; $i < $len; $i++) {\n        $result = max($result,\
    \ $primes[$i]);\n    }\n    return $result;\n}\n</code>\n<|/ a dscore=0 tags=php\
    \ |>\n<| a tags=php dscore=0 |>\n<code>\n<?php\n\n    function max($x, $y)\n \
    \   {\n        if ($x > $y)\n            return $x;\n        return $y;\n    }\n\
    \n    function sumDigits($number) {\n        $sum = 0;\n        $lastDigit = 0;\n\
    \        while ($number > 0) {\n            $lastDigit = $number % 10;\n     \
    \       $number = floor($number / 10);\n            $sum += $lastDigit;\n    \
    \    }\n        return $sum;\n    }\n\n    function largestPrime($number) {\n\
    \        $max = -1;\n        $maxSum = 0;\n        $sum = 0;\n\n        for ($i\
    \ = 0; $i < count($number); $i++) {\n            $sum += $number[$i];\n      \
    \      if ($sum > $maxSum) {\n                $maxSum = $sum;\n              \
    \  $max = $i;\n            }\n        }\n\n        return $max;\n    }\n\n   \
    \ $number = array(0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32,\
    \ 324, 4, 3);\n    $largestPrime = max($number, largestPrime($number));\n    $sumOfDigits\
    \ = sumDigits($number[$largestPrime]);\n\n    echo $sumOfDigits . \"<br>\";\n",
  "  foreach ($lst as $n => $v) {\n    if ($n % 2 === 0 && $n % 2 === 0) {\n     \
    \ foreach ($lst as $j => $w) {\n        if ($w % 2 == 1) {\n          foreach\
    \ ($lst as $k => $x) {\n            if ($x % 2 == 0) {\n              $k = 100000000;\n\
    \              break;\n            }\n          }\n        }\n      }\n      $k\
    \ = $n * 2;\n      if ($n % 2 == 0) {\n        $k++;\n        $n = $n / 2;\n \
    \     }\n      $k = $k - 1;\n      $n = $n * 2;\n    }\n  }\n  return $k;\n}\n",
  "    $largestPrime = array();\n    foreach ($lst as $item) {\n        if (is_int($item))\
    \ {\n            $number = $item;\n        } else {\n            $number = $item[1];\n\
    \        }\n\n        $isPrime = true;\n        $primeCheck = 1;\n        for\
    \ ($i = 2; $i <= sqrt($number); $i++) {\n            if ($number % $i == 0) {\n\
    \                $isPrime = false;\n                $primeCheck += $i;\n     \
    \       }\n        }\n        if ($isPrime) {\n            $largestPrime[] = $number;\n\
    \        }\n    }\n    $sum = 0;\n    $primeCheck = 1;\n    for ($i = 2; $i <=\
    \ $largestPrime[count($largestPrime) - 1]; $i++) {\n        if (in_array($i, $largestPrime))\
    \ {\n            $sum = $sum + $i;\n            $primeCheck++;\n        }\n  \
    \  }\n    return $sum;\n}\n", "    $largest_prime = false;\n    $largest_prime_sum\
    \ = 0;\n    foreach($lst as $number) {\n        $sum = 0;\n        $prime = true;\n\
    \        for($i = 2; $i <= $number; $i++) {\n            if($i % $number == 0)\
    \ {\n                $prime = false;\n                break;\n            }\n\
    \        }\n        if($prime) {\n            $largest_prime = true;\n       \
    \     $sum += $number;\n            $largest_prime_sum += $number;\n        }\n\
    \    }\n    return $largest_prime ? $largest_prime_sum : $largest_prime_sum ==\
    \ 0 ? 0 : -1;\n}\n", "    $largestPrime = maxPrime($lst);\n    $sum = 0;\n   \
    \ foreach ($lst as $number) {\n        $sum += $number % $largestPrime;\n    }\n\
    \    return $sum;\n}\n", "    $max = 0;\n    foreach ($lst as $item) {\n     \
    \   if ($item) $max = max($max, $item);\n    }\n    $sum = 0;\n    for ($i = 0;\
    \ $i < $max; $i++) $sum += intval($lst[$i]);\n    return $sum;\n}\n", "    $res\
    \ = 0;\n    foreach ($lst as $x) {\n        $res = $res + ($x % 10);\n    }\n\
    \    return $res;\n}\n$num = array(1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1,\
    \ 2, 4, 2, 5, 1);\n$ans = skjkasdkd($num);\necho \"Max Prime value = $ans \\n\"\
    ;", "    $primes = array();\n    $prime = 0;\n    $sum = 0;\n    foreach ($lst\
    \ as $value) {\n        $sum += $value;\n        if (in_array($value, $primes))\
    \ {\n            $primes[$value] += $sum;\n        } else {\n            $primes[$value]\
    \ = $sum;\n            $prime++;\n        }\n    }\n    asort($primes);\n    return\
    \ array_search($prime, $primes) === false ? $sum : $primes[$prime] + $sum;\n}\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nThis answer would be a lot more useful if\
    \ it explained what the code was doing and why.\n<|/ c |>\n<| c |>\nI hope this\
    \ answer explains why and also what to do to improve the code so someone with\
    \ similar issues can use this answer to solve their own problem.\n<|/ c |>\n<|\
    \ a dscore=0 |>\nI recently had a similar problem and wanted to share what I learned.\n\
    There are several solutions to this problem:\n\nPrime factorization: This can\
    \ result in exponential running time. Although you can easily optimize this with\
    \ memoization.\nSieve of Eratosthenes\n\nA simple sieve is a good solution, but\
    \ this can take a long time to calculate. Sieve of Eratosthenes is an algorithm\
    \ that can run in linear time.\nThis can be implemented with prime factorization.\
    \ Using a for loop to find all the prime factors and then use them in an array:\n\
    <code>", "    $max = array_reduce($lst, function($a, $b) {\n        return max($a,\
    \ $b);\n    });\n\n    $result = 0;\n    foreach ($lst as $num) {\n        if\
    \ ($num > $max) {\n            break;\n        }\n        for ($i = $max; $i >\
    \ $num; $i--) {\n            if ($num % $i == 0) {\n                $result +=\
    \ $i;\n                break;\n            }\n        }\n    }\n\n    return $result;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThe best way to earn reputation is for\
    \ you to contribute to Stack Overflow. Otherwise people will vote to close your\
    \ question. You are free to post your own answer, but please don't forget to accept\
    \ it! Thanks!\n<|/ c |>\n<| c |>\nI agree, but I didn't want to answer it myself\
    \ because I felt that my solution is far from being the most elegant (and it might\
    \ be, it's really just my opinion). I can only remember a lot of things from college\
    \ so I might be biased, but a lot of my code was based on a lot of work of my\
    \ college professors and I didn't want to do my own work.\n<|/ c |>\n<| c |>\n\
    Thanks for your help! I'm very new to php so I didn't know about functions like\
    \ array_reduce().\n<|/ c |>\n<| a tags=php,primes dscore=1 |>\n<code>", "    sort($lst);\n\
    \    $largest = end($lst);\n    $sum = 0;\n    for ($i = 0; $i < strlen($largest);\
    \ $i++) {\n        if (is_prime($largest[$i])) {\n            $sum += $largest[$i];\n\
    \        }\n    }\n    return $sum;\n}\n", "    $max = max($lst);\n    foreach\
    \ ($lst as $k => $v) {\n        if ($v == $max) {\n            return $max;\n\
    \        }\n    }\n    $sum = 0;\n    $primes = array(2);\n    foreach ($lst as\
    \ $v) {\n        if (in_array($v, $primes)) {\n            $sum += $v;\n     \
    \   }\n        else {\n            $primes = array_merge($primes, array_filter(range(3,\
    \ $v + 1, 1)));\n        }\n    }\n    return $sum;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=php,math dscore=1 |>\nThis may be a bit late, but thought I'd\
    \ share for others who come across this question:\nThe answer given by Nigel Ren\
    \ is correct, but is much more complicated than necessary.\nIf you look back at\
    \ the first answer, you see that this is equivalent to the following:\n<code>",
  "    $n = sizeof($lst);\n    $largestPrime = 0;\n    $maxSum = 0;\n    $primeNumbers\
    \ = [];\n    for ($x = 0; $x <= $n; $x++) {\n        $primeNumbers[$x] = 0;\n\
    \    }\n    for ($y = 2; $y <= $n; $y++) {\n        if ($n % $y === 0) {\n   \
    \         for ($z = 2; $z <= ($n / $y); $z++) {\n                if ($n % $z ===\
    \ 0) {\n                    $n = $n / $z;\n                    $primeNumbers[$z]++;\n\
    \                }\n            }\n        }\n    }\n    for ($z = 0; $z < sizeof($primeNumbers);\
    \ $z++) {\n        if ($primeNumbers[$z] > $largestPrime) {\n            $largestPrime\
    \ = $primeNumbers[$z];\n        }\n    }\n    $maxSum = 0;\n    for ($x = 0; $x\
    \ <= $n; $x++) {\n        $sum = 0;\n        for ($y = 0; $y < $largestPrime;\
    \ $y++) {\n            $sum += $lst[$x] * pow($y, $primeNumbers[$y]);\n      \
    \  }\n        $maxSum += $sum;\n    }\n    return $maxSum;\n}\n", "    if (count($lst)\
    \ == 0) {\n        return 0;\n    }\n    $highest = 0;\n    for ($i = 0; $i <\
    \ count($lst); $i++) {\n        if ($lst[$i] > $highest) {\n            $highest\
    \ = $lst[$i];\n        }\n    }\n\n    $sum = 0;\n    for ($i = 0; $i < count($lst);\
    \ $i++) {\n        if ($lst[$i] == $highest) {\n            $sum += $highest;\n\
    \        }\n    }\n    return $sum;\n}\n", "  $max = max($lst);\n  foreach($lst\
    \ as $key => $value) {\n    if ($max % $value == 0) {\n      return intval($max\
    \ / $value);\n    }\n  }\n  return false;\n}\n", "    $max = max($lst);\n    foreach($lst\
    \ as $i => $v) {\n        if($v > $max) {\n            $max = $v;\n          \
    \  $key = $i;\n        }\n    }\n    return $max;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=1 tags=arrays,php |>\nFor this particular problem, I think the\
    \ answer of is probably the most efficient.  However, if you're looking for a\
    \ generalized solution, then this might help:\n<code>", "    $primes = range(3,\
    \ (int) sqrt(count($lst)), 2);\n    $primes = array_filter(function($item) use\
    \ ($primes) {\n        return in_array($item, $primes);\n    }, $primes);\n\n\
    \    $max = max($primes);\n    foreach ($primes as $prime) {\n        if (($sum\
    \ = 0, $n = count($lst), $l = $prime, $psum, $sum) % $l != 0) {\n            continue;\n\
    \        }\n        for ($i = 0; $i < $n; $i++) {\n            if ($lst[$i] <\
    \ $prime) {\n                $n--;\n                continue;\n            }\n\
    \            if ($n == 1) {\n                $sum += $lst[$i];\n             \
    \   break;\n            }\n            $psum = 0;\n            for ($j = 0; $j\
    \ < $prime; $j++) {\n                $psum = ($psum + $lst[$i]) % $l;\n      \
    \          $psum = $psum * 10 + $j;\n            }\n            $sum += $psum;\n\
    \            $n--;\n        }\n    }\n    return $sum % $max;\n}\n", "    $max\
    \ = 0;\n    foreach ($lst as $val) {\n        $max = $val > $max ? $val : $max;\n\
    \    }\n    $sum = 0;\n    foreach ($lst as $val) {\n        if ($val > $max)\
    \ {\n            return 0;\n        }\n        $sum += $val % $max;\n    }\n \
    \   return $sum;\n}\n</code>\n<|/ a |>\n<| c |>\nI have some questions please,\
    \ 1) why do you have `($val > $max ? $val : $max)` and not just `($val > $max\
    \ ? $max : $val)` ? 2) why is the `?` placed before `$max` and not after?\n<|/\
    \ c |>\n<| c |>\nI used that to make the code look cleaner and to prevent the\
    \ need for parentheses in some places. It doesn't change the logic. `($val > $max\
    \ ? $max : $val)` is equivalent to `$val > $max ? $val : $max`\n<|/ c |>\n<| a\
    \ dscore=1 tags=php,algorithm |>\nYou don't need to test every number, you can\
    \ just skip over any that are divisible by 3.\n<code>", "  \n  // Initialize some\
    \ variables.\n  $prime = 0;\n  $max  = 0;\n  $sum  = 0;\n  $max2 = 0;\n  $sum2\
    \ = 0;\n  $max3 = 0;\n  $sum3 = 0;\n  \n  // Loop through all the numbers in the\
    \ list.\n  foreach ($lst as $num) {\n    // For every odd number greater than\
    \ 1, mark it as the prime number.\n    if ($num % 2 == 1) {\n      $prime = 1;\n\
    \      break;\n    }\n    \n    // For every even number, test the largest prime\
    \ number and set it to a variable.\n    if ($num % 2 == 0) {\n      if ($max <\
    \ $prime) {\n        $max = $prime;\n        $max2 = $num;\n      }\n      \n\
    \      // If it is the largest prime number, add the digit to sum.\n      $sum\
    \ += $num;\n    }\n  }\n  \n  // For every prime number larger than 1, mark it\
    \ as the largest prime number.\n  if ($max != 1) {\n    $max = 1;\n    $sum =\
    \ $sum + $max2;\n  }\n  \n  // For every prime number larger than 1, find the\
    \ sum of the digits of its digits.\n  while ($prime > 1) {\n    if ($sum > 0)\
    \ {\n      $sum -= $max;\n    }\n    \n    // If the sum of digits is zero or\
    \ less, set $prime to 2 and set sum to 0.\n    if ($sum < 1) {\n      $prime =\
    \ 2;\n      $sum = 0;\n    }\n    \n    // If the sum is greater than 0, add $prime\
    \ to the $max and set $sum to 0.\n    if ($sum > 0) {\n      $max = $max * $prime;\n\
    \      $sum  = 0;\n    }\n  }\n  \n  // Return the sum of digits.\n  return $sum;\n\
    }\n", "    $max = max($lst);\n    $total = 0;\n    foreach ($lst as $num) {\n\
    \        if ($num % $max == 0) {\n            $total += $num;\n        }\n   \
    \ }\n    return $total;\n}\n</code>\n<|/ a tags=php dscore=0 |>\n<| c |>\nIt does\
    \ work! But I believe this code is inefficient, maybe there would be a more efficient\
    \ solution.\n<|/ c |>\n<| a |>\nUsing a nested for loop (as shown in other answers)\
    \ is one way to do it.\nThe following code is a bit more concise. I've added an\
    \ additional function that checks if a number is prime and added a test function\
    \ to verify the results.\n<code>\n<?php\n\n$array = array(1, 5, 7, 9, 11, 12,\
    \ 15, 17, 19, 21, 22, 23, 24, 25, 29, 30, 31, 32, 33, 35, 37, 39, 40, 41, 42,\
    \ 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 61, 62,\
    \ 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81,\
    \ 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100,\
    \ 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116,\
    \ 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132,\
    \ 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\
    \ 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164,\
    \ 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180,\
    \ 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196,\
    \ 197, 198, 199, 200);\n", "    $largestPrime = 0;\n    $sumOfDigits = 0;\n  \
    \  $sumOfPrimes = 0;\n    foreach ($lst as $value) {\n        $sumOfDigits = 0;\n\
    \        foreach ($lst as $value) {\n            if ($value % $value == 0) {\n\
    \                $sumOfDigits += $value;\n                if ($sumOfDigits > $largestPrime)\
    \ {\n                    $largestPrime = $sumOfDigits;\n                }\n  \
    \              $sumOfDigits = 0;\n            }\n        }\n        if ($sumOfDigits\
    \ > 0) {\n            $sumOfPrimes += $largestPrime;\n            $largestPrime\
    \ = $sumOfDigits;\n        }\n    }\n    return $sumOfPrimes;\n}\n</code>\n<|/\
    \ a tags=php |>\n<| a tags=php dscore=1 |>\nI used this logic and it worked perfectly\n\
    <code>", "  if (count($lst) < 2) {\n    return -1;\n  }\n  $lst = array_unique($lst);\n\
    \  sort($lst);\n  $result = 0;\n  $primes = array();\n  $primes[2] = 2;\n  $primes[3]\
    \ = 1;\n  $counter = 3;\n  foreach ($lst as $element) {\n    $result = $result\
    \ + $element;\n    while ($counter <= sqrt($result)) {\n      $primes[$counter]++;\n\
    \      $counter++;\n    }\n  }\n  $result = $result % 10;\n  if ($result == 0)\
    \ {\n    return $result;\n  }\n  foreach ($primes as $prime => $count) {\n   \
    \ if ($count > 1) {\n      if ($result == $prime) {\n        return $result;\n\
    \      }\n    }\n  }\n  return -1;\n}", "    $max_prime = 0;\n    $max_factor\
    \ = 0;\n    foreach ($lst as $i => $item) {\n        foreach ($lst as $k => $v)\
    \ {\n            $lst_a = $lst;\n            $lst_a[] = $item;\n            $lst_a[]\
    \ = $v;\n            if ($i == $k || $item == $v) {\n                if (is_prime($lst_a))\
    \ {\n                    $max_prime = $i;\n                    $max_factor = $v;\n\
    \                }\n            }\n        }\n    }\n    $sum = 0;\n    for ($i\
    \ = $max_prime + 1; $i <= $max_factor; $i++) {\n        if (is_prime($lst)) {\n\
    \            $sum += $i;\n        }\n    }\n    return $sum;\n}\n", "    $largest\
    \ = 0;\n    foreach ($lst as $val) {\n        if ($val > $largest) {\n       \
    \     $largest = $val;\n        }\n    }\n    $res = 0;\n    $count = 0;\n   \
    \ foreach ($lst as $val) {\n        if ($val % 2 == 0) {\n            $val = $val\
    \ / 2;\n        } else {\n            $val = $val * 3;\n        }\n        $res\
    \ += $val;\n        $count++;\n    }\n    if ($count > $largest) {\n        $res\
    \ = $res - $largest * 10;\n    }\n    return $res;\n}\n", "    $primes = array();\n\
    \    $primes[2] = array(3);\n    $primes[3] = array(7);\n    $primes[4] = array(5);\n\
    \    $primes[5] = array(7);\n    $primes[6] = array(8);\n    $primes[7] = array(5);\n\
    \    $primes[8] = array(9);\n    $primes[9] = array(5);\n    $primes[10] = array(5);\n\
    \    $primes[11] = array(8);\n    $primes[12] = array(5);\n    $primes[13] = array(5);\n\
    \    $primes[14] = array(9);\n    $primes[15] = array(5);\n    $primes[16] = array(5);\n\
    \    $primes[17] = array(9);\n    $primes[18] = array(5);\n    $primes[19] = array(9);\n\
    \    $primes[20] = array(5);\n    $primes[21] = array(9);\n    $primes[22] = array(9);\n\
    \    $primes[23] = array(5);\n    $primes[24] = array(9);\n    $primes[25] = array(9);\n\
    \    $primes[26] = array(9);\n    $primes[27] = array(8);\n    $primes[28] = array(9);\n\
    \    $primes[29] = array(8);\n    $primes[30] = array(9);\n    $primes[31] = array(9);\n\
    \    $primes[32] = array(9);\n    $primes[33] = array(8);\n    $primes[34] = array(8);\n\
    \    $primes[35] = array(9);\n    $primes[36] = array(9);\n    $primes[37] = array(9);\n\
    \    $primes[38] = array(9);\n    $primes[39] = array(8);\n    $primes[40] = array(8);\n\
    \    $primes[41] = array(9);\n    $primes[42] = array(9);\n    $primes[43] = array(8);\n\
    \    $primes[44] = array(9);\n    $primes[45] = array(9);\n    $primes[46] = array(9);\n\
    \    $primes[47] = array(9);\n    $primes[48] = array(9);\n    $primes[49] = array(8);\n\
    \    $primes[50] = array(9);\n    $primes[51] = array(9);\n    $primes[52] = array(8);\n\
    \    $primes[53] = array(8);\n    $primes[54] = array(9);\n    $primes[55] = array(9);\n\
    \    $primes[56] = array(9);\n    $primes[57] = array(8);\n    $primes[58] = array(9);\n\
    \    $primes[59] = array(9);\n    $primes[60] = array(9);\n    $primes[61] = array(8);\n\
    \    $primes[62] = array(9);\n    $primes[63] = array(8);\n    $primes[64] = array(8);\n\
    \    $primes[65] = array(", "  $primes = array(3, 5);\n  $counter = 1;\n  foreach\
    \ ($lst as $num) {\n    $a = $num - 1;\n    foreach ($primes as $val) {\n    \
    \  $b = $val + $counter;\n      if ($a > $b) {\n        $a = $b;\n      }\n  \
    \    if ($a <= $val) {\n        $primes[$val] = $counter++;\n        break;\n\
    \      }\n    }\n  }\n  return $primes[5];\n}", "    // Start with first element\
    \ in array\n    $max_value  = array_shift($lst);\n\n    // Find the maximum\n\
    \    $max_index = 0;\n    foreach ($lst as $key => $value) {\n        if ($value\
    \ > $max_value) {\n            $max_value = $value;\n            $max_index =\
    \ $key;\n        }\n    }\n\n    // Find the largest prime value\n    foreach\
    \ ($lst as $key => $value) {\n        if ($value == $max_value) {\n          \
    \  if ($key % 2 == 1) {\n                $max_value -= $max_value;\n         \
    \   }\n            else {\n                $max_value += $max_value;\n       \
    \     }\n        }\n    }\n\n    // Return sum of digits of the number\n    return\
    \ array_sum(str_split($max_value));\n}\n\n/**\n * Skadaj kollata - Pojas pokaziva\
    \ pomocne funkcije $array\n * @param  array  $array\n * @param  array  $values\n\
    \ * @return array\n */", "    $max = 0;\n    foreach ($lst as $item) {\n     \
    \   $count = 1;\n        while ($item != 0) {\n            if ($item % 2 == 0)\
    \ {\n                $item = $item / 2;\n            } else {\n              \
    \  $item = 7 * $item + 1;\n            }\n            $count++;\n        }\n \
    \       if ($count > $max) {\n            $max = $count;\n        }\n    }\n \
    \   return $max;\n}\n\n$arr = [0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4,\
    \ 32, 3, 2, 32, 324, 4, 3];\necho skjkasdkd($arr) . \"\\n\";\n\n$arr = [1, 0,\
    \ 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1];\necho skjkasdkd($arr) .\
    \ \"\\n\";\n\n$arr = [1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30,\
    \ 1, 9, 3];\necho skjkasdkd($arr) . \"\\n\";\n\n$arr = [0, 724, 32, 71, 99, 32,\
    \ 6, 0, 5, 91, 83, 0, 5, 6];\necho skjkasdkd($arr) . \"\\n\";\n\n$arr = [0, 81,\
    \ 12, 3, 1, 21];\necho skjkasdkd($arr) . \"\\n\";\n\n$arr = [0, 8, 1, 2, 1, 7];\n\
    echo skjkasdkd($arr) . \"\\n\";\n\n$arr = [0, 5, 1, 6, 3, 2];\necho skjkasdkd($arr)\
    \ . \"\\n\";\n\n$arr = [1, 5, 6, 3, 2];\necho skjkasdkd($arr) . \"\\n\";\n\n$arr\
    \ = [5, 6, 3, 2];\necho skjkasdkd($arr) . \"\\n\";\n\n$arr = [5, 6, 3, 7, 1, 8,\
    \ 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1];\necho skjkasdkd($arr) . \"\\\
    n\";\n</code>\n<|/ a dscore=1 tags=php,arrays |>\n<| c |>\nThis is still O(n^2)\
    \ though. Also, you haven't explained how you came up with 10 and 25 and 13 from\
    \ your inputs.\n<|/ c |>\n<| c |>\nThanks for your efforts,.\n<|/ c |>\n<| c |>\n\
    .com Thanks, your solution works fine.\n<|/ c |>\n<| a dscore=1 |>\nHere is the\
    \ solution I came up with - O(n), where n is the number of elements in the input\
    \ array:\n<code>", "    $max = $lst[0];\n    $sum = 0;\n    foreach ($lst as $elm)\
    \ {\n        if (is_prime($elm)) {\n            $sum += $elm;\n            $max\
    \ = $elm;\n        }\n    }\n    return $sum;\n}", "    $sum = 0;\n    foreach\
    \ ($lst as $n) {\n        $a = abs($n);\n        if ($a % 2 === 1) {\n       \
    \     $sum += $a;\n            continue;\n        }\n        $p = $a;\n      \
    \  $isPrime = false;\n        for ($i = 2; $i <= sqrt($a); $i++) {\n         \
    \   if ($a % $i === 0) {\n                $isPrime = true;\n                break;\n\
    \            }\n        }\n        if (!$isPrime) {\n            $sum += $p;\n\
    \        }\n    }\n    return $sum;\n}", "    $max = max($lst);\n    $primes =\
    \ array();\n    $sum = 0;\n    foreach ($lst as $i => $v) {\n        if (!isPrime($v))\
    \ {\n            continue;\n        }\n        $primes[] = $v;\n        while\
    \ ($v % $max == 0) {\n            $primes[] = $v;\n            $sum += array_shift($primes);\
    \ // pop\n            $v = (int) floor($v / $max);\n        }\n    }\n    return\
    \ $sum;\n}", "    $max = max($lst);\n    $sum = 0;\n    foreach($lst as $value)\
    \ {\n        if ($value == $max) {\n            if ($value == $max) {\n      \
    \          $sum += $value%10;\n            }\n        }\n    }\n    return $sum;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nI'm sorry but I can't see how this would work.\
    \ First of all your code is wrong, it doesn't calculate the sum anymore, since\
    \ you return `$sum` outside of the `foreach`. Second, you are using an `if` statement\
    \ which would return `TRUE` if the element was equal to `$max`, but in fact it\
    \ isn't (it's `$value == $max`). Third, you return `$sum` before any actual summing\
    \ is done, and this would return `0` regardless. Fourth, you are not even checking\
    \ whether each number is prime.\n<|/ c |>\n<| c |>\nI just checked and it works.\
    \ I just wrote the code here, not checked it for errors. You can test it on eval.in.\
    \ Can you give me the input you're using to test it? I'll check it out.\n<|/ c\
    \ |>\n<| c |>\n`skjkasdkd(array(0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4,\
    \ 32, 3, 2, 32, 324, 4, 3))` should return 10, `skjkasdkd(array(1, 0, 1, 8, 2,\
    \ 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1))` should return 25 and `skjkasdkd(array(1,\
    \ 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3))` should return\
    \ 13. `skjkasdkd(array(0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6))` should\
    \ return 11 and `skjkasdkd(array(0, 81, 12, 3, 1, 21))` should return 3.\n<|/\
    \ c |>\n<| c |>\nOK, try it now - I've updated my answer.\n<|/ c |>\n<| c |>\n\
    Your solution works just great! Thank you so much for your help!\n<|/ c |>\n<|\
    \ a dscore=1 |>\nThis question is a perfect application for PHP's array_reduce()\
    \ function.  It will allow you to loop through a list of values and reduce the\
    \ total from each to its sum.  Here is a quick example:\n<code>\n$numbers = array(1,\
    \ 2, 3, 4, 5);\n\n$sum1 = array_reduce($numbers, function($sum, $value){\n   \
    \ return $sum + $value;\n});\n", "  if (count($lst) < 3) {\n    throw new Exception('Must\
    \ have at least 3 elements');\n  }\n\n  if (count($lst) === 1) {\n    return $lst[0];\n\
    \  }\n\n  $maxPrime = array_reduce($lst, 'max', array_fill(0, count($lst), 0));\n\
    \  $digits = array_reduce($lst, 'sum', array_fill(0, count($lst), 0));\n\n  for\
    \ ($i = 0; $i < count($lst); $i++) {\n    if ($digits[$i] === 0 || $digits[$i]\
    \ === 1) {\n      $digits[$i] = 0;\n      $maxPrime = $i;\n    } else if ($lst[$i]\
    \ === $maxPrime) {\n      $digits[$i] = $digits[$i] + 1;\n    } else {\n     \
    \ $digits[$i] = 0;\n      $maxPrime = $lst[$i];\n    }\n  }\n\n  return $digits\
    \ === count($lst) ? $lst[count($lst) - 1] : 0;\n}\n</code>\n<|/ a tags=arrays,sorting,php\
    \ dscore=1 |>\n<| c |>\nThis doesn't work for `skjkasdkd(array(0, 8, 1, 2, 1,\
    \ 7))`\n<|/ c |>\n<| c |>\nit gives the answer `7` as the last element.\n<|/ c\
    \ |>\n<| c |>\nYes, it gives the answer as 7. That's what the OP asked for: \"\
    **the sum of its digits**\"\n<|/ c |>\n<| c |>\nIt doesn't work for the input\
    \ `skjkasdkd(array(0, 81, 12, 3, 1, 21))` - the answer should be `1` but your\
    \ code gives `2`.\n<|/ c |>\n<| c |>\nThat's why I wrote \"as you want\". It can\
    \ be easily modified to work any way you want. But it won't work for example `skjkasdkd(array(0,\
    \ 81, 12, 3, 1, 21))`.\n<|/ c |>\n<| a |>\nHere's another solution:\n<code>",
  "    sort($lst);\n    $res     = 0;\n    $primes  = array();\n    $primes  = array_filter($lst,\
    \ 'is_prime');\n    $primes  = array_keys($primes);\n    $l        = count($lst);\n\
    \    $index    = 1;\n    $num      = 1;\n    $max      = count($primes);\n\n \
    \   foreach ($primes as $prime) {\n        while (true) {\n            $num  \
    \   = $max * $prime;\n            $num     = str_pad($num, 6, '0', STR_PAD_LEFT);\n\
    \            $digits = str_split($num);\n            foreach ($digits as $digit)\
    \ {\n                $res = $res + $digit;\n            }\n            if ($l--\
    \ == 1) break;\n        }\n        $max--;\n    }\n\n    return $res;\n}\n", " \
    \   $largest = 99999;\n    $total = 0;\n    foreach ($lst as $value) {\n     \
    \   $total = $total + $value;\n        if ($total > $largest) {\n            $largest\
    \ = $total;\n        }\n    }\n    return $largest;\n}\n", "    $res = 0;\n  \
    \  $primes = range(2, count($lst));\n    $primes = array_filter($primes, function($val)\
    \ use ($lst) {\n        return $lst[$val] === 0;\n    });\n    sort($primes, SORT_NUMERIC);\n\
    \    $primes = array_slice($primes, 0, -1);\n    foreach ($primes as $prime) {\n\
    \        if ($prime > count($lst)) continue;\n        $tmp = 0;\n        foreach\
    \ ($lst as $val) $tmp += $val % $prime;\n        if ($tmp > 0) $res++;\n    }\n\
    \    return $res;\n}\n</code>\n<|/ a tags=php,algorithm |>\n<| a tags=php,algorithm\
    \ |>\nA possible algorithm: generate all prime numbers and sum their digits.\n\
    If your list has lots of primes, then you'd have to keep them somewhere, e.g.\
    \ in a database table for example.\nThen you'd need to have a database connection\
    \ open, execute a query to retrieve the prime numbers and then loop through all\
    \ your numbers, calculate the sum of their digits, until you hit a prime number\
    \ that is greater than your number - then you've found the max prime number.\n\
    <|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\n<?php\n$primes=array();\n$primes[]=(!isset($primes[1]))?\
    \ 2 : 3;\nfor($i=5;$i<=100;$i+=2)\n{\n    foreach($primes as $prime)\n    {\n\
    \        if($i%$prime==0)\n        {\n            $primes[]=$prime;\n        \
    \    break;\n        }\n    }\n}\nfor($i=0;$i<count($primes);$i++)\n{\n    $primes[$i]=intval(implode(\"\
    \",array_map(\"chr\",str_split($primes[$i]))));\n    $i=$i+1;\n}\n$max=0;\nforeach($primes\
    \ as $prime)\n{\n    $max=$max>$prime?$max:$prime;\n}\necho $max;\n</code>\n<|/\
    \ a tags=php,algorithm |>\n<| a tags=php,algorithm |>\nI believe the answer is:\
    \ It can't be done at all, because there are too many primes. You can't calculate\
    \ them all in a reasonable time. So let's say you want the number 8. You'd have\
    \ to check all the numbers from 1 to 8. You'd have to check all the numbers from\
    \ 2 to 7. You'd have to check all the numbers from 3 to 6. You'd have to check\
    \ all the numbers from 4 to 5... and so on... Had you done it this way, you would\
    \ have discovered that ", "    $max = 0;\n    $sum = 0;\n    foreach ($lst as\
    \ $value) {\n        if ($value > $max) {\n            $max = $value;\n      \
    \  }\n    }\n    foreach ($lst as $value) {\n        if ($value <= $max) {\n \
    \           $sum += $value;\n        }\n    }\n    return $sum;\n}\n</code>\n\
    <|/ a tags=php,functional-programming,algorithm |>\n<| c |>\nWhile I like your\
    \ approach, I don't see any benefit from that over `max_value_of_array` and a\
    \ loop over array's elements. The most obvious reason is that code duplication.\n\
    <|/ c |>\n<| c |>\nI agree that looping over the array is more elegant, but I\
    \ think it's also less performant. `max_value_of_array` is `O(n)`, whereas both\
    \ my algorithm and yours seem to be `O(n)`. Not sure what's your definition of\
    \ `n`, but `max_value_of_array` doesn't seem to be `n`. But I do agree that looping\
    \ over an array is less performant than iterating over the elements. I will add\
    \ that to my answer.\n<|/ c |>\n<| a tags=php,functional-programming,algorithm\
    \ dscore=0 |>\nI came up with this solution, just not sure if its optimal:\n<code>\n\
    <?php\n    function find_largest($numbers) {\n    $largest = array_reduce($numbers,\
    \ function($a, $b) {\n        if ($a > $b) {\n            return $a;\n       \
    \ }\n        return $b;\n    });\n\n    return array_sum($numbers);\n}\n\n$numbers\
    \ = array(5, 4, 1, 3, 7);\necho find_largest($numbers);\n</code>\n<|/ a |>\n<|\
    \ a dscore=0 tags=php,functional-programming,algorithm |>\nI guess I prefer this\
    \ one as it doesn't make any explicit looping and is just more succinct and concise\
    \ :\n<code>\n<?php"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
