name: HumanEval_58_common
language: php
prompt: "<?php\n// Return sorted unique common elements for two arrays.\n// >>> common(array(1,\
  \ 4, 3, 34, 653, 2, 5), array(5, 7, 1, 5, 9, 653, 121))\n// array(1, 5, 653)\n//\
  \ >>> common(array(5, 3, 2, 8), array(3, 2))\n// array(2, 3)\nfunction common($l1,\
  \ $l2) {\n"
tests: "function candidate(...$args) {\n    return common(...$args);\n}\n\nfunction\
  \ test(): void {\n    if (candidate(array(1, 4, 3, 34, 653, 2, 5), array(5, 7, 1,\
  \ 5, 9, 653, 121)) !== array(1, 5, 653)) { throw new Exception(\"Test failed!\"\
  ); }\n    if (candidate(array(5, 3, 2, 8), array(3, 2)) !== array(2, 3)) { throw\
  \ new Exception(\"Test failed!\"); }\n    if (candidate(array(4, 3, 2, 8), array(3,\
  \ 2, 4)) !== array(2, 3, 4)) { throw new Exception(\"Test failed!\"); }\n    if\
  \ (candidate(array(4, 3, 2, 8), array()) !== array()) { throw new Exception(\"Test\
  \ failed!\"); }\n}\n\ntest();"
completions: ["    // Sort the arrays to make the merge go simpler.\n    sort($l1);\n\
    \    sort($l2);\n\n    // Do the merge.\n    $i = $j = 0;\n    $ret = $l1[$i];\n\
    \    while ($i < count($l1) && $j < count($l2)) {\n        if ($l1[$i] == $l2[$j])\
    \ {\n            $i++;\n            $j++;\n        } else if ($l1[$i] > $l2[$j])\
    \ {\n            $ret = $l1[$i];\n            $i++;\n        } else {\n      \
    \      $ret = $l2[$j];\n            $j++;\n        }\n    }\n\n    return $ret;\n\
    }\n", "    return array_unique(array_intersect($l1, $l2));\n}\n</code>\n<|/ a\
    \ tags=php,arrays |>\n<| a |>\nYou can use the array_unique function\n<code>\n\
    $array = array(\n\"A\" => \"cat\",\n\"B\" => \"cat\",\n\"C\" => \"dog\",\n\"D\"\
    \ => \"fish\",\n\"E\" => \"fish\"\n);\n\n$array = array_unique($array);\n\nprint_r($array);\n\
    </code>\n<|/ a dscore=2 tags=php,arrays |>\n<| c |>\nIt won't work in the above\
    \ case. The question asks for two arrays to compare the common elements from,\
    \ so array_unique will fail because it will try to compare the elements of both\
    \ the arrays.\n<|/ c |>\n<| c |>\nActually, he didn't ask for two arrays, he said\
    \ to compare two arrays. I didn't say array_unique won't work with that, I said\
    \ the above won't work. I'm confused. Did you read it correctly?\n<|/ c |>\n<|\
    \ a dscore=1 |>\n<code>\n<?php\n\n$a1 = array(\n    array(\"A\"=>\"cat\", \"B\"\
    =>\"cat\", \"C\"=>\"dog\", \"D\"=>\"fish\", \"E\"=>\"fish\"),\n    array(\"F\"\
    =>\"cat\", \"G\"=>\"fish\", \"H\"=>\"fish\"),\n    array(\"A\"=>\"dog\", \"B\"\
    =>\"fish\", \"C\"=>\"dog\", \"D\"=>\"fish\", \"E\"=>\"fish\")\n    );\n$a2 = array(\"\
    A\"=>\"cat\", \"B\"=>\"cat\", \"C\"=>\"dog\", \"D\"=>\"fish\", \"E\"=>\"fish\"\
    );\nprint_r($a1);\nprint_r($a2);\n$a3 = array_intersect($a1, $a2);\nprint_r($a3);\n\
    </code>\noutput\n<code>\nArray\n(\n    [0] => Array\n        (\n            [A]\
    \ => cat\n            [B] => cat\n            [C] => dog\n            [D] => fish\n\
    \            [E] => fish\n        )\n\n    [1] => Array\n        (\n         \
    \   [F] => cat\n            [G] => fish\n            [H] => fish\n        )\n\n\
    \    [2] => Array\n        (\n            [A] => dog\n            [B] => fish\n\
    \            [C] => dog\n            [D] => fish\n            [E] => fish\n  \
    \      )\n\n)\nArray\n(\n    [A] => cat\n    [B] => cat\n    [C] => dog\n    [D]\
    \ => fish\n    [E] => fish\n)\nArray\n(\n    [A] => cat\n    [B] => cat\n    [C",
  "    sort($l1);\n    sort($l2);\n    $i = 0;\n    $ret = $l1;\n    while($i < count($l1)\
    \ && $i < count($l2)) {\n        if($l1[$i] == $l2[$i]) $ret[] = $l1[$i];\n  \
    \      $i++;\n    }\n    return $ret;\n}", "    $r1 = array_slice($l1, 0, max(count($l1),\
    \ count($l2)));\n    $r2 = array_slice($l2, 0, max(count($l1), count($l2)));\n\
    \    return array_intersect($r1, $r2);\n}", "  $a1 = array_slice($l1, 0, max(count($l1),\
    \ count($l2)));\n  $a2 = array_slice($l2, 0, max(count($l1), count($l2)));\n \
    \ foreach ($a2 as $k => $v) {\n    if ($v1[$k] === $v2[$k]) return $k;\n  }\n\
    \  return null;\n}\n", "  $common = array();\n  foreach ($l1 as $v1) {\n    foreach\
    \ ($l2 as $v2) {\n      if ($v1 == $v2) {\n        $common[] = $v1;\n      }\n\
    \    }\n  }\n  return $common;\n}\n", "    $common = array();\n    foreach ($l1\
    \ as $key => $value) {\n        if (in_array($value, $l2)) {\n            $common[]\
    \ = $value;\n        }\n    }\n    return $common;\n}\n", "    foreach ($l2 as\
    \ $item) {\n        if ( ! in_array($item, $l1)) { return $item; }\n    }\n  \
    \  return array();\n}", "  global $common;\n  $common = array();\n  $l1 = array_merge($l1);\n\
    \  $l2 = array_merge($l2);\n  foreach ($l1 as $key => $val) {\n    if (in_array($val,\
    \ $l2)) {\n      $common[] = $val;\n    }\n  }\n  return $common;\n}\n\n/**\n\
    \ * @see getCommon()\n */", "    $result = array();\n    foreach ($l1 as $elem1)\
    \ {\n        foreach ($l2 as $elem2) {\n            if ($elem1 == $elem2) {\n\
    \                $result[] = $elem1;\n                break;\n            }\n\
    \        }\n    }\n    return $result;\n}\n", "    foreach ($l1 as $k => $v) {\n\
    \        if (in_array($v, $l2)) {\n            $l2[$k] = $v;\n        }\n    }\n\
    \n    return $l2;\n}", "  $common = [];\n  $l1 = array_filter($l1);\n  $l2 = array_filter($l2);\n\
    \  foreach($l1 as $v) {\n    if(isset($l2[$v])) {\n      $common[] = $v;\n   \
    \ }\n  }\n  return $common;\n}", "    // First sort the arrays, putting values\
    \ in decreasing order\n    sort($l1);\n    sort($l2);\n\n    // Merge the two\
    \ arrays together, giving each the lowest common value\n    $cs = array();\n \
    \   foreach ($l1 as $i => $val) {\n        if (in_array($val, $l2, true)) {\n\
    \            $cs[] = $val;\n            unset($l1[$i]);\n        }\n    }\n  \
    \  $cs = array_merge($l1, $cs);\n    sort($cs);\n\n    return $cs;\n}\n", "  \
    \  if (!$l1 || !$l2) return array();\n    sort($l1);\n    sort($l2);\n    $result\
    \ = array();\n    while ($l1 && $l2) {\n        if ($l1[0] === $l2[0]) {\n   \
    \         $result[] = $l1[0];\n            array_shift($l1);\n            array_shift($l2);\n\
    \        } elseif ($l1[0] < $l2[0]) {\n            $result[] = $l1[0];\n     \
    \       array_shift($l1);\n        } else {\n            $result[] = $l2[0];\n\
    \            array_shift($l2);\n        }\n    }\n    return $result;\n}\n", " \
    \ // $l1 and $l2 should be sorted.\n  if (count($l1) != count($l2)) {\n    throw\
    \ new Exception('Elements should be sorted.');\n  }\n  $result = array();\n  $size\
    \ = count($l1);\n  for ($i = 0; $i < $size; ++$i) {\n    $result[$i] = $i;\n \
    \ }\n  for ($i = 0; $i < $size; ++$i) {\n    $j = 0;\n    while ($j < $size &&\
    \ $result[$i] == $l2[$j]) {\n      $j++;\n    }\n    $result[$i] = $j;\n  }\n\
    \  return $result;\n}\n", "    sort($l1);\n    sort($l2);\n    $count = count($l1);\n\
    \    $retval = array();\n    for ($i = 0; $i < $count; $i++) {\n        for ($j\
    \ = 0; $j < $count; $j++) {\n            if ($l1[$i] == $l2[$j]) {\n         \
    \       array_push($retval, $l1[$i]);\n            }\n        }\n    }\n    return\
    \ $retval;\n}\n", "    return array_intersect($l1, $l2);\n}\n", "    $len1 = count($l1);\n\
    \    $len2 = count($l2);\n    $common = array();\n    for ($i = 0; $i < $len1;\
    \ $i++) {\n        for ($j = 0; $j < $len2; $j++) {\n            if ($l1[$i] ==\
    \ $l2[$j]) {\n                $common[] = $l1[$i];\n            }\n        }\n\
    \    }\n    return $common;\n}\n", "\t$l1 = array_values($l1);\n\t$l2 = array_values($l2);\n\
    \t$n1 = sizeof($l1);\n\t$n2 = sizeof($l2);\n\n\t$common = array();\n\tfor ($i=0;\
    \ $i<$n1; $i++) {\n\t\tfor ($j=0; $j<$n2; $j++) {\n\t\t\tif ($l1[$i] == $l2[$j])\
    \ {\n\t\t\t\t$common[] = $l1[$i];\n\t\t\t\t$l1[$i] = false;\n\t\t\t\t$l1[$j] =\
    \ false;\n\t\t\t\t$l2[$j] = false;\n\t\t\t\t$n1 = $n1-1;\n\t\t\t\t$n2 = $n2-1;\n\
    \t\t\t}\n\t\t}\n\t}\n\tif ($n1 < $n2)\n\t\tcommon = array_slice($l1, $n1);\n\t\
    return $common;\n}", "    $common = array();\n    $l1 = array_keys($l1);\n   \
    \ $l2 = array_keys($l2);\n    sort($l1);\n    sort($l2);\n    foreach ($l1 as\
    \ $i1 => $v1) {\n        $i2 = array_search($v1, $l2);\n        if ($i2 !== false)\
    \ {\n            $common[] = $v1;\n            unset($l1[$i1]);\n            unset($l2[$i2]);\n\
    \        }\n    }\n    foreach ($l2 as $i2 => $v2) {\n        $i1 = array_search($v2,\
    \ $l1);\n        if ($i1 !== false) {\n            $common[] = $v2;\n        \
    \    unset($l1[$i2]);\n            unset($l2[$i1]);\n        }\n    }\n    return\
    \ array_values($common);\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nthis solution\
    \ is quite inefficient.\n<|/ c |>\n<| c |>\n: Of course it is. Because of all\
    \ the `array_keys` calls and sorting operations.\n<|/ c |>\n<| c |>\nthis does\
    \ not work correctly with duplicates. `common(array(1, 4, 3, 34, 653, 2, 5), array(5,\
    \ 7, 1, 5, 9, 653, 121))` returns `array(1, 5)` where it should return `array(1,\
    \ 5, 653)`\n<|/ c |>\n<| c |>\n: This was a bug in the last version of the code.\
    \ Fixed it.\n<|/ c |>\n<| a tags=php,arrays |>\n<code>", "    $common = array();\n\
    \    foreach($l1 as $v) {\n        foreach($l2 as $v2)\n            if ($v ===\
    \ $v2)\n                $common[] = $v;\n    }\n    return $common;\n}\n", " \
    \   if (count($l1) != count($l2)) {\n        throw new Exception('Cannot get common\
    \ elements. Array sizes are different.');\n    }\n    $i1 = 0;\n    $i2 = count($l1)\
    \ - 1;\n    $common = array();\n    while (true) {\n        while ($i1 < $i2)\
    \ {\n            if ($l1[$i1] == $l2[$i2]) {\n                $common[] = $l1[$i1];\n\
    \                $i1++;\n                $i2--;\n                continue;\n \
    \           }\n            if ($l1[$i1] < $l2[$i2]) {\n                break;\n\
    \            }\n            $i2--;\n        }\n        while ($i1 > $i2) {\n \
    \           if ($l1[$i1] == $l2[$i2]) {\n                $common[] = $l1[$i1];\n\
    \                $i1--;\n                $i2++;\n                continue;\n \
    \           }\n            if ($l1[$i1] > $l2[$i2]) {\n                break;\n\
    \            }\n            $i2++;\n        }\n        if ($i1 == $i2) {\n   \
    \         return $common;\n        }\n    }\n}\n", "  $u = $l1;\n  usort($l2,\
    \ 'strnatcmp');\n  $u2 = $l2;\n  usort($u2, 'strnatcmp');\n  $j = 0;\n  while\
    \ ($j < count($u) && $j < count($u2)) {\n    if ($u[$j] == $u2[$j]) {\n      ++$j;\n\
    \      continue;\n    }\n    if ($u[$j] > $u2[$j]) {\n      return $u;\n    }\n\
    \    return $u2;\n  }\n  return $u;\n}\n\n/**\n * Helper function for building\
    \ HTML attribute strings. Requires the input\n * be in the form of array($key,\
    \ $value, $escape).\n */", "\t$l1 = array_keys($l1);\n\t$l2 = array_keys($l2);\n\
    \t$l1 = array_slice($l1, 0, count($l1));\n\t$l2 = array_slice($l2, 0, count($l2));\n\
    \t$c = array_intersect($l1, $l2);\n\t$c = array_values($c);\n\tsort($c);\n\treturn\
    \ $c;\n}", "    $common = array();\n    foreach ($l1 as $k => $v) {\n        if\
    \ (in_array($v, $l2)) {\n            $common[] = $v;\n        }\n    }\n    return\
    \ $common;\n}\n", "    $a = array_diff($l1, $l2);\n    $b = array_diff($l2, $l1);\n\
    \    return array_intersect($a, $b) ? $a : array_diff($b, $a);\n}", "    return\
    \ sort(array_unique(array_merge(array_keys($l1), array_keys($l2))), SORT_NUMERIC);\n\
    }\n", "  // Add first element of $l1 if it doesn't exist.\n  if (!isset($l1[0]))\
    \ {\n    $l1 = array($l1);\n  }\n  // Add first element of $l2 if it doesn't exist.\n\
    \  if (!isset($l2[0])) {\n    $l2 = array($l2);\n  }\n\n  // Sort arrays.\n  sort($l1,\
    \ SORT_NUMERIC);\n  sort($l2, SORT_NUMERIC);\n\n  // Find intersection.\n  $i=0;\n\
    \  $j=0;\n  $k=0;\n  while($i < count($l1) && $j < count($l2)) {\n    if ($l1[$i]\
    \ == $l2[$j]) {\n      $i++;\n      $j++;\n    } else if ($l1[$i] < $l2[$j]) {\n\
    \      $k++;\n    } else {\n      $k++;\n    }\n  }\n\n  // Return sorted unique\
    \ elements.\n  return array_unique(array_slice($l1, $i));\n}", "    $common =\
    \ array();\n    $i1 = 0;\n    $i2 = count($l1) - 1;\n    while ($i1 < $i2) {\n\
    \        $k1    = $i2 + 1;\n        $k2    = $i2 + 1;\n        while ($k1 < $i1\
    \ && $k1 < $i2) {\n            if ($l1[$i1] === $l2[$k1]) {\n                $common[]\
    \ = $l1[$i1];\n                $i1++;\n                $k1++;\n            } else\
    \ {\n                $k2 = $i2 + 1;\n            }\n        }\n        $i2 = $k1\
    \ - 1;\n    }\n    return $common;\n}", "    if ($l1 == $l2) {\n        return\
    \ $l1;\n    }\n    $result = [];\n    foreach ($l1 as $e) {\n        if (in_array($e,\
    \ $l2)) {\n            $result[] = $e;\n        }\n    }\n    return $result;\n\
    }", "\tsort($l1);\n\tsort($l2);\n\n\t$i = 0;\n\twhile(isset($l1[$i]) && isset($l2[$i]))\
    \ {\n\t\tif ($l1[$i] == $l2[$i]) {\n\t\t\t$i++;\n\t\t} else {\n\t\t\tunset($l1[$i]);\n\
    \t\t\tunset($l2[$i]);\n\t\t}\n\t}\n\tif (isset($l1[0])) {\n\t\treturn array_merge($l1,\
    \ $l2);\n\t} else {\n\t\treturn $l2;\n\t}\n}\n", "  $a = array_slice($l1, 0, min(count($l1),\
    \ count($l2)));\n  $b = array_slice($l2, 0, min(count($l1), count($l2)));\n  return\
    \ array_intersect($a, $b);\n}\n", "    return array_unique(array_filter(array_merge(\n\
    \        array_keys($l1),\n        array_keys($l2)\n    )));\n}\n</code>\n<|/\
    \ a dscore=2 |>\n<| a tags=php,sorting,arrays dscore=2 |>\nAnother approach without\
    \ looping or recursion.\n<code>", "  $common = array();\n  $count = count($l1);\n\
    \  for ($i = 0; $i < $count; $i++) {\n    $found = FALSE;\n    foreach ($l2 as\
    \ $l2) {\n      if ($l1[$i] == $l2) {\n        $found = TRUE;\n        break;\n\
    \      }\n    }\n    if ($found == FALSE) {\n      $common[] = $l1[$i];\n    }\n\
    \  }\n  return $common;\n}\n", "    $result = array();\n    foreach ($l1 as $key\
    \ => $value) {\n        if (array_key_exists($value, $l2)) {\n            $result[$value]\
    \ = $key;\n        }\n    }\n    return $result;\n}", "    // Sort the arrays\
    \ first. \n    if (!is_array($l1) || !is_array($l2)) {\n        throw new InvalidArgumentException(\"\
    Arrays must be sorted first!\");\n    }\n    uasort($l1, static function ($a,\
    \ $b) use ($l2) {\n        return strnatcmp($b, $a);\n    });\n    uasort($l2,\
    \ static function ($a, $b) use ($l1) {\n        return strnatcmp($a, $b);\n  \
    \  });\n    $common = array();\n    foreach ($l1 as $key => $value) {\n      \
    \  if (in_array($value, $l2)) {\n            $common[$key] = $value;\n       \
    \     unset($l2[$key]);\n        }\n    }\n    foreach ($l2 as $key => $value)\
    \ {\n        if (in_array($value, $l1)) {\n            $common[$key] = $value;\n\
    \            unset($l1[$key]);\n        }\n    }\n    return $common;\n}\n", " \
    \   $result = [];\n    foreach ($l1 as $key => $value) {\n        if (in_array($value,\
    \ $l2)) {\n            $result[] = $value;\n        }\n    }\n    return $result;\n\
    }\n", "    $set = array_merge($l1, $l2);\n    sort($set);\n    return array_unique($set);\n\
    }\n", "    return array_intersect($l1, $l2);\n}\n", "  $a1 = [];\n  $a2 = [];\n\
    \  $i1 = 0; $i2 = 0;\n  while (count($l1) > 0 && count($l2) > 0) {\n    // find\
    \ common element\n    $x = $l1[$i1];\n    if (in_array($x, $l2)) {\n      $a1[$i1]\
    \ = $x;\n      $l1[$i1] = null;\n    } else {\n      $a1[$i1] = null;\n    }\n\
    \    $i2++;\n  }\n  while (count($l1) > 0) {\n    $a1[$i1] = $l1[$i1];\n    $i1++;\n\
    \  }\n  while (count($l2) > 0) {\n    $a2[$i2] = $l1[$i2];\n    $i2++;\n  }\n\
    \  return array_values(array_filter(array_merge($a1, $a2), 'is_int'));\n}\n",
  "    if ($l1 == $l2) {\n        return $l1;\n    }\n    $l1 = array_reverse($l1);\n\
    \    $l2 = array_reverse($l2);\n    foreach ($l1 as $k => $v1) {\n        if (in_array($v1,\
    \ $l2)) {\n            $l1[$k] = $v1;\n            unset($l2[$k]);\n        }\n\
    \    }\n    foreach ($l2 as $k => $v2) {\n        if (in_array($v2, $l1)) {\n\
    \            unset($l1[$k]);\n        }\n    }\n    return array_values($l1);\n\
    }", "    $s1 = array_keys($l1);\n    $s2 = array_keys($l2);\n    $s1[array_search($l1,\
    \ $s1)] = $s1[array_search($l2, $s1)];\n    return $s1;\n}\n</code>\n<|/ a |>\n\
    <| a tags=php,arrays,search dscore=1 |>\nThis is a great solution which I took\
    \ and used (with some modification) to solve a problem I was having, and is now\
    \ part of my library. No clue where I found it, and I can't find a way to contact\
    \ the author to report a bug, so if you come across this and need help, you can\
    \ contact me on Github.\n<code>\n<?php\n/**\n * Given two arrays of values, return\
    \ an array containing the unique entries of\n * the two arrays.\n * \n * array\n\
    \ *   $values1\n * array\n *   $values2\n * array\n */", "    $common = array();\n\
    \    $size = max(count($l1), count($l2));\n    for($i = 0; $i < $size; $i++) {\n\
    \        if ($l1[$i] != $l2[$i]) {\n            $common[] = $l1[$i];\n       \
    \ }\n    }\n    return $common;\n}\n", "\tforeach ($l1 as $key => $value) {\n\t\
    \tif (in_array($value, $l2, true)) {\n\t\t\tunset($l1[$key]);\n\t\t}\n\t}\n\t\
    return array_values($l1);\n}\n\n/**\n * Converts a multi-dimensional array into\
    \ an array of arrays, recursively.\n *\n * @param array $array Array to flatten.\n\
    \ * @return array Flattened array.\n */", "    sort($l1);\n    sort($l2);\n\n\
    \    $n1 = count($l1);\n    $n2 = count($l2);\n\n    for ($i = 0; $i < $n1 &&\
    \ $i < $n2; $i++) {\n        if ($l1[$i] == $l2[$i]) {\n            $l1[$i] =\
    \ $l1[$n1 - 1]; // overwrite element of first array\n            $l1[$n1 - 1]\
    \ = NULL;\n            $l1[--$n1] = NULL; // remove last element of second array\n\
    \            $l2[$i] = $l2[$n2 - 1];\n            $l2[$n2 - 1] = NULL;\n     \
    \       $l2[$--$n2] = NULL;\n        }\n    }\n\n    // return array with common\
    \ elements\n    return array_unique(array_merge($l1, $l2));\n}\n", "    $common\
    \ = array();\n    foreach ($l1 as $key) {\n        if (array_key_exists($key,\
    \ $l2)) {\n            $common[] = $key;\n        }\n    }\n    return $common;\n\
    }\n", "  $out = array();\n  $common = array_intersect($l1, $l2);\n  foreach($l1\
    \ as $i) {\n    if (in_array($i, $common)) continue;\n    else $out[] = $i;\n\
    \  }\n  foreach($l2 as $i) {\n    if (in_array($i, $common)) continue;\n    else\
    \ $out[] = $i;\n  }\n  return $out;\n}", "    $common = array();\n\n    foreach\
    \ ($l1 as $element) {\n        if (in_array($element, $l2)) {\n            $common[]\
    \ = $element;\n        }\n    }\n    return $common;\n}", "  return array_filter(\n\
    \    $l1,\n    function($v) use ($l2) {\n      return in_array($v, $l2);\n   \
    \ },\n    ARRAY_FILTER_USE_BOTH\n  );\n}\n", "  if (is_array($l1) && is_array($l2))\
    \ {\n    return array_intersect($l1, $l2);\n  }\n  return array();\n}\n", "  \
    \  $r1 = array_unique($l1);\n    $r2 = array_unique($l2);\n    $resultArray =\
    \ array();\n    foreach ($r1 as $val) {\n        if (in_array($val, $r2)) {\n\
    \            $resultArray[] = $val;\n        }\n    }\n    return $resultArray;\n\
    }\n", "    if (count($l1) < count($l2)) {\n        return $l1;\n    }\n    if\
    \ (count($l1) > count($l2)) {\n        return $l2;\n    }\n    $result = array();\n\
    \    foreach ($l1 as $key => $value) {\n        if (!isset($l2[$key])) {\n   \
    \         $result[$key] = $value;\n            continue;\n        }\n        $result[$key]\
    \ = $l2[$key];\n    }\n    return $result;\n}\n", "  $result = array();\n  sort($l1);\n\
    \  sort($l2);\n  $count = max(count($l1), count($l2));\n  for ($i = 0; $i < $count;\
    \ $i++) {\n    if ($l1[$i] == $l2[$i]) {\n      $result[] = $l1[$i];\n    }\n\
    \  }\n  return $result;\n}\n", "    return array_intersect($l1, $l2);\n}\n", " \
    \   $common = array();\n    foreach ($l1 as $item) {\n        if (in_array($item,\
    \ $l2)) {\n            $common[] = $item;\n        }\n    }\n    return $common;\n\
    }\n", "    return array_intersect($l1, $l2);\n}", "    $ret = [];\n    foreach\
    \ ($l1 as $k1 => $v1) {\n        if (!isset($l2[$k1])) {\n            $ret[] =\
    \ $v1;\n            continue;\n        }\n        foreach ($l2 as $k2 => $v2)\
    \ {\n            if ($v1 == $v2) {\n                continue 2;\n            }\n\
    \            if ($v1 < $v2) {\n                break;\n            }\n       \
    \ }\n        $ret[] = $v1;\n    }\n    return $ret;\n}\n</code>\n<|/ a |>\n<|\
    \ c |>\nThe first `foreach` loop is iterating over the first array (`$l1`). The\
    \ second `foreach` loop is iterating over the second array (`$l2`). The second\
    \ `foreach` loop is iterating over all elements of both arrays. So the `$v2` variable\
    \ will always be the second element of `$l2`. That is why the second `foreach`\
    \ loop needs the conditional break.\n<|/ c |>\n<| c |>\nI think you are missing\
    \ the point of the question. If $l1 and $l2 are of the same size, this loop can\
    \ be executed a constant number of times. So there is no reason to compare two\
    \ arrays. Though your answer does provide the unique common elements for two arrays,\
    \ but the elements are not necessarily in the same order.\n<|/ c |>\n<| c |>\n\
    Thanks, I see it now. I missed that part with the $v1 < $v2 conditional. I need\
    \ to brush up on my `break`s. I guess the main reason why your answer works is\
    \ because of the `continue` and the `$v1` < `$v2` conditional.\n<|/ c |>\n<| a\
    \ dscore=0 tags=arrays,php,loops |>\nJust in case it helps, here's my take on\
    \ it using a variable to store the minimum value found and the current index.\n\
    <code>\n$array1 = [1 => 4, 3 => 5, 4 => 6, 5 => 7, 6 => 8, 7 => 9];\n$array2 =\
    \ [1 => 5, 2 => 6, 3 => 7, 4 => 8, 5 => 9, 6 => 10];\n\n$result = [];\n$min =\
    \ null;\n$index = 0;\n\nforeach ($array1 as $key => $value) {\n    if (isset($array2[$key])\
    \ && $array2[$key] < $value) {\n        if (!isset($min) || $min > $value) {\n\
    \            $min = $value;\n            $index = $key;\n        }\n    }\n}\n\
    \nif (isset($min)) {\n    $result[$index] = $min;\n}\n\nprint_r($result);\n</code>\n\
    <|/ a |>\n<| c |>", "    return sort($l1) === sort($l2) ? $l1 : $l2;\n}", "  \
    \  if ($l1 == $l2) {\n        return $l1;\n    }\n    if (count($l1) != count($l2))\
    \ {\n        return array();\n    }\n\n    $common = array_intersect($l1, $l2);\n\
    \    if (count($common) == count($l1)) {\n        return $common;\n    }\n\n \
    \   return array_diff($l2, $common);\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=arrays,php\
    \ |>\nTry this (PHP >= 5.3.0):\n<code>\n$array = array(\n    array(\n        \"\
    id\" => 1,\n        \"name\" => \"Blah\",\n        \"status\" => 1\n    ),\n \
    \   array(\n        \"id\" => 2,\n        \"name\" => \"Hallo\",\n        \"status\"\
    \ => 1\n    )\n);\n\n$array2 = array(\n    array(\n        \"id\" => 1,\n    \
    \    \"name\" => \"Blah\",\n        \"status\" => 1\n    ),\n    array(\n    \
    \    \"id\" => 2,\n        \"name\" => \"Hallo\",\n        \"status\" => 1\n \
    \   ),\n    array(\n        \"id\" => 3,\n        \"name\" => \"Hello\",\n   \
    \     \"status\" => 1\n    ),\n    array(\n        \"id\" => 4,\n        \"name\"\
    \ => \"Hallo\",\n        \"status\" => 0\n    )\n);\n\nprint_r(array_merge($array,\
    \ array_diff($array2, $array)));\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI did this\
    \ but array_diff is giving me a blank array\n<|/ c |>\n<| c |>\nAh, I forgot to\
    \ add that I had to make sure that all arrays were the same size otherwise it\
    \ would give a blank.\n<|/ c |>\n<| a dscore=0 |>\nHow about this?\n<code>\n$merge\
    \ = array_merge($array1,$array2);\n$diff = array_diff($array1, $merge);\n</code>\n\
    <|/ a tags=arrays,php |>\n<| c |>\nThis doesn't work if array2 is smaller than\
    \ array1.\n<|/ c |>\n<| c |>\n: It was a typo, now fixed.\n<|/ c |>\n<| c |>\n\
    This answer does not answer the question, which states that array2 is smaller\
    \ than array1. In your example, array2 has two additional elements, but the OP\
    \ wants the result to have only those elements that appear in both arrays.\n<|/\
    \ c |>\n<| a tags=arrays,php |>\nTry this :\n<code>\n$new = array_unique(array_merge($",
  "    $common = array();\n\n    foreach($l1 as $key => $value) {\n        if(in_array($value,\
    \ $l2)) {\n            $common[] = $value;\n        }\n    }\n\n    foreach($l2\
    \ as $key => $value) {\n        if(in_array($value, $l1)) {\n            $common[]\
    \ = $value;\n        }\n    }\n\n    return $common;\n}", "  $common = array();\n\
    \  foreach ($l1 as $key => $value) {\n    if (isset($l2[$key]) && $l2[$key] ==\
    \ $value) {\n      $common[] = $key;\n    }\n  }\n  return $common;\n}\n", " \
    \ return array_uintersect($l1, $l2, 'array_uintersect');\n}\n\n/**\n * Given an\
    \ array, sort the array by the values using a user-supplied callback.\n *\n *\
    \ @param array       $arr\n * @param callable    $callback\n * @param string|null\
    \ $sort_key_callback\n *\n * @return array\n */", "    $l1 = array_unique($l1);\n\
    \    $l2 = array_unique($l2);\n    if (count($l1) < count($l2)) {\n        //\
    \ More elements in l1 than in l2, return l2.\n        return $l2;\n    }\n   \
    \ if (count($l1) > count($l2)) {\n        // More elements in l2 than in l1, return\
    \ l1.\n        return $l1;\n    }\n    // Both arrays have the same number of\
    \ elements.\n    $result = array();\n    $j = 0;\n    for ($i = 0; $i < count($l1);\
    \ $i++) {\n        while (in_array($l1[$i], $l2) && ($j < count($l2) || (!isset($l2[$j]))))\
    \ {\n            $result[] = $l1[$i];\n            $j++;\n        }\n        while\
    \ (in_array($l2[$i], $l1) && ($j < count($l1) || (!isset($l1[$j])))) {\n     \
    \       $result[] = $l2[$i];\n            $j++;\n        }\n    }\n    return\
    \ $result;\n}\n</code>\nThe two loops are used just to make sure that the final\
    \ array is sorted (no duplicates) and that there are no duplicates.\n<|/ a tags=arrays,php,sorting\
    \ |>\n<| c |>\nThe `common` function should use `return array_merge($l1, $l2);`\
    \ rather than `return $l2;` in order to preserve duplicates.\n<|/ c |>\n<| c |>\n\
    Thanks for pointing that out. I made a test case where the common elements were\
    \ in different order. I don't know if that is allowed in my particular use case.\
    \ I've updated my answer accordingly. Thanks for pointing it out!\n<|/ c |>\n\
    <| a |>\nThe PHP function array_intersect() does exactly what you need. It returns\
    \ an array of common elements. \nhttp://us3.php.net/manual/en/function.array-intersect.php\n\
    <|/ a dscore=4 tags=arrays,php,sorting |>\n<| c |>\nFor a complete answer, please\
    \ provide an example with 2 arrays.\n<|/ c |>\n<| a tags=arrays,php,sorting dscore=4\
    \ |>\nFor large arrays, the accepted answer takes much longer than the below solution.\n\
    <code>", "\t$l1 = array_filter($l1, function($e){return !($e instanceof Traversable);});\n\
    \t$l2 = array_filter($l2, function($e){return !($e instanceof Traversable);});\n\
    \t$l1 = array_diff($l1, $l2);\n\treturn array_filter($l1);\n}\n/*\n * Recursively\
    \ sort and merge arrays by key (useful for array_merge_recursive).\n * Original\
    \ array is untouched, new array contains values (no keys) sorted ascending.\n\
    \ * Sorting can be done in-place by using $l1[$k] = $v1; instead of $l1[$k] =\
    \ $v1;.\n * Original array is also untouched, new array contains values (no keys)\
    \ sorted ascending.\n * Sorting can be done in-place by using $l1[$k] = $v1; instead\
    \ of $l1[$k] = $v1;.\n * Original array is also untouched, new array contains\
    \ values (no keys) sorted ascending.\n * Sorting can be done in-place by using\
    \ $l1[$k] = $v1; instead of $l1[$k] = $v1;.\n * Original array is untouched, new\
    \ array contains values (no keys) sorted ascending.\n * Sorting can be done in-place\
    \ by using $l1[$k] = $v1; instead of $l1[$k] = $v1;.\n * Original array is untouched,\
    \ new array contains values (no keys) sorted ascending.\n * Sorting can be done\
    \ in-place by using $l1[$k] = $v1; instead of $l1[$k] = $v1;.\n * Original array\
    \ is untouched, new array contains values (no keys) sorted ascending.\n * Sorting\
    \ can be done in-place by using $l1[$k] = $v1; instead of $l1[$k] = $v1;.\n */",
  "\t$a = array_diff($l1, $l2);\n\t$b = array_diff($l2, $l1);\n\t$c = array_intersect($l1,\
    \ $l2);\n\t$d = array_intersect($l2, $l1);\n\t$e = array_intersect($a, $b);\n\t\
    $f = array_intersect($b, $a);\n\t$g = array_intersect($c, $d);\n\t$h = array_intersect($d,\
    \ $c);\n\t$i = array_intersect($e, $f);\n\t$j = array_intersect($f, $e);\n\t$k\
    \ = array_intersect($g, $h);\n\t$l = array_intersect($h, $g);\n\treturn array_merge($a,\
    \ $b, $c, $d, $e, $f, $g, $h, $i, $j, $k, $l);\n}\n", "    return array_intersect($l1,\
    \ $l2);\n}\n", "    $r1 = array_unique($l1);\n    $r2 = array_unique($l2);\n\n\
    \    $count = count($r1);\n    for ($i = 0; $i < $count; $i++) {\n        $matches\
    \ = false;\n        for ($j = 0; $j < $count; $j++) {\n            if ($r1[$i]\
    \ === $r2[$j]) {\n                $matches = true;\n            }\n        }\n\
    \        if (!$matches) {\n            return $r1[$i];\n        }\n    }\n\n \
    \   return $r1[$count];\n}\n", "    foreach ($l1 as $k1 => $v1) {\n        if\
    \ (!isset($l2[$k1])) {\n            return false;\n        }\n        foreach\
    \ ($l2 as $k2 => $v2) {\n            if ($v1 == $v2) {\n                if (is_numeric($k1))\
    \ {\n                    $l1[$k1] = array_shift($l2);\n                } else\
    \ {\n                    $l1[$k1] = array_pop($l2);\n                }\n     \
    \       }\n        }\n    }\n    return $l1;\n}\n</code>\n<|/ a dscore=5 |>\n\
    <| c |>\nThis appears to return the intersection of two sets (i.e. the intersection\
    \ between the two input sets), not a single element common between the two input\
    \ sets.\n<|/ c |>\n<| c |>\nIt appears that my `common` function was designed\
    \ to do this.  It returns unique values common to both input arrays.  If you have\
    \ both arrays of unique values, then it returns the unique values common to both\
    \ arrays.  If you have only one array that has duplicates in it, you can see that\
    \ `common` returns all of the duplicates.  I thought this was obvious.\n<|/ c\
    \ |>\n<| c |>\nI believe this to be the best answer, though I don't agree with\
    \ the \"not as efficient\" part. It's actually O(n) rather than O(n^2). Which\
    \ is fine for small arrays, but a nasty problem for large ones.\n<|/ c |>\n<|\
    \ c |>\nThe \"not as efficient\" part is not true. It is not O(n) but O(n*log(n)).\
    \ You have to sort the input arrays before you do this.\n<|/ c |>\n<| c |>\nThe\
    \ \"not as efficient\" part is not true. It is not O(n) but O(n*log(n)). You have\
    \ to sort the input arrays before you do this. -- this part is simply wrong. Your\
    \ solution is O(n^2) and that means it is not a solution for finding intersection\
    \ of two sets of elements. Please take a look on this solution: https://stackoverflow.com/a/47450434/1949810\n\
    <|/ c |>\n<| a tags=arrays,set,php,algorithm dscore=5 |>\nHere's an O(n) solution\
    \ that relies on sorting.\n<code>", "    // Iterate through the arrays and compare\
    \ each element to each other.\n    foreach ($l1 as $key => $value) {\n       \
    \ foreach ($l2 as $key2 => $value2) {\n            // If the same key is found\
    \ with different values, we found a common value.\n            if ($key == $key2\
    \ && $value != $value2) {\n                return array($value, $value2);\n  \
    \          }\n        }\n    }\n    // No common values were found.\n    return\
    \ false;\n}\n", "    $common = array();\n\n    foreach ($l1 as $key => $value)\
    \ {\n        if (in_array($value, $l2)) {\n            $common[] = $value;\n \
    \           unset($l1[$key]);\n            unset($l2[$key]);\n        }\n    }\n\
    \n    foreach ($l2 as $key => $value) {\n        if (in_array($value, $l1)) {\n\
    \            $common[] = $value;\n            unset($l1[$key]);\n            unset($l2[$key]);\n\
    \        }\n    }\n\n    return array_values(array_filter($common));\n}", "  \
    \  $i1 = array_search($l1[0], $l2);\n    $i2 = array_search($l2[0], $l1);\n  \
    \  if ($i1 != $i2) return array($l1[$i1], $l2[$i2]);\n    return array();\n}\n\
    \n$common = array_map(\"common\", $arr1, $arr2);\n</code>\n<|/ a tags=arrays,php,merge\
    \ |>\n<| c |>\nthanks for this.. just need to find how can i remove duplicate\
    \ values from this array\n<|/ c |>\n<| c |>\n: Use [array_unique](http://php.net/array_unique)\
    \ to remove duplicates and leave the result as array.\n<|/ c |>\n<| c |>\n: I\
    \ added an example. I hope you can understand what I mean by that. If you don't\
    \ understand something, please ask a new question and describe what exactly you\
    \ want to do.\n<|/ c |>\n<| c |>\n: I added an example. It should help you to\
    \ get started.\n<|/ c |>\n<| c |>\n: Did you try the example? Does it work for\
    \ you?\n<|/ c |>\n<| a |>\nWhat you are describing is called an intersection between\
    \ arrays.\n<|/ a dscore=2 tags=arrays,php,merge |>\n<| a tags=arrays,php,merge\
    \ |>\n<code>\n<?php\n$arr1 = array(\"first\", \"second\", \"third\");\n$arr2 =\
    \ array(4, 5, 6);\n\n$arr3 = array_diff($arr1, $arr2);\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nI don't think this does what the question asks: It returns common\
    \ elements and removes uncommon elements.\n<|/ c |>\n<| c |>\nWhat about array_intersect()?\
    \ http://php.net/manual/en/function.array-intersect.php\n<|/ c |>\n<| a tags=arrays,php,merge\
    \ |>\nYou could use array_intersect.\n<|/ a dscore=1 |>\n<| a dscore=0 tags=arrays,php,merge\
    \ |>\n<code>\n<?php\n$arr1 = array(\"first\", \"second\", \"third\");\n$arr2 =\
    \ array(4, 5, 6);\n$arr3 = array_diff($arr1, $arr2);", "    if (empty($l1) ||\
    \ empty($l2)) {\n        return array();\n    }\n\n    return array_intersect($l1,\
    \ $l2);\n}\n", "    $result = array();\n    foreach ($l1 as $v) {\n        $found\
    \ = FALSE;\n        foreach ($l2 as $v2) {\n            if ($v === $v2) {\n  \
    \              $found = TRUE;\n                break;\n            }\n       \
    \ }\n        if (!$found) {\n            $result[] = $v;\n        }\n    }\n \
    \   return $result;\n}\n", "    $common = array();\n    foreach ($l1 as $k =>\
    \ $v)\n        if (in_array($v, $l2))\n            $common[] = $v;\n    return\
    \ $common;\n}\n", "    $u1 = array_ukey($l1);\n    $u2 = array_ukey($l2);\n  \
    \  $common = array_intersect($u1, $u2);\n    return $common;\n}\n", "  $common\
    \ = array();\n  $i1=0;\n  $i2=count($l2);\n  while ($i1 < $i2) {\n    $c1 = $l1[$i1];\n\
    \    $c2 = $l2[$i2];\n    if ($c1 < $c2)\n      { $common[] = $c1; }\n    else\n\
    \      { $common[] = $c2; }\n    $i1++;\n    $i2++;\n  }\n  return $common;\n\
    }\n", "  $common = array();\n  $size = min(count($l1), count($l2));\n  for($i\
    \ = 0; $i < $size; ++$i) {\n    if($l1[$i] != $l2[$i]) {\n      $common[$i] =\
    \ $l1[$i];\n    }\n  }\n  return $common;\n}", "\t$common = array();\n\tforeach\
    \ ($l1 as $k1 => $v1) {\n\t\tforeach ($l2 as $k2 => $v2) {\n\t\t\tif ($v1 ===\
    \ $v2) {\n\t\t\t\t$common[$k1] = $v1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\
    return $common;\n}\n", "  return $l1[0] & $l2[0] ? array($l1[0]) => $l1[1]\n \
    \   : $l1[0] & $l2[1] ? array($l1[1]) => $l1[0]\n    : $l2[0] & $l1[1] ? array($l2[1])\
    \ => $l2[0]\n    : $l2[0];\n}\n", "  $i1 = array_search($l1, $l2);\n  if ($i1\
    \ === false) {\n    return $l2;\n  }\n\n  $i2 = array_search($l2, $l1);\n  if\
    \ ($i2 === false) {\n    return $l1;\n  }\n\n  return array_slice($l1, $i1, 1);\n\
    }\n\n", "    sort($l1);\n    sort($l2);\n    $result = array_intersect($l1, $l2);\n\
    \    asort($result);\n    return array_values($result);\n}\n", "    if (!isset($l1)\
    \ || !isset($l2)) {\n        return array();\n    }\n\n    $common = array();\n\
    \n    foreach ($l1 as $key => $value) {\n        foreach ($l2 as $key2 => $value2)\
    \ {\n            if ($value === $value2) {\n                $common[] = $value;\n\
    \            }\n        }\n    }\n\n    return $common;\n}\n", "    $common =\
    \ array();\n    $l1 = array_unique($l1);\n    $l2 = array_unique($l2);\n    foreach\
    \ ($l1 as $e) {\n        if (in_array($e, $l2)) {\n            $common[] = $e;\n\
    \        }\n    }\n    return $common;\n}", "    $result = array();\n    foreach\
    \ ($l1 as $i => $v) {\n        if (in_array($v, $l2)) {\n            $result[]\
    \ = $v;\n        }\n    }\n    return $result;\n}", "  if (empty($l1) || empty($l2))\
    \ {\n    return array();\n  }\n  $n1 = count($l1);\n  $n2 = count($l2);\n  $i\
    \ = $j = 0;\n  $c = array();\n  for (; $i < $n1 && $j < $n2; $i++) {\n    if ($l1[$i]\
    \ == $l2[$j]) {\n      $c[$i] = $l1[$i];\n      $j++;\n    } else if ($l1[$i]\
    \ > $l2[$j]) {\n      $i++;\n    } else {\n      $j++;\n    }\n  }\n  for (; $i\
    \ < $n1; $i++) {\n    $c[$i] = $l1[$i];\n  }\n  return $c;\n}\n", "  $l1 = array_unique($l1);\n\
    \  $l2 = array_unique($l2);\n  $r1 = array_diff_assoc($l1, $l2);\n  $r2 = array_diff_assoc($l2,\
    \ $l1);\n  return array_merge($r1, $r2);\n}", "    if (empty($l1) || empty($l2))\
    \ {\n        return array();\n    }\n    $result = [];\n    foreach ($l1 as $key\
    \ => $value) {\n        if (in_array($value, $l2)) {\n            $result[] =\
    \ $value;\n            unset($l2[$key]);\n        }\n    }\n    return array_values($l2);\n\
    }\n", "    return array_uintersect($l1, $l2, function($x, $y) {\n        return\
    \ $x < $y ? -1 : 1;\n    });\n}\n", "    $l1 = array_unique($l1);\n    $l2 = array_unique($l2);\n\
    \    sort($l1);\n    sort($l2);\n    $common = array();\n    $l1 = array_flip($l1);\n\
    \    foreach ($l2 as $k2 => $v2) {\n        if (!isset($l1[$k2])) {\n        \
    \    $common[$k2] = $v2;\n        }\n    }\n    return $common;\n}\n</code>\n\
    The code above works by first checking if an array has the element before hand.\
    \ If it does not, the element is added to the array. Otherwise, it checks if the\
    \ element is present in the array. If the element is present, the element is removed.\
    \ Otherwise, the element is added to the array and returned.\nThe code can be\
    \ further optimized to run better on large arrays.\n<|/ a tags=arrays,duplicates,php\
    \ dscore=3 |>\n<| c |>\nYour code returns false for the following cases: array(1,\
    \ 4, 3, 34, 653, 2, 5), array(5, 7, 1, 5, 9, 653, 121) And array(5, 3, 2, 8),\
    \ array(3, 2)\n<|/ c |>\n<| c |>\nI tested the cases and I got \"array(1, 5, 653)\"\
    \ and \"array(2, 3)\" as results. What did you expect?\n<|/ c |>\n<| a |>\nUse\
    \ array_unique() to get the unique elements. Then you can just loop through them\
    \ and use in_array() to get the common elements.\n<code>\n$array1 = array(1,4,3,34,653,2,5);\n\
    $array2 = array(5,7,1,5,9,653,121);\n$array3 = array(5,3,2,8);\n", "    sort($l1);\n\
    \    sort($l2);\n    \n    $i = 0;\n    \n    foreach ($l1 as $k => $v) {\n  \
    \      while ($i < $l1[$k]) {\n            if (isset($l2[$k]) && $v === $l2[$k])\
    \ {\n                return array($k);\n            }\n            $i++;\n   \
    \     }\n    }\n    return array();\n}\n", "  $c1 = array_count_values($l1);\n\
    \  $c2 = array_count_values($l2);\n  foreach ($c1 as $i => $v) {\n    if ($c1[$i]\
    \ != $c2[$i]) {\n      return $i;\n    }\n  }\n  return count($c1);\n}\n</code>\n\
    <|/ a tags=php |>\n<| c |>\nHow does this work when the array has duplicates?\
    \ Can you give me an example of when this fails?\n<|/ c |>\n<| a |>\n<code>\n\
    <?php\n$arr1 = [1,1,2,3];\n$arr2 = [1,2,2,3,3,4];\n\n$common = 0;\n$result = array();\n\
    foreach($arr1 as $key => $value) {\n    foreach($arr2 as $key2 => $value2) {\n\
    \        if ($key == $key2 && $value == $value2) {\n            $common++;\n \
    \       } else {\n            continue;\n        }\n    }\n}\nif($common >= 2)\
    \ {\n    foreach($arr2 as $key => $value) {\n        if($key == $common) {\n \
    \           $result[] = $value;\n        }\n    }\n}\n\nprint_r($result);\n</code>\n\
    <|/ a dscore=4 tags=php |>\n<| c |>\nThis should be the accepted answer! It works\
    \ even if there are duplicates in the arrays.\n<|/ c |>\n<| c |>\nThis is probably\
    \ the only solution that considers the order of the arrays in any way\n<|/ c |>\n\
    <| a tags=php |>\nTo get the common elements in the two arrays you can use array_intersect:\n\
    <code>\n$array1 = array(\"hello\",\"world\",\"goodbye\",\"world\");\n$array2 =\
    \ array(\"hello\",\"hello\",\"goodbye\");\n$array3 = array_intersect($array1,$array2);\n\
    print_r($array3);\n</code>\nOutput will be:\n<code>\nArray\n(\n    [0] => goodbye\n\
    )\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis is what I've been looking for. Thanks.\n\
    <|/ c |>\n<| c |>\nNot sure how this answer got upvotes. This is **not** the same\
    \ as the OP's code. While the code will give the common array (as seen by OP),\
    \ it will also return the element that appears **first** in both arrays. Your\
    \ code would return `goodbye` and not `hello`. Please see my answer for an updated\
    \ solution.\n<|/ c |>\n<| a dscore=4 |>\n<code>\n<?php\n$array1 = [1,2,3,4,5,6,",
  "    if (!is_array($l1) || !is_array($l2)) {\n        return array();\n    }\n \
    \   return array_intersect($l1, $l2);\n}\n", "    $set1 = array();\n    $set2\
    \ = array();\n    foreach ($l1 as $i => $v) {\n        if (!isset($l2[$i])) {\n\
    \            $set1[$i] = $v;\n        } else {\n            $set2[$i] = $v;\n\
    \        }\n    }\n    return array_intersect($set1, $set2);\n}", "    $common\
    \ = array();\n    $l1 = array_values($l1);\n    $l2 = array_values($l2);\n   \
    \ foreach ($l1 as $key => $value) {\n        foreach ($l2 as $key2 => $value2)\
    \ {\n            if ($value == $value2) {\n                $common[] = $value;\n\
    \                unset($l2[$key2]);\n                break;\n            }\n \
    \       }\n    }\n    return $common;\n}\n$list1 = array();\n$list2 = array();\n\
    $file1 = fopen(\"list1.txt\", \"r\");\n$file2 = fopen(\"list2.txt\", \"r\");\n\
    while ($line = fgets($file1))\n{\n$list1[] = $line;\n}\nwhile ($line = fgets($file2))\n\
    {\n$list2[] = $line;\n}\n$common = common($list1, $list2);\necho \"Common elements\
    \ are :\\n\";\nprint_r($common);\nfclose($file1);\nfclose($file2);", "  uasort($l1,\
    \ function ($a, $b) {\n    return $a < $b ? -1 : ($a > $b ? 1 : 0);\n  });\n \
    \ uasort($l2, function ($a, $b) {\n    return $a < $b ? -1 : ($a > $b ? 1 : 0);\n\
    \  });\n  $common = [];\n  $l1[count($l1)-1] = $l1[count($l1)-1]+1;\n  for ($i\
    \ = 1; $i < count($l1); $i++) {\n    $common[] = $l1[$i];\n  }\n  for ($i = 1;\
    \ $i < count($l2); $i++) {\n    if (isset($common[$i])) {\n      for ($j = $i;\
    \ $j < count($l1); $j++) {\n        if ($l1[$j] === $common[$i]) {\n         \
    \ $common[] = $l1[$j];\n        }\n      }\n    }\n  }\n  return $common;\n}\n\
    </code>\n<|/ a tags=sorting,arrays,php dscore=0 |>\n<| a |>\n<code>\n$arr = array(1,\
    \ 4, 3, 34, 653, 2, 5);\n$arr1 = array(5, 7, 1, 5, 9, 653, 121);\n$result = array_uintersect(\
    \ $arr, $arr1, array_map( 'count', array( $arr, $arr1 ) ) );\n</code>\n<|/ a dscore=0\
    \ tags=sorting,arrays,php |>\n<| a tags=sorting,arrays,php dscore=0 |>\nThis might\
    \ also work:\n<code>\n<?php\n\n$array1 = [2,1,3,5,4,2,5,6,7,8,9];\n$array2 = [2,1,3,5,4,2,5,6,7,8,9];\n\
    \n$array3 = array_intersect($array1, $array2);\n\n$result3 = array_filter($array3,\
    \ function($var) use ($array1, $array2) {\n    return in_array($var, $array1)\
    \ || in_array($var, $array2);\n});\n\nvar_dump($result3);\n</code>\n<|/ a |>\n\
    <| a |>\n<code>\n<?php\n$array1 = [2,1,3,5,4,2,5,6,7,8,9];\n$array2 = [2,1,3,5,4,2,5,6,7,8,9];\n\
    \n$array3 = array_intersect($array1, $array2);\n\n$result3 = array_filter($array3,\
    \ function($var) use ($array1, $array2) {\n    return in_array($var, $array1)\
    \ || in_array($var, $array2);\n});\n\nvar_dump($result3);\n</code>\n<|/ a tags=sor",
  "\tsort($l1);\n\tsort($l2);\n\n\t$common = array();\n\tforeach ($l1 as $key => $value)\
    \ {\n\t\tif ($key === $key) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ($l1[$key] === $l1[$key])\
    \ {\n\t\t\t$common[$key] = $value;\n\t\t}\n\t}\n\tforeach ($l2 as $key => $value)\
    \ {\n\t\tif ($key === $key) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ($l1[$key] === $l1[$key])\
    \ {\n\t\t\t$common[$key] = $value;\n\t\t}\n\t}\n\treturn $common;\n}\n", "   \
    \ sort($l1);\n    sort($l2);\n    $result = array();\n    foreach ($l1 as $i)\
    \ {\n        if (!in_array($i, $l2)) {\n            $result[] = $i;\n        }\n\
    \    }\n    return $result;\n}\n</code>\n<|/ a dscore=1 tags=php,sorting,arrays\
    \ |>\n<| c |>\nI see no advantage of your solution over `array_intersect()` which\
    \ I find more readable. The sorting does not help here. That might be a good idea\
    \ if you have already sorted the arrays in your PHP script, but here they are\
    \ completely unsorted and cannot be compared element-wise.\n<|/ c |>\n<| c |>\n\
    I agree. I just made this solution as an example of sorting and comparing two\
    \ arrays. The above solution could be refactored even more, but is more readable.\
    \ I was just trying to show how the algorithm works.\n<|/ c |>\n<| a |>\nYou can\
    \ use array_intersect_assoc() function to get common array from two arrays. \n\
    array_intersect_assoc(): Returns values in array 1 where key is present in array\
    \ 2\n<|/ a dscore=0 tags=php,sorting,arrays |>\n<| a tags=php,sorting,arrays dscore=0\
    \ |>\nTo get the common elements in two arrays use:\n<code>\n$intersect = array_intersect($arr1,\
    \ $arr2);\n</code>\nTo get the common keys in two arrays use:\n<code>\n$intersect_keys\
    \ = array_intersect_key($arr1, $arr2);\n</code>\nTo get the common values use:\n\
    <code>\n$intersect_values = array_intersect_assoc($arr1, $arr2);\n</code>\nTo\
    \ get the common pairs use:\n<code>\n$intersect_pairs = array_intersect_uassoc($arr1,\
    \ $arr2, $strict);\n</code>\n<|/ a |>\n<| c |>\nHow do you get the common pairs?\n\
    <|/ c |>\n<| c |>\nThe last example shows how to do that. The third example shows\
    \ how to use it to get the common keys and values. You can just pass the $strict\
    \ parameter to array_intersect_assoc() to include additional values (keys in $arr2\
    \ that are not present in $arr1).\n<|/ c |>\n<| a tags=php,sorting,arrays |>\n\
    try array_intersect function it will return common elements\n<code>\n$result =\
    \ array_intersect($l1,$l2);\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThe sorting\
    \ is not part of the problem. It only helps to reduce the number of elements that\
    \ need to be ", "  return array_unique(array_merge(array_intersect($l1, $l2),\
    \ array_diff($l1, $l2)));\n}", "    $u1 = array_unique($l1);\n    $u2 = array_unique($l2);\n\
    \    sort($u1);\n    sort($u2);\n\n    return array_diff($u1, $u2);\n}", "   \
    \ $ret = [];\n    foreach ($l1 as $el1) {\n        foreach ($l2 as $el2) {\n \
    \           if ($el1 == $el2) $ret[] = $el1;\n        }\n    }\n    return $ret;\n\
    }\n</code>\n<|/ a tags=arrays,php |>\n<| a |>\n<code>\n$arr1 = [1,2,3,4,5,6,7,8];\n\
    $arr2 = [8,4,6,7,1,5,4,3,2];\n$arr3 = array_diff($arr1,$arr2);\n$arr4 = array_merge($arr1,$arr3);\n\
    $arr5 = array_unique($arr4);\n$arr6 = array_intersect($arr1,$arr5);\nprint_r($arr6);\n\
    </code>\n<|/ a dscore=2 tags=arrays,php |>\n<| a |>\n<code>\n<?php", "    $common\
    \ = array();\n    $llen1 = count($l1);\n    $llen2 = count($l2);\n    for ($i\
    \ = 0; $i < $llen1 && $i < $llen2; $i++) {\n        $common[] = $l1[$i];\n   \
    \ }\n    for ($i = 0; $i < $llen1 && $i < $llen2; $i++) {\n        $c = $l1[$i];\n\
    \        for ($j = 0; $j < $llen2; $j++) {\n            if ($l1[$i] === $l1[$j]\
    \ && $l2[$j] !== $c) {\n                $common[] = $l1[$j];\n            }\n\
    \        }\n    }\n    for ($i = 0; $i < $llen1; $i++) {\n        for ($j = 0;\
    \ $j < $llen2; $j++) {\n            if ($l1[$i] === $l1[$j] && $l2[$i] !== $l1[$j])\
    \ {\n                $common[] = $l1[$i];\n            }\n        }\n    }\n \
    \   return $common;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nWhile this may answer\
    \ the question, it would be better to include some explanation about what your\
    \ code does.\n<|/ c |>\n<| c |>\nWhile this code may answer the question, providing\
    \ additional context regarding why and/or how this code answers the question improves\
    \ its long-term value.\n<|/ c |>\n<| c |>\nYes, I know, I did explain it. If I\
    \ can remember how I did it when I was in school I will. I'll put that in the\
    \ answers though.\n<|/ c |>\n<| c |>\nI fixed it by modifying my own code slightly.\n\
    <|/ c |>\n<| c |>\nIt would be best if you explained what your code does.\n<|/\
    \ c |>\n<| a tags=arrays,php |>\nTry using array_intersect() function. That should\
    \ work for you.\n<code>\n$a = array(\n    1 => 4,\n    2 => 5,\n    3 => 6,\n\
    \    4 => 5,\n    5 => 2,\n    6 => 8,\n    7 => 2,\n    8 => 8,\n);\n$b = array(\n\
    \    1 => 4,\n    2 => 5,\n    3 => 6,\n    4 => 5,\n    5 => 2,\n    6 => 8,\n\
    \    7 => 2,\n    8 => 8,\n);\n\n$c = array_intersect($a, $b);\n</code>\nThe output\
    \ will be \n<code>\nArray\n(\n    [1] => ", "    if (!count($l1) || !count($l2))\
    \ {\n        return array();\n    }\n    $n1 = max(count($l1), count($l2));\n\
    \    $l1 = array_fill(0, $n1, null);\n    $l2 = array_fill(0, $n1, null);\n  \
    \  foreach ($l1 as $i => $v) {\n        if (null !== $v)\n            $l1[$i]\
    \ = $v;\n    }\n    foreach ($l2 as $i => $v) {\n        if (null !== $v)\n  \
    \          $l2[$i] = $v;\n    }\n    $intersect = array_intersect($l1, $l2);\n\
    \    return array_keys($intersect);\n}\n", "  $n1 = count($l1);\n  $n2 = count($l2);\n\
    \  $ret = $l1;\n  for ($i = 1; $i < $n2; ++$i) {\n    if ($l1[$i] == $l2[$i])\
    \ {\n      continue;\n    }\n    sort($ret);\n    sort($l1);\n    sort($l2);\n\
    \    $ret[] = $l2[$i];\n    $l1[$i] = $l2[$i];\n  }\n  return $ret;\n}\n", "\t\
    $a = array_unique($l1);\n\t$b = array_unique($l2);\n\tsort($a);\n\tsort($b);\n\
    \treturn array_intersect($a, $b);\n}\n", "    sort($l1);\n    sort($l2);\n   \
    \ return array_intersect($l1, $l2);\n}", "  $keys = array_keys(array_flip($l1),\
    \ $l2);\n  return array_filter($keys, function($key) {\n    return isset($l2[$key]);\n\
    \  });\n}\n</code>\n<|/ a dscore=2 tags=sorting,php,arrays,associative-array,combinations\
    \ |>\n<| a |>\nThis was a real challenge for me. I wanted to sort my array of\
    \ categories by a specific attribute in the categories themselves. I ended up\
    \ using recursion with array_reduce(), and here's the code:\n<code>\n$categories\
    \ = array(\n    'general' => array(\n        'name' => 'general',\n        'slug'\
    \ => 'general',\n        'description' => 'General Category Desc',\n        'category_parent'\
    \ => null,\n        'category_image' => '/images/general.png',\n        'category_order'\
    \ => 0,\n        'category_weight' => 0\n    ),\n    'animals' => array(\n   \
    \     'name' => 'animals',\n        'slug' => 'animals',\n        'description'\
    \ => 'Animal Category Desc',\n        'category_parent' => null,\n        'category_image'\
    \ => '/images/animals.png',\n        'category_order' => 1,\n        'category_weight'\
    \ => 0\n    ),\n    'fish' => array(\n        'name' => 'fish',\n        'slug'\
    \ => 'fish',\n        'description' => 'Fish Category Desc',\n        'category_parent'\
    \ => 'animals',\n        'category_image' => '/images/fish.png',\n        'category_order'\
    \ => 2,\n        'category_weight' => 0\n    ),\n    'vegetables' => array(\n\
    \        'name' => 'vegetables',\n        'slug' => 'vegetables',\n        'description'\
    \ => 'Vegetable Category Desc',\n        'category_parent' => 'animals',\n   \
    \     'category_image' => '/images/vegetables.png',\n        'category_order'\
    \ => 3,\n        'category_weight' => 0\n    ),\n    'herbs' => array(\n     \
    \   'name' => 'herbs',\n        'slug' => 'herbs',\n        'description' => 'Herb\
    \ Category Desc',\n        'category_parent' => 'animals',\n        'category_image'\
    \ => '/images/herb.png',\n        'category_order' => 4,\n        'category_weight'\
    \ => 0\n    ),\n    'other' => array(\n        'name' => 'other',\n        'slug'\
    \ => 'other',\n        'description' => 'Other Category Desc',\n        'category_parent'\
    \ => 'general',\n        'category_image' => '/images/other.png',\n        'category_order'\
    \ => 5,\n        'category_weight' => 0\n    ),\n);\n\n$categories_by_order =\
    \ array_reduce($categories, function($carry, $category) {\n    return $carry +\
    \ (isset($category['category_order']) ? $category['", "\t$n1 = count($l1);\n\t\
    $n2 = count($l2);\n\t$i = 0;\n\twhile ($i < $n1 && $i < $n2) {\n\t\tif ($l1[$i]\
    \ === $l2[$i]) $i++;\n\t\telse break;\n\t}\n\treturn $i < $n1 ? $l1 : $l2;\n}\n",
  "  global $common, $cache;\n\n  $l1 = array_map('current', $l1);\n  $l2 = array_map('current',\
    \ $l2);\n\n  foreach ($l1 as $i => $a1) {\n    foreach ($l2 as $j => $a2) {\n\
    \      if ($a1 === $a2) continue 2;\n      elseif ($cache[$a1 . $a2]) {\n    \
    \    unset($l1[$i], $l2[$j]);\n      }\n    }\n  }\n  foreach ($l2 as $i => $a2)\
    \ {\n    foreach ($l1 as $j => $a1) {\n      if ($a1 === $a2) continue 2;\n  \
    \    elseif ($cache[$a1 . $a2]) {\n        unset($l2[$i], $l1[$j]);\n      }\n\
    \    }\n  }\n  return array_values(array_unique($l1, SORT_NUMERIC));\n}", "  $set1\
    \ = array();\n  $set2 = array();\n  $i = -1;\n  while (++$i < count($l1)) {\n\
    \    $set1[$l1[$i]] = 1;\n  }\n  while (++$i < count($l2)) {\n    $set2[$l2[$i]]\
    \ = 1;\n  }\n  return array_keys(array_intersect($set1, $set2));\n}", "    $result\
    \ = array();\n    if (is_array($l1) && is_array($l2)) {\n        $length = count($l1);\n\
    \        for ($i = 0; $i < $length; $i++) {\n            if (in_array($l1[$i],\
    \ $l2))\n                $result[] = $l1[$i];\n        }\n    }\n    return $result;\n\
    }", "  $u1 = array_unique($l1);\n  $u2 = array_unique($l2);\n  $common = array_intersect($u1,\
    \ $u2);\n  return array_unique($common);\n}", "  foreach ($l1 as $key => $value)\
    \ {\n    if (array_search($value, $l2, true) !== $key) {\n      unset($l1[$key]);\n\
    \    }\n  }\n  return $l1;\n}", "    $l1 = array_filter($l1, function ($item)\
    \ { return !in_array($item, $l2); });\n    $l2 = array_filter($l2, function ($item)\
    \ { return !in_array($item, $l1); });\n    return array_intersect($l1, $l2);\n\
    }\n", "    $c = [];\n    foreach ($l1 as $v) {\n        if (in_array($v, $l2))\
    \ {\n            $c[] = $v;\n        }\n    }\n    return $c;\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nThis isn't what I was looking for but it gave me the idea to\
    \ create a function that would return the number of intersections between the\
    \ two arrays and then compare that to the total length of each array. Thanks for\
    \ your answer though.\n<|/ c |>\n<| c |>\nHis question was about a PHP function\
    \ which can do this \"efficiently\". I don't see how this answer provides a way\
    \ to do this.\n<|/ c |>\n<| c |>\nThis code doesn't work if one of the arrays\
    \ is empty. It returns empty array instead of empty set.\n<|/ c |>\n<| c |>\n\
    Yes it does. `in_array()` returns true if a value exists in the array, false if\
    \ it doesn't, or null if the first parameter evaluates to false. `in_array()`\
    \ returns true or false depending on whether or not the value exists in the array.\n\
    <|/ c |>\n<| c |>\nit works but doesn't scale well with large datasets because\
    \ the function calls itself in each iteration and for large datasets it gets inefficient\
    \ and unacceptable.\n<|/ c |>\n<| a dscore=5 |>\nThe accepted answer by user3372067\
    \ doesn't work when the arrays are empty.\nIf you need this function to return\
    \ an empty array, you should use the in_array function like this:\n<code>", " \
    \   $intersect = array_intersect($l1, $l2);\n    sort($intersect);\n    return\
    \ array_unique($intersect);\n}\n", "  $result = array();\n\n  foreach ($l1 as\
    \ $element) {\n    if (in_array($element, $l2)) {\n      $result[] = $element;\n\
    \    }\n  }\n\n  return $result;\n}\n\n/**\n * Get the last element of an array\n\
    \ *\n * @param $array array An array\n *\n * @return mixed The last element\n\
    \ */", "  $result = array();\n  if (count($l1) != count($l2)) {\n    return $result;\n\
    \  }\n  foreach ($l1 as $key => $value) {\n    if (isset($l2[$key])) {\n     \
    \ $result[] = $value;\n    }\n  }\n  return $result;\n}", "  $r1 = array_count_values($l1);\n\
    \  $r2 = array_count_values($l2);\n  $common = array();\n  foreach ($r1 as $i\
    \ => $n) {\n    if (!isset($r2[$i])) {\n      $common[$i] = $n;\n    }\n  }\n\
    \  return $common;\n}\n$common = common($arr1, $arr2);\n$common = array_unique($common);\n\
    $result = array_intersect($arr1, $arr2);\n$result = array_intersect($result, $common);\n\
    $result = array_filter($result, function($v){\n    return $v > 0;\n});\n</code>\n\
    <|/ a dscore=0 tags=php,sorting |>\n<| a dscore=0 tags=php,sorting |>\nIf you\
    \ have two arrays, say $a and $b, this simple code snippet will get the common\
    \ values (in any order) from the two arrays:\n<code>\n$common = array_intersect($a,\
    \ $b);\n</code>\nIt also works when you want to find common values between a pair\
    \ of arrays:\n<code>\n$common = array_intersect($a, $b); // Get the common values\
    \ between arrays a and b\n$common = array_intersect($a, $b, $c); // Get the common\
    \ values between arrays a and b and array c\n</code>\n<|/ a |>\n<| c |>\nOP needs\
    \ a solution that will allow to sort values by number of occurences in both arrays\n\
    <|/ c |>\n<| c |>\nThat's a fair point. I think it would be helpful to give a\
    \ more complete example to clarify that.\n<|/ c |>\n<| a |>\n<code>\n<?php\n$array1\
    \ = [1,2,3,4,5,6];\n$array2 = [5,3,4,1,9,1,2];\n$array3 = array_diff($array1,\
    \ $array2);\n$array4 = array_intersect($array2, $array3);\n$array5 = array_merge($array1,\
    \ $array4);\n\necho \"<pre>\";\nprint_r($array5);\n</code>\n<|/ a dscore=0 tags=php,sorting\
    \ |>\n<| c |>\nWhile this code may answer the question, providing additional context\
    \ regarding how and/or why it solves the problem would improve the answer's long-term\
    \ value.\n<|/ c |>\n<| c |>\nPlease explain how this code works, what it does,\
    \ and how it answers the question asked\n<|/ c |>\n<| a |>\n<code>\n<?php\n$array1\
    \ = [1,2,3,4,5,6];\n$array2 = [5,", "    $common = array();\n\n    foreach ($l1\
    \ as $key => $value) {\n        if (in_array($value, $l2)) {\n            $common[]\
    \ = $value;\n        }\n    }\n\n    return $common;\n}\n", "    // Return null\
    \ if either array is empty.\n    if (empty($l1) || empty($l2)) {\n        return\
    \ null;\n    }\n    // Return sorted unique elements from both arrays.\n    return\
    \ array_unique(array_merge($l1, $l2));\n}", "    // return an array with elements\
    \ common to both arrays\n    $out = [];\n    foreach ($l1 as $e) {\n        if\
    \ (in_array($e, $l2)) {\n            $out[] = $e;\n        }\n    }\n    return\
    \ $out;\n}", "    sort($l1);\n    sort($l2);\n    $d = array_merge($l1, $l2);\n\
    \    $d1 = array_count_values($d);\n    return array_keys($d1);\n}\n", "    $result\
    \ = array();\n    foreach ($l1 as $val) {\n        if (in_array($val, $l2)) {\n\
    \            $result[] = $val;\n        }\n    }\n    return $result;\n}", " \
    \ $common = [];\n  foreach ($l1 as $k1 => $v1) { if (in_array($v1, $l2)) { $common[$k1]\
    \ = $v1; } }\n  return $common;\n}\n", "  $l1 = (array) $l1;\n  $l2 = (array)\
    \ $l2;\n  $intersect = array_intersect($l1, $l2);\n  $unique = array_unique($l1,\
    \ $l2);\n  return array_diff($intersect, $unique);\n}", "    if (!$l1 || !$l2)\n\
    \        return array();\n    $sorted = array_merge($l1, $l2);\n    usort($sorted,\
    \ 'cmp');\n    return array_unique($sorted);\n}\n", "    $common = array();\n\
    \    foreach ($l1 as $i => $v) {\n        if (array_search($v, $l2) === FALSE)\
    \ {\n            $common[$i] = $v;\n        }\n    }\n    return $common;\n}\n\
    \n/**\n * Return the difference of two arrays.\n * @param array $l1 The first\
    \ array\n * @param array $l2 The second array\n * @return array The difference\
    \ of $l1 and $l2\n */", "  $l1 = array_reverse($l1);\n  $l2 = array_reverse($l2);\n\
    \  $i = NULL;\n  $j = 0;\n  $count = 0;\n\n  while ($j < count($l1) and $count\
    \ < count($l2)) {\n    if ($l1[$i] == $l2[$j]) {\n      $count++;\n      $i++;\n\
    \      $j++;\n    } else {\n      if ($count > 0) {\n        $l1[$i] = $count;\n\
    \      }\n      $count = 0;\n      $j++;\n      $i++;\n    }\n  }\n\n  if ($count\
    \ > 0) {\n    $l1[$i] = $count;\n  }\n  return array_reverse($l1);\n}\n", "  \
    \  if (count($l1) != count($l2)) return array();\n    $l1 = array_values($l1);\n\
    \    $l2 = array_values($l2);\n    $i = -1;\n    $result = array();\n    foreach\
    \ ($l1 as $item) {\n        ++$i;\n        $found = false;\n        foreach ($l2\
    \ as $item) {\n            if ($item == $l1[$i]) {\n                $found = true;\n\
    \                break;\n            }\n        }\n        if ($found === false)\
    \ {\n            $result[] = $l1[$i];\n        }\n    }\n    return $result;\n\
    }\n", "  $common = array();\n  foreach ($l1 as $k => $v1) {\n    foreach ($l2\
    \ as $k2 => $v2) {\n      if ($v1 === $v2) {\n        $common[] = $v1;\n     \
    \   unset($l2[$k2]);\n      }\n    }\n  }\n  foreach ($l2 as $k => $v2) {\n  \
    \  $common[] = $v2;\n  }\n  return $common;\n}\n\n$result = common(array_keys($files),\
    \ array_keys($files_not_found));\necho implode(\"\\n\", $result);", "  $set1 =\
    \ array();\n  $set2 = array();\n  foreach ($l1 as $key => $value) {\n    if ($l1[$key]\
    \ === $l1[$key]) {\n      $set1[$key] = $value;\n    }\n  }\n  foreach ($l2 as\
    \ $key => $value) {\n    if ($l2[$key] === $l2[$key]) {\n      $set2[$key] = $value;\n\
    \    }\n  }\n  return array_intersect($set1, $set2);\n}", "    $unique = array_merge($l1,\
    \ $l2);\n    $result = array();\n    $found  = array();\n\n    foreach($unique\
    \ as $item) {\n        foreach($found as $k => $v) {\n            if($item ==\
    \ $v) unset($unique[$k]);\n        }\n        if(in_array($item, $found)) $result[]\
    \ = $item;\n        $found[] = $item;\n    }\n    return $result;\n}", "    $l1\
    \ = array_filter($l1);\n    $l2 = array_filter($l2);\n\n    $intersect = array_intersect($l1,\
    \ $l2);\n    return array_unique(array_merge($l1, $l2, $intersect));\n}\n</code>\n\
    <|/ a |>\n<| a dscore=1 |>\n<code>\n<?php\n$array1 = array(\n  \"0\" => 0,\n \
    \ \"1\" => 1,\n  \"2\" => 2,\n  \"3\" => 3\n);\n\n$array2 = array(\n  \"0\" =>\
    \ 0,\n  \"1\" => 1,\n  \"2\" => 2,\n  \"3\" => 3\n);\n\n$array3 = array(\n  \"\
    0\" => 0,\n  \"1\" => 1,\n  \"2\" => 2,\n  \"3\" => 3\n);\n\n$array4 = array(\n\
    \  \"0\" => 0,\n  \"1\" => 1,\n  \"2\" => 2,\n  \"3\" => 3\n);\n\n$array5 = array(\n\
    \  \"0\" => 0,\n  \"1\" => 1,\n  \"2\" => 2,\n  \"3\" => 3\n);\n\n$array6 = array(\n\
    \  \"0\" => 0,\n  \"1\" => 1,\n  \"2\" => 2,\n  \"3\" => 3\n);\n\n$array7 = array(\n\
    \  \"0\" => 0,\n  \"1\" => 1,\n  \"2\" => 2,\n  \"3\" => 3\n);\n\n$array8 = array(\n\
    \  \"0\" => 0,\n  \"1\" => 1,\n  \"2\" => 2,\n  \"3\" => 3\n);\n\n$array9 = array(\n\
    \  \"0\" => 0,\n  \"1\" => 1,\n  \"2\" => 2,\n  \"3\" => 3\n);\n\n$array10 = array(\n\
    \  \"0\" => 0,\n  \"1\" => 1,\n  \"2\" => 2,\n  \"3\" => 3\n);\n\n$array11 = array(\n\
    \  \"0\" => 0,\n  \"1\" => 1,\n  \"2\" => 2,\n  \"3\" => 3\n);\n\n$array12 = array(\n\
    \  \"0\" => 0,\n  \"1\" => 1,\n  \"2\" => 2,\n  \"3\" => 3\n);\n\n$array13 = array(\n\
    \  \"0\" => 0,\n  \"1\" => 1,\n  \"2\" => 2,\n  \"3\" => 3\n);\n\n$array14 = array(\n\
    \  \"0\" => 0,\n  \"1\" => 1,\n  \"2\" => 2,\n  \"3\" => 3\n);\n\n$array15 = array(\n\
    \  \"0\" => 0,\n  \"1\" => 1,\n  \"2\" => 2,\n  \"3\" => 3\n);\n\n$array16 = array(\n\
    \  \"0\" => 0,\n  \"1\" => 1,\n  \"2\" => 2,\n  \"", "\t$common = array();\n\t\
    foreach ($l1 as $key => $value) {\n\t\tif (in_array($value, $l2)) {\n\t\t\t$common[$key]\
    \ = $value;\n\t\t}\n\t}\n\treturn $common;\n}", "    $common = array();\n    foreach($l1\
    \ as $k1 => $v1) {\n        foreach($l2 as $k2 => $v2) {\n            if ($v1\
    \ === $v2) {\n                if (in_array($v1, $common)) {\n                \
    \    unset($l1[$k1]);\n                    unset($l1[$k2]);\n                }\n\
    \                else {\n                    $common[] = $v1;\n              \
    \  }\n            }\n        }\n    }\n    return $l1 + $l2;\n}\n", "    sort($l1);\n\
    \    sort($l2);\n    $set = array_intersect($l1, $l2);\n    if ($l1 === $l2) {\n\
    \        return $set;\n    }\n    else {\n        return array_intersect($l2,\
    \ $l1);\n    }\n}\n", "  $r = array();\n  $c = count($l1);\n  for ($i = 0; $i\
    \ < $c; $i++) {\n    $l1[$i] == $l2[$i] ? $r[] = $l1[$i] : $r[$l1[$i]] = $l1[$i];\n\
    \  }\n  return $r;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nHi there - thank you\
    \ for this. I just tried it, but I think I may have done something wrong as I'm\
    \ getting some weird results. I did `print_r($r)` and the result is `Array` -\
    \ which is not right... Any ideas?\n<|/ c |>\n<| c |>\nHi there. Sorry for the\
    \ delay! I didn't realize that `array_count_values()` was returning an array of\
    \ arrays - that makes a lot of sense!\n<|/ c |>\n<| c |>\n: No problem. You are\
    \ always welcome. By the way, I added a link to a working demo of this code.\n\
    <|/ c |>\n<| a |>\nIt has been a while since I've played with this kind of thing,\
    \ but if I recall correctly I used array_count_values to count the occurrence\
    \ of each unique value.  Then to find the common values I did a little bit of\
    \ array_diff.  Not sure if this is the most efficient solution but it certainly\
    \ works:\n<code>\n$array1 = array(1,2,3,4,1,5,7,6,7,8,9,8);\n$array2 = array(7,5,6,8,9,5,7,2,3,4,8,5,6,3,8,1);\n\
    \n$count1 = array_count_values($array1);\n$count2 = array_count_values($array2);\n\
    \n$result = array();\nforeach($count1 as $key=>$val) {\n    $common_values = array_diff($count2[$key],\
    \ $val);\n    if($common_values) {\n        $result[] = $common_values;\n    }\n\
    }\n</code>\n<|/ a tags=arrays,php dscore=1 |>\n<| a dscore=1 |>\n<code>\n<?php\n\
    $a = [1,2,3,4,1,5,7,6,7,8,9,8];\n$b = [7,5,6,8,9,5,7,2,3,4,8,5,6,3,8,1];\n$c =\
    \ array_count_values($a);\n$d = array_count_values($b);\n\n$common = array_diff_assoc($c,\
    \ $d);\n\nprint_r($common);\n</code>\n<|/ a tags=arrays,php |>\n<| c |>\narray_diff_assoc\n\
    <|/ c |>\n<| a dscore=0 tags=arrays,php |>\n<code>\n$array", "  $common = array();\n\
    \  foreach ($l1 as $k => $v) {\n    if (in_array($v, $l2)) {\n      $common[]\
    \ = $v;\n    }\n  }\n  return $common;\n}\n", "\t$common = array_intersect($l1,\
    \ $l2);\n\tsort($common);\n\treturn $common;\n}\n", "    $common = array();\n\
    \    foreach ($l1 as $k) {\n        if (!in_array($k, $common)) {\n          \
    \  $common[] = $k;\n        }\n    }\n    foreach ($l2 as $k) {\n        if (!in_array($k,\
    \ $common)) {\n            $common[] = $k;\n        }\n    }\n    return array_unique($common);\n\
    }\n", "  $result = [];\n  foreach ($l1 as $v) {\n    if (in_array($v, $l2)) {\n\
    \      $result[] = $v;\n    }\n  }\n  return $result;\n}\n", "    $l1 = array_unique($l1);\n\
    \    $l2 = array_unique($l2);\n    return array_intersect($l1, $l2);\n}", "  $r1\
    \ = $l1;\n  $r2 = $l2;\n\n  $l1 = array_merge($l1, $r1);\n  $l2 = array_merge($l2,\
    \ $r2);\n\n  $u = $l1;\n  $u = array_flip($u);\n\n  $l1 = $l1 + array_diff($l1,\
    \ $u);\n  $l2 = $l2 + array_diff($l2, $u);\n\n  $l1 = array_filter($l1, function($v)\
    \ {\n    return !isset($u[$v]);\n  });\n  $l2 = array_filter($l2, function($v)\
    \ {\n    return !isset($u[$v]);\n  });\n\n  return $l1 + $l2;\n}\n", "  $intersect\
    \ = array_intersect($l1, $l2);\n  return array_keys($intersect);\n}", "    $intersect\
    \ = array_intersect($l1, $l2);\n    $l1 = array_unique($l1);\n    $l2 = array_unique($l2);\n\
    \    return array_intersect($l1, $l2);\n}", "    if ($l1 == $l2) return $l1;\n\
    \    if (count($l1) > count($l2)) return $l1;\n    return $l2;\n}", "    if (count($l1)\
    \ != count($l2)) {\n        return array();\n    }\n    $ret = array();\n    foreach\
    \ ($l1 as $key => $lval) {\n        $found = false;\n        foreach ($l2 as $k2\
    \ => $lval) {\n            if ($lval == $l1[$key]) {\n                $found =\
    \ true;\n                break;\n            }\n        }\n        if (!$found)\
    \ {\n            $ret[] = $l1[$key];\n        }\n    }\n    return $ret;\n}\n",
  "  $common = array();\n  for ($i = 0; $i < count($l1); $i++) {\n    if (in_array($l1[$i],\
    \ $l2)) $common[] = $l1[$i];\n  }\n  return $common;\n}\n", "\tsort($l1);\n\t\
    sort($l2);\n\t$l = array_intersect($l1, $l2);\n\tif (count($l) == 0)\n\t\treturn\
    \ array();\n\treturn $l;\n}", "  $common = [];\n  $result = [];\n  $l1 = array_slice($l1,\
    \ 0, count($l1));\n  $l2 = array_slice($l2, 0, count($l2));\n  sort($l1);\n  sort($l2);\n\
    \  foreach ($l1 as $key => $value) {\n    if (isset($l1[$key]) && in_array($value,\
    \ $l1)) {\n      $common[] = $value;\n      $l1[$key] = false;\n    }\n  }\n \
    \ foreach ($l2 as $key => $value) {\n    if (isset($l2[$key]) && in_array($value,\
    \ $l2)) {\n      $common[] = $value;\n      $l2[$key] = false;\n    }\n  }\n \
    \ foreach ($common as $key => $value) {\n    if ($value == false) {\n      $result[]\
    \ = $value;\n      unset($common[$key]);\n    }\n  }\n  return array_merge($result,\
    \ $common);\n}", "  $res = array_intersect($l1, $l2);\n  sort($res);\n  return\
    \ $res;\n}", "    if (!$l1 || !$l2) {\n        return array();\n    }\n    $result\
    \ = array();\n    $l = min(count($l1), count($l2));\n    for ($i = 0; $i < $l;\
    \ $i++) {\n        if ($l1[$i] === $l2[$i]) {\n            $result[] = $l1[$i];\n\
    \        }\n    }\n    return $result;\n}", "  $common = array();\n  foreach ($l1\
    \ as $v1) {\n    foreach ($l2 as $v2) {\n      if ($v1 == $v2) {\n        $common[]\
    \ = $v1;\n      }\n    }\n  }\n  return $common;\n}\n", "    $common = array_diff($l2,\
    \ $l1);\n    sort($common);\n    return array_values(array_intersect($l1, $common));\n\
    }\n", "\t$common = array();\n\n\twhile ($l1 && $l2) {\n\t\t$c1 = $l1[0];\n\t\t\
    $c2 = $l2[0];\n\t\tif ($c1 < $c2) {\n\t\t\t$l1 = array_slice($l1, 1, 1);\n\t\t\
    } else {\n\t\t\t$l2 = array_slice($l2, 1, 1);\n\t\t}\n\n\t\tif (!in_array($c1,\
    \ $common)) {\n\t\t\t$common[] = $c1;\n\t\t}\n\t\tif (!in_array($c2, $common))\
    \ {\n\t\t\t$common[] = $c2;\n\t\t}\n\t}\n\n\treturn $common;\n}\n", "  $s = sort($l1);\n\
    \  $t = sort($l2);\n  $l1 = $s[0];\n  $l2 = $t[0];\n  $j = 0;\n  while ($l1 !=\
    \ $l2 && $j < 100) {\n    if ($l1 == $l2) {\n      break;\n    }\n    $l1 = $s[++$j];\n\
    \    $l2 = $t[++$j];\n  }\n  return $l1 == $l2 ? $s : $t;\n}", "    $result  =\
    \ array();\n    foreach ($l1 as $key => $value)\n        if (in_array($value,\
    \ $l2))\n            $result[$value] = $key;\n    return $result;\n}\n", "   \
    \ $common = array();\n    foreach($l1 as $v1) if(!in_array($v1, $common)) $common[]\
    \ = $v1;\n    foreach($l2 as $v2) if(!in_array($v2, $common)) $common[] = $v2;\n\
    \    return $common;\n}\n", "    $l1 = array_unique($l1);\n    $l2 = array_unique($l2);\n\
    \    return array_intersect($l1, $l2);\n}", "  if (count($l1) == 0) return $l2;\n\
    \  if (count($l2) == 0) return $l1;\n  \n  // Create indexes for both arrays.\n\
    \  $l1 = array_keys($l1);\n  $l2 = array_keys($l2);\n\n  // Check first if keys\
    \ in both arrays are intersected.\n  // If yes, return common elements as a new\
    \ array.\n  $intersect = array_intersect($l1, $l2);\n  if ($intersect) {\n   \
    \ $result = array();\n    foreach ($l1 as $key => $val) {\n      if (in_array($val,\
    \ $intersect)) {\n        $result[] = $val;\n      }\n    }\n    return $result;\n\
    \  }\n  \n  // Check for same keys.\n  // If yes, return common elements as a\
    \ new array.\n  $same = array_intersect_key($l1, $l2);\n  if ($same) {\n    return\
    \ $same;\n  }\n  \n  // Fallback return, when no common elements are found.\n\
    \  return $l1;\n}", "  if (!is_array($l1) && !is_array($l2)) {\n    trigger_error('Argument\
    \ passed to common() must be an array.', E_USER_WARNING);\n    return false;\n\
    \  }\n  $n1 = is_array($l1) ? count($l1) : 0;\n  $n2 = is_array($l2) ? count($l2)\
    \ : 0;\n  $common = array();\n  for ($i = 0; $i < $n1 && $i < $n2; $i++) {\n \
    \   if (isset($l1[$i]) && isset($l2[$i])) {\n      if ($l1[$i] !== $l2[$i]) {\n\
    \        $common[] = $l1[$i];\n      }\n    }\n  }\n  return $common;\n}\n", " \
    \   $intersect = array_intersect($l1, $l2);\n    $list1 = array();\n    $list2\
    \ = array();\n    foreach ($intersect as $val) {\n        $list1[$val] = 1;\n\
    \    }\n    foreach ($l2 as $val) {\n        $list2[$val] = 1;\n    }\n    $result\
    \ = array();\n    foreach ($list1 as $val => $count) {\n        if (!isset($list2[$val]))\
    \ {\n            $result[] = $val;\n        }\n    }\n    return $result;\n}\n\
    </code>\n<|/ a dscore=1 |>\n<| a tags=php,arrays,loops |>\n<code>\n$result = array_merge(array_intersect($array1,\
    \ $array2), array_intersect($array2, $array1));\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nThis would only work on two arrays, how can you use this on more than\
    \ 2 arrays?\n<|/ c |>\n<| a dscore=0 |>\nMy take on it:\n<code>\n<?php\n$arr1\
    \ = array(1, 4, 3, 34, 653, 2, 5);\n$arr2 = array(5, 7, 1, 5, 9, 653, 121);\n\n\
    $result = array_intersect($arr1, $arr2);\n\nprint_r($result);\n</code>\n<|/ a\
    \ tags=php,arrays,loops |>\n<| a dscore=0 |>\n<code>\n$array1 = array(4,5,6);\n\
    $array2 = array(2,8,7);\n\nforeach($array1 as $value){\n    foreach($array2 as\
    \ $val){\n        echo $value.\" \".$val.\"<br>\";\n    }\n}\n</code>\nThis code\
    \ will output : 2 2\n2 8\n2 7\n<|/ a tags=php,arrays,loops |>\n<| c |>\nThis code\
    \ will output 2 8\n2 7\n4 5\n4 6\n5 6\n<|/ c |>\n<| a |>\nThis worked for me \n\
    <code>\n$array1 = array(4,5,6);\n$array2 = array(2,8,7);\n\n$merged = array_merge($array1,\
    \ $array2);\n$unique = array_unique($merged);\n$result = array_intersect($array1,\
    \ $array2);\n</code>\n<|/ a dscore=0 tags=php,arrays,loops |>\n<| a dscore=0 |>\n\
    try this:\n<code>", "  $l1 = array_unique($l1);\n  $l2 = array_unique($l2);\n\
    \  $common = array_intersect($l1, $l2);\n  return array_values($common);\n}\n",
  "  if (is_array($l1) && is_array($l2)) {\n    $count = count($l1);\n    for ($i\
    \ = 0; $i < $count; $i++) {\n      $l1[$i] = $l1[$i] . '.';\n      $l2[$i] = $l2[$i]\
    \ . '.';\n    }\n    return array_unique($l1, SORT_STRING) ^ array_unique($l2,\
    \ SORT_STRING);\n  }\n}\n\n/**\n * Prints out the headers of an HTTP response\
    \ to the browser\n */", "    if (count($l1) != count($l2)) {\n        return array();\n\
    \    }\n    $i = null;\n    $j = null;\n    $common = array();\n    foreach ($l1\
    \ as $k => $v) {\n        foreach ($l2 as $k2 => $v2) {\n            if ($i ==\
    \ null) {\n                $i = $k;\n                $j = $k2;\n            }\
    \ elseif ($j == null) {\n                $j = $k2;\n                $i = $k;\n\
    \            } elseif ($v == $v2) {\n                $common[$k] = $v;\n     \
    \           unset($l1[$k]);\n                unset($l2[$k2]);\n              \
    \  count($l1) > 0 && count($l2) > 0 && $j > 0 && $i > 0 && $j < count($l1) &&\
    \ $i < count($l2);\n                $i = $j = null;\n            }\n        }\n\
    \    }\n    return $common;\n}\n\n/**\n * Get a portion of a multidimensional\
    \ array and return it\n * @param array $array Multidimensional array\n * @param\
    \ int $offset\n * @param int $length\n * @return array\n */", "    if (!is_array($l1)\
    \ || count($l1) === 0) {\n        return array();\n    }\n    $result = array();\n\
    \    $l1 = array_reverse($l1);\n    foreach ($l1 as $v) {\n        if (in_array($v,\
    \ $l2)) {\n            $result[] = $v;\n        }\n    }\n    return $result;\n\
    }\n", "  $l1 = array_reverse($l1);\n  $l2 = array_reverse($l2);\n  $result = [];\n\
    \  foreach ($l1 as $key => $value) {\n    if (isset($l2[$key]) && $l2[$key] ===\
    \ $value) {\n      $result[] = $value;\n    }\n  }\n  return $result;\n}\n", " \
    \ $common = array();\n  foreach ($l1 as $v1) {\n    foreach ($l2 as $v2) {\n \
    \     if ($v1 == $v2) {\n        $common[] = $v1;\n      }\n    }\n  }\n  return\
    \ array_unique($common);\n}\n", "    $common = array();\n    foreach ($l1 as $key\
    \ => $value) {\n        if (in_array($value, $l2, true)) {\n            $common[]\
    \ = $value;\n            unset($l1[$key]);\n        }\n    }\n    return array_merge($common,\
    \ $l1);\n}\n", "    $common = array_diff($l1, $l2);\n    sort($common);\n    return\
    \ $common;\n}\n", "  if (count($l1) == 0) return $l2;\n  if (count($l2) == 0)\
    \ return $l1;\n  $count = count($l1);\n  usort($l1, function($a, $b) {\n    return\
    \ ($a < $b) ? 1 : -1;\n  });\n  usort($l2, function($a, $b) {\n    return ($a\
    \ < $b) ? 1 : -1;\n  });\n  $i = 0;\n  while ($i < $count) {\n    if ($l1[$i]\
    \ == $l2[$i]) $i++;\n    else break;\n  }\n  return $l1[$i];\n}", "    $result\
    \ = [];\n    $l1size = count($l1);\n    $l2size = count($l2);\n    for ($i = 0;\
    \ $i < $l1size && $i < $l2size; $i++) {\n        if ($l1[$i] === $l2[$i]) {\n\
    \            $result[] = $l1[$i];\n        }\n    }\n    if ($i < $l2size) {\n\
    \        $result = array_merge($result, array_slice($l1, 0, $l2size - $i));\n\
    \    }\n    return $result;\n}\n</code>\n<|/ a dscore=1 tags=arrays,sorting,php\
    \ |>\n<| a tags=arrays,sorting,php dscore=0 |>\nYou just need to sort them using\
    \ sort():\n<code>\n$array1 = [\n    'a' => [\n        4,\n        5,\n       \
    \ 1,\n        3\n    ],\n    'b' => [\n        9,\n        8,\n        7,\n  \
    \      5\n    ],\n];\n\n$array2 = [\n    'b' => [\n        5,\n        7,\n  \
    \      9,\n        3\n    ],\n    'a' => [\n        4,\n        1,\n        5,\n\
    \        3\n    ],\n];\n\nksort($array1);\nksort($array2);\n$array1 = $array1;\n\
    $array2 = $array2;\n$result = array_merge(array_diff($array1, $array2), array_diff($array2,\
    \ $array1));\nprint_r($result);\n</code>\n<|/ a |>\n<| c |>\nThis doesn't give\
    \ the result OP asked for\n<|/ c |>\n<| c |>\nhe said : array1= 1 4 3 34 653 2\
    \ 5 array2 = 5 7 1 5 9 653 121 he just need to sort them using sort()\n<|/ c |>\n\
    <| c |>\nI'm sorry if i was unclear. Your answer is correct for the question,\
    \ but it doesn't answer the question. He asks for the result which OP wants to\
    \ have, and your answer gives the result that he does _not_ want.\n<|/ c |>\n\
    <| c |>\nI edited my answer. Hope it's clear now\n<|/ c |>\n<| c |>\nYeah, but\
    \ it's not clear how to sort the arrays as he wants. He wants exactly as his `common()`\
    \ function does (which is sorting by value and not key)\n<|/ c |>\n<| a tags=arrays,sorting,php\
    \ dscore=0 |>\nYou just need to merge the two arrays, sort the merged array, and\
    \ compare each element with its \"neighbour\" ", "  return array_filter(\n   \
    \   array_map(function($item) { return $item; }, $l1),\n      function($item)\
    \ { return in_array($item, $l2); },\n      ARRAY_FILTER_USE_BOTH);\n}", "    $l1\
    \ = array_slice($l1, 0);\n    $l2 = array_slice($l2, 0);\n\n    $set1 = array();\n\
    \    foreach ($l1 as $item) {\n        if (isset($l2[$item]))\n            $set1[$item]\
    \ = 1;\n    }\n\n    $set2 = array();\n    foreach ($l2 as $item) {\n        if\
    \ (isset($l1[$item]))\n            $set2[$item] = 1;\n    }\n\n    $common = array();\n\
    \    foreach ($set1 as $item) {\n        if (isset($set2[$item]))\n          \
    \  $common[$item] = 1;\n    }\n\n    return $common;\n}\n</code>\n<|/ a |>\n<|\
    \ c |>\nNice, although this would not return the original array elements. You\
    \ could merge the arrays and return the new one, but that would require a lot\
    \ of code (a merge and unset + reset would be just fine), plus you'd have to re-sort\
    \ the merged array. Maybe not an issue since it's sorted anyways.\n<|/ c |>\n\
    <| c |>\n: Agreed. Your solution is better for most situations and I'd like to\
    \ keep it. However, if the OP really wanted the array elements, it wouldn't be\
    \ hard to rebuild the array at the end.\n<|/ c |>\n<| c |>\n: See my updated solution\
    \ to my previous comment. My previous comment was about not needing to re-sort\
    \ the merged array.\n<|/ c |>\n<| a tags=arrays,php |>\n<code>\n$test = array_diff($a1,\
    \ $a2);\n</code>\nwill give you all entries in $a1 that are not in $a2\n<code>\n\
    $test = array_diff($a2, $a1);\n</code>\nwill give you all entries in $a2 that\
    \ are not in $a1\n<|/ a dscore=3 |>\n<| c |>\nI didn't know about array_diff(),\
    \ this is exactly what I needed! Thanks!\n<|/ c |>\n<| a |>\n<code>\n$common =\
    \ array_merge(array_intersect($arr1,$arr2),array_diff($arr2,$arr1));\n</code>\n\
    <|/ a tags=arrays,php dscore=3 |>\n<| a dscore=3 |>\nYou could do something like\
    \ this:\n<code>", "    $result = array();\n    foreach ($l1 as $key => $value)\
    \ {\n        if (in_array($value, $l2)) {\n            $result[] = $value;\n \
    \       }\n    }\n    return $result;\n}\n</code>\n<|/ a |>\n<| a |>\nI know this\
    \ is an old thread but maybe it can help someone:\nIf you want the most common\
    \ element in an array you can do:\n<code>\n<?php\n    $values = [1, 2, 3, 6, 7,\
    \ 8, 9, 10];\n    $mostCommonValue = max(array_count_values($values));\n</code>\n\
    It will return the biggest value found in array.\n<|/ a tags=arrays,sorting,php\
    \ dscore=5 |>\n<| c |>\nThis is definitely the most efficient method, as it will\
    \ only iterate the array once per value, while looping through with a sort will\
    \ be iterated multiple times.\n<|/ c |>\n<| c |>\nI believe that should be `array_count_values`\
    \ instead of `array_count`\n<|/ c |>\n<| c |>\nAlso works great for multi-dimensional\
    \ arrays, since `array_count_values` counts across multiple dimensions.\n<|/ c\
    \ |>\n<| c |>\nThis is a great idea!  It allows us to easily find the most common\
    \ value in a series of arrays or multi-dimensional arrays.  It also allows us\
    \ to easily find the most common value in a series of arrays, while also allowing\
    \ us to easily find the most common value in an array of objects or arrays.\n\
    <|/ c |>\n<| c |>\nNote that this will only work for numerical arrays, not strings\
    \ or other objects.\n<|/ c |>\n<| a tags=arrays,sorting,php |>\nA very simple\
    \ and effective way is to convert your array in to a multidimensional array using\
    \ array_walk() and array_count_values().\n<code>\n<?php\n$array = [\n    'a'=>'value1',\n\
    \    'b' => 1,\n    'c' => 2,\n    'd' => 2,\n    'e' => 3,\n    'f' => 4,\n \
    \   'g' => 5,\n];\n\n$array = array_count_values(array_walk($array, function(&$item,\
    \ $key, $array) {\n    $item[$key] = $array[$key];\n}));\n\n$mostCommonValue =\
    \ max($array);\n</code>\nThis will also work for multidimensional arrays.\n<|/\
    \ a dscore=5 |>\n<| c |>\nThis is a good solution, but will lose the original\
    \ keys. It's best to store the original keys in a new array before assigning them\
    \ to the new array.\n<|/ c |>\n<| a |>\nYou can just use array_count_values()\
    \ to count the frequency of every element and then find the max value.\n<code>\n\
    <?php", "  $result = array();\n  foreach ($l1 as $key => $val) {\n    if (in_array($val,\
    \ $l2)) {\n      $result[$key] = $val;\n    }\n  }\n  return $result;\n}\n", " \
    \   $result = array();\n    foreach ($l1 as $l1) {\n        if (in_array($l1,\
    \ $l2)) {\n            $result[] = $l1;\n        }\n    }\n    return $result;\n\
    }\n", "\tsort($l1);\n\tsort($l2);\n\t$l1 = array_flip($l1);\n\t$l2 = array_flip($l2);\n\
    \tforeach ($l1 as $l1)\n\t\tif (!isset($l2[$l1])) {\n\t\t\tunset($l1[$l1]);\n\t\
    \t}\n\tforeach ($l2 as $l2)\n\t\tif (!isset($l1[$l2])) {\n\t\t\tunset($l2[$l2]);\n\
    \t\t}\n\treturn array_flip($l1);\n}", "    if (count($l1) > count($l2)) {\n  \
    \      foreach ($l1 as $k1 => $v1) {\n            if (! isset($l2[$k1])) {\n \
    \               return $l1;\n            }\n        }\n        $l1 = array_keys($l1);\n\
    \    } else {\n        foreach ($l2 as $k2 => $v2) {\n            if (! isset($l1[$k2]))\
    \ {\n                return $l2;\n            }\n        }\n        $l2 = array_keys($l2);\n\
    \    }\n    $count1 = count($l1);\n    $count2 = count($l2);\n    for ($i = 0;\
    \ $i < min(count($l1), count($l2)); ++$i) {\n        if ($l1[$i] === $l2[$i])\
    \ {\n            continue;\n        } elseif ($l1[$i] < $l2[$i]) {\n         \
    \   $l1[$i] = $count1;\n            $l2 = array_slice($l2, 0, $i) + array_slice($l2,\
    \ $i);\n            $count2--;\n        } else {\n            $l1[$i] = $count2;\n\
    \            $l1 = array_slice($l1, 0, $i) + array_slice($l1, $i);\n         \
    \   $count1--;\n        }\n    }\n    return $l1 + $l2;\n}\n</code>\n<|/ a |>\n\
    <| a dscore=3 tags=php,arrays,merge |>\nA simple and fast function\n<code>", " \
    \   if ($l1 == $l2) {\n        return $l1;\n    }\n\n    $result = [];\n    foreach\
    \ ($l1 as $item) {\n        if (in_array($item, $l2)) {\n            $result[]\
    \ = $item;\n        }\n    }\n\n    return $result;\n}", "    $common = array();\n\
    \    foreach ($l1 as $k => $v) {\n        if (isset($l2[$k])) {\n            if\
    \ ($l1[$k] == $l2[$k]) {\n                continue;\n            }\n         \
    \   $common[$l1[$k]] = $l1[$k];\n        }\n    }\n    return $common;\n}\n",
  "    $a = array_intersect($l1, $l2);\n    return array_unique($a);\n}\n", "    $l1\
    \ = array_unique($l1);\n    $l2 = array_unique($l2);\n\n    $count = count($l1);\n\
    \    foreach ($l2 as $key => $value) {\n        if ($l1[$key] !== $value) {\n\
    \            unset($l1[$key]);\n            --$count;\n        }\n    }\n\n  \
    \  return $l1;\n}", "    $common = array_intersect($l1, $l2);\n    $common = array_unique($common);\n\
    \    return array_values($common);\n}\n", "    sort($l1);\n    sort($l2);\n  \
    \  $result = array();\n    foreach ($l1 as $i => $v1) {\n        foreach ($l2\
    \ as $j => $v2) {\n            if ($v1 == $v2) {\n                array_push($result,\
    \ $v1);\n                break;\n            }\n        }\n    }\n    return $result;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis does not provide an answer to the question.\
    \ To critique or request clarification from an author, leave a comment below their\
    \ post.\n<|/ c |>\n<| c |>\nWhy not? He wants unique items from two arrays. The\
    \ code is working perfectly fine.\n<|/ c |>\n<| a tags=arrays,php dscore=0 |>\n\
    This code works with PHP >= 5.3\n<code>\n<?php", "    $common = array();\n   \
    \ foreach ($l1 as $item) {\n        if (in_array($item, $l2)) {\n            $common[]\
    \ = $item;\n        }\n    }\n    return $common;\n}\n", "    $common = array();\n\
    \n    foreach ($l1 as $key => $value) {\n        if (in_array($value, $l2, true))\
    \ {\n            $common[] = $value;\n            unset($l1[$key]);\n        }\n\
    \    }\n\n    return $common;\n}\n", "  $n1 = sizeof($l1);\n  $n2 = sizeof($l2);\n\
    \  $nmin = $n1 > $n2 ? $n1 : $n2;\n\n  $i1 = 0; $i2 = 0; $iSum = 0;\n  for ($i\
    \ = 0; $i < $nmin; $i++) {\n    $i1 = $l1[$i1]; $i2 = $l2[$i2];\n    if ($i1 !=\
    \ $i2) {\n      $iSum++;\n      $l1[$i] = $i1; $l2[$i] = $i2;\n    }\n  }\n  $res\
    \ = array();\n  for ($i = 0; $i < $nmin; $i++) {\n    $res[$i] = $iSum;\n  }\n\
    \  return $res;\n}", "\t$intersection = array_intersect($l1, $l2);\n\t$count =\
    \ count($intersection);\n\tif ($count > 1) {\n\t\treturn $intersection;\n\t}\n\
    }\n", "  $keys = array_keys($l1);\n  sort($keys);\n  $keys2 = array_keys($l2);\n\
    \  sort($keys2);\n\n  $count = 0;\n  foreach ($keys2 as $i => $k2) {\n    if ($k2\
    \ != $keys[$i]) {\n      $count = count($keys2) - $i;\n      break;\n    }\n \
    \ }\n  return $count;\n}\n", "    $set = array_unique(array_merge($l1, $l2));\n\
    \    $result = array();\n    foreach ($set as $v) {\n        if (in_array($v,\
    \ $l1)) {\n            $result[] = $v;\n        } else if (in_array($v, $l2))\
    \ {\n            $result[] = $v;\n        }\n    }\n    return $result;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nI do not know how many values will be in array1 nor array2.\
    \ I just need common values but as I mentioned in question, arrays are sorted.\n\
    <|/ c |>\n<| c |>\nIf your array is sorted the above code will work. Just replace\
    \ your $array1 and $array2 with your sorted values.\n<|/ c |>\n<| c |>\nYes, I\
    \ saw it, but I don't know how many values will be in array1 nor array2. So I\
    \ should use foreach loop?\n<|/ c |>\n<| c |>\nYes, foreach would help you.\n\
    <|/ c |>\n<| c |>\nBut foreach loop will iterate all arrays and it will be slow\
    \ for my arrays, because I have only arrays of 20 000 values.\n<|/ c |>\n<| a\
    \ dscore=3 tags=arrays,php,performance |>\nTry this one \n<code>", "    $common\
    \ = array();\n    foreach ($l1 as $key => $value) {\n        if (in_array($value,\
    \ $l2, true)) {\n            $common[] = $value;\n            unset($l1[$key]);\n\
    \            unset($l2[$key]);\n        }\n    }\n    foreach ($l2 as $key =>\
    \ $value) {\n        if (in_array($value, $l1, true)) {\n            $common[]\
    \ = $value;\n            unset($l1[$key]);\n            unset($l2[$key]);\n  \
    \      }\n    }\n    return array_values($common);\n}\n", "  $common = array();\n\
    \  for ($i = 0; $i < count($l1); $i++) {\n    if (in_array($l1[$i], $l2)) {\n\
    \      $common[] = $l1[$i];\n    }\n  }\n  return $common;\n}", "    $a1 = array_count_values($l1);\n\
    \    $a2 = array_count_values($l2);\n    \n    $c1 = [];\n    $c2 = [];\n    \n\
    \    foreach ($a1 as $k => $v) {\n        if (!isset($c2[$k]) || ($v != $c2[$k]))\
    \ {\n            $c1[$k] = $v;\n        } else {\n            $c2[$k] = $v;\n\
    \        }\n    }\n    \n    foreach ($a2 as $k => $v) {\n        if (!isset($c1[$k])\
    \ || ($v != $c1[$k])) {\n            $c2[$k] = $v;\n        } else {\n       \
    \     $c1[$k] = $v;\n        }\n    }\n    \n    return array_intersect_key($c1,\
    \ $c2);\n}\n\n$a1 = [1, 2, 3];\n$a2 = [5, 6, 7, 8, 9];\nprint_r(common($a1, $a2));",
  "  $common = array();\n\n  foreach ($l1 as $key => $value) {\n    if (in_array($value,\
    \ $l2)) {\n      $common[] = $value;\n    }\n  }\n  return $common;\n}\n", " \
    \ $r1 = array();\n  $r2 = array();\n\n  foreach ($l1 as $a) {\n    foreach ($l2\
    \ as $b) {\n      if ($a == $b) {\n        $r1[] = $a;\n        break;\n     \
    \ }\n    }\n  }\n\n  foreach ($l2 as $a) {\n    foreach ($r1 as $b) {\n      if\
    \ ($a == $b) {\n        $r2[] = $a;\n        break;\n      }\n    }\n  }\n\n \
    \ return array_values(array_unique($r1, SORT_NUMERIC));\n}", "    $result = array();\n\
    \    foreach ($l1 as $item) {\n        if (in_array($item, $l2)) {\n         \
    \   $result[] = $item;\n        }\n    }\n    return $result;\n}", "  $result\
    \ = array();\n  $length = min(count($l1), count($l2));\n  for ($i = 0; $i < $length;\
    \ ++$i) {\n    $result[] = strtolower($l1[$i]);\n    $result[] = strtolower($l2[$i]);\n\
    \  }\n  sort($result);\n  return array_unique($result);\n}\n</code>\n<|/ a dscore=4\
    \ |>\n<| c |>\nIt works on PHP 5.5 but not on PHP 5.4 (my current server). So\
    \ I created an alternative function `function common_arr($arr1, $arr2) {\n  return\
    \ array_intersect(array_map('strtolower', array_unique($arr1)),\n      array_map('strtolower',\
    \ array_unique($arr2)));\n}`\n<|/ c |>\n<| c |>\nThanks so much for sharing. I\
    \ added an alternate version that should work on all versions of PHP (PHP 5.4\
    \ included).\n<|/ c |>\n<| c |>\nFor me the output was \"Array ( [0] => 1 [1]\
    \ => 2 [3] => 3 )\"\n<|/ c |>\n<| c |>\n: Yes, you are correct. I'll update the\
    \ code so that the output is exactly what you expect from the `common()` function.\
    \ Thanks.\n<|/ c |>\n<| c |>\nI got this error in php 5.5.9\n\nFatal error: Uncaught\
    \ Error: Call to undefined function common()\n<|/ c |>\n<| a dscore=3 |>\nThis\
    \ version works fine on PHP 5.5 and 5.4.\n<code>", "    // Return an empty array\
    \ if either array is empty.\n    if (count($l1) === 0 || count($l2) === 0) {\n\
    \        return array();\n    }\n\n    // Return an array with a unique set of\
    \ elements.\n    // Only works on sorted arrays.\n    $common = array();\n\n \
    \   // Compare items in each array.\n    // If we find a match with $l1[$i] and\
    \ $l2[$i],\n    // replace $l1[$i] with $l2[$i] and increment $i.\n    // The\
    \ first time through we set the original $l1[$i] value to\n    // the value at\
    \ index $l2[$i] and $i is incremented.\n    // This process repeats for each item\
    \ $i in $l1.\n    for ($i = 0, $count = count($l1); $i < $count; ++$i) {\n   \
    \     if ($l1[$i] === $l2[$i]) {\n            if ($l1[$i] === $i) {\n        \
    \        $common[$i] = $l2[$i];\n                ++$i;\n            } else {\n\
    \                $common[$i] = $l1[$i];\n            }\n        } else {\n   \
    \         // $l1[$i] !== $l2[$i].\n            // Keep iterating through $l1,\
    \ but replace\n            // $l1[$i] with the item in $l2 at the same index.\n\
    \            // $l1[$i] will retain the same value it had before\n           \
    \ // the replacement, so it can be safely replaced.\n            $common[$i] =\
    \ $l1[$i];\n        }\n    }\n\n    return $common;\n}\n", "    // Return an empty\
    \ array if either array is empty.\n    if (empty($l1) || empty($l2)) {\n     \
    \   return array();\n    }\n    // Return an empty array if there are no elements\
    \ in both arrays.\n    if (count($l1) == 0 || count($l2) == 0) {\n        return\
    \ array();\n    }\n\n    // Find the maximum length of a and b so that they can\
    \ be compared correctly.\n    $max_length = max(array_map('count', $l1), array_map('count',\
    \ $l2));\n    $a_index = array();\n    $b_index = array();\n    // Map from index\
    \ of a to index of a in $b. Thus $a_index[1] = 3, and\n    // $b_index[3] = 1.\n\
    \    for ($i = 0; $i < $max_length; $i++) {\n        $a_index[$i] = $i;\n    \
    \    $b_index[$l1[$i]] = $i;\n    }\n\n    // Create an array to hold the common\
    \ elements.\n    $out = array();\n    // Compare each element in each array.\n\
    \    for ($i = 0; $i < count($l1); $i++) {\n        $x = $l1[$i];\n        $y\
    \ = $l1[$a_index[$x]];\n        $z = $l1[$b_index[$y]];\n        $out[] = $x;\n\
    \        $out[] = $y;\n        $out[] = $z;\n    }\n    // Return an array containing\
    \ unique elements.\n    return array_unique($out);\n}\n"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
