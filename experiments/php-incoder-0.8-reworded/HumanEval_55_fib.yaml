name: HumanEval_55_fib
language: php
prompt: "<?php\n// Return n-th Fibonacci number.\n// >>> fib(10)\n// 55\n// >>> fib(1)\n\
  // 1\n// >>> fib(8)\n// 21\nfunction fib($n) {\n"
tests: "function candidate(...$args) {\n    return fib(...$args);\n}\n\nfunction test():\
  \ void {\n    if (candidate(10) !== 55) { throw new Exception(\"Test failed!\");\
  \ }\n    if (candidate(1) !== 1) { throw new Exception(\"Test failed!\"); }\n  \
  \  if (candidate(8) !== 21) { throw new Exception(\"Test failed!\"); }\n    if (candidate(11)\
  \ !== 89) { throw new Exception(\"Test failed!\"); }\n    if (candidate(12) !==\
  \ 144) { throw new Exception(\"Test failed!\"); }\n}\n\ntest();"
completions: ["  return fib(static::num($n), $n-1);\n}", "    return ($n < 2) ? 1\
    \ : fib( ($n - 1) ) + fib( ($n - 2) );\n}\n", "    if ($n < 2) {\n        return\
    \ 1;\n    }\n    return fib(--$n) + fib(--$n);\n}\n", "    if ($n < 2) {\n   \
    \     return 1;\n    }\n    return fib(--$n) + fib(--$n);\n}", "\tif ($n < 0)\
    \ {\n\t\tthrow new Exception(\"fib() requires an integer >= 0\");\n\t}\n\n\tif\
    \ ($n <= 1) {\n\t\treturn $n;\n\t}\n\n\treturn fib(floor($n / 2) + $n - 1) + fib(floor($n\
    \ / 2) - $n - 1);\n}\n", "  if ($n <= 1) {\n    return 1;\n  }\n  return fib($n\
    \ - 1) + fib($n - 2);\n}", "    if ($n <= 1) return $n;\n\n    $a = 0; $b = 1;\n\
    \    while ($n < $a) $n = $a + $b;\n    return $n;\n}\n", "    if ($n < 2) { return\
    \ 1; }\n    return fib(--$n) + fib(--$n);\n}", "    if ($n < 2) {\n        return\
    \ $n;\n    }\n    return fib($n-2) + fib($n-1);\n}\n", "\tif ($n < 2) {\n\t\t\
    return $n;\n\t}\n\treturn fib(--$n) + fib(--$n);\n}\n", "\treturn $n <= 2 ? $n\
    \ : fib(--$n - 1) + fib(--$n);\n}\n\n/**\n * Generate all possible permutations\
    \ of a string.\n *\n * @param string $str The string to permute.\n * @return string\
    \ An array of the permuted string.\n */", "    if ($n < 2) return $n;\n    return\
    \ fib($n - 1) + fib($n - 2);\n}", "    if ($n < 2) return $n;\n    return fib(--$n)\
    \ + fib(--$n);\n}\n\n$starttime = microtime(true);\nfor($i=0;$i<10000;$i++) {\n\
    \    fib($i);\n}\necho microtime(true)-$starttime;\n", "    if ($n <= 1) return\
    \ $n;\n    return fib($n - 1) + fib($n - 2);\n}", "    if ($n < 2) {\n       \
    \ return 1;\n    }\n    return fib(--$n) + fib(--$n);\n}", "    $prev = 0;\n \
    \   $next = 1;\n    for ($i = 0; $i < $n; ++$i) {\n        $prev = $next;\n  \
    \      $next = $prev + $next;\n    }\n    return $next;\n}\n", "  if ($n < 2)\
    \ {\n    return 1;\n  }\n  return fib(fib(fib($n - 1))) + $n;\n}", "    if ($n\
    \ <= 1) return 1;\n    return fib(n - 1) + fib(n - 2);\n}\n", "\tif ($n < 2) {\n\
    \t\treturn $n;\n\t} elseif ($n <= 3) {\n\t\treturn fib($n - 1) + fib($n - 2);\n\
    \t} else {\n\t\treturn fib($n - 1) + fib($n - 2);\n\t}\n}\n", "  // Return Fibonacci\
    \ number for integer n.\n  return isset($a) ? $a[\"F($n)\"] : fib($n-1) + fib($n-2);\n\
    }\n", "    if ($n <= 1) return 1;\n    return fib($n - 1) + fib($n - 2);\n}\n",
  "\t$cache[$n] = $cache[$n - 2] + ($cache[$n - 1] || 0);\n\treturn $cache[$n];\n}",
  "\t$a = 1;\n\t$b = 1;\n\t$c = 1;\n\t$fib = 0;\n\n\twhile($n > 0) {\n\t\t$fib = $a\
    \ + $c;\n\t\t$c = $b;\n\t\t$b = $fib;\n\t\t$a++;\n\t\t$n--;\n\t}\n\n\treturn $fib;\n\
    }\n", "\treturn ($n < 1)? 1 : (fib(floor($n/2)) + fib(floor($n%2)));\n}", "\t\
    return (is_numeric($n) && $n <= 2) ? $n : (fib($n - 1) + fib($n - 2));\n}\n$fib10\
    \ = fib(10);\n$fib1 = fib($_GET['id']);\necho 'Fibonacci: ' . $fib10 . ' <-> '\
    \ . $fib1;", "  return array_reduce(range(1,$n),function($c,$k){return $c+$k;});\n\
    }\n", "    if ($n <= 2) {\n        return 1;\n    } else {\n        return fib(fib(--$n))\
    \ + (--$n);\n    }\n}", "    if ($n < 2) {\n        return $n;\n    }\n\n    return\
    \ fib(--$n) + fib(--$n);\n}\n\nclass A{\n    private $a = 1;\n    private $b =\
    \ 1;\n    public function __construct(){\n        echo $this->a;\n    }\n    public\
    \ function set_a($a){\n        $this->a = $a;\n    }\n    public function get_a(){\n\
    \        return $this->a;\n    }\n    public function set_b($b){\n        $this->b\
    \ = $b;\n    }\n    public function get_b(){\n        return $this->b;\n    }\n\
    }\nclass B extends A{\n    private $c = 1;\n    private $d = 1;\n    public function\
    \ __construct(){\n        echo $this->a;\n        echo $this->b;\n        echo\
    \ $this->c;\n        echo $this->d;\n    }\n}\n\nclass C extends B{\n    private\
    \ $e = 1;\n    private $f = 1;\n    public function __construct(){\n        echo\
    \ $this->a;\n        echo $this->b;\n        echo $this->c;\n        echo $this->d;\n\
    \        echo $this->e;\n        echo $this->f;\n    }\n}\n\nclass D extends C{\n\
    \    private $g = 1;\n    public function __construct(){\n        echo $this->a;\n\
    \        echo $this->b;\n        echo $this->c;\n        echo $this->d;\n    \
    \    echo $this->e;\n        echo $this->f;\n        echo $this->g;\n    }\n}\n\
    class E extends D{\n    private $h = 1;\n    public function __construct(){\n\
    \        echo $this->a;\n        echo $this->b;\n        echo $this->c;\n    \
    \    echo $this->d;\n        echo $this->e;\n        echo $this->f;\n        echo\
    \ $this->g;\n        echo $this->h;\n    }\n}\nclass F extends E{\n    private\
    \ $i = 1;\n    public function __construct(){\n        echo $this->a;\n      \
    \  echo $this->b;\n        echo $this->c;\n        echo $this->d;\n        echo\
    \ $this->e;\n        echo $this->f;\n        echo $this->g;\n        echo $this->h;\n\
    \        echo $this->i;\n    }\n}\nclass G extends F{\n    private $j = 1;\n \
    \   public function __construct(){\n        echo $this->a;\n        echo $this->b;\n\
    \        echo $this->c;\n        echo $this->d;\n        echo $this->e;\n    \
    \    echo $this->f;\n        echo $this->g;\n        echo $this->h;\n        echo\
    \ $this->i;\n        echo $this->j;\n    }\n}\n\nclass H{\n    private $k = 1;\n\
    \    private $l = 1;\n    public function __construct(){\n        echo $this->k;\n\
    \        echo $this->l;\n    }\n}\n\nclass I extends ", "\tif ($n < 2)\n\t\treturn\
    \ 1;\n\treturn fib(--$n) + fib(--$n);\n}\n", "  if ($n <= 2) return $n;\n  return\
    \ fib(n - 2) + fib(n - 1);\n}", "    if ($n < 2) return $n;\n    return fib($n\
    \ - 1) + fib($n - 2);\n}\n", "\t$fibonacci[$n] = isset($fibonacci[$n])\n\t\t?\
    \ $fibonacci[$n]\n\t\t: ($fibonacci[$n] = fib($n - 1) + fib($n - 2));\n\treturn\
    \ $fibonacci[$n];\n}\n\n/**\n * Return Fibonacci series up to given value or run\
    \ indefinitely if value\n * is less.\n *\n * @param $limit\n * @param $value\n\
    \ * @return mixed\n */", "  if ($n <= 1) return 1;\n  return fib(--$n) + fib(--$n);\n\
    }\n", "\t$a = isset($a) ? $a : 1;\n\t$b = isset($b) ? $b : 0;\n\tfor ( ; $n <\
    \ 0; $n--, $a++, $b++) {\n\t\techo $a;\n\t}\n\treturn $b;\n}", "    if ($n <=\
    \ 2) {\n        return 1;\n    }\n    return fib(floor($n / 2)) + fib(floor($n\
    \ / 2) - 1);\n}", "    return ($n < 2) ? 1 : fib($n-2) + fib($n-1);\n}\n", " \
    \ return fib(--$n).($n>1 ? fib(--$n) : $n);\n}\n", "  if ($n < 2) {\n    return\
    \ $n;\n  }\n  return fib(--$n - 1) + fib(--$n);\n}", "    if ($n < 2) {\n    \
    \    return 1;\n    }\n    return fib(n - 1) + fib(n - 2);\n}\n", "  $x = 0;\n\
    \  $y = 0;\n  while ($n < 0 || $n < $x) { $x += $y; $y += $x; $n++; }\n  return\
    \ $y;\n}\n\n$f = fib($i);\necho $f; ?>\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    If you're going to do this, it's worth checking the value you're passing to fib,\
    \ it's possible someone could pass in 0 and get an infinite loop, and you'd be\
    \ in trouble\n<|/ c |>\n<| c |>\nThis answer has the potential to cause a stack\
    \ overflow if the argument is large enough.\n<|/ c |>\n<| a |>\nHere is another\
    \ way to calculate the nth Fibonacci number:\n<code>\n<?php\n", "    if ($n <\
    \ 2) {\n        return 1;\n    }\n\n    if ($n < 3) {\n        return $n;\n  \
    \  }\n\n    return fib($n - 1) + fib($n - 2);\n}", "  if ($n < 0) return 0;\n\
    \  if ($n == 0) return 1;\n  if ($n == 1) return 1;\n  return fib(floor($n/2))\
    \ + fib(floor($n%2));\n}\n", "\treturn ($n <= 1) ? $n : fib($n - 1) + fib(--$n);\n\
    }", "  return is_int($n) ? $n < 2 ? 1 : fib($n-1) + fib($n-2)\n              \
    \ : $n\n}", "    if ($n <= 2) return $n;\n    return fib($n - 2) + fib($n - 1);\n\
    }", "\tif ($n < 2) {\n\t\treturn $n;\n\t}\n\treturn fib(--$n) - fib(--$n);\n}\n\
    \n$start = microtime(true);\n\n$n = 0;\nfor ($i = 0; $i < $limit; $i++) {\n\t\
    $n++;\n\t$sum += fib($n) / $n;\n}\necho 'PHP Fibonacci Sum: ' . $sum . ' (' .\
    \ sprintf('%.5f', $limit / $i . ' ops/sec') . ')' . \"\\n\";\n$end = microtime(true);\n\
    $time = $end - $start;\necho 'Time: ' . $time . ' (' . sprintf('%.5f', $time /\
    \ $i . ' ops/sec') . ')' . \"\\n\";", "\t$a = 1; $b = 1;\n\tfor ($i = 0; $i <\
    \ $n; $i++) {\n\t\t$c = $a + $b;\n\t\t$a = $b;\n\t\t$b = $c;\n\t}\n\treturn $c;\n\
    }\n", "    if ($n <= 1) return 1;\n    return fib(--$n) + fib(--$n);\n}", "\t\
    if ($n <= 1) return 1;\n\treturn fib(n - 1) + fib(n - 2);\n}\n", "    return $n\
    \ < 2 ? $n : fib(n - 1) + fib(n - 2);\n}", "    $prev = $first = $second = 0;\n\
    \    for ($i = 0; $i < $n; ++$i) {\n        $prev = $second;\n        $second\
    \ = $first + $prev;\n        $first = $second;\n    }\n    return $first;\n}\n",
  "    if ($n < 2) {\n        return 1;\n    }\n    return fib(--$n) + fib(--$n);\n\
    }\n", "\tif ($n < 2) {\n\t\t$f = 1;\n\t} else {\n\t\t$f = fib(int($n/2)) + fib(int($n%2));\n\
    \t}\n\treturn $f;\n}\n", "  if ($n < 2) {\n    return 1;\n  }\n  return fib(--$n)\
    \ + fib(--$n);\n}\n\n/**\n * Convert English letters to numbers.\n *\n * Use `strtoupper()`\
    \ to preserve case.\n *\n * This is useful for creating tag clouds.\n */", " \
    \   if ($n < 2) {\n        return 1;\n    }\n    return fib(n - 2) + fib(n - 1);\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a |>\nTo get last two elements without looping\
    \ through whole array, use this code\n<code>\n$lasttwo = array_slice($arr, -2);\n\
    </code>\n<|/ a tags=php,arrays,recursion dscore=1 |>\n<| a |>\n<code>", "    if\
    \ ($n === 0) return 0;\n    if ($n === 1) return 1;\n    return fib($n - 1) +\
    \ fib($n - 2);\n}\n", "  if ($n < 2) {\n    return 1;\n  }\n\n  if ($n < 4) {\n\
    \    return $n;\n  }\n\n  return fib($n - 2) + fib($n - 3);\n}", "  if ($n < 2)\
    \ {\n    return $n;\n  }\n\n  return fib($n - 1) + fib($n - 2);\n}\n\n$fibs =\
    \ [];\n$fibs[0] = 0;\n$fibs[1] = 1;\nfor ($i = 2; $i < 10000; $i++) {\n    $fibs[]\
    \ = fib($i);\n}\n\n$fibs[89999];\n$fibs[89999];\n$fibs[89999];\n", "  if ($n <\
    \ 3) {\n    return $n;\n  }\n  return fib(n - 1) + fib(n - 2);\n}\n</code>\n<|/\
    \ a tags=fibonacci,php |>\n<| c |>\nThanks for this, it works nicely for me. I\
    \ also found this to be the fastest solution, though it uses a recursive function.\
    \ Here is the benchmark of mine that shows recursive version is consistently the\
    \ fastest:\nhttps://gist.github.com/leehdo/74d2770d15cc09e546cb\n<|/ c |>\n<|\
    \ c |>\nRecursive functions can be dangerous for some programs. A recursive function\
    \ can cause a stack overflow for large values of `n` - it may crash your webserver\
    \ for example if you have a large recursion depth.\n<|/ c |>\n<| c |>\n\"Recursive\
    \ functions can be dangerous\" - what does it mean?\n<|/ c |>\n<| c |>\nA recursive\
    \ function can call itself recursively and cause a stack overflow. It can make\
    \ your web server crash, and if its not configured correctly it could easily crash\
    \ your computer. Recursion will always eventually reach a point where it either\
    \ crashes your computer or your webserver, which can lead to some very nasty errors.\
    \ \"nasty errors\" are a bad mojo.\n<|/ c |>\n<| a |>\nThis is a recursive solution.\n\
    <code>\n/**\n * $n int\n * int\n */", "\t$prev  = $curr = 1;\n\t$result = $prev;\n\
    \t\n\tfor ($i = 2; $i <= $n; $i++) {\n\t\t$result = $curr + $prev;\n\t\t$prev\
    \   = $curr;\n\t\t$curr   = $result;\n\t}\n\treturn $result;\n}", "\treturn (is_null($n))\
    \ ? 0 : (is_numeric($n)) ? fib($n - 1) + fib($n - 2) : $n;\n}\n", "    if ($n\
    \ === 0)\n        return 0;\n    if ($n === 1)\n        return 1;\n    if ($n\
    \ === 2)\n        return 2;\n    return fib($n - 1) + fib($n - 2);\n}\n", "\t\
    if ($n <= 0) return 0;\n\tif ($n <= 1) return 1;\n\treturn fib($n - 1) + fib(n\
    \ - 2);\n}\n\n/*\n * PHP QR Code encoder\n *\n * Based on libqrencode C library\
    \ distributed under LGPL 2.1\n * Copyright (C) 2006, 2007, 2008, 2009 Kentaro\
    \ Fukuchi <removed@example.com>\n *\n * PHP QR Code is distributed under LGPL\
    \ 3\n * Copyright (C) 2010 Dominik Dzienia <deltalab at poczta dot fm>\n *\n *\
    \ This library is free software; you can redistribute it and/or\n * modify it\
    \ under the terms of the GNU Lesser General Public\n * License as published by\
    \ the Free Software Foundation; either\n * version 3 of the License, or any later\
    \ version.\n *\n * This library is distributed in the hope that it will be useful,\n\
    \ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY\
    \ or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License\
    \ for more details.\n *\n * You should have received a copy of the GNU Lesser\
    \ General Public\n * License along with this library; if not, write to the Free\
    \ Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301\
    \ USA\n */\n", "\tif ($n < 0 || $n === 1 || $n === 2) return $n;\n\treturn fib($n\
    \ - 1) + fib($n - 2);\n}\n", "  if ($n <= 1) return $n;\n\n  return fib(floor($n/2))\
    \ + fib(floor($n%2));\n}", "  if ($n < 0 || $n === 0 || $n === 1) return $n;\n\
    \  return fib($n - 1) + fib($n - 2);\n}\n\n$fib = fib($n);", "    if($n < 2) return\
    \ $n;\n    return fib(--$n) + fib(--$n);\n}\n", "  $fib = [0, 1];\n  $f = 1;\n\
    \  while ($n < 2) {\n    $fib[] = $f;\n    $f = $fib[$f] + $fib[$f - 1];\n   \
    \ $n--;\n  }\n  return $fib[$n];\n}\n", "    if ($n < 2) return $n;\n    return\
    \ fib($n - 1) + fib($n - 2);\n}", "    return isset($cache[$n]) ? $cache[$n] :\
    \ ($cache[$n] = isset($cache[$n - 1]) ? $cache[$n - 1] + $cache[$n - 2] : $n -\
    \ 2);\n}\n</code>\n<|/ a tags=fibonacci,php,caching dscore=1 |>\n<| a |>\nYou\
    \ could use the cache to store a value that indicates whether the last function\
    \ call was successful or not. Here's an example:\n<code>\n<?php\n\n$cached = array();\n",
  "  $fib = [];\n  fib(0, $fib, 0, $n);\n  return $fib[$n];\n}\n", "    if ($n <=\
    \ 0) return 0;\n    if ($n === 1) return 1;\n    return fib($n - 1) + fib($n -\
    \ 2);\n}\n$a = fib($a);\necho 'a = '.$a.'<br>';", "    return array_reduce(range($n-2),\
    \ function($acc, $item) { return $item+$acc; }, 0);\n}\n", "  if ($n === 0) {\n\
    \    return 0;\n  }\n  if ($n <= 2) {\n    return $n;\n  }\n  $a = fib($n - 1);\n\
    \  $b = fib($n - 2);\n  return $a + $b;\n}", "\treturn (1 === $n) ? 1 : fib($n\
    \ - 1) + fib($n - 2);\n}\n</code>\n<|/ a dscore=4 tags=fibonacci,recursion,php\
    \ |>\n<| c |>\nJust a note that this is only fib that returns the nth number as\
    \ opposed to the Fibonacci numbers. That is, if your looking for the Fibonacci\
    \ number of say 4 you would simply do fib($n) - fib(1) to get your number and\
    \ not the Fibonacci number. Thanks for this answer though! This was extremely\
    \ helpful.\n<|/ c |>\n<| a tags=fibonacci,recursion,php dscore=4 |>\n<code>\n\
    <?php\n", "  if ($n < 2) { return 1; }\n  return fib($n - 1) + fib($n - 2);\n}",
  "\tif ($n <= 2) {\n\t\treturn $n;\n\t} else {\n\t\treturn fib(n - 1) + fib(n - 2);\n\
    \t}\n}", "\tif ($n <= 2) {\n\t\treturn $n;\n\t}\n\treturn fib(n - 1) + fib(n -\
    \ 2);\n}", "    $nums = [0,1];\n    for ($i=2;$i<$n;$i++) {\n        $nums[$i]\
    \ = $nums[$i-1] + $nums[$i-2]\n    }\n    return $nums[$n];\n}", "\treturn (isset($n)\
    \ ? fib($n-2) + fib($n-1) : 1);\n}\n", "    return ($n <= 1) ? $n : (fib($n -\
    \ 1) + fib($n - 2));\n}\n</code>\n<|/ a dscore=5 tags=php,recursion,fibonacci\
    \ |>\n<| c |>\nGood work, though I prefer `fib(10)` over `fib('10')`\n<|/ c |>\n\
    <| c |>\nYeah, but thats what OP asked for. As long as we have the number as string\
    \ we can use that to calculate it.\n<|/ c |>\n<| c |>\nThis code is working fine,\
    \ but I got the output by adding print statement in every recursion level & it\
    \ gives the right output. Why it prints multiple times ?\n<|/ c |>\n<| c |>\n\
    I have no idea what you are asking here.\n<|/ c |>\n<| c |>\nThis is great!  I\
    \ love the recursion.  I wonder why the fib table doesn't have 0's in the first\
    \ few places.  Like why do we need the \"if($n <= 1)\" part.  Just seems like\
    \ there should be another way of doing this that would be more performant.\n<|/\
    \ c |>\n<| a dscore=5 |>\n<code>", "  return $n <= 0 ? 0 : ($n <= 1 ? 1 : fib(floor($n/2))\
    \ + fib(floor($n%2)));\n}", "\t$c = 1;\n\t$n = (int) $n;\n\tfor (; $n >= 1; $n\
    \ -= 2) $c = bcadd($c, $c);\n\treturn $c;\n}", "  return $n < 2 ? $n : fib(min($n-1,\
    \ 2)) + fib(max($n-1, 2));\n}\n", "\treturn (1 == $n) ? 1 : fib($n - 1) + fib($n\
    \ - 2);\n}\n", "  return ($n <= 1) ? $n : fib($n - 1) + fib($n - 2);\n}\n", " \
    \   if ($n < 2) return $n;\n    return fib($n - 1) + fib($n - 2);\n}\n", "   \
    \ static $cache;\n    if ($n < 2) {\n        return 1;\n    }\n    if (!isset($cache[$n]))\
    \ {\n        $cache[$n] = fib($n-1) + fib($n-2);\n    }\n    return $cache[$n];\n\
    }", "    return fib1($n) - fib0($n);\n}\n", "    $a, $b, $c;\n    if ($n === 0)\
    \ {\n        return 0;\n    } elseif ($n <= 2) {\n        return 1;\n    } else\
    \ {\n        $c = $a + $b; \n        $b = $a;\n        $a = $c;\n        return\
    \ $a;\n    }\n}\n</code>\n<|/ a |>\n<| a |>\nThe recursive approach does not always\
    \ work when the base case is very large.\nThe iterative solution works fine.\n\
    <code>\n<?php\n", "\tif ($n <= 1) return 1;\n\treturn fib($n - 1) + fib($n - 2);\n\
    }\n", "\t$a = 0;\n\t$b = 1; \n\tfor ($i = 0; $i < $n; $i++) {\n\t\t$c = $a + $b;\n\
    \t\t$a = $b;\n\t\t$b = $c;\n\t}\n\treturn $b;\n}\n", "  if ($n < 0) return 0;\n\
    \  if ($n === 1) return 1;\n  return fib(floor($n/2)) + fib(floor($n%2));\n}\n",
  "\tif ($n < 2) {\n\t\treturn $n;\n\t}\n\treturn fib(get_fib_from_n($n)) + fib(get_fib_from_n($n\
    \ - 1));\n}\n", "\tif ($n < 2) {\n\t\treturn $n;\n\t} elseif ($n === 2) {\n\t\t\
    return 1;\n\t}\n\treturn fib(fib($n - 2)) + fib(fib($n - 1));\n}\n", "  return\
    \ $n < 2 ? $n : fib($n - 1) + fib($n - 2);\n}", "    if ($n <= 1) return $n;\n\
    \    return fib($n - 1) + fib($n - 2);\n}\n", "\treturn $n < 2 ? $n : fib($n -\
    \ 1) + fib($n - 2);\n}\n", "    if ($n <= 1) {\n        return $n;\n    }\n  \
    \  $fibs = array(\n        0,\n        1,\n    );\n    $n--;\n    $fibs[] = fib($n-2)\
    \ + fib($n-3);\n    return $fibs[$n];\n}\n</code>\n<|/ a tags=php,fibonacci,recursion\
    \ |>\n<| c |>\nI like the array based solution. Though I didn't know that PHP\
    \ has implemented tail recursion.\n<|/ c |>\n<| c |>\nTail recursion doesn't work\
    \ in PHP as it doesn't support it until 7.4\n<|/ c |>\n<| c |>\nIn php 7.4 you\
    \ can use [tail recursion support](https://wiki.php.net/rfc/tail_call)\n<|/ c\
    \ |>\n<| a |>\nHere is another recursive implementation using tail call recursion\
    \ in PHP (tested in PHP 7.3)\n<code>", "    // Return Fibonacci number w/ n Fibonacci\
    \ numbers in array.\n    if ($n <= 1) return $n;\n    $prev = $prevFib = $prevFib2\
    \ = 1;\n    $arr = $aFibs = array();\n    $aFibs[0] = $prevFib = $prevFib2 = $prev;\n\
    \    for ($i = 2; $i <= $n; ++$i) {\n        $aFibs[$i] = $prevFib + $prevFib2;\n\
    \        $prevFib = $prevFib2;\n        $prevFib2 = $aFibs[$i - 1];\n    }\n \
    \   return $aFibs[$n];\n}\n</code>\n<|/ a tags=php,fibonacci |>\n<| c |>\nThe\
    \ first one is slow in terms of runtime\n<|/ c |>\n<| c |>\nThe first one is also\
    \ slow in terms of memory, which can make the first one be the most effective\
    \ in terms of execution speed\n<|/ c |>\n<| a dscore=2 |>\nFibonacci number is\
    \ calculated by two base case:\n<code>\nif ($n == 0)\n    return 0; \n\nif ($n\
    \ == 1)\n    return 1;\n</code>\nFor any number n, it is obvious that the value\
    \ at n+1 will be the value at n+2 and value at n+2 will be the value at n+3.\n\
    So let's write a recursive function that returns the nth Fibonacci number:\n<code>",
  "    $a = 1;\n    $b = 1;\n    $result = $n;\n\n    while ($n > 1) {\n        $result\
    \ = $a + $b;\n        $a = $b;\n        $b = $result;\n        $n--;\n    }\n\n\
    \    return $result;\n}\n", "    static $a, $b, $c, $d, $e;\n    if ($n < 2) {\n\
    \        return $n;\n    }\n    if ($a == NULL) {\n        $a = 0 ;\n        $b\
    \ = 1;\n    } else {\n        $c = $a + $b;\n        $d = $a;\n        $a = $b;\n\
    \        $b = $c;\n    }\n    $n = $n - 1;\n    $e = $d;\n    $d = $c;\n    $c\
    \ = $b;\n    $b = $a;\n    $a = $d;\n    return $e;\n}", "    if ($n < 2) {\n\
    \        return $n;\n    }\n\n    return fib(--$n) + fib(--$n);\n}", "\t$prev\
    \ = 0;\n\t$next = 1;\n\tfor (; $n < 10; ++$n) {\n\t\t$next = $prev + $next;\n\t\
    \t$prev = $next;\n\t}\n\treturn $prev;\n}", "    if ($n < 2) return 1;\n    return\
    \ fib($n - 1) + fib($n - 2);\n}", "\tif ($n < 2) {\n\t\treturn 1;\n\t} else if\
    \ ($n < 4) {\n\t\treturn $n;\n\t} else {\n\t\treturn fib($n - 2) + fib($n - 1);\n\
    \t}\n}\n", "    return ($n > 1)\n        ? fib($n - 1) + fib(n - 2)\n        :\
    \ 1;\n}\n", "    if ($n === 0) return 0;\n    if ($n === 1) return 1;\n    return\
    \ fib($n - 1) + fib($n - 2);\n}\n", "    if ($n <= 0) return 0;\n    if ($n <=\
    \ 2) return 1;\n    $a = fib(floor($n/2));\n    $b = fib(floor($n));\n    return\
    \ $a + $b;\n}", "    return ($n < 2) ? $n : fib($n-1) + fib($n-2);\n}\n", "  \
    \  if ($n <= 0) {\n        return 0;\n    }\n    return ($n == 1) ? 1 : fib($n\
    \ - 1) + fib($n - 2);\n}\n\n$numbers = range(1,100);\n$results = [];\nforeach($numbers\
    \ as $number) {\n    $results[] = fib($number);\n}\nprint_r($results);\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nJust to clarify, this solution uses recursion, which\
    \ (from what I understand) requires PHP. Recursion is a great feature in PHP which\
    \ can be abused, but it's also very useful when implementing algorithms. Just\
    \ be careful to not end up with endless recursion.\n<|/ c |>\n<| c |>\nI don't\
    \ think the question was about recursion, but thanks for providing a code example.\
    \  In fact, I think this question is a bit misleading.  It doesn't appear to be\
    \ asking about iterative vs recursive solutions.  It's about how to find the n'th\
    \ Fibonacci number in one pass instead of two.  I wonder if there's some way to\
    \ implement this in PHP?\n<|/ c |>\n<| c |>\n: It does appear to be asking about\
    \ recursion.\n<|/ c |>\n<| c |>\nIt's a good answer but it's very slow.  How can\
    \ we do this in constant time?  What if we're talking about 1,000,000th Fibonacci\
    \ number?\n<|/ c |>\n<| c |>\n: You just have to make it work on the large range\
    \ then. That's what the code example is doing.\n<|/ c |>\n<| a dscore=4 tags=php\
    \ |>\nHere's an O(n) solution that doesn't use recursion.\n<code>", "    return\
    \ $n < 2 ? $n : fib(--$n) + fib(--$n);\n}", "  if ($n < 2) {\n    return 1;\n\
    \  }\n\n  return fib(--$n - 1) + fib(--$n);\n}\n</code>\n<|/ a tags=php,fibonacci,recursion\
    \ |>\n<| a dscore=5 |>\n<code>\n$a = 1;\n$b = 1;\n$c = 1;\n\nwhile ($a <= 100)\n\
    {\n    $c = $a + $b;\n    $a = $b;\n    $b = $c;\n    echo $c.\"<br>\";\n}\n</code>\n\
    <|/ a tags=php,fibonacci,recursion |>\n<| c |>\nNot working in php7.\n<|/ c |>\n\
    <| c |>\nThis is not recursive and it doesn't use recursion.\n<|/ c |>\n<| a |>\n\
    <code>\n<?php\n", "  $a = 0;\n  $b = 1;\n  $c;\n  for ($i = 0; $i < $n; $i++)\
    \ {\n    $c = $a + $b;\n    $a = $b;\n    $b = $c;\n  }\n  return $c;\n}", " \
    \ return isset($fibs[$n]) ? $fibs[$n] : unset($fibs[$n]);\n}\n$fibs[4] = 5;\n\
    $fibs[5] = 1;\n$fibs[7] = 6;\n$fibs[8] = 7;\n$fibs[9] = 8;\n$fibs[10] = 9;\n$fibs[11]\
    \ = 11;\n", "\t$n = (int) $n;\n\tif ($n < 0) return null;\n\tif ($n <= 2) return\
    \ $n;\n\treturn fib($n - 1) + fib($n - 2);\n}", "    if ($n <= 2) {\n        return\
    \ $n;\n    }\n    return fib(--$n) + fib(--$n);\n}\n", "    if ($n < 2) {\n  \
    \      return $n;\n    }\n    return fib($n - 1) + fib($n - 2);\n}\n\n$start =\
    \ microtime(true);\nfor ($i = 0; $i < 100000; $i++) {\n    $fibs = fib($i);\n\
    }\n$end = microtime(true);\n$time = $end - $start;\n\necho \"Fibonacci (php) takes\
    \ {$time} seconds\\n\";\n</code>\nResult:\n<code>\nFibonacci (php) takes 0.2760374\
    \ seconds\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nI've tried several ways\
    \ to compute the Fibonacci numbers using PHP. Here are my results:\n\nUsing recursive\
    \ function: 0.043s\n<code>\n<?php", "    $k = 0;\n    $a = 1;\n    $b = 1;\n \
    \   $c = 1;\n    for ($i = 0; $i <= $n; $i++) {\n        $a1 = $a + $b;\n    \
    \    $b1 = $c + $a;\n        $c = $a;\n        $a = $a1;\n        $b = $b1;\n\
    \        $k++;\n    }\n    return $k;\n}", "    return ($n < 2)\n        ? $n\n\
    \        : fib(--$n) + fib(--$n);\n}\n", "    return $n < 2 ? $n : fib(--$n) +\
    \ fib(--$n);\n}\n\nclass ClassWithStaticMethods {\n    public static function\
    \ example() {\n        echo 'Static method';\n    }\n}\n\nClassWithStaticMethods::example();\n",
  "    if ($n < 0 || $n >= PHP_EOL) {\n        throw new \\InvalidArgumentException('Fibonacci\
    \ number is not defined for negative or out-of-bounds arguments.');\n    }\n \
    \   // Spread the numbers so we are sure we are always doing $n-1 additions.\n\
    \    // See Mathematica: fibonacci[n - 1] + fibonacci[n - 2]\n    $fib_array =\
    \ [0, 1];\n    for ($i = 1; $i < $n; $i++) {\n        $fib_array[$i - 1] = $fib_array[$i\
    \ - 1] + $fib_array[$i];\n    }\n    return $fib_array[$n];\n}\n</code>\n<|/ a\
    \ |>\n<| a dscore=0 tags=fibonacci,math,php |>\nThe accepted answer is fine, but\
    \ in PHP 7 you can just use the native generator functions.\n<code>\n<?php", " \
    \   $result = 0;\n    if ($n < 2) return $n;\n    $f = fib_cache[$n];\n    if\
    \ ($f) return $f;\n\n    foreach (fibs_cache[$n] as $fib) {\n        $result =\
    \ $fib + $result;\n    }\n\n    return $cache[$n] = $result;\n}\n\n$fibs_cache\
    \ = [\n    1 => [1,1,2,3,5,8],\n    2 => [2,3,5,8],\n    3 => [5,8],\n    4 =>\
    \ [8,13],\n    5 => [13,21],\n    6 => [21,34],\n    7 => [34,55],\n    8 => [55,89],\n\
    \    9 => [89,144],\n];\n\n$fib_cache = [\n    1 => 1,\n    2 => 2,\n    3 =>\
    \ 3,\n    4 => 5,\n    5 => 8,\n    6 => 13,\n    7 => 21,\n    8 => 34,\n   \
    \ 9 => 55,\n];\n\n$cache = [];\n</code>\n<|/ a tags=php,math,fibonacci |>\n<|\
    \ c |>\nVery nice, but I don't think it's as efficient as you're suggesting it\
    \ is.\n<|/ c |>\n<| a |>\nThe fastest and most efficient way I found to calculate\
    \ Fibonacci numbers in php was this way.\n<code>\n$fibs_cache = [\n    1 => [1,1,2,3,5,8],\n\
    \    2 => [2,3,5,8],\n    3 => [5,8],\n    4 => [8,13],\n    5 => [13,21],\n \
    \   6 => [21,34],\n    7 => [34,55],\n    8 => [55,89],\n    9 => [89,144],\n\
    ];\n$cache = [];\n", "    $a=0;\n    $b=1;\n    for ($i=0;$i<$n;$i++) {\n    \
    \    $a=$b;\n        $b=$a+$b;\n    }\n    return $b;\n}\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nIt does have some disadvantages though. It isn't recursive, it\
    \ is an iterative solution. On top of that, it doesn't use any built-in language\
    \ constructs (like loops), it requires looping constructs (`for`), it uses globals,\
    \ it requires globals and doesn't use namespaces. But it's still a useful exercise\
    \ in general anyway!\n<|/ c |>\n<| c |>\nThis function is recursive, but it's\
    \ not the most efficient way to do it. The function call overhead is way too high,\
    \ especially for something that's only going to be called once per page load.\n\
    <|/ c |>\n<| c |>\n: Thanks for the feedback, I have updated my answer. Also,\
    \ thanks for pointing out my mistakes.\n<|/ c |>\n<| c |>\n: Thanks for the feedback.\
    \ I think your solution is probably the best solution for this problem. Just one\
    \ thing, since you mentioned it is an exercise in general that is not a very good\
    \ solution, I would suggest to also include the best way to achieve the goal of\
    \ implementing this as a function.\n<|/ c |>\n<| a dscore=4 tags=recursion,php\
    \ |>\nI took's code and simplified it a bit.\n<code>\n<?php", "\tif ($n < 0) {\n\
    \t\tthrow new \\InvalidArgumentException;\n\t}\n\n\tif ($n < 2) {\n\t\treturn\
    \ $n;\n\t}\n\n\treturn fib(--$n) + fib(--$n);\n}\n", "    if ($n <= 2) { return\
    \ 1; }\n    return fib(n - 1) + fib(n - 2);\n}\n</code>\nIn PHP, there is no built-in\
    \ function to calculate Fibonacci numbers, so we must calculate them ourselves.\
    \ Below is Python implementation of Fibonacci numbers. Python has the great library\
    \ of mathematical functions to calculate various numbers, so we must simply import\
    \ them. We can import them using \"from math import *\".\n<code>\nfrom math import\
    \ *\n...\ndef fib(n):\n    if n <= 2:\n        return 1\n    return fib(n - 1)\
    \ + fib(n - 2)\n\ndef fibonacci(n):\n    if n == 0:\n        return 0\n    elif\
    \ n == 1:\n        return 1\n    else:\n        return fibonacci(n - 1) + fibonacci(n\
    \ - 2)\n\nprint fib(10)\nprint fibonacci(10)\n</code>\nThe output is as expected:\n\
    <code>\n55\n55\n</code>\n<|/ a dscore=5 |>\n<| c |>\nNice recursive solution,\
    \ but if you're doing this for fun you should look into [tail recursion](https://en.wikipedia.org/wiki/Tail_call).\n\
    <|/ c |>\n<| c |>\nThank you for the suggestion, I have updated my answer.\n<|/\
    \ c |>\n<| a dscore=5 |>\nThe most efficient solution is to use memoization. Your\
    \ function needs to call itself recursively, but memoization is also a good solution.\n\
    A Python solution, using functools.lru_cache:\n<code>\nimport functools\n\ndef\
    \ fib(n):\n    if n < 2:\n        return 1\n    memo = functools.lru_cache(None)\n\
    \    def fib2(n):\n        if n < 2:\n            return 1\n        return memo(n)\n\
    \    return fib2(n)\n\nprint(fib(10))\n</code>\nThis produces the following output:\n\
    <code>\n55\n</code>\nThis memoization stores the result for fib(10) in fib(10).\
    \ This way, the second call to fib(10) will just return the first result (which\
    \ is already calculated).\nIf you want to see the code for functools.lru_cache,\
    \ you can use the following command:\n<code>\nfrom __builtin__ import functools\n\
    \nprint(functools.__file__)\n</code>\n<|/ a tags=fibonacci,php,math |>\n<| c |>\n\
    This is awesome, thank you very much. Can you explain to me the use of `functools.lru_cache`\
    \ in depth?\n<|/ c |>\n<| c |>\nYou're welcome. I added some explanation about\
    \ `functools.lru_cache` so you can read the details. In short, the code doesn't\
    \ take any time to run, and it is possible to cache the results. Since you always\
    \ use the function `fib2", "\tif ($n < 2) {\n\t\treturn 1;\n\t}\n\treturn fib(static::fibonacci($n\
    \ - 1)) + fib(static::fibonacci($n - 2));\n}\n", "    return ($n == 0 || $n ==\
    \ 1) ? $n :\n        fib(--$n) + fib(--$n);\n}", "    if ($n < 2) {\n        return\
    \ $n;\n    }\n    return fib($n - 1) + fib($n - 2);\n}\n", "    return $n < 2\
    \ ? $n : fib(floor($n/2)) + fib(floor($n%2));\n}", "\tif ($n < 2) {\n\t\treturn\
    \ $n;\n\t}\n\treturn fib(n - 1) + fib(n - 2);\n}\n", "  if ($n < 2) {\n    return\
    \ $n;\n  }\n  return fib($n - 1) + fib($n - 2);\n}", "\treturn (1 + $n) / 2;\n\
    }\n", "  return array_reduce(range(1, $n), function($carry, $x) {\n    return\
    \ $carry + $x;\n  }, 1);\n}\n</code>\n<|/ a |>\n<| c |>\nThis can be further optimized\
    \ by using [generators](http://www.php.net/manual/en/language.generators.overview.php)\n\
    <|/ c |>\n<| c |>\nAs an alternative to generators, you can try [memoization](http://www.php.net/manual/en/function.array-reduce.php#101884).\n\
    <|/ c |>\n<| c |>\nThanks so much for the alternative answers Robert. I learned\
    \ a lot with your posts and answers. I wish I could give you more than one \"\
    correct answer\". Thanks so much again for your help.\n<|/ c |>\n<| c |>\nNice!\
    \ This is a great answer! My code was taking too long with recursion, though.\n\
    <|/ c |>\n<| c |>\nUsing a generator is definitely the way to go. Here's a link\
    \ to a really good article explaining how to create generators http://www.phpbuilder.com/articles/application-development/php-generators-and-the-generator-pattern/\n\
    <|/ c |>\n<| a dscore=5 tags=php,fibonacci |>\nUsing array_reduce()\n<code>\n\
    $fibonacci = [1, 1, 2, 3, 5, 8, 13, 21, 34];\n", "    // fib(0) = 0\n    if ($n\
    \ === 0) {\n        return 0;\n    }\n    // fib(1) = 1\n    if ($n === 1) {\n\
    \        return 1;\n    }\n    // fib(n) = fib(n - 1) + fib(n - 2)\n    return\
    \ fib(n - 1) + fib(n - 2);\n}\n", "    $f = 1;\n    $f1 = $f;\n    $f2 = $f;\n\
    \    for ($i = 0; $i < $n; $i++) {\n        $f1 = $f2 + $f1;\n        $f2 = $f;\n\
    \        $f = $f1;\n    }\n    return $f;\n}\n", "    if ($n < 0) {\n        if\
    \ ($n < -1) return 0;\n        $n = abs($n);\n        if ($n <= 3) return $n;\n\
    \    }\n    if ($n < 2) return 1;\n    if ($n == 1) return 1;\n    return fib(--$n)\
    \ + fib(--$n);\n}\n", "    if ($n < 2) return $n;\n    return fib(--$n) + fib(--$n);\n\
    }\n", "\tif ($n < 1) {\n\t\treturn 1;\n\t}\n\treturn fib($n - 1) + fib($n - 2);\n\
    }\n\n$a = array( 'A' => 1, 'B' => 2, 'C' => 3, 'D' => 4, 'E' => 5, 'F' => 6, 'G'\
    \ => 7, 'H' => 8, 'I' => 9, 'J' => 10 );\n$a = array_map( 'fib', $a );\n$a = array_filter(\
    \ $a );\n$a = array_merge( array( 0 => 0 ), $a );\nprint_r( array_values( $a )\
    \ );", "  // Return the Fibonacci number for the n-th number in the sequence\n\
    \  // >>> fib(10)\n  // 55\n  // >>> fib(1)\n  // 1\n  // >>> fib(8)\n  // 21\n\
    \  if ($n === 0 || $n === 1) {\n    return $n;\n  }\n  // Otherwise calculate\
    \ Fibonacci number\n  return fib(n - 2) + fib(n - 1);\n}", "  if ($n === 0 ||\
    \ $n === 1) return $n;\n  return fib(--$n) + fib(--$n);\n}", "    return isset($n)\
    \ ? fib(isset($n-1) ? $n-1 : 2).$n\n                 : array(1,1);\n}\n", "\t\
    return fib($n-1).fib(1).fib(2);\n}\n", "  return array_reduce(range(1, $n), [0\
    \ => '1', 1 => '0'], function ($result, $current) {\n    return $result + $current;\n\
    \  });\n}\n</code>\n<|/ a dscore=1 |>\n<| a |>\nHere's a solution using Python\
    \ and the excellent module NumPy. \n<code>", "  // return 0 when $n==0 or $n==1;\n\
    \  if ($n < 2) return 0;\n  // return last fibonacci number when $n is bigger\
    \ than 2.\n  if ($n == 2) return 1;\n  // compute fibonacci number by adding previous\
    \ two numbers,\n  // then return last result and continue with next step.\n  return\
    \ fib($n - 1) + fib($n - 2);\n}\n", "    if ($n < 0) throw new RangeException(sprintf('Negative\
    \ number given, expected natural number or %s, given %s.', $n < 0 ? -$n : 0, 1));\n\
    \    if ($n <= 2) return $n;\n    $n2 = $n-1;\n    if ($n2 < 0) return $n;\n \
    \   foreach ([3, 2, 1] as $k => $v)\n        $n2 = $n2 + $v;\n    return $n2;\n\
    }\n</code>\n<|/ a tags=fibonacci,php,fibonacci-heap |>\n<| c |>\nI wouldn't use\
    \ recursion at all, just loop and maintain some state (maybe a stack of previous\
    \ results)\n<|/ c |>\n<| c |>\nYou might want to check out my answer using recursion.\
    \ That's a lot faster than iterating over an array to find the next Fibonacci\
    \ number. Using a recursion here just makes it complicated because you don't always\
    \ need to loop over the entire array to get to the required element.\n<|/ c |>\n\
    <| c |>\nI agree this way is simpler, but it's not very efficient. I haven't timed\
    \ this, but I suspect that iterating over an array to find the next Fibonacci\
    \ number will be O(n) but my method will be O(n). My method will also have an\
    \ error if the index passed is too high. My method will also have the advantage\
    \ that it's very easy to change the Fibonacci numbers so that they don't repeat.\n\
    <|/ c |>\n<| c |>\nYes, you are right, my method has an error in the negative\
    \ case. That's why I said it's complicated :)\n<|/ c |>\n<| c |>\nI updated my\
    \ answer to include an implementation of your method using a stack. I'm pretty\
    \ sure it's as efficient as my original method and probably faster. :)\n<|/ c\
    \ |>\n<| a |>\nYou can use the following, it works for every case I tested\n<code>",
  "  // return Fibonacci number for n\n  return $n < 3 ? 1 : fib($n - 1) + fib($n\
    \ - 2);\n}\n", "\tif ($n < 2) {\n\t\treturn 1;\n\t}\n\treturn fib($n - 1) + fib($n\
    \ - 2);\n}\n", "  return ($n < 2) ? 1 : (fib($n - 1) + fib($n - 2));\n}", "  \
    \  $a = 1;\n    $b = 1;\n    $sum = 0;\n    while ($n > 0) {\n        $a = $a\
    \ + $b;\n        $b = $a + $b;\n        $sum = $sum + $a;\n        $n--;\n   \
    \ }\n    return $sum;\n}", "    if ($n <= 1)\n        return 1;\n    return fib(--$n)\
    \ + fib(--$n);\n}\n</code>\n<|/ a tags=recursion,php |>\n<| a tags=recursion,php\
    \ |>\n<code>", "    if ($n <= 1) return 1;\n    return fib($n - 2) + fib($n -\
    \ 1);\n}\n", "  if ($n < 0 || $n === 1 || $n === 2)\n    return $n;\n  return\
    \ fib($n - 1) + fib($n - 2);\n}", "  return array_slice($this, ($n < 1) ? 0 :\
    \ ($n > 1) ? $n - 1 : $n, 1);\n}\n", "\tif ($n < 2) return 1;\n\treturn fib($n\
    \ - 1) + fib($n - 2);\n}\n", "    if ($n < 2) return $n;\n    return fib(--$n)\
    \ + fib(--$n);\n}\n</code>\n<|/ a tags=function,php,recursion,fibonacci |>\n<|\
    \ a dscore=4 |>\nIf your curious, here is my implementation of Fibonacci using\
    \ recursion and generators.\n<code>", "    if ($n <= 1) return $n;\n    return\
    \ fib($n - 1) + fib($n - 2);\n}", "    if ($n <= 0) {\n        return 0;\n   \
    \ }\n    return fib($n - 1) + fib($n - 2);\n}", "  // Make sure n is an integer\
    \ or default to 1.\n  $n = intval($n) ?: 1;\n\n  // Set up initial two numbers\
    \ to return.\n  $a = 1;\n  $b = 1;\n\n  // Calculate the first n-1 Fibonacci numbers.\n\
    \  for ($i = 2; $i <= $n; $i++) {\n    // Calculate the new two numbers.\n   \
    \ $c = $a + $b;\n    $b = $a;\n    $a = $c;\n  }\n\n  return $a;\n}\n", "  if\
    \ ($n < 2) {\n    return $n;\n  }\n  return fib(--$n) + fib(--$n);\n}", "    if\
    \ ($n <= 2) {\n        return 1;\n    } else {\n        return fib(--$n) + fib(--$n);\n\
    \    }\n}\n", "  if ($n < 2) return $n;\n  return fib($n - 1) + fib($n - 2);\n\
    }", "\t$a = $b = 1;\n\tfor ($i = 1; $i <= $n; $i++) {\n\t\t$b = $a + $b;\n\t\t\
    $a = $b;\n\t}\n\treturn $b;\n}", "  if ($n < 2) return 1;\n  return fib(--$n)\
    \ + fib(--$n);\n}", "\t$fib1 = $fib2 = 1;\n\t$index = 1;\n\twhile ($index < $n)\
    \ {\n\t\t$next = $fib1 + $fib2;\n\t\t$fib1 = $fib2;\n\t\t$fib2 = $next;\n\t\t\
    $index++;\n\t}\n\treturn $fib2;\n}\n", "\tif ($n < 2) {\n\t\treturn $n;\n\t}\n\
    \n\treturn fib($n - 1) + fib($n - 2);\n}", "    if ($n <= 1) return $n;\n\n  \
    \  return fib($n-1) + fib($n-2)\n}\n", "    static $fibs;\n    if (!isset($fibs[$n]))\
    \ {\n        $fibs[$n] = fib($n - 1) + fib($n - 2);\n    }\n\n    return $fibs[$n];\n\
    }\n</code>\nThis uses the fact that you can implement the Fibonacci numbers using\
    \ two values: the first and the last numbers in the sequence.\nThis is better\
    \ than a traditional recursive implementation because in the worst case scenario,\
    \ you will get StackOverflowError, which will eventually exhaust the memory and\
    \ cause the script to stop working.\n<|/ a dscore=5 |>\n<| c |>\nYeah, the last\
    \ sentence is really important. Recursive functions tend to be more memory hungry\
    \ than iterative ones.\n<|/ c |>\n<| c |>\nI like the idea, but it's not iterative.\n\
    <|/ c |>\n<| c |>\nThe Fibonacci sequence is a recursive definition :)\n<|/ c\
    \ |>\n<| c |>\nNot all languages implement tail recursion, though.\n<|/ c |>\n\
    <| c |>\n, good point. I'll remove it.\n<|/ c |>\n<| a tags=fibonacci,php,algorithm,performance\
    \ dscore=5 |>\nThis is not exactly a fibonacci sequence but is very simple to\
    \ calculate (tested in Python 2.7.3): \n<code>\ndef fib(n):\n    a, b = 0, 1\n\
    \    while a < n:\n        print a\n        a, b = b, a+b\n</code>\nThis prints\
    \ out the entire sequence of numbers.  To get it to stop early:\n<code>\ndef fib(n):\n\
    \    a, b = 0, 1\n    if n < 2:\n        return n\n    while a < n:\n        print\
    \ a\n        a, b = b, a+b\n</code>\n<|/ a |>\n<| c |>\nWhile this is a simple\
    \ and elegant solution, it's extremely inefficient.\n<|/ c |>\n<| c |>\nFor Python\
    \ programmers, this will cause an `IndentationError: unindent does not match any\
    \ outer indentation level`\n<|/ c |>\n<| c |>\n, no, it doesn't, at least not\
    \ in python 3.6.\n<|/ c |>\n<| c |>\nThis code works well for small values, but\
    \ it's extremely inefficient for large values (>~20!). It's not even the fastest\
    \ algorithm possible, and it uses exponential space because it's linear to the\
    \ number of terms in the sequence. I think you're looking at O(2^n) algorithms,\
    \ which are much less efficient than simple recursion.\n<|/ c ", "    if ($n ===\
    \ 0 || $n === 1) return $n;\n    return fib(--$n) + fib(--$n);\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nThank you! I didn't know there was a name for these sorts of\
    \ recursive methods, and it's pretty simple to implement them in PHP!\n<|/ c |>\n\
    <| c |>\n, glad to have been of help! Feel free to [accept my answer](http://meta.stackexchange.com/questions/5234/how-does-accepting-an-answer-work)\
    \ if you feel it was useful to you. :-)\n<|/ c |>\n<| c |>\nActually, this doesn't\
    \ work. It does work if I call fib 3 times but if I call it more than 3 times\
    \ it returns the wrong answer.\n<|/ c |>\n<| c |>\nYes, I fixed the problem. I\
    \ forgot to pass $n to fib().\n<|/ c |>\n<| c |>\n, glad it helped! If my answer\
    \ properly responded to your question, please [accept it](http://meta.stackexchange.com/questions/5234/how-does-accepting-an-answer-work)\
    \ by clicking the check mark next to the answer. That action lets others know\
    \ the question has an answer and it gives the person that helps you credit for\
    \ the assist. See [this link](http://meta.stackexchange.com/a/5235) for more information\
    \ regarding the etiquette on Stack Overflow. Thanks!\n<|/ c |>\n<| a |>\nThe classic\
    \ way to implement an n-th Fibonacci number is as follows:\n<code>", "    if ($n\
    \ < 2) return $n;\n    return fib($n - 1) + fib($n - 2);\n}\n", "    if ($n <\
    \ 2) {\n        return $n;\n    }\n    return fib($n - 1) + fib($n - 2);\n}\n",
  "\tif ($n < 0) {\n\t\treturn NaN;\n\t}\n\n\tif ($n === 0 || $n === 1) {\n\t\treturn\
    \ 1;\n\t}\n\n\treturn fib(floor($n) - 1) + fib(floor($n) - 2);\n}\n", "    if\
    \ ($n < 2) {\n        return $n;\n    }\n    return fib($n - 2) + fib($n - 1);\n\
    }", "    $a = 1;\n    $b = 1;\n    for ($i = 2; $i <= $n; $i++) {\n        $a\
    \ = ($b * $a) % $modulus;\n        $b = ($a * $b) % $modulus;\n    }\n    return\
    \ $a;\n}", "    // Make sure n is a valid number or return an error.\n    if(!is_numeric($n))\
    \ {\n        throw new InvalidArgumentException('Invalid number');\n    }\n\n\
    \    // If n is 0 or 1 then return 1.\n    if($n === 0 || $n === 1) {\n      \
    \  return $n;\n    }\n\n    // Calculate the nth Fibonacci number by repeatedly\
    \ adding 2 to the\n    // nth Fibonacci number.\n    $a = 1;\n    $b = 1;\n  \
    \  for($i = 2; $i < $n; ++$i) {\n        $c = $a + $b;\n        $a = $b;\n   \
    \     $b = $c;\n    }\n    return $b;\n}\n", "\t$sum = 0;\n\t$n = max(2, $n);\n\
    \tif ($n < 2) return 1;\n\tfor ($i = 2; $i <= $n; $i++) {\n\t\t$sum = $sum + $i;\n\
    \t\t$n = $n - 1;\n\t}\n\treturn $sum;\n}\n", "  if ($n < 0) {\n    echo \"<b>\"\
    \ . sprintf('Fibonacci number not defined for n=%d (n < 0)', $n) . \"</b>\";\n\
    \    return null;\n  }\n  if ($n <= 2) {\n    return $n;\n  }\n  if ($n === 5)\
    \ {\n    return 6;\n  }\n  return fib($n - 1) + fib($n - 2);\n}\n", "    if ($n\
    \ < 2) {\n        return 1;\n    }\n    return fib(n - 1) + fib(n - 2);\n}", " \
    \   if ($n < 2) return $n;\n    return fib(sub(1, $n)) + fib(sub(2, $n));\n}",
  "    return $n < 2 ? $n : fib($n - 1) + fib(--$n);\n}\n\n/**\n * Implements the\
    \ recursive version of [fib](#fib).\n *\n * @param $n\n *\n * @return int\n */",
  "    $first = 1;\n    $second = 1;\n    for ($count = 1; $count < $n; $count++)\
    \ {\n        $new = $first + $second;\n        $first = $second;\n        $second\
    \ = $new;\n    }\n    return $second;\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\n\
    <code>\n$fiboSeq = [0, 1, 1, 2, 3]\nfor($i = 0; $i < 3; $i++){\n    if($i < $max){\n\
    \        $newFiboSeq[] = $fiboSeq[$i]+$fiboSeq[$i+1];\n        $fiboSeq[] = $newFiboSeq[$i];\n\
    \    }\n}\n</code>\n<|/ a tags=php,fibonacci |>\n<| a tags=php,fibonacci |>\n\
    <code>\n<?php", "    if ($n <= 1 || $n >= $fibNum) {\n        return 1;\n    }\n\
    \    return fib($n - 2) + fib($n - 1);\n}\n", "    if ($n < 0) return 0;\n   \
    \ if ($n === 1) return 1;\n    return fib(--$n) + fib(--$n);\n}", "\treturn (isset($n)\
    \ && $n <= 31) ?\n\t\tarray_slice(fibonacci(array_keys($fib)), $n - 1, 1)[0] :\n\
    \t\tfib($n-1) + fib($n-2);\n}", "    if ($n < 2) {\n        return 1;\n    }\n\
    \    return fib(n - 1) + fib(n - 2);\n}", "    if ($n <= 2) return $n;\n    return\
    \ fib(floor($n/2)) + fib(floor($n/2));\n}", "\treturn $n < 2 ? $n : fib(fib($n\
    \ - 1)) + fib(fib($n - 2));\n}\n", "  return ($n < 1)? 1 : (fib($n - 1) + fib($n\
    \ - 2));\n}", "\tif ($n < 2) {\n\t\treturn $n;\n\t} else {\n\t\treturn fib($n\
    \ - 2) + fib($n - 1);\n\t}\n}\n", "  if ($n < 2) {\n    return 1;\n  }\n\n  return\
    \ fib(--$n) + fib(--$n);\n}\n", "\tif ($n < 2) {\n\t\treturn 1;\n\t} else {\n\t\
    \treturn fib(floor($n / 2)) + fib(floor($n % 2));\n\t}\n}\n", "    $f1 = 0;\n\
    \    $f2 = 0;\n    for ($i = 0; $i < $n; $i++) {\n        $f1 = $f2 + $f1;\n \
    \       $f2 = $f1;\n        $f1 = $f2;\n    }\n    return $f2;\n}", "\tif ($n\
    \ <= 1) return $n;\n\treturn fib(floor($n/2)) + fib(floor($n%2));\n}", "  if ($n\
    \ < 2) {\n    return 1;\n  }\n\n  return fib(--$n) + fib(--$n);\n}", "    return\
    \ array_sum(array(\n        fib($n - 1) + fib($n - 2),\n        fib($n - 2),\n\
    \    ));\n}", "    return fib($n - 1) + fib($n - 2);\n}\n", "  $fns = array(\n\
    \    array(1, 1),\n    array(2, 1),\n    array(1, 2),\n    array(2, 2),\n    array(1,\
    \ 3),\n    array(2, 3),\n    array(1, 4),\n    array(3, 4),\n    array(1, 5),\n\
    \    array(2, 5),\n    array(1, 6),\n    array(3, 6),\n    array(1, 7),\n    array(2,\
    \ 7),\n    array(1, 8),\n    array(3, 8),\n    array(1, 9),\n    array(4, 9),\n\
    \    array(5, 5),\n    array(6, 8),\n    array(7, 13),\n    array(8, 21),\n  \
    \  array(9, 34),\n    array(10, 55),\n    array(11, 89),\n    array(12, 144),\n\
    \    array(13, 233),\n    array(14, 377),\n    array(15, 610),\n    array(16,\
    \ 987),\n    array(17, 1597),\n    array(18, 2584),\n    array(19, 4181),\n  \
    \  array(20, 6765),\n    array(21, 10233),\n    array(22, 15373),\n    array(23,\
    \ 20352),\n    array(24, 26376),\n    array(25, 43409),\n    array(26, 67065),\n\
    \    array(27, 104457),\n    array(28, 156857),\n    array(29, 207623),\n    array(30,\
    \ 267536),\n    array(31, 434821),\n    array(32, 671588),\n    array(33, 1059687),\n\
    \    array(34, 1584376),\n    array(35, 2089534),\n    array(36, 2600705),\n \
    \   array(37, 4349765),\n    array(38, 6724265),\n    array(39, 10700480),\n \
    \   array(40, 15990051),\n    array(41, 20996023),\n    array(42, 26121465),\n\
    \    array(43, 43503569),\n    array(44, 67697405),\n    array(45, 107902320),\n\
    \    array(46, 16025921),\n    array(47, 20110703),\n    array(48, 26154745),\n\
    \    array(49, 43529927),\n    array(50, 67783889),\n    array(51, 108434579),\n\
    \    array(52, 161365570),\n    array(53, 20222287),\n    array(54, 26313055),\n\
    \    array(55, 43546655),\n    array(56, 67861055),\n    array(57, 108546255),\n\
    \    ", "\tif ($n < 2) {\n\t\treturn $n;\n\t}\n\treturn fib(n - 1) + fib(n - 2);\n\
    }", "\tif ($n < 2) {\n\t\treturn $n;\n\t}\n\treturn fib(--$n) + fib(--$n);\n}\n",
  "    if ($n <= 1) {\n        return $n;\n    }\n    return fib($n - 1) + fib($n\
    \ - 2);\n}"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
