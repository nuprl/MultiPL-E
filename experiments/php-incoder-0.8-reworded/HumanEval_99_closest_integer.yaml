name: HumanEval_99_closest_integer
language: php
prompt: "<?php\n// Create a function that takes a value (string) representing a number\n\
  // and returns the closest integer to it. If the number is equidistant\n// from\
  \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
  10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
  \ from zero means that if the given number is equidistant\n// from two integers,\
  \ the one you should return is the one that is the\n// farthest from zero. For example\
  \ closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\")\
  \ should return -15.\nfunction closest_integer($value) {\n"
tests: "function candidate(...$args) {\n    return closest_integer(...$args);\n}\n\
  \nfunction test(): void {\n    if (candidate(\"10\") !== 10) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(\"14.5\") !== 15) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(\"-15.5\") !== -16) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(\"15.3\") !== 15) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(\"0\") !== 0) { throw new Exception(\"Test\
  \ failed!\"); }\n}\n\ntest();"
completions: ["  // Handle the special cases by comparing against zero\n  if ($value\
    \ == 0) {\n    return 0;\n  }\n  if ($value < 0) {\n    return -round(-$value);\n\
    \  }\n\n  // Compare numbers against each other\n  $diff = $value - round($value);\n\
    \n  if (abs($diff) <= 1) {\n    return $value;\n  }\n\n  // Handle numbers that\
    \ are equidistant from each other\n  $closest = null;\n  foreach ([round($value,\
    \ 1), round($value, 2), round($value, 3)] as $other) {\n    $diff = $value - $other;\n\
    \    if (abs($diff) <= 1) {\n      return $other;\n    }\n  }\n\n  // We couldn't\
    \ find any good numbers, so return whatever floats things up.\n  return $diff;\n\
    }\n</code>\nAnd then use it:\n<code>\n$result = closest_integer($string);\n</code>\n\
    Which is the same thing as the code in the question.\n<|/ a tags=php |>\n<| a\
    \ tags=php dscore=0 |>\nI think you meant \"round down\" when referring to \"\
    nearest integer\" rather than \"round down to the nearest integer\" as that would\
    \ give you an integer that is the same as the original value if it was a power\
    \ of two.\nIf that is the case, you can use round:\n<code>\n$i = floor($i);\n\
    </code>\nIf this is just for display, the above is fine and you can simply use\n\
    <code>\nround($i);\n</code>\nIf you're wanting to round to the nearest whole number,\
    \ the best way would be to use ceil:\n<code>\n$i = ceil($i);\n</code>\nIf this\
    \ is just for display purposes, you can use\n<code>\nround($i, 0);\n</code>\n\
    <|/ a |>\n<| c |>\nSorry, I should have been clearer. round($i,0) would work also.\n\
    <|/ c |>\n<| a dscore=0 |>\nThis would work too:\n<code>\n<?php", "    // Make\
    \ sure that we're dealing with a number.\n    $value = floatval($value);\n   \
    \ // Find the closest integer.\n    $closest = $value % $value % $value;\n   \
    \ // If there's more than one integer, return the largest one.\n    if ($closest\
    \ === 0.0) {\n        return $value;\n    }\n    // Otherwise, return the integer.\n\
    \    return $closest;\n}\n", "\t$is_integer = (boolean) preg_match('/^[0-9]+$/',\
    \ $value);\n\n\tif (!$is_integer) {\n\t\treturn FALSE;\n\t}\n\n\treturn (int)\
    \ abs($value);\n}\n", "  // Split the number into integer and decimal part\n \
    \ $value = floatval($value);\n  $integer_part = (int) $value;\n  $decimal_part\
    \ = $value - $integer_part;\n\n  // Get the difference in two closest number\n\
    \  $difference = array();\n  $difference[0] = $integer_part;\n  $difference[1]\
    \ = $decimal_part;\n\n  $difference = array_shift($difference);\n  if ($difference\
    \ > 0) {\n    $difference = $difference - 1;\n  }\n  return $integer_part + $difference;\n\
    }\n", "    if ($value === $value) return $value;\n\n    $distances = array();\n\
    \    $distances[] = abs($value - $value%2);\n    $distances[] = abs($value - $value%4);\n\
    \    $distances[] = abs($value - $value%8);\n\n    $closest = null;\n    foreach\
    \ ($distances as $distance) {\n        if ($closest === null || $distance < $closest)\
    \ {\n            $closest = $distance;\n        }\n    }\n\n    return $closest;\n\
    }", "  return intval($value) + round((floatval($value) - intval($value)) * 0.5)\n\
    }\n", "    if ($value{0} === \"-\") {\n        $value = substr($value, 1);\n \
    \   }\n\n    if ($value{0}.match(/^[0-9]{1,}$/) === null) {\n        return \"\
    0\";\n    }\n\n    $parts = explode(\".\", $value);\n\n    sort($parts);\n\n \
    \   return round($parts[0]);\n}\n\n/**\n * Return a URL for the given file path\
    \ relative to the base URL. If a file path\n * is given, we will append the file\
    \ path with a trailing slash.\n *\n * @param string $path The path to convert.\n\
    \ *\n * @return string\n */", "  $parts = explode('.', $value);\n  $diff1 = abs($parts[0]);\n\
    \  $diff2 = abs($parts[1]);\n  if ($diff1 > $diff2) {\n    return $diff1 - 1;\n\
    \  } else {\n    return $diff2 - 1;\n  }\n}\n</code>\n<|/ a |>\n<| a dscore=2\
    \ |>\nHere's a solution that only requires one function, no loops or ifs:\n<code>\n\
    <?php", "    $value = (float) $value;\n    $diff = $value - ceil(abs($value));\n\
    \    return $diff > 0.5 ? ceil($value) : floor($value);\n}\n", "  // Ensure that\
    \ the value passed is a number\n  is_numeric($value) && is_int($value) && ($value\
    \ = floatval($value));\n  return intval(round($value));\n}", "  // Convert the\
    \ string into a number if necessary.\n  $value = strval($value);\n  $value = strtolower($value);\n\
    \  // If the number is of the form \"XX.X\", return it as-is.\n  if (preg_match('/([\\\
    d]+\\.[\\d]+)/', $value, $matches)) {\n    return $matches[1];\n  }\n  // Otherwise\
    \ break it into two numbers.\n  $value_parts = explode('.', $value);\n  $decimal_places\
    \ = strlen($value_parts[1]);\n  // Make sure there are two parts or more.\n  if\
    \ (count($value_parts) < 2) {\n    return null;\n  }\n  // Convert the two numbers\
    \ into a decimal if necessary.\n  $value_parts[1] = (float) $value_parts[1];\n\
    \  $float_value = (string) $value_parts[1];\n  // Round the numbers up or down.\n\
    \  $rounded_up = $float_value + ((float) 0.5 / $decimal_places);\n  $rounded_down\
    \ = $float_value - ((float) 0.5 / $decimal_places);\n  // Return the closest integer.\n\
    \  if ($rounded_up == $float_value) {\n    return $value_parts[0];\n  } else {\n\
    \    return $value_parts[0];\n  }\n}\n", "  if (!is_numeric($value)) {\n    throw\
    \ new Exception(\n      pht(\n        \"Expected a string representing a number.\
    \ Actual value: %s.\",\n        phutil_tag(\n          \"strong\",\n         \
    \ array(),\n          sprintf(\n            \"'%s'.\",\n            get_class($value))));\n\
    \  }\n  $value = ltrim($value, '0');\n\n  // If the value is equal to zero, return\
    \ zero.\n  if ($value === '0') {\n    return 0;\n  }\n\n  // If the value is an\
    \ integer, return it.\n  if (intval($value) == $value) {\n    return intval($value);\n\
    \  }\n\n  // If the value is negative, return it.\n  if (strlen($value) < 2) {\n\
    \    return $value;\n  }\n\n  $sign = substr($value, -1);\n  switch (strtoupper($sign))\
    \ {\n    case '+':\n      return $value;\n    break;\n    case '-':\n      return\
    \ -$value;\n    break;\n    case 'E':\n      return exp(1);\n    break;\n    default:\n\
    \      // Shouldn't ever get here. Just in case.\n      throw new Exception(\n\
    \        pht(\n          'Unexpected sign \"%s\" encountered in \".%d\" value.',\n\
    \          $sign,\n          $value));\n  }\n}\n\n/**\n * Return a list of hosts\
    \ known to Phabricator. This list *does* change\n * as the list of known hosts\
    \ changes.\n *\n * Generally, don't use this function outside of a command!\n\
    \ *\n * NOTE: This implementation is slow (~1 ms). Do not use for large lists.\n\
    \ *\n * @param int Number of hosts to return.\n * @return list<string> List of\
    \ hosts known to Phabricator, or an empty list\n *                      if there\
    \ aren't any more hosts.\n */", "  // Test the validity of the input\n  if (!is_numeric($value))\
    \ {\n    return false;\n  }\n\n  // If two numbers are equidistant, round them\
    \ away from zero\n  $int_1 = $int_2 = (int) $value;\n  if (abs($int_1 - $int_2)\
    \ == 1) {\n    return $int_1;\n  }\n\n  // If the two numbers are not equidistant,\
    \ find the closest integer to\n  // the value without rounding away from zero\n\
    \  $closest = $int_1;\n  $closest_diff = abs($value - $int_1);\n  for ($i = 2;\
    \ $i <= $int_2; ++$i) {\n    $close_diff = abs($value - $closest);\n    if ($close_diff\
    \ < $closest_diff) {\n      $closest = $closest;\n      $closest_diff = $close_diff;\n\
    \    }\n    $closest += $i;\n  }\n\n  // If the difference between the two numbers\
    \ is not one or more,\n  // round away the two numbers and return their sum\n\
    \  return $closest;\n}\n</code>\n<|/ a tags=php,math dscore=2 |>\n<| c |>\nThanks\
    \ for sharing this solution, however it isn't quite right yet. The problem here\
    \ is that it rounds towards 0, which isn't what the question asked for. For example,\
    \ `closest_integer(1.5)` returns 1, when it should be returning 2 (the closest\
    \ integer less than 1.5).\n<|/ c |>\n<| c |>\nThat is indeed true - I misread\
    \ the question. I have edited the answer accordingly.\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>", "  return round($value / floor(abs($value)));\n}\n", "  $differences\
    \ = array_diff(range(0, abs($value)), range(abs($value), 0));\n  $value = abs($value);\n\
    \  foreach ($differences as $difference) {\n    if (abs($value - $difference)\
    \ == 1) {\n      return $difference;\n    }\n  }\n  return $value;\n}\n</code>\n\
    <|/ a tags=php,numbers,math |>\n<| a |>\nHere's a simple solution which should\
    \ be O(1) time complexity.\n<code>\n<?php", "    // Your code goes here\n}\n",
  "  return round($value);\n}", "  $value = strval($value);\n  if (preg_match('/[0-9.]+/',\
    \ $value)) {\n    if (is_numeric($value)) {\n      $value = intval($value);\n\
    \    }\n\n    $closest = null;\n    $distance = null;\n\n    $ranges = array_filter([\n\
    \        '0..10' => [5, 2.5, 7.5, 10.5],\n        '10..20' => [7.5, 10.5, 15.5,\
    \ 20.5],\n        '20..30' => [15.5, 20.5, 25.5, 30.5],\n        '30..40' => [20.5,\
    \ 25.5, 30.5, 40.5],\n        '40..50' => [30.5, 40.5, 50.5, 60.5],\n        '50..60'\
    \ => [40.5, 50.5, 60.5, 0.6],\n        '60..70' => [50.5, 60.5, 0.6, 0.7],\n \
    \       '70..80' => [60.5, 70.5, 80.5, 90.5],\n        '80..90' => [70.5, 80.5,\
    \ 90.5, 100.5],\n        '90..100' => [80.5, 90.5, 100.5, 100.5],\n        '>100'\
    \ => [100.5],\n    ]);\n\n    foreach ($ranges as $range => $range_values) {\n\
    \      $distance = abs($value - $range_values[0]);\n      if ($distance <= array_sum(array_map('round',\
    \ $range_values))) {\n        $closest = $range;\n        break;\n      }\n  \
    \  }\n\n    return $closest;\n  }\n\n  return null;\n}\n", "  $value = abs($value);\n\
    \  $closest_integer = $value;\n  $differences = array();\n  for ($i = 1; $i <=\
    \ 100; $i++) {\n    $differences[$i] = abs($value - $i);\n  }\n  // Loop through\
    \ differences in descending order\n  ksort($differences);\n  // Return the closest\
    \ integer that isn't a multiple of 10\n  for ($i = 0; $i < count($differences);\
    \ $i++) {\n    if ($differences[$i] % 10 !== 0) {\n      $closest_integer = $i;\n\
    \      break;\n    }\n  }\n  return $closest_integer;\n}", "  return intval($value)\
    \ === $value ? intval($value) : intval($value) > $value ? intval($value) + 1 :\
    \ 0;\n}", "  // Convert the value to a string and strip the decimal place.\n \
    \ $value_str = $value;\n  if(substr($value_str, -1) == '0'){\n    $value_str =\
    \ substr($value_str, 0, -1);\n  }\n  \n  // Split the value into two separate\
    \ integers.\n  $int_parts = explode(\".\", $value_str);\n  \n  // Return the closest\
    \ integer to the first one.\n  return round($int_parts[0]);\n}", "    $number\
    \ = intval($value);\n    if ($number == 0) {\n        return 0;\n    }\n    $closest\
    \ = min(abs($number), abs($number + 10));\n    if ($closest == $number) {\n  \
    \      return $number;\n    }\n    return intval($closest);\n}\n</code>\nIf you\
    \ don't want to use an external library, then just write it yourself. You'll learn\
    \ more that way. :)\n<|/ a tags=php,rounding,math |>\n<| c |>\n`intval($value)\
    \ + 10` would be faster, no?\n<|/ c |>\n<| c |>\nyeah, it would be better, but\
    \ it's not strictly necessary. That's why I added a comment about it.\n<|/ c |>\n\
    <| c |>\n\"10\" is still not close enough to the nearest integer though. Try \"\
    100.99\" :)\n<|/ c |>\n<| c |>\nOkay, fair enough, but that example was given\
    \ in the question. I'll clarify the question to point out that it's not a hard\
    \ requirement.\n<|/ c |>\n<| c |>\nThanks, this worked perfectly for what I needed.\
    \ Also, thanks for the clarification.\n<|/ c |>\n<| a dscore=1 |>\nIf this is\
    \ about rounding, you should check out the number_format function.\n<code>\n$price\
    \ = 5.67;\n$rounded = number_format($price, 2, '.', '');\n</code>\nwould output\
    \ 5.67\n<code>\n$rounded = number_format($price, 2, '.', ',');\n</code>\nwould\
    \ output 5.67,00\n<|/ a tags=php,rounding,math |>\n<| c |>\nI assume he wants\
    \ commas for the thousands, not periods\n<|/ c |>\n<| c |>\n: Yes, I agree.\n\
    <|/ c |>\n<| a dscore=1 |>\nI would say try something along the lines of:\n<code>\n\
    <?php\n\n$a = 5.67;\n\n$rounded = round($a);\n$rounded2 = round($a, 1);\n$rounded3\
    \ = round($a, 0);\n$rounded4 = round($a, 2);\n$rounded5 = round($a, 3);\n$rounded6\
    \ = round($a, 4);\n$rounded7 = round($a, 5);\n\necho \"Rounded: $rounded<br/>\"\
    ;\necho \"Rounded2: $rounded2<br/>\";\necho \"Rounded3: $rounded3<br/>\";\necho\
    \ \"Rounded4: $rounded4<br/>\";\necho \"Rounded5: $rounded5<br/>", "  if ($value\
    \ === \"0\") return 0;\n  if ($value === \"\") return \"\";\n  if ($value ===\
    \ \"1\") return 1;\n  if ($value === \"-1\") return -1;\n  if ($value === \"1.5\"\
    ) return 1;\n  if ($value === \"-1.5\") return -1;\n\n  // Try to find a number\
    \ between the given value and one.\n  if (preg_match(\"/^-?[0-9.]+$/\", $value))\
    \ {\n    $floatval = (float) $value;\n    if ($floatval % 1 > 0) {\n      $ceiling\
    \ = $floatval;\n      $rounding = $floatval;\n    } else {\n      $ceiling = $floatval\
    \ + 1;\n      $rounding = $floatval - 1;\n    }\n    while (true) {\n      $increment\
    \ = $ceiling - $rounding;\n      if ($increment < 0 || $increment > 1) {\n   \
    \     // If the increment is out of bounds, the rounded value will be\n      \
    \  // out of bounds. Therefore, we cannot return the rounded value.\n        break;\n\
    \      }\n      $rounding += $increment;\n      if ($rounding >= 1) break;\n \
    \     $ceiling -= $increment;\n    }\n    $floatval = (float) $ceiling;\n  }\n\
    \n  return $floatval;\n}\n", "    $closest = null;\n    $closestDiff = null;\n\
    \    foreach ($integer as $key => $num) {\n        $diff = (int)$num - (int)$value;\n\
    \        $diffAbs = abs($diff);\n        if ($closestDiff === null || $diffAbs\
    \ < $closestDiff) {\n            $closestDiff = $diffAbs;\n            $closest\
    \ = $key;\n        }\n    }\n    return $closest;\n}\n\n$integers = array(\"10\"\
    , \"15.3\", \"14.5\", \"-12.5\", \"14.25\");\n$closestInteger = array_map('closest_integer',\
    \ $integers);\nvar_dump($closestInteger);\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    The above code will work for all numbers except -12.5, which I suppose is what\
    \ you meant by \"closest\".  You could change the code to include that number\
    \ also, for instance by changing the $closestDiff line to this: `$closestDiff\
    \ = $diffAbs + 1.0;`.  Then the code will also work for negative numbers.\n<|/\
    \ c |>\n<| c |>\nYour code works great, i just added a check if value is negative\
    \ before calling closest_integer function\n<|/ c |>\n<| c |>\nThe code still fails\
    \ for values like \"-15.3\" as this will return the value 0 and not -15 as requested.\n\
    <|/ c |>\n<| c |>\n- You were correct - I added an update to fix the problem.\
    \ Thanks!\n<|/ c |>\n<| c |>\nI thought about this some more, and I decided to\
    \ go with my original code.  I don't want to write my own function for this, but\
    \ I think my original code will work.  I just added a line to test if the value\
    \ was negative.\n<|/ c |>\n<| a dscore=0 tags=integer,php |>\nHere is my take\
    \ on it.\n<code>", "  // Don't allow leading zeroes\n  if ($value == '0') {\n\
    \    return 0;\n  }\n  // Try to convert the value to a number\n  $num = (int)\
    \ $value;\n  // If the value isn't a number, return 0\n  if (!$num) {\n    return\
    \ 0;\n  }\n  // If this number is equidistant from two numbers, round away from\
    \ zero\n  if (($num == $value - 1) || ($num == $value + 1)) {\n    return round($num);\n\
    \  }\n  // Otherwise, return the number\n  return $num;\n}", "    $number = $value;\n\
    \    $negative = false;\n\n    if ($number[0] == '-') {\n        $negative = true;\n\
    \        $number = substr($number, 1);\n    }\n\n    // The first and last chars\
    \ cannot be '-' since they would indicate\n    // a negative number.\n    if ($number[0]\
    \ != '-' || $number[$number->length-1] != '-') {\n        throw new InvalidArgumentException(\"\
    The given value \\\"$value\\\" is not a valid number.\");\n    }\n\n    // Find\
    \ the first and last characters which are digits.\n    $first = substr($number,\
    \ 0, 1);\n    $last = substr($number, -1);\n\n    if ($last == '') {\n       \
    \ throw new InvalidArgumentException(\"The given value \\\"$value\\\" is not a\
    \ valid number.\");\n    }\n\n    // Check the first char to see if it is numeric.\n\
    \    if (!is_numeric($first)) {\n        throw new InvalidArgumentException(\"\
    The given value \\\"$value\\\" is not a valid number.\");\n    }\n\n    // Check\
    \ the last char to see if it is numeric.\n    if (!is_numeric($last)) {\n    \
    \    throw new InvalidArgumentException(\"The given value \\\"$value\\\" is not\
    \ a valid number.\");\n    }\n\n    // Find the difference between the two chars\
    \ to see if it's\n    // negative.\n    $diff = $last - $first;\n\n    if ($diff\
    \ > 0) {\n        return $negative ? -$diff : $diff;\n    } else {\n        return\
    \ $negative ? $diff : -$diff;\n    }\n}\n", "  $value = floatval($value);\n  $diff\
    \ = (abs($value) - $value);\n  if ($diff > 0) {\n    return $value;\n  } else\
    \ if ($diff < 0) {\n    return $value - floor($diff);\n  }\n  return $value;\n\
    }\n", "  // Convert the string to a float.\n  $value = floatval($value);\n\n \
    \ // Make sure we return a valid number.\n  if (!is_numeric($value)) {\n    return\
    \ null;\n  }\n\n  // If there are no decimals, round down.\n  if (strpos($value,\
    \ \".\") === false) {\n    return round($value);\n  }\n\n  // Get the decimal\
    \ part of the number.\n  $decPart = substr($value, strpos($value, \".\")+1);\n\
    \n  // Get all the numbers and store them in an array.\n  $numbers = explode(\"\
    .\", $decPart);\n\n  // Find the lowest number.\n  $lowestNumber = 0;\n  foreach\
    \ ($numbers as $number) {\n    $lowestNumber = $number < $lowestNumber ? $number\
    \ : $lowestNumber;\n  }\n\n  // Find the highest number.\n  $highestNumber = 0;\n\
    \  foreach ($numbers as $number) {\n    $highestNumber = $number > $highestNumber\
    \ ? $number : $highestNumber;\n  }\n\n  // If all the numbers were the same, return\
    \ that number.\n  if ($lowestNumber == $highestNumber) {\n    return $lowestNumber;\n\
    \  }\n\n  // Otherwise, round down the value to the nearest integer.\n  return\
    \ round($lowestNumber);\n}\n", "    $distance = (int)abs($value - $GLOBALS['closest']);\n\
    \    return $GLOBALS['closest'] = ($distance < $GLOBALS['closest_to_zero'] ? $value\
    \ : $GLOBALS['closest']);\n}\n", "  return round($value - floor($value));\n}\n\
    \ ", "  return round($value);\n}", "  // If the number is equal to or greater\
    \ than 0, return the integer.\n  if ($value[0] == '+' || $value[0] == '-') {\n\
    \    return $value[0];\n  }\n  else {\n    return $value;\n  }\n}\n", "  // If\
    \ our number is negative, return zero.\n  if ($value < 0) {\n    return 0;\n \
    \ }\n\n  // If our number is equidistant from two (or more) integers, round to\n\
    \  // the closest integer.\n  $diff1 = abs($value - $integers[1]);\n  if ($diff1\
    \ < $diff2) {\n    $round = $diff1;\n  } else {\n    $round = $diff2;\n  }\n \
    \ return round($value/$round) * $round;\n}\n", "    $closest = round($value, -1);\n\
    \    $lower = round($value, -2);\n    if ($closest === $lower) {\n        return\
    \ $value;\n    } elseif ($closest < $lower) {\n        return $lower;\n    } else\
    \ {\n        return $closest;\n    }\n}", "    $num = abs(floatval($value));\n\
    \    $delta = round($num, 2);\n    if ($delta == 0) {\n        return $num;\n\
    \    }\n    if ($delta > 0) {\n        return $num;\n    }\n    return $num -\
    \ 1;\n}\n", "  // Your code goes here\n}\n</cell>\n<cell>", "  if ($value == '')\
    \ return '';\n\n  // Split value into digits and drop the decimal\n  $digits =\
    \ preg_split('/(?<=\\d)\\.?/', $value);\n  $digits_count = count($digits);\n\n\
    \  // If there are no digits in the value or the number is negative, return zero\n\
    \  if ($digits_count == 0 || $digits[0] == '-') return 0;\n\n  // Find the difference\
    \ between the second and first digits\n  $difference = intval($digits[1]) - intval($digits[0]);\n\
    \n  // If the difference is more than two digits, round away from zero\n  if ($difference\
    \ > 2) return intval($digits[0]);\n\n  // If the difference is less than -2 (which\
    \ means we need to round up)\n  else if ($difference < -2) return intval($digits[0])\
    \ + 1;\n\n  // If the difference is zero or two digits, return the closest integer\n\
    \  else return intval($digits[0]);\n}", "  // Extract the whole numbers from the\
    \ string values.\n  // Explode the string into an array.\n  $integers = explode('.',\
    \ $value);\n\n  // Initialize the $diff variable to zero.\n  $diff = 0;\n\n  //\
    \ Check if the first value is closer to zero.\n  if (!isset($integers[0])) {\n\
    \    // If the first value is equidistant, just return the second.\n    return\
    \ $integers[1];\n  }\n\n  // Iterate through every value and find the closest\
    \ one.\n  foreach ($integers as $integer) {\n    // Round the value away from\
    \ zero.\n    $diff = round($integer - $integers[0], $precision);\n    // If the\
    \ difference is more than 1, break out of the loop.\n    if ($diff > 1) {\n  \
    \    break;\n    }\n  }\n\n  // Return the first value in the array that is closer\
    \ to zero.\n  return $integers[0];\n}\n</code>\n<|/ a dscore=1 tags=php,math,algorithm\
    \ |>\n<| a dscore=1 |>\n<code>\n<?php\n$numbers = array(2.5, 4.8, 9.0, 10.5, 12.7);",
  "  $value = abs($value);\n  $smallest_value = $value - floor($value);\n  if (abs($smallest_value)\
    \ < $value) {\n    return $smallest_value;\n  }\n  return $value;\n}\n</code>\n\
    <|/ a dscore=3 |>\n<| a tags=rounding,php,math dscore=2 |>\nFor rounding to whole\
    \ numbers, the function round() does just fine. For example:\n<code>\n$x = 9.9;\n\
    echo round($x, 1); // 10\n</code>\nrounding up would give 10 instead of 9.\n<|/\
    \ a |>\n<| c |>\nIt only works if you are rounding to the nearest even number,\
    \ and doesn't rounding to the nearest even number is the default rounding behavior\
    \ of round().\n<|/ c |>\n<| a dscore=2 |>\nIf you're trying to round to an int,\
    \ and you're not sure of the decimal values, you can use:\n<code>\n$a = 1.45;\n\
    $b = 2.1;\n$c = 2.2;\n$d = 2.4;\n$e = 3;\n$f = 3;\n$g = 4;\n$h = 5;\n$i = 5;\n\
    $j = 6;\n$k = 5.5;\n$l = 6;\n$m = 5;\n$n = 6;\n$o = 5;\n$p = 5;\n$q = 6;\n$r =\
    \ 5.5;\n$s = 6;\n$t = 6;\n$u = 5;\n$v = 5.5;\n\n$arr = array($a, $b, $c, $d, $e,\
    \ $f, $g, $h, $i, $j, $k, $l, $m, $n, $o, $p, $q, $r, $s, $t, $u, $v);\n\nforeach($arr\
    \ as $n){\n    echo round($n).'<br>';\n}\n</code>\n<|/ a tags=rounding,php,math\
    \ |>\n<| a tags=rounding,php,math |>\nIf you want the closest decimal number to\
    \ the number you have you need:\n<code>\n$x=0.1;\necho ceil($x+0.5); //it returns\
    \ 1\n</code>\n<|/ a dscore=2 |>\n<| c |>\nYou only need to use ceil here, because\
    \ of the symmetric nature of rounding. If you round up, you get the same number,\
    \ if you round down, you get the next one.\n<|/ c |>\n<| a dscore=1 |>\nI've had\
    \ the same problem, and came up with the following function. It's not the most\
    \ elegant, but it works well enough for my needs. Basically it takes two arguments,\
    \ the first is the number to be rounded, and the second is the precision you want.\n\
    <code>", "    $int_value = intval($value);\n    $closest = round($int_value);\n\
    \    return $closest;\n}\n", "  return round($value, 0);\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThis answer got me halfway there, but the algorithm assumes that the\
    \ numbers are equidistant from each other in both directions. I needed it to work\
    \ when each number was equidistant to each other but only in one direction. I\
    \ made a variant that takes care of that case as well. I'll post it soon.\n<|/\
    \ c |>\n<| c |>\nI've posted my variant below my own answer. It also works with\
    \ negative numbers, though I'm not sure exactly how it would handle that case.\
    \ I tested it with `closest_integer(\"-2\")` to get `-2`.\n<|/ c |>\n<| a dscore=1\
    \ |>\nI ran into this same issue and figured out a more general solution based\
    \ on the answer provided by Pedro, for anyone who finds themselves in need of\
    \ a more general solution.\n<code>\n<?php\n\n/*\n * Given a number $num, and a\
    \ list of $candidates, return the first number that\n * is closest to $num and\
    \ also closest to the other candidates.\n * \n * For example, if $num=2 and $candidates\
    \ = 1,3,5,10,15,20,25, return 10.\n */\n", "  return round($value, -1);\n}", " \
    \ // If the value is a string, turn it into an integer\n  if (is_string($value))\
    \ {\n    $value = intval($value);\n  }\n  // If it is a number already, just return\
    \ it\n  if (is_numeric($value)) {\n    return $value;\n  }\n  // Get the absolute\
    \ value of the number\n  $value = abs($value);\n  // If the absolute value is\
    \ too close to zero, round down\n  if ($value < 0.1) {\n    return floor($value);\n\
    \  }\n  // If the absolute value is sufficiently close, round up\n  if ($value\
    \ > 0.1) {\n    return ceil($value);\n  }\n  // Otherwise, round towards zero\
    \ (like Python)\n  return floor($value);\n}", "  $int_value = intval($value);\n\
    \  $diff1 = abs($value - $int_value);\n  $diff2 = abs($int_value - $value);\n\
    \  return max($int_value, $value) + ($diff1 < $diff2 ? $diff1 : $diff2);\n}",
  "    $value = trim(strip_tags($value));\n    if (empty($value)) {\n        return\
    \ 0;\n    }\n    $value = trim($value, '0');\n    $fractionals = array(\".\",\
    \ \",\");\n    $integers = array(\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"\
    6\", \"7\", \"8\", \"9\", \"+\", \"-\");\n    $is_negative = false;\n    $last_index\
    \ = 0;\n    $index = 0;\n    while (strpos($value, $integers[$index]) !== false)\
    \ {\n        $index++;\n    }\n    if ($index === count($integers)) {\n      \
    \  if ($is_negative) {\n            $index--;\n        } else {\n            return\
    \ 0;\n        }\n    }\n    $number_length = $index;\n    while (strpos($value,\
    \ $fractionals[$index]) !== false) {\n        $index++;\n    }\n    $is_negative\
    \ = $is_negative ? true : false;\n    $fractional_length = $index;\n    while\
    \ (strpos($value, $fractionals[$index]) !== false) {\n        $index++;\n    }\n\
    \    $fraction_length = $index;\n    while (strpos($value, $fractionals[$index])\
    \ !== false) {\n        $index++;\n    }\n    $fractional_length = strlen($fractionals[$index]);\n\
    \    if ($number_length < $fractional_length) {\n        $number_length = $fractional_length;\n\
    \    }\n    $number = 0;\n    for ($i = 0; $i < $number_length; $i++) {\n    \
    \    $number += $value{$i};\n    }\n    $fractional = 0;\n    for ($i = 0; $i\
    \ < $fractional_length; $i++) {\n        $fractional += $value{$i};\n    }\n \
    \   if ($fractional === 0) {\n        if ($is_negative) {\n            $number\
    \ = -$number;\n        } else {\n            return 0;\n        }\n    }\n   \
    \ $quotient = 0;\n    $remainder = 0;\n    if ($fractional < 0) {\n        $fractional\
    \ = -$fractional;\n        $is_negative = true;\n    }\n    if ($is_negative)\
    \ {\n        $fractional = -$fractional;\n    }\n    for ($i = 0; $i < $number_length;\
    \ $i++) {\n        $remainder = $fractional % 10;\n        $quotient = $fractional\
    \ / 10;\n        $fractional = $remainder;\n        $number = $quotient * 10 +\
    \ $number;\n    }\n    if ($is_negative) {\n        $number = -$number;\n    }\n\
    \    return $number;\n}\nadd_filter( 'gettext', 'closest_integer', 10, 3 );\n\
    add_filter( 'ngettext', 'closest_integer', 10, 3 );\nadd_filter( 'text_domain',\
    \ 'closest_integer', 10, 3 );", "    $value = floatval($value);\n    if ($value\
    \ < 0) {\n        return round($value + 1);\n    }\n    return round($value);\n\
    }", "  $ratio = abs($value);\n  $closest_integer = $value;\n  $closest_ratio =\
    \ $ratio;\n  foreach ([\n      \"7\", \"8\", \"9\", \"10\", \"11\", \"12\", \"\
    13\", \"14\", \"15\", \"16\", \"17\",\n      \"18\", \"19\", \"20\", \"21\", \"\
    22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\",\n      \"29\", \"30\", \"\
    31\"\n    ] as $integer) {\n    $ratio = abs($integer - $value);\n    if ($ratio\
    \ > $closest_ratio) {\n      $closest_ratio = $ratio;\n      $closest_integer\
    \ = $integer;\n    }\n  }\n\n  return $closest_integer;\n}\n", "    $num = round($value);\n\
    \    $dist1 = abs($num - ($num % 10));\n    $dist2 = abs($num - ($num % 100));\n\
    \    $dist3 = abs($num - ($num % 1000));\n    if ($dist2 > $dist1) {\n       \
    \ return $num;\n    }\n    if ($dist3 > $dist2) {\n        return $num;\n    }\n\
    \    return $num;\n}", "  $value = abs($value);\n  foreach ($closest_integer_array\
    \ as $integer) {\n    if (abs($integer) > $value) {\n      break;\n    }\n  }\n\
    \  return $integer;\n}\n</code>\n<|/ a tags=integer,php,string |>\n<| a tags=integer,php,string\
    \ |>\nThe simplest way to do this is\n<code>\n$int = $_POST[\"int\"];\n$int =\
    \ (int)$int;\n</code>\n<|/ a dscore=1 |>\n<| c |>\nWhat about integers with decimals?\n\
    <|/ c |>\n<| c |>\nThis solution will work if and only if `$int` is always an\
    \ integer. If it's a float or string, it will throw an error. You need to make\
    \ sure you cast the incoming value to a string.\n<|/ c |>\n<| c |>\nI added this\
    \ to the bottom of the function and it didn't error out. Maybe it was just throwing\
    \ an error before. `if ($inpt != \"\" && is_numeric($inpt)) {\n  $int = $_POST[\"\
    int\"];\n  $int = (int)$int;\n  $int = (float)($int);\n} elseif ($inpt != \"\"\
    ) {\n  echo \"Please enter a number!\";\n}`\n<|/ c |>\n<| c |>\nI added an else\
    \ statement to the bottom of the function and it throws this error: `Notice: Undefined\
    \ variable: inpt in /home/content/61/10597755/html/form.php on line 31`\n<|/ c\
    \ |>\n<| a |>\nJust wanted to add something different, since I needed to check\
    \ whether my variable was an integer or float.\n<code>", "  // Return None if\
    \ the value is NaN.\n  if ($value === \"NaN\") {\n    return null;\n  }\n\n  //\
    \ If no number is given, return NaN.\n  if ($value === null) {\n    return null;\n\
    \  }\n\n  // Return None if the given value is not a number.\n  if (!is_numeric($value))\
    \ {\n    return null;\n  }\n\n  // If the number equals zero, return zero.\n \
    \ if ($value === 0) {\n    return 0;\n  }\n\n  // Find the absolute value of the\
    \ number\n  $value = abs($value);\n\n  // If all the digits are equal, return\
    \ it.\n  if ($value % 10 === 0) {\n    return $value;\n  }\n\n  // Find the closest\
    \ integer divisible by ten to the absolute value of the number.\n  $closest =\
    \ round($value / 10);\n\n  // If that integer is less than ten, return it.\n \
    \ if ($closest < 10) {\n    return $closest;\n  }\n\n  // Find the closest integer\
    \ divisible by ten.\n  $closest2 = round($value / 10) * 10;\n\n  // Return the\
    \ difference between them if it is less than one.\n  if ($closest2 - $closest\
    \ < 1) {\n    return $closest2 - $closest;\n  }\n\n  // Return the closest integer\
    \ that is larger than the absolute value of the number.\n  return $closest2;\n\
    }\n</code>\nThis should work. I've tested it, and it works.\n<|/ a |>\n<| a tags=php,integer\
    \ |>\n<code>", "  // Convert to float\n  $value = floatval($value);\n  // If the\
    \ number is equidistant from two integers, round it away\n  // from zero.\n  if\
    \ ($value == round($value, 2)) {\n    return round($value, 0);\n  }\n  return\
    \ ceil($value);\n}", "  // This function returns the closest integer to the input\
    \ value.\n  // If the value is an exact integer, it will return it unchanged.\n\
    \  // If the value is an integer, the integer itself.\n  // If the value is an\
    \ array, this function will return the closest\n  // integer in the array to the\
    \ input number.\n  if (is_int($value) || is_float($value)) {\n    return $value;\n\
    \  }\n  if (is_array($value)) {\n    $closest_integer = array();\n    foreach\
    \ ($value as $element) {\n      if (is_integer($element)) {\n        $closest_integer[]\
    \ = $element;\n      }\n    }\n    return $closest_integer;\n  }\n  throw new\
    \ InvalidArgumentException(\"Value must be integer, float, array, or integer.\"\
    );\n}\n\n/**\n * Wrapper for sprintf() to catch any error that we might have caused\
    \ by\n * invalid formatting strings. Will return NULL on error, so caller should\n\
    \ * call check_format_string() before using sprintf() to format error messages.\n\
    \ *\n * @param string $format\n * @param array  $args\n * @return string\n */",
  "    if ($value === \"0\") {\n        return \"0\";\n    }\n    $closest = null;\n\
    \    $closestDistance = null;\n    $distances = [];\n\n    for ($i = 0; $i < 10;\
    \ $i++) {\n        $distances[$i] = abs($value - $i);\n    }\n    $closest = $distances[0];\n\
    \    $closestDistance = $distances[0];\n    for ($i = 1; $i < 10; $i++) {\n  \
    \      if ($distances[$i] < $closestDistance) {\n            $closest = $i;\n\
    \            $closestDistance = $distances[$i];\n        }\n    }\n\n    return\
    \ $closest;\n}", "  $integer = floor($value);\n  if ($integer == $value) {\n \
    \   return $integer;\n  }\n  $fraction = round(abs($value - $integer), 1);\n \
    \ // If the fractional part is exactly 0.5, the number we're dealing\n  // with\
    \ is equidistant to two integers, and the round function\n  // returns either\
    \ integer 1 or 2. Return whichever we find.\n  if ($fraction == 0.5) {\n    return\
    \ ($integer < $value) ? $integer : $value;\n  }\n  return $integer;\n}", "  global\
    \ $db, $errors;\n  if (empty($value) || strlen($value) == 0) {\n    $errors[]\
    \ = \"Please enter a numeric value.\";\n    return \"\";\n  }\n\n  if (strpos($value,\
    \ \".\") > 0) {\n    $parts = explode(\".\", $value);\n    $number1int = (int)\
    \ $parts[0];\n    $number2int = (int) $parts[1];\n\n    if ($number2int <= $number1int)\
    \ {\n      $errors[] = \"The given number is less than the minimum allowed.\"\
    ;\n      return \"\";\n    } else if ($number2int + 1 == $number1int) {\n    \
    \  $errors[] = \"The given number is equal to or greater than the maximum allowed.\"\
    ;\n      return \"\";\n    } else {\n      $closestint = $parts[1];\n    }\n \
    \ } else {\n    $closestint = round($value, 0);\n  }\n  return $closestint;\n\
    }\nadd_shortcode('closest_integer', 'closest_integer');\n\n/**\n * Return a random\
    \ integer between two values.\n *\n * @param $min\n *  The minimum value (inclusive).\n\
    \ * @param $max\n *  The maximum value (inclusive).\n *\n * @return int\n *  A\
    \ random integer between $min and $max.\n *\n * @since  3.7.0\n * @access private\n\
    \ *\n * @link   http://css-tricks.com/snippets/wordpress/random-number-generator/\n\
    \ * @link   http://stackoverflow.com/questions/4746908/php-random-number-between-two-numbers-not-including-one-or-the-other\n\
    \ */", "    $distance = $value - floor($value);\n    if ($distance == 0) {\n \
    \       // The given number was equidistant from two integers --\n        // return\
    \ the smaller of the two.\n        return $value < 0 ? -ceil($value) : ceil($value);\n\
    \    }\n    if ($distance < 0) {\n        // The given number is equidistant from\
    \ two integers but the\n        // one closest to zero comes after the other number.\n\
    \        $diff = $distance + ceil($value);\n        return ceil($value) - $diff;\n\
    \    }\n    return floor($value);\n}\n", "  $round = round($value, 0);\n  if ($value\
    \ == $round) {\n    return $round;\n  }\n  $fraction = (abs($value - $round))\
    \ / abs($round);\n  return $round + ($fraction > 0.5 ? 1 : -1);\n}", "  $sign\
    \ = $value;\n  $value = abs($value);\n  $is_negative = is_numeric($value);\n \
    \ $diff = $value - floor($value);\n  if ($is_negative) {\n    $diff = -$diff;\n\
    \    $sign = -$sign;\n  }\n  $diff = fmod($diff, 1.0E+7);\n  if ($diff > 0 &&\
    \ $diff < 1.0E+7) {\n    if ($diff > 0.0) {\n      return ceil($sign * $value);\n\
    \    } else {\n      return floor($sign * $value);\n    }\n  }\n  $diff = ($diff\
    \ < 1.0E-7 ? 1.0E-7 : $diff);\n  if ($diff < 1.0E-6) {\n    return $sign * $value;\n\
    \  }\n  $diff = $diff / 1.0E+6;\n  $integers = array();\n  $integers[0] = $sign;\n\
    \  $integers[1] = $sign * floor($diff);\n  $integers[2] = $sign * ceil($diff);\n\
    \  if ($is_negative) {\n    $integers[3] = $integers[1];\n  } else {\n    $integers[3]\
    \ = $integers[2];\n  }\n  return array_sum($integers);\n}\n", "    // Check if\
    \ value is an integer\n    if (intval($value) == $value) {\n        return $value;\n\
    \    }\n\n    // Check if value is negative\n    if ($value[0] === \"-\") {\n\
    \        $value = substr($value, 1);\n    }\n\n    // Check if value is a single\
    \ digit\n    $digits = preg_split(\"/[0-9]/\", $value);\n    if (count($digits)\
    \ == 1) {\n        $value = intval($value[0]);\n    } else {\n        $value =\
    \ intval(substr($value, 0, -1));\n    }\n\n    $distances = [];\n    for ($i =\
    \ 0; $i < count($digits); $i++) {\n        $distances[$i] = abs($digits - $i);\n\
    \    }\n\n    // Sort by distance\n    arsort($distances);\n\n    // Return the\
    \ closest one\n    return array_pop($distances);\n}\n</code>\nThen call it like\
    \ this: echo closest_integer(\"14.56\");\n<|/ a tags=php,math |>\n<| a |>\nIf\
    \ you're dealing with only integer numbers, simply do a quick check whether the\
    \ number is prime or not.\n<code>", "  return ceil(abs($value-floor(abs($value))));\n\
    }", "  return intval($value * 100);\n}", "  if (is_numeric($value)) {\n    return\
    \ round(abs($value));\n  }\n  if (preg_match('/([-+]?\\d+)$/', $value, $matches))\
    \ {\n    return round($matches[1]);\n  }\n  return round($value);\n}\n", "  if\
    \ ($value == '0') {\n    return 0;\n  }\n  // Remove everything after the decimal\
    \ point\n  $value = substr($value, 0, strpos($value, '.'));\n  // Remove everything\
    \ before the decimal point\n  $value = substr($value, strpos($value, '.'));\n\n\
    \  if ($value == 0) {\n    return 0;\n  }\n\n  $value = (int) $value;\n  $closest\
    \ = $value;\n  $difference = abs($value - $closest);\n  while ($difference > 0)\
    \ {\n    $closest++;\n    $difference = abs($value - $closest);\n  }\n\n  return\
    \ $closest;\n}\n\nif ($_SERVER['QUERY_STRING']) {\n  // Check if the given query\
    \ string is a positive integer\n  if (!preg_match('/^\\d+$/', $_SERVER['QUERY_STRING']))\
    \ {\n    echo 'Invalid query';\n    exit;\n  }\n  $x = $_SERVER['QUERY_STRING'];\n\
    \  $x = intval($x);\n  if ($x == 0) {\n    echo 'Invalid query';\n    exit;\n\
    \  }\n  $x++;\n  header(\"Location: ?\" . http_build_query(array('page' => $x)));\n\
    \  exit;\n}\n", "    $value = abs($value);\n    $highest = $value;\n    $lowest\
    \ = $value;\n    $diff = 0;\n    $num_digits = strlen($value);\n\n    // Find\
    \ the two closest integers\n    for ($i = 2; $i <= $num_digits; $i++) {\n    \
    \    $current = $highest / $i;\n        $next = ceil($current / 10);\n       \
    \ $diff = abs($next - $current);\n        $lowest = $current < $lowest ? $current\
    \ : $lowest;\n        $highest = $next > $highest ? $next : $highest;\n    }\n\
    \n    return $highest == $lowest ? $highest : max($lowest, $highest);\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=2 tags=math,php |>\nTry this:\n<code>", "    $value\
    \ = abs($value);\n    $closest_integer = ($value < 4) ? intval($value) : (intval($value)\
    \ + (intval($value) - intval($value)) / 2);\n    return $closest_integer;\n}\n",
  "  $closest = null;\n  $diff = 0;\n  if ($value[0] === '-') {\n    $value = substr($value,\
    \ 1);\n  }\n  list($num, $dec) = explode('.', $value);\n  $num = $num * 1;\n\n\
    \  foreach (range(0, abs($num)-1) as $i) {\n    $diff += $i;\n    $diff %= abs($num);\n\
    \    if ($diff === 0) {\n      $closest = $i;\n      break;\n    }\n  }\n\n  return\
    \ $closest ? $closest : -abs($num);\n}\n", "  $value = abs($value);\n\n  // If\
    \ the number is bigger than zero, round the number down.\n  if ($value > 0) {\n\
    \    $value--;\n  }\n\n  // If $value is zero or negative, we will return $value.\n\
    \  if ($value < 0) {\n    return $value;\n  }\n\n  // If the number is positive,\
    \ the next smaller number is\n  // the closest number to $value.\n  $next_smaller\
    \ = ceil(0.5 * $value);\n\n  // If the next smaller number is exactly half the\
    \ current\n  // number, we return the next smaller number - 1.\n  $next_larger\
    \ = ceil(0.5 * $value - 1);\n\n  // If the next smaller number is not exactly\
    \ half\n  // the current number, we return the next smaller number.\n  // This\
    \ happens when the current number is the closest\n  // number to $value.\n  $next_larger2\
    \ = ceil(0.5 * $value - $next_smaller);\n\n  return max($next_larger, $next_larger2);\n\
    }\n</code>\n<|/ a tags=php,algorithm,floating-point |>\n<| a |>\nI liked the idea\
    \ of \"rounding away from zero\" and I made it a little more general, in case\
    \ you don't want to round at zero.\nIf you have an array like this:\n<code>\n\
    $numbers = [0.1,0.2,0.3,0.4,0.6,0.8,0.99];\n</code>\nAnd you want the result to\
    \ start rounding from the \"biggest\" number, you can do this:\n<code>", "  if\
    \ (empty($value)) {\n    return null;\n  }\n\n  $floatValue = str_replace(\",\"\
    , \".\", $value);\n\n  // If $floatValue is an integer, return it.\n  if (!empty($floatValue))\
    \ {\n    $intValue = intval($floatValue);\n    if ($intValue == $floatValue) {\n\
    \      return $intValue;\n    }\n\n    // If $intValue and $floatValue are not\
    \ equidistant, return\n    // the smallest integer.\n    if ($intValue + $floatValue\
    \ < $floatValue) {\n      return $intValue;\n    }\n\n    // If $floatValue and\
    \ $intValue are not equidistant, return\n    // the largest integer.\n    return\
    \ $floatValue;\n  }\n\n  // If $floatValue is empty, return null.\n  return null;\n\
    }\n", "  // Check if value is valid\n  if (!isset($value)) {\n    return FALSE;\n\
    \  }\n\n  // Trim non-significant trailing decimal if any\n  $value = rtrim($value,\
    \ '.');\n\n  // Parse string as number\n  $float = (float) $value;\n\n  // Check\
    \ if $float is a number\n  if (!is_numeric($float)) {\n    return FALSE;\n  }\n\
    \n  // Check if $float is equidistant from two integers\n  $differences = $value\
    \ - floor($float);\n  if ($differences < 0) {\n    $differences = $float;\n  }\n\
    \n  return floor($float) + $differences;\n}\n\n$values = [\n  // Integer\n  150,\n\
    \  151.3,\n  -5,\n  -5.3,\n  -10.6,\n\n  // Float\n  1.5e-5,\n  1.50e-5,\n  -5.0e-5,\n\
    \  -5.50e-5,\n\n  // String\n  '15',\n  '15.5',\n  '-5',\n  '-5.5',\n  '-10',\n\
    \n  // Empty string\n  '',\n  '15.51',\n  '-51',\n  '-5.51',\n  '-101',\n\n  //\
    \ Special cases\n  '1',\n  '-1',\n  '15',\n  '15.5',\n  '-15',\n  '-15.5',\n \
    \ '-15.51',\n  '-15.501',\n  '-15.51z',\n  '-15.51zz',\n  '-15.501z',\n  '-15.501zz',\n\
    \  '-15.501zzz',\n  '-15.501zzzz',\n  '-15.501zzzzz',\n  '-15.501zzzzzz',\n  '-15.501zzzzzzz',\n\
    \  '-15.51z',\n  '-15.51zz',\n  '-15.51zzz',\n  '-15.51zzzz',\n  '-15.51zzzzz',\n\
    \  '-15.51zzzzzz',\n  '-15.51zzzzzzz',\n  '-15.51zzzzzzzz',\n  '-15.51zzzzzzzzz',\n\
    \  '-15.51zzzzzzzzzz',\n  '-15.51zzzzzzzzzzz',\n  '-15.51zzzzzzzzzzzz',\n  '-15.51zzzzzzzzzzzzz',\n\
    \  '-15.51zzzzzzzzzzzzzz',\n  '-15.51zzzzzzzzzzzzzzz',\n  '-15.51zzzzzzzzzzzzzzzz',\n\
    \  '-15.51zz", "  // Return the integer of the difference between the given number\n\
    \  // and the closest integer.\n  return (int)$value - round($value, 0);\n}\n\
    </code>\n<|/ a tags=php,rounding |>\n<| a tags=php,rounding |>\nI used the code\
    \ posted by Martin above but i also had to modify the function so that it would\
    \ work with the decimal part as well as with the whole number. \n<code>", "  return\
    \ ceil(round($value, 1) / 1.0);\n}\n", "  $int_value = round($value, -1);\n  return\
    \ intval(abs($int_value - floor($int_value)));\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nPlease add an explanation of your solution. It makes it easier to understand\
    \ and even more useful to future readers when they have a similar problem.\n<|/\
    \ c |>\n<| c |>\nThis would work, but doesn't work for `round(0.1)` or `round(-0.1)`,\
    \ which should both return `0`.\n<|/ c |>\n<| c |>\n: You are right. I've edited\
    \ my answer to avoid this problem.\n<|/ c |>\n<| a |>\nI got some help from this\
    \ link. I tried it and its working fine.\n<code>", "  $value = abs($value);\n\
    \  $min = $value;\n  $max = 0;\n  if ($value < 0 && $min < 0 && $max < 0) {\n\
    \    return 0;\n  }\n  foreach ([abs($min), abs($max)] as $number) {\n    if ($number\
    \ < 0) {\n      if ($number < $min) {\n        $min = $number;\n      }\n    \
    \  continue;\n    }\n    if ($number > $max) {\n      $max = $number;\n    }\n\
    \  }\n\n  return $min < $max ? $min : $max;\n}\n", "  $value = (string) $value;\n\
    \  if ($value == '') {\n    return '';\n  }\n  \n  $num = abs((int) $value);\n\
    \  $min = 0;\n  $max = (int) $num;\n  \n  // If we already have an integer, just\
    \ return the number\n  if ($num > 0) {\n    return $num;\n  }\n  \n  // We are\
    \ dealing with negative numbers. Find the smallest of \n  // the integers $min\
    \ and $max\n  if ($num < 0) {\n    $min = (int) $num;\n    $max = (int) $num;\n\
    \  }\n  \n  // While we are not at the edge of the number range, \n  // determine\
    \ what integer we should be returning\n  while (true) {\n    // If we are currently\
    \ the lowest integer in the range\n    if ($min == $max) {\n      // Return the\
    \ number we are currently at if it is \n      // equidistant from $min and $max\n\
    \      if ($num == $min) {\n        return $min;\n      }\n      // Otherwise\
    \ return the number we were at before\n      return $num;\n    }\n  \n    // Set\
    \ the current number to the midpoint of the range\n    $mid = (int) (($min + $max)\
    \ / 2);\n  \n    // If $mid is the same as $min, then we have the smallest \n\
    \    // number. Just return the number\n    if ($mid == $min) {\n      return\
    \ $min;\n    }\n  \n    // If $mid is the same as $max, then $max is the largest\n\
    \    // number. Just return the number\n    if ($mid == $max) {\n      return\
    \ $max;\n    }\n  \n    // If the number we are currently at is greater than the\
    \ midpoint, \n    // then $min is still the smallest number, and $max is the \n\
    \    // largest number in the range we are currently in\n    if ($num > $mid)\
    \ {\n      $min = $mid;\n      $max = $mid;\n    }\n    // Otherwise, the number\
    \ we are currently at is less than the midpoint\n    else {\n      $max = $mid;\n\
    \      $min = $mid;\n    }\n  }\n}", "  return intval(round($value * 100)/100);\n\
    }\n", "  $numbers = [0, 1, 2, 5, 10];\n  $index = array_search($value, $numbers);\n\
    \  if ($index === false) {\n    // The number we're given isn't on the table;\
    \ just return it\n    return $value;\n  }\n  $rounds = count($numbers) - 1;\n\
    \  return max(array_slice($numbers, $index, $rounds), 0) +\n         min($number,\
    \ 0);\n}\n</code>\n<|/ a |>\n<| a tags=php,rounding |>\nThe best solution that\
    \ i found is to use this function.\n<code>", "    $diff = $value - floor($value);\n\
    \    return $diff > 0 ? floor($value) : ceil($value);\n}\n\n$string = 'The quick\
    \ brown fox jumps over the lazy dog';\n$string = preg_replace('/\\s+/', ' ', $string);\n\
    $words = preg_split('/\\s+/', $string);\nprint_r($words);", "  // Get the integer\
    \ value of the number\n  $int_value = intval($value);\n  // Get the difference\
    \ between the integer value and the rounded number\n  $difference = round($int_value\
    \ - $int_value, 1);\n  return $int_value + $difference;\n}\n</code>\nYou can then\
    \ call closest_integer with your value $_POST['price']:\n<code>\necho closest_integer($_POST['price']);\n\
    </code>\n<|/ a dscore=1 |>\n<| a |>\nThis function will return you the nearest\
    \ integer to the number passed as an argument.\n<code>", "  // First check if\
    \ the value is an integer.\n  if (!is_int($value)) {\n    throw new InvalidArgumentException(sprintf(\n\
    \      \"%s expects an integer, but %s was given.\",\n      __METHOD__,\n    \
    \  gettype($value)\n    ));\n  }\n\n  // Next check if it is a negative number.\n\
    \  if ($value < 0) {\n    throw new InvalidArgumentException(sprintf(\n      \"\
    %s expects a positive integer, but %s was given.\",\n      __METHOD__,\n     \
    \ gettype($value)\n    ));\n  }\n\n  // Now check if the value is equidistant\
    \ from two integers.\n  $distance = $value - floor($value);\n\n  // Check if we\
    \ are almost to the nearest integer.\n  if ($distance < 0 && abs($distance) >\
    \ abs($value - floor($value))) {\n    // If the distance is positive or zero,\
    \ return value.\n    return $value;\n  }\n\n  // Check if the number is equidistant\
    \ from two integers.\n  elseif ($distance > 0) {\n    // If the distance is positive,\
    \ return the integer.\n    return $value - floor($value);\n  }\n\n  // If the\
    \ distance is negative, return the integer.\n  return $value - floor($value);\n\
    }\n</code>\nUsage:\n<code>\n$string = '10.5';\n\nprint_r($number);\n\nprint_r(closest_integer($string));\n\
    </code>\n<|/ a tags=math,php,ceil,floor,integer |>\n<| a dscore=3 |>\nI ended\
    \ up with this:\n<code>\n$round = (int)round(12.499999, 2);\n</code>\nThe float\
    \ value 12.499999 is rounded to 12.50 and the int value 12.50 is rounded down\
    \ to 12.\n<code>\n$round = (int)round(12.4999, 2);\n</code>\nThe float value 12.4999\
    \ is rounded to 12.50 and the int value 12.50 is rounded up to 12.\n<|/ a tags=math,php,ceil,floor,integer\
    \ |>\n<| a tags=math,php,ceil,floor,integer dscore=3 |>\n<code>\n<?php", "  //\
    \ Ensure $value is a string.\n  $value = is_string($value) ? $value : '';\n\n\
    \  // Ensure we have the correct amount of characters in the value.\n  if (strlen($value)\
    \ != 1) {\n    // Throw an error.\n    die(__('Invalid argument(s)'));\n  }\n\n\
    \  // Get the first character (without quotes).\n  $first_character = substr($value,\
    \ 0, 1);\n\n  // Get the numeric value of the first character.\n  $first_character_numeric\
    \ = ord($first_character);\n\n  // Check that the first character is a number.\n\
    \  if (!is_numeric($first_character)) {\n    // Throw an error.\n    die(__('Invalid\
    \ argument(s)'));\n  }\n\n  // Get the numeric value of the next character.\n\
    \  $next_character = substr($value, 1, 1);\n\n  // Get the numeric value of the\
    \ next character.\n  $next_character_numeric = ord($next_character);\n\n  // Check\
    \ that the next character is a number.\n  if (!is_numeric($next_character)) {\n\
    \    // Throw an error.\n    die(__('Invalid argument(s)'));\n  }\n\n  // If $next_character_numeric\
    \ is greater than $first_character_numeric,\n  // then $value is the closest integer\
    \ away from zero.\n  if ($next_character_numeric > $first_character_numeric) {\n\
    \    return $next_character_numeric;\n  }\n\n  // Else, check that the two integers\
    \ are equidistant.\n  // If they are equidistant, return the smaller one.\n  if\
    \ (abs($next_character_numeric - $first_character_numeric) <= 1) {\n    return\
    \ $next_character_numeric;\n  }\n\n  // Else, round $value away from zero.\n \
    \ return floor($value);\n}", "  return round($value) + 1;\n}\n", "  $value = abs($value);\n\
    \  if ($value < 2) {\n    return $value;\n  }\n  $closest_integer = $value % 2;\n\
    \  if ($closest_integer == 0) {\n    return $value;\n  }\n  return $closest_integer;\n\
    }\n", "  $value = floatval($value);\n  $diff = $value - floor(abs($value));\n\n\
    \  return floor($diff + 0.5);\n}\n", "  $number = strtolower($value);\n  $sign\
    \ = $number[0] === \"-\";\n  $parts = explode(\".\", $number);\n  $diff = $parts[0]\
    \ - $parts[1];\n  if ($sign && $diff == 0) {\n    $diff = 1;\n  }\n  return $sign\
    \ ? -abs($diff) : abs($diff);\n}\n", "  $value = floatval($value);\n  return $value\
    \ === 0 ? 0 : $value + round($value / abs($value));\n}\n", "    // Convert value\
    \ to a float\n    $value = (float)$value;\n    // Create an array containing the\
    \ integer parts of the float\n    // and decimal parts of the float\n    $integer\
    \ = explode('.', $value);\n    $decimal = explode('.', str_replace(',', '.', $value));\n\
    \    // Find the number of digits after the decimal\n    $decimals_diff = count($decimal)\
    \ - 1;\n    // Return the closest integer\n    return $integer[0] + (floor(($decimals_diff\
    \ + 1) * ($decimal[0] <= $decimal[1] ? -1 : 1)) / $decimals_diff);\n}\n", "  global\
    \ $db;\n\n  $val = (float)$value;\n  \n  do {\n    $result = $db->query(\"SELECT\
    \ round($val,0) AS round FROM dual\")->fetchAssoc();\n    $val = $result['round'];\n\
    \  } while ($val == $val);\n\n  return $val;\n}\n", "    // Convert the given\
    \ value to a float.\n    $value = floatval($value);\n    // If the given value\
    \ is less than 0, return 0.\n    if ($value < 0)\n        return 0;\n    // If\
    \ the given value is equal to or greater than 10, return 10.\n    if ($value ==\
    \ 10)\n        return 10;\n    // If the given value is equal to or greater than\
    \ 100, return 100.\n    if ($value == 100)\n        return 100;\n    // If the\
    \ given value is equal to or greater than 1000, return 1000.\n    if ($value ==\
    \ 1000)\n        return 1000;\n    // Find the difference between a given number\
    \ and 10.\n    $diff = $value - 10;\n    // If the given number is less than or\
    \ equal to 10, return it.\n    if ($diff <= 0)\n        return $value;\n    //\
    \ If the given number is more than 10 but not less than or equal to 10, find the\
    \ closest number to 10.\n    if ($diff > 10 && $diff <= 20)\n        return 10\
    \ + round($diff / 5);\n    // If the given number is more than 20 but not less\
    \ than or equal to 10, find the closest number to 20.\n    if ($diff > 20 && $diff\
    \ <= 30)\n        return 20 + round($diff / 10);\n    // If the given number is\
    \ more than 30 but not less than or equal to 10, find the closest number to 30.\n\
    \    if ($diff > 30 && $diff <= 40)\n        return 30 + round($diff / 25);\n\
    \    // If the given number is more than 40 but not less than or equal to 10,\
    \ find the closest number to 40.\n    if ($diff > 40 && $diff <= 50)\n       \
    \ return 40 + round($diff / 50);\n    // If the given number is more than 50 but\
    \ not less than or equal to 10, find the closest number to 50.\n    if ($diff\
    \ > 50)\n        return 50 + round($diff / 100);\n    // If the given number is\
    \ more than 50, return the closest number to 100.\n    return 100;\n}\n", "  if\
    \ (empty($value)) {\n    return NULL;\n  }\n  if ($value == 0) {\n    return 0;\n\
    \  }\n  $closest_integer = floor($value);\n  if ($closest_integer == $value) {\n\
    \    return $closest_integer;\n  }\n  foreach (array_reverse(explode('.', $value))\
    \ as $decimal_number) {\n    $decimal_number = str_pad($decimal_number, 4, '0',\
    \ STR_PAD_LEFT);\n    $decimal_number = ltrim($decimal_number, '0');\n    if ($decimal_number\
    \ >= 0) {\n      if ($decimal_number == $closest_integer) {\n        return $decimal_number;\n\
    \      }\n      $closest_integer = $decimal_number;\n    }\n  }\n  return $closest_integer;\n\
    }\n", "  $int = $value;\n  $closest = null;\n  // If the value is an integer,\
    \ return it\n  if (intval($value) === $value) {\n    return $value;\n  }\n  if\
    \ ($int === 0 || $int === 1) {\n    // All zeroes and ones are equidistant, so\
    \ return the\n    // closest one\n    return $int;\n  }\n  // Find the nearest\
    \ integer\n  foreach (range(1, abs(intval($int)) - 1) as $diff) {\n    $newint\
    \ = intval($int) + $diff;\n    if ($newint < 0 || $newint > abs(intval($int)))\
    \ {\n      // A number outside the bounds of the integer is no more than\n   \
    \   // two \"away\" from zero.\n      $closest = $newint;\n      break;\n    }\n\
    \    $int = $newint;\n  }\n  // If the number is now equidistant from two integers,\
    \ round it away\n  // from zero.\n  // If it is equidistant from three integers,\
    \ round it away from zero.\n  // If it is equidistant from four integers, round\
    \ it away from zero.\n  if ($closest === null && count(range(1, abs(intval($int))\
    \ - 1, 2))) {\n    $closest = 0;\n  }\n  if ($closest === null && count(range(1,\
    \ abs(intval($int)) - 1, 3))) {\n    $closest = 1;\n  }\n  if ($closest === null\
    \ && count(range(1, abs(intval($int)) - 1, 4))) {\n    $closest = 2;\n  }\n  return\
    \ $closest;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks, this is useful! However\
    \ I didn't ask for it to be \"exact\", but for it to be \"close\".\n<|/ c |>\n\
    <| a |>\nYou can use PHP's floor() and ceil() functions to return the closest\
    \ number to what you are looking for, without having to use a custom function.\n\
    http://php.net/manual/en/function.floor.php\nhttp://php.net/manual/en/function.ceil.php\n\
    <|/ a tags=php dscore=1 |>\n<| c |>\nThis was a nice way to get to the correct\
    \ answer but it doesn't solve the question. floor() will round down, which is\
    \ not the correct answer\n<|/ c |>\n<| a tags=php |>\nYou could use something\
    \ like the following:\n<code>\n<?php\n$test = array('10', '15.3', '16.5', '17.6',\
    \ '18.5');\nforeach($test as $val)\n{\n    $val = floor($val);\n    echo $val\
    \ . \"<br>\";\n}", "  $int1 = intval($value);\n  $int2 = $int1;\n  if ($int2 <\
    \ $int1) {\n    $int2 = $int1;\n  }\n  return $int2;\n}\n</code>\nThe function\
    \ will return the nearest integer to the given value (or return $value if value\
    \ is greater than or equal to the nearest integer). For example, closest_integer(\"\
    14.5\") should return 15 and closest_integer(\"-14.5\") should return -15.\n<|/\
    \ a tags=php,ceil,ceiling,floor,division |>\n<| a tags=php,ceil,ceiling,floor,division\
    \ dscore=0 |>\nI used your solution to solve my issue. It was very helpful.\n\
    <code>", "  $value = abs($value);\n  $closest = null;\n  $closestDiff = null;\n\
    \  $closestNum = null;\n\n  foreach (range(0, 10) as $i) {\n    $diff = $value\
    \ - $i;\n\n    if ($closestDiff === null || abs($diff) >= abs($closestDiff)) {\n\
    \      $closestDiff = $diff;\n      $closestNum = $i;\n    }\n  }\n\n  return\
    \ $closestNum;\n}\n", "    if (is_numeric($value)) {\n        $difference = $value\
    \ - floor($value);\n        if ($difference > 0) {\n            return $value;\n\
    \        } else {\n            return floor($value);\n        }\n    } else {\n\
    \        return false;\n    }\n}", "    $integers = array(10, 15, 17, 19.4, 20.6,\
    \ 21.9, 23.6, 25.3, 27.5,\n        29.6, 30.8,  31.9, 33.3, 35.8, 37.9, 39.4,\
    \ 41.6, 43.1, 45.4);\n    $differences = array_map('absval', array_map(\n    \
    \    'intval',\n        array_diff($integers, array_map('intval', explode(\".\"\
    , $value)))\n    ));\n    sort($differences);\n    $difference = array_pop($differences);\n\
    \    sort($integers);\n    $integer = array_pop($integers);\n    if ($difference\
    \ == 0) {\n        return $integer;\n    }\n    return round($integer + ($difference\
    \ / abs($difference)));\n}\n", "  $value = str_replace(',', '', $value); // Strip\
    \ out commas\n  $value = str_replace('.0', '', $value); // Strip out decimals\n\
    \  $value = str_replace('.', '', $value); // Strip out whole numbers\n  $value\
    \ = round($value);\n  // $value = max(0, $value);\n  return $value;\n}\n</code>\n\
    <|/ a dscore=2 tags=numbers,math,php |>\n<| a dscore=1 |>\nFor example you have\
    \ a number $number1 = '123'; and you want to round this up (like in Google) you\
    \ can use this code:\n<code>\n$number1 = '123';\n$number2 = intval($number1);\n\
    $number2++;\n$number2 = str_pad($number2, strlen($number1), 0, STR_PAD_LEFT);\n\
    echo \"$number1\";\necho \"<br>\";\necho \"$number2\";\n</code>\n<|/ a tags=numbers,math,php\
    \ |>\n<| a dscore=1 |>\nThis solution works for positive numbers only! It rounds\
    \ up to the nearest whole number. If there's a number that's equidistant from\
    \ two integers, it rounds up from zero.\n<code>", "  return intval($value) + (!($value\
    \ > 0 && $value < 1) ? 0.5 : 0);\n}\n", "    if (is_numeric($value)) {\n     \
    \   $delta = $value - floor($value);\n        if ($delta == 0) {\n           \
    \ return $value;\n        }\n\n        return floor($value) + $delta;\n    }\n\
    \n    return 0;\n}\n\n/**\n * Generates a random hash\n * $options is an optional\
    \ associative array of options to overwrite the default\n *\n * 'salt'       \
    \ => string - a salt string to hash\n * 'algorithm'   => string - a hashing algorithm\
    \ to use\n *\n * 'min_length' => integer - the minimum length of the hash string\n\
    \ *\n * 'max_length' => integer - the maximum length of the hash string\n *\n\
    \ * 'ignore_case' => bool - set to true to ignore case when generating a random\
    \ hash\n *\n * 'no_collisions' => bool - set to true to disable collision detection\n\
    \ *\n * 'include_special_chars' => bool - set to true to include special characters\
    \ when generating a random hash\n *\n * @return  string\n */", "  // Convert strings\
    \ to floats to avoid issues when the integer\n  // is rounded down.\n  $value\
    \ = strval($value);\n  $value = floatval($value);\n  $value = (int) $value;\n\n\
    \  if ($value <= 0) {\n    return $value;\n  }\n\n  $closest = round(($value -\
    \ $value % $value) / $value);\n  $closest = $closest < $value ? $value : $closest;\n\
    \  return $closest;\n}\n", "  return ceil(abs($value - round($value, 0)));\n}\n",
  "    $closest_integer = floor($value);\n    $difference = abs($value - $closest_integer);\n\
    \    if ($difference <= 3) {\n        return $closest_integer;\n    }\n    $closest_integer\
    \ = ceil($value);\n    $difference = abs($value - $closest_integer);\n    if ($difference\
    \ <= 3) {\n        return $closest_integer;\n    }\n    return $value;\n}\n</code>\n\
    <|/ a tags=php,mysql |>\n<| c |>\nYou might also consider using `ABS` instead\
    \ of `ABS(value-x)`.\n<|/ c |>\n<| c |>\nthanks so much for the great response\
    \ and your time.\n<|/ c |>\n<| c |>\nI thought that might be the case but ran\
    \ some tests and it is actually slower, I edited my answer to include some benchmarks.\
    \ I really like the idea of abs and that seems to do the job, I'll be using it\
    \ at some point in the near future so thanks again.\n<|/ c |>\n<| a tags=php,mysql\
    \ |>\nHere is a solution using a stored function.\nFirst, create the stored function:\n\
    <code>\nCREATE FUNCTION closest_integer(num1 INT, num2 INT)\nRETURNS INT\nBEGIN\n\
    \    DECLARE diff, num3;\n\n    SET diff = (SELECT ABS(num1 - num2) FROM tbl);\n\
    \    IF diff <= 3 THEN\n        SET num3 = (SELECT num1 FROM tbl WHERE num1 =\
    \ num2);\n    ELSE\n        SET num3 = (SELECT num2 FROM tbl WHERE num1 = num2);\n\
    \    END IF;\n    RETURN num3;\nEND;\n</code>\nThis function is designed for two\
    \ arguments and returns a value that would be close to the input. I used a table\
    \ name 'tbl' to test the function.\nThen create two tables:\n<code>\nCREATE TABLE\
    \ tbl \n(\nnum1 INT NOT NULL,\nnum2 INT NOT NULL,\nPRIMARY KEY(num1,num2)\n);\n\
    \nINSERT INTO tbl (num1, num2) VALUES (1,3),(2,4),(3,9),(4,2),(5,0),(6,5),(7,12),(8,10),(9,5),(10,0),(11,2),(12,7),(13,0),(14,3),(15,1),(16,7);\n\
    </code>\nAnd run the query:\n<code>\nSELECT closest_integer(num1, num2) \nFROM\
    \ tbl\n</code>\nAnd the results are:\n<code>\nclosest_integer\n3\n4\n9\n2\n0\n\
    5\n12\n10\n5\n0\n11\n2\n12\n7\n13\n0\n14\n3", "    $int_part = (int) $value;\n\
    \    $float_part = (float) $value;\n\n    if ($int_part == 0) {\n        return\
    \ 0;\n    }\n\n    if ($float_part == 0) {\n        return $int_part;\n    }\n\
    \n    $decimal_part = (float) $int_part - $float_part;\n\n    return round($decimal_part)\
    \ == 0.0 ? $int_part : round($decimal_part);\n}\n</code>\n<|/ a dscore=5 |>\n\
    <| c |>\nI wrote a similar version but my function doesn't work for negative numbers,\
    \ i.e. `closest_integer(\"-23.6\")` returns `-2`, whereas it should return `23`\n\
    <|/ c |>\n<| c |>\nJust fixed it.\n<|/ c |>\n<| c |>\nThis works well but if you're\
    \ comparing decimals then it will not work. For example, it won't work for 3.5\
    \ <= 4.3. It will return false because 1.5 is not equal to 2 times the number.\n\
    <|/ c |>\n<| c |>\nThe correct answer would be to use round() instead of floor().\
    \ floor() is used to round numbers that have a fractional part, while round()\
    \ rounds them down to whole numbers, and therefore rounds down 1.5 to 1 instead\
    \ of 2. See https://3v4l.org/1L6Q4\n<|/ c |>\n<| c |>\n`floor` rounds the number\
    \ upwards. That is the opposite of what one wants. `round` rounds the number downwards.\n\
    <|/ c |>\n<| a |>\nThe simplest and most generic answer to the question is:\n\
    <code>\n$number = 1.5; // or any other number\n\n$round = ceil($number); // or\
    \ floor\n</code>\nThe result of the above code will be:\n<code>\n$round = 2; //\
    \ the closest number to the decimal number\n</code>\n<|/ a tags=php,numbers,rounding\
    \ dscore=5 |>\n<| c |>\n`ceil` not `ceiling` ;)\n<|/ c |>\n<| c |>\nYes thanks.\
    \ I corrected it.\n<|/ c |>\n<| c |>\nThis does not work for floats. Try it with\
    \ `1.5` and `1.7` which should be the closest integers to those numbers. `ceil`\
    \ returns `2`.\n<|/ c |>\n<| c |>\nWorks for me with PHP 5.6.38\n<|/ c |>\n<|\
    \ c |>\nThis doesn't answer the question, the OP asks for the closest integer,\
    \ not the next higher or lower integer. For example, with $number = 1.5 ceil(1.5)\
    \ will give 2, whereas ceil(1.7", "  // Convert the value to a float\n  $value\
    \ = floatval($value);\n\n  $difference = abs($value - $value);\n  $closest = $value\
    \ - $difference;\n\n  // If $value is equidistant from two integers, return the\
    \ integer\n  // that is furthest from zero.\n  if ($difference < $closest && $difference\
    \ > -$closest) {\n    return $closest;\n  }\n\n  // If the value is not equidistant\
    \ from two integers, return the value\n  // that is furthest from zero.\n  return\
    \ $value;\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=0 |>\nYou can try this\n\
    <code>\n<?php\n$val = '0';\n$val = explode(\" \", $val);\n$val = array_filter($val,\
    \ 'is_numeric');\n$val = array_sum($val);\n</code>\n<|/ a tags=numbers,string,php,arrays,sum\
    \ |>\n<| a tags=numbers,string,php,arrays,sum |>\nTry this function:\n<code>",
  "\t$value = floatval($value);\n\tif (is_null($value)) {\n\t\treturn;\n\t}\n\t//\
    \ If the number is greater than zero, it is closest to the integer 0\n\tif ($value\
    \ > 0.0) {\n\t\treturn 0;\n\t}\n\t// If the number is less than zero, it is closest\
    \ to the integer 0\n\tif ($value < 0.0) {\n\t\treturn 0;\n\t}\n\t// Find the difference\
    \ between the original number and the rounded number\n\t// The difference should\
    \ also be negative\n\t$diff = abs($value - round($value));\n\tif ($diff > 0.0)\
    \ {\n\t\treturn 0;\n\t} elseif ($diff < 0.1) {\n\t\treturn $value;\n\t} else {\n\
    \t\treturn round($value);\n\t}\n}\n$closest = round($closest, 1);", "    if ($value\
    \ == 0) {\n        return 0;\n    }\n    $closest_integer = $value;\n    $current_integer\
    \ = floor($value);\n    $previous_integer = $current_integer;\n    while ($current_integer\
    \ != $previous_integer) {\n        $previous_integer = $current_integer;\n   \
    \     $current_integer = floor($value / 10);\n    }\n    return $previous_integer;\n\
    }", "    if (is_numeric($value)) {\n        $fractional_parts = explode('.', $value);\n\
    \        $decimals = count($fractional_parts) - 1;\n        $fraction = array_slice($fractional_parts,\
    \ -1);\n        if ($fraction[0] === '-') {\n            $fraction = array_slice($fraction,\
    \ 1);\n        }\n        $num_fraction = array_sum($fraction);\n        if ($num_fraction\
    \ > 0) {\n            $num_to_round = $num_fraction - $decimals;\n           \
    \ if ($num_fraction > 1) {\n                $num_to_round += 0.5;\n          \
    \  }\n            $new_decimals = $decimals + $num_to_round;\n            if ($new_decimals\
    \ <= 0) {\n                $new_decimals = 0;\n            }\n            $fractional_parts[$decimals]\
    \ = round($value * (pow(10, $new_decimals)), -3);\n            $value = implode('.',\
    \ $fractional_parts);\n        }\n        $value = filter_var($value, FILTER_SANITIZE_NUMBER_FLOAT);\n\
    \    }\n    return $value;\n}\n</code>\n<|/ a dscore=3 |>\n<| a dscore=2 tags=php,math,rounding\
    \ |>\nUse round():\n<code>\n$num = 10;\n$num2 = 5.1;\n\n$numWithTwoDecimals =\
    \ round($num * 100) / 100;\n$numWithTwoDecimals = round($num2 * 100) / 100;\n\
    </code>\n<|/ a |>\n<| c |>\nThis will round 10.999 to 11, which is not correct.\
    \ Also the OP asked for a decimal rounding, not a truncating.\n<|/ c |>\n<| a\
    \ dscore=1 |>\nFor anyone needing this in Java or C# you can use:\n<code>\npublic\
    \ static double roundNumber(double number, int decimalPlaces)\n{\n    double factor\
    \ = Math.pow(10, decimalPlaces);\n    return Math.round(number * factor) / factor;\n\
    }\n</code>\n<|/ a tags=php,math,rounding |>\n<| a |>\nFor those looking for truncating\
    \ instead of rounding, here's a recursive solution:\n<code>", "  $num = abs($value);\n\
    \  $base = floor($num);\n  if ($num == $base) {\n    return $num;\n  }\n\n  $fraction\
    \ = $num - $base;\n  $next = $base + 1;\n  if ($fraction < 0.5) {\n    if ($next\
    \ == $base) {\n      return $base;\n    }\n\n    return $next;\n  }\n  if ($fraction\
    \ > 0.5) {\n    if ($next == $base) {\n      return $next;\n    }\n\n    return\
    \ $next;\n  }\n\n  return $next;\n}\n", "  // We are rounding away from zero,\
    \ so we check if our number is equidistant\n  // from two integers.\n  $closest_int\
    \ = $value;\n  if(abs($value - $closest_int) < 1) {\n    // If the number is not\
    \ equidistant, return whichever integer is farthest\n    // away from zero.\n\
    \    foreach(array(\n        10,\n        8,\n        6,\n        4,\n       \
    \ 2,\n        1\n      ) as $int) {\n      if(abs($value - $int) < abs($value\
    \ - $closest_int)) {\n        $closest_int = $int;\n      }\n    }\n  }\n  return\
    \ $closest_int;\n}\n", "  $closest_integer = $value % 10;\n\n  $nearest_integer\
    \ = $value / 10;\n\n  if ($nearest_integer == $closest_integer) {\n    return\
    \ $value;\n  }\n\n  $nearest_integer_remainder = $nearest_integer % 10;\n\n  if\
    \ ($nearest_integer_remainder == $closest_integer) {\n    return $nearest_integer;\n\
    \  }\n\n  return $nearest_integer + 10;\n}\n", "  $int_value = intval($value);\n\
    \  $diff = $int_value - $int_value % 1;\n  return $int_value + ($diff ? -$diff\
    \ : 0);\n}\n", "  if (is_numeric($value)) {\n    $number = $value;\n    $difference\
    \ = 0;\n    while ($number > 1) {\n      $difference++;\n      $number *= 10;\n\
    \    }\n    return $number + $difference;\n  }\n  return $value;\n}\nadd_filter('get_theme_mod',\
    \ 'wp_get_theme_mod');", "  return round($value) %2 == 0 ? round($value) : round($value\
    \ - 0.5)\n}", "  if (abs($value) == 1) {\n    return $value;\n  }\n  $diff = $value\
    \ - floor($value);\n  return $diff < 0 ? ceil($value) : floor($value);\n}\n</code>\n\
    The function takes the number of integers and returns the closest. For example\
    \ closest_integer(9) will return 9. If the number is equidistant from two integers,\
    \ it returns the closest integer.\nYou can use the code above as a basis for your\
    \ own function. The function will return a string that is the number with one\
    \ integer removed. For example closest_integer(\"9\") will return \"8\" and closest_integer(\"\
    14.4\") will return \"14.4\".\n<|/ a tags=javascript,php |>\n<| c |>\nYes. That\
    \ is exactly what I was looking for. Thanks.\n<|/ c |>\n<| c |>\nI made some edits\
    \ to the code so that the function returns a string instead of an integer. This\
    \ makes it easier to manipulate the string if necessary.\n<|/ c |>\n<| a tags=javascript,php\
    \ dscore=1 |>\nI believe this is what you're looking for:\n<code>", "  $closest\
    \ = intval($value); // Cast to integer\n  $closest = round($closest, 1); // Round\
    \ away from zero\n  $closest = abs($closest); // Get the absolute value\n  if\
    \ ($closest > $value) { // Is the absolute value greater than the value?\n   \
    \ return $value; // If so, return it\n  } else { // Else, subtract it\n    return\
    \ $closest - 1;\n  }\n}", "  $int_value = intval($value);\n  $min_value = $int_value\
    \ - $int_value % 0.5;\n  $max_value = $int_value + $int_value % 0.5;\n  if ($int_value\
    \ == 0) {\n    return 0.0;\n  } else if ($min_value == $max_value) {\n    return\
    \ $min_value;\n  } else {\n    return min($min_value, $max_value);\n  }\n}\n",
  "  $value = abs($value);\n  $increment = 0;\n  $closest_val = floor($value);\n \
    \ do {\n    $value = $value + $increment;\n    $closest_val = floor($value);\n\
    \    $increment++;\n  } while ($closest_val != $value && $increment < PHP_INT_MAX);\n\
    \  return ($closest_val < $value) ? -$closest_val : $closest_val;\n}\n\n/**\n\
    \ * Takes a number and returns an integer that is equivalent to the number\n *\
    \ rounded away from zero.\n *\n * Example:\n * >>> round_away_from_zero(10)\n\
    \ * 10\n * >>> round_away_from_zero(10.3)\n * 10\n * >>> round_away_from_zero(10.5)\n\
    \ * 10.5\n * >>> round_away_from_zero(10.67)\n * 11\n * >>> round_away_from_zero(-10)\n\
    \ * -10\n * >>> round_away_from_zero(-10.3)\n * -10\n * >>> round_away_from_zero(-10.5)\n\
    \ * -10.5\n * >>> round_away_from_zero(-10.67)\n * -11\n * Note:\n * Rounding\
    \ away from zero means that if the given number is equidistant\n * from two integers,\
    \ the one you should return is the one that is the\n * farthest from zero. For\
    \ example round_away_from_zero(\"14.5\") should\n * return 15 and round_away_from_zero(\"\
    -14.5\") should return -15.\n *\n * @param   float    $value\n * @return  float\n\
    \ */", "    // Your code here\n}\nprint(closest_integer(14.5));\n</code>\nSolution\n\
    <code>\n<?php", "  // Split the value into an array of numbers\n  $values = preg_split(\"\
    /[.]/\", $value);\n  // Create a variable to hold the closest integer\n  $closest\
    \ = $values[0];\n  // Loop through all the numbers in the array\n  foreach (array_slice($values,\
    \ 1) as $number) {\n    // Calculate the difference between the current number\
    \ and the\n    // closest integer\n    $diff = abs($number - $closest);\n    //\
    \ If the difference between the current number and the closest integer\n    //\
    \ is less than the original value, then update the closest integer\n    // to\
    \ the current number\n    if ($diff < $closest) {\n      $closest = $number;\n\
    \    }\n  }\n  return $closest;\n}", "    // Convert the input to a float\n  \
    \  $float = floatval($value);\n\n    // If the float is equidistant from two integers,\
    \ round it away\n    // from zero.\n    if($float == intval($float)) {\n     \
    \   $float = $float - intval($float);\n    }\n\n    // Return the float\n    return\
    \ $float;\n}\n", "  $result = round($value, 0);\n  if ($result == $value) {\n\
    \    return $result;\n  }\n  if (abs($result - intval($result)) < abs($result\
    \ - floatval($result))) {\n    return intval($result);\n  }\n  return floatval($result);\n\
    }\n\n$wp_query = new WP_Query(array(\n  'post_type' => 'post_type',\n  'orderby'\
    \ => 'rand',\n  'order' => 'ASC',\n  'posts_per_page' => 1,\n  'paged' => $paged\n\
    ));\n\nif ($wp_query->have_posts()) : \n  while ($wp_query->have_posts()) : $wp_query->the_post();\n\
    \  $featured_image = wp_get_attachment_url(get_post_thumbnail_id($post->ID));\n\
    \  ?>\n  <article class=\"post\">\n    <h2 class=\"post-title\">\n      <?php\
    \ the_title(); ?>\n    </h2>\n    <?php echo get_the_post_thumbnail($post->ID,\
    \ 'full', array('class' => 'post-image')); ?>\n    <?php\n    $excerpt = get_the_excerpt();\n\
    \    if (strlen($excerpt) > 100) {\n      echo substr($excerpt, 0, 100).'...';\n\
    \    } else {\n      echo $excerpt;\n    }\n    ?>\n    <div class=\"post-info\"\
    >\n      Posted on <?php the_time('l, F j, Y') ?> in <?php the_category(', ');\
    \ ?>\n      <?php edit_post_link(__('Edit'), '<p class=\"post-meta\">', '</p>');\
    \ ?>\n    </div>\n  </article>\n  <?php endwhile; endif; ?>\n  <div class=\"post-list\"\
    >\n    <?php if ($wp_query->max_num_pages > 1) : ?>\n      <?php wp_pagenavi();\
    \ ?>\n    <?php endif; ?>\n  </div>\n<?php get_footer(); ?>\n</code>\n<|/ q dscore=0\
    \ |>\n<| a |>\nUse a paginated loop and add some logic to check the current post\
    \ id to decide whether to show the prev/next navigation buttons. Something like\
    \ this (untested):\n<code>\n<?php\n$wp_query = new WP_Query(array(\n  'post_type'\
    \ => 'post_type',\n  'orderby' => 'rand',\n  'order' => 'ASC',\n  'posts_per_page'\
    \ => 1,\n  'paged' => $paged\n));\n\n$previous_post = get_previous_post();\n$next_post\
    \ = get_next_post();\nif ($previous_post || $next_post) {\n    echo '<div class=\"\
    post-list\">';\n    if ($previous_post !== null){\n        echo '", "  // Convert\
    \ the value to a number\n  $number = (int)$value;\n  // See if the number is equidistant\
    \ from two integers.\n  // See http://stackoverflow.com/a/1824392\n  $diff = abs($number\
    \ - $number);\n  if ($diff < 5){\n    return $number;\n  }\n  return $number-$diff;\n\
    }\n", "  if ($value == 0) {\n    return 0;\n  }\n  $sign = $value < 0 ? '-' :\
    \ '';\n  $value = abs($value);\n  $minimum = 0;\n  $maximum = PHP_INT_MAX;\n \
    \ for ($i = 0; $i < strlen($value); ++$i) {\n    $minimum = ($minimum > $value[$i])\
    \ ? $minimum : $value[$i];\n    $maximum = ($maximum < $value[$i]) ? $maximum\
    \ : $value[$i];\n  }\n  if ($minimum > $maximum) {\n    return $sign * abs($minimum);\n\
    \  }\n  if ($minimum == $maximum) {\n    return $sign * $minimum;\n  }\n  return\
    \ $sign * (PHP_INT_MAX - $maximum);\n}", "  return ceil($value);\n}\n", "  //\
    \ TODO: Write the function here\n}\n", "  return ($value  + round($value  / $value)\
    \ - round($value / $value)) / $value;\n}\n", "  return round( $value * 2.5 ) /\
    \ 2.5;\n}\n", "    // Get a list of all the integers between the current and provided\
    \ number\n    // by splitting by \".\"\n    $numbers = explode('.', $value);\n\
    \    $current_integer = $numbers[0];\n    $closest_integer = $current_integer;\n\
    \    $difference = abs($current_integer - $numbers[1]);\n\n    // Loop through\
    \ the numbers until we find one that is equidistant from\n    // the current and\
    \ provided number\n    foreach ($numbers as $number) {\n        // Add one to\
    \ the difference if it makes sense\n        $difference++;\n\n        // If difference\
    \ is greater than or equal to the closest integer,\n        // update the current\
    \ integer to equal the provided number and\n        // the closest integer to\
    \ equal the difference between the current\n        // integer and the provided\
    \ number\n        if ($difference >= $closest_integer) {\n            $current_integer\
    \ = $number;\n            $closest_integer = $difference;\n        }\n    }\n\n\
    \    // If there is only one number left in the list, return that number\n   \
    \ return count($numbers) === 1 ? $numbers[0] : $closest_integer;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=0 |>\nTry this, it works as per your requirement,\
    \ i have used a php function \nexplode()\n<code>\n <?php\n\n    $str = '1,5,10';\n\
    \    $array = explode(',', $str);\n    $result = array();\n\n    foreach($array\
    \ as $value){\n    $value = explode(',', $value);\n    $result[] = $value[0];\
    \ // here index 0 contains first no\n    $result[] = $value[1]; // here index\
    \ 1 contains second no\n    }\n\n    sort($result); // sorting based on first\
    \ no\n    for($i=0; $i<count($result); $i++){\n        $res[] = $result[$i]; //\
    \ here index[0] contains first no \n    }\n    sort($res); // sorting based on\
    \ second no\n    for($i=0; $i<count($res); $i++){\n        echo $res[$i].\"<br>\"\
    ;\n    }\n\n ?>\n</code>\n<|/ a tags=math,php |>\n<| c |>\nThis would fail on\
    \ `2,5,10`, for example.\n<|/ c |>\n<| c |>\nYes, you were right I have updated\
    \ my code, thank you. Now you can check it.\n<|/ c |>\n<| a tags=math,php |>\n\
    This is your solution (without functions)\n<code>\n$arr = [\n    '1,2,3',\n  \
    \  '10,12,14',\n    '6,7,8',\n    '5,4,2',\n    '10,12,14',\n    '6,7,8',\n  \
    \  '5,4,2',", "  $value = abs($value);\n  $diff = $value - round($value);\n  return\
    \ ($diff > 0.5) ? round($value) : -round($value);\n}", "\treturn round($value-floor($value));\n\
    }", "  if ($value === '' || $value === null) { return ''; }\n  $int_value = floatval($value);\n\
    \  if (is_nan($int_value)) { return ''; }\n  $int_value = round($int_value);\n\
    \  return $int_value;\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nFor those who don't\
    \ know: round() returns a float number. intval() returns the integer value.\n\
    <|/ c |>\n<| c |>\nWhat happens if there is two integers equidistant from each\
    \ other? For example `15` and `14.5`?\n<|/ c |>\n<| c |>\nThat's what the OP was\
    \ asking for: \"If the number is equidistant from two integers, round it away\
    \ from zero\"\n<|/ c |>\n<| c |>\n, Ahh sorry. I thought he was asking for the\
    \ closest to zero. Your answer is a better way to do that.\n<|/ c |>\n<| c |>\n\
    , The OP mentioned in a comment to his question: \"I need the integer value of\
    \ the input\". Your answer does not answer the question. It gives no integer value\
    \ for the input. I think you might have confused him.\n<|/ c |>\n<| a dscore=2\
    \ |>\nYou could use bcadd() as a workaround:\n<code>\n$foo = \"3.1415926535\"\
    ;\n$foo = bcadd($foo, \"0.00000000001\");\necho $foo;\n</code>\n<|/ a tags=php,rounding\
    \ |>\n<| a |>\nThe other answers are good, but if you're on PHP 7.4 or higher,\
    \ you could just use round():\n<code>\nround(3.1415926535);", "  // Convert the\
    \ given string to a float\n  $value = floatval($value);\n\n  // If no value was\
    \ given, return zero\n  if (!isset($value)) {\n    return 0;\n  }\n\n  // Calculate\
    \ the difference between the two given values\n  $difference = abs($value - $value);\n\
    \n  // If the difference is equidistant from two integers, round away\n  // from\
    \ zero\n  if ($difference <= 0.5) {\n    return $value;\n  }\n\n  // Return an\
    \ integer, but if it was equidistant from two integers, round\n  // away from\
    \ zero\n  return intval($value);\n}\n</code>\n<|/ a tags=php,math dscore=2 |>\n\
    <| a |>\nThis can be done in O(1) time by simply counting up from zero:\n<code>\n\
    $min = 0;\n$max = 200;\n\n$i = 0;\nwhile ($i < $max) {\n    $i++;\n\n    if ($min\
    \ > $i) {\n        $min = $i;\n    }\n}\n\nvar_dump($min);\n</code>\n<|/ a dscore=2\
    \ tags=php,math |>\n<| a tags=php,math |>\n<code>\n<?php", "  list($first, $second)\
    \ = explode('.', $value);\n  if ($first == 0) {\n    return $second;\n  }\n\n\
    \  if ($second == 0) {\n    return $first;\n  }\n\n  return $first > $second ?\
    \ $first : $second;\n}\n", "  $integer = $value;\n  while($integer < $value*1000)\
    \ {\n    $integer++;\n  }\n  while($integer > $value*1000) {\n    $integer--;\n\
    \  }\n  return $integer;\n}\n", "  return round( abs($value - round($value)) );\n\
    }", "  $value = abs($value); // negative numbers are closer to zero\n  list($a,\
    \ $b) = $is_negative = $value = explode('.', $value);\n  $a = ltrim($a, '-');\n\
    \  $b = ltrim($b, '-');\n  $is_negative = isset($is_negative) ? $is_negative :\
    \ false;\n  list($ab, $re) = $is_negative ? array(\n    'a' => -abs($b), 'b' =>\
    \ abs($b),\n  ) : (\n    'a' => abs($a), 'b' => abs($a),\n  );\n  return $ab ===\
    \ $re ? $a : $ab < $re ? $a : $b;\n}", "  if ($value == '') return '';\n  $value\
    \ = abs($value);\n\n  // Check for equidistant values\n  $lower = $value < 0 ?\
    \ -$value : 0;\n  $upper = $upper ? $upper : 0;\n  if (abs($lower) < abs($upper))\
    \ {\n    // Equidistant\n    if ($value == $lower) $return = $lower;\n    else\
    \ if ($value == $upper) $return = $upper;\n    else {\n      if ($value > $upper)\
    \ $return = $upper;\n      else if ($value < $lower) $return = $lower;\n    }\n\
    \  } else {\n    // Clockwise\n    if ($value == $lower) $return = $upper;\n \
    \   else if ($value == $upper) $return = $lower;\n    else {\n      if ($value\
    \ < $lower) $return = $lower;\n      else if ($value > $upper) $return = $upper;\n\
    \    }\n  }\n\n  return $return;\n}\n", "  // Get the absolute value of the number\n\
    \  $abs = abs($value);\n\n  // If there is only one number, return it unmodified\n\
    \  if ($abs == 1) {\n    return $value;\n  }\n\n  // If there is only 1 digit,\
    \ return it unmodified\n  if ($abs <= 10) {\n    return $value;\n  }\n\n  // Initialize\
    \ an accumulator for storing the number\n  $accumulator = 0;\n\n  // Set the accumulator\n\
    \  $accumulator += $abs / 10;\n\n  // Iterate over all the digits in the number\
    \ and add the number\n  for ($i = 1; $i <= 9; $i++) {\n    $accumulator += $abs\
    \ / pow(10, $i);\n  }\n\n  // If the number is equidistant from two integers,\
    \ round it away from\n  // zero\n  if ($accumulator === 0) {\n    return $value;\n\
    \  }\n\n  // Return the number closest to zero\n  return $accumulator;\n}", " \
    \ return (int)round(abs($value), -(int)strlen($value));\n}\n", "  return ceil($value);\n\
    }", "  $number = abs($value);\n  $integers = range($number-4, $number+4);\n  $closest_integer\
    \ = $integers[0];\n  foreach ($integers as $integer) {\n    if (abs($integer-$number)\
    \ < abs($number-$closest_integer)) {\n      $closest_integer = $integer;\n   \
    \ }\n  }\n  return $closest_integer;\n}", "  // Convert value to a number.\n \
    \ $value = filter_var(filter_var($value, FILTER_SANITIZE_NUMBER_INT), FILTER_SANITIZE_NUMBER_INT);\n\
    \  // If the value is a valid number, check for equidistant integers\n  // and\
    \ return the one that's farthest from zero.\n  if ($value !== false && ($value%1)\
    \ === 0 && $value != 0) {\n    $min = $max = $value;\n    foreach(range(-5,5)\
    \ as $diff) {\n      // Add 1 to $min and subtract 1 to $max until $min and $max\
    \ are equal.\n      // If $min and $max are equal, we're done (because both $min\
    \ and $max\n      // are integers and $value is an integer).\n      $min = ($diff\
    \ > 0) ? ($min+1) : $min;\n      $max = ($diff < 0) ? ($max-1) : $max;\n     \
    \ // If the difference between $min and $max is 1, we're done.\n      if ($max\
    \ == $min) {\n        break;\n      }\n      // Else, check if the difference\
    \ between $min and $max is less\n      // than the original difference (which\
    \ means $min and $max are\n      // equidistant).\n      if ($max-$min <= $diff)\
    \ {\n        break;\n      }\n    }\n    return $min;\n  }\n  // Return 0 if the\
    \ value isn't a valid number.\n  return 0;\n}\n", "  global $closest;\n  $closest\
    \ = null;\n  if ($value === null) {\n    return null;\n  }\n  $value = intval($value);\n\
    \  $value_prev = $value;\n  while (($integer := $value - floor($value)) > 0) {\n\
    \    if (abs($integer - $value_prev) < abs($value - $value_prev)) {\n      $closest\
    \ = $integer;\n    }\n    $value_prev = $value;\n    $value = $integer + 1;\n\
    \  }\n  return $closest;\n}\n</code>\n<|/ a |>\n<| c |>\nthis seems pretty cool,\
    \ thanks for sharing! how would I implement this with multiple variables that\
    \ I need to check?\n<|/ c |>\n<| c |>\nI added a more generic solution using `floatval`\
    \ to accommodate the use cases you describe.\n<|/ c |>\n<| a dscore=1 |>\nI made\
    \ a function for calculating the nearest integer that works with strings as well:\n\
    <code>\n<?php\n", "    $value = strval($value);\n    if ($value === \"0\")\n \
    \       return 0;\n    $float = floatval($value);\n    $parts = explode(\".\"\
    , $float);\n    $parts[0] = (int) $parts[0];\n    return $parts[0] === $float\
    \ ? $parts[0] : $parts[0] - 1 === $float ? $parts[0] + 1 : round($parts[0]);\n\
    }", "  return round($value / 4) * 4;\n}", "    $parts = explode('.', trim($value,\
    \ '0'));\n    sort($parts);\n    // Return closest number smaller than the number\n\
    \    return $parts[0] ? ($parts[0] * -1) : $parts[0];\n}\n", "    return round($value)\
    \ + ($value === $value ? 0.0 : 1.0);\n}\n", "    $value = floatval($value);\n\
    \    $closest = intval($value);\n    $diff = $value - $closest;\n    if (abs($diff)\
    \ < 1.E-14) {\n        return intval($value);\n    }\n    $nearby = array(\n \
    \       \"closest\" => round($closest, 0),\n        \"farthest\" => round($value,\
    \ 0),\n    );\n    // Now find the closest and farthest integers\n    for ($i\
    \ = 1; $i < 10; ++$i) {\n        $diff = $value - $closest.$i;\n        if (abs($diff)\
    \ < 1.E-14) {\n            $closest = $closest.$i;\n            continue;\n  \
    \      }\n        $farthest = $farthest.$i;\n        if (abs($diff) < 1.E-14)\
    \ {\n            $farthest = $value;\n        }\n        break;\n    }\n    //\
    \ Make sure we actually got two numbers\n    if (empty($nearby)) {\n        //\
    \ No two numbers were equidistant\n        return $closest;\n    }\n    // Get\
    \ the two numbers and make sure they are integers\n    for ($i = 0; $i < 2; ++$i)\
    \ {\n        if (! is_numeric($nearby[$i])) {\n            $nearby[$i] = intval($nearby[$i]);\n\
    \        }\n    }\n    // Round them away\n    return intval($nearby[0] < $nearby[1]\
    \ ? $nearby[0] : $nearby[1]);\n}\n</code>\n<|/ a |>\n<| c |>\nGreat job! I appreciate\
    \ it! I'm really looking for an answer with the `max` function in php and your\
    \ solution is quite simple and understandable. My only issue is that you used\
    \ `round()` instead of `ceil()` or `floor()`. I understand `round()` will round\
    \ up or down to the nearest number or decimal, but I'm wondering if using `ceil()`\
    \ and `floor()` would work the same way or would that not matter?\n<|/ c |>\n\
    <| c |>\nNo, `floor()` and `ceil()` are for floating point numbers. If you have\
    \ a string and want an integer value you can parse it to a float and get the integer\
    \ value of the number. Try `echo floor(floatval('10.1')); echo ceil(floatval('10.5'));`\n\
    <|/ c |>\n<| a tags=math,php |>\n<code>\n<?php\n\n$test1=1;\n$test2=$test1+1;\n\
    \nif($test2 > $test1) {\necho $test2;\n}\nelse {\necho $test1;\n}\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nThanks for your response. I'm not trying to find the\
    \ next or previous number", "  $int1 = floor($value);\n  $int2 = ceil($value);\n\
    \  $diff1 = abs($int1 - $int2);\n  $diff2 = abs($value - $int1);\n  $diff3 = abs($value\
    \ - $int2);\n  if ($diff1 > $diff2) {\n    if ($diff1 > $diff3) return $int1;\n\
    \    return $int2;\n  } else {\n    if ($diff2 > $diff3) return $int2;\n    return\
    \ $int1;\n  }\n}\n", "  $int = $value;\n  // Return value if close enough to zero\n\
    \  if ($int === 0) {\n    return $value;\n  }\n  // Check difference between original\
    \ and rounded value\n  $int_diff = $int - floor($int);\n  // Return original integer\
    \ if equidistant from two integers\n  if (abs($int_diff) >= 0.5) {\n    return\
    \ $int;\n  }\n  // Return closest int\n  return $int - abs($int_diff);\n}", " \
    \ $int = floor($value);\n  $diff = $value - $int;\n  if ($diff < 1) {\n    return\
    \ $int;\n  } else {\n    return $int + round($diff * 0.5);\n  }\n}", "\treturn\
    \ abs(intval($value));\n}\n", "  return round($value) + abs(round($value) - round($value));\n\
    }\n", "  if ($value == null) return null;\n  return round($value);\n}\n", "  \
    \  return (int) round($value);\n}", "  $value = abs($value);\n  while ($value\
    \ < 100) {\n    $value *= 10;\n  }\n  if ($value == 0) {\n    return 0;\n  }\n\
    \  $factor = 100;\n  $closest_value = $value;\n  while ($value / $factor >= $closest_value)\
    \ {\n    $closest_value /= $factor;\n    $factor *= 10;\n  }\n  return $closest_value;\n\
    }\n", "  // Return early if there is no input.\n  if (empty($value)) {\n    return\
    \ 0;\n  }\n\n  // Parse the string as a float.\n  $value = floatval($value);\n\
    \n  // If the value is positive, return the floor of the value.\n  if ($value\
    \ > 0) {\n    return floor($value);\n  }\n\n  // If the value is negative, return\
    \ the ceiling of the value.\n  return ceil($value);\n}\n", "    // Return the\
    \ nearest integer from $value.\n    if ($value === \"\") {\n        $value = null;\n\
    \    }\n    if ($value === null) {\n        return 0;\n    }\n    if ($value ===\
    \ 0) {\n        return 0;\n    }\n    return round($value, -1);\n}\n", "  return\
    \ round(($value - floor($value)) + 1);\n}\n", "    $closest_integer = intval($value);\n\
    \n    foreach ($GLOBALS['db']->find('integer', array('value' => $value)) as $row)\
    \ {\n        $current_integer = intval($row['value']);\n\n        if ($current_integer\
    \ < $closest_integer) {\n            $closest_integer = $current_integer;\n  \
    \      }\n    }\n\n    return $closest_integer;\n}\n", "  // If this value is\
    \ equidistant from two integers, return the integer\n  // that is farthest from\
    \ zero.\n  if ( $value === $value % 2 ) {\n    $value = $value - 1;\n  }\n\n \
    \ return $value % 2 > 0 ? $value + 1 : $value - 1;\n}\n", "  $parts = explode('.',\
    \ $value);\n  $difference = abs($parts[0] - $parts[1]);\n\n  if($difference ==\
    \ 0) {\n    return $parts[0];\n  }\n\n  if($difference < 1) {\n    $parts[1] +=\
    \ 1;\n    return implode('.', $parts);\n  }\n\n  if($difference < 2) {\n    $parts[1]\
    \ -= 1;\n    return implode('.', $parts);\n  }\n\n  return $parts[1];\n}\n", " \
    \ // This function returns the smallest integer that is closest to a\n  // given\
    \ value.\n  // It does so by iterating from negative infinity upwards to zero\n\
    \  // while changing the sign in each iteration.\n  // We start at the lowest\
    \ negative number and decrease until we\n  // reach zero.\n  // We then start\
    \ at the lowest zero and increase until we reach the\n  // given value.\n  //\
    \ Examples:\n  // >>> closest_integer(\"-2\")\n  // 2\n  // >>> closest_integer(\"\
    -14.6\")\n  // -14\n  // >>> closest_integer(\"-1\")\n  // 0\n  // >>> closest_integer(\"\
    -0.5\")\n  // -0.5\n  // >>> closest_integer(\"-0.1\")\n  // 0\n  // >>> closest_integer(\"\
    0\")\n  // 0\n  // >>> closest_integer(\"0.2\")\n  // 0\n  // >>> closest_integer(\"\
    1.0\")\n  // 1\n  // >>> closest_integer(\"1.5\")\n  // 2\n  // >>> closest_integer(\"\
    10.5\")\n  // 10\n  // >>> closest_integer(\"10.25\")\n  // 10\n  // >>> closest_integer(\"\
    10.1\")\n  // 10\n  // >>> closest_integer(\"9.99999999999999\")\n  // 10\n  //\
    \ >>> closest_integer(\"9.99999999999999\")\n  // 10\n  // >>> closest_integer(\"\
    9.999999999999999\")\n  // 10\n  // >>> closest_integer(\"9.999999999999999\"\
    )\n  // 10\n  // >>> closest_integer(\"9.999999999999999\")\n  // 10\n  // >>>\
    \ closest_integer(\"9.999999999999999\")\n  // 10\n  // >>> closest_integer(\"\
    9.999999999999999\")\n  // 10\n  // >>> closest_integer(\"9.999999999999999\"\
    )\n  // 10\n  // >>> closest_integer(\"9.999999999999999\")\n  // 10\n  // >>>\
    \ closest_integer(\"9.999999999999999\")\n  // 10\n  // >>> closest_integer(\"\
    9.999999999999999\")\n  // 10\n  // >>> closest_integer(\"9.999999999999999\"\
    )\n  // 10\n  // >>> closest_integer(\"9.999999999999999\")\n  // 10\n  // >>>\
    \ closest_integer(\"9.999999999999999\")\n  // 10\n  // >>> closest_integer(\"\
    9.999999999999999\")\n  // 10\n  // >>> closest_integer(\"9.999999999999999\"\
    )\n  // 10\n  // >>> closest_integer(\"9.999999999999999\")\n  // 10\n  // >>>\
    \ closest_integer(\"9.999999999999999\")\n  // 10\n  // >>> closest_integer(\"\
    9.999999999999999\")\n  // 10\n  // >>> closest_integer(\"9.999999999999999\"\
    )\n  // 10\n  // >>> closest_integer(\"9.99999999", "  return (int)$value;\n}\n",
  "  // If the value is numeric, return it.\n  if (!is_numeric($value)) {\n    return\
    \ $value;\n  }\n\n  // If the value is an integer, just return it.\n  if ($value\
    \ == (int) $value) {\n    return $value;\n  }\n\n  // If the value is negative,\
    \ invert it and return the integer.\n  if ($value < 0) {\n    $value = -$value;\n\
    \  }\n\n  // Find the largest integer that's less than $value.\n  $max = (int)\
    \ $value;\n  for ($i = $max; $i > 0; $i--) {\n    if ($i == (int) $value) {\n\
    \      return $i;\n    }\n  }\n\n  // If the value is zero or negative, return\
    \ zero.\n  if ($value == 0 || $value < 0) {\n    return 0;\n  }\n\n  // If the\
    \ largest integer is larger than $value, return $value.\n  return $max;\n}\n</code>\n\
    <|/ a dscore=3 |>\n<| a dscore=2 |>\nThis solution works well for me\n<code>\n\
    <?php ", "  return round($value + 0.01) - round($value);\n}", "  return round(\
    \ (int) $value, 0, PHP_ROUND_HALF_DOWN );\n}\n", "  $diff = $value - round($value);\n\
    \  $diff = ($diff > 0.0 && $diff < 1.0) ? $diff : 0.0;\n  return round($value\
    \ + $diff * 1.0);\n}\n", "  // This function will return the closest integer to\
    \ a given value if the value\n  // is equidistant from two integers, otherwise\
    \ it will return the value itself.\n  $closest = $value;\n  $difference = 0;\n\
    \n  if ($value < $closest) {\n    return $closest;\n  }\n\n  // If the value is\
    \ closer than the current closest, reverse the sign.\n  if ($value < $closest)\
    \ {\n    $difference = $value - $closest;\n    $closest = $closest + $difference;\n\
    \  }\n\n  // If the value is further away than the current closest, reverse the\
    \ sign again.\n  if ($value > $closest) {\n    $difference = $value - $closest;\n\
    \    $closest = $closest + $difference;\n  }\n\n  return $closest;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nI think that the best solution\n<|/ c |>\n<| c |>\nThanks for\
    \ this answer! I used this for a project. But, when I used it in a while loop,\
    \ it wasn't working as expected (it would loop indefinitely). After some time\
    \ I realized that I had a typo in the condition of the while loop. After fixing\
    \ it, it worked great.\n<|/ c |>\n<| a dscore=3 tags=rounding,php |>\nIt depends\
    \ what you're trying to achieve, but I'd go with something like this:\n<code>\n\
    $int = (int)($number + ($number % 1 > 0.5 ? 0.5 : -0.5));\n</code>\n<|/ a |>\n\
    <| c |>\nThanks for your answer, I think your solution will work fine but I need\
    \ this to be implemented into a function that rounds numbers towards 0.\n<|/ c\
    \ |>\n<| a |>\n<code>\n$roundToNearestFour = round($number, -1);\n</code>\nThe\
    \ minus sign will round numbers up. Positive rounds towards negative zero; negative\
    \ rounds towards positive zero.\n<|/ a tags=rounding,php dscore=3 |>\n<| c |>\n\
    This is not what the question was asking for. This will just round up or down.\n\
    <|/ c |>\n<| c |>\nThis is the answer that I was looking for, thank you!\n<|/\
    \ c |>\n<| c |>\nThis just gives me an integer.\n<|/ c |>\n<| a tags=rounding,php\
    \ dscore=3 |>\nYou can use the round() function with PHP_ROUND_HALF_UP constant.\n\
    <code>\n$rounded_number = round($number, PHP_ROUND_HALF_UP);\n</code>\nPHP_ROUND_HALF_UP\
    \ will round the number up (0.5 or 1.5 or 2.5 or 3.5...) ", "    $is_negative\
    \ = (intval($value) < 0);\n    $is_even = (intval($value) % 2 == 0);\n    $integer_part\
    \ = intval($value);\n    $fractional_part = 0.0;\n    // If the value was either\
    \ negative or even, there will be no fractional\n    // part. Find out if there\
    \ was a fractional part by checking if the\n    // value is negative.\n    if\
    \ ($is_negative || $is_even) {\n        // If the value is negative, we need to\
    \ find the nearest positive\n        // integer.\n        $fractional_part = ($is_negative)\
    \ ? -$integer_part : $integer_part;\n        if (abs($fractional_part) == abs($integer_part))\
    \ {\n            // If the fractional part is equidistant from the two integers,\
    \ we\n            // need to add one to round away from zero\n            $fractional_part\
    \ += 1.0;\n        }\n    }\n    else {\n        // If the value is positive,\
    \ the fractional part is always zero.\n        // So we simply need to return\
    \ the integer part here.\n        $fractional_part = 0.0;\n    }\n    $nearest_integer\
    \ = intval($integer_part + $fractional_part);\n    if (abs($nearest_integer) >\
    \ abs($value)) {\n        $nearest_integer = intval($nearest_integer);\n    }\n\
    \    return $is_negative ? -$nearest_integer : $nearest_integer;\n}", "  global\
    \ $min, $max;\n  $min_value = $min;\n  $max_value = $max;\n\n  if (is_numeric($value))\
    \ {\n    if ($value > $max) {\n      $value = $max;\n    } else if ($value < $min)\
    \ {\n      $value = $min;\n    } else {\n      if ($value == 0) {\n        $value\
    \ = 0;\n      } else {\n        $value = round($value);\n      }\n    }\n    $value\
    \ = $value - $min;\n  }\n  return $value;\n}", "  return round($value);\n}", " \
    \ $int_diff = $value - floor($value);\n  if (abs($int_diff) < 0.000001)\n    return\
    \ floor($value);\n  $floor_diff = round($int_diff / abs($int_diff));\n  if ($floor_diff\
    \ == 0)\n    return floor($value);\n  return $int_diff >= 0 ? floor($value) :\
    \ ceil($value);\n}", "  // Get the absolute value of the number\n  $abs = abs($value);\n\
    \n  // If the absolute value is less than or equal to one digit, we\n  // round\
    \ it to the nearest whole integer\n  if ($abs <= 1) {\n    return round($abs,\
    \ 0);\n  }\n\n  // If the absolute value is less than or equal to ten, we round\
    \ it to\n  // the nearest integer\n  if ($abs >= 10) {\n    return round($abs,\
    \ 0);\n  }\n\n  // If the absolute value is less than or equal to hundred, we\
    \ round it\n  // to the nearest hundred\n  $factor = round($abs / 100, 0);\n\n\
    \  return round($abs - $factor * 100, 0);\n}\n", "    $integer = intval($value);\n\
    \n    return $integer === $value ? $integer :\n        $integer < $value ? $integer\
    \ - 1 : $integer + 1;\n}\n</code>\n<|/ a tags=php,numbers,rounding |>\n<| a |>\n\
    A more general solution which can handle negative numbers:\n<code>", "  $value\
    \ = strtolower($value);\n  $exponent = substr($value, strlen($value) - 1);\n \
    \ preg_match('/\\d+\\.(\\d+)/', $value, $digits);\n  $decimal_digits = $digits[1];\n\
    \  $integer = $digits[0];\n\n  return $integer + (intval($exponent) - intval($decimal_digits)\
    \ + 1) / pow(10, strlen($decimal_digits));\n}\n", "  $difference = 0;\n  $closest_integer\
    \ = $value;\n  foreach (range(0, 10) as $num) {\n    $difference += floor($value/pow(10,\
    \ $num));\n    if ($difference >= 0) {\n      $closest_integer = $value/pow(10,\
    \ $num);\n      break;\n    }\n  }\n  return $closest_integer;\n}\n", "    $parts\
    \ = explode('.', $value);\n    // If the given number is equidistant from two\
    \ integers, round it away\n    // from zero.\n    if (count($parts) == 2) {\n\
    \        $magnitude = abs($parts[0] - $parts[1]);\n        if ($magnitude >= 1)\
    \ {\n            return $parts[0];\n        } else {\n            return $parts[1];\n\
    \        }\n    }\n\n    return $parts[0];\n}\n", "    return round($value);\n\
    }\n", "  // Return an empty string if $value is an empty string or null or if\
    \ the\n  // $value is an invalid number.\n  if (empty($value) || !is_numeric($value))\
    \ {\n    return '';\n  }\n  // Determine the number of significant digits (digits\
    \ after the decimal)\n  // for the return value.\n  $decimals = strlen(substr($value,\
    \ strpos($value, '.')+1));\n  // Round $value up or down.\n  if ($value[0] ===\
    \ '-') {\n    $sign = $value;\n    $value = substr($value, 1);\n  } else {\n \
    \   $sign = '';\n  }\n  // Remove any decimal fraction digits.\n  $remainder =\
    \ substr($value, 0, strpos($value, '.'));\n  // Convert the value to a string\
    \ with exactly that many significant digits.\n  $value_string = str_pad(substr($value,\
    \ 0, strpos($value, '.')), $decimals, '0', STR_PAD_LEFT);\n  // If the remainder\
    \ is greater than 10, it is too big. Round the remainder\n  // up. If it is less\
    \ than 10, it is too small.\n  $remainder_as_int = intval($remainder);\n  if ($remainder_as_int\
    \ > 10) {\n    $rounded = $remainder_as_int + 1;\n    $remainder_as_int = intval($remainder)\
    \ - 1;\n  } else {\n    $rounded = $remainder_as_int - 1;\n  }\n  // Round the\
    \ value to the next largest integer.\n  $next_integer = (int) round($rounded *\
    \ pow(10, $decimals));\n  // If the value is greater than $next_integer, return\
    \ $next_integer. If\n  // it is less, return $next_integer - 1. Return $next_integer\
    \ if it is\n  // equal to $next_integer or $next_integer - 1.\n  if ($next_integer\
    \ >= $next_integer - 1) {\n    return $sign + $next_integer;\n  }\n  return $sign\
    \ + $next_integer - 1;\n}\n", "  // If the given value is a string, we convert\
    \ it to a float so we\n  // can perform our math.\n  if (is_string($value)) {\n\
    \    $value = floatval($value);\n  }\n\n  // This function compares two floating\
    \ point values and returns the one\n  // that is farthest from zero.\n  $difference\
    \ = abs($value - floor($value));\n\n  // If the difference is greater than 1,\
    \ then it must be equidistant\n  // from two integers, so round the difference\
    \ up.\n  if ($difference > 1) {\n    return $value + floor($difference);\n  }\n\
    \n  return $value;\n}", "    return round(($value - $value % 1) / ($value % 1));\n\
    }\n</code>\n<|/ a |>\n<| a |>\nI came up with a little bit more elegant solution\
    \ that does not use functions. Just put your variables in an array. \n<code>\n\
    <?php\n\n$a = \"-334\";\n$b = \"-331\";\n$c = \"-323\";\n$d = \"-335\";\n\n$a\
    \ = abs($a);\n$b = abs($b);\n$c = abs($c);\n$d = abs($d);\n\n$a_diff = $a - $b;\n\
    $b_diff = $b - $c;\n$c_diff = $c - $d;\n$d_diff = $d - $a;\n\n$diff_array = [];\n\
    \n$diff_array[0] = $a_diff;\n$diff_array[1] = $b_diff;\n$diff_array[2] = $c_diff;\n\
    $diff_array[3] = $d_diff;\n\n$biggest = max($diff_array);\n$biggest_index = $diff_array[$biggest];\n\
    \necho $a;\necho $b;\necho $c;\necho $d;\n", "  $num = $value;\n\n  // Make sure\
    \ the value is an integer.\n  // Note: This code snippet won't work if value contains\
    \ a\n  // decimal point because PHP will treat that as a decimal point.\n  if\
    \ (preg_match('/^\\d+$/', $value)) {\n    // If value contains no fractional parts,\
    \ add one so that it will\n    // be treated as an integer.\n    // If value contains\
    \ fractional parts, it will not be modified.\n    $num = sprintf(\"%.0f\", $num);\n\
    \n    // Get the decimal length of the value.\n    // Note: This code snippet\
    \ won't work if value contains a\n    // decimal point because PHP will treat\
    \ that as a decimal point.\n    $decimal = strlen(substr($value, strpos($value,\
    \ '.') + 1));\n\n    // If decimal length is less than or equal to 2, then add\
    \ one to\n    // the value to make it an integer and round it away from zero.\n\
    \    if ($decimal <= 2) {\n      $num++;\n    }\n  }\n\n  return $num;\n}", " \
    \ // Check if $value is a number\n  if (!is_numeric($value)) {\n    throw new\
    \ Exception(\"Given value is not a number\");\n  }\n  // Check if $value is an\
    \ exact integer\n  if ($value == intval($value)) {\n    return intval($value);\n\
    \  }\n  // Get the difference between $value and zero\n  $diff_from_zero = abs($value\
    \ - 0);\n  // Get the remainder of $value after dividing by $diff_from_zero\n\
    \  $integer_part = floor($value / $diff_from_zero);\n  // If the remainder equals\
    \ zero, return $value\n  if ($integer_part == 0) {\n    return $value;\n  }\n\
    \  // Get the remainder of $value after dividing by $diff_from_zero\n  $fractional_part\
    \ = $value - $integer_part * $diff_from_zero;\n  // Return the closes integer\
    \ to $value\n  return $integer_part + $fractional_part * 0.5;\n}\n", "    $val\
    \ = round($value, -1);\n    $min_diff = abs($val - $val);\n\n    foreach (range(0,\
    \ intval($min_diff) + 1, 1) as $diff) {\n        if ($diff > $min_diff) {\n  \
    \          $min_diff = $diff;\n        }\n    }\n\n    return $val;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThe code in the answer appears to assume that the numbers are\
    \ integers. What about floats?\n<|/ c |>\n<| c |>\n, thank you for pointing that\
    \ out! I've updated my answer accordingly.\n<|/ c |>\n<| a tags=php,math,algorithm\
    \ |>\nMy solution is pretty similar to what you did, but instead of using a recursive\
    \ function, I used a while loop:\n<code>\n$number = round(12.71);\n$diff = 1;\
    \ // this variable will hold the number we wanna round to\n\nwhile(abs($number\
    \ - round($number)) > $diff) {\n    $diff = abs($number - round($number));\n}\n",
  "    // Convert the string to an integer.\n    $value = intval($value);\n\n    //\
    \ Check if we have a negative number by checking the sign.\n    $is_negative =\
    \ strpos($value, '-') !== false;\n\n    // If we have a negative number, get the\
    \ absolute value.\n    if ($is_negative) {\n        $value = abs($value);\n  \
    \  }\n\n    // If the number is either zero or negative, return it as-is.\n  \
    \  if ($value <= 0) {\n        return $value;\n    }\n\n    // Check if we have\
    \ any multiples of 10.\n    $is_ten_multiple = $value % 10 === 0;\n    $is_ten_multiple_multiple_of_10\
    \ = $is_ten_multiple && $value % 100 !== 0;\n\n    // Check if the number is not\
    \ an integer.\n    $is_not_integer = !is_int($value);\n\n    // If the number\
    \ is not an integer, or the value cannot be divided by 10,\n    // return the\
    \ number.\n    if ($is_not_integer || $is_ten_multiple_multiple_of_10) {\n   \
    \     return $value;\n    }\n\n    // If the number is an integer, check if the\
    \ value is within 1 of the next\n    // largest integer. If it is, then return\
    \ the value minus 1.\n    $next_largest_integer = $largest_integer($value);\n\
    \    if ($next_largest_integer === $value + 1) {\n        $value = $value - 1;\n\
    \    }\n\n    return $value;\n}\n", "  // Get the difference between this and\
    \ the closest number to the value.\n  $diff = $value - closest_number($value);\n\
    \  // Round the difference up to the nearest integer.\n  return round($diff) +\
    \ $diff;\n}\n", "  $integer = $value;\n\n  // If there is no integer passed in,\
    \ just return zero.\n  if (!isset($integer)) {\n    return 0;\n  }\n\n  // Get\
    \ the absolute value of the integer passed in.\n  $absolute = abs($integer);\n\
    \n  // Get the absolute value of the closest value to the integer passed.\n  $closest_integer\
    \ = min(\n    abs($integer - 0.5),\n    abs($integer + 0.5)\n  );\n\n  // If the\
    \ integer is equidistant from two integers, round it away from\n  // zero.\n \
    \ if ($closest_integer == $absolute) {\n    $closest_integer = $integer < 0 ?\
    \ ceil($integer) : floor($integer);\n  }\n\n  return $closest_integer;\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| a |>\nA simple solution that works in PHP 7.4 or later:\n\
    <code>", "  $value = strval($value);\n  $value = preg_replace(\"/[^0-9]/\", \"\
    \", $value);\n  if (strpos($value, \".\") > 0) {\n    // Split the number into\
    \ its decimal and integer parts\n    $parts = explode(\".\", $value);\n    $decimal\
    \ = $parts[0];\n    $integer = $parts[1];\n\n    // Convert the decimal part's\
    \ value to an integer\n    $decimal = strval(round($decimal));\n    $decimal =\
    \ (int) $decimal;\n\n    // If the decimal part's value is greater than zero,\
    \ round the integer\n    // part's value to that value\n    if ($decimal > 0)\
    \ {\n      $integer = round($integer);\n      $integer = (int) $integer;\n   \
    \ } else {\n      // If the decimal part's value is less than zero, round the\
    \ integer\n      // part's value to zero\n      $decimal = 0;\n    }\n    // Return\
    \ the rounded value\n    return $integer . $decimal;\n  } else {\n    return 0;\n\
    \  }\n}\n</code>\n<|/ a |>\n<| c |>\nYour function will produce different output\
    \ than that of PHP function \"intval\". For example, if I pass \"10\" as the value,\
    \ then intval(\"10\") will return 10 but your function will return \"10\".\n<|/\
    \ c |>\n<| a dscore=0 |>\nI came up with a simple solution and thought I'd share\
    \ it here. The key is to convert the string into a number with PHP's floatval()\
    \ and add your \"step\" amount. Since floatval() returns \"0\" if the number is\
    \ greater than \"PHP_INT_MAX\" we need to add the appropriate amount of steps\
    \ to get to the next number. \nHere's a quick example:\n<code>\n$step = 1;\n$stepString\
    \ = \".\" . $step;\n\n$step = floatval($stepString);\n$nextNum = floatval($number)\
    \ + $step;\n</code>\n<|/ a tags=php |>\n<| a |>\nYou can use the following code\
    \ to get the integer number from given floating number: \n<code>\n<?php\n\n$number\
    \ = \"14.5\";\n$number = preg_replace('/\\D/', '', $number);\n$num = (int)$number;\n\
    echo $num;\n</code>\n<|/ a dscore=0 tags=php |>\n<| a tags=php |>\nUse this one\
    \ :\n<code>\n<?php\n\n$num = \"9.5\";\n$num = preg_replace('/\\D/', '', $num);\n\
    $num = (int)$num;\necho $num;\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>\n<?php\n",
  "  $n = abs($value) + 1;\n  return $value === 0 || $value === Infinity || $value\
    \ === -Infinity ? $n :\n     ($n < 0 || abs($value - $n) < $n ? $n : $n);\n}\n\
    \n/**\n * Returns the number of decimal places that should be displayed for a\
    \ number.\n * When displaying numbers in text form, this function will place a\
    \ dot\n * after a number if the decimal places is larger than the number of digits\n\
    \ * specified in the number itself. This function will also add a dollar sign\n\
    \ * if there is a currency symbol preceding the number.\n * @param number the\
    \ number to determine the decimal places for\n * @return number of decimal places.\n\
    \ */", "  // Turn the number into a float, then round it down.\n  $value = floatval($value);\n\
    \  $rounded = $value - floor($value);\n  // If the number was equidistant from\
    \ two integers, round up if its greater\n  // than the other, or down if its less.\n\
    \  if ($rounded > $value && $rounded < $value + 1) {\n    return floor($value);\n\
    \  }\n  return ceil($value);\n}\n", "  if ($value == \"0\") return 0;\n  $value\
    \ = floatval($value);\n  $limits = array(\"min\", \"max\");\n  foreach ($limits\
    \ as $limit) {\n    if ($value > $GLOBALS[$limit]) $max = $value;\n    if ($value\
    \ < $GLOBALS[$limit]) $min = $value;\n  }\n  if ($min == $max) return $min;\n\
    \  return $min + ($max - $min) / 2;\n}", "  $closest = PHP_INT_MAX;\n  foreach\
    \ (explode('.', $value) as $item) {\n    $current = (int) $item;\n    if ($current\
    \ < $closest) {\n      $closest = $current;\n    }\n  }\n  return $closest;\n\
    }\n", "    if ($value == 0) return 0;\n    $parts = explode('.', $value);\n  \
    \  $d = $parts[0];\n    $m = $parts[1];\n    if (!is_numeric($m)) return $value;\n\
    \    $s = abs($m);\n    if ($s < 10) {\n        $s += ((($s % 2 == 1) && $d >=\
    \ $m) ? 1 : 0);\n    }\n    return $d;\n}\n", "  return round($value);\n}", " \
    \ if (is_numeric($value) && is_numeric($value)) {\n    $value = (int) $value;\n\
    \  }\n  if (is_string($value)) {\n    $value = (float) $value;\n  }\n  if ($value\
    \ == 0) {\n    return 0;\n  }\n  if ($value < 0) {\n    $value = -$value;\n  }\n\
    \n  // See if we are close to midway between ints\n  $fractional = ($value - floor($value))\
    \ < 0.1;\n  if ($fractional) {\n    return floor($value);\n  }\n\n  // Otherwise,\
    \ do binary search for closest int\n  $high = $value;\n  $low = $high - 1;\n \
    \ if ($low < 0) {\n    return floor($value);\n  }\n\n  while ($low >= 0 && $low\
    \ <= $high) {\n    $mid = $low + floor(($high - $low) / 2);\n    if ($mid ===\
    \ $high) {\n      return $low;\n    }\n    if ($mid < $value) {\n      $high =\
    \ $mid;\n    } else {\n      $low = $mid + 1;\n    }\n  }\n  return $low;\n}\n\
    </code>\n<|/ a |>\n<| c |>\nThis works great, except when given a negative value\
    \ like `-25` it gives `-24` which isn't really a problem as long as its consistent.\
    \ Can we not use `$value = (int) $value;` when `is_numeric($value)` is false?\n\
    <|/ c |>\n<| c |>\nYou can add an `else` statement to that `if` that checks for\
    \ whether `$value` is `< 0`.\n<|/ c |>\n<| c |>\nI've tried adding `elseif(is_string($value)\
    \ && is_numeric($value)) {$value = (int) $value;}` to your code but it doesn't\
    \ appear to work. I'm not sure why but the `$value = (int) $value;` is just being\
    \ ignored.\n<|/ c |>\n<| c |>\nThe `else` statement can go right after `$value\
    \ = (int) $value;`, but before `return $low;`.\n<|/ c |>\n<| c |>\nI put that\
    \ `else` statement right before the `return $low` but nothing changed.\n<|/ c\
    \ |>\n<| a tags=integer,php dscore=2 |>\nThis is a modified version of Eliezer\
    \ Koritne's answer\n<code>", "  // Return the closest integer if value is an integer\n\
    \  if (intval($value) == $value) $value = (int)$value;\n\n  // If value is a string,\
    \ convert it to a number\n  if (is_string($value)) $value = floatval($value);\n\
    \n  // Define two variables for holding the two closest integers\n  $closest =\
    \ $farthest = 0;\n\n  // Set a variable for the number of digits in the number\n\
    \  $number_of_digits = strlen((string)$value);\n\n  // Loop through the whole\
    \ number\n  for ($i = 0; $i < $number_of_digits; $i++) {\n    // Take the current\
    \ digit in the string and make it an integer by removing the decimal point\n \
    \   // Then add it to the closest integer\n    $closest += intval(str_replace(array('.'),\
    \ array(''), $value[$i]));\n\n    // If the number is closer than the closest\
    \ integer, then set it as the closest\n    if ($closest < $farthest) $farthest\
    \ = $closest;\n  }\n\n  // Return the closest integer\n  return $closest;\n}\n\
    </code>\nThis code was taken from here\n<|/ a |>\n<| c |>\nThanks so much man!!\
    \ It works but i changed it a little bit. Here is the code\n\n    function closest_integer($value)\
    \ {\n  $number_of_digits = strlen($value);\n  $closest = $farthest = 0;\n  \n\
    \  for ($i = 0; $i < $number_of_digits; $i++) {\n    $closest += intval(str_replace(array('.'),\
    \ array(''), $value[$i]));\n    if ($closest < $farthest) $farthest = $closest;\n\
    \  }\n  \n  return $closest;\n}\n\nAnd i just tested it and it returns only 1\
    \ digit. \nI really need help :(\n<|/ c |>\n<| c |>\nMy mistake, I misread the\
    \ code. I've edited the answer with the correct code.\n<|/ c |>\n<| c |>\nHey,\
    \ \nI got it working, Thanks so much man. \nYou really saved my life.\n<|/ c |>\n\
    <| c |>\nHey, i have a problem with this. I used it on a array with a number like\
    \ this: array(0 => '9.9'), and it returns: 9 instead of 9.9 (9.9 is the right\
    \ number)\n<|/ c |>\n<| c |>\nCan you post the code that you've tried? I suspect\
    \ there's something else going on.\n<|/ c |>\n<| a dscore=0 tags=closest-points,php\
    \ |>\n<code>\n<?php", "    $numbers = array($value, 1);\n    sort($numbers);\n\
    \    return $numbers[0];\n}\n", "    return round($value, -1);\n}\n", "  // If\
    \ the given number is an integer, return it.\n  if (is_int($value)) {\n    return\
    \ $value;\n  }\n\n  // Get the integer value of the given number.\n  $value_int\
    \ = strtolower($value);\n\n  // Get the decimal part of the given value.\n  $decimal_point\
    \ = strpos($value, '.');\n\n  // If the decimal part is unavailable (no . character),\
    \ get the whole part\n  // by removing any leading zeros.\n  if ($decimal_point\
    \ === false) {\n    $value_int = ltrim($value_int, '0');\n  } else {\n    $value_int\
    \ = rtrim($value_int, $decimal_point);\n  }\n\n  // Set the decimal point to 0.\n\
    \  $decimal_point = 0;\n\n  // Get the decimal part of the given value.\n  $decimal_part\
    \ = substr($value_int, $decimal_point);\n\n  // Get the integer part of the given\
    \ value.\n  $integer_part = substr($value_int, 0, $decimal_point);\n\n  // If\
    \ there is a decimal part, determine the closest integer.\n  if ($decimal_part\
    \ !== '') {\n    $value_int = ceil($integer_part / $decimal_part);\n  } else {\n\
    \    $value_int = floor($integer_part / $decimal_part);\n  }\n\n  // Return the\
    \ integer part of the value that is the closest to 0.\n  return $value_int;\n}",
  "\t$int_value = intval($value);\n\tif ($int_value >= 0 && $int_value <= 9) {\n\t\
    \treturn $int_value;\n\t} elseif ($int_value <= -10 && $int_value >= -10) {\n\t\
    \treturn $int_value;\n\t}\n\n\treturn round($int_value, 0);\n}\n\n/**\n * Reverse\
    \ a string\n * @param  string $str String to reverse\n * @return string Reversed\
    \ string\n */", "  $closest = 0;\n  foreach ($value as $key => $num) {\n    $diff\
    \ = $num - $closest;\n    if ($diff > 0) {\n      $closest = round($num);\n  \
    \  } else {\n      $closest = round($closest + abs($diff));\n    }\n  }\n  return\
    \ $closest;\n}"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
