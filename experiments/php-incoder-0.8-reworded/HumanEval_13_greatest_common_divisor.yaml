name: HumanEval_13_greatest_common_divisor
language: php
prompt: "<?php\n// Return a greatest common divisor of two integers a and b\n// >>>\
  \ greatest_common_divisor(3, 5)\n// 1\n// >>> greatest_common_divisor(25, 15)\n\
  // 5\nfunction greatest_common_divisor($a, $b) {\n"
tests: "function candidate(...$args) {\n    return greatest_common_divisor(...$args);\n\
  }\n\nfunction test(): void {\n    if (candidate(3, 7) !== 1) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(10, 15) !== 5) { throw new Exception(\"Test\
  \ failed!\"); }\n    if (candidate(49, 14) !== 7) { throw new Exception(\"Test failed!\"\
  ); }\n    if (candidate(144, 60) !== 12) { throw new Exception(\"Test failed!\"\
  ); }\n}\n\ntest();"
completions: ["  return $b ? gcd($a, $b)\n           : gmp_init('9876543210');\n}\n",
  "    while ($a && $b) {\n        if ($a % $b === 0) {\n            return $b;\n\
    \        }\n        $b = $b % $a;\n        $a = $a % $b;\n    }\n    return $a\
    \ || $b;\n}", "  return !is_nan($a) && is_nan($b) ? NaN : !is_nan($a) && !is_nan($b)\
    \ ? $a % $b : $a < $b ? $b : $a;\n}\n", "    // Return the greatest common divisor\
    \ of a and b\n    // a & b will always be integers\n    return ($a & $b) ? ((~$a\
    \ % $b) + $b) : ($a & $b);\n}\n", "    return $a % $b ? $b : $a;\n}\n", "    $a\
    \ = max($a, 0);\n    $b = max($b, 0);\n    while ($b != 0) {\n        $d = $a\
    \ % $b;\n        $a = $b;\n        $b = $d;\n    }\n    return $a;\n}\n", "  \
    \  return ($b % $a == 0) ? $b : ($a % $b) ? $a : $b;\n}\n</code>\n<|/ a |>\n<|\
    \ c |>\n`return (a % b == 0) ? b : (a % b == 0) ? a : b;` is equivalent to: `return\
    \ (a % b) ? b : (a % b) ? a : b;`\n<|/ c |>\n<| c |>\nThat is definitely a lot\
    \ shorter than my answer.\n<|/ c |>\n<| a dscore=3 |>\nFor very large numbers,\
    \ this would be the correct solution:\n<code>\n<?php\n/**\n * gcd.php\n *\n *\
    \ Integer $a\n * Integer $b\n *\n * Integer\n */", "    // Find Euclid's algorithm\n\
    \    // http://en.wikipedia.org/wiki/Euclidean_algorithm\n    if ($a < 0) {\n\
    \        $a = $a * -1;\n    }\n    if ($b < 0) {\n        $b = $b * -1;\n    }\n\
    \    $remainder = 0;\n    if ($a > $b) {\n        $remainder = $a % $b;\n    \
    \    $a = $b;\n        $b = $remainder;\n    }\n    while ($a != 0) {\n      \
    \  $remainder = $a % $b;\n        $a = $b;\n        $b = $remainder;\n    }\n\
    \    if ($a == 0) {\n        return $b / $a;\n    }\n    return -1;\n}", "   \
    \ $remainder = $a % $b;\n    return $b + ($remainder ? 1 : 0);\n}\n", "    if\
    \ ($a == 0) return $b;\n    if ($b == 0) return $a;\n    \n    // a and b are\
    \ both positive integers\n    $m = ($a % $b);\n    if ($m == 0) return $a;\n \
    \   return greatest_common_divisor($b, $m);\n}\n</code>\nThis one will find you\
    \ the greatest common divisor of any two positive integers and is probably the\
    \ most efficient way of doing it (as long as the numbers are relatively small).\
    \ For larger numbers it may be more efficient to just multiply them and carry\
    \ out the division by hand.\n<|/ a |>\n<| a |>\nYou could also write a recursive\
    \ function that will find the GCD of any number of numbers. \n<code>", "  $gcd\
    \ = 0;\n  $remainder = 0;\n  while ($a !== 0) {\n    $remainder = $a % $b;\n \
    \   if ($remainder === 0) {\n      $gcd = $b;\n      $a = 0;\n    }\n    else\
    \ {\n      $a = $b;\n      $b = $remainder;\n    }\n  }\n  return $gcd;\n}\n",
  "    $gcd = 0;\n    while ($a && $b) {\n        if ($a > $b) {\n            $a =\
    \ $a - $b;\n        } else {\n            $b = $b - $a;\n        }\n        $gcd\
    \ = $gcd+$a;\n    }\n    return $gcd;\n}", "    // If either number is a fraction,\
    \ then return a fraction\n    // with the remainder as the GCD and the numerator\
    \ and denominator\n    // of the fraction as integers\n    $frac_a = $a % $b;\n\
    \    $frac_b = $b % $a;\n    $gcd = intval($frac_a / $frac_b);\n\n    if ($gcd\
    \ > 1) {\n        $gcd -= $a;\n    }\n\n    return $gcd;\n}", "  return $a % $b\
    \ == 0 ? $a / $b : $b;\n}\n", "    if ($a < $b) return $b - $a;\n    return $a\
    \ - $b;\n}\n", "    while ($a % $b !== 0 && $a != $b) ;\n    return $a;\n}\n",
  "    return gcd($b, $a) % $a;\n}\n</code>\n(For an explanation of what this does,\
    \ refer to https://math.stackexchange.com/a/102559)\n<|/ a dscore=4 tags=php,modulo\
    \ |>\n<| c |>\nThis is great!  Do you have a link to where you learned this? \
    \ It would be awesome if SO allowed that kind of thing.\n<|/ c |>\n<| c |>\nI\
    \ learned this by using the calculator, for that exact purpose, and it always\
    \ came up with the same result. Google \"gcd modulo arithmetic PHP\" to get several\
    \ other answers :)\n<|/ c |>\n<| c |>\nAhhh... so Google is doing some weird mathematical\
    \ operations on the result.  That makes perfect sense now... Thanks.\n<|/ c |>\n\
    <| a tags=php,modulo dscore=4 |>\nHere's a simple solution using binary maths:\n\
    <code>\n$remainder = 10 - (($a / $b) % 10);\n</code>\n<|/ a |>\n<| c |>\nNot sure\
    \ why this was down voted: clever and simple!\n<|/ c |>\n<| a tags=php,modulo\
    \ |>\n<code>\n$a = 95;\n$b = 100;\n\n$mod = $a%$b;\n$remainder = $b-$mod;\n</code>\n\
    <|/ a dscore=3 |>\n<| a dscore=3 |>\nI wanted to implement a solution to this.\n\
    My solution is as follows:\n<code>\n<?php\n$a = 95;\n$b = 100;\necho $mods = $b\
    \ % ($a / $b);\necho \"<br/>\";\necho $remainder = $a % $b;\n</code>\nIt does\
    \ what we expect. In the first output, it gives the remainder of the division\
    \ between two integers while in the second output, it gives the remainder of a\
    \ modulus of an integer by a number.\n<|/ a tags=php,modulo |>\n<| a tags=php,modulo\
    \ |>\nUsing binary maths is the right way to go for this problem.  However, since\
    \ you're doing this in a PHP script you'll have to do the maths yourself.  A good\
    \ algorithm to do this is the Euclidian algorithm.  Here are some PHP functions\
    \ you can use:\n\nhttp://php.net/manual/en/function.bcmod.php\nhttp://php.net/manual/en/function.bcadd.php\n\
    http://php.net/manual/en/function.bcmul.php\n\nI won't try to implement this for\
    \ you, but here's a nice article that explains how to do it.\n", "    // Get the\
    \ remainder of the division (the decimal point before the first decimal digit)\n\
    \    $r = $a % $b;\n    // Get the remainder of the division (the decimal point\
    \ after the last decimal digit)\n    $r = $r ? $r / $b : $b / $a;\n    // Return\
    \ the greatest common divisor of the two numbers, rounded down to the nearest\
    \ integer\n    return $r ? ceil($r) : 1;\n}\n</code>\nThe function above is quite\
    \ simple, it just does a modulus (%) operation with a second variable (which gets\
    \ the remainder of the division) and then checks if the remainder is zero (no\
    \ remainder), otherwise it keeps dividing the divisor by itself and gets the remainder\
    \ again.\nAnd here is the complete code:\n<code>\n<?php\n", "    // Initialize\
    \ variables\n    $g = Math_PI_DENOM;\n    $h = $b - $a;\n    $i = ($h < 0) ? -$h\
    \ : $h;\n    $j = ($i > 0) ? $h : $i;\n\n    // Repeat while quotient does not\
    \ divide both a and b\n    do {\n        $g = $a - $h*$g;\n        $h = ($g >\
    \ 0) ? floor($g) : $g;\n        $a = $h + $b;\n        $h = ($a > 0) ? floor($a)\
    \ : $a;\n        $g = $h + $b;\n        $i = ($h < 0) ? -$h : $h;\n        $j\
    \ = ($i > 0) ? $h : $i;\n    } while ($a != $g);\n\n    return $j;\n}\n", "  \
    \  $c = $a;\n    while($c <= $b){\n        $c = $a * $b / gcd($a, $b);\n     \
    \   $a++;\n    }\n    return $c;\n}\n", "  return ($a % $b + $b) % $a;\n}", " \
    \ if ($a < $b) {\n    return greatest_common_divisor($b, $a);\n  }\n\n  if ($a%$b\
    \ == 0)\n    return $b;\n  else\n    return greatest_common_divisor($b, $a%$b);\n\
    }", "    $r = 1;\n    while ($b !== 0) {\n        $r = $a % $b;\n        $a =\
    \ $b;\n        $b = $r;\n    }\n    return $a;\n}\n", "    if ($a == 0)\n    \
    \    return $b;\n    if ($b == 0)\n        return $a;\n    if ($a > $b) {\n  \
    \      $tmp = $a;\n        $a = $b;\n        $b = $tmp;\n    }\n    $d = $a%$b;\n\
    \    $bs = $b - $d;\n    $ds = $d % $a;\n    if ($ds == 0)\n        return $b;\n\
    \    return greatest_common_divisor($a, $bs);\n}\n", "    while ($a != 0) {\n\
    \        $a = $b % $a;\n        $b = $a * ($a + 1);\n    }\n    return $b;\n}\n\
    </code>\n<|/ a |>\n<| c |>\n`lcm()` and `gcd()` are in php 5.5 and up.\n<|/ c\
    \ |>\n<| c |>\nThanks. I was not aware of these functions.\n<|/ c |>\n<| a tags=function,php\
    \ |>\n<code>\n/**\n * Returns the greatest common divisor between two integers\
    \ a and b\n * \n * int $a The first number\n * int $b The second number\n * int\
    \ The greatest common divisor\n */", "  if ($a == 0 && $b == 0) {\n    return\
    \ 0; // Neither a nor b is zero\n  }\n  if ($a == 0) {\n    return $b; // a is\
    \ zero\n  }\n  if ($b == 0) {\n    return $a; // b is zero\n  }\n  // Both are\
    \ positive integers\n  $gcd = bcdiv($a, $b);\n  $quotient = bcmod($a, $b);\n \
    \ if ($quotient != 0) {\n    $gcd = bcsub($gcd, $quotient);\n  }\n  return $gcd;\n\
    }\n</code>\n<|/ a tags=php,laravel,math,laravel-5.2 |>\n<| a |>\nThis function\
    \ is much more efficient\n<code>", "    $divisors = array();\n    while ($a &&\
    \ $b) { \n        $divisors[] = ($a % $b); \n        $a = floor($a/$b); \n   \
    \     $b = floor($b/$b); \n    }\n    return $divisors ? array_pop($divisors)\
    \ : 0;\n}", "    return ($a % $b) + $b;\n}\n\n$a = 50;\n$b = 5;\necho \"Greatest\
    \ common divisor of $a and $b is \" . greatest_common_divisor($a, $b);", "   \
    \ if ($a < $b) {\n        $a = $b;\n        $b = $a;\n    }\n\n    while ($a >\
    \ 0 && $b > 0) {\n        $tmp = $a;\n        $a = $b;\n        $b = $tmp;\n \
    \   }\n\n    return $a;\n}\n", "  return $b ? gcd($a, $b % $a) : $a;\n}\n", " \
    \   // initialize $c and $d so that they are integers\n    $c = $d = 1;\n    //\
    \ initialize $m\n    $m = 0;\n    // loop while $a divides $b\n    while (0 !==\
    \ ($m = $a % $b)) {\n        // if $a divides $b, update $d\n        if (0 !==\
    \ $m) {\n            $d += 1;\n        }\n        // if $d divides $c, update\
    \ $c\n        if (0 !== ($m = $d % $c)) {\n            $c += 1;\n        }\n \
    \   }\n    return $c;\n}\n", "\treturn ($a % $b) / gcd($a, $b);\n}\n", "  return\
    \ $a % $b ?: $b; // b > 0 ? a : b\n}\n", "    $g = gcd($a, $b);\n    if ($g ==\
    \ 0)\n        return 0;\n    else\n        return $a / $g;\n}", "    if ($a <\
    \ 0) {\n        $a = -$a;\n    }\n    if ($b < 0) {\n        $b = -$b;\n    }\n\
    \n    while ($a !== 0) {\n        if ($b === 0) {\n            return $a;\n  \
    \      }\n        if ($a > $b) {\n            $a = $a - $b;\n        } else {\n\
    \            $b = $b - $a;\n        }\n    }\n\n    return 0;\n}\n", "  $x = abs(($a\
    \ / $b) % $b);\n  if ($x === 0) {\n    return $b;\n  }\n  return $b;\n}\n</code>\n\
    <|/ a tags=php,algorithm |>\n<| c |>\nVery interesting approach! But what about\
    \ larger numbers such as 40000000 and 80000000? The results for 40000000 and 80000000\
    \ would be 1 and the remainder would be 0.\n<|/ c |>\n<| c |>\nYes, thanks, that\
    \ is a problem. There should be a check to see if the remainder is divisible by\
    \ b, and if so subtract a from b. I'll update the answer.\n<|/ c |>\n<| c |>\n\
    Thanks for your answer. I checked the algorithm on `40000000 = 2` and `80000000\
    \ = 1` and it still doesn't work. It returns `80000000` for the first two test\
    \ cases and `80000000` for the last two test cases.\n<|/ c |>\n<| c |>\nWhat about\
    \ `40000000 = 1000000000` and `80000000 = 1000000000`? Your algorithm returns\
    \ `1000000000` for the first two test cases and `1000000000` for the last two\
    \ test cases. The correct result should be `2`.\n<|/ c |>\n<| c |>\nI checked\
    \ this on `40000000` and `80000000` and the results were correct for both of those\
    \ cases. I ran the algorithm with the code I provided and they both returned `2`\n\
    <|/ c |>\n<| a tags=php,algorithm |>\nTo solve the problem you stated above, I\
    \ think this would work:\n<code>", "    $rr = $b % $a;\n    if ($rr == 0) {\n\
    \        return $a;\n    }\n    return $a + greatest_common_divisor($a, $b);\n\
    }", "    return !($b < 0) ? $a : ($a % $b ? $a / $b : $b / $a);\n}", "\tif ($a\
    \ < 0 || $b < 0) {\n\t\treturn PHPExcel_Calculation_Functions::NaN();\n\t}\n\t\
    return !isset($a) ?\n\t\t$b\n\t\t:\n\t\t!isset($b) ?\n\t\t\t$a\n\t\t\t:\n\t\t\t\
    $a % $b + floor($a / $b) * $b;\n}\n\t\n/**\n * PHPExcel_Calculation_Functions::inversePercentile\n\
    \ *\n * Returns the inverse of the specified percentile (0 returns the minimum\
    \ value while 100 returns the maximum).\n *\n * Excel Function:\n *        PERCENTILE.INV(val[,\
    \ sorted])\n *\n * @access    public\n * @category  Statistical Functions\n *\
    \ @param     float     val            The value at which the percentile is computed.\n\
    \ * @param     boolean    sorted        Optional boolean that indicates whether\
    \ the\n *                                    array is already sorted.\n * @return\
    \    float\n */", "    $m = 1;\n    while ($b > 0) {\n        $m = $a % $m;\n\
    \        $a = ($b / $m) >> 0;\n        $b--;\n    }\n    return $m;\n}", "   \
    \ $remainder = $a;\n    $divisor = $b;\n    while(!is_nan($divisor)) {\n     \
    \   $remainder = $remainder % $divisor;\n        $divisor = $divisor % $divisor;\n\
    \    }\n    return $remainder;\n}\n", "  // We can't use div for remainders, because\
    \ PHP does not\n  // guarantee that a % b == 0 for values of modulus n over n\
    \ <= 31\n  // This means that for the sake of speed, we don't bother with\n  //\
    \ special cases for most powers of two except for 1, which is trivial\n  return\
    \ $b ? gcd($a, $b % $a) : $a; // eslint-disable-line no-extra-parens\n}", "  \
    \  // Return early if either number is 0\n    if ($a == 0 || $b == 0) {\n    \
    \    return 0;\n    }\n    return $a % $b + greatest_common_divisor($b, $a % $b);\n\
    }\n", "    return gmp_div_qr($a, $b, $t);\n}", "\t$a = abs($a); // make sure a\
    \ is a number\n\t$b = abs($b); // make sure b is a number\n\tif ($a < $b) { $tmp\
    \ = $b; $b = $a; $a = $tmp; }\n\treturn ($b == 0) ? $a : $a%$b;\n}\n", "  // Greatest\
    \ common divisor and least common multiple\n  $gcd = $a % $b;\n  if ($gcd == 0)\
    \ {\n    return $b;\n  }\n  return $gcd;\n}\n", "    $remainder = 0;\n    while\
    \ ($a && $b) {\n        $remainder = ($a % $b);\n        $a = ($a - $remainder)\
    \ / $b;\n        $b = ($b - $remainder) / $a;\n    }\n    return $remainder;\n\
    }", "    $gcd = 0;\n    for ($i = 1; $i <= $b && $a >= $i; ++$i) {\n        $gcd\
    \ = max($gcd, $i);\n    }\n    for ($i = 1; $i <= $a && $b >= $i; ++$i) {\n  \
    \      $gcd = max($gcd, $i);\n    }\n    return $gcd;\n}\n", "    if ($a < 0)\
    \ {\n        $a = abs($a);\n        $b = abs($b);\n    }\n    return $b <= 0 ?\
    \ $a : gcd($b, $a % $b);\n}\n", "    $n = abs($a) - abs($b);\n    $d = 1;\n  \
    \  while ($n !== 0) {\n        if ($n % 2) {\n            $n = ($n - 1) / 2;\n\
    \            $d++;\n        }\n        else {\n            $n /= 2;\n        \
    \    $d--;\n        }\n    }\n    return $d ? $d + $a : $a;\n}\n", "    $gcd =\
    \ 0;\n    while ($a != 0) {\n        $a = $a % $b;\n        $gcd = $b % $gcd;\n\
    \        $b = $a / $b;\n    }\n    return $gcd;\n}\n", "  // Initialize $c\n \
    \ $c = 1;\n  // Initialize $d\n  $d = $a;\n  // Initialize remainder\n  $remainder\
    \ = 0;\n  // Initialize quotient\n  $quotient = 0;\n  // Initialize remainder_a\n\
    \  $remainder_a = 0;\n  // Initialize remainder_b\n  $remainder_b = 0;\n\n  //\
    \ Calculate $quotient\n  while ($d !== 0) {\n    if ($d == 0) {\n      break;\n\
    \    }\n    // Calculate $remainder\n    $remainder = $remainder % $b;\n    //\
    \ Calculate $d\n    $d = $d / $a;\n    // Calculate $quotient\n    $quotient =\
    \ $quotient + $remainder;\n  }\n\n  // Calculate remainder_a\n  while ($d !==\
    \ 0) {\n    // Calculate $remainder\n    $remainder_a = $remainder_a % $a;\n \
    \   // Calculate $d\n    $d = $d / $b;\n    // Calculate $quotient\n    $quotient\
    \ = $quotient + $remainder_a;\n  }\n\n  // Calculate remainder_b\n  while ($d\
    \ !== 0) {\n    // Calculate $remainder\n    $remainder_b = $remainder_b % $b;\n\
    \    // Calculate $d\n    $d = $d / $a;\n    // Calculate $quotient\n    $quotient\
    \ = $quotient + $remainder_b;\n  }\n\n  return $quotient;\n}", "    $a = abs($a);\n\
    \    $b = abs($b);\n    while ($a && $b) { $a = $a % $b; $b = $b / $b; }\n   \
    \ return $b;\n}\n", "  if (!is_numeric($a) || !is_numeric($b))\n    return null;\n\
    \n  if ($a === 0 || $b === 0)\n    return 0;\n  return gmp_init(\n    greatest_common_divisor(abs($a),\
    \ abs($b)),\n    $a,\n    $b\n  );\n}\n", "    // The GCD of two positive numbers\
    \ is always positive\n    if ($a < 0) {\n        $a = -$a;\n    }\n    if ($b\
    \ < 0) {\n        $b = -$b;\n    }\n\n    if ($b == 0) {\n        return $a;\n\
    \    }\n\n    return $a / greatest_common_divisor($b, $a % $b);\n}\n", "    if\
    \ ($a === $b) {\n        return $a;\n    }\n\n    $x = $a%$b;\n    $y = $a/$b;\n\
    \n    return max($x, $y);\n}", "    $a = abs($a);\n    $b = abs($b);\n    while\
    \ ($a && $b) { $a = $b; $b = 0; }\n    return min($a, $b);\n}\n", "  if ($b ==\
    \ 0)\n    return $a;\n\n  if ($a < 0)\n    $a = -$a;\n\n  $r = $a;\n  $x = $b;\n\
    \  for ($i = 1; $i <= $a; ++$i) {\n    $r = ($r * $x) % $b;\n  }\n\n  return $r;\n\
    }\n", "  if ($b == 0)\n    return $a;\n  return greatest_common_divisor($b, $a\
    \ % $b);\n}", "    if ($a == 0 || $b == 0) {\n        return 0;\n    }\n    return\
    \ $a % $b ? greatest_common_divisor($b, $a % $b) : $b;\n}\n", "    return $b ?\
    \ greatest_common_divisor($b, $a % $b) : $a;\n}\n", "    $r = 1;\n    while ($a\
    \ % $r == 0) {\n        $r = $r * 10 % $b;\n    }\n    while ($b % $r == 0) {\n\
    \        $r = $r * 10 % $a;\n    }\n    return $r;\n}", "    return ($a % $b ==\
    \ 0) ? $a / $b : greatest_common_divisor($b, $a % $b);\n}\n", "  $gcd = 0;\n \
    \ while($a && $b) {\n    $d = intval($a / $b);\n    $a = $a - $d*$b;\n    $gcd\
    \ = max($gcd, $d);\n  }\n  return $gcd;\n}", "    $gcd = 0;\n    for ($i = $a\
    \ - 1; $i >= $b; $i--) {\n        $gcd = $i % $gcd ? $gcd : $i;\n    }\n    return\
    \ $gcd;\n}", "  // Make sure $a and $b are positive integers\n  if (is_numeric($a)\
    \ && is_numeric($b) && intval($a) >= 0 && intval($b) >= 0) {\n    $a = intval($a);\n\
    \    $b = intval($b);\n    // Find the greatest common divisor\n    $gcd = $a;\
    \ $m = 1;\n    while ($b !== 0) {\n      $m = $m * ($b % $gcd, $gcd = $gcd);\n\
    \      $b = $b / $gcd;\n    }\n    // Return result if there's a common divisor\n\
    \    return $m !== 0 ? $m : -1;\n  }\n  // Return result if there's no common\
    \ divisor\n  return -1;\n}\n\n/**\n * Converts an angle from degrees to radians\n\
    \ *\n * @param string $angle_deg The angle in degrees. Valid values: 90, 180,\
    \ 270, 360 , 90, 180, 270\n *\n * @return float $angle_deg_rad The angle in radians\n\
    \ */", "    while ($b !== 0) {\n        $r = ($b % $a) + $a;\n        $b = (int)\
    \ ($a / $r);\n        $a = $r;\n    }\n\n    return $a;\n}\n", "  if (!is_int($a)\
    \ || !is_int($b)) {\n    trigger_error('greatest_common_divisor() expects both\
    \ numbers to be integers', E_USER_WARNING);\n    return false;\n  }\n\n  if ($a\
    \ < $b) {\n    $temp = $a;\n    $a = $b;\n    $b = $temp;\n  }\n\n  while ($a\
    \ >= $b) {\n    $a = $a % $b;\n  }\n\n  return $a;\n}\n", "  for ($i = $a; $i\
    \ <= $b;$i++) {\n    if ($i % $a == 0 && $i % $b == 0) {\n      return $i;\n \
    \   }\n  }\n  return null;\n}\n", "  // Make sure that $a and $b are integers.\n\
    \  if (!is_int($a) || !is_int($b)) {\n    return false;\n  }\n  // Use a naive\
    \ approach of multiplying the two numbers and counting the\n  // number of \"\
    zero\" digits. This is a good approximation for the\n  // greatest common divisor\
    \ because if a and b have the same digits, the\n  // product will be even.\n \
    \ // >>> greatest_common_divisor(12, 24)\n  // 4\n  return $a * $b /\n    (($a\
    \ + $b + (int)(($a > $b ? 1 : 0)) * 8336) >> (int)(($a > $b ? 1 : 0)));\n}\n",
  "  $d = abs($a % $b);\n  if ($d == 0) return $b;\n  if ($d == $b) return $a;\n \
    \ return $d + greatest_common_divisor($b, $d);\n}\n", "  if ($a < 0 || $b < 0)\
    \ {\n    return 0;\n  }\n  $div = $a % $b;\n  if ($div === 0) {\n    return $b;\n\
    \  }\n  return $a + greatest_common_divisor($b, $div);\n}\n", "  // Get a common\
    \ factor of the two\n  $p = $a%$b;\n  // If that common factor is greater than\
    \ the divisor\n  // then divide both a and b to reduce the number of\n  // common\
    \ factors, then take the remainder of the dividend\n  // and the divisor\n  if($p>0)\
    \ {\n    return greatest_common_divisor($b, $p);\n  } else {\n    return $p;\n\
    \  }\n}", "  // If the numbers are equal or one or both are zero return 1\n  if\
    \ ($a === 0 || $b === 0) {\n    return 1;\n  }\n  // If the numbers are equal,\
    \ return greatest common divisor\n  if ($a === $b) {\n    return $a;\n  }\n  //\
    \ Divide by one\n  $a *= $a % $b;\n  // Iteratively reduce by divisor\n  $a =\
    \ $a / $b;\n  // Return greatest common divisor of two\n  return $a;\n}\n\n/*\
    \ --------------------------- INLINE NOTIFICATION --------------------------*/\n",
  "    if ($a < 0) {\n        $a = -$a;\n    }\n    if ($b < 0) {\n        $b = -$b;\n\
    \    }\n    while ($a != 0) {\n        $a = ($a % $b);\n        $b = $a / $b;\n\
    \    }\n    return $b;\n}\n", "  while ($b) {\n    $d = $a % $b;\n    if ($d ==\
    \ 0) {\n      return $b;\n    }\n    $a = $b;\n    $b = $d;\n  }\n  return $a;\n\
    }\n", "  return $b ? gcd($a, $b) : $a;\n}\n", "    $a = (int) $a;\n    $b = (int)\
    \ $b;\n\n    do {\n        $tmp = $a % $b;\n        $a = $b;\n        $b = $tmp;\n\
    \    } while (!($a % $b));\n\n    return $a;\n}\n", "  return $b ? gcd($a, $b)\
    \ : $a;\n}\n</code>\n<|/ a dscore=1 tags=php,algorithm |>\n<| c |>\nThanks for\
    \ your answer, but I already know it :) I want to know why it's not working with\
    \ PHP - I thought PHP is smarter then me :) So I'm looking for a PHP implementation\
    \ :)\n<|/ c |>\n<| a dscore=1 |>\nYou can use a recursive PHP function - like\
    \ so:\n<code>", "    $c = $a%$b;\n    if ($c == 0) {\n        return $a;\n   \
    \ } else {\n        return greatest_common_divisor($b, $c);\n    }\n}", "    return\
    \ ($a % $b + ($a % $b > 0)) ? $a / $b : $b;\n}\n", "    while($b != 0) {\n   \
    \     if ($a % $b == 0) {\n            return $b;\n        }\n        $a = $b;\n\
    \        $b = $a % $b;\n    }\n    return $a;\n}\n</code>\n<|/ a tags=php,math\
    \ |>\n<| a dscore=0 |>\nYou can use this code\n<code>\n<?php", "    $x = abs($a);\
    \ $y = abs($b);\n    if ($x > $y)\n    {\n        $temp = $x;\n        $x = $y;\n\
    \        $y = $temp;\n    }\n    while ($x % $y == 0)\n    {\n        $x = $x\
    \ / $y;\n        $y++;\n    }\n    return $y;\n}", "    if ($a === 0 || $b ===\
    \ 0) {\n        return 0;\n    }\n\n    return $a % $b !== 0 ? greatest_common_divisor($b,\
    \ $a % $b) : $b;\n}\n", "  $f = $b;\n  $i = 1; \n  while ($a > $f) { \n    $f\
    \ = $a%$f;\n    $i++;\n  }\n  return $f;\n}\n", "    // If either number is 0,\
    \ return 0.\n    if ($a === 0 || $b === 0) {\n        return 0;\n    }\n    //\
    \ Make sure that $a is greater than or equal to $b.\n    if ($a < $b) {\n    \
    \    $a = $b;\n        $b = $a;\n    }\n\n    // Set $c to $a. If $c is zero,\
    \ set $c to $b. If $c is less than or equal to zero,\n    // subtract $c from\
    \ $b.\n    $c = 0;\n    if ($c < $a) {\n        $c = $a;\n        $a = $c;\n \
    \   }\n\n    // $d = $b.\n    $d = $b;\n\n    // Calculate $e: $d = $d / $c.\n\
    \    $e = $d / $c;\n\n    // $f = $e. If $f is zero, set $f to $c. If $f is less\
    \ than or equal to zero,\n    // subtract $f from $c.\n    $f = 0;\n    if ($f\
    \ < $e) {\n        $f = $e;\n        $e = $f;\n    }\n\n    // $g = $f.\n    $g\
    \ = $f;\n\n    // Calculate $h = $g. $h = $h / $d.\n    $h = $g / $d;\n\n    //\
    \ $i = $h.\n    $i = $h;\n\n    // If $i is zero, return 0.\n    if ($i === 0)\
    \ {\n        return 0;\n    }\n    // If $i is less than or equal to zero, return\
    \ 1.\n    if ($i <= 0) {\n        return 1;\n    }\n    // If $i is greater than\
    \ or equal to one, return 0.\n    if ($i >= 1) {\n        return 0;\n    }\n \
    \   // If $i is greater than or equal to two, return 1.\n    if ($i >= 2) {\n\
    \        return 1;\n    }\n\n    // Calculate $j = $i - 1.\n    $j = $i - 1;\n\
    \n    // Calculate $k = $j * $j.\n    $k = $j * $j;\n\n    // Set $l = $k / $j.\n\
    \    $l = $k / $j;\n\n    // If $l is zero, return 1.\n    if ($l === 0) {\n \
    \       return 1;\n    }\n    // If $l is less than or equal to one, return 0.\n\
    \    if ($l <= 1) {\n        return 0;\n    }\n    // If $l is greater than or\
    \ equal to two, return 1.\n    if ($l >= 2) {\n        return 1;\n    }\n\n  \
    \  // Calculate $m = $l - 1.\n    $m = $l - 1;\n\n    // Set $n = $m / $l.\n \
    \   $n = $m / $l;\n\n    // If $n is zero, return 1.\n    if ($n === 0) {\n  \
    \      return 1;\n    }\n    // If $n is less than ", "    $a = abs($a); $b =\
    \ abs($b);\n    $c = min(max($a,$b), 0);\n    $d = min($a,$b);\n    while ($d\
    \ >= $c) {\n        $d = $c % $a;\n        $c = $a;\n        $a = $d;\n    }\n\
    \    while ($d <= $c) {\n        $d = $c % $b;\n        $c = $b;\n        $b =\
    \ $d;\n    }\n    return $c;\n}\n", "  return 0 == $a % $b ? $a : $b == $a ? $a\
    \ : gcd($b, $a % $b);\n}\n", "    $gcd = 0;\n    while ($a && $b) {\n        $a\
    \ = $a % $b;\n        $gcd = $b ? $gcd : $a;\n        $b = $a ? $b : 0;\n    }\n\
    \    return $gcd;\n}\n", "    $gcd = 0; \n    while($a != 0) {\n        $t = $a;\
    \ \n        $a = $b%$t; \n        $b = $t; \n        $gcd = $t;\n    }\n    return\
    \ $gcd;\n}\n", "  $remainder = null;\n  if ($a % $b) {\n    $b = $a % $b;\n  \
    \  $remainder = $a;\n  } else {\n    $b = $a % $b;\n    $remainder = $b;\n  }\n\
    \  while ($b) {\n    $a = $b;\n    $b = $remainder % $a;\n    $remainder = $a;\n\
    \  }\n  return $b;\n}\n", "    $r = $b;\n    $m = 0;\n    while ($r !== 0) {\n\
    \        $q = floor(($a / $r) + 1);\n        $r = ($a % $r) / $q;\n        $m\
    \ = ($q > $m ? $q : $m);\n    }\n    return $m;\n}\n", "    $a_bigger = ($a >\
    \ $b) ? $a : $b;\n    return ($a % $a_bigger) == 0 ? $a_bigger : gcd($a_bigger,\
    \ $b);\n}\n", "    return $b ? gcd($a, $b)\n        : greatest_common_divisor($b,\
    \ $a); // swap arguments if necessary\n}\n", "  if ($a == 0)\n    return 0;\n\
    \  if ($b == 0)\n    return $a;\n  if ($a < $b)\n    return greatest_common_divisor($b,\
    \ $a);\n  $greatest_divisor = 1;\n  for ($i = 1; $i <= $a; $i++)\n    $greatest_divisor\
    \ *= $i;\n  for ($i = $b; $i > 0; $i--)\n    $greatest_divisor *= $i;\n  return\
    \ $greatest_divisor;\n}\n</code>\nIn a way, you are just taking the factorial\
    \ of n-1 and the product of n and (n-1), then multiplying those two values together\
    \ and multiplying the answer by (1/2) and then subtracting half of that.  This\
    \ approach is similar to the approach that you tried previously.\n<|/ a |>\n<|\
    \ c |>\nThanks Mark. I was thinking of this approach too, but I wasn't sure if\
    \ the time complexity would be as expected given that we are using recursive functions.\n\
    <|/ c |>\n<| c |>\nYes, this approach is O(n) time complexity and O(1) space complexity.\n\
    <|/ c |>\n<| c |>\nFor large numbers, this approach will take a long time. For\
    \ example, if you try it with `greatest_common_divisor(105, 50); `, the function\
    \ will take a very long time because the number is so large and there are many\
    \ terms to evaluate.\n<|/ c |>\n<| c |>\nThe above code returns 1, not 5.\n<|/\
    \ c |>\n<| c |>\nThanks so much for the update. This is a really nice solution\
    \ and easy to understand. I would only add that if you were to create a recursive\
    \ function, it would not be a tail call because it was recursively calling a function,\
    \ but rather iterative due to the fact that it was using the loop construct. I\
    \ would recommend reading the wiki page on tail call optimization https://en.wikipedia.org/wiki/Tail_call\n\
    <|/ c |>\n<| a dscore=5 tags=algorithm,greatest-common-divisor,php |>\nThe PHP\
    \ function below is based on the concept of \"greatest common divisor\" presented\
    \ here - https://en.m.wikipedia.org/wiki/Euclidean_algorithm\n<code>", "\t$a =\
    \ $a % $b;\n\tif ($a < 0) $a = $b - $a;\n\treturn $a;\n}\n", "    $i = 0;\n  \
    \  $j = 0;\n    while ($i < $b) {\n        if ($a % $j == 0) {\n            $a\
    \ = $j;\n        } else {\n            $i++;\n        }\n        $j++;\n    }\n\
    \    return $a;\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", " \
    \   return $b ? gcd($a, $b % $a) : $a;\n}\n", "  return $a - ($a / $b) * $b;\n\
    }\n</code>\n<|/ a dscore=4 |>\n<| c |>\nWhat is the time complexity of this algorithm?\n\
    <|/ c |>\n<| c |>\nIt should be O(log(n)), which means O(log(n))-O(log(n)), which\
    \ means O(log(n)).\n<|/ c |>\n<| c |>\nOops, I thought the O(1) was O(log(n)).\
    \ Anyway, your answer is probably best.\n<|/ c |>\n<| c |>\nFor a smaller number\
    \ you get: \n```", "  return $a % $b;\n}", "    $a_rem = $a%$b;\n    $a = $b-$a_rem;\n\
    \    return $a;\n}\n</code>\n<|/ a |>\n<| c |>\nThat was a great answer thank\
    \ you!\n<|/ c |>\n<| c |>\nAgreed. Greatest common divisor can be done a lot more\
    \ efficiently with bitwise operators.\n<|/ c |>\n<| c |>\nI think you missed the\
    \ return statement at the end\n<|/ c |>\n<| c |>\nNo I did not miss it. I just\
    \ missed it when I copied the code into my answer :P Good catch.\n<|/ c |>\n<|\
    \ a dscore=0 tags=php,algorithm,math |>\nA very efficient way is to use a lookup\
    \ table. PHP has one built in:\n<code>\n$result = $lookupTable[ ($a - $b) / $b\
    \ ];\n</code>\nThe only problem with this is that if the divisor is very large,\
    \ the lookup table would exceed the PHP memory limit.\n<|/ a |>\n<| a tags=php,algorithm,math\
    \ dscore=0 |>\nIf you want the result to be in range [0, 1] you can just do something\
    \ like this where $num is your number:\n<code>\n$min = $num % $divisor;\n$max\
    \ = floor($num/$divisor);\n</code>\nIf you want it to have a minimum you could\
    \ use min() on $min and $max.\n<|/ a |>\n<| a |>\nIf you want your result to be\
    \ in range [0, 1]:\n<code>\n$min = ($num / $divisor) - 0.5;\n$max = ($num / $divisor)\
    \ + 0.5;\n</code>\n<|/ a tags=php,algorithm,math dscore=0 |>\n<| a |>\n<code>",
  "    while ($b != 0) {\n        $tmp = $b;\n        $b = $a % $b;\n        $a =\
    \ $tmp;\n    }\n    return $a;\n}\n", "  if ($a < $b)\n    $a = $b;\n  if ($a\
    \ == 0)\n    return $b;\n  if ($b == 0)\n    return $a;\n  $a = abs($a / $b);\n\
    \  $b = abs($b / $a);\n  $c = $a * $b; // $c = $a * $b / $b\n  return $c;\n}\n\
    \n$i = '15';\n$j = '15';\n$k = '25';\nif (greatest_common_divisor($i, $j) > greatest_common_divisor($k,\
    \ $j)) {\n  $i = $j;\n}\n\n$i = $i - '0';\n$j = $j - '0';\n$k = $k - '0';\n\n\
    if ($i != $k && $j != $k) {\n  echo 'The two numbers are not the same.';\n} else\
    \ {\n  echo 'The two numbers are the same.';\n}\n</code>\n<|/ a dscore=1 tags=php,floating-point,math\
    \ |>\n<| c |>\nThanks. I used the solution in http://stackoverflow.com/questions/2490365/fastest-way-to-test-if-a-number-is-a-fraction-or-not/2490382#2490382\n\
    <|/ c |>\n<| c |>\n- That is very different from the question you linked to -\
    \ that one was asking about fractions as whole numbers. I'm sorry that I didn't\
    \ notice you were talking about whole numbers. The solution in the comment you\
    \ referenced is much better and I'll update my answer accordingly.\n<|/ c |>\n\
    <| a |>\nI'm assuming this is a homework question, but I'll throw it out there\
    \ anyway.\nIf it weren't for rounding errors, the largest integer that could fit\
    \ into a float would be 2^24 - 1, so for float $a = 3.14159265, you wouldn't need\
    \ anything bigger than that. You're just rounding down, so you'll end up with\
    \ $a / $b = 0.14159265.\n<|/ a dscore=0 tags=php,floating-point,math |>\n<| c\
    \ |>\nI don't think so. The largest number that can fit in a float is 2^24. Try\
    \ `var_dump((float)pow(2, 24))` and see for yourself.\n<|/ c |>\n<| c |>\nYou\
    \ only need 2^24 to represent 3.14159265 but not to represent 1/3.\n<|/ c |>\n\
    <| c |>\n`var_dump((float)pow(2, 24));` gives me `float(2.147483647E+18)` on my ",
  "  // See http://en.wikipedia.org/wiki/Euclidean_algorithm\n  // for how to calculate\
    \ the GCD.\n  $m = 1;\n  $n = $a;\n  while ($m != 0) {\n    if ($b & $m) {\n \
    \     $m = $m >> 1;\n    }\n    if ($a & $m) {\n      $n = $n >> 1;\n    }\n \
    \   $a = $a >> 1;\n    $m = $m >> 1;\n  }\n  return $n;\n}\n\n/**\n * Get an absolute\
    \ path to a file.\n *\n * @param string $path Path to the file.\n *\n * @return\
    \ string Full path.\n */", "  for ($i = 0; $i < abs($a - $b); ++$i) {\n    if\
    \ ($a % $i == 0 && $b % $i == 0) {\n      return $i;\n    }\n  }\n\n  return $a;\n\
    }\n", "    $remainder = $a % $b;\n    $quotient = $a / $b;\n    if ($remainder\
    \ === 0) {\n        return $quotient;\n    }\n    return greatest_common_divisor($b,\
    \ $remainder);\n}\n", "  $n = 0;\n  for ($i = 0; $i <= $a; $i++) {\n    if ($b\
    \ % $i == 0) {\n      $n = $i;\n      break;\n    }\n  }\n  return $n;\n}", " \
    \ if ($a === $b) {\n    return $a;\n  }\n  $a = abs($a);\n  $b = abs($b);\n  //\
    \ Make sure that $a is always higher than $b\n  // If $a is smaller than $b, then\
    \ swap them\n  if ($a < $b) {\n    $tmp = $a;\n    $a = $b;\n    $b = $tmp;\n\
    \  }\n  // Set the result to a power of $b\n  $c = pow($b, floor(log($b) / log(2)));\n\
    \  // Divide the two numbers and repeat until $b is no longer a power of two\n\
    \  for (;;) {\n    if ($a % $c === 0) {\n      return $b;\n    }\n    $a = $c\
    \ * $a % $b;\n    $c = pow($b, floor(log($b) / log(2)));\n  }\n}\n", "  // Make\
    \ sure all arguments are integers\n  if (!is_int($a) || !is_int($b)) {\n    throw\
    \ new InvalidArgumentException('Both numbers should be integers');\n  }\n\n  //\
    \ Check if b > a\n  if ($b < $a) {\n    list($b, $a) = array($a, $b);\n  }\n\n\
    \  // If the GCD(a, b) = 1, return a\n  if ($a === 1) {\n    return $a;\n  }\n\
    \n  // If the GCD(a, b) < 1, return the greatest common divisor of a and b\n \
    \ $r = $b;\n  while ($r != 0) {\n    $m = $r % $a;\n    $r = $a;\n    $a = $m;\n\
    \  }\n\n  // Return a\n  return $a;\n}", "\tif ($a < $b) return $b;\n\treturn\
    \ $a;\n}", "    return ($a % $b + ($a / $b) % $b)\n}\n", "  $max_a = $a;\n  $max_b\
    \ = $b;\n  while ($max_b !== 0) {\n    $remainder = $max_a % $max_b;\n    $max_b\
    \ = $b - $remainder;\n    $max_a = $max_b;\n  }\n  return $max_a;\n}", "    if\
    \ ($a < $b) {\n        $temp = $a;\n        $a = $b;\n        $b = $temp;\n  \
    \  }\n    $d = 0;\n    while ($a % $b) {\n        $a = $a - $b;\n        $d =\
    \ $d + 1;\n    }\n    return $d;\n}\n\n/**\n * Return a string with leading zeros\
    \ as appropriate.\n *\n * >>> left_pad(3, 'A', true)\n * '003'\n * >>> left_pad(3,\
    \ 'A')\n * 'A'\n */", "    // Euclid's algorithm to compute GCD\n    // http://en.wikipedia.org/wiki/Euclidean_algorithm\n\
    \    do {\n        $d = $b;\n        $b = $a % $d;\n        $a = $d;\n    } while\
    \ ($a != 0);\n    return $b;\n}\n", "  if ($a < $b) return $a;\n  return $b;\n\
    }\n", "    while ($a && $b) {\n        $temp = $a % $b;\n        $a = $b;\n  \
    \      $b = $temp;\n    }\n    return $b;\n}\n", "    $r = $a % $b;\n    return\
    \ $r ? $r + $b : $b;\n}\n", "  $r = $a % $b;\n  while ($r == 0) {\n    $a = $b;\
    \ // remainder\n    $b = $a % $b;\n    $r = $a % $b;\n  }\n  return $b;\n}\n",
  "    $a = abs($a); $b = abs($b);\n    if ($a > $b) {\n        return $b;\n    }\n\
    \    return $a;\n}\n", "    return $b ? gcd($b, $a) : $a;\n}\n", "    if ($a <\
    \ $b) return $a;\n    if ($a > $b) return $b;\n    // both numbers are equal\n\
    \    if ($a == $b) return $a;\n    // at least one is zero\n    if ($a === 0)\
    \ return $b;\n    // both numbers are negative\n    if ($a < 0 && $b < 0) return\
    \ $a;\n    if ($a < 0 && $b > 0) return $b;\n    // both numbers are positive\n\
    \    if ($a > 0 && $b > 0) return $b;\n    // no numbers are common divisors\n\
    \    if ($a > $b) return $b;\n    return $a;\n}\n", "    return abs($a / gcd($a,\
    \ $b)) - abs($b / gcd($a, $b));\n}\n\n/**\n * Return the sum of the absolute differences\
    \ between two numbers.\n * @param  integer $a The first number\n * @param  integer\
    \ $b The second number\n * @return integer The sum of the absolute differences\
    \ between the two numbers\n */", "  $tmp = $a % $b;\n  while ($tmp != 0) {\n \
    \   $tmp = $a % $b;\n    $a = $b;\n    $b = $tmp;\n  }\n  return $b;\n}", "  \
    \  return $b % $a ? greatest_common_divisor($b, $a % $b) : $a;\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nThanks for the code!  I did notice that the first example (which\
    \ I used anyway) returned a number that didn't divide evenly into $a, which was\
    \ ok in my case since I only needed the smallest factor.  For anyone who is interested,\
    \ I used this as a starting point: http://www.php.net/manual/en/function.gcd-inverse.php#110372\n\
    <|/ c |>\n<| c |>\nThe first example is wrong. `greatest_common_divisor(1, 3)`\
    \ returns `1`, not `3`.\n<|/ c |>\n<| c |>\nThis also fails on `greatest_common_divisor(32,\
    \ 7)` which should return `1`.\n<|/ c |>\n<| a dscore=5 |>\n<code>", "    if ($a\
    \ % $b) {\n        return $b;\n    }\n    return $a;\n}\n", "  $rem = $a % $b;\n\
    \  if ($rem == 0) return $b;\n  else return $rem + greatest_common_divisor($b,\
    \ $rem);\n}\n", "  $r = $a % $b;\n  $remainder = $b - $r;\n  \n  while($a != 0)\
    \ {\n    if ($r == 0) {\n      return $a;\n    }\n    \n    $a = $a - $b;\n  \
    \  $r = $r % $a;\n    $remainder = $remainder % $a;\n  }\n  \n  return $remainder;\n\
    }\n", "  $reminder = $a % $b;\n  if ($reminder == 0) return $b;\n  else if ($reminder\
    \ > 0) return greatest_common_divisor($b, $a % $b);\n  else return greatest_common_divisor($b,\
    \ $b);\n}\n", "  if ($a == 0)\n    return $b;\n  if ($b == 0)\n    return $a;\n\
    \  if ($a < 0)\n    $a = -$a;\n  if ($b < 0)\n    $b = -$b;\n  do {\n    $x =\
    \ ($a % $b);\n    if ($x == 0)\n      return $b;\n    $a = $b;\n    $b = $x;\n\
    \  } while ($a != 1);\n  return $b;\n}\n", "    return abs(a) % ($a + b) > abs(b)\
    \ ? ($a + b) : abs(a) % ($a + b);\n}\n</code>\nThe function returns the greatest\
    \ common divisor, or the absolute value of $a modulo abs($a) + abs($b).\n<|/ a\
    \ tags=arrays,php |>\n<| c |>\n`abs` here is totally useless. You can just compare\
    \ it with `$a`.\n<|/ c |>\n<| c |>\nI wrote this answer 3 years ago and I didn't\
    \ remember when I was using php so I rewrited it and I forgot to remove that `abs`.\n\
    <|/ c |>\n<| c |>\n`abs` might be useless but it's not useless. You should use\
    \ it instead of `if` statements everywhere, because it would make your code clearer.\
    \ You're better off with it.\n<|/ c |>\n<| c |>\nI totally agree about uselessness,\
    \ I just wrote it after my first php and I forgot to remove it. I added it now\
    \ to my answer.\n<|/ c |>\n<| c |>\n: I agree about uselessness. I added it to\
    \ my answer because I forgot to remove it when I was using php. It's my own mistake\
    \ because I wrote it when I was learning php and I forgot that `abs` is useless.\
    \ Thanks.\n<|/ c |>\n<| a |>\nUsing array_filter() you can filter out the empty\
    \ values and then use array_sum() to get the sum of the values.\n<code>\n$array\
    \ = [1, \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"\
    , \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"\
    , \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"\
    , \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"\
    , \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"\
    , \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"\
    , \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"\
    , \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"\
    , \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"\
    , \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"\
    , \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"\
    , \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"\
    , \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"\
    , \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"\
    , \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"\
    , \"\", \"\", \"\", \"\", \"\", \"\", \"\", ", "    // http://en.wikipedia.org/wiki/Euclidean_algorithm\n\
    \    // gcd(a, b) == abs(a * b) ? (a & -b) * (b - a) : (a & b) * (b - a) + ((a\
    \ ^ b) >> 1)\n    // We use the following property to find the greatest common\
    \ divisor:\n    // gcd(a, b) == abs(a * b) ? (a & -b) * (b - a) <==> abs(a) *\
    \ abs(b) <==> abs(a * b) <==> gcd(a, b)\n    $a = abs($a);\n    $b = abs($b);\n\
    \    $gcd = ($a & $b) ?\n        ($a & $b ?\n            ($a ^ $b) :\n       \
    \     $a >> 1) :\n        (($a ^ $b) >> 1);\n    // If $gcd === 0, it means $a\
    \ is equal to $b.\n    return $gcd === 0 ? $a : max($gcd, $b);\n}", "  // If the\
    \ numbers are the same, return them directly\n  if ($a === $b)\n    return $a;\n\
    \  // If the numbers are different, find greatest common divisor\n  return $a\
    \ > $b ? $a : gcd($b, $a%$b);\n}", "  return !is_int($a) || !is_int($b) ? 0 :\
    \ ($a < $b) ? $b : $a;\n}", "    $lcm = $a % $b;\n    if ($lcm == 0) {\n     \
    \   return $b;\n    }\n    return $lcm;\n}\n\n/**\n * Find the most common word\
    \ in an array\n */", "  if ($a == 0) return $b; // Common case: two non-zero integers\n\
    \  if ($b == 0) return $a; // Common case: two non-zero integers\n  if ($a < $b)\
    \ return greatest_common_divisor($b, $a); // Make sure that $a >= $b\n  // Find\
    \ the highest common divisor of a and b:\n  $gcd = 0;\n  $a = abs($a);\n  $b =\
    \ abs($b);\n  for ($i = 0; $i < $a; $i++) {\n    $gcd = max($gcd, $i);\n    for\
    \ ($j = $i + 1; $j < $b; $j++) {\n      $gcd = max($gcd, $j);\n    }\n  }\n  return\
    \ $gcd;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nHere's my solution to\
    \ finding the Greatest Common Divisor of any two numbers (including 0). It also\
    \ works for negative numbers by using the pow() function, and checking if the\
    \ first number is greater than 0.\n<code>", "    // Using Euclid's algorithm\n\
    \    if ($a === 0) {\n        return $b;\n    } elseif ($b === 0) {\n        return\
    \ $a;\n    }\n\n    $x = $a; $y = $b;\n    $d = 1;\n\n    while ($x != 0) {\n\
    \        if ($y % $x == 0) {\n            $y = $x / $x;\n            $d = $d +\
    \ 1;\n        } else {\n            $x = $x * $x / $y;\n        }\n    }\n\n \
    \   return $d;\n}", "    $r = $b;\n    while ($r > 0 && !($r&1)) {\n        $r\
    \ = $a % $r;\n    }\n    return $r;\n}\n", "  // Make sure that $a is always a\
    \ positive integer\n  if (!is_numeric($a)) {\n    $a = intval($a);\n  }\n  //\
    \ Make sure that $b is always a positive integer\n  if (!is_numeric($b)) {\n \
    \   $b = intval($b);\n  }\n  if ($a < 0 || $b < 0) {\n    return null;\n  }\n\n\
    \  $gcd = $b;\n  $r = $a % $gcd;\n  while ($r != 0) {\n    $gcd = $gcd-1;\n  \
    \  $r = $a % $gcd;\n  }\n  return $gcd;\n}\n", "    if (!is_int($a) || !is_int($b))\
    \ {\n        throw new \\InvalidArgumentException('Parameters must be a whole\
    \ numbers');\n    }\n\n    // if zero, return zero\n    if ($a === 0) {\n    \
    \    return 0;\n    }\n\n    if ($b === 0) {\n        return $a;\n    }\n\n  \
    \  // find least common divisor\n    $r = $b;\n    while (true) {\n        if\
    \ ($r % $a === 0) {\n            return $r;\n        }\n        $r += 1;\n   \
    \ }\n}\n", "    $a = intval($a);\n    $b = intval($b);\n    $a = $a % $b; // Remainder\n\
    \    return $b;\n}\n", "    $p = 1;\n    $q = 1;\n    while($a%$b !== 0 || $b%$a\
    \ !== 0)\n    {\n        $p = $q;\n        $q = ($q*$b + $a%$b)/($b+$a);\n   \
    \ }\n    return $q;\n}\n", "  // http://en.wikipedia.org/wiki/Euclidean_algorithm\n\
    \  // http://stackoverflow.com/a/7602919\n  if($a < 0 || $b < 0) {\n    throw\
    \ new InvalidArgumentException('The greatest_common_divisor function requires\
    \ positive integers');\n  }\n\n  $a = abs($a);\n  $b = abs($b);\n  if ($a ===\
    \ 0) {\n    if ($b === 1) {\n      return 1;\n    }\n\n    return $b;\n  }\n\n\
    \  if ($b === 0) {\n    return $a;\n  }\n\n  $r = $a%$b;\n  if ($r === 0) {\n\
    \    return $b;\n  }\n  return $r;\n}\n", "    return !$b\n        ? $a\n    \
    \    : $a % $b ? greatest_common_divisor($a, $b / $a) : $b;\n}", "    $tmp = 0;\n\
    \    while ($a > $b) {\n        $tmp = $b;\n        $b = $a;\n        $a = $tmp;\n\
    \    }\n    return $a;\n}", "    $div = $a / $b;\n    $remainder = $a % $b;\n\
    \    while ($remainder != 0) {\n        if ($remainder == $div) {\n          \
    \  return $div;\n        } else {\n            $div += $remainder;\n        }\n\
    \        $remainder = $a % $b;\n    }\n    return $div;\n}\n</code>\n<|/ a dscore=1\
    \ tags=php,arrays,recursion |>\n<| c |>\nIt doesn't work when $a = 1 and $b =\
    \ 5, because $a is divisible by $b, so $a is divisible by $a too!\n<|/ c |>\n\
    <| c |>\nIt's working fine for me with values `1` and `5`.\n<|/ c |>\n<| c |>\n\
    Thanks, I modified it slightly, but your answer is perfect. Thanks again!\n<|/\
    \ c |>\n<| c |>\n, your `greatest_common_divisor` function is wrong, when `$a\
    \ = 5` and `$b = 5`, it returns `1` instead of `1`. Your `greatest_common_divisor`\
    \ function is not recursive.\n<|/ c |>\n<| a tags=php,arrays,recursion |>\nIf\
    \ $a and $b are positive, you can use Euclid's algorithm:\n<code>", "  $a = abs($a);\
    \ // Necessary since abs() returns a float\n  $b = abs($b);\n  // Initializing\n\
    \  $gcd = 0;\n  $max = $a;\n  $min = $b;\n  // Checking if b is larger than a\n\
    \  while($a != 0) {\n    // Subtracting b from a until it is smaller than a\n\
    \    $temp = $a % $b; // Remainder of a/b\n    $a = $b;           // Updating\
    \ a\n    $b = $temp;         // Updating b\n  }\n  // Checking if b is smaller\
    \ than a\n  while($b != 0) {\n    // Adding b to a until it is larger than a\n\
    \    $temp = $b % $a; // Remainder of b/a\n    $a = $b;           // Updating\
    \ a\n    $b = $temp;         // Updating b\n  }\n  // Returning the greatest common\
    \ divisor\n  return $gcd;\n}", "  if ($a < $b) {\n    $a = $b;\n    $b = $a;\n\
    \  }\n  return $b % $a;\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis is actually\
    \ what I've been using. I'll just wait and see if someone else can come up with\
    \ a function that does this mathematically and isn't O(logN), but I doubt it,\
    \ and if they do I'll accept your answer. Thanks! :)\n<|/ c |>\n<| c |>\n: It\
    \ doesn't seem to be O(logN), but at least it's O(N).  You don't actually have\
    \ to find the greatest common divisor; you can find the greatest common divisor\
    \ of _n_ numbers and then apply the O(logN) algorithm to that.\n<|/ c |>\n<| c\
    \ |>\nHmm... So you have a loop and `sqrt($a)` each time, right?\n<|/ c |>\n<|\
    \ c |>\n: No, that's just one trial.\n<|/ c |>\n<| c |>\nI figured it out. Thanks!\
    \ :)\n<|/ c |>\n<| a dscore=2 |>\nYou can use PHP's gmp_init() and gmp_div_qr().\
    \ These functions will take care of most of the math stuff for you:\n<code>\n\
    <?php", "    return abs($a) > abs($b) ? abs($a) : abs($b);\n}\n", "    return\
    \ ($a < $b) ? $a : ($b > $a) ? $b : $a;\n}\n", "    if (!is_int($a) || !is_int($b))\
    \ {\n        return false;\n    }\n\n    $r = $a % $b;\n    if ($r == 0) {\n \
    \       return $b;\n    }\n\n    return $r;\n}\n", "\t$r = $a % $b;\n\tif ($r\
    \ == 0) {\n\t\treturn $b;\n\t} else {\n\t\treturn $r;\n\t}\n}\n", "    $r = $a\
    \ % $b;\n    $remainder = $b - $r;\n    if ($remainder === 0) {\n        return\
    \ $r;\n    }\n    return $greatest_common_divisor($b, $remainder);\n}", "    $gcd\
    \ = 0;\n    if ($a < 0 && $b <= 0) {\n        return $a;\n    } elseif ($a < 0)\
    \ {\n        $a = -$a;\n        $b = -$b;\n    }\n    while (1) {\n        if\
    \ (($a % $b) == 0) {\n            $gcd = $b;\n            $b = $a / $b;\n    \
    \    } else {\n            $a = $a / $b;\n        }\n        if ($gcd) {\n   \
    \         break;\n        }\n    }\n    return $gcd;\n}\n", "    if ($a == 0)\
    \ return $b;\n    if ($b == 0) return $a;\n    if ($a < $b) return greatest_common_divisor($b,\
    \ $a);\n    $a = $a - $b;\n    return greatest_common_divisor($b, $a) - 1;\n}\n",
  "    while ($a % $b) {\n        $a = $b;\n        $b = $a % $b;\n    }\n    return\
    \ $b;\n}", "    $a = abs($a); $b = abs($b);\n    $result = $a;\n    while ($a\
    \ && $b) {\n        if ($a > $b) { $a = $a - $b; } else { $b = $b - $a; }\n  \
    \      $result = $result % $b;\n    }\n    return $result;\n}\n</code>\n<|/ a\
    \ dscore=5 |>\n<| c |>\n+1 for the mathematical approach to solving the problem,\
    \ but this question was about a PHP-only solution.\n<|/ c |>\n<| c |>\nAgreed.\
    \ However this solution does work. At least for PHP 5.4 under x64, where I'm testing\
    \ it.\n<|/ c |>\n<| c |>\nGreat solution! To my eye this is much more readable\
    \ than using `gcd()` from math.h.\n<|/ c |>\n<| c |>\n+1 for the mathematical\
    \ approach, but I really dislike the use of globals. I would prefer an inline\
    \ function instead. I'll refactor this answer if anyone posts it. Also, thanks\
    \ for posting the solution! I was wondering if it would be possible to get the\
    \ same functionality without using globals :)\n<|/ c |>\n<| c |>\nI like it. I\
    \ just tried this on an empty script on my hosting server, and it works fine.\
    \ Thanks!\n<|/ c |>\n<| a |>\nUse the following code:\n<code>\n<?php\n", "   \
    \ if ($a % $b !== 0) {\n        return $b;\n    }\n\n    return gcd($a, $b);\n\
    }\n", "    $r = $a % $b;\n    while ($r == 0)\n        $r = $a % --$b;\n    return\
    \ $b;\n}\n", "    if ($a < $b) $a = $b, $b = $a;\n    do {\n        $r = $a %\
    \ $b;\n        $a = $b;\n        $b = $r;\n    } while ($a != 0);\n    return\
    \ $b;\n}", "    return ($a % $b) / gcd($a, $b);\n}\n", "    $a = abs($a); $b =\
    \ abs($b);\n    $r = $b;\n    while ($a != 0) {\n        $r = $a % $b;\n     \
    \   $a = $b;\n        $b = $r;\n    }\n    return $b;\n}", "    if ($a < $b) {\n\
    \        $tmp = $a;\n        $a = $b;\n        $b = $tmp;\n    }\n    while ($a\
    \ % $b == 0) {\n        $a = floor($a / $b);\n        $b--;\n    }\n    return\
    \ $a;\n}\n\n$a = 3;\n$b = 5;\n$c = greatest_common_divisor($a, $b);\nvar_dump($c);\
    \ // 1\n", "    return $a % $b ? $a + greatest_common_divisor($b, $a % $b) : $b;\n\
    }\n", "  if ($a % $b == 0) {\n    return $b;\n  } else {\n    return gcd($b, $a\
    \ % $b);\n  }\n}\n", "  // Make sure both integers are integers\n  // By \"integer\"\
    , we mean integer that is an integer\n  // or something that can be coerced into\
    \ one\n  $a = (int) $a;\n  $b = (int) $b;\n\n  // Handle the case of a and b being\
    \ equal\n  if ($a === $b) {\n    return $a;\n  }\n\n  // If the values are equal,\
    \ then return a and b are relatively prime\n  if ($a === 0) {\n    return $b;\n\
    \  }\n\n  // If b is 0, then return a\n  if ($b === 0) {\n    return $a;\n  }\n\
    \n  // If a is greater than b, then a is relatively prime\n  // If b is greater\
    \ than a, then b is relatively prime\n  // If a is less than b, then b is relatively\
    \ prime\n  // If a = 0, then return b\n  if ($a > $b) {\n    return $a;\n  }\n\
    \n  return $b;\n}\n", "    $remainder = 0;\n    $i = 0;\n    while ($a % $b !==\
    \ 0 && $i < $b) {\n        $remainder = $b;\n        $b = $a % $b;\n        $a\
    \ = $b;\n        $i++;\n    }\n    return $remainder;\n}\n</code>\n<|/ a tags=math,php\
    \ |>\n<| c |>\nHow does this return the greatest common divisor? This seems to\
    \ return the smallest common divisor.\n<|/ c |>\n<| a tags=math,php dscore=1 |>\n\
    <code>", "  $remainder = $a % $b;\n  if ($remainder == 0)\n    return $b;\n  elseif\
    \ ($remainder < 0)\n    return greatest_common_divisor($b, $remainder);\n  else\n\
    \    return greatest_common_divisor($remainder, $b);\n}\n</code>\n<|/ a |>\n<|\
    \ a dscore=0 tags=php,number-theory,math,numbers |>\nThe number in the question\
    \ is too large and PHP will throw a Floating point overflow  error.\nHere is another\
    \ version that also works with negative numbers.\n<code>", "    $q = $a / $b;\n\
    \    $r = $q % $a;\n    while ($r === 0) {\n        $r = $q % $b;\n        $q\
    \ = $q / $b;\n    }\n    return $q;\n}\n", "    $m = 0;\n    $n = 1;\n    while\
    \ (1) {\n        if ($a % $n == 0 && $b % $n == 0) {\n            $m = $n;\n \
    \       }\n        if ($n % $n == 0) {\n            return $n;\n        }\n  \
    \      $n = $n * (int) ($a / $n);\n    }\n    return $m;\n}", "  $c = $d = 0;\n\
    \  while (true) {\n    if ($a != 0) {\n      if ($b % $a === 0) {\n        $b\
    \ = $b / $a;\n        $c++;\n      }\n    }\n    if ($b == 0) {\n      break;\n\
    \    }\n    $a--;\n  }\n  return $c;\n}\n", "    if ($a === 0 || $b === 0) {\n\
    \        return 0;\n    }\n\n    $r = $a % $b;\n    $num_divisors = $b;\n\n  \
    \  while (!(is_int($r) && $r >= $a && $r % $a === 0)) {\n        $num_divisors--;\n\
    \        $r = ($a % $num_divisors) + $b;\n    }\n\n    return $num_divisors;\n\
    }\n", "    // http://en.wikipedia.org/wiki/Euclidean_algorithm\n    // http://math.stackexchange.com/questions/12211/how-do-you-calculate-greatest-common-divisor-of-large-numbers\n\
    \    $gcd = ($a % $b == 0) && ($a > 0) ?\n        (int)$a / $b : (greatest_common_divisor($b,\
    \ $a % $b));\n    // print \"GCD of $a and $b is $gcd\\n\";\n    return $gcd;\n\
    }\n</code>\n<|/ a tags=laravel,laravel-5,php |>\n<| a |>\nI made a function for\
    \ the same, It works for me :\n<code>", "  $r = 1;\n  while ($a & $b) {\n    $r\
    \ = ($r << 1) | ($a & $b); // shift the larger one down\n    $a = $a >> 1; //\
    \ mask & shift down\n    $b = $b >> 1; // mask & shift down\n  }\n  return $r;\n\
    }\n", "    $gcd = 0;\n    while ($a && $b) {\n        if ($a > $b) {\n       \
    \     $a = $a % $b;\n        } else {\n            $b = $b % $a;\n        }\n\
    \        $gcd = ($gcd) ? $gcd + 1 : 1;\n    }\n    return $gcd;\n}\n</code>\n\
    <|/ a dscore=2 tags=division,php,algorithm |>\n<| c |>\nYes, you are right, but\
    \ my code was a proof of concept to better my understanding of algorithms and\
    \ mathematics. I wasn't looking to actually code this function.\n<|/ c |>\n<|\
    \ c |>\nThe algorithm is incorrect, `greatest_common_divisor(5,3)` should return\
    \ 1 but returns 0\n<|/ c |>\n<| a dscore=1 |>\nHere is a simple solution based\
    \ on recursive function and using mathematical induction:\n<code>", "    while\
    \ ($b != 0) {\n        if ($a % $b == 0) {\n            return $b;\n        }\n\
    \        $a = $b % $a;\n    }\n    return 0;\n}\n", "    if ($a == 0 || $b ==\
    \ 0) {\n        return 0;\n    }\n    return ($a % $b == 0) ? $b : ($a / $b) +\
    \ 1;\n}\n", "  $gcm = 0;\n  if ($a == 0 || $b == 0) {\n    return 0;\n  }\n  if\
    \ ($a < $b) {\n    $a = $b;\n    $b = $a;\n  }\n  while ($a > $b) {\n    $a =\
    \ $a - $b;\n    $gcm++;\n  }\n  return $gcm;\n}\n", "    // $a / $b -> $q\n  \
    \  $q = 0;\n    $r = $a%$b;\n    while($b!=0){\n        $t = $b;\n        $b =\
    \ $r%$t;\n        $q += $t;\n    }\n    return $q;\n}\n</code>\n<|/ a |>\n<| a\
    \ tags=php,algorithm |>\n<code>\n<?php\n/**\n * Greatest Common Divisor function\n\
    \ *\n * integer $a First number to be divided.\n * integer $b Second number to\
    \ be divided.\n * integer $c Return value to be returned. 0 will be returned if\
    \ division can't be done.\n */", "    for ($i = 1;$i <= $b;$i++) {\n        if\
    \ ($a % $i == 0 && $b % $i == 0) {\n            $j = (int) ($i / $a);\n      \
    \      return $j * ($b / $a);\n        }\n    }\n    return 1;\n}\n", "    if\
    \ ($a < $b) {\n        $a = $b;\n    }\n    if ($a % $b) {\n        $a = $a %\
    \ $b;\n    }\n    return $a;\n}\n", "    while ($a && $b) {\n        if ($a >\
    \ $b) {\n            $a = $a % $b;\n        } else {\n            $b = $b - $a\
    \ % $b;\n        }\n    }\n    return $a;\n}\n", "  $a = abs($a);\n  $b = abs($b);\n\
    \  $tmp = $a % $b;\n  if ($a == 0)\n    return abs($b);\n  else if ($b == 0)\n\
    \    return abs($a);\n  else\n    return $tmp == 0 ? $b : $a;\n}", "    return\
    \ $b ? ltrim(str_repeat('1', ceil($a / $b)), '1') : 1;\n}", "    // Return the\
    \ greatest common divisor\n    // of two integers a and b\n    // >>> greatest_common_divisor(9,\
    \ 3)\n    // 3\n    // >>> greatest_common_divisor(12, 3)\n    // 6\n    // >>>\
    \ greatest_common_divisor(125, 12)\n    // 10\n\n    // Handle edge cases:\n \
    \   if ($a == 0)\n        return $b;\n    if ($b == 0)\n        return $a;\n\n\
    \    // Euclid's algorithm\n    // https://en.wikipedia.org/wiki/Euclidean_algorithm\n\
    \    $gcd = $b;\n    for ($i = 1; $i <= $a; $i++)\n        $gcd = ($gcd * $i)\
    \ % $b;\n    return $gcd;\n}\n", "  return !($a % $b) ? $a / $b : greatest_common_divisor($b,\
    \ $a % $b);\n}\n", "    if ($a < $b) {\n        return $a;\n    }\n    return\
    \ $b;\n}\n", "    if ($a < $b) {\n        $tmp = $b;\n        $b = $a;\n     \
    \   $a = $tmp;\n    }\n\n    while (b != 0) {\n        $r = $a % b;\n        $a\
    \ = b;\n        b = $r;\n    }\n\n    return $a;\n}\n", "  $d = $a%$b;\n  while($d\
    \ > 0) {\n    $a = $b;\n    $b = $d;\n    $d = $a%$b;\n  }\n  return $b;\n}\n",
  "  if ($a == 0)\n    return $b;\n  if ($b == 0)\n    return $a;\n  if ($a > $b)\n\
    \    return greatest_common_divisor($b, $a);\n  $div = bcdiv(bcmod($a, $b), $a,\
    \ 0);\n  if ($div == 0)\n    return $b;\n  return greatest_common_divisor($b,\
    \ $div);\n}\n", "  $div = abs(($a % $b) / $b);\n  return $a if $div == 0;\n  return\
    \ gcd($a, $b);\n}\n", "    if ($a < b) {\n        $temp = $b;\n        $b = $a;\n\
    \        $a = $temp;\n    }\n\n    $r = $a;\n    $d = 1;\n    while ($d < $b)\
    \ {\n        $t = $r / $d;\n        $r -= $d * $t;\n        $d += 1;\n    }\n\
    \    return $r;\n}\n</code>\n<|/ a |>\n<| c |>\nThanks for your efforts, it helped\
    \ me a lot.\n<|/ c |>\n<| c |>\nI didn't know it was that easy, but this is definitely\
    \ what I was looking for. Thanks again.\n<|/ c |>\n<| c |>\nYeah if your question\
    \ was answered, you can mark it as the correct answer! Glad I could help :)\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>", "    return !$a || !$b\n        ? 0\n   \
    \     : $a % $b === 0\n            ? $b\n            : greatest_common_divisor($b,\
    \ $a % $b);\n}\n</code>\n<|/ a dscore=4 tags=php,math |>\n<| a dscore=4 tags=php,math\
    \ |>\nYou can do it with PHP by casting to an int.\n<code>\n$int1 = (int)($input1\
    \ / $input2) * 100;\n$int2 = (int)($input2 / $input1) * 100;\n</code>\n<|/ a |>\n\
    <| a dscore=4 |>\n<code>\n$int1 = $input1 / $input2;\n$int2 = $input2 / $input1;\n\
    \n$percentage = ($int1 * 100) / $int2;\n</code>\n<|/ a tags=php,math |>\n<| a\
    \ tags=php,math |>\n<code>\n$percentage = $int1 * 100 / $int2;\n</code>\n<|/ a\
    \ dscore=3 |>\n<| a dscore=3 |>\n<code>", "    $g = max($a, $b);\n    while($a\
    \ % $g == 0 && $b%$g == 0) {\n        $g = max($g, $b);\n    }\n    return $g;\n\
    }\n</code>\n<|/ a tags=php,algorithm |>\n<| c |>\nI think it's unfair to judge\
    \ an answer based on the number of downvotes.\n<|/ c |>\n<| c |>\nIt was my opinion\
    \ that he was looking for something that would return an int rather than a fraction,\
    \ and that this would not do that. I didn't downvote it because I personally didn't\
    \ think it was fair, however I suspect that my answer is far more general than\
    \ what was requested.\n<|/ c |>\n<| a dscore=0 |>\nIt seems that you want the\
    \ greatest common divisor between two numbers (and not just any number), so the\
    \ following function should work:\n<code>\n<?php", "    $n = abs($b);\n    $d\
    \ = abs($a);\n    while ($d != 0) {\n        if ($d == $n) {\n            return\
    \ $d;\n        }\n        $n = $n / $d;\n        $d = $d / $d;\n    }\n    return\
    \ 1;\n}\n", "    $a = abs($a); // Coerce to a positive number\n    $b = abs($b);\
    \ // Coerce to a positive number\n\n    // If the divisor is zero, return zero\n\
    \    if ($b == 0) {\n        return 0;\n    }\n\n    // If the divisor is one,\
    \ return one\n    if ($b == 1) {\n        return $a;\n    }\n\n    // If the divisor\
    \ is even, return the minimum of the two divisors\n    if ($b % 2 == 0) {\n  \
    \      return min($a, $b);\n    }\n\n    // If the divisor is odd, return the\
    \ maximum of the two divisors\n    return max($a, $b);\n}\n</code>\n<|/ a tags=php\
    \ |>\n<| c |>\nGreat answer, but `abs($b)` is redundant; it will just be converted\
    \ back to positive anyway.\n<|/ c |>\n<| c |>\nThe abs function is not redundant,\
    \ it prevents overflow. The abs function is used to get a positive number without\
    \ overflow. Otherwise it could return negative numbers.\n<|/ c |>\n<| a tags=php\
    \ dscore=0 |>\nA recursive version which does not use $max\n<code>", "    if ($a\
    \ < $b) return $a;\n    else return $b;\n}", "    return ($a % $b + (($a < $b\
    \ ? 1 : 0) * abs($b)) % $b)\n}\n", "  // Check for negatives\n  $aAbs = abs($a)\n\
    \  $bAbs = abs($b)\n  if (($aAbs < $bAbs) ||\n      ($aAbs == $bAbs && ($a < 0\
    \ && $b < 0)) ||\n      ($aAbs == $bAbs && ($a > 0 && $b > 0))) {\n    die('Wrong\
    \ input. Try again.');\n  }\n  // If both are positives, return minimum\n  $c\
    \ = $aAbs < $bAbs ? $a : $b;\n  while (true) {\n    $r = $a % $c;\n    $a = $c;\n\
    \    $c = $b;\n    $b = $r;\n    if (!$b) {\n      break;\n    }\n  }\n  return\
    \ $c;\n}", "    // Only works with integers.\n    if ($a % $b == 0) {\n      \
    \  return $b;\n    }\n    else {\n        return $b % $a;\n    }\n}", "\tif ($a\
    \ == 0) return $b;\n\tif ($b == 0) return $a;\n\tif ($a < $b) return greatest_common_divisor($b,\
    \ $a);\n\treturn ($a % $b) == 0 ? $a : greatest_common_divisor($b, $a % $b);\n\
    }"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
