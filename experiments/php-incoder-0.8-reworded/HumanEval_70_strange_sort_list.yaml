name: HumanEval_70_strange_sort_list
language: php
prompt: "<?php\n// Given array of integers, return array in strange order.\n// Strange\
  \ sorting, is when you start with the minimum value,\n// then maximum of the remaining\
  \ integers, then minimum and so on.\n// Examples:\n// >>> strange_sort_list(array(1,\
  \ 2, 3, 4))\n// array(1, 4, 2, 3)\n// >>> strange_sort_list(array(5, 5, 5, 5))\n\
  // array(5, 5, 5, 5)\n// >>> strange_sort_list(array())\n// array()\nfunction strange_sort_list($lst)\
  \ {\n"
tests: "function candidate(...$args) {\n    return strange_sort_list(...$args);\n\
  }\n\nfunction test(): void {\n    if (candidate(array(1, 2, 3, 4)) !== array(1,\
  \ 4, 2, 3)) { throw new Exception(\"Test failed!\"); }\n    if (candidate(array(5,\
  \ 6, 7, 8, 9)) !== array(5, 9, 6, 8, 7)) { throw new Exception(\"Test failed!\"\
  ); }\n    if (candidate(array(1, 2, 3, 4, 5)) !== array(1, 5, 2, 4, 3)) { throw\
  \ new Exception(\"Test failed!\"); }\n    if (candidate(array(5, 6, 7, 8, 9, 1))\
  \ !== array(1, 9, 5, 8, 6, 7)) { throw new Exception(\"Test failed!\"); }\n    if\
  \ (candidate(array(5, 5, 5, 5)) !== array(5, 5, 5, 5)) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(array()) !== array()) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(array(1, 2, 3, 4, 5, 6, 7, 8)) !== array(1,\
  \ 8, 2, 7, 3, 6, 4, 5)) { throw new Exception(\"Test failed!\"); }\n    if (candidate(array(0,\
  \ 2, 2, 2, 5, 5, -5, -5)) !== array(-5, 5, -5, 5, 0, 2, 2, 2)) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(array(111111)) !== array(111111)) { throw\
  \ new Exception(\"Test failed!\"); }\n}\n\ntest();"
completions: ["    if (!$lst) {\n        return array();\n    }\n\n    // Sort all\
    \ items in list\n    $sorted = $lst;\n    sort($sorted, SORT_NUMERIC);\n\n   \
    \ // First item in list\n    $first = array_shift($sorted);\n\n    // Find max\
    \ of remaining items\n    $max = max($sorted);\n\n    // Put first item at end\n\
    \    $sorted = array_merge(array($first), $sorted);\n\n    // Put max item at\
    \ beginning\n    $sorted = array_merge(array($max), $sorted);\n\n    return $sorted;\n\
    }\n</code>\nThis way you can easily get all items in the order you want.\n<|/\
    \ a dscore=2 |>\n<| a |>\nTry this \n<code>\n    <?php\n    function strange_sort_list($lst)\
    \ {\n    if (!$lst) {\n        return array();\n    }\n\n    // Sort all items\
    \ in list\n    $sorted = $lst;\n    sort($sorted, SORT_NUMERIC);\n\n    // First\
    \ item in list\n    $first = array_shift($sorted);\n\n    // Find max of remaining\
    \ items\n    $max = max($sorted);\n\n    // Put first item at end\n    $sorted\
    \ = array_merge(array($first), $sorted);\n\n    // Put max item at beginning\n\
    \    $sorted = array_merge(array($max), $sorted);\n\n    return $sorted;\n}\n\n\
    $arr=array(1, 2, 3, 4);\n$arr=strange_sort_list($arr);\nprint_r($arr);\n</code>\n\
    <|/ a tags=php,arrays,sorting,algorithm dscore=1 |>\n<| a |>\n<code>", "    if\
    \ (empty($lst)) {\n        return array();\n    }\n    asort($lst);\n    $sorted\
    \ = array();\n    foreach ($lst as $key => $value) {\n        $sorted[$key] =\
    \ $value;\n    }\n    return $sorted;\n}\n\n/**\n * Converts decimal numbers to\
    \ binary (base-2 binary).\n * Returns base-10 binary number in string.\n * For\
    \ example str2b(\"10010\") returns \"1000110\".\n *\n * @param string $s\n *\n\
    \ * @return string\n */", "    foreach ($lst as $key => $value) {\n        for\
    \ ($i = $key; $i < count($lst); $i++) {\n            if ($lst[$i] < $lst[$key])\
    \ {\n                $tmp = $lst[$i];\n                $lst[$i] = $lst[$key];\n\
    \                $lst[$key] = $tmp;\n            }\n        }\n    }\n    return\
    \ $lst;\n}", "  // We do not sort empty list, return as is.\n  if (empty($lst))\
    \ {\n    return $lst;\n  }\n\n  // Create array of unsorted numbers.\n  $unsorted\
    \ = array();\n  foreach ($lst as $num) {\n    $unsorted[] = $num;\n  }\n\n  //\
    \ Sort array of numbers.\n  natsort($unsorted);\n\n  // Create array of sorted\
    \ by numbers list.\n  $sorted = array();\n  foreach ($unsorted as $num) {\n  \
    \  $sorted[] = $num;\n  }\n\n  return $sorted;\n}\n", "  $sorted_lst = array();\n\
    \  for ($i = 0, $n = count($lst); $i < $n; ++$i) {\n    // The first time through\
    \ the loop, we're setting $key to the current value of $i\n    $key = array_search($i,\
    \ $lst);\n    // If the key is in the $sorted_lst, then $i is already in the $sorted_lst.\n\
    \    if ($key !== false) {\n      $sorted_lst[$key] = $lst[$i];\n    } else {\n\
    \      // If the key is not in the $sorted_lst, then $i is greater than the maximum\n\
    \      // value of the remaining $lst values.\n      // So we replace $i with\
    \ $i + 1.\n      $sorted_lst[] = $lst[$i + 1];\n      // Then we add $i to the\
    \ $sorted_lst.\n      $sorted_lst[] = $lst[$i];\n    }\n  }\n  return $sorted_lst;\n\
    }\n</code>\n<|/ a dscore=2 tags=sorting,algorithm,php |>\n<| a dscore=2 |>\n<code>\n\
    <?php\n$array = array(1, 2, 3, 4);\n$min = array_reduce($array, 'min');\n$max\
    \ = array_reduce($array, 'max');\n$min = ($min === $max) ? 0 : $min;\nreturn array_flip(array_flip($array)\
    \ + array($min + $max + 1))\n</code>\n<|/ a tags=sorting,algorithm,php |>\n<|\
    \ c |>\nOops, I forgot the `$max = array_reduce($array, 'max');` line. Edited.\n\
    <|/ c |>\n<| c |>\nThis is nice, but it only returns the array with the lowest\
    \ and highest values, not the sorted values.\n<|/ c |>\n<| a dscore=1 tags=sorting,algorithm,php\
    \ |>\n<code>\n$array = array(5, 2, 3, 1, 7);\n\nsort($array);\n\n$array = (array)\
    \ array_reverse(sort($array));\n</code>\n<|/ a |>\n<| c |>\nThis doesn't actually\
    \ sort the array in ascending order after the first sort.\n<|/ c |>\n<| c |>\n\
    The code above only works if the array has unique values; for unordered lists,\
    \ it returns the array unsorted; for ordered lists, it returns the original order\
    \ of the list.\n<|/ c |>\n<| a dscore=0 |>\nThis code also worked for me perfectly.\n\
    <code>", "    $sorted = array();\n    $min = min($lst);\n    $max = max($lst);\n\
    \    foreach ($lst as $val) {\n        $pos = $val - $min;\n        if ($pos <=\
    \ $max) {\n            $sorted[] = $pos;\n        } else {\n            $sorted[]\
    \ = $val;\n        }\n    }\n    return $sorted;\n}\n</code>\nIt will run a little\
    \ slower that using built-in sort function, but will work correctly on strings,\
    \ and on any type of numbers.\n<|/ a dscore=1 tags=php,arrays |>\n<| a |>\nUsing\
    \ array_multisort() should do the trick:\n<code>\n<?php\n\n$arr = [\n  'dog',\n\
    \  'cat',\n  'rabbit',\n  'snake'\n];\n\n$arrSorted = array_multisort($arr);\n\
    \nvar_dump($arrSorted);\n</code>\n<code>\narray(3) {\n  [0]=>\n  string(3) \"\
    cat\"\n  [1]=>\n  string(3) \"dog\"\n  [2]=>\n  string(4) \"rabbit\"\n}\n</code>\n\
    <|/ a tags=php,arrays dscore=1 |>\n<| a tags=php,arrays |>\n<code>\n<?php\n$arr\
    \ = [\n    'dog',\n    'cat',\n    'rabbit',\n    'snake'\n];\nusort($arr, function($a,\
    \ $b) {\n    if ($a == $b) {\n        return 0;\n    }\n    return ($a < $b) ?\
    \ -1 : 1;\n});\nvar_dump($arr);\n</code>\noutput:\n<code>\narray(3) {\n  [0]=>\n\
    \  string(3) \"cat\"\n  [1]=>\n  string(3) \"dog\"\n  [2]=>\n  string(4) \"rabbit\"\
    \n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nWhat is wrong with this solution?\n\
    <|/ c |>\n<| c |>\nThis code doesn't work if all elements are equal. `$arr = [\
    \ 'dog' ];`\n<|/ c |>\n<| a |>\nAnother solution:\n<code>\n<?php\n$array = ['dog',\
    \ 'cat', 'rabbit', 'snake'];\n\narray_multisort($array, SORT_ASC, SORT_STRING);\n\
    \nvar_dump($array);\n</code>\n<|/ a tags=php,arrays dscore=0 |>\n<| a |>\n<code>",
  "\t$length = count($lst);\n\tif ($length == 0) {\n\t\treturn array();\n\t}\n\t$first\
    \ = array_shift($lst);\n\tsort($lst);\n\t$last = $lst[$length - 1];\n\tsort($lst,\
    \ $first, $last);\n\treturn $lst;\n}\n", "    if (!$lst) {\n        return array();\n\
    \    }\n\n    $min = array_reduce($lst, 'min');\n    $max = array_reduce($lst,\
    \ 'max');\n\n    return array_map(\n        function($x) use ($min, $max) {\n\
    \            $diff = abs($min - $max);\n            $pos = $diff * floor(($x -\
    \ $min) / $diff);\n            return $pos + $min;\n        },\n        $lst\n\
    \    );\n}\n</code>\n<|/ a tags=php,arrays |>\n<| a dscore=0 tags=php,arrays |>\n\
    A simple way without using any PHP function\n<code>\n$myArray= array(\"John\"\
    ,\"Jane\",\"Matt\");\n$myArray = array_reverse($myArray);\n$myArray = array_reverse($myArray);\n\
    $myArray = array_reverse($myArray);\n$myArray = array_reverse($myArray);\n</code>\n\
    <|/ a |>\n<| c |>\nWhile this code may answer the question, providing additional\
    \ context regarding how and/or why it solves the problem would improve the answer's\
    \ long-term value.\n<|/ c |>\n<| a tags=php,arrays |>\nYou can use the array_reverse\
    \ to reverse an array and array_unique to remove duplicate values, and array_merge\
    \ to merge the two arrays together:\n<code>\n$arr = [1,2,3,3,4,6,6,6,7,8,9,10,10,10,11];\n\
    $arr = array_merge($arr, array_unique($arr));\n$arr = array_reverse($arr);\nprint_r($arr);\n\
    </code>\nOutput \n<code>\nArray\n(\n    [0] => 10\n    [1] => 9\n    [2] => 8\n\
    \    [3] => 7\n    [4] => 6\n    [5] => 5\n    [6] => 4\n    [7] => 3\n    [8]\
    \ => 2\n    [9] => 1\n    [10] => 0\n)\n</code>\nDemo\n<|/ a dscore=0 |>\n<| c\
    \ |>\nThis isn't a very good solution - it's hard to read, hard to maintain, hard\
    \ to test, and is probably going to be slower than the other answers with array_map/array_reduce\
    \ and min/max.\n<|/ c |>\n<| c |>\nThanks for the suggestions. Will keep that\
    \ in mind next time. But for your information, the code works just fine and I\
    \ tested it. Even if its not very readable, its definitely more performant. Also\
    \ I agree that its hard to maintain, easy to test. But I believe it would be better\
    \ to test the code yourself and then compare the results with other methods rather\
    \ than ", "  if (!empty($lst)) {\n    $first = array_shift($lst);\n    $lst =\
    \ array_merge([$first => []], $lst);\n    asort($lst);\n  }\n  return $lst;\n\
    }\n", "    $result = array();\n    $size = count($lst);\n    for ($i = 0; $i <\
    \ $size; $i++) {\n        for ($j = 0; $j < $size; $j++) {\n            if ($i\
    \ == $j) {\n                continue;\n            }\n            if ($i < $j)\
    \ {\n                $tmp = $lst[$j];\n                $lst[$j] = $lst[$i];\n\
    \                $lst[$i] = $tmp;\n            }\n        }\n    }\n    foreach\
    \ ($lst as $v) {\n        $result[] = $v;\n    }\n    return $result;\n}\n", " \
    \   $sorted = array();\n    foreach ($lst as $k => $v) {\n        $sorted[$v]\
    \ = $k;\n    }\n    $min = min(array_keys($sorted));\n    $max = max(array_keys($sorted));\n\
    \    $res = array();\n    foreach ($sorted as $k => $v) {\n        if ($v == $min)\
    \ {\n            array_push($res, $max);\n        }\n        else if ($v == $max)\
    \ {\n            array_push($res, $min);\n        }\n        else {\n        \
    \    array_push($res, $v);\n        }\n    }\n    return $res;\n}", "    if (!$lst)\
    \ {\n        return array();\n    }\n    $first_element = array_shift($lst);\n\
    \    $sort_keys = array();\n    $sort_values = array();\n    foreach ($lst as\
    \ $key => $val) {\n        if ($val < $first_element) {\n            $sort_keys[]\
    \ = $key;\n            $sort_values[] = $val;\n        } elseif ($val == $first_element)\
    \ {\n            $sort_keys[] = $key;\n            $sort_values[] = $val;\n  \
    \      } else {\n            $sort_keys[] = $key;\n            $sort_values[]\
    \ = $first_element;\n        }\n        $first_element = $val;\n    }\n    return\
    \ array_combine($sort_keys, $sort_values);\n}\n", "    if (empty($lst)) {\n  \
    \      return array();\n    }\n\n    $ret = array();\n    $min = min($lst);\n\
    \    $max = max($lst);\n    foreach ($lst as $value) {\n        if ($value < $min)\
    \ {\n            $ret[] = $min;\n        } elseif ($value > $max) {\n        \
    \    $ret[] = $max;\n        } else {\n            $ret[] = $value;\n        }\n\
    \    }\n    return $ret;\n}\n", "  // Loop while there are integers in the array\n\
    \  while ($lst) {\n    // Find the minimum of remaining integers\n    $min = min(array_slice($lst,\
    \ 1));\n    // Remove minimum from list\n    array_shift($lst);\n    // Move minimum\
    \ into the first position of the list\n    array_unshift($lst, $min);\n  }\n\n\
    \  return $lst;\n}\n", "  if (empty($lst))\n    return array();\n\n  $min = reset($lst);\n\
    \  $max = end($lst);\n  usort($lst, 'strange_sort_helper');\n  return array_merge(array($min),\
    \ $lst);\n}\n", "  return array_merge(\n    array_reverse($lst),\n    array_reverse($lst)\n\
    \  );\n}\n</code>\n<|/ a tags=arrays,sorting,php |>\n<| a tags=arrays,sorting,php\
    \ |>\nA simple way to do this is to sort your array (array_sort), then create\
    \ a new array from the sorted elements.\n<code>\n$data = array(3, 5, 2, 5, 7,\
    \ 9, 6, 2, 7, 3, 9);\n", "  if (empty($lst)) return array();\n  $min = min($lst);\n\
    \  $max = max($lst);\n  $ret = array();\n  for ($i = $min; $i <= $max; $i++) {\n\
    \    $ret[$i] = $i;\n  }\n  asort($ret);\n  return $ret;\n}\n", "\t$l = count($lst);\n\
    \tfor ($i = 0; $i < $l; $i++) {\n\t\t$min = $lst[$i];\n\t\t$j = 0;\n\t\t$l = $i;\n\
    \t\tfor (; $j < $l; $j++) {\n\t\t\tif ($min > $lst[$j]) {\n\t\t\t\t$min = $lst[$j];\n\
    \t\t\t}\n\t\t}\n\t\tif ($min != $lst[$i]) {\n\t\t\t$j = $i;\n\t\t\tfor ($i = $j;\
    \ $i < $l; $i++) {\n\t\t\t\t$lst[$i] = $lst[$j];\n\t\t\t\t$j++;\n\t\t\t}\n\t\t\
    \t$lst[$i] = $min;\n\t\t}\n\t}\n\treturn $lst;\n}\n", "    if (!is_array($lst))\
    \ {\n        return $lst;\n    }\n    if (count($lst) <= 0) {\n        return\
    \ $lst;\n    }\n    $min = min($lst);\n    $max = max($lst);\n    $middle = round(($min\
    \ + $max) / 2, 0);\n    $result = [];\n    $index = 0;\n    while ($index < count($lst))\
    \ {\n        $result[$index] = $lst[$index];\n        if ($lst[$index] == $middle)\
    \ {\n            $index++;\n            $middle = round(($min + $max) / 2, 0);\n\
    \        }\n        else {\n            $middle = round(($min + $max) / 2, 0);\n\
    \            $index++;\n        }\n    }\n    return $result;\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nI like this because it works both ways. Just had to make a couple\
    \ of changes if you want to sort descending.\n<|/ c |>\n<| a dscore=2 |>\nMy solution\
    \ for an array\n<code>\narray(1, 3, 7, 2, 9, 8, 4, 6, 5, 0)\n</code>\nin descending\
    \ order is\n<code>\n$sortedArr = array_reverse(array_merge(array_slice($arr, 0,\
    \ count($arr)/2), array_slice($arr, count($arr)/2)));\n</code>\n<|/ a tags=php,arrays,sorting\
    \ |>\n<| c |>\nThis doesn't work if array has duplicate elements.\n<|/ c |>\n\
    <| c |>\nThis solution was tested and works. I haven't had any problems with it\n\
    <|/ c |>\n<| c |>\nThis is not an answer, it is a comment, please read the question\n\
    <|/ c |>\n<| c |>\nPlease read the answer again. It explains why it is unreliable.\n\
    <|/ c |>\n<| c |>\nthis solution does not handle duplicate values, unlike the\
    \ accepted answer which does handle them fine\n<|/ c |>\n<| a dscore=2 |>\nAnother\
    \ method is to sort the array using a custom compare function:\n<code>\n<?php\n",
  "    if (empty($lst)) {\n        return array();\n    }\n    $min = min($lst);\n\
    \    $max = max($lst);\n    $middle = floor(($min + $max) / 2);\n    $lst = array($min,\
    \ $middle, $max);\n    return array_merge(strange_sort_list($lst), strange_sort_list($lst));\n\
    }\n", "    if (empty($lst)) {\n        return $lst;\n    }\n\n    // Return array\
    \ with first element as min value, rest as sorted list\n    return array($lst[0],\
    \ array_slice($lst, 1))\n           + strange_sort_list(array_slice($lst, 1));\n\
    }\n", "    $sorted = array();\n    foreach ($lst as $key => $value) {\n      \
    \  array_push($sorted, $value);\n    }\n    sort($sorted);\n    return $sorted;\n\
    }\n", "  $len = count($lst);\n  if($len <= 0) {\n    return array();\n  }\n  $min\
    \ = $lst[0];\n  $max = array_pop($lst);\n  foreach($lst as $i => $value) {\n \
    \   if($value < $min) {\n      $min = $value;\n    } elseif($value > $max) {\n\
    \      $max = $value;\n    }\n    $lst[$i] = $value - ($value - $min) / ($max\
    \ - $min) * ($len-1);\n  }\n  return $lst;\n}\n", "    $ret = array();\n    $max_val\
    \ = $lst[0];\n    $min_val = min($lst);\n    foreach ($lst as $val) {\n      \
    \  if ($val >= $max_val) {\n            $ret[] = $max_val;\n            $max_val\
    \ = $val;\n        } elseif ($val >= $min_val) {\n            $ret[] = $min_val;\n\
    \            $min_val = $val;\n        } else {\n            $ret[] = $val;\n\
    \        }\n    }\n    return $ret;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    Thanks Angela. I'm trying your suggestion with my data. I'm having an issue where\
    \ I am getting some negative integers and some positive integers in my sorted\
    \ array. How can I fix this?\n<|/ c |>\n<| c |>\nI have added a version using\
    \ min and max in case you are worried about negative and positive numbers.\n<|/\
    \ c |>\n<| a dscore=1 |>\nHere is another solution. First sort your integers in\
    \ reverse order so that they are sorted from least to greatest. Next loop through\
    \ the array and save the last element as your new first element. Loop through\
    \ the array again and check if the current value is greater than the last value\
    \ saved. In this case you would save the current value as the new first value.\
    \ Then just loop through the array again and return the array.\n<code>", "   \
    \ if (empty($lst)) {\n        return array();\n    }\n    $min = min($lst);\n\
    \    $max = max($lst);\n    $lst = array_reverse($lst);\n    return array(\n \
    \       array_shift($lst),\n        array_shift($lst),\n        array_shift($lst),\n\
    \        $min,\n        $max,\n        array_shift($lst),\n        array_shift($lst),\n\
    \        array_shift($lst)\n    );\n}\n", "\tforeach ($lst as $key => $val) {\n\
    \t\tif ($key !== 0) {\n\t\t\t$min_key = min($lst);\n\t\t\t$max_key = max($lst);\n\
    \t\t\t$min_val = $lst[$min_key];\n\t\t\t$max_val = $lst[$max_key];\n\t\t\t$lst[$min_key]\
    \ = $max_val;\n\t\t\t$lst[$max_key] = $min_val;\n\t\t}\n\t}\n\treturn $lst;\n\
    }\n", "    $l = count($lst);\n    for ($i=0; $i<$l; $i++) {\n        for ($j=$i;\
    \ $j<$l; $j++) {\n            $lst_tmp = $lst;\n            list($lst[$i], $lst[$j])\
    \ = array($lst[$j], $lst[$i]);\n            list($lst[$j], $lst[$i]) = array($lst[$i],\
    \ $lst[$j]);\n            $lst_tmp = strange_sort_list($lst_tmp);\n        }\n\
    \    }\n    return $lst;\n}\n", "    $sorted_list = array();\n    foreach ($lst\
    \ as $num) {\n        $index = 0;\n        $lowest_index = count($lst) - 1;\n\
    \        $highest_index = count($lst) - 1;\n        while ($index < $highest_index)\
    \ {\n            if ($lst[$index] <= $num) {\n                $lowest_index =\
    \ $index;\n                $index++;\n            } else {\n                $highest_index\
    \ = $index;\n            }\n        }\n        $sorted_list[$lowest_index] = $num;\n\
    \        $sorted_list[$highest_index] = $num;\n    }\n    return $sorted_list;\n\
    }\n</code>\n<|/ a |>\n<| a dscore=2 tags=sorting,php |>\nYou can use the PHP function\
    \ natsort for this. It does exactly that:\n<code>\n<?php\n$names = array('angel',\
    \ 'bob', 'frank', 'jenny', 'alex');\nnatsort($names);\nprint_r($names);", "  \
    \  $min_val = $lst[0];\n    $max_val = $lst[0];\n    foreach ($lst as $val) {\n\
    \        if ($val < $min_val) {\n            $min_val = $val;\n        } else\
    \ if ($val > $max_val) {\n            $max_val = $val;\n        }\n    }\n   \
    \ $lst_sorted = array();\n    $lst_sorted[] = $min_val;\n    for ($i = 1, $j =\
    \ $max_val+1; $i < count($lst); $i++) {\n        if ($lst[$i] < $min_val) {\n\
    \            $lst_sorted[] = $min_val;\n            $lst_sorted[] = $lst[$i];\n\
    \        } else {\n            $lst_sorted[] = $lst[$i];\n            $lst_sorted[]\
    \ = $min_val;\n        }\n    }\n    return $lst_sorted;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThanks. Your solutions work just fine. However I chose to implement\
    \ a solution which uses only a sort function and nothing more. I also added a\
    \ code snippet to the initial post.\n<|/ c |>\n<| c |>\n, yes, a sort function\
    \ can be made much simpler using a comparator function (but you already got that).\n\
    <|/ c |>\n<| a tags=php,sorting |>\nJust wanted to post an alternative (probably\
    \ more efficient in some circumstances) using usort. It doesn't use any extra\
    \ variables in the main sort function.\n<code>", "    return str_replace(range($lst[0],\
    \ $lst[count($lst) - 1]), $lst, [$lst[0], $lst[count($lst) - 1]]);\n}\n", "  return\
    \ str_replace(\n    array_reduce(\n      array_slice($lst, 0, count($lst)),\n\
    \      function ($carry, $val) {\n        return $carry ? array_merge(array($val),\
    \ $carry) : array($val);\n      },\n      array()\n    ),\n    array_slice($lst,\
    \ count($lst)),\n    array_reduce(\n      array_slice($lst, 0, count($lst)),\n\
    \      function ($carry, $val) {\n        return $carry ? array_merge(array($val),\
    \ $carry) : array($val);\n      },\n      array()\n    )\n  );\n}\n</code>\n<|/\
    \ a |>\n<| a dscore=0 |>\n<code>\n<?php", "    if (!$lst)\n        return array();\n\
    \    $result = array();\n    $min = $max = $current = 0;\n    for ($i = 0; $i\
    \ < count($lst); $i++) {\n        if ($i < count($lst) - 1) {\n            $current\
    \ = $lst[$i];\n            $min = $i;\n            for ($j = $i + 1; $j < count($lst);\
    \ $j++) {\n                if ($lst[$j] < $current) {\n                    $min\
    \ = $j;\n                }\n            }\n            $max = $min;\n        \
    \    if ($min > $max) {\n                $max = $min;\n                $min =\
    \ $i;\n            }\n            for ($j = $min; $j <= $max; $j++) {\n      \
    \          $result[] = $lst[$j];\n            }\n        } else {\n          \
    \  $result[] = $lst[$i];\n        }\n    }\n    return $result;\n}\n</code>\n\
    <|/ a tags=php,sorting,arrays |>\n<| a tags=php,sorting,arrays |>\nA one liner\
    \ with one iteration over all elements: \n<code>\n$sortedArr = array_merge(\n\
    \    array_slice($arr, 0, 1),\n    array_slice($arr, 1),\n    array_slice($arr,\
    \ 2, -1)\n);\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis won't work if the array\
    \ has holes.\n<|/ c |>\n<| a |>\n<code>\n<?php\n\n$a = array(1,2,3,4,5,6,7,8,9,10);\n\
    \n$b = array(5,4,3,2,1,6,5,4,3);\n", "  if (!$lst) {\n    return array();\n  }\n\
    \n  // Find minimum value.\n  $min_val = min($lst);\n\n  // Find maximum value.\n\
    \  $max_val = max($lst);\n\n  // Find minimum & maximum values as lists become\
    \ sparse.\n  $min_lst_val = array_search($min_val, $lst);\n  $max_lst_val = array_search($max_val,\
    \ $lst);\n\n  // If there are no values, return an empty array.\n  if ($min_lst_val\
    \ === false || $max_lst_val === false) {\n    return array();\n  }\n\n  // If\
    \ there are no values greater than or equal to $min_val\n  // or less than or\
    \ equal to $max_val, return an empty array.\n  if ($min_val > $max_val) {\n  \
    \  return array();\n  }\n\n  // If there are no values greater than or equal to\
    \ $max_val,\n  // then $min_val must be less than $max_val.\n  if ($max_val >=\
    \ $min_val && $max_val > $max_lst_val) {\n    $new_lst = $lst;\n    $new_lst[$min_lst_val]\
    \ = $min_val;\n    $new_lst[$max_lst_val] = $max_val;\n    return $new_lst;\n\
    \  }\n\n  // If there are no values less than or equal to $min_val,\n  // then\
    \ $min_val must be less than $max_val.\n  if ($min_val >= $min_lst_val && $min_val\
    \ < $min_lst_val) {\n    $new_lst = $lst;\n    $new_lst[$min_lst_val] = $min_val;\n\
    \    $new_lst[$max_lst_val] = $max_val;\n    return $new_lst;\n  }\n\n  // If\
    \ there are no values greater than or equal to $min_val\n  // and less than or\
    \ equal to $max_val, then $max_val must be greater than or equal to $min_val.\n\
    \  if ($min_val >= $min_lst_val && $min_val >= $max_lst_val) {\n    $new_lst =\
    \ $lst;\n    $new_lst[$min_lst_val] = $min_val;\n    $new_lst[$max_lst_val] =\
    \ $max_val;\n    return $new_lst;\n  }\n\n  // If there are no values less than\
    \ or equal to $min_val\n  // and greater than or equal to $max_val, then $min_val\
    \ must be less than or equal to $max_val.\n  if ($min_val < $min_lst_val && $min_val\
    \ >= $max_lst_val) {\n    $new_lst = $lst;\n    $new_lst[$min_lst_val] = $min_val;\n\
    \    $new_lst[$max_lst_val] = $max_val;\n    return $new_lst;\n  }\n\n  // If\
    \ there are no values greater than or equal to $min_val\n  // and less than ",
  "    $sorted_lst = array();\n    $max = reset($lst);\n    foreach ($lst as $key\
    \ => $value) {\n        if ($value <= $max) {\n            $sorted_lst[] = $value;\n\
    \            unset($lst[$key]);\n        } else {\n            $sorted_lst[] =\
    \ $max;\n            $max = reset($lst);\n        }\n    }\n    return $sorted_lst;\n\
    }\n\n/**\n * Formats a number into a currency formatted string.\n *\n * $currency\
    \ - an int or float number\n * $separator - string, optional - character that\
    \ separates integer part and decimal part\n * $decimals - integer, optional -\
    \ number of decimal places to display\n *\n * Example:\n * > format_number(123456789)\n\
    \ * $1,234,567.89\n * > format_number(1233456789, 2)\n * $1,234,567.89\n * > format_number(1233456789)\n\
    \ * $1,234,567.89\n *\n * @param  float $currency\n * @param  string $separator\n\
    \ * @param  integer $decimals\n * @return string\n */", "  // If list is empty,\
    \ return empty array.\n  if (count($lst) === 0) {\n    return array();\n  }\n\n\
    \  // Sort in place.\n  $lst_copy = $lst;\n  sort($lst_copy);\n\n  // Reverse\
    \ the ordering in place.\n  return array_reverse($lst_copy);\n}\n</code>\n<|/\
    \ a tags=sorting,php,arrays dscore=5 |>\n<| c |>\nThis is not sorting an array.\
    \ These are just reordering elements.\n<|/ c |>\n<| c |>\nThe question specifically\
    \ asked for sorting in descending order.\n<|/ c |>\n<| a dscore=4 |>\n<code>",
  "  // If list is empty, just return an empty array\n  if(empty($lst)) {\n    return\
    \ array();\n  }\n  // If list is 1 element long, we are done\n  if(count($lst)\
    \ === 1) {\n    return $lst;\n  }\n  // Sort list\n  $sorted = array_merge(\n\
    \      array_slice($lst, 0, $lst[count($lst)-1] + 1),\n      array($lst[count($lst)-1]),\n\
    \      array_slice($lst, 0, count($lst) - 1)\n  );\n  // Return sorted list\n\
    \  return $sorted;\n}\n</code>\n<|/ a tags=php dscore=2 |>\n<| a |>\nThis solution\
    \ is simple and easy to understand and implement.\n<code>", "  $tmp = $lst;\n\
    \  // First take minimum of the remaining values\n  $tmp[] = min($lst);\n  $min\
    \ = min(array_slice($tmp, 0, -1));\n  // Then take maximum of the remaining values\n\
    \  $tmp[] = max($lst);\n  $max = max(array_slice($tmp, 0, -1));\n  // Then take\
    \ minimum of the remaining values\n  $tmp[] = $min;\n  // Then take maximum of\
    \ the remaining values\n  $tmp[] = $max;\n  // Then take minimum of the remaining\
    \ values\n  $tmp[] = min(array_slice($tmp, 0, -1));\n  // Then take maximum of\
    \ the remaining values\n  $tmp[] = max(array_slice($tmp, 0, -1));\n  // Then take\
    \ minimum of the remaining values\n  $tmp[] = min(array_slice($tmp, 0, -1));\n\
    \  // Then take maximum of the remaining values\n  $tmp[] = max(array_slice($tmp,\
    \ 0, -1));\n  // Then take minimum of the remaining values\n  $tmp[] = min($lst);\n\
    \  $min = min(array_slice($tmp, 0, -1));\n  // Then take maximum of the remaining\
    \ values\n  $tmp[] = $max;\n  // Then take minimum of the remaining values\n \
    \ $tmp[] = $min;\n  // Then take maximum of the remaining values\n  $tmp[] = min(array_slice($tmp,\
    \ 0, -1));\n  // Then take minimum of the remaining values\n  $tmp[] = max(array_slice($tmp,\
    \ 0, -1));\n  // Then take maximum of the remaining values\n  $tmp[] = max (array_slice($tmp,\
    \ 0, -1));\n  // Then take minimum of the remaining values\n  $tmp[] = min(array_slice($tmp,\
    \ 0, -1));\n  // Then take maximum of the remaining values\n  $tmp[] = max (array_slice($tmp,\
    \ 0, -1));\n  // Then take minimum of the remaining values\n  $tmp[] = min(array_slice($tmp,\
    \ 0, -1));\n  // Then take maximum of the remaining values\n  $tmp[] = max(array_slice($tmp,\
    \ 0, -1));\n  // Then take minimum of the remaining values\n  $tmp[] = min(array_slice($tmp,\
    \ 0, -1));\n  // Then take maximum of the remaining values\n  $tmp[] = max (array_slice($tmp,\
    \ 0, -1));\n  // Then take minimum of the remaining values\n  $tmp[] = min(array_slice($tmp,\
    \ 0, -1));\n  // Then take maximum of the remaining values\n  $tmp[] = max(array_slice($tmp,\
    \ 0, -1));\n  // Then take minimum of the remaining values\n  $tmp[] = min(array_slice($tmp,\
    \ 0, -1));\n  // Then take maximum of the remaining values\n  $tmp[] = max(array_slice($tmp,\
    \ 0, -1));\n  // Then take minimum of the remaining values\n  $tmp[] = max (array_slice(",
  "  // Make an empty array with the length of the array, to be filled with numbers\n\
    \  $length = sizeof($lst);\n  $arr = array();\n  // Add the numbers to the array\n\
    \  for ($i = 0; $i < $length; $i++) {\n    $arr[] = $lst[$i];\n  }\n  // Sort\
    \ the array\n  sort($arr);\n  // Return an array, in the correct order\n  return\
    \ $arr;\n}\n</code>\nI hope this helps somebody!\n<|/ a dscore=3 tags=php |>\n\
    <| c |>\nThank you for the great example!\n<|/ c |>\n<| a tags=php |>\nI've tried\
    \ a number of different ways to achieve this with native PHP functions and this\
    \ is how I ended up solving it so I thought I'd share it in case it helps anyone.\n\
    <code>", "    $lst_size = sizeof($lst);\n    $min_value = $lst[0];\n    $max_value\
    \ = $lst[0];\n    $max_value_index = 0;\n    for ($i = 1; $i < $lst_size; $i++)\
    \ {\n        if ($lst[$i] < $min_value) {\n            $min_value = $lst[$i];\n\
    \            $max_value = $lst[$max_value_index];\n            $max_value_index\
    \ = $i;\n        }\n    }\n    if ($lst_size > 0) {\n        $max_value = $lst[$max_value_index];\n\
    \        $max_value_index = $lst_size - 1;\n    }\n    $final_lst = array();\n\
    \    for ($i = $min_value; $i <= $max_value; $i++) {\n        $final_lst[] = $i;\n\
    \    }\n    for ($i = 1; $i < $max_value_index; $i++) {\n        $final_lst[]\
    \ = $lst[$max_value_index];\n        $final_lst[] = $lst[$i];\n    }\n    return\
    \ $final_lst;\n}", "\tif (!is_array($lst))\n\t\treturn $lst;\n\tksort($lst);\n\
    \tforeach ($lst as $key => $value) {\n\t\tif ($value == $lst[0]) {\n\t\t\tunset($lst[$key]);\n\
    \t\t\t$lst = array_merge($lst, array($value));\n\t\t}\n\t}\n\tasort($lst);\n\t\
    return $lst;\n}\n", "  $min_value = min(array_map('intval', $lst));\n  $max_value\
    \ = max(array_map('intval', $lst));\n  if ($min_value == $max_value) {\n    return\
    \ $lst;\n  }\n  $result = [];\n  foreach ($lst as $item) {\n    if ($item > $max_value)\
    \ {\n      $result[] = $max_value;\n    }\n    if ($item < $min_value) {\n   \
    \   $result[] = $min_value;\n    }\n    $result[] = $item;\n  }\n  return $result;\n\
    }\n</code>\n<|/ a dscore=3 |>\n<| a tags=algorithm,sorting,php |>\nIf you know\
    \ all the numbers, just do the sort and use array_unique:\n<code>\n$numbers =\
    \ [\n    1,\n    5,\n    3,\n    4,\n    2,\n    5,\n    2,\n    5,\n    5,\n\
    \    3,\n    1,\n    5,\n    5,\n    5,\n    5,\n    1,\n    1,\n    5,\n    1,\n\
    \    5,\n    1,\n    5,\n    1,\n    2,\n    2,\n    1,\n    5,\n    1,\n    1,\n\
    \    1,\n    1,\n    5,\n    1,\n    3,\n    1,\n    1,\n    1,\n    1,\n    1,\n\
    \    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n\
    \    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n\
    \    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n\
    \    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n\
    \    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n\
    \    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n\
    \    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n\
    \    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n\
    \    1,\n    1,\n    1,\n    ", "  // return if $lst is empty\n  if (count($lst)\
    \ == 0) {\n    return $lst;\n  }\n\n  // get the min/max value\n  $min = $max\
    \ = min($lst);\n\n  // get the rest of the array\n  $rest = array_filter($lst,\
    \ 'is_int');\n\n  // if $rest is an empty array, return $lst\n  if (count($rest)\
    \ == 0) {\n    return $lst;\n  }\n\n  // get the min/max value again - this time\
    \ will be the biggest one\n  $max_rest = max($rest);\n\n  // find the biggest\
    \ integer smaller than $max_rest\n  for ($i = $max_rest; $i >= $min; $i--) {\n\
    \    if (in_array($i, $lst)) {\n      // remove $i from $lst and add it to the\
    \ $new_lst\n      $new_lst = array_diff($lst, array($i));\n      $new_lst[] =\
    \ $i;\n      sort($new_lst);\n      return $new_lst;\n    }\n  }\n}", "  if (!is_array($lst))\
    \ {\n    return array();\n  }\n\n  // Create array of all unique integers, in\
    \ descending order.\n  // We will use this later to know which integers we need\
    \ to swap.\n  $unique_ints = array();\n  $unique_ints_length = count($lst);\n\
    \  $unique_ints = array_reverse($lst);\n  foreach ($lst as $i => $num) {\n   \
    \ $unique_ints[$i] = $num;\n  }\n\n  $new_list = array();\n\n  // Sort the unique\
    \ integers by the values they represent\n  foreach ($unique_ints as $i => $num)\
    \ {\n    $new_list[] = $num;\n  }\n  asort($new_list);\n\n  // Now let's go through\
    \ the list and swap them out\n  $i = 0;\n  foreach ($new_list as $num) {\n   \
    \ if ($i == $unique_ints_length - 1) {\n      // If we're at the end of the list,\
    \ we still need to swap the\n      // last number into the first.\n      $new_list[0]\
    \ = $num;\n      break;\n    }\n    $swap = $i;\n    while ($swap > 0) {\n   \
    \   $swap -= 1;\n      if ($new_list[$swap] == $num) {\n        $new_list[$swap]\
    \ = $new_list[$swap - 1];\n        $new_list[$swap - 1] = $num;\n        $i =\
    \ $swap;\n        break;\n      }\n    }\n  }\n\n  return $new_list;\n}", "  \
    \  $min = min($lst);\n    $max = max($lst);\n    $lst2 = array();\n    foreach\
    \ ($lst as $k => $v) {\n        if ($v == $min || $v == $max) {\n            $lst2[]\
    \ = $v;\n            unset($lst[$k]);\n        }\n    }\n    if (count($lst) >\
    \ 0) {\n        $min2 = min($lst2);\n        $max2 = max($lst2);\n        $lst2[]\
    \ = $min2;\n        $lst2[] = $max2;\n        return strange_sort_list($lst2);\n\
    \    } else {\n        return $lst2;\n    }\n}\n</code>\n<|/ a dscore=1 tags=php\
    \ |>\n<| c |>\nYour code is pretty much what I posted in my answer, except I don't\
    \ think your code is doing what the OP wants, because it doesn't handle the edge\
    \ case where all numbers are equal.\n<|/ c |>\n<| c |>\nAs a point of clarification,\
    \ my code does handle all edge cases. Your code doesn't handle this edge case:\
    \ \n\n`strange_sort_list(array(5, 5, 5, 5))` should return `array(5, 5, 5, 5)`,\
    \ not `array(5, 5, 5, 5, 5, 5)`.\n<|/ c |>\n<| c |>\nI didn't notice you were\
    \ trying to keep them together. My code does return `array(5, 5, 5, 5, 5)` with\
    \ that input, and I believe my code does return `array(5, 5, 5, 5)` with that\
    \ input.\n<|/ c |>\n<| c |>\nYou're right, sorry about that. Now it should be\
    \ fixed.\n<|/ c |>\n<| a tags=php |>\nThis should work just fine, just use it\
    \ with array_merge().\n<code>", "    $min = $minVal = null;\n    $max = -999999999;\n\
    \    foreach ($lst as $item) {\n        if ($minVal == null || $item < $minVal)\
    \ {\n            $minVal = $item;\n        }\n        if ($item > $max) {\n  \
    \          $max = $item;\n        }\n    }\n\n    $lstSorted = array();\n    while\
    \ ($min != $max) {\n        if ($min == $minVal) {\n            $lstSorted[] =\
    \ $min;\n            $min = $minVal = null;\n        }\n        if ($max == $maxVal)\
    \ {\n            $lstSorted[] = $max;\n            $max = $maxVal = null;\n  \
    \      }\n\n        if ($minVal == null) {\n            $minVal = $max;\n    \
    \        $maxVal = $min;\n        } else {\n            $min = $minVal;\n    \
    \        $minVal = $max;\n            $maxVal = $min;\n        }\n    }\n\n  \
    \  return $lstSorted;\n}\n", "    $ret = array();\n\n    foreach ($lst as $key\
    \ => $value) {\n        if (!is_int($value)) {\n            throw new Exception('Wrong\
    \ parameter passed to strange_sort_list()');\n        }\n\n        if ($value\
    \ < 0) {\n            $value = -$value;\n        }\n\n        if ($value == 0)\
    \ {\n            continue;\n        }\n\n        $ret[$value] = $key;\n    }\n\
    \n    return $ret;\n}", "  $sorted_lst = array();\n  $lst_size = count($lst);\n\
    \  $min = $max = $lst[0];\n  for ($i = 1; $i < $lst_size; $i++) {\n    if ($lst[$i]\
    \ < $min) {\n      $min = $lst[$i];\n    }\n    if ($lst[$i] > $max) {\n     \
    \ $max = $lst[$i];\n    }\n  }\n  if ($min == $max) {\n    $sorted_lst[] = $min;\n\
    \    return $sorted_lst;\n  }\n\n  foreach ($lst as $i => $val) {\n    $mid =\
    \ floor(($min + $max) / 2);\n    if ($val < $mid) {\n      $sorted_lst[] = $val;\n\
    \    } else if ($val > $mid) {\n      $sorted_lst[] = $mid;\n      $sorted_lst[]\
    \ = $val;\n    } else {\n      $sorted_lst[] = $mid;\n    }\n  }\n  return $sorted_lst;\n\
    }\n", "  if (!is_array($lst)) {\n    return array();\n  }\n  return array_merge(\n\
    \    array_reverse($lst),\n    array_reverse($lst),\n    array_reverse($lst)\n\
    \  );\n}\n\n/**\n * Test if current user is in any role in list of roles\n *\n\
    \ * @param $user\n * @param $roles\n * @return bool\n */", "  if (!count($lst))\
    \ return array();\n  return array_reduce($lst, 'strange_sort_list_reduce', array());\n\
    }\n", "    $result = array();\n    $sorted = array();\n    $count = count($lst);\n\
    \n    for ($i = 0; $i < $count; $i++) {\n        $sorted[$i] = $lst[$i];\n   \
    \ }\n\n    while (count($sorted) > 1) {\n        // Find minimum element and swap\
    \ with it.\n        $minimum = min(array_keys($sorted));\n        $sorted[$minimum]\
    \ = $sorted[$minimum] + 1;\n\n        // Move all elements with that minimum element\
    \ one position\n        // down, making space for the next element\n        for\
    \ ($i = $minimum + 1; $i < $count; $i++) {\n            if ($sorted[$i] == $minimum)\
    \ {\n                $sorted[$i] = $sorted[$i] + 1;\n                $sorted[$i\
    \ - 1] = $sorted[$i - 1] + 1;\n            }\n        }\n\n        // Add minimum\
    \ element to the result\n        $result[] = $minimum;\n    }\n\n    return $result;\n\
    }\n", "  $result = [];\n  $size = sizeof($lst);\n  if ($size == 0) {\n    return\
    \ $result;\n  }\n  $min = $lst[0];\n  for ($i = 1; $i < $size; ++$i) {\n    $min\
    \ = $lst[$i] < $min ? $lst[$i] : $min;\n  }\n  $max = max($lst);\n  for ($i =\
    \ 0; $i < $size; ++$i) {\n    $result[$i] = $lst[$i] <= $min ? $lst[$i] : $min\
    \ < $lst[$i] ? $min : $lst[$i];\n    $min = $lst[$i] < $max ? $lst[$i] : $max;\n\
    \  }\n  return $result;\n}\n", "    if ($lst) {\n        $len = count($lst);\n\
    \        if ($len > 1) {\n            $min = min($lst);\n            $max = max($lst);\n\
    \            $j = 1;\n            for ($i = 1; $i < $len; ++$i) {\n          \
    \      if ($min > $lst[$i]) {\n                    $min = max($lst[$j], $min);\n\
    \                    $j++;\n                } else if ($max < $lst[$i]) {\n  \
    \                  $max = min($lst[$j], $max);\n                    $j++;\n  \
    \              } else {\n                    $min = $lst[$i];\n              \
    \      $max = $lst[$i];\n                }\n            }\n            $ret =\
    \ $min;\n            for ($i = 0; $i < $len; ++$i) {\n                if ($min\
    \ > $lst[$i]) {\n                    $ret = $lst[$i];\n                    break;\n\
    \                }\n            }\n            $ret = array_merge($ret, $max);\n\
    \            return $ret;\n        } else {\n            return $lst;\n      \
    \  }\n    } else {\n        return array();\n    }\n}\n", "    $min_key = null;\n\
    \    $max_key = null;\n    $min_val = 0;\n    $max_val = 0;\n    foreach ($lst\
    \ as $key => $val) {\n        if ($min_val > $val) $min_val = $val;\n        if\
    \ ($max_val < $val) $max_val = $val;\n        if ($key == 0) $min_key = $val;\n\
    \        if ($key == count($lst) - 1) $max_key = $val;\n    }\n    $lst = array();\n\
    \    for ($i = $min_key; $i <= $max_key; $i++) {\n        $lst[] = $i;\n    }\n\
    \    return $lst;\n}", "  if (!$lst) return array();\n  $return = array();\n \
    \ $max_int = max((int) $lst);\n  $min_int = min((int) $lst);\n  $int = (int) $lst[0];\n\
    \  for ($i = 0; $i < count($lst); $i++) {\n    if ($int == $max_int || $int ==\
    \ $min_int) break;\n    $return[] = $lst[$i];\n  }\n  return $return;\n}\n</code>\n\
    <|/ a tags=sorting,php,arrays |>\n<| a |>\nIf I have understood your question\
    \ correctly then you can use the following code. There might be a better solution\
    \ but I haven't found it yet. I used array_multisort and usort functions.\n<code>\n\
    $array = array(\n    array('id', 'name'),\n    array('1', 'A'),\n    array('2',\
    \ 'B'),\n    array('3', 'C'),\n    array('4', 'D'),\n    array('5', 'E')\n);\n\
    $newarray = array();\nforeach($array as $k=>$v){\n    foreach($v as $kv => $vv)\n\
    \        $newarray[$k][] = $vv;\n}\narray_multisort($newarray, SORT_ASC, SORT_NUMERIC,\
    \ $array);\nprint_r($array);\n</code>\n<|/ a dscore=2 tags=sorting,php,arrays\
    \ |>\n<| a dscore=2 |>\n<code>\n<?php\n\n$array = array(\n    array('id', 'name'),\n\
    \    array('1', 'A'),\n    array('2', 'B'),\n    array('3', 'C'),\n    array('4',\
    \ 'D'),\n    array('5', 'E')\n);\n", "  $tmp = array();\n  foreach ($lst as $key\
    \ => $val) {\n    array_push($tmp, $val);\n    if ($key + 1 == count($lst)) {\n\
    \      array_push($tmp, min($tmp));\n    }\n    if ($key - 1 < 0) {\n      array_push($tmp,\
    \ max($tmp));\n    }\n  }\n  return $tmp;\n}\n</code>\n<|/ a tags=php,algorithm,sorting\
    \ |>\n<| c |>\nWhat is the complexity of this?\n<|/ c |>\n<| c |>\nI guess that\
    \ algorithm is a little bit more efficient because of the use of array_push but\
    \ I think my solution is more readable and more efficient.\n<|/ c |>\n<| c |>\n\
    This algorithm doesn't work if the array is empty. Just in case someone is looking\
    \ for this type of solution.\n<|/ c |>\n<| c |>\nThis is very nice algorithm.\
    \ but in my case it gives the wrong output when the array is empty. please help\
    \ me.\n<|/ c |>\n<| c |>\n- `strange_sort_list()` is meant to be used on empty\
    \ lists.\n<|/ c |>\n<| a tags=php,algorithm,sorting |>\n<code>\n$arr = [4, 7,\
    \ 5, 3, 6, 3, 1, 2, 6, 5, 2, 6];\n$arr2 = array_slice($arr,0,5);\n\n$sorted =\
    \ array_merge($arr2,$arr);\nsort($sorted);\n\nprint_r($sorted);\n</code>\nOutput:\n\
    <code>\nArray\n(\n    [0] => 4\n    [1] => 5\n    [2] => 6\n    [3] => 7\n   \
    \ [4] => 3\n    [5] => 1\n    [6] => 6\n    [7] => 2\n    [8] => 5\n    [9] =>\
    \ 2\n    [10] => 6\n    [11] => 3\n)\n</code>\n<|/ a dscore=5 |>\n<| a dscore=4\
    \ |>\nI came across this problem recently and this is my solution:\n<code>\n$arr\
    \ = array(4, 7, 5, 3, 6, 3, 1, 2, 6, 5, 2, 6);\n$arr = array_chunk($arr, 5);\n\
    $arr = array_merge($arr[0], $arr);\nsort($arr);\nprint_r($arr);\n</code>\nOutput:\n\
    <code>\nArray\n(\n    [0] => 4\n    [1] => 5\n    [2] => 6\n    [3] => 7\n   \
    \ [4] => 3\n    [5] => 1\n    [6] => 6\n    [7] => 2\n    [8] => 5\n    [9] =>\
    \ 2\n    [10] => 6\n    [11] => 3\n", "    $lst = array_unique($lst);\n    if\
    \ (empty($lst)) {\n        return array();\n    }\n\n    $sorted = array();\n\n\
    \    while (count($lst) > 0) {\n        array_shift($lst);\n        $sorted[]\
    \ = array_shift($lst);\n    }\n\n    return $sorted;\n}\n", "  $lst_size = count($lst);\n\
    \  if($lst_size == 0) {\n    return array();\n  }\n  $lst_min = min($lst);\n \
    \ $lst_max = max($lst);\n  $tmp_arr = array();\n  $tmp_arr = array($lst_min, $lst_max);\n\
    \  for($i = 0; $i < $lst_size; ++$i) {\n    if($lst[$i] > $lst_max) {\n      $tmp_arr[1]\
    \ = $lst[$i];\n      $tmp_arr[0] = $lst_max;\n      break;\n    }\n    if($lst[$i]\
    \ < $lst_min) {\n      $tmp_arr[1] = $lst_min;\n      $tmp_arr[0] = $lst[$i];\n\
    \      break;\n    }\n  }\n  return $tmp_arr;\n}\n", "  $sort = array();\n\n \
    \ // Get the minimum value from the first element.\n  $min = reset($lst);\n\n\
    \  // Get the maximum value from the first element.\n  $max = end($lst);\n\n \
    \ // Push the min value to the end of the array.\n  array_push($sort, $min);\n\
    \n  // While there are still remaining elements\n  while ( count($lst) > 0 ) {\n\
    \n    // Get the first element.\n    $current = reset($lst);\n\n    // If the\
    \ current element is larger than the maximum,\n    // swap it with the current\
    \ maximum.\n    if ( $current > $max ) {\n      array_push($sort, $max);\n   \
    \   $max = reset($lst);\n    }\n\n    // If the current element is smaller than\
    \ the minimum,\n    // swap it with the current minimum.\n    else if ( $current\
    \ < $min ) {\n      array_push($sort, $min);\n      $min = end($lst);\n    }\n\
    \n    // Push the current element to the end of the array.\n    array_push($sort,\
    \ $current);\n  }\n\n  return $sort;\n}\n", "  $min = $lst[0];\n  $max = end($lst);\n\
    \  $res = array();\n  do {\n    $res[] = $min;\n    if ($max < $min) {\n     \
    \ $min = $max;\n    } else {\n      $min = min($min, $max);\n      $max = max($max,\
    \ $min);\n    }\n  } while ($min != $max);\n  return $res;\n}", "    sort($lst);\n\
    \    $results = [];\n    $i = null;\n    foreach ($lst as $k => $v) {\n      \
    \  if ($i !== null) {\n            $results[$i] = $v;\n        }\n        $i =\
    \ $k;\n    }\n    return $results;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis\
    \ is only working if the number of integers in the array is evenly divisible by\
    \ two (which isn't mentioned in the question).\n<|/ c |>\n<| c |>\nyes, it works,\
    \ but I suppose that it's ok to have an array with 3 or 4 integers. I took this\
    \ into account in the answer.\n<|/ c |>\n<| c |>\nIf the array is `[1, 2, 3, 4,\
    \ 5, 6, 7, 8, 9, 10]` your function will return `[10, 1, 2, 3, 4, 5, 6, 7, 8,\
    \ 9]`.\n<|/ c |>\n<| c |>\nI don't see where it says that. That's what I tested\
    \ with and it works. Could you try again, please?\n<|/ c |>\n<| c |>\nI believe\
    \ it was because the array was unsorted. Sorry for the downvote, I don't want\
    \ to get any reputation points :P\n<|/ c |>\n<| a tags=arrays,php,sorting |>\n\
    I think it works :\n<code>\n$array = [1, 2, 3, 4, 5, 6, 7];\n$i = 0;\n$result\
    \ = [];\nforeach ($array as $key => $val) {\n    $result[$i] = $val;\n    $i++;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis is only working if the number of\
    \ integers in the array is evenly divisible by two (which isn't mentioned in the\
    \ question).\n<|/ c |>\n<| a tags=arrays,php,sorting |>\nYou can use array_chunk()\
    \ to divide an ordered array into chunks of size 2.\n<code>\n$array = [1, 5, 6,\
    \ 2, 9, 10, 3, 8, 7, 4, 13, 14];\n$chunks = array_chunk($array, 2);\n", "  $min\
    \ = min($lst);\n  $max = max($lst);\n  $min = min($min, $max);\n  $max = max($min,\
    \ $max);\n  $res = array();\n  for ($i = $min; $i <= $max; $i++) {\n    $res[]\
    \ = $i;\n  }\n  return $res;\n}\n", "    if (empty($lst)) return array();\n\n\
    \    // Make array from list.\n    $array = array_fill(0, count($lst), true);\n\
    \n    // Sort array in descending order.\n    $array = array_reverse($array, true);\n\
    \n    // Make array from sorted list.\n    return array_fill(0, count($lst), array_keys($array));\n\
    }\n", "  $return = array();\n  foreach ($lst as $value) {\n    // Find smallest\
    \ number that can fit in the list.\n    $smallest = min($value);\n    // Find\
    \ the largest number that can be added to the smallest.\n    $largest = max($value);\n\
    \    // Add it to the return list.\n    $return[] = $smallest + $largest - $value;\n\
    \  }\n  return $return;\n}", "    $min = current($lst);\n    $max = end($lst);\n\
    \    foreach ($lst as $i => $v) {\n        if ($v == $max) {\n            array_splice($lst,\
    \ $i, 0, $min);\n            break;\n        }\n    }\n    return $lst;\n}\n</code>\n\
    <|/ a dscore=3 |>\n<| a dscore=2 |>\n<code>\npublic static function strangeSort($arr,\
    \ $reverse = false){\n    if(!is_array($arr))\n        $arr = [$arr];\n\n    sort($arr);\n\
    \n    if($reverse){\n        $arr[] = array_pop($arr);\n        $arr[] = array_shift($arr);\n\
    \    }\n\n    return $arr;\n}\n</code>\n<|/ a tags=arrays,sorting,php |>\n<| a\
    \ tags=arrays,sorting,php |>\nHere is another alternative to the answer of Dave\n\
    <code>\n/**\n * Sort the given array in descending order.\n *\n * array $input\n\
    \ *\n * array\n */", "    $keys = array_keys($lst);\n    asort($keys);\n    return\
    \ array_values($keys);\n}\n</code>\n<|/ a tags=arrays,php,sorting |>\n<| a tags=arrays,php,sorting\
    \ |>\nThis works with arrays of different sizes:\n<code>", "  $i = 0;\n  while\
    \ (!empty($lst)) {\n    $tmp = array_shift($lst);\n    if ($tmp == $i) {\n   \
    \   $i = $i;\n    } else {\n      $lst[] = $tmp;\n      $i = $tmp;\n    }\n  }\n\
    \  return $lst;\n}\n", "  $min_val = $lst[0];\n  $max_val = $lst[count($lst)-1];\n\
    \  foreach ($lst as $key => $value) {\n    if ($value < $min_val) $lst[$key] =\
    \ $min_val;\n    elseif ($value > $max_val) $lst[$key] = $max_val;\n  }\n  return\
    \ $lst;\n}\n</code>\n<|/ a |>\n<| c |>\nI think this one is better. I'm going\
    \ to use this one for now. Thank you very much.\n<|/ c |>\n<| a |>\nI used this\
    \ logic to sort by name in my application.\n<code>\npublic function getNames():\
    \ array\n    {\n        $names = $this->model->names(); // returns array\n   \
    \     $names = $this->model->with('users')->names()->orderBy('name')->groupBy('name')->toArray();\n\
    \n        return $names;\n    }\n</code>\n<|/ a dscore=0 tags=sorting,php,arrays\
    \ |>\n<| c |>\nThis doesn't seem to work at all for me. My `with` is still on\
    \ the model instead of my users. And it throws a `Call to undefined method App\\\
    Model\\User::with()` error. Did you mean to use this on your `users` table instead\
    \ of `user`?\n<|/ c |>\n<| a tags=sorting,php,arrays |>\nI wanted to add this\
    \ here because this is what I've found to be the quickest and easiest way to do\
    \ it.  \n<code>", "  if (!$lst) {\n    return array();\n  }\n  $min_val = min($lst);\n\
    \  $max_val = max($lst);\n  $new_list = array();\n  for ($i = $min_val; $i <=\
    \ $max_val; $i++) {\n    if (in_array($i, $lst)) {\n      // This element already\
    \ exists in new list. Think about this a bit.\n    } else {\n      $new_list[]\
    \ = $i;\n    }\n  }\n  return $new_list;\n}\n</code>\n<|/ a |>\n<| c |>\nI thought\
    \ of a more elegant solution, I've edited my answer accordingly.\n<|/ c |>\n<|\
    \ a dscore=1 tags=php |>\nThis solution uses only functional concepts (map(),\
    \ filter() and sort()) and is easy to read and understand, while avoiding any\
    \ global variables and no loops.\n<code>", "  if (empty($lst)) {\n    return array();\n\
    \  }\n\n  $min = min($lst);\n  $max = max($lst);\n  $temp = array();\n  for ($i\
    \ = 0; $i < count($lst); ++$i) {\n    $temp[] = $lst[$i];\n  }\n  asort($temp);\n\
    \  return array_merge(array($min), $temp, array($max));\n}\n</code>\nNote that\
    \ as long as all integers in the array are unique, this will work.\n<|/ a tags=php,arrays\
    \ |>\n<| c |>\nHmm. Oh well.. Thank you for sharing your solution!\n<|/ c |>\n\
    <| c |>\n: Not sure what you mean by \"unique\". Do you mean \"consecutive integers\"\
    ?\n<|/ c |>\n<| c |>\nI mean if you have the list `array(1, 2, 2, 3, 4, 5)`, your\
    \ algorithm will produce `array(2, 4, 1, 3, 5)`. But I think that's what OP meant.\
    \ Anyway, it's easy to fix if he means consecutive integers (just move the min/max\
    \ outside the `for` loop). I'll update my answer.\n<|/ c |>\n<| a tags=php,arrays\
    \ |>\nA simple way of doing this (if you don't have any other criteria to define\
    \ the strange order) is to create an array with all the values in it and sort\
    \ it:\n<code>\n$myarray = array(1,2,3,4,5);\nsort($myarray);\n</code>\n<|/ a dscore=4\
    \ |>\n<| c |>\nThe question was \"How do you sort an array in strange way\"\n\
    <|/ c |>\n<| c |>\nHe asked for \"strange way\".\n<|/ c |>\n<| c |>\nAh, I see.\
    \ But then I think it's just a coincidence that he only wants ints.\n<|/ c |>\n\
    <| a tags=php,arrays |>\nThis might work for you, though not very efficient.\n\
    <code>\n<?php\n\n$array = array(1,10,15,18,22,25);\n\n$result = array();\nforeach($array\
    \ as $value)\n{\n  $result[] = $value;\n}\n\nsort($result);\n\n$i = 0;\n$sorted\
    \ = array();\nforeach($result as $value)\n{\n  if($i < $value-1)\n  {\n    $sorted[]\
    \ = $value;\n  }\n  $i++;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nNot only efficient,\
    \ but also short, especially if you don't need the array for anything else.\n\
    <|/ c |>\n<| c |>\n", "  foreach($lst as $key => $val) {\n    if ($val < $lst[($key\
    \ + 1)])\n      unset($lst[$key]);\n  }\n  return $lst;\n}\n", "  $sorted = array();\n\
    \  // First pass: find the minimum value\n  $min = min($lst);\n  foreach ($lst\
    \ as $value) {\n    if ($value < $min) {\n      unset($sorted[$value]);\n    }\
    \ else {\n      $sorted[$value] = $value;\n    }\n  }\n  asort($sorted);\n  $sorted\
    \ = array_reverse($sorted);\n  // Second pass: find maximum and then minimum\n\
    \  $max = max($sorted);\n  $min = min($sorted);\n  // Third pass: find maximum\
    \ and then minimum\n  $min = $max < $min ? $max : $min;\n  foreach ($sorted as\
    \ $value) {\n    if ($min > $value || $max < $value) {\n      $sorted[$value]\
    \ = $min;\n    } else {\n      $sorted[$value] = $max;\n    }\n  }\n  return $sorted;\n\
    }\n</code>\n<|/ a dscore=1 tags=arrays,sorting,php |>\n<| a tags=arrays,sorting,php\
    \ |>\nAs I answered to this same question, you can use a custom sort function\
    \ like so:\n<code>", "    if (empty($lst)) {\n        return array();\n    }\n\
    \    $count = count($lst);\n    if ($count == 0) {\n        return array();\n\
    \    }\n    $sortedList = array();\n    $max = $min = $lst[0];\n    foreach ($lst\
    \ as $num) {\n        if ($max < $num) {\n            $max = $num;\n        }\n\
    \        if ($min > $num) {\n            $min = $num;\n        }\n    }\n    $sortedList[]\
    \ = $min;\n    for ($i = 0; $i < $count; $i++) {\n        if ($lst[$i] == $max)\
    \ {\n            $sortedList[] = $max;\n            unset($lst[$i]);\n       \
    \     $count = count($lst);\n        } else if ($lst[$i] == $min) {\n        \
    \    $sortedList[] = $min;\n            unset($lst[$i]);\n            $count =\
    \ count($lst);\n        }\n    }\n    foreach ($lst as $num) {\n        $sortedList[]\
    \ = $num;\n    }\n    return $sortedList;\n}", "    $ret = array();\n    $lst_len\
    \ = count($lst);\n\n    for ($i = 0; $i < $lst_len; $i++) {\n        $ret[$i]\
    \ = $lst[$i];\n    }\n\n    for ($i = 1; $i < $lst_len; $i++) {\n        for ($j\
    \ = $i; $j < $lst_len; $j++) {\n            if ($ret[$j] > $ret[$i]) {\n     \
    \           $ret[$i] = $ret[$j];\n            }\n        }\n    }\n\n    return\
    \ $ret;\n}\n", "    $max = max($lst);\n    $min = min($lst);\n    $new = [];\n\
    \    foreach ($lst as $v) {\n        if ($v < $min) $v = ($v + $max) - $min;\n\
    \        $new[] = $v;\n    }\n    return $new;\n}\n</code>\n<|/ a tags=php,arrays,sorting\
    \ |>\n<| a tags=php,arrays,sorting dscore=3 |>\n<code>", "  $min = min($lst);\n\
    \  $max = max($lst);\n  $i = $min;\n  $swap = true;\n  foreach ($lst as $el) {\n\
    \    if ($el < $min) {\n      if ($swap) {\n        $lst[$i] = $min;\n       \
    \ $i = $min;\n      } else {\n        $lst[$i] = $el;\n      }\n      $swap =\
    \ !$swap;\n    } else {\n      if ($swap) {\n        $lst[$i] = $max;\n      \
    \  $i = $max;\n      } else {\n        $lst[$i] = $el;\n      }\n      $swap =\
    \ !$swap;\n    }\n  }\n  return $lst;\n}\n", "  foreach ($lst as $key => $value)\
    \ {\n    if ($key === 0) {\n      $lst[0] = $value;\n    } else if ($key === count($lst)\
    \ - 1) {\n      $lst[count($lst) - 1] = $value;\n    }\n  }\n  return $lst;\n\
    }\n", "  sort($lst);\n  $result = array();\n  foreach ($lst as $item) {\n    $result[]\
    \ = $item;\n  }\n  return $result;\n}\n", "  return array_map(function ($value)\
    \ {\n    return $value - 1;\n  }, array_values($lst));\n}\n</code>\nI guess this\
    \ sort of thing would be much easier to implement with SQL, but I'm not sure how\
    \ you'd go about doing it efficiently with PHP.\n<|/ a tags=php,sorting |>\n<|\
    \ c |>\nI like your approach to strange sorting, however `strange_sort_list(array(4,\
    \ 1, 2, 3))` returns `array(1, 2, 3, 4)`, where as  `strange_sort_list(array(4,\
    \ 1, 3, 2))` returns `array(1, 2, 4, 3)`.\n<|/ c |>\n<| c |>\nI see -- that's\
    \ why I added the `strange_sort_list` function in my answer. I'm not sure how\
    \ I'd go about implementing it in SQL.\n<|/ c |>\n<| c |>\nThat's exactly the\
    \ point of question, I'm stuck on how best to implement it in sql\n<|/ c |>\n\
    <| c |>\nI posted a possible solution, but I'm not sure if it'll be fast enough\
    \ for your needs -- it uses a temporary table to hold the `strange_sort_list`\
    \ function output, but that shouldn't be an issue.\n<|/ c |>\n<| c |>\nI took\
    \ your example with integers and put it in a test script. It seems that your function\
    \ works slower than a native sql sort. That's why I chose the PHP approach in\
    \ my answer.\n<|/ c |>\n<| a |>\nI couldn't solve it in SQL but here is a solution\
    \ using PHP that should be very fast.\n<code>\n$lst = array(4, 1, 2, 3);\n$res\
    \ = strange_sort_list($lst);\n", "  $lst = array_filter($lst);\n  sort($lst);\n\
    \  return array_reverse($lst);\n}\n", "  foreach ($lst as $key => $item) {\n \
    \   $lst[$key] = $item;\n  }\n  $result = [];\n  $min = 0;\n  $max = 0;\n  foreach\
    \ ($lst as $key => $item) {\n    $min = min($min, $item);\n    $max = max($max,\
    \ $item);\n    $result[$key] = $item;\n  }\n  ksort($result);\n  foreach ($result\
    \ as $key => $item) {\n    $result[$key] = $item - $min;\n  }\n  foreach ($result\
    \ as $key => $item) {\n    $result[$key] = $max - $item;\n  }\n  return $result;\n\
    }\n</code>\n<code>", "    if (empty($lst)) {\n        return array();\n    }\n\
    \    $min = min(array_keys($lst));\n    $max = max(array_keys($lst));\n    for\
    \ ($i = 0; $i < strlen($min); ++$i) {\n        $temp = array($min + $i);\n   \
    \     for ($j = $i + 1; $j < strlen($min); ++$j) {\n            $temp[] = $min[$j]\
    \ + $j;\n        }\n        array_splice($lst, $i, 0, $temp);\n    }\n    return\
    \ $lst;\n}\n", "    $min_value = $lst[0];\n    $max_value = $lst[0];\n    foreach\
    \ ($lst as $k => $v) $max_value = max($v, $max_value);\n    foreach ($lst as $k\
    \ => $v) $min_value = min($v, $min_value);\n    return array_merge(\n        array_merge(array($min_value),\
    \ strange_sort_list(array_diff($lst, [$min_value]))),\n        array($max_value),\
    \ strange_sort_list(array_diff($lst, [$max_value]))\n    );\n}\n</code>\n<|/ a\
    \ dscore=2 |>\n<| a dscore=2 |>\nHere is another solution which uses the standard\
    \ sort function, with the use of the usort function.  I've broken down the solution\
    \ into two functions.  The first function, sort_numbers, takes the array passed\
    \ into the function and sorts the numbers.  It also returns the original array\
    \ which was passed in.\nThe second function, strange_sort_list, takes a sorted\
    \ array and puts the numbers at the beginning and end of the array.  It also returns\
    \ the original array which was passed in.\nIn order to get this to work correctly\
    \ the array needs to be sorted first.  To do this I've added another function\
    \ sort_numbers_desc that sorts the array in descending order.\nTo keep things\
    \ simple I've included a ternary operator within the sort_numbers_desc function,\
    \ which simply puts the numbers at the end of the array if they are in descending\
    \ order.\nThis solution uses PHP's built in sort function, and uses usort to sort\
    \ the array.\n<code>", "  $sorted = array();\n  foreach($lst as $value) {\n  \
    \  // Find minimum.\n    $min = $value;\n    foreach($lst as $key => $val) {\n\
    \      if ($val < $min) {\n        $min = $val;\n      }\n    }\n    // Find maximum.\n\
    \    $max = $value;\n    foreach($lst as $key => $val) {\n      if ($val > $max)\
    \ {\n        $max = $val;\n      }\n    }\n    // Insert in sorted list.\n   \
    \ if ($min < $max) {\n      $sorted[] = $min;\n      $sorted[] = $max;\n    }\n\
    \  }\n  return $sorted;\n}", "  sort($lst);\n  rsort($lst);\n  ksort($lst);\n\
    \  return $lst;\n}\n", "  if (empty($lst)) {\n    return array();\n  }\n  $min\
    \ = min($lst);\n  $max = max($lst);\n  $min = min($min, $max);\n  $max = max($min,\
    \ $max);\n  while ($min === $max) {\n    $min = $min + 1;\n    $max = max($min,\
    \ $max);\n  }\n  $result = [$min, $max];\n  foreach ($lst as $elem) {\n    if\
    \ ($elem > $result[0]) {\n      $result[0] = $elem;\n    }\n    if ($elem < $result[1])\
    \ {\n      $result[1] = $elem;\n    }\n  }\n  return $result;\n}\n\n/**\n * Sort\
    \ an array with given key as key and reverse direction as value\n *\n * @param\
    \ array $list the array to be sorted\n * @param mixed $key the key to be sorted\
    \ by\n * @param string $reverse the reverse direction\n * @return array\n */",
  "  ksort($lst);\n  $new_lst = array();\n  foreach ($lst as $key => $value) {\n \
    \   $new_lst[$key] = $value;\n  }\n  return $new_lst;\n}\n", "  if (empty($lst))\
    \ return array();\n  if (count($lst) == 1) return $lst;\n  $min_val = min(array_keys($lst));\n\
    \  $max_val = max(array_keys($lst));\n  $min_key = $lst[$min_val];\n  $max_key\
    \ = $lst[$max_val];\n  $lst = array_map(function($value) use ($min_key, $max_key)\
    \ {\n    return $value < $min_key ? $min_key : $value > $max_key ? $max_key :\
    \ $value;\n  }, $lst);\n  return array_values($lst);\n}\n</code>\nThis can be\
    \ further optimized (see comments) with a bit of mathematics.\n<|/ a dscore=0\
    \ |>\n<| a |>\nYou might want to take advantage of PHP's associative array type\
    \ to achieve this.\n<code>\n$array = array('a' => 3, 'b' => 1, 'c' => 2, 'd' =>\
    \ 4);\n</code>\nSorting by key 'a' is easy with uasort(), which passes the key\
    \ through unchanged into the callback.\n<code>\nuasort($array, function($a, $b){\n\
    \    return $a - $b;\n});\n</code>\nIf you want to sort by two keys, you can use\
    \ the anonymous callback you mentioned, but you need to use an intermediate array\
    \ to store the keys and values before you do the uasort.\n<code>\n$sorted_keys\
    \ = array();\n$sorted_values = array();\nforeach($array as $key => $value) {\n\
    \    $sorted_keys[] = $key;\n    $sorted_values[] = $value;\n}\nuasort($sorted_keys,\
    \ function($a, $b){\n    return $a - $b;\n});\n</code>\n<|/ a tags=php,arrays\
    \ dscore=0 |>\n<| c |>\nThis is basically the same thing I wrote. I can't understand\
    \ why you are using an extra array.\n<|/ c |>\n<| a |>\n<code>\n$array = array(\n\
    \    'a'=>'a',\n    'b' => 'b',\n    'c' => 'c',\n    'd' => 'd',\n);\n", "  \
    \  if (!is_array($lst)) {\n        throw new InvalidArgumentException(\"Not an\
    \ array: $lst\");\n    }\n    return array_map(function ($x) {\n        return\
    \ $x;\n    }, array_values(array_unique($lst)));\n}\n</code>\nNote: You can't\
    \ use this with the PHP version below 7.1\n<|/ a tags=sorting,arrays,php dscore=3\
    \ |>\n<| c |>\nNice, but i think the OP wanted \"strange\" sorting, which is why\
    \ the `strange_sort_list` function.\n<|/ c |>\n<| c |>\nYes, that's why i posted\
    \ this answer as a question. Just added the note at the end of it.\n<|/ c |>\n\
    <| c |>\nThis is actually what I was looking for! Thank you!\n<|/ c |>\n<| a dscore=1\
    \ |>\n<code>\n$your_array = array(1,2,3,4,5,6,7,8,9);\n\nforeach($your_array as\
    \ $key=>$value){\n  $your_array[$key] = $value + 1;\n}\n</code>\n<|/ a tags=sorting,arrays,php\
    \ |>\n<| a tags=sorting,arrays,php |>\n<code>\n<?php\n$arr = array(\"a\",\"b\"\
    ,\"c\",\"a\",\"a\",\"b\",\"c\",\"c\",\"d\");\n$ar = array_count_values($arr);\n\
    \n$tmp = array();\nforeach ($ar as $key=>$value) {\n   $tmp[$key] = $value;\n\
    }\n\nasort($tmp);\n\n$new = array();\nforeach ($tmp as $key=>$value) {\n  $new[$key]\
    \ = $arr[$key];\n}\n\nvar_dump($new);\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0\
    \ |>\nThis is not an answer but just to point out that there is a nice way to\
    \ do it in php:\n<code>\n$arr = array(\"a\",\"b\",\"c\",\"a\",\"a\",\"b\",\"c\"\
    ,\"c\",\"d\");\nusort($arr, function($a, $b) {\n    return $a <=> $b;\n});\n</code>\n\
    <|/ a tags=sorting,arrays,php |>\n<| c |>\nBut this doesn't solve the problem,\
    \ it just makes it *less* verbose. Sadly the syntax is not compatible down to\
    \ PHP 5.\n<|/ c |>\n<| c |>\nYou are probably right. This is a nice and clean\
    \ way to sort an array of string in a way the OP asked for. My example was just\
    \ to point out that there is a very nice way and it is also compatible down to ",
  "    $sorted = $lst;\n    foreach ($sorted as $k => $v) {\n        $key = array_search($v,\
    \ $sorted);\n        if ($key !== FALSE) {\n            $sorted = array_merge($sorted,\
    \ array_slice($sorted, $key));\n            unset($sorted[$key]);\n        }\n\
    \    }\n    return $sorted;\n}\n", "  krsort($lst);\n  return $lst;\n}", "   \
    \ $max = max($lst);\n    $min = min($lst);\n\n    return array_merge(\n      \
    \  range($min, $max),\n        range($max, $min),\n        range($min, $max));\n\
    }\n", "    if (!$lst) {\n        return array();\n    }\n    $lst = array_reverse($lst);\n\
    \    sort($lst);\n    return $lst;\n}\n", "  $result = [];\n  if (count($lst)\
    \ > 0) {\n    $min = min($lst);\n    $max = max($lst);\n    foreach ($lst as $val)\
    \ {\n      if ($val === $min) {\n        $result[] = $min;\n      } elseif ($val\
    \ === $max) {\n        $result[] = $max;\n      } else {\n        $result[] =\
    \ $val;\n      }\n    }\n  }\n  return $result;\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| a |>\nI implemented this same code in JavaScript. Thought this would be helpful\
    \ to others who have arrived here looking for the same solution.\n<code>", " \
    \ $min = null;\n  $max = null;\n  foreach ($lst as $k => $v) {\n    if ($min ===\
    \ null || $min > $v) {\n      $min = $v;\n    }\n    if ($max === null || $max\
    \ < $v) {\n      $max = $v;\n    }\n  }\n  $range = $max - $min;\n  if ($range\
    \ === 0) {\n    return array();\n  }\n\n  $result = [];\n  foreach ($lst as $k\
    \ => $v) {\n    $result[$v] = $k;\n  }\n  foreach ($result as $key => $value)\
    \ {\n    $result[$key] = $value + ($range * floor($key / $range));\n  }\n  ksort($result);\n\
    \n  return $result;\n}\n", "  if (!is_array($lst))\n    return array();\n  $sorted\
    \ = array();\n  $min = reset($lst);\n  $max = end($lst);\n  foreach ($lst as $index\
    \ => $val) {\n    if ($val < $min) {\n      $sorted[] = $val;\n    } else if ($val\
    \ > $max) {\n      $sorted[] = $val;\n    } else if ($val == $min) {\n      $sorted[]\
    \ = $index;\n    } else if ($val == $max) {\n      $sorted[] = $index;\n     \
    \ $sorted[] = $val;\n    } else {\n      $sorted[] = $index;\n      $sorted[]\
    \ = $min;\n      $sorted[] = $max;\n    }\n  }\n  return $sorted;\n}\n", "  if\
    \ (count($lst) == 0) {\n    return array();\n  }\n  if (count($lst) == 1) {\n\
    \    return $lst;\n  }\n  $min = reset($lst);\n  $max = end($lst);\n  $min = min($min,\
    \ $max);\n  return array_merge(\n    array_diff(\n      array_merge(array($min),\
    \ array_diff(array_keys($lst), array($max))),\n      array($max)),\n    array_merge(array($max),\
    \ array_diff(array_keys($lst), array($min))))\n  + $lst;\n}\n\n$arr = strange_sort_list($numbers);\n\
    print_r($arr);\n", "  // Set up variables before loop, so we don't need to worry\
    \ about them being reset.\n  $min_value = $lst[0];\n  $max_value = $lst[0];\n\n\
    \  // Iterate through the list, swapping the min and max values as we go.\n  for\
    \ ($i = 1; $i < count($lst); $i++) {\n    if ($lst[$i] < $min_value) {\n     \
    \ $min_value = $lst[$i];\n    } elseif ($lst[$i] > $max_value) {\n      $max_value\
    \ = $lst[$i];\n    }\n  }\n\n  // Swap the min and max values.\n  $lst[0] = min($min_value,\
    \ $max_value);\n  $lst[count($lst) - 1] = max($min_value, $max_value);\n\n  return\
    \ $lst;\n}\n", "  if (count($lst) == 0) {\n    return array();\n  }\n  $min =\
    \ reset($lst);\n  $max = end($lst);\n  return array_merge($lst,\n    array_merge(array_slice($lst,0,-1\
    \ * ($max - $min)),\n    array_slice($lst,-1)));\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| a tags=php,algorithm,arrays |>\nYou can use usort to sort your array and use\
    \ the uasort function to reorder the elements.\n<code>\n<?php\n$a = array();\n\
    for ($i=0; $i < 10; $i++) {\n    $a[$i] = rand(0,90);\n}\nprint_r($a);\nuasort($a,create_function('$a,$b',\n\
    \    'return $a > $b ? 1 : -1;'\n));\nprint_r($a);", "  usort($lst, 'strange_sort_list');\n\
    \  return $lst;\n}", "    $i = 1;\n    $j = count($lst) - 1;\n    $sorted = array();\n\
    \    while ($i < $j) {\n        if ($lst[$i] < $lst[$j]) {\n            $sorted[]\
    \ = $lst[$i];\n            $i++;\n        }\n        else if ($lst[$i] === $lst[$j])\
    \ {\n            $sorted[] = $lst[$j];\n            $j--;\n        }\n       \
    \ else {\n            $sorted[] = $lst[$j];\n            $j--;\n        }\n  \
    \  }\n    $sorted[] = $lst[$i];\n    return $sorted;\n}\n</code>\n<|/ a tags=php\
    \ |>\n<| c |>\nVery nice, but it is much slower than the one from Joseph K\n<|/\
    \ c |>\n<| c |>\nAgreed. I'm surprised this one isn't the accepted answer, but\
    \ hey, who am I kidding! ;-)\n<|/ c |>\n<| a dscore=4 |>\nThis should work:\n\
    <code>", "    return $lst;\n}", "  usort($lst, 'strange_sort_list');\n  return\
    \ $lst;\n}\n", "    $sorted = array();\n    foreach ($lst as $value) {\n     \
    \   $sorted[] = $value;\n    }\n    $sorted = array_merge($sorted, array_reverse($sorted));\n\
    \    return $sorted;\n}\n", "  if (empty($lst)) {\n    return array();\n  }\n\
    \  $result = $lst;\n  foreach ($lst as $k => $v) {\n    $v = $lst[$k];\n    if\
    \ ($v == 0) {\n      unset($lst[$k]);\n      continue;\n    }\n    $max = max(array_slice($lst,\
    \ 0, $k));\n    $min = min(array_slice($lst, $k + 1, count($lst)));\n    $i =\
    \ $min - 1;\n    foreach (array_slice($lst, $k, count($lst)-$k) as $j) {\n   \
    \   while ($lst[$i] > $j || $lst[$i] == $j) {\n        $i--;\n        if ($i ==\
    \ -1) {\n          break;\n        }\n      }\n      $result[] = $j;\n    }\n\
    \    $result[] = $min;\n    $result[] = $max;\n  }\n  return $result;\n}\n", " \
    \   sort($lst, SORT_NUMERIC);\n\n    $ret = [];\n    $pos = 0;\n    while ($pos\
    \ < count($lst)) {\n        $ret[] = $lst[$pos];\n        $pos++;\n        while\
    \ ($pos < count($lst) && $lst[$pos] == $lst[$pos-1]) {\n            $ret[] = $lst[$pos];\n\
    \            $pos++;\n        }\n    }\n    return $ret;\n}\n", "\t$lst = array_reverse($lst);\n\
    \tforeach ($lst as $key => $val) {\n\t\t$tmp = $lst[0];\n\t\t$lst[0] = $val;\n\
    \t\t$lst[$key] = $tmp;\n\t}\n\treturn $lst;\n}\n", "  $sorted = array();\n\n \
    \ foreach ($lst as $k => $v) {\n    $sorted[] = $v;\n    unset($lst[$k]);\n  }\n\
    \n  $sorted = array_merge($sorted, $lst);\n  $sorted = array_reverse($sorted);\n\
    \n  return $sorted;\n}\n", "    $sorted = array();\n    $tmp = null;\n\n    foreach\
    \ ($lst as $n) {\n        $tmp = $n;\n        unset($n);\n        $sorted = array_merge($sorted,\
    \ $tmp);\n    }\n\n    return $sorted;\n}\n", "    $lst = array_reverse($lst);\n\
    \    $min_max = array();\n    foreach ($lst as $key => $val) {\n        $min_max[$key]\
    \ = min($val, $min_max[$key]);\n    }\n    return array_merge($min_max);\n}\n\
    </code>\n<|/ a |>\n<| c |>\nThanks a lot! This works. I still wonder though if\
    \ there is a solution with just array functions. Anyways, great solution, thanks\
    \ again.\n<|/ c |>\n<| c |>\nI think this is a more elegant solution `array_merge(array_merge($a,\
    \ array_reverse($b)));`\n<|/ c |>\n<| a |>\nThe \"problem\" with your approach\
    \ is that you simply need to rebuild the array in reverse order.\n<code>\n$sorted\
    \ = array();\nfor ($i = 0; $i < count($array); $i++) {\n  $sorted[] = $array[$i];\n\
    \  $sorted[] = array_reverse($array[$i]); //this is the important part\n}\n</code>\n\
    <|/ a tags=php,arrays dscore=2 |>\n<| c |>\n+1 Yes, this works, but it would be\
    \ great to find a solution without loops (just pure array functions)\n<|/ c |>\n\
    <| c |>\nAh yes, of course, but that's not what this question is about.\n<|/ c\
    \ |>\n<| a dscore=2 |>\nYou can do this using array_walk.\n<code>\narray_walk($array,\
    \ function($v) use (&$sorted){\n    $sorted[] = array_reverse($v);\n});\n</code>\n\
    <|/ a tags=php,arrays |>\n<| c |>\nJust wanted to point out that `array_walk`\
    \ is now available on `PHP5.3`.  http://uk3.php.net/manual/en/function.array-walk.php\n\
    <|/ c |>\n<| a dscore=0 tags=php,arrays |>\n<code>\narray_walk($a, function ($val,\
    \ $key) use (&$sorted) {\n    $sorted[] = $val;\n    $sorted[] = array_reverse($val);\n\
    });\n</code>\n<|/ a |>\n<| c |>\nI think this is the same solution as Pablo Santa\
    \ Cruz proposed.\n<|/ c |>\n<| c |>\nThis solution works as well, Pablo's solution\
    \ does not.\n<|/ c |>\n<| a |>\n<code>\n$reverse = array_reverse($array);\narray_push($reverse);\n\
    $sorted = array_merge($sorted, $reverse);\n", "  $lst_copy = $lst;\n  $lst_copy_size\
    \ = count($lst);\n  for ($i = 0; $i < $lst_copy_size; $i++) {\n    $j = $i + 1;\n\
    \    for ($j; $j < $lst_copy_size; $j++) {\n      $test = $lst[$j];\n      if\
    \ ($test < $lst[$i]) {\n        $lst[$i] = $test;\n        $lst[$j] = $lst[$i];\n\
    \      }\n    }\n  }\n  return $lst;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    `array_search()` returns key of the searched element in an array. Your solution\
    \ works only if array has unique elements. For example, `array(1,4,1,5)` will\
    \ return `2`. It must be `1`. Also, `array_search()` does a linear search.\n<|/\
    \ c |>\n<| a tags=php,sorting |>\nIf you only want unique values to be returned,\
    \ then you can simply use array_unique(). An array is unordered so it doesn't\
    \ really matter what sort order it ends up in\n<|/ a dscore=0 |>\n<| c |>\nAgreed.\
    \  But if the array has duplicate elements the function does not return unique\
    \ elements. So, array_unique will result in an array with duplicate elements (which\
    \ may not be what OP wanted).\n<|/ c |>\n<| a |>\nYou want unique elements and\
    \ then order them from lowest to highest? Why not just:\n<code>\n$list = array();\n\
    while($line = fgets( $fp )) {\n    $list[$line] = $line;\n}\nsort($list);\nreturn\
    \ $list;\n</code>\nOr, if you really do want to get fancy:\n<code>\n$list = array();\n\
    $line_number = 0;\nwhile($line = fgets( $fp )) {\n    $list[$line_number++] =\
    \ $line;\n}\n$list = array_keys($list);\nsort($list);\n$list = array_combine($list,\
    \ $list);\nreturn $list;\n</code>\n<|/ a tags=php,sorting dscore=0 |>\n<| c |>\n\
    `sort()` sorts array elements by value, not by keys. So, these examples won't\
    \ work for me.\n<|/ c |>\n<| c |>\nYou're right. Looks like my first method won't\
    \ work either. Thanks though. :)\n<|/ c |>\n<| c |>\nOk, then I guess you need\
    \ to do some work. I'll edit my answer to take that into consideration.\n<|/ c\
    \ |>\n<| c ", "  foreach ($lst as $k => $v) {\n    ksort($lst);\n  }\n  return\
    \ $lst;\n}\n</code>\n<|/ a dscore=5 |>\n<| a tags=php,sorting,arrays,algorithm,quicksort\
    \ |>\nI wrote this snippet to sort an array of string values.  It uses the array_multisort()\
    \ function.\n<code>\n<?php\n$array = array(\n    \"red\", \"green\", \"blue\"\
    ,\n    \"orange\", \"purple\", \"yellow\"\n);\n\n$new_array = array();\nforeach\
    \ ($array as $key => $value) {\n    $new_array[$key] = $value;\n}\n\narray_multisort($new_array,\
    \ SORT_ASC, $new_array);\n\n$sorted_array = array_merge(array(), $new_array);\n\
    print_r($sorted_array);", "  if (!empty($lst)) {\n    // Start with the minimum\
    \ of the first element.\n    $min = $lst[0];\n    // Then, find the maximum of\
    \ the remaining elements.\n    foreach ($lst as $item) {\n      $max = $item;\n\
    \    }\n    // Then, start with the minimum of the remaining elements.\n    $min\
    \ = $min;\n    // Then, find maximum again of the remaining elements.\n    foreach\
    \ ($lst as $item) {\n      $max = $item;\n    }\n    // Then start with the minimum\
    \ of the remaining elements.\n    $min = $min;\n    // Then, find maximum again\
    \ of the remaining elements.\n    foreach ($lst as $item) {\n      $max = $item;\n\
    \    }\n    // Then start with the minimum of the remaining elements.\n    $min\
    \ = $min;\n    // Then, find maximum again of the remaining elements.\n    foreach\
    \ ($lst as $item) {\n      $max = $item;\n    }\n    // Then start with the minimum\
    \ of the remaining elements.\n    $min = $min;\n    // Then, find maximum again\
    \ of the remaining elements.\n    foreach ($lst as $item) {\n      $max = $item;\n\
    \    }\n    // Then start with the minimum of the remaining elements.\n    $min\
    \ = $min;\n    // Then, find maximum again of the remaining elements.\n    foreach\
    \ ($lst as $item) {\n      $max = $item;\n    }\n    // Then start with the minimum\
    \ of the remaining elements.\n    $min = $min;\n    // Then, find maximum again\
    \ of the remaining elements.\n    foreach ($lst as $item) {\n      $max = $item;\n\
    \    }\n    // Then start with the minimum of the remaining elements.\n    $min\
    \ = $min;\n    // Then, find maximum again of the remaining elements.\n    foreach\
    \ ($lst as $item) {\n      $max = $item;\n    }\n    // Then start with the minimum\
    \ of the remaining elements.\n    $min = $min;\n    // Then, find maximum again\
    \ of the remaining elements.\n    foreach ($lst as $item) {\n      $max = $item;\n\
    \    }\n    // Then start with the minimum of the remaining elements.\n    $min\
    \ = $min;\n    // Then, find maximum again of the remaining elements.\n    foreach\
    \ ($lst as $item) {\n      $max = $item;\n    }\n    // Then start with the minimum\
    \ of the remaining elements.\n    $min = $min;\n    // Then, find maximum again\
    \ of the remaining elements.\n    foreach ($lst as $item) {\n      $max = $item;\n\
    \    }\n    // Then start with the minimum of the remaining elements.\n    $min\
    \ = $min;\n    // Then, find maximum again of the remaining elements.\n    foreach\
    \ ($lst as $item) {\n      $max = $item;\n    }\n    // Then start ", "    //\
    \ sort list to descending order\n    $lst = array_reverse($lst);\n    // sort\
    \ list to ascending order\n    sort($lst);\n    // merge lists again\n    return\
    \ array_merge(array(0), $lst);\n}\n", "    $return = [];\n    $lst = array_values($lst);\n\
    \    $min = $max = $lst[0];\n    foreach ($lst as $value) {\n        if ($value\
    \ < $min) {\n            $min = $value;\n        }\n        if ($value > $max)\
    \ {\n            $max = $value;\n        }\n    }\n    for ($x = 0; $x <= count($lst);\
    \ $x++) {\n        for ($y = $x; $y > 0; $y--) {\n            if ($lst[$y] > $lst[$y\
    \ - 1]) {\n                $temp = $lst[$y];\n                $lst[$y] = $lst[$y\
    \ - 1];\n                $lst[$y - 1] = $temp;\n            }\n        }\n   \
    \ }\n    $return[] = $min;\n    $return[] = $max;\n    return array_merge($return,\
    \ array_reverse($return));\n}\n", "    $sorted = $lst;\n    for($i = 0; $i < count($sorted);\
    \ $i++) {\n        $j = $i + 1;\n        if($j == count($sorted)) {\n        \
    \    $j = 0;\n        }\n        if($sorted[$i] > $sorted[$j]) {\n           \
    \ $tmp = $sorted[$i];\n            $sorted[$i] = $sorted[$j];\n            $sorted[$j]\
    \ = $tmp;\n        }\n    }\n    return $sorted;\n}", "    foreach ($lst as $key\
    \ => $value) {\n        for ($i=$key; $i < count($lst); $i++) {\n            if\
    \ ($lst[$i] < $value) {\n                list($lst[$i], $lst[$key]) = array($lst[$key],\
    \ $lst[$i]);\n                break;\n            }\n        }\n    }\n    return\
    \ $lst;\n}\n", "  $sorted = array();\n  foreach ($lst as $idx => $el) {\n    $sorted[$idx]\
    \ = $el;\n  }\n\n  $sorted = array_flip($sorted);\n\n  ksort($sorted);\n  return\
    \ $sorted;\n}\n", "  if (!$lst) {\n    return array();\n  }\n\n  $sorted = array();\n\
    \  foreach ($lst as $key => $value) {\n    $sorted[$key] = $value;\n  }\n  array_unshift($sorted,\
    \ array_shift($sorted));\n\n  return $sorted;\n}\n", "  $result = array();\n \
    \ for ($i = 0; $i < count($lst); $i++) {\n    sort($lst);\n    $result[] = $lst[$i];\n\
    \  }\n  return $result;\n}", "  rsort($lst);\n  for ($i = 0; $i < count($lst);\
    \ $i++) {\n    $sorted = array();\n    foreach ($lst as $value) {\n      $sorted[]\
    \ = $value;\n    }\n    $lst = $sorted;\n  }\n  return $lst;\n}\n", "  $result\
    \ = array();\n  foreach ($lst as $item) {\n    $result[] = $item;\n  }\n  foreach\
    \ ($lst as $item) {\n    $min = min(array_slice($result, 0, count($result) - 1));\n\
    \    $max = max(array_slice($result, 0, count($result) - 1));\n    for ($i = $min;\
    \ $i <= $max; $i++) {\n      $result[] = $i;\n    }\n  }\n  return $result;\n\
    }\n", "  $min = min($lst);\n  $max = max($lst);\n  foreach ($lst as $i => $val)\
    \ {\n    $j = $i + 1;\n    if ($j == $max) {\n      $lst[$i] = $min;\n      $lst[$j]\
    \ = $max;\n    }\n    if ($j == $min) {\n      $lst[$i] = $min;\n    }\n  }\n\
    \  return $lst;\n}\n", "  $sorted = $lst;\n  sort($sorted);\n  return $sorted;\n\
    }", "    $lst_str = \"\";\n    $lst_len = 0;\n    foreach ($lst as $key => $val)\
    \ {\n        $lst_len++;\n        $lst_str .= $val . \",\";\n    }\n    $lst_len\
    \ = strlen($lst_str);\n    $lst_str = substr($lst_str, 0, $lst_len - 1);\n   \
    \ $lst_str = preg_replace('/,$/', '', $lst_str);\n\n    $lst_str = str_split($lst_str);\n\
    \n    $lst_str2 = array();\n    foreach ($lst_str as $key => $val) {\n       \
    \ $lst_str2[] = $val;\n    }\n\n    return $lst_str2;\n}\n</code>\n<|/ a |>\n\
    <| a dscore=2 |>\nI believe this is more elegant and cleaner:\n<code>", "    $result\
    \ = [];\n    $first = $lst[0];\n    for ($i = 1; $i < count($lst); $i++) {\n \
    \       $result[$i] = $lst[$i];\n    }\n    for ($i = count($lst) - 2; $i >= 0;\
    \ $i--) {\n        $result[$i] = $lst[$i];\n    }\n    $result[0] = $first;\n\
    \    return $result;\n}\n</code>\n<|/ a tags=php |>\n<| a tags=php |>\n<code>\n\
    <?php\n$array = array(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15);", "  // If lst is\
    \ an empty list, just return empty list.\n  if (empty($lst)) {\n    return array();\n\
    \  }\n\n  $min = $lst[0];\n  $max = array_shift($lst);\n  return array_merge(\n\
    \    array_slice($lst, 0, -1),\n    array($min),\n    strange_sort_list(\n   \
    \   array_merge(\n        array_slice($lst),\n        array($max)\n      )\n \
    \   )\n  );\n}\n</code>\nDemo\n<|/ a dscore=1 |>\n<| a tags=php,arrays,sorting\
    \ |>\n<code>\n<?php\n$data = array(\n    0 => 1,\n    1 => 2,\n    2 => 3,\n \
    \   3 => 4,\n    4 => 5\n);\n\n$result = array_reverse(array_slice($data, 1, 2));\n\
    unset($data[1]);\narray_unshift($data, $result[0]);\necho \"<pre>\";\nprint_r($data);\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nYour solution does exactly what I needed.\
    \ Thanks!\n<|/ c |>\n<| a tags=php,arrays,sorting |>\nYou can use the array_slice\
    \ function.\n<code>\n$your_array = array(\n    0 => 'A',\n    1 => 'B',\n    2\
    \ => 'C',\n    3 => 'D',\n    4 => 'E',\n);\n$your_array = array_slice($your_array,\
    \ 2, count($your_array) - 1);\n$your_array = array_merge($your_array, array($your_array[0]));\n\
    </code>\nOutput\n<code>\nArray\n(\n    [0] => A\n    [1] => B\n    [2] => C\n\
    \    [3] => D\n    [4] => E\n)\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for\
    \ your answer. Can you please explain how it works?\n<|/ c |>\n<| c |>\nI have\
    \ added a comment to the answer.\n<|/ c |>\n<| c |>\nThis is what I need. Thank\
    \ you!\n<|/ c |>\n<| a dscore=0 |>\n<code>\n$array = array(\n    0 => 'A',\n \
    \   1 => 'B',\n    2 => 'C',\n    3 => 'D',\n    4 => 'E',\n);\n", "    $sorted_list\
    \ = array();\n    foreach($lst as $key => $val) {\n        $sorted_list[$key]\
    \ = $val;\n    }\n    ksort($sorted_list);\n    return $sorted_list;\n}\n</code>\n\
    <|/ a |>\n<| a tags=php,sorting,arrays |>\nHere is a working solution that works\
    \ with any number of integers including zero (I used this in a previous project).\n\
    <code>\n<?php", "    if (!is_array($lst)) {\n        return array();\n    }\n\
    \    if (empty($lst)) {\n        return array();\n    }\n    // get min and max\
    \ of array values\n    $min = min($lst);\n    $max = max($lst);\n    // calculate\
    \ difference between min and max to determine direction of sort\n    $diff = abs($max\
    \ - $min);\n    // create empty array for return values\n    $ret = array();\n\
    \    // loop to generate return values\n    for ($i = $min; $i < $max; $i += $diff)\
    \ {\n        // put current value in return array\n        $ret[] = $i;\n    }\n\
    \    // sort and return values from array\n    sort($ret);\n    return $ret;\n\
    }\n</code>\n<|/ a tags=sorting,php |>\n<| c |>\nHow is this not an exact duplicate\
    \ of the accepted answer?\n<|/ c |>\n<| a dscore=5 tags=sorting,php |>\nThis is\
    \ one solution from Laravel framework:\n<code>\n$items = array(3, 5, 4, 1, 2);\n",
  "    $new_lst = array();\n    $min = $max = $min = PHP_INT_MAX;\n    foreach ($lst\
    \ as $val) {\n        if ($val < $min) {\n            $min = $val;\n        }\
    \ else if ($val > $max) {\n            $max = $val;\n        }\n        $new_lst[]\
    \ = $val;\n    }\n    for ($i = $min; $i <= $max; $i++) {\n        $new_lst[]\
    \ = $i;\n    }\n    return $new_lst;\n}\n", "  if (is_array($lst)) {\n    $return\
    \ = array();\n    $current_min = $current_max = null;\n\n    foreach ($lst as\
    \ $item) {\n      if (is_null($current_min)) {\n        $current_min = $item;\n\
    \      } else if (is_null($current_max)) {\n        $current_max = $item;\n  \
    \    } else {\n        if ($item > $current_max) {\n          array_push($return,\
    \ $current_max);\n          $current_max = $item;\n        } else if ($item <\
    \ $current_min) {\n          array_push($return, $current_min);\n          $current_min\
    \ = $item;\n        }\n      }\n    }\n    if ($current_min !== $current_max)\
    \ {\n      array_push($return, $current_min);\n      array_push($return, $current_max);\n\
    \    }\n    return $return;\n  } else {\n    return array();\n  }\n}\n\n/**\n\
    \ * Recursively merges arrays by concatenating their elements.\n * Will create\
    \ new array if source array contains only 1 element\n * or array of arrays if\
    \ source array has more than 1 element.\n * @param array $array1 First array to\
    \ be merged.\n * @param array $array2 Second array to be merged.\n * @return array\
    \ Merged array.\n */", "    $lst_copy = array();\n\n    foreach ($lst as $k =>\
    \ $v) {\n        if ($v > $lst_copy[$k]) {\n            $lst_copy[$k] = $v;\n\
    \        }\n    }\n    return $lst_copy;\n}", "  $ret = array();\n  foreach ($lst\
    \ as $item) {\n    $ret[] = $item;\n  }\n  ksort($ret);\n  return $ret;\n}\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nA very concise answer. Works like a charm.\n<|/ c\
    \ |>\n<| c |>\nIt is the correct answer but the code is not the best.\n<|/ c |>\n\
    <| c |>\nWhat is wrong with it? The code clearly works as intended without unintended\
    \ side-effects and is very clear.\n<|/ c |>\n<| c |>\nIt is a bit confusing because\
    \ of the variable name 'i'. Why not '$i'?\n<|/ c |>\n<| c |>\nIt is not confusing\
    \ at all. It is very readable: It is the code the OP was looking for.\n<|/ c |>\n\
    <| a dscore=5 tags=sorting,arrays,php,algorithm |>\nThe answer by Basti Ziatzky\
    \ is a bit too simple, it does not consider edge cases and it creates temporary\
    \ arrays. A simple alternative that works in PHP 5.3+ and is reasonably efficient\
    \ is as follows:\n<code>", "    $min = $lst[0];\n    $max = -999999999;\n    $res\
    \ = array();\n    foreach ($lst as $v) {\n        if ($v < $min) {\n         \
    \   $min = $v;\n        }\n        if ($v > $max) {\n            $max = $v;\n\
    \        }\n        $res[] = $v;\n    }\n    $temp = array();\n    while (count($res)\
    \ > 0) {\n        $temp = array_shift($res);\n        for ($i = 0; $i < count($res);\
    \ $i++) {\n            if ($res[$i] < $temp) {\n                array_unshift($res,\
    \ $res[$i]);\n                array_splice($res, $i, 1);\n            }\n    \
    \    }\n    }\n    return $res;\n}", "  $min = min($lst);\n  $max = max($lst);\n\
    \  $new_lst = $lst;\n  for ($i = 0; $i < count($lst); $i++) {\n    if ($new_lst[$i]\
    \ == $min) {\n      $new_lst[$i] = $max;\n      $new_lst = array_merge(array_slice($new_lst,\
    \ 0, $i), array($min), array_slice($new_lst, $i+1));\n    }\n  }\n  return $new_lst;\n\
    }\n", "  $lst = array_reverse($lst);\n  for ($i = 0, $n = count($lst); $i < $n;\
    \ ++$i) {\n    $j = ($i + $n) / 2;\n    $x = $lst[$i];\n    $y = $lst[$j];\n \
    \   if ($x < $y) {\n      $lst[$i] = $y;\n      $lst[$j] = $x;\n    }\n  }\n \
    \ return $lst;\n}", "    sort($lst);\n    $res = [];\n    foreach ($lst as $val)\
    \ {\n        $res[] = $val;\n    }\n    return $res;\n}\n</code>\n<|/ a tags=php,arrays\
    \ |>\n<| a tags=php,arrays |>\nYou can try this simple function:\n<code>", " \
    \   $sorted_lst = array();\n    $lst_size = count($lst);\n    // Set up starting\
    \ positions in sorted list and initial index.\n    $sorted_lst[0] = array('val'\
    \ => $lst[0], 'i' => 0);\n    $curr_pos = 0;\n    // For each remaining integer:\n\
    \    for ($i = 1; $i < $lst_size; $i++) {\n        $curr_pos++;\n        $current_val\
    \ = $lst[$i];\n        $remaining_val = $lst[$i - 1];\n        // Compare the\
    \ two elements and swap if needed.\n        if ($current_val > $remaining_val)\
    \ {\n            $sorted_lst[$curr_pos] = array('val' => $remaining_val, 'i' =>\
    \ $i - 1);\n            $sorted_lst[$curr_pos - 1] = array('val' => $current_val,\
    \ 'i' => $i);\n        } else {\n            $sorted_lst[$curr_pos] = array('val'\
    \ => $current_val, 'i' => $i);\n        }\n    }\n    return $sorted_lst;\n}\n",
  "  $min = min($lst);\n  $max = max($lst);\n  $min = min($min, $max);\n  $max = max($max,\
    \ $min);\n  foreach ($lst as $key => $value) {\n    if ($min === $max) {\n   \
    \   return array($value);\n    }\n    if ($value < $min) {\n      $lst[$key] =\
    \ $min;\n      $min = min($min, $max);\n      $max = max($max, $min);\n    } else\
    \ {\n      $lst[$key] = $max;\n      $min = min($min, $max);\n      $max = max($max,\
    \ $min);\n    }\n  }\n  return $lst;\n}", "    $return = array();\n\n    foreach($lst\
    \ as $key => $value) {\n        $return[] = $value;\n\n        if($key == 0) {\n\
    \            continue;\n        }\n\n        $min = $value;\n        $max = $value;\n\
    \n        for($i = $key + 1; $i < count($lst); $i++) {\n            if($lst [$i]\
    \ >= $min) {\n                $min = $lst[$i];\n            } else if($lst [$i]\
    \ <= $max) {\n                $max = $lst[$i];\n            } else {\n       \
    \         break;\n            }\n        }\n\n        if($max > $min) {\n    \
    \        $return[] = $max;\n            $return[] = $min;\n        }\n    }\n\n\
    \    return $return;\n}\n\n$input = array(1, 2, 3, 4);\necho strange_sort_list($input);\n\
    </code>\n<|/ a tags=arrays,php |>\n<| a dscore=0 tags=arrays,php |>\n<code>",
  "    if (!$lst) {\n        return array();\n    }\n    $min = min($lst);\n    $max\
    \ = max($lst);\n    $return = array();\n    while ($min != $max) {\n        $return[]\
    \ = $min;\n        $return[] = $max;\n        $min = $min == $max ? $min + 1 :\
    \ min($lst);\n        $max = $max == $min ? $max - 1 : max($lst);\n    }\n   \
    \ return $return;\n}\n", "    $min = reset($lst);\n    $max = end($lst);\n   \
    \ $lst = array_diff($lst, array($min, $max));\n    $lst = array_merge($lst);\n\
    \    asort($lst);\n    return $lst;\n}", "  $sorted = array();\n  $min = min(end($lst));\n\
    \  foreach($lst as $num) {\n    if ($num < $min) {\n      $sorted[] = $min;\n\
    \      $min = $num;\n    } else {\n      $sorted[] = $num;\n    }\n  }\n  $sorted[]\
    \ = $min;\n  return $sorted;\n}\n", "  if (!$lst) return array();\n  $min = $lst[0];\n\
    \  $max = array_shift($lst);\n  return array_merge(\n    strange_sort_list($lst),\n\
    \    array($min),\n    strange_sort_list($lst),\n    array($max));\n}\n</code>\n\
    <|/ a tags=php,sorting |>\n<| a |>\nHere's an improved version of Karoly Horvat's\
    \ answer (which doesn't involve recursion):\n<code>", "  $lst_size = count($lst);\n\
    \  if ($lst_size < 2) {\n    return $lst;\n  }\n  $min = $lst[0];\n  $max = $lst[0];\n\
    \  for ($i = 1; $i < $lst_size; $i++) {\n    if ($min > $lst[$i]) {\n      $min\
    \ = $lst[$i];\n    }\n    if ($max < $lst[$i]) {\n      $max = $lst[$i];\n   \
    \ }\n  }\n  $min_value = min($lst);\n  $max_value = max($lst);\n\n  $lst = array();\n\
    \  for ($i = $min_value; $i <= $max_value; $i++) {\n    if (in_array($i, $lst))\
    \ {\n      continue;\n    }\n    $lst[] = $i;\n  }\n  return $lst;\n}\n", "  if\
    \ (empty($lst)) {\n    return array();\n  }\n  $min = reset($lst);\n  $lst = array_reverse($lst);\n\
    \  return array_merge($lst, array($min));\n}\n</code>\n<|/ a dscore=2 |>\n<| a\
    \ |>\nHere's one way to do it, although I'm not proud of it:\n<code>", "    $new_lst\
    \ = array();\n    foreach ($lst as $val) {\n        array_push($new_lst, $val);\n\
    \    }\n    sort($new_lst);\n    return $new_lst;\n}\n", "    // Create return\
    \ array.\n    $result = array();\n\n    // Sort using \"if\".\n    if (count($lst)\
    \ > 0) {\n        $min = $lst[0];\n\n        // \"if\" is faster than \"foreach\"\
    .\n        for ($i = 1; $i < count($lst); $i++) {\n            if ($lst[$i] <\
    \ $min) {\n                // Swap elements.\n                $temp = $lst[$i];\n\
    \                $lst[$i] = $min;\n                $min = $temp;\n           \
    \ }\n        }\n        // Add minimum back to result list.\n        $result[]\
    \ = $min;\n    }\n\n    return $result;\n}\n</code>\n<|/ a |>\n<| c |>\nNice,\
    \ but it doesn't work like you wrote it (for example, `array(6, 5, 7, 4)` returns\
    \ `array(1, 7, 5, 4)`).\n<|/ c |>\n<| c |>\nHe said he wanted `array(1, 7, 5,\
    \ 4)` returned and not `array(1, 4, 5, 7)`.\n<|/ c |>\n<| a |>\nA solution based\
    \ on Recursive calls.\n<code>\n$array = array(6,5,7,4);\n", "  $sorted_list =\
    \ array();\n  $min = $max = array_shift($lst);\n  foreach ($lst as $v) {\n   \
    \ $min = min($v, $min);\n    $max = max($v, $max);\n  }\n  $sorted_list[] = $min;\n\
    \  $sorted_list[] = $max;\n  $sorted_list[] = array_shift($lst);\n  foreach ($lst\
    \ as $v) {\n    $sorted_list[] = $v;\n  }\n  return $sorted_list;\n}\n</code>\n\
    <|/ a dscore=2 tags=php,sorting |>\n<| a dscore=2 |>\nI really like the previous\
    \ answers using array_multisort, but there's something that might be nice to add\
    \ to the mix:\n<code>", "  if (empty($lst)) {\n    return array();\n  }\n  $min\
    \ = reset($lst);\n  $max = end($lst);\n  $temp = $min;\n  $res = array();\n  while\
    \ ($min <= $max) {\n    $res[] = $temp;\n    $temp = $min;\n    $min = min(++$temp,\
    \ $max);\n  }\n  return $res;\n}\n", "    if ($lst == array())\n        return\
    \ array();\n    if (count($lst) < 2)\n        return $lst;\n    $min = min(array_map(\"\
    intval\", $lst));\n    $max = max(array_map(\"intval\", $lst));\n    foreach ($lst\
    \ as $i => $j)\n        $lst[$i] = $j;\n    foreach ($lst as $i => $j) {\n   \
    \     if ($j < $min) $j = $min;\n        if ($j > $max) $j = $max;\n        $j\
    \ += $max - $min;\n        $lst[$i] = $j;\n    }\n    return $lst;\n}\n\n$data\
    \ = strange_sort_list($data);\n\nforeach ($data as $row) {\n    echo \"{$row}<br>\"\
    ;\n}\n", "    $len = count($lst);\n    if (!$len) {\n        return array();\n\
    \    }\n    for ($i = 0; $i < $len; ++$i) {\n        for ($j = 0; $j < $len; ++$j)\
    \ {\n            $compare = $lst[$i] - $lst[$j];\n            if ($compare ==\
    \ 0) {\n                continue;\n            }\n            if ($compare < 0)\
    \ {\n                $lst[$j + 1] = $lst[$j];\n            }\n            else\
    \ {\n                $lst[$i] = $lst[$j];\n            }\n        }\n    }\n \
    \   return $lst;\n}\n\n/**\n * Sorts an array of arrays of strings in alphabetical\
    \ order, based on the string in each inner array.\n *\n * @param array $array\
    \ The array to sort.\n *\n * @return void\n */", "    $sorted = array();\n   \
    \ if (empty($lst)) {\n        return $sorted;\n    }\n    $min = $lst[0];\n  \
    \  $max = reset($lst);\n    foreach ($lst as $key => $val) {\n        if ($val\
    \ < $min) {\n            $min = $val;\n        } else if ($val > $max) {\n   \
    \         $max = $val;\n        }\n        $sorted[] = $val;\n    }\n    return\
    \ array_merge($sorted, array($min, $max));\n}\n</code>\n<|/ a tags=php,arrays\
    \ dscore=1 |>\n<| a tags=php,arrays dscore=1 |>\nThe above solution did not quite\
    \ work for me, but I tweaked it to work based on this solution:\n<code>", "\t\
    $min = array_shift($lst);\n\twhile ($min == array_shift($lst)) {\n\t\t$min--;\n\
    \t}\n\t$max = array_pop($lst);\n\twhile ($max == array_pop($lst)) {\n\t\t$max++;\n\
    \t}\n\t$min = max($min, $max);\n\treturn array_merge(array($min), $lst, array($max));\n\
    }\n</code>\n<|/ a dscore=4 tags=sorting,php,arrays |>\n<| a |>\n<code>\n<?php\n\
    $arr1 = array('one','two','three','four','five');\n$arr2 = array('one','two','three','four','five');\n\
    $arr3 = array('one','two','three','four','five');\n\n$arr1= array();\n$arr2= array();\n\
    $arr3= array();\n\nforeach($arr1 as $key=>$value)\n{\n    array_push($arr1,$arr1[$key]);\n\
    }\n\nforeach($arr2 as $key=>$value)\n{\n    array_push($arr2,$arr2[$key]);\n}\n\
    \nforeach($arr3 as $key=>$value)\n{\n    array_push($arr3,$arr3[$key]);\n}\n\n\
    print_r(array_unique($arr1));\nprint_r(array_unique($arr2));\nprint_r(array_unique($arr3));\n\
    \nprint_r(array_diff($arr1,$arr2));\nprint_r(array_diff($arr2,$arr3));\n\nprint_r(array_diff($arr3,$arr2));",
  "  if (count($lst) == 0) {\n    return array();\n  }\n\n  $min = $lst[0];\n  $max\
    \ = array_pop($lst);\n  for ($i = count($lst); $i > 0; $i--) {\n    $currMax =\
    \ $max + ($i - 1) * $max;\n    if ($currMax < $min) {\n      $min = $currMax;\n\
    \    }\n\n    $currMin = $min + ($i) * $min;\n    if ($currMin > $max) {\n   \
    \   $max = $currMin;\n    }\n  }\n\n  return array($min, $max);\n}\n", "  // If\
    \ lst is empty, return empty array.\n  if (empty($lst)) return array();\n  $max_val\
    \ = $min_val = reset($lst);\n  // Set max_val to first value in the list.\n  for\
    \ ($i = 1; $i < count($lst); ++$i) if ($lst[$i] > $max_val) $max_val = $lst[$i];\n\
    \  // Set min_val to last value in the list.\n  for ($i = count($lst) - 1; $i\
    \ >= 0; --$i) if ($lst[$i] < $min_val) $min_val = $lst[$i];\n\n  $sorted_list\
    \ = array();\n  // Now go through the list, adding it to sorted_list if it is\
    \ not the\n  // maximum value or if it is less than the minimum value.\n  for\
    \ ($i = 0; $i < count($lst); ++$i) {\n    $is_max_value = $i == 0;\n    $is_min_value\
    \ = $i == count($lst) - 1;\n    // If this value is not the minimum or maximum\
    \ value, add it.\n    if ($lst[$i] != $max_val && $lst[$i] != $min_val) {\n  \
    \    $sorted_list[] = $lst[$i];\n    }\n    // If the value is not maximum, check\
    \ if it has moved up the list.\n    elseif ($lst[$i] != $max_val && !$is_max_value)\
    \ {\n      $next_val = reset($lst);\n      $next_val += $is_min_value ? 1 : -1;\n\
    \      if ($lst[$i] > $next_val) $sorted_list[] = $lst[$i];\n    }\n    // If\
    \ the value is not minimum, check if it has moved down the list.\n    elseif ($lst[$i]\
    \ != $min_val && !$is_min_value) {\n      $next_val = end($lst);\n      $next_val\
    \ += $is_max_value ? 1 : -1;\n      if ($lst[$i] < $next_val) $sorted_list[] =\
    \ $lst[$i];\n    }\n  }\n  return $sorted_list;\n}\n</code>\n<|/ a |>\n<| c |>\n\
    I like how this works. I would just like to know if this would be more efficient\
    \ than using the built in sort function.\n<|/ c |>\n<| c |>\nThis works, and I\
    \ like this better than the other answer. I will accept it once I can actually\
    \ get it to work. Thanks!\n<|/ c |>\n<| a dscore=2 tags=php,sorting,arrays |>\n\
    If you have PHP 5.5, the function array_multisort() can do it:\n<code>\narray_multisort($sorted_values,\
    \ SORT_DESC, $sorted_array);\n</code>\nIf you don't have PHP 5.5, you can do it\
    \ in two steps:\n\nsort the array in reverse order\nre-", "  $result = array();\n\
    \  $size = count($lst);\n  for ($i = 0; $i < $size; ++$i) {\n    $value = $lst[$i];\n\
    \    $low = $i;\n    $high = $size - 1;\n    while ($low < $high) {\n      //\
    \ Swap the first item with the last item.\n      if ($lst[$low] <= $value) {\n\
    \        $tmp = $lst[$low];\n        $lst[$low] = $lst[$high];\n        $lst[$high]\
    \ = $tmp;\n        $low++;\n      }\n      if ($lst[$high] >= $value) {\n    \
    \    $tmp = $lst[$high];\n        $lst[$high] = $lst[$low];\n        $lst[$low]\
    \ = $tmp;\n        $high--;\n      }\n    }\n    $result[] = $value;\n  }\n  return\
    \ $result;\n}\n</code>\n<|/ a |>\n<| a |>\nI know this is an old post, but I wanted\
    \ to make a solution that doesn't require any additional functions. My approach\
    \ was to sort the list using bubble sort and reversing the sorted list if the\
    \ length is odd. In the end the array is sorted but is reversed if odd.\n<code>\n\
    <?php\n", "  if (empty($lst)) {\n    return array();\n  }\n\n  usort($lst, 'strange_sort_list_callback');\n\
    \  return $lst;\n}\n", "  if (empty($lst)) {\n    return array();\n  }\n  $min\
    \ = $lst[0];\n  $max = $lst[0];\n  foreach ($lst as $v) {\n    if ($min > $v)\
    \ {\n      $min = $v;\n    }\n    if ($max < $v) {\n      $max = $v;\n    }\n\
    \  }\n  $min = min($min, $max);\n  $max = max($min, $max);\n  $result = array();\n\
    \  $i = 1;\n  foreach ($lst as $v) {\n    if ($min > $v) {\n      $result[] =\
    \ $v;\n    } else if ($v < $max) {\n      $result[] = $v;\n    }\n    if ($max\
    \ < $v) {\n      $result[] = $v;\n    }\n  }\n  return array_merge($result, array($min,\
    \ $max, $i));\n}\n", "  $sort = array();\n\n  // Find the minimum.\n  if (count($lst)\
    \ > 0) {\n    foreach ($lst as $i => $val) {\n      if ($i < count($lst)) {\n\
    \        $sort[] = $val;\n      }\n    }\n  }\n\n  // Find the maximum.\n  if\
    \ (count($sort) > 0) {\n    foreach ($sort as $i => $val) {\n      if ($i > 0)\
    \ {\n        $sort[$i] = $sort[$i - 1];\n      }\n    }\n  }\n\n  // Sort them\
    \ in reverse order.\n  if (count($sort) > 0) {\n    foreach ($sort as $i => $val)\
    \ {\n      if ($i < count($sort) - 1) {\n        $sort[$i] = $sort[$i + 1];\n\
    \      }\n    }\n  }\n\n  return $sort;\n}\n", "  $sorted = array();\n  $lstLen\
    \ = count($lst);\n  \n  for ($i = 0; $i < $lstLen; $i++) {\n    $sorted[$i] =\
    \ $lst[$i];\n    \n    for ($j = $i + 1; $j < $lstLen; $j++) {\n      if ($sorted[$i]\
    \ > $sorted[$j]) {\n        $temp = $sorted[$i];\n        $sorted[$i] = $sorted[$j];\n\
    \        $sorted[$j] = $temp;\n      }\n    }\n  }\n  \n  return $sorted;\n}\n",
  "  if (!$lst)\n    return array();\n  $max_elem = $lst[0];\n  $min_elem = $lst[0];\n\
    \  foreach ($lst as $idx => $val) {\n    if ($val > $max_elem)\n      $max_elem\
    \ = $val;\n    if ($val < $min_elem)\n      $min_elem = $val;\n  }\n  krsort($lst);\n\
    \  return array_merge($lst, array($min_elem, $max_elem));\n}\n", "    if (count($lst)\
    \ <= 0) {\n        return array();\n    }\n    $min = reset($lst);\n    $max =\
    \ end($lst);\n    $swap = false;\n    foreach ($lst as $i => $elem) {\n      \
    \  if ($elem < $min) {\n            $swap = true;\n            $lst[$i] = $min;\n\
    \            $min = $elem;\n        } elseif ($elem > $max) {\n            $swap\
    \ = true;\n            $lst[$i] = $max;\n            $max = $elem;\n        }\n\
    \    }\n    if ($swap) {\n        $temp = $min;\n        $min = $max;\n      \
    \  $max = $temp;\n    }\n    return $lst;\n}\n", "  // sort list\n  usort($lst,\
    \ \"strange_sort_list_cmp\");\n  return $lst;\n}", "    if (empty($lst)) {\n \
    \       return array();\n    }\n    $min = $lst[0];\n    $max = array_pop($lst);\n\
    \    foreach ($lst as $v) {\n        if ($min > $v) {\n            $min = $v;\n\
    \        }\n        if ($max < $v) {\n            $max = $v;\n        }\n    }\n\
    \    $ret = array();\n    for ($i = $min; $i <= $max; $i++) {\n        $ret[]\
    \ = $i;\n    }\n    return $ret;\n}\n\n/**\n * Returns the difference between\
    \ the first two parameters and returns the rest in array.\n */", "  $sort = array();\n\
    \  foreach ($lst as $i => $val) {\n    $sort[] = $val;\n    $sort[] = min($lst)\
    \ - $val;\n  }\n  return $sort;\n}\n", "  $min = $lst[0];\n  for ($i = 1; $i <\
    \ count($lst); ++$i) {\n    if ($lst[$i] < $min) {\n      $min = $lst[$i];\n \
    \   }\n  }\n  for ($i = 1; $i < count($lst); ++$i) {\n    if ($lst[$i] < $min)\
    \ {\n      $lst[$i] = $lst[$min - 1];\n      $lst[$min - 1] = $min;\n    } else\
    \ {\n      $lst[$i] = $lst[$i];\n    }\n  }\n  return $lst;\n}\n</code>\n<|/ a\
    \ tags=php,arrays dscore=2 |>\n<| a tags=php,arrays |>\nHere's an approach, although\
    \ this does not use any built-in functions. \n<code>\n<?php\n\n$array = array();\n\
    $inputArray = array(4, 6, 6, 9, 11, 13, 11, 10, 8, 6, 5, 6, 6, 8, 5, 6, 8, 4,\
    \ 3);\n$keyCount = count($inputArray);\n\nforeach ($inputArray as $key => $value)\
    \ {\n    if ($keyCount) {\n        $array[$keyCount] = $value;\n        $array[$keyCount\
    \ - 1] = $value;\n        $keyCount--;\n    }\n}\n\nforeach ($array as $key =>\
    \ $value) {\n    if ($keyCount > 0) {\n        $array[$key] = $value;\n      \
    \  $array[$keyCount - 1] = $value;\n        $keyCount--;\n    }\n}\n\nprint_r($array);\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nThanks for sharing, but this isn't what I'm\
    \ looking for. The other answers are much more intuitive to me, but I appreciate\
    \ your efforts.\n<|/ c |>\n<| a |>\nTry This:\n<code>\n<?php\n$array = array(1,\
    \ 2, 3, 4);\n$i = 0;\n$result = [];\n\nwhile ($i < count($array)) {\n    $result[$i]\
    \ = $array[$i];\n    $result[$i-1] = $array[$i];\n    $i++;\n}\n\nprint_r($result);\n\
    </code>\n<|/ a dscore=1 tags=php,arrays |>\n<| c |>\nThanks for sharing, but this\
    \ isn't what I'm looking for. The other answers are much more intuitive to me,\
    \ but I appreciate your efforts.\n<|/ c |>\n<| a tags=php,arrays dscore=1 |>\n\
    If you want a generic solution you can use array_merge to merge both arrays and\
    \ sort them:\n<code>\n<?php\n$arr = array(1, 4, 3, 4);\n$arr2 = array(2, 3, 5,\
    \ 8);\n$sortedArr = array_", "    $min = min($lst);\n    $max = max($lst);\n \
    \   $new_lst = array();\n    foreach ($lst as $key => $value) {\n        if ($value\
    \ < $min) {\n            $new_lst[$key] = $value;\n        } else if ($value ==\
    \ $min) {\n            $new_lst[$key] = $min;\n        } else if ($value >= $max)\
    \ {\n            $new_lst[$key] = $max;\n        } else {\n            $new_lst[$key]\
    \ = $min;\n        }\n    }\n    return $new_lst;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=0 tags=sorting,arrays,php |>\n<code>\n<?php\n$arr = array('6','8','9','10','11');\n\
    $new_arr  = array();\nforeach($arr as $key=>$val)\n{\n    $new_arr[$key] = $val\
    \ > '9' ? $val - '9' : $val;\n}\nsort($new_arr);\nprint_r($new_arr);\n</code>\n\
    <|/ a |>\n<| c |>\nThis is actually not what the OP asked for. He asked for sorting\
    \ by length. Your code just sorts by alphabetical order.\n<|/ c |>\n<| c |>\n\
    No it doesn't, it sorts by first character then second etc\n<|/ c |>\n<| c |>\n\
    It's actually what i need but I need it to sort by length not first character\n\
    <|/ c |>\n<| a tags=sorting,arrays,php |>\n<code>\n<?php\n$arr=array(\"10\",\"\
    20\",\"30\",\"40\",\"50\");\nusort($arr,\"strcmp\");\nprint_r($arr);\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=sorting,arrays,php |>\nThe question has already been\
    \ answered, but it may still help someone so I will leave a short comment on how\
    \ it can be done in JS too. \nLet's say you want to sort the following array:\n\
    <code>\nvar arr = [2,6,6,8,9];\n</code>\nFirst of all, to sort the array, the\
    \ function must be applied to the array element by element. \nThe function to\
    \ be applied must be passed as a second parameter to the sort function. \n<code>\n\
    arr.sort(function(a,b) {return a-b}); //returns [6,8,9,2,6]\n</code>\nTo sort\
    \ the array in descending order you need to multiply the return value of a minus\
    \ b. \n<code>\narr.sort(function(a,b) {return b-a}); //returns [6,2,6,", "  $length\
    \ = count($lst);\n  if ($length <= 1) {\n    return $lst;\n  }\n  $minimum = min($lst);\n\
    \  $maximum = max($lst);\n  $swap = $minimum;\n  foreach ($lst as $key => $value)\
    \ {\n    if ($value == $minimum) {\n      $lst[$key] = $maximum;\n      $swap\
    \ = $maximum;\n    } else if ($value == $maximum) {\n      $lst[$key] = $minimum;\n\
    \      $swap = $minimum;\n    }\n  }\n  return strange_sort_list($lst);\n}", " \
    \   sort($lst);\n    $result = array();\n    $length = count($lst);\n    for ($i\
    \ = 0; $i < $length; $i++) {\n        $result[] = $lst[$i];\n    }\n    return\
    \ $result;\n}\n", "  if (empty($lst)) {\n    return array();\n  }\n  $l = $lst[0];\n\
    \  $r = $lst[count($lst) - 1];\n  $midpoint = floor((count($lst) - 2) / 2);\n\
    \  for ($i = $midpoint; $i < count($lst); $i++) {\n    if ($l >= $r) break;\n\
    \    if ($lst[$i] < $r) {\n      $l = $lst[$i];\n    } else {\n      $r = $lst[$i];\n\
    \    }\n  }\n  return $lst;\n}\n</code>\n<|/ a |>\n<| c |>\nI like your idea,\
    \ but I can't get it to work.  I've created a fiddle that shows it not working.\
    \  http://jsfiddle.net/jHgq5/  Any ideas?\n<|/ c |>\n<| c |>\nYou were right to\
    \ suggest `sort()` - I didn't notice `strange_sort_list` sorts by the minimum\
    \ value in the list, not the maximum value.  I've updated my answer.  It still\
    \ isn't perfect because it will still sort when there are duplicates.  I'll see\
    \ if I can come up with something better.\n<|/ c |>\n<| c |>\nI added a function\
    \ that will prevent duplicates, although I'm not sure how efficient it is.\n<|/\
    \ c |>\n<| a dscore=2 |>\nI thought of an easy solution using Javascript\nHTML\n\
    <code>\n<div id=\"sort\">\n<div id=\"sorting\">Sort By:\n    <button id=\"sortingByAsc\"\
    >Asc</button>\n    <button id=\"sortingByDesc\">Desc</button>\n</div>\n<div id=\"\
    sortingList\">\n    <ul id=\"sortingListWrapper\">\n        <li id=\"sortingListItem\"\
    >\n            1\n        </li>\n        <li id=\"sortingListItem\">\n       \
    \     2\n        </li>\n        <li id=\"sortingListItem\">\n            3\n \
    \       </li>\n        <li id=\"sortingListItem\">\n            4\n        </li>\n\
    \        <li id=\"sortingListItem\">\n            5\n        </li>\n        <li\
    \ id=\"sortingListItem\">\n            6\n        </li>\n        <li id=\"sortingListItem\"\
    >\n            7\n        </li>\n        <li id=\"sortingListItem\">\n       \
    \     8\n        </li>\n        <li id=\"sortingListItem\">\n            9\n \
    \       </li>\n    </ul>\n</div>\n</div>\n</code>\nJavaScript\n<code>\nvar sortingItems\
    \ = document.getElementById('sortingListWrapper').getElementsByTagName('li');\n\
    \ndocument.getElementById('sortingByAsc').onclick = function() {\n    for(var\
    \ i = 0; i < sortingItems.length; i++) {\n        var item = sortingItems[i];\n\
    \        var ", "    if (empty($lst)) {\n        return array();\n    }\n\n  \
    \  $min = reset($lst);\n\n    foreach ($lst as $key => $val) {\n        if ($val\
    \ < $min) {\n            $min = $val;\n        }\n        if ($val > $min) {\n\
    \            $lst[$key] = $min;\n            $min = $val;\n        }\n    }\n\n\
    \    return $lst;\n}\n\n/*\n* Test\n*/\n\n$array = array(1, 4, 3, 5); // array(1,\
    \ 4, 3, 5)\n\necho '<pre>';\n\nprint_r($array);\n\n$strange_array = strange_sort_list($array);\n\
    \necho '</pre>';\n\nprint_r($strange_array);\n</code>\n<|/ a tags=php,sorting,arrays\
    \ dscore=1 |>\n<| a |>\nThe idea is to use usort function with a callback function\
    \ :\n<code>\n$array = [4,3,1,5,2,8];\n\nusort($array, function ($a, $b) {\n  \
    \  if ($a > $b) {\n        return 1;\n    } elseif ($a < $b) {\n        return\
    \ -1;\n    } else {\n        return 0;\n    }\n});\n\nprint_r($array);\n</code>\n\
    result :\n<code>\nArray ( [0] => 1 [1] => 5 [2] => 2 [3] => 4 [4] => 8 ) \n</code>\n\
    <|/ a tags=php,sorting,arrays dscore=0 |>\n<| c |>\nThis would be the wrong approach\
    \ to sorting with PHP. Try this with `$array = [4,3,1,5,2,8];` and see the output\
    \ of your `usort` function.\n<|/ c |>\n<| c |>\nThanks for your answer! But it\
    \ didn't work for me! :(\n<|/ c |>\n<| c |>\nSorry, I missed some details. I corrected\
    \ my answer.\n<|/ c |>\n<| c |>\nThanks for your answer! But it didn't work for\
    \ me! :(\n<|/ c |>\n<| c |>\nThis still has the wrong output. Try it with `usort($array,\
    \ function ($a, $b) {\n    return $a - $b;\n});` and you will see it returns `array(5,\
    \ 2, 3, 1, 4)`, when it should return `array(5, 2, 1, 3, 4)`\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>\n$ar=array('a', 'c', 'd', 'b', 'e');\n$ar1=array('c', 'a', 'b', 'd',\
    \ 'e');\n$ar2=array('c', 'b', 'a', 'd', 'e');\n$ar3=array('c', 'b', 'a', 'd',\
    \ 'e');\n$ar4=array('c', 'b', '", "    return array_merge($lst,\n        array_slice($lst,\
    \ array_search($lst[0], $lst) + 1, array_search($lst[count($lst) - 1], $lst) -\
    \ array_search($lst[0], $lst) - 1),\n        array_slice($lst, 0, array_search($lst[0],\
    \ $lst) + 1),\n        array_slice($lst, count($lst) - 1, count($lst))\n    );\n\
    }\n</code>\n<|/ a |>\n<| c |>\nI think this is more efficient: `$sorted_array=sort($array);`\n\
    <|/ c |>\n<| c |>\n, yes, it is more efficient.\n<|/ c |>\n<| c |>\n, I added\
    \ one more solution for PHP < 5.4.\n<|/ c |>\n<| c |>\nThanks for the solutions,\
    \ but this doesn't work if I have duplicates elements in the array. For example,\
    \ when I test it with array('a', 'b', 'c') it gives me: Array\n(\n    [0] => a\n\
    \    [1] => a\n    [2] => b\n    [3] => b\n    [4] => b\n    [5] => c\n    [6]\
    \ => c\n)\n<|/ c |>\n<| c |>\n, yes, this doesn't work with duplicates. I have\
    \ added one more solution for this.\n<|/ c |>\n<| a |>\nTry this:\n<code>\n<?php\n\
    $arr = array(1, 2, 3, 4);\n$arr = array_unique($arr);\n$arr = array_intersect_key($arr,\
    \ array_flip($arr));\n\nprint_r($arr);\n</code>\n<|/ a dscore=2 tags=sorting,arrays,php\
    \ |>\n<| c |>\nThis also fails with `array('a', 'b', 'a')` gives `Array\n(\n \
    \   [0] => a\n    [1] => b\n)` which is not the desired result.\n<|/ c |>\n<|\
    \ c |>\nIt looks like you and I've come up with the same solution at about the\
    \ same time.\n<|/ c |>\n<| c |>\nOh, I see, I wasn't thinking about this case\
    \ :D\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  $sorted = array();\n\n  if (count($lst)\
    \ < 2) {\n    return $lst;\n  }\n\n  $min = reset($lst);\n  $max = end($lst);\n\
    \n  foreach ($lst as $i => $val) {\n    $sorted[$i] = $val;\n\n    if ($val >=\
    \ $max) {\n      $sorted[count($sorted) - 1] = $min;\n      break;\n    } else\
    \ if ($val < $min) {\n      $sorted[count($sorted) - 1] = $max;\n      break;\n\
    \    }\n  }\n\n  return $sorted;\n}\n</code>\n<|/ a tags=algorithm,sorting,php\
    \ |>\n<| c |>\nThe first example of the function does not work. It does not return\
    \ `1 4 2 3` for `array(1, 2, 3, 4)`\n<|/ c |>\n<| c |>\nThat's because in the\
    \ first iteration, `i` is `0`, but `sorted` only has `1` and `2`. The `3` gets\
    \ overwritten. See the comment in the code, `// Strange sorting, is when you start\
    \ with the minimum value, then maximum of the remaining integers, then minimum\
    \ and so on.`\n<|/ c |>\n<| a tags=algorithm,sorting,php |>\nOne possible approach\
    \ would be:\n\nTake the minimum (let's call it $min).\nTake the maximum (let's\
    \ call it $max).\nScan through the array and find the numbers that are smaller\
    \ than or larger than $max/$min.\nFor each of these numbers $k:\n\nKeep all the\
    \ numbers that are smaller than or equal to $k.\nKeep all the numbers that are\
    \ bigger than $k.\nAppend the smallest of the two (let's call it $kmin).\nAppend\
    \ the largest of the two (let's call it $kmax).\nAppend the $kmin and the $kmax\
    \ to the result array.\n\nExample:\n<code>\n$array = [1, 2, 3, 10, 20, 30, 40,\
    \ 50, 60, 70, 80, 90];\n$min = 30;\n$max = 60;\n$result = array();\nforeach ($array\
    \ as $k => $val) {\n    if ($val >= $min && $val < $max) {\n        $result[]\
    \ = $kmin;\n        $result[] = $kmax;\n    }\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| a dscore=2 |>\n<code>\n$array = [1, 2, 3, 10, 20, 30, 40, 50, 60, 70, 80, 90];\n\
    $min = 30;\n$max = 60;\n", "  $sort_keys = array();\n  $sort_values = array();\n\
    \  $min = null;\n  $max = null;\n  foreach ($lst as $k => $v) {\n    if ($min\
    \ === null) {\n      $min = $v;\n      $max = $v;\n    }\n    if ($v < $min) {\n\
    \      $min = $v;\n    }\n    if ($v > $max) {\n      $max = $v;\n    }\n    $sort_values[$v]\
    \ = $k;\n    $sort_keys[$k] = $v;\n  }\n  krsort($sort_values);\n  krsort($sort_keys);\n\
    \  $result = array();\n  foreach ($sort_values as $k => $v) {\n    $result[$k]\
    \ = $sort_values[$k];\n  }\n  foreach ($sort_keys as $k => $v) {\n    $result[$k]\
    \ = $v;\n  }\n  return $result;\n}\n", "  $ret = array();\n  foreach ($lst as\
    \ $key => $value) {\n    if ($ret != array()) {\n      $key = array_search($value,\
    \ $ret);\n    }\n    $ret[$key] = $value;\n  }\n  return $ret;\n}\n</code>\n<|/\
    \ a tags=arrays,php,sorting |>\n<| a |>\n<code>", "    $min_val = min($lst);\n\
    \    $max_val = max($lst);\n    $i = 0;\n    $j = 0;\n    $result = array();\n\
    \    foreach ($lst as $val) {\n        if ($val == $min_val) {\n            $j\
    \ = $i;\n        } else if ($val == $max_val) {\n            $j = $i - 1;\n  \
    \      } else {\n            $i = $j + 1;\n            $j = $i;\n        }\n \
    \       $result[$j] = $val;\n    }\n    return $result;\n}\n</code>\n<|/ a dscore=2\
    \ tags=php,sorting,algorithm |>\n<| c |>\nNice - but your function does not work\
    \ for me. `strange_sort_list([-4, -1, 0, 2, 3])` gives me `[-1, 0, 2, 3]` instead\
    \ of `[0, 1, 2, 3, 4]`\n<|/ c |>\n<| c |>\nOops, I edited my answer before your\
    \ comment appeared. I'll update it again.\n<|/ c |>\n<| c |>\nThis is working\
    \ only for positive integers, not for negative integers. How to make it work for\
    \ negative integers?\n<|/ c |>\n<| c |>\n- You can simply change the if condition\
    \ to `if ($val > 0 && $val == $min_val)`\n<|/ c |>\n<| a dscore=0 |>\nFor anyone\
    \ who is still looking for this, I created a more robust and flexible solution\
    \ below. This allows sorting by any field, with any sort order. \nIt sorts first\
    \ by ascending order if there is a tie, then by ascending order if the value is\
    \ smaller than the smallest value in the array. After that, by ascending order\
    \ if the value is bigger than the smallest value in the array.\n<code>\n/**\n\
    \ * Sort array by values \n * \n * array $array array \n * string $field field\
    \ to sort by\n * string $order asc or desc\n * array sorted array\n */", "  $ret\
    \ = array();\n  $len = count($lst);\n  for ($i = 0; $i < $len; $i++) {\n    $ret[]\
    \ = $lst[$i];\n  }\n  return $ret;\n}\n</code>\n<|/ a dscore=0 tags=php,sorting\
    \ |>\n<| c |>\nYou should explain what you did, what it does, and why it works\n\
    <|/ c |>\n<| c |>\nI have added some explanation.\n<|/ c |>\n<| a dscore=0 |>\n\
    I found this simple solution:\n<code>\n$array1 = array();\n$array1[] = array('name'\
    \ => 'Zachary', 'age' => '35');\n$array1[] = array('name' => 'James', 'age' =>\
    \ '22');\n$array1[] = array('name' => 'James', 'age' => '18');\n\nusort($array1,\
    \ function($a, $b) {\n    return strcmp($a[\"name\"], $b[\"name\"]);\n});\n\n\
    print_r($array1);\n</code>\n<|/ a tags=php,sorting |>\n<| c |>\nYou should explain\
    \ what you did, what it does, and why it works\n<|/ c |>\n<| a |>\nThis way works,\
    \ too:\n<code>\nusort($arr, [$this, 'sortByName']);\n\npublic function sortByName($a,\
    \ $b) {\n    return strnatcmp($a->name, $b->name);\n}\n</code>\n<|/ a tags=php,sorting\
    \ dscore=0 |>\n<| a |>\nMy solution uses the sort() method of the ArrayObject\
    \ object:\n<code>", "    if (!$lst) return array();\n    $min = $lst[0];\n   \
    \ $max = array_pop($lst);\n    return array_merge(array($min), strange_sort_list($lst),\
    \ array($max));\n}\n</code>\n<|/ a tags=php,sorting |>\n<| c |>\nHi there, thanks\
    \ for your reply! The code you suggested didn't seem to work for my needs. I appreciate\
    \ your help though!\n<|/ c |>\n<| c |>\nI guess I forgot to mention that the array\
    \ is actually not always sorted from min to max... but maybe that makes a difference?\n\
    <|/ c |>\n<| c |>\nI've tried your solution and it is still not working correctly.\
    \ It looks like the array is randomly being reordered, and sometimes it doesn't\
    \ even change from min to max. It is a random problem I'm experiencing and I can't\
    \ figure out how to fix it.\n<|/ c |>\n<| c |>\nHi, I see a problem with the array\
    \ I posted and have updated my code to fix it. Strange sorting, is when you start\
    \ with the minimum value, then maximum of the remaining integers, then minimum\
    \ and so on. \n\nI guess I forgot to mention that I need the array to remain sorted\
    \ the way it is with the min value to max value reversed.\n\nI appreciate your\
    \ help so far!\n<|/ c |>\n<| c |>\nI guess I forgot to mention that the array\
    \ is actually not always sorted from min to max... but maybe that makes a difference?\n\
    <|/ c |>\n<| a dscore=0 tags=php,sorting |>\nOkay, so I finally figured out my\
    \ own answer! I was trying to implement a sorting algorithm that would not sort\
    \ from min to max and have it reversed. Here is how I solved this problem:\n<code>",
  "  if (empty($lst)) {\n    return array();\n  }\n\n  sort($lst);\n\n  $result =\
    \ array();\n  foreach ($lst as $v) {\n    $result[] = $v;\n  }\n  return $result;\n\
    }\n", "  if(count($lst) == 0) return array();\n  $min = min($lst);\n  $max = max($lst);\n\
    \  $result = array();\n  for($i = $min; $i < $max; $i++) {\n    $result[] = $i;\n\
    \  }\n  for($i = $max; $i >= $min; $i--) {\n    $result[] = $i;\n  }\n  return\
    \ $result;\n}\n</code>\n<|/ a dscore=2 tags=php |>\n<| c |>\nAwesome, thanks for\
    \ the help. I forgot to mention that I wanted the array to be in descending order.\
    \ Sorry about that.\n<|/ c |>\n<| a dscore=1 tags=php |>\nThis is not a very elegant\
    \ solution, but here it goes:\n<code>\n<?php\n\n$array = array(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20);\n\
    \nsort($array);\n$a = array_slice($array, 0, 10);\n$b = array_slice($array, 11,\
    \ 10);\n$c = array_slice($array, 10, 10);\n$d = array_slice($array, 20, 10);\n\
    \n$array = $a.$b.$c.$d;\n\nvar_dump($array);\n", "  $i = null;\n  $n = count($lst);\n\
    \  $m = null;\n  while ($i < $n) {\n    $m = $lst[$i];\n    for ($j = i; $j <\
    \ $n; ++$j) {\n      if ($lst[$j] < $m) {\n        $lst[$j] = $lst[$i];\n    \
    \    $lst[$i] = $m;\n        $m = $lst[$j];\n      }\n    }\n    $i = $j + 1;\n\
    \  }\n  return $lst;\n}\n</code>\nIn PHP, just use a foreach loop.\n<|/ a dscore=4\
    \ tags=sorting,php,arrays |>\n<| a tags=sorting,php,arrays |>\nYou can do it simply\
    \ using array_multisort().\nJust use array_multisort() with an array of 2 keys.\
    \ So this should work:\n<code>\n<?php\n$array1 = array(\"a\",\"b\",\"c\",\"d\"\
    ,\"e\");\n$array2 = array(\"e\",\"a\",\"b\",\"d\",\"c\");\narray_multisort($array1,\
    \ $array2);\nprint_r($array1);", "    $copy = array();\n    foreach ($lst as $item)\
    \ {\n        $copy[] = $item;\n    }\n    sort($copy);\n    return $copy;\n}\n\
    </code>\n<|/ a |>\n<| c |>\nYes, I agree that this is a good idea. However, the\
    \ OP wants an array of integers, not an array of strings\n<|/ c |>\n<| c |>\n\
    Ah, yes, good point. I didn't see that from the OP :)\n<|/ c |>\n<| c |>\nYour\
    \ solution works only when all values are unique. If they can be repeated, it's\
    \ still wrong because it will sort this array: `array(\"c\", \"b\", \"a\", \"\
    c\")`. It should give this result: `array(\"a\", \"b\", \"c\", \"c\")`\n<|/ c\
    \ |>\n<| c |>\nIt doesn't sort the array, it just returns it.  Just like any sort.\n\
    <|/ c |>\n<| a tags=sorting,php |>\nThis should do the trick (if you're just trying\
    \ to reverse the order of the array, you can just use array_reverse()):\n<code>\n\
    $result = array_reverse($array);\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis is\
    \ the simplest and most logical answer for this question.\n<|/ c |>\n<| c |>\n\
    This doesn't work if you have an array of objects that have properties like `created_at`\
    \ or `updated_at`. The properties will be changed as well, while they're actually\
    \ not relevant for this question.\n<|/ c |>\n<| c |>\nThis answer doesn't make\
    \ sense.  `array_reverse` won't reverse a numeric array.  https://3v4l.org/0iHaT\n\
    <|/ c |>\n<| c |>\nYou're right, sorry. Corrected now.\n<|/ c |>\n<| c |>\nThat\
    \ is awesome man! I really appreciate you saving my life, I've been trying to\
    \ sort this out for a while now. Cheers!\n<|/ c |>\n<| a dscore=5 tags=sorting,php\
    \ |>\n<code>\n$array = array('3', '2', '1', '4');\nsort($array);\nprint_r($array);\n\
    </code>\n<|/ a |>\n<| c |>\nIt's worth noting, that this does not actually sort\
    \ the array, it just reorders it. Check out this fiddle: https://3v4l.org/hQY8Y\n\
    <|/ c |>\n<| c |>\nActually, this sorts the array, just like `asort()` would.\
    \ It's not an in-place sort.\n<|/ c |>\n<| c |>\nH", "    if (empty($lst)) return\
    \ array();\n    $sorted = array();\n    $sorted = array_merge($sorted, $lst);\n\
    \    $sorted = array_merge($sorted, $lst);\n    $sorted = array_merge($sorted,\
    \ $lst);\n    $sorted = array_merge($sorted, $lst);\n    $sorted = array_merge($sorted,\
    \ $lst);\n    $sorted = array_merge($sorted, $lst);\n    $sorted = array_merge($sorted,\
    \ $lst);\n    return $sorted;\n}\n", "  $result = array();\n  $first_element =\
    \ null;\n  $last_element = null;\n  for ($i = 0; $i < count($lst); $i++) {\n \
    \   if ($i == 0) {\n      $first_element = $lst[$i];\n    } else {\n      $last_element\
    \ = $lst[$i];\n    }\n    if ($lst[$i] < $first_element) {\n      for ($j = $i;\
    \ $j > 0; $j--) {\n        $result[] = $lst[$j];\n      }\n      $result[] = $first_element;\n\
    \      $i--;\n      $first_element = null;\n    } else {\n      for ($j = $i;\
    \ $j < count($lst); $j++) {\n        $result[] = $lst[$j];\n      }\n      $result[]\
    \ = $last_element;\n      $i++;\n      $last_element = null;\n    }\n  }\n  return\
    \ $result;\n}\n", "  $sorted = array();\n  $min = $lst[0];\n  for ($i = 0; $i\
    \ < count($lst); $i++) {\n    if ($lst[$i] == $min) {\n      $sorted[] = $min;\n\
    \      $min = $min+($lst[$i]-$min);\n    } else {\n      $sorted[] = $lst[$i];\n\
    \      $min = $lst[$i];\n    }\n  }\n  if (count($sorted) < count($lst)) {\n \
    \   array_push($sorted, $lst[count($sorted)]);\n  }\n  return $sorted;\n}", " \
    \   if (empty($lst)) {\n        return array();\n    }\n\n    // Return an empty\
    \ list if all values are equal\n    if ($lst[0] == $lst[1]) {\n        return\
    \ array();\n    }\n\n    // Return the original list if all values are equal\n\
    \    if ($lst[0] == $lst[count($lst) - 1]) {\n        return $lst;\n    }\n\n\
    \    // Return the original list if all values are equal mod 2\n    if ($lst[0]\
    \ == $lst[count($lst) - 1] && ($lst[count($lst) - 1] % 2)) {\n        return $lst;\n\
    \    }\n\n    // Find the lowest number in the list\n    $lo = array_shift($lst);\n\
    \n    // Find the highest number in the list\n    $hi = array_pop($lst);\n\n \
    \   // Sort the middle numbers with the other numbers in between\n    $sorted\
    \ = array();\n    for ($i = $lo; $i <= $hi; $i++) {\n        $sorted[] = $i;\n\
    \    }\n\n    // Merge the remainder with the sorted middle numbers\n    return\
    \ array_merge($sorted, strange_sort_list($lst));\n}\n", "  $first = array_shift($lst);\n\
    \  $max = array_reduce($lst, 'max', $first);\n  $min = array_reduce($lst, 'min',\
    \ $first);\n  $rest = array_reduce($lst, 'array_merge', array($min, $max));\n\
    \  return array_merge($rest, strange_sort_list($rest));\n}", "  uksort($lst, 'strange_sort_list_callback');\n\
    \  return $lst;\n}\n", "  // We are sorting in ascending order.\n  // We use the\
    \ key function to sort by the value itself,\n  // or sort by index if there are\
    \ duplicates.\n  // This way we sort by the value itself, which is what we want,\n\
    \  // and then by index to break ties.\n  return array_map(function ($item, $key)\
    \ {\n    return $key + $item;\n  }, sort($lst), array_keys($lst));\n}\n</code>\n\
    <|/ a dscore=1 tags=sorting,php,array-algorithms,arrays |>\n<| c |>\nThis solution\
    \ is too slow for large arrays.\n<|/ c |>\n<| a tags=sorting,php,array-algorithms,arrays\
    \ |>\nThis can be achieved without using any additional array and with O(n) complexity\
    \ by using array_merge() with array_flip() on both original arrays first and then\
    \ sorting them using ksort().\n<code>\n<?php\n$array1 = [2, 3, 5, 7, 11, 13];\n\
    $array2 = [4, 5, 6, 8, 12];\n$result = array_merge(array_flip($array1), array_flip($array2));\n\
    ksort($result);\nvar_dump($result);\n</code>\n<|/ a dscore=1 |>\n<| c |>\nBut\
    \ this doesn't preserve the original ordering - which might be important to OP\n\
    <|/ c |>\n<| c |>\nThis solution is too slow for large arrays.\n<|/ c |>\n<| a\
    \ dscore=0 |>\n<code>\n<?php", "  // We sort a list\n  // starting with the minimum\
    \ value\n  // then with the maximum value\n  // then with the minimum of the remaining\
    \ numbers\n  // then with the maximum of the remaining numbers\n  // ...\n  //\
    \ Then, continue this until we have nothing left to sort and return it\n  if (empty($lst))\
    \ {\n    return array();\n  }\n  $min = 0;\n  $max = 0;\n  $cur = 0;\n  while\
    \ ($max < count($lst) - 1) {\n    if ($min == 0) {\n      $min = $lst[$cur];\n\
    \      $max = $lst[$cur + 1];\n    } else {\n      if ($max < $min + 1) {\n  \
    \      // swap min and max\n        $tmp = min($min, $max);\n        $min = $max;\n\
    \        $max = $tmp;\n      }\n    }\n    $cur += 1;\n  }\n  $lst = array_merge(array($min),\
    \ $lst);\n  krsort($lst);\n  return $lst;\n}", "    $result = array();\n    $i\
    \ = 0;\n    $size = count($lst);\n    while (count($result) < $size) {\n     \
    \   if ($lst[$i] == $lst[0]) {\n            $result[$i] = $lst[0];\n         \
    \   $i++;\n            $result[$i] = $lst[$i];\n            $i++;\n          \
    \  $result[$i] = $lst[$i];\n            $i++;\n            $result[$i] = $lst[0];\n\
    \            $i++;\n            $result[$i] = $lst[$i];\n            $i++;\n \
    \           $result[$i] = $lst[0];\n            $i++;\n            $result[$i]\
    \ = $lst[$i];\n            $i++;\n            $result[$i] = $lst[0];\n       \
    \     $i++;\n            $result[$i] = $lst[$i];\n            $i++;\n        \
    \    $result[$i] = $lst[0];\n            $i++;\n            $result[$i] = $lst[$i];\n\
    \            $i++;\n            $result[$i] = $lst[0];\n            $i++;\n  \
    \          $result[$i] = $lst[$i];\n            $i++;\n            $result[$i]\
    \ = $lst[0];\n            $i++;\n            $result[$i] = $lst[$i];\n       \
    \     $i++;\n            $result[$i] = $lst[0];\n            $i++;\n         \
    \   $result[$i] = $lst[$i];\n            $i++;\n            $result[$i] = $lst[0];\n\
    \            $i++;\n            $result[$i] = $lst[$i];\n            $i++;\n \
    \           $result[$i] = $lst[0];\n            $i++;\n            $result[$i]\
    \ = $lst[$i];\n            $i++;\n            $result[$i] = $lst[0];\n       \
    \     $i++;\n            $result[$i] = $lst[$i];\n            $i++;\n        \
    \    $result[$i] = $lst[0];\n            $i++;\n            $result[$i] = $lst[$i];\n\
    \            $i++;\n            $result[$i] = $lst[0];\n            $i++;\n  \
    \          $result[$i] = $lst[$i];\n            $i++;\n            $result[$i]\
    \ = $lst[0];\n            $i++;\n            $result[$i] = $lst[$i];\n       \
    \     $i++;\n            $result[$i] = $lst[0];\n            $i++;\n         \
    \   $result[$i] = $lst[$i];\n            $i++;\n            $result[$i] = $lst[0];\n\
    \            $i++;\n            $result[$i] = $lst[$i];\n            $i++;\n \
    \           $result[$i] = $lst[0];\n            $i++;\n            $result[$i]\
    \ = $lst[$i];\n            $i++;\n            $result[$i] = $lst[0];\n       \
    \     $i++;\n            $result[$i] = $lst[$i];\n", "  if (!is_array($lst))\n\
    \    return array();\n  // Return first element\n  $ret = array($lst[0]);\n  //\
    \ Get length of array\n  $len = count($lst);\n  // Loop\n  for ($i = 1; $i < $len;\
    \ $i++) {\n    // Get current value\n    $cur = $lst[$i];\n    // Loop over remaining\
    \ array\n    for ($j = $i + 1; $j < $len; $j++) {\n      // Get next value\n \
    \     $next = $lst[$j];\n      // Sort if current value is larger than next value\n\
    \      if ($cur > $next)\n        array_unshift($ret, $cur);\n      // Sort if\
    \ current value is smaller than next value\n      elseif ($cur < $next)\n    \
    \    array_push($ret, $cur);\n    }\n  }\n  return $ret;\n}\n", "  // Check if\
    \ we got anything\n  if (!$lst) {\n    return array();\n  }\n\n  // Create a copy\
    \ of the original array\n  $sorted_list = array_map(function($v) { return $v;\
    \ }, $lst);\n  // Reverse it, so we have descending order\n  array_reverse($sorted_list);\n\
    \n  // return sorted copy\n  return $sorted_list;\n}\n", "  $len = count($lst);\n\
    \  if ($len < 2) return $lst;\n  // Create array of keys in descending order.\n\
    \  // Note that reverse sorting order is also available with\n  // array_flip\
    \ function.\n  foreach (array_reverse(range($len)) as $k) {\n    $result[$k] =\
    \ $lst[$k];\n  }\n  return $result;\n}\n", "  if (empty($lst)) {\n    return array();\n\
    \  }\n\n  $min = $lst[0];\n  $max = array_shift($lst);\n\n  foreach ($lst as $key\
    \ => $value) {\n    if ($value < $min) {\n      $min = $value;\n    }\n    if\
    \ ($value > $max) {\n      $max = $value;\n    }\n  }\n\n  $arr = array();\n \
    \ foreach ($lst as $key => $value) {\n    if ($min <= $value && $max >= $value)\
    \ {\n      $arr[] = $value;\n    }\n  }\n\n  return $arr;\n}\n", "  if (!$lst)\
    \ {\n    return array();\n  }\n  $min = reset($lst);\n  $max = end($lst);\n  $min_key\
    \ = array_search($min, $lst);\n  $max_key = array_search($max, $lst);\n  $temp\
    \ = $lst;\n  unset($temp[$min_key]);\n  unset($temp[$max_key]);\n  ksort($temp);\n\
    \  return $temp;\n}", "  $min_val = PHP_INT_MAX;\n  $max_val = -PHP_INT_MAX;\n\
    \  foreach ($lst as $value) {\n    if ($value < $min_val) {\n      $min_val =\
    \ $value;\n    }\n    if ($value > $max_val) {\n      $max_val = $value;\n   \
    \ }\n  }\n  if ($min_val == $max_val) {\n    return array();\n  }\n  $lst = array();\n\
    \  $start = 0;\n  $end = PHP_INT_MAX;\n  $reversed = FALSE;\n  for ($i = $max_val;\
    \ $i >= $min_val; --$i) {\n    $end = $i;\n    if ($start == $end) {\n      $reversed\
    \ = TRUE;\n      $start = $i + 1;\n    }\n    $lst[] = $start;\n    if ($reversed)\
    \ {\n      $end = $start - 1;\n      $start = $end - 1;\n    }\n  }\n  return\
    \ $lst;\n}\n</code>\n<|/ a tags=php |>\n<| c |>\nNice, but i think you mean `if\
    \ ($start == $end) {\n      $reversed = TRUE;\n      $start = $i + 1;\n    }\n\
    \    if ($reversed) {\n      $start = $end - 1;\n      $end = $start + 1;\n  \
    \  }`\n<|/ c |>\n<| a tags=php |>\n<code>\n<?php", "  // If the list is empty,\
    \ just return an empty array.\n  if (empty($lst)) {\n    return array();\n  }\n\
    \n  $min_elem = $lst[0];\n  $max_elem = $lst[0];\n  $min_pos = 0;\n  $max_pos\
    \ = 0;\n\n  foreach ($lst as $elem => $pos) {\n    if ($elem < $min_elem) {\n\
    \      $min_elem = $elem;\n      $min_pos = $pos;\n    } else if ($elem > $max_elem)\
    \ {\n      $max_elem = $elem;\n      $max_pos = $pos;\n    }\n  }\n\n  $lst_temp\
    \ = array();\n  foreach ($lst as $pos => $elem) {\n    if ($min_pos <= $pos &&\
    \ $max_pos >= $pos) {\n      $lst_temp[$elem] = $pos;\n    }\n  }\n\n  return\
    \ $lst_temp;\n}\n", "\t$min = $min = $minVal = null;\n\t$max = $max = $maxVal\
    \ = null;\n\tforeach($lst as $val) {\n\t\tif ($min == null) $min = $val;\n\t\t\
    else $min = $val > $minVal ? $val : $min;\n\t\tif ($max == null) $max = $val;\n\
    \t\telse $max = $val < $maxVal ? $val : $max;\n\t}\n\tfor ($i = 0; $i < $max;\
    \ ++$i) {\n\t\t$new[$i] = $lst[$i];\n\t\tfor ($j = $i; $j < $max; ++$j) {\n\t\t\
    \tif ($lst[$i] > $lst[$j]) {\n\t\t\t\t$tmp = $lst[$i];\n\t\t\t\t$lst[$i] = $lst[$j];\n\
    \t\t\t\t$lst[$j] = $tmp;\n\t\t\t}\n\t\t}\n\t}\n\tfor ($i = 0; $i < $min; ++$i)\
    \ {\n\t\t$new[$i] = $lst[$i];\n\t\tfor ($j = $i; $j < $min; ++$j) {\n\t\t\tif\
    \ ($lst[$i] < $lst[$j]) {\n\t\t\t\t$tmp = $lst[$i];\n\t\t\t\t$lst[$i] = $lst[$j];\n\
    \t\t\t\t$lst[$j] = $tmp;\n\t\t\t}\n\t\t}\n\t}\n\treturn $new;\n}", "    if (empty($lst))\
    \ return array();\n    sort($lst, SORT_NUMERIC);\n    $last = array_pop($lst);\n\
    \    return $lst + array($last);\n}\n</code>\nThe above function expects the array\
    \ to be already ordered, but it does not require it. The function will sort the\
    \ array in-place.\nAnd it uses array_pop() which returns the last element from\
    \ the array, but unset it from the array.\n<|/ a tags=php |>\n<| a |>\n<code>"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
