name: HumanEval_21_rescale_to_unit
language: php
prompt: "<?php\n// Given array of numbers (of at least two elements), apply a linear\
  \ transform to that array,\n// such that the smallest number will become 0 and the\
  \ largest will become 1\n// >>> rescale_to_unit(array(1.0, 2.0, 3.0, 4.0, 5.0))\n\
  // array(0.0, 0.25, 0.5, 0.75, 1.0)\nfunction rescale_to_unit($numbers) {\n"
tests: "function candidate(...$args) {\n    return rescale_to_unit(...$args);\n}\n\
  \nfunction test(): void {\n    if (candidate(array(2.0, 49.9)) !== array(0.0, 1.0))\
  \ { throw new Exception(\"Test failed!\"); }\n    if (candidate(array(100.0, 49.9))\
  \ !== array(1.0, 0.0)) { throw new Exception(\"Test failed!\"); }\n    if (candidate(array(1.0,\
  \ 2.0, 3.0, 4.0, 5.0)) !== array(0.0, 0.25, 0.5, 0.75, 1.0)) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(array(2.0, 1.0, 5.0, 3.0, 4.0)) !== array(0.25,\
  \ 0.0, 1.0, 0.5, 0.75)) { throw new Exception(\"Test failed!\"); }\n    if (candidate(array(12.0,\
  \ 11.0, 15.0, 13.0, 14.0)) !== array(0.25, 0.0, 1.0, 0.5, 0.75)) { throw new Exception(\"\
  Test failed!\"); }\n}\n\ntest();"
completions: ["    return array_map(function ($value) {\n        return (1 - $value)\
    \ * (1 / $numbers);\n    }, $numbers);\n}\n", "  $min = min($numbers);\n  $max\
    \ = max($numbers);\n  if ($min == 0.0) {\n    return array();\n  }\n  return $numbers\
    \ / max($max - $min, 0.0);\n}", "    if (empty($numbers)) {\n        return $numbers;\n\
    \    }\n    $smallestElement = $numbers[0];\n    $biggestElement = $numbers[0];\n\
    \    for ($i = 1; $i < count($numbers); $i++) {\n        $currentElement = $numbers[$i];\n\
    \        if ($currentElement < $smallestElement) {\n            $smallestElement\
    \ = $currentElement;\n        }\n        if ($currentElement > $biggestElement)\
    \ {\n            $biggestElement = $currentElement;\n        }\n    }\n    $smallestElement\
    \ = 1.0 / $smallestElement;\n    $biggestElement = 1.0 / $biggestElement;\n  \
    \  return array_map(function ($number) use ($smallestElement, $biggestElement)\
    \ {\n        return $smallestElement * $number + $biggestElement;\n    }, $numbers);\n\
    }\n", "  $min = min($numbers);\n  $max = max($numbers);\n  if ($min == $max) {\n\
    \    return $numbers;\n  }\n  $diff = $max - $min;\n  $scale = 1 / $diff;\n  return\
    \ array_map(function ($num) use ($scale) {\n    return $num * $scale;\n  }, $numbers);\n\
    }\n", "  $min = min($numbers);\n  $max = max($numbers);\n  return array_map(function\
    \ ($number) {\n    return $number / $max - $min;\n  }, $numbers);\n}\n", "   \
    \ $minimum = array_shift($numbers);\n    $maximum = array_reduce($numbers, function($a,\
    \ $b) {\n        return $a >= $b ? $a : $b;\n    });\n\n    return array($minimum,\
    \ $maximum);\n}\n", "\t$min = array_shift($numbers);\n\t$max = array_shift($numbers);\n\
    \t$diff = array_diff($numbers, array($min, $max));\n\tif (empty($diff)) {\n\t\t\
    return array();\n\t}\n\t$diff = array_filter($diff);\n\tif (empty($diff)) {\n\t\
    \treturn array($min);\n\t}\n\treturn array($min + ($min - $max) / count($diff));\n\
    }\n", "    $length = count($numbers);\n    for ($i = 1; $i <= $length; $i++) {\n\
    \        $numbers[$i] -= $numbers[0] * $i;\n    }\n    return $numbers;\n}\n",
  "  // $numbers is an array of numbers of at least two elements, otherwise throw\
    \ an exception\n  if (count($numbers) < 2) {\n    die(\"There must be at least\
    \ two numbers to apply a linear transform to\");\n  }\n\n  $smallest = null;\n\
    \  $largest = null;\n  $num_elements = count($numbers);\n  for ($i = 0; $i < $num_elements;\
    \ $i++) {\n    if ($smallest == null || $smallest[0] > $numbers[$i]) {\n     \
    \ $smallest = $numbers[$i];\n    }\n    if ($largest == null || $largest[0] <\
    \ $numbers[$i]) {\n      $largest = $numbers[$i];\n    }\n  }\n\n  $scale = ($largest\
    \ - $smallest) / ($numbers[$num_elements - 1] - $numbers[0]);\n  $rescaled = array();\n\
    \  for ($i = 0; $i < $num_elements; $i++) {\n    $rescaled[$i] = $numbers[$i]\
    \ * $scale;\n  }\n\n  return $rescaled;\n}\n", "    $min = min($numbers);\n  \
    \  $max = max($numbers);\n    $scale = 1 / $max - $min;\n    return array_map(function\
    \ ($number) {\n        return $min + ($number - $min) * $scale;\n    }, $numbers);\n\
    }\n", "  $min = min($numbers);\n  $max = max($numbers);\n  return array_map(function($number)\
    \ use ($min, $max) {\n    return $number - $min;\n  }, $numbers);\n}\n", "   \
    \ // Sort so that smallest numbers end up at front\n    uasort($numbers, function($a,\
    \ $b) {\n        return $a - $b;\n    });\n\n    $minimum = $numbers[0];\n   \
    \ $maximum = count($numbers) === 1 ? 0 : $numbers[count($numbers)-1];\n\n    //\
    \ If there are no numbers, return array instead of boolean\n    if ($maximum ===\
    \ 0)\n        return array();\n\n    // If there's only one number, return boolean\
    \ instead of array\n    if (count($numbers) === 1)\n        return $numbers[0]\
    \ === $minimum;\n\n    // Now loop through numbers and find minimum and maximum\n\
    \    foreach ($numbers as $number => $value) {\n        if ($value >= $minimum)\n\
    \            $minimum = $value;\n        if ($value <= $maximum)\n           \
    \ $maximum = $value;\n    }\n\n    // Now scale everything to be between minimum\
    \ and maximum\n    $new_numbers = array();\n    foreach ($numbers as $number =>\
    \ $value) {\n        $new_numbers[$number] = (float) ($value / $maximum * ($minimum\
    \ - $minimum));\n    }\n\n    // Return an array with new numbers\n    return\
    \ $new_numbers;\n}\n</code>\n<|/ a |>\n<| a dscore=1 |>\nThis is my answer. \n\
    <code>\n<?php\n$numbers = array(2, 4, 6, 8, 10);\n", "    $smallest_number = min(array_filter(array_map(function($n)\
    \ {\n        return $n;\n    }, $numbers)));\n    $max_number = max(array_filter(array_map(function($n)\
    \ {\n        return $n;\n    }, $numbers)));\n    $range = max(($max_number -\
    \ $smallest_number), ($max_number - 0));\n    return array_map(function($n) {\n\
    \        return $n - $smallest_number / $range;\n    }, $numbers);\n}\n", "  return\
    \ array($numbers[0] / min(abs($numbers[0]), abs($numbers[1])), $numbers[1] / max(abs($numbers[0]),\
    \ abs($numbers[1])));\n}", "    if (!is_array($numbers) || !count($numbers)) {\n\
    \        return $numbers;\n    }\n    $rangeEnd = end($numbers);\n    $largest\
    \ = array_pop($numbers);\n    foreach ($numbers as &$value) {\n        if ($value\
    \ < $rangeEnd) {\n            $value = ($value / $rangeEnd) * $largest;\n    \
    \    } else {\n            $value = $largest;\n        }\n    }\n    return $numbers;\n\
    }\n", "\t$sum = array_sum($numbers);\n\t$max_val = max($numbers);\n\t$min_val\
    \ = min($numbers);\n\n\tforeach ($numbers as $index => $value) {\n\t\t$numbers[$index]\
    \ = $value / $sum;\n\t}\n\n\treturn $numbers;\n}\n\n", "  $minimum = min($numbers);\n\
    \  $maximum = max($numbers);\n  $scale = ($maximum - $minimum) / 1.0;\n  $rescaled\
    \ = array();\n  foreach ($numbers as $n) {\n    $rescaled[$n] = round($n * $scale)\
    \ + $minimum;\n  }\n  return $rescaled;\n}\n", "    sort($numbers);\n    list($smallest,\
    \ $largest) = $numbers;\n    if ($smallest == $largest) {\n        return $numbers;\n\
    \    }\n    $scale = 1.0 * $largest / $smallest;\n    return array(0, $smallest\
    \ * $scale);\n}\n", "    $minimum = min($numbers);\n    $maximum = max($numbers);\n\
    \n    if ($minimum == $maximum) {\n        return array($minimum, $minimum);\n\
    \    }\n\n    $range = 1 - $maximum / $minimum;\n    $range = round($range * 100);\n\
    \    $range = array_fill(0, 2, $range);\n\n    return array($minimum, $range);\n\
    }\n</code>\nThe above code would then allow you to run a transformation like this:\n\
    <code>\n<?php\n", "  return array_map(\n      function($n) { return $n * (1.0\
    \ / min(count($numbers), count($numbers)-1)); },\n      $numbers);\n}\n</code>\n\
    <|/ a |>\n<| c |>\nI made a slight change: rescale from 0 to 1 so that (0,1) is\
    \ (0 ,1) and (1,0) is (1,1)\n<|/ c |>\n<| a tags=php,arrays dscore=3 |>\n<code>\n\
    $min = min($array);\n$max = max($array);\n\n$result = array();\nfor($i = 0; $i\
    \ < count($array); $i++) {\n  $result[$i] = (1 - $min / $max) * $result[$i] +\
    \ $min / $max;\n}\n</code>\n<|/ a |>\n<| c |>\nThis answer will work better than\
    \ the one from Elias because it is more efficient because it doesn't require a\
    \ double loop\n<|/ c |>\n<| a tags=php,arrays dscore=2 |>\nOne liner solution\
    \ (I prefer this to the others)\n<code>\n$array = [0,1,2,3,4,5,6];\n$result =\
    \ array_map(function($num) {\n    return $num * (1 - min($array) / max($array));\
    \ }, $array);\n</code>\n<|/ a |>\n<| a dscore=2 |>\nYou could use array_sum()\
    \ with array_map() like this:\n<code>\n<?php\n\n$array = array(1,2,3,4,5,6);\n\
    \n$array = array_map('round', array_map(\n    function ($val) {\n        return\
    \ $val * .1;\n    },\n    $array\n));\n\nvar_dump($array);\n</code>\nResult:\n\
    <code>\narray(6) {\n  [0]=>\n  int(0)\n  [1]=>\n  int(.1)\n  [2]=>\n  int(.2)\n\
    \  [3]=>\n  int(.3)\n  [4]=>\n  int(.4)\n  [5]=>\n  int(.5)\n}\n</code>\n<|/ a\
    \ tags=php,arrays |>\n<| a dscore=1 |>\n<code>\n$array = array(0,1,2,3,4,5,6);\n\
    $min = min($array);\n$max = max($array);\n$new_array = array();\nforeach($array\
    \ as $val){\n    $new_array[] = round(($val-$min)/($max-$min)*100);\n}\nprint_r($new_array);\n\
    </code>\n<|/ a tags=php,arrays |>\n<| c |>\nThis answer will work better than\
    \ the one from John Wood because it is more efficient because it doesn't ", "\t\
    $min_num = min($numbers);\n\t$max_num = max($numbers);\n\t$scale = ($min_num -\
    \ $max_num) / (count($numbers) - 1);\n\t$array = array();\n\tfor ($i = 0; $i <\
    \ count($numbers); $i++) {\n\t\t$array[$i] = $numbers[$i] * $scale;\n\t}\n\treturn\
    \ $array;\n}\n", "  // Normalize the input array of numbers, so they always sum\
    \ to 1\n  $sum = 0;\n  foreach ($numbers as $n) {\n    $sum += $n;\n  }\n  $sum\
    \ = 1.0 / $sum;\n  foreach ($numbers as $n) {\n    $numbers[$n] = $n * $sum;\n\
    \  }\n\n  // Find the smallest and largest number in the array of numbers, and\
    \ apply\n  // linear transformations to those numbers so that the smallest number\
    \ will become 0 and\n  // the largest will be 1.\n  $min = min($numbers);\n  $max\
    \ = max($numbers);\n  foreach ($numbers as $n) {\n    $numbers[$n] -= $min;\n\
    \  }\n  $numbers[0] = 0;\n  $numbers[count($numbers)-1] = 1;\n\n  return $numbers;\n\
    }\n", "    foreach ($numbers as $key => $value) {\n        if ($value < 0 && $value\
    \ >= $numbers[$key-1]) {\n            $numbers[$key] -= $numbers[$key-1];\n  \
    \      }\n    }\n    return $numbers;\n}\n", "  $total = array_sum($numbers);\n\
    \  $min_val = min($numbers);\n  $max_val = max($numbers);\n\n  return array_map(function($num)\
    \ use ($total, $min_val, $max_val) {\n    return $num * ($max_val - $min_val)\
    \ / $total;\n  }, $numbers);\n}\n", "  return array_map(function($n) {\n    return\
    \ $n - array_sum($n) / count($n);\n  }, $numbers);\n}\n</code>\n<|/ a dscore=1\
    \ tags=php,arrays,algorithm,language-agnostic |>\n<| c |>\nWhy are you using `array_sum`\
    \ and `array_count` when you can use `array_reduce`?\n<|/ c |>\n<| c |>\nYes,\
    \ the main idea of the algorithm was to find the minimum and maximum value using\
    \ array_sum and array_count then substract min from max to make the range 0 and\
    \ 1\n<|/ c |>\n<| c |>\nOh, I didn't know about array_reduce. Thanks. :)\n<|/\
    \ c |>\n<| c |>\nOh sorry, I thought it was a built-in PHP function :D\n<|/ c\
    \ |>\n<| c |>\nI haven't even heard of array_reduce, but I learned something new.\
    \ Thanks! :)\n<|/ c |>\n<| a dscore=1 |>\nThe question is very similar to mine.\
    \ I've found the following simple solution:\n<code>\n$result = array();\nforeach\
    \ ($numbers as $k => $v) {\n    $result[] = $v / array_sum($numbers);\n}\nreturn\
    \ $result;\n</code>\n<|/ a tags=php,arrays,algorithm,language-agnostic |>\n<|\
    \ a dscore=0 |>\nMy solution is very simple\n<code>\n$total = 0;\n$max_val = array_sum($numbers);\n\
    foreach($numbers as $num){\n   $total = $total+$num;\n}\n$result = array();\n\
    foreach($numbers as $num){\n   $result[] = ($num/($total));\n}\n</code>\n<|/ a\
    \ tags=php,arrays,algorithm,language-agnostic |>\n<| c |>\nThis doesn't answer\
    \ the question. You just wrote a program to do a very simple task.\n<|/ c |>\n\
    <| a |>\nMy solution (PHP):\n<code>", "    foreach ($numbers as $key => $number)\
    \ {\n        if ($number < 0.0) {\n            $numbers[$key] = 0.0;\n       \
    \ }\n        if ($number > 1.0) {\n            $numbers[$key] = 1.0;\n       \
    \ }\n    }\n\n    return $numbers;\n}\n", "    foreach ($numbers as $i => $number)\
    \ {\n        $min = min($numbers);\n        $max = max($numbers);\n        $numbers[$i]\
    \ = $number * $max / ($max - $min);\n    }\n    return $numbers;\n}\n", "    $min\
    \ = min($numbers);\n    $max = max($numbers);\n    $scale = (($max - $min) / count($numbers));\n\
    \    foreach ($numbers as &$number) {\n        $number = ($number - $min) * $scale;\n\
    \    }\n    return $numbers;\n}\n", "  // Get the minimum and maximum values.\n\
    \  $minimum = min($numbers);\n  $maximum = max($numbers);\n  // Get the desired\
    \ output range's maximum.\n  $range = $maximum - $minimum;\n  // Scale the numbers\
    \ from their range to fit within the output range.\n  $numbers = array();\n  for\
    \ ($i = 0; $i < count($numbers); ++$i) {\n    $numbers[$i] = $numbers[$i] / $range;\n\
    \  }\n  // Add the minimum back to the array to bring it up to 0, and the maximum\
    \ back.\n  return array_merge($numbers, array($minimum));\n}\n", "  return array_map(function\
    \ ($x) {\n    return min($x, 1);\n  }, $numbers);\n}\n\n/**\n * Reverse a linear\
    \ transformation.\n *\n * Given an array of numbers, apply a linear transform\
    \ to that array,\n * such that the smallest number will become 1 and the largest\
    \ will become 0\n * >>> rescale_to_unit(array(0.0, 0.25, 0.5, 0.75, 1.0))\n *\
    \ array(1.0, 2.0, 3.0, 4.0, 5.0)\n *\n * @param array $numbers An array of numbers.\n\
    \ *\n * @return array An array of numbers, that after being reversed the smallest\
    \ number will become 1 and the largest will become 0.\n */", "    $max_num = max($numbers);\n\
    \    $min_num = min($numbers);\n    if ($max_num == $min_num) {\n        return\
    \ array(0, 1);\n    }\n\n    return array($min_num / $max_num, $max_num / $min_num);\n\
    }\n", "    if (count($numbers) < 2) {\n        return $numbers;\n    }\n\n   \
    \ // Find minimum\n    $min = min($numbers);\n    // Find maximum\n    $max =\
    \ max($numbers);\n    // Set minimum to zero\n    $min = ($min == 0.0) ? 0.0 :\
    \ $min;\n    // Set maximum to one\n    $max = ($max == 1.0) ? 1.0 : $max;\n\n\
    \    return $numbers / max($max - $min, $min);\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| a dscore=0 |>\nTo extend Andrew Hanley's answer, you can use the logarithmic\
    \ scale for linear scaling (like most plotting packages do): \n<code>", "    $sum\
    \ = 0;\n    foreach($numbers as $n)\n        $sum += $n;\n    if($sum < 1)\n \
    \       $sum = 1;\n    return array_map(function($n) use($sum) {\n        return\
    \ $sum * $n / $sum;\n    }, array_values($numbers));\n}\n", "    if (!isset($numbers[0])\
    \ || count($numbers) < 2) {\n        return $numbers;\n    }\n    sort($numbers);\n\
    \    $min = $numbers[0];\n    $max = array_pop($numbers);\n    $range = count($numbers)\
    \ - 1;\n    return array($min / $range, $max / $range);\n}\n", "  sort($numbers);\n\
    \  $min = reset($numbers);\n  $max = end($numbers);\n\n  foreach ($numbers as\
    \ $key => $number) {\n    $numbers[$key] = $number / max($min, $max);\n  }\n\n\
    \  return $numbers;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\n+1: This doesn't\
    \ require extra loops and is very efficient. I like the use of dividing by `max($min,\
    \ $max)` to account for negative values if you allow the negative scale factor.\n\
    <|/ c |>\n<| c |>\nI do like this answer, but it's not really a solution to the\
    \ question, which was about finding values between two numbers.  This doesn't\
    \ do that, and it doesn't solve the issue of negative values being treated as\
    \ positive.\n<|/ c |>\n<| c |>\n: Yeah, I agree with you that it's not an exact\
    \ solution to the question. That's why I added it as a comment and not an answer.\n\
    <|/ c |>\n<| a tags=arrays,php |>\nThe function you are looking for is array_filter.\
    \ Here's an example of how to use it for your specific case:\n<code>\n$arr1 =\
    \ array(\n  array(\n    0 => 1,\n    1 => 3,\n    2 => 1,\n    3 => 2,\n    4\
    \ => 1,\n    5 => 3,\n    6 => 2,\n    7 => 1,\n    8 => 2,\n    9 => 1,\n   \
    \ 10 => 3,\n    11 => 2,\n    12 => 1,\n    13 => 3,\n    14 => 2,\n    15 =>\
    \ 1,\n    16 => 3,\n    17 => 2,\n    18 => 1,\n    19 => 3,\n    20 => 2,\n \
    \   21 => 1,\n    22 => 3,\n    23 => 2,\n    24 => 1,\n    25 => 3,\n    26 =>\
    \ 2,\n    27 => 1,\n    28 => 3,\n    29 => 2,\n    30 => 1,\n    31 => 3,\n \
    \   32 => 2,\n    33 => 1,\n    34 => 3,\n    35 => 2,\n    36 => 1,\n    37 =>\
    \ 3,\n    38 => 2,\n    39 => 1,\n    40 => 3,\n    41 => 2,\n    42 => 1,\n \
    \   43 => 3,\n    44 => 2,\n    45 => 1,\n    46 => 3,\n    47 => 2,\n    48 =>\
    \ 1,\n    49 => 3,\n    50 => 2,\n    51 => 1,\n    52 => 3,\n    53 ", "  $min\
    \  = min($numbers);\n  $max  = max($numbers);\n  $length = count($numbers);\n\n\
    \  $unit = [];\n  foreach ($numbers as $index => $value) {\n    $unit[$index]\
    \ = $value / $max;\n  }\n  ksort($unit);\n\n  for ($i = 0; $i < $length; $i++)\
    \ {\n    $numbers[$i] -= $min;\n  }\n  ksort($numbers);\n\n  return array_values($numbers);\n\
    }\n</code>\n<|/ a tags=php,math,arrays,multidimensional-array dscore=4 |>\n<|\
    \ c |>\nThank you for your answer! For what I'm concerned, I prefer the simplicity\
    \ of just applying the min and max values directly to each array element.\n<|/\
    \ c |>\n<| c |>\nFor those who wonder why it works, here is a breakdown of how\
    \ this works: `min($array)` gets the minimum value from the array. `$array[$key]\
    \ /= $max;` takes the max and divides each value by the max. Then `array_values($array)`\
    \ re-indexes everything and returns the new array.\n<|/ c |>\n<| c |>\nJust to\
    \ make it clear - this answer is correct only if the values are in ascending order.\
    \ Otherwise it is wrong.\n<|/ c |>\n<| a dscore=3 |>\nFor anyone reading this\
    \ in 2019 or later, here's a variation of Jason Miller that uses array_udiff()\
    \ to compare the differences between the original array and the rescaled array:\n\
    <code>", "  if (empty($numbers)) {\n    return $numbers;\n  }\n  sort($numbers);\n\
    \  $min = array_shift($numbers);\n  $max = array_shift($numbers);\n  return array_map(function\
    \ ($x) { return $min + ($x - $min) / ($max - $min) * $max; }, $numbers);\n}\n\n",
  "  return array_map(function($val) {\n    return ($val / min($numbers)) * 1.0;\n\
    \  }, $numbers);\n}\n", "    $sum = array_sum($numbers);\n\n    return array_map(function($x)\
    \ use ($sum) {\n        return $x / $sum;\n    }, $numbers);\n}\n", "    foreach\
    \ ($numbers as $i => $n) {\n        if ($n < 0.000001 && $n > -0.000001) {\n \
    \           // if there are both negative and positive numbers, don't use rescaling\n\
    \            $numbers[$i] = $n;\n        }\n    }\n    return $numbers;\n}\n",
  "    assert(count($numbers) > 0);\n    list($min, $max) = array($numbers[0], $numbers[0]);\n\
    \    foreach ($numbers as $value) {\n        if ($value < $min) {\n          \
    \  $min = $value;\n        }\n        if ($value > $max) {\n            $max =\
    \ $value;\n        }\n    }\n    // Rescale to 0-1 range\n    $range = max($max\
    \ - $min);\n    $min = round($min / $range) * $range;\n    $max = round($max /\
    \ $range) * $range;\n    return array($min, $max);\n}\n", "  list($min, $max)\
    \ = $numbers;\n  $min = max(0, $min);\n  $max = min($max, 1);\n  $delta = $max\
    \ - $min;\n  $scale = 1 / $delta;\n  $normalized = array();\n  foreach ($numbers\
    \ as $number) {\n    $normalized[] = $min + ($number - $min) * $scale;\n  }\n\
    \  return $normalized;\n}\n</code>\n<|/ a tags=php,math dscore=2 |>\n<| c |>\n\
    Good solution, but why not add some explanation about how it works, and why it\
    \ would be better?\n<|/ c |>\n<| a tags=php,math |>\nI took Michael Williams solution,\
    \ modified it to allow me to specify a scale in percentage, and to accept decimals.\
    \ \n<code>", "\tsort($numbers);\n\treturn array_map(null, $numbers, array_fill(1,\
    \ count($numbers), 0));\n}\n", "    $smallest = min($numbers);\n    $largest =\
    \ max($numbers);\n    $midpoint = ($smallest + $largest) / 2;\n    return array_map(function\
    \ ($number) { return $number / $midpoint; }, $numbers);\n}\n</code>\n<|/ a |>\n\
    <| c |>\nIt's unclear to me why you chose to divide `($min + $max) / 2` instead\
    \ of simply `($max - $min) / 2`. Could you elaborate?\n<|/ c |>\n<| c |>\nBecause\
    \ when you add up all the numbers, `($max - $min) / 2 != $max - $min` so divide\
    \ by 2 instead of just using `$max - $min`\n<|/ c |>\n<| c |>\nAh, I see. That\
    \ makes sense, thank you. I also see [here](https://stackoverflow.com/a/4425675/573036)\
    \ that you also use `$max - $min` for normalizing. Is there a reason you prefer\
    \ one over the other?\n<|/ c |>\n<| c |>\nIf you use `$max - $min` you get more\
    \ of the original number in the \"normal\" range. This will make the numbers \"\
    look\" better (a bit). For example, if you have `0-1` and `1-2`, then `0-1` will\
    \ get rounded up to `0.5` instead of `0.0`. So if you just divide `0-1` by 2 you\
    \ get `0.5` instead of `0.0`\n<|/ c |>\n<| c |>\nThat's interesting. That would\
    \ make sense for my particular use case, but I'm thinking this might not work\
    \ well elsewhere if I apply it to numbers in a different range.\n<|/ c |>\n<|\
    \ a tags=arrays,php |>\nThe best solution I found so far is to simply use array_sum()\
    \ with an array_map() call:\n<code>\n$arr = array(1,2,3);\n$result = array_map(function($el){\n\
    \    return $el / array_sum($arr);\n}, $arr);\n</code>\nOutput:\n<code>\nArray\n\
    (\n    [0] => 0\n    [1] => 0.3333333333333333\n    [2] => 0.6\n)\n</code>\n<|/\
    \ a dscore=3 |>\n<| c |>\nI like this solution as it takes the array into account.\
    \ Thanks!\n<|/ c |>\n<| a tags=arrays,php |>\nThe best solution I found is to\
    \ use:\n<code>\narray_sum($arr) / count($arr);\n</code>\n<|/ a dscore=2 |>\n<|\
    \ a |>\nYou can use array_sum() to achieve what you want.\n<code>\n$numbers =\
    \ array(1,2,3,4,5);\n", "  $smallest = min($numbers);\n  $largest = max($numbers);\n\
    \  $range = $largest - $smallest;\n  return $range/$largest;\n}\n", "  return\
    \ array_map(\n    function ($number) {\n      return ($number - min($number))\
    \ / (max($number) - min($number));\n    },\n    $numbers\n  );\n}\n", "    $min\
    \ = min($numbers);\n    $max = max($numbers);\n    if ($min == $max) {\n     \
    \   return array($min);\n    }\n\n    $unit = $min / ($max - $min);\n    $rescaled\
    \ = array();\n    foreach ($numbers as $number) {\n        $rescaled[] = $number\
    \ * $unit;\n    }\n\n    return $rescaled;\n}\n</code>\n<|/ a dscore=1 tags=arrays,php,algorithm\
    \ |>\n<| a |>\nI like Marcelo's answer - very clever.\nBut here's a version that's\
    \ easier to understand. \n<code>\n<?php", "  if (!count($numbers)) {\n    return\
    \ $numbers;\n  }\n  $min_number = reset($numbers);\n  $max_number = end($numbers);\n\
    \  $length = max(count($numbers), count($numbers) >> 1, count($numbers) >> 2,\
    \ count($numbers) >> 3);\n  $scale = ($max_number / $min_number);\n  foreach ($numbers\
    \ as $key => $number) {\n    if ($number >= $min_number && $number < $min_number\
    \ + $scale * $length) {\n      $numbers[$key] = $min_number;\n    } else if ($number\
    \ >= $min_number + $scale * $length) {\n      $numbers[$key] = $min_number + $scale\
    \ * $length;\n    } else if ($number >= $min_number + $scale * $length + $scale\
    \ * $length) {\n      $numbers[$key] = $min_number + $scale * $length + $scale\
    \ * $length;\n    } else {\n      $numbers[$key] = $min_number + $scale * $length\
    \ + $scale * $length + $scale * $length;\n    }\n  }\n  return $numbers;\n}\n",
  "    $min = min($numbers);\n    $max = max($numbers);\n    $num_scales = count($numbers)\
    \ - 1;\n    return array_map(function ($num) use ($max, $min) {\n        return\
    \ $num * ($max - $min) / ($num_scales + 1);\n    }, $numbers);\n}\n</code>\n<|/\
    \ a dscore=4 |>\n<| a |>\nIn a nut shell, if you have a set of numbers to scale\
    \ and you want to transform them in such a way that the smallest number becomes\
    \ 0 and the largest becomes 1, you can do the following:\n<code>\n<?php\n\n$input\
    \ = array(\n   1,\n   2,\n   3,\n   4,\n   5,\n   6\n);\n\n$output = array();\n\
    \nforeach($input as $num) {\n    $output[] = round(($num - min($input)) / max($input)\
    \ - min($input), 1);\n}\n\necho implode(',', $output);\n</code>\nThis outputs:\n\
    <code>\n0.1,0.2,0.3,0.4,0.5,0.6\n</code>\nIf you need slightly different result,\
    \ just replace the min() and max() calls with some different functions.\n<|/ a\
    \ tags=arrays,php,transformation dscore=4 |>\n<| c |>\nThis isn't what the question\
    \ asks. You are calculating the difference between min and max and dividing that\
    \ by the number of elements in the set. Your function should be `round(($num-$min)/($max-$min)-1,1)`\n\
    <|/ c |>\n<| c |>\nThanks for pointing that out. Fixed now. I don't think this\
    \ can go wrong, but I'll double-check.\n<|/ c |>\n<| a dscore=3 |>\nThis can be\
    \ very helpful if you want to create custom transformations like \"scale linearly\
    \ with zero\" and so on.\n<code>", "\tarray_walk($numbers, function (&$value)\
    \ { $value = round($value); });\n\treturn array_map(function ($value) { return\
    \ round($value); }, $numbers);\n}\n", "\t$min = min($numbers);\n\t$max = max($numbers);\n\
    \t$scale = 1 / min($max - $min);\n\t$numbers = array_map(function ($value) use\
    \ ($min, $scale) {\n\t\treturn $value * $scale;\n\t}, $numbers);\n\treturn $numbers;\n\
    }", "  // sort our numbers so that smallest will come first\n  sort($numbers);\n\
    \n  // find min and max\n  $min_value = array_shift($numbers);\n  $max_value =\
    \ array_shift($numbers);\n\n  // scale all values so that min and max are the\
    \ same\n  $scale = 1.0 * ($max_value - $min_value);\n  return array_map(function($value)\
    \ use ($scale) {\n    return ($value - $min_value) / $scale;\n  }, $numbers);\n\
    }\n</code>\n<|/ a |>\n<| c |>\nthank you for your answer. I added my implementation\
    \ to my question.\n<|/ c |>\n<| a |>\nBased on's answer, I adapted it for use\
    \ in an array. I also added an optional param to give the starting position and\
    \ length of each sub array in each array.\n<code>\n$array = [\n        [\n   \
    \         4,\n            6,\n            3,\n            2,\n            1,\n\
    \            5,\n            8,\n            4,\n            3,\n            2,\n\
    \            5,\n            9,\n            7,\n            1,\n            6,\n\
    \            1,\n            1,\n        ],\n        [\n            1,\n     \
    \       6,\n            3,\n            4,\n            3,\n            4,\n \
    \           4,\n            4,\n            2,\n            4,\n            6,\n\
    \            3,\n            4,\n            3,\n            1,\n            6,\n\
    \            5,\n            1,\n            2,\n            1,\n            1,\n\
    \            5,\n            5,\n        ],\n        [\n            3,\n     \
    \       1,\n            3,\n            2,\n            4,\n            4,\n \
    \           6,\n            1,\n            1,\n            1,\n            2,\n\
    \            1,\n            1,\n            3,\n            4,\n            6,\n\
    \            2,\n            2,\n            1,\n            4,\n            1,\n\
    \        ],\n        [\n            2,\n            4,\n            1,\n     \
    \       2,\n            3,\n            3,\n            2,\n            4,\n \
    \           4,\n            4,\n            3,\n            5,\n            6,\n\
    \            3,\n            3,\n            4,\n            4,\n            3,\n\
    \            3,\n            2,\n            3,\n            2,\n        ],\n\
    \        [\n            3,\n            4,\n            4,\n            4,\n \
    \           2,\n            3,\n            3,\n            3,\n            2,\n\
    \            4,\n            4,\n            4,\n            3,\n            4,\n\
    \            4,\n            4,\n            4,\n            2,\n            3,\n\
    \            4,\n            4,\n            4,\n            2,\n        ],\n\
    \        [\n            3,\n            4,\n            4,", "\tglobal $min, $max;\n\
    \tif (count($numbers) < 2) return $numbers;\n\tfor ($i = 1; $i < count($numbers);\
    \ $i++) {\n\t\tif ($numbers[$i] < $min) $min = $numbers[$i];\n\t\tif ($numbers[$i]\
    \ > $max) $max = $numbers[$i];\n\t}\n\tfor ($i = 1; $i < count($numbers); $i++)\
    \ {\n\t\t$numbers[$i] -= $min;\n\t\t$numbers[$i] *= (100 - $min / $max) / 100;\n\
    \t\t$numbers[$i] += $min;\n\t}\n\treturn $numbers;\n}\n", "  if(count($numbers)\
    \ < 2)\n    return array();\n  $min = min($numbers);\n  $max = max($numbers);\n\
    \  if($min == $max)\n    return array($min);\n  $scale = 1.0 * ($max - $min) /\
    \ count($numbers);\n  $offset = $min - ($min * $scale) / 2.0;\n  return array_map(function($x)\
    \ use($offset) {\n    return $offset + $scale * $x;\n  }, $numbers);\n}\n", " \
    \ $min = min($numbers);\n  $max = max($numbers);\n\n  $scale = 1 / ($max - $min);\n\
    \  foreach ($numbers as $key => $number) {\n    $numbers[$key] = $number * $scale;\n\
    \  }\n  return $numbers;\n}\n", "  if (count($numbers) < 2) {\n    return array($numbers[0]);\n\
    \  }\n\n  $min = array_shift($numbers);\n  $max = array_pop($numbers);\n\n  $numbers\
    \ = array_map(function ($number) use ($max, $min) {\n    $scaled = $number - $min;\n\
    \    return $scaled / ($max - $min);\n  }, $numbers);\n\n  return array_merge($numbers);\n\
    }\n</code>\n<|/ a tags=php,arrays,math |>\n<| c |>\nThis is really cool. I love\
    \ how it can work with multidimensional arrays too. Nice!\n<|/ c |>\n<| a tags=php,arrays,math\
    \ |>\nI've just written a small function which solves this problem:\n<code>",
  "    $min = min($numbers);\n    $max = max($numbers);\n    $range = $max - $min;\n\
    \    if ($range == 0) {\n        // all numbers are the same, so simply return\
    \ the array as-is\n        return $numbers;\n    }\n    $offset = array_sum($numbers)\
    \ / count($numbers);\n    return array($min - $offset, $offset + $range);\n}\n\
    </code>\n<|/ a dscore=5 tags=math,php |>\n<| c |>\nThis solution worked perfectly\
    \ for me.  Thanks so much!\n<|/ c |>\n<| a tags=math,php |>\nThis should work:\n\
    <code>", "    return array_map(function ($number) { return ($number > 0.0) ? floor($number\
    \ / 1.0) : floor($number / 1.0) + 1.0; }, $numbers);\n}\n", "    $minimum = min($numbers);\n\
    \    $maximum = max($numbers);\n    \n    // if there are only two elements, there's\
    \ no point in doing any scaling\n    if ($minimum == $maximum) {\n        return\
    \ array($minimum);\n    }\n    \n    $delta = ($maximum - $minimum);\n    \n \
    \   // shift all the elements down by $delta so that all numbers are between 0\
    \ and 1\n    $numbers -= $minimum;\n    \n    // multiply all elements by $delta\
    \ so that all numbers become between 0 and 1\n    foreach ($numbers as $key =>\
    \ $value) {\n        $numbers[$key] = $delta / $value;\n    }\n    \n    return\
    \ $numbers;\n}\n</code>\nThe above function will take in any array of numbers\
    \ $numbers, and will rescale them to be between $minimum and $maximum, where $minimum\
    \ and $maximum are defined above in the function.\n<|/ a dscore=1 tags=php |>\n\
    <| c |>\nThank you so much! Your explanation was very clear and easy to understand.\
    \ Worked perfectly!\n<|/ c |>\n<| c |>\nGlad to help. You can [accept this answer](https://stackoverflow.com/help/accepted-answer)\
    \ if you found it helpful.\n<|/ c |>\n<| c |>\nI ran into a slight issue. I'm\
    \ very new to PHP. I'm getting this error `Warning: Division by zero in C:\\xampp\\\
    htdocs\\test\\index.php on line 13` on line 13 of your code `return array($minimum\
    \ / $delta);`\n<|/ c |>\n<| c |>\nYou'll need to post more code - specifically,\
    \ the code that calls `rescale_to_unit`\n<|/ c |>\n<| c |>\nLine 13 is `return\
    \ array($minimum / $delta);`\n<|/ c |>\n<| a tags=php dscore=1 |>\nJust for fun,\
    \ here is another solution that is a bit simpler. It finds the difference between\
    \ the maximum and the minimum of the given array and uses it for the scale of\
    \ the returned numbers. \n<code>\n<?php\n", "  if (!is_array($numbers)) {\n  \
    \  trigger_error(\"rescale_to_unit() expects argument to be an array\", E_USER_WARNING);\n\
    \    return array();\n  }\n  $lowest = min($numbers);\n  $highest = max($numbers);\n\
    \  if ($lowest > $highest) {\n    trigger_error(\"rescale_to_unit() expects all\
    \ arguments to be >= 0\", E_USER_WARNING);\n    return array();\n  }\n  if ($lowest\
    \ == 0.0) {\n    trigger_error(\"rescale_to_unit() expects at least one argument\
    \ to be >= 0\", E_USER_WARNING);\n    return array();\n  }\n  $range = array();\n\
    \  foreach ($numbers as $number) {\n    $range[] = $number - $lowest;\n  }\n \
    \ if ($range[0] < 0.0) {\n    $range[0] -= 1.0;\n  }\n  if ($range[count($range)\
    \ - 1] > 1.0) {\n    $range[count($range) - 1] -= 1.0;\n  }\n  return $range;\n\
    }\n", "    if (!count($numbers)) return array($numbers[0]);\n    $max = max($numbers);\n\
    \    $min = min($numbers);\n    // $max and $min should be integers, but we might\
    \ have\n    // floating point numbers in $numbers, so we convert them\n    //\
    \ to integers here, to avoid errors later on.\n    $max = (int) $max;\n    $min\
    \ = (int) $min;\n    if ($min == $max) return $numbers;\n    $range = range(1,\
    \ $max + 1);\n    $inv_range = array();\n    foreach ($range as $i => $val) {\n\
    \        if ($i > $min) {\n            $inv_range[$val] = $i - ($min - 1); //\
    \ $min is always at 0\n        }\n    }\n    return array_map(function ($x) use\
    \ ($inv_range) {\n        return $x * $inv_range[$x];\n    }, $numbers);\n}\n",
  "  if (!$numbers) return array();\n\n  $min = $numbers[0];\n  $max = $numbers[0];\n\
    \n  foreach ($numbers as $number) {\n    if ($number < $min) $min = $number;\n\
    \    if ($number > $max) $max = $number;\n  }\n\n  // Normalize the range\n  if\
    \ ($max < 1.0) {\n    $max += 1.0 / ($max - $min);\n  } else {\n    $max -= 1.0\
    \ / $min;\n    $min += 1.0;\n  }\n\n  // Apply new range to array\n  $array =\
    \ array();\n  foreach ($numbers as $number) {\n    $array[] = ($number - $min)\
    \ / ($max - $min);\n  }\n\n  return $array;\n}\n\n/**\n * Return the distance\
    \ between two points.\n *\n * @param array $point1\n * @param array $point2\n\
    \ * @return array\n * @since 5.4.0\n */", "    return array(\n        floor(min(array(min($numbers),\
    \ 1.))),\n        ceil(max(array(max($numbers), 0.))),\n    );\n}\n\n/**\n * Find\
    \ the maximum value of an array in a given array using callback as selector.\n\
    \ * Usage:\n *\n *     $array = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0];\n *     $result\
    \ = max_array($array, function ($val) { return $val * 10; });\n *     $expected\
    \ = array(10.0, 10.0, 10.0, 10.0, 10.0, 10.0);\n *     print_r($result);\n * \
    \    assert($result === $expected);\n *\n * $selector must return scalar.\n */",
  "    $min_number = min($numbers);\n    $max_number = max($numbers);\n    $scale\
    \ = 1.0 / $max_number;\n    $new_numbers = array();\n    for ($i = 0; $i < count($numbers);\
    \ $i++) {\n        $new_numbers[$i] = round($numbers[$i] * $scale);\n    }\n \
    \   return $new_numbers;\n}\n", "  $smallest = min($numbers);\n  $largest = max($numbers);\n\
    \  foreach ($numbers as $key => $number) {\n    if ($number == $smallest) {\n\
    \      $numbers[$key] = 0.0;\n    } else if ($number == $largest) {\n      $numbers[$key]\
    \ = 1.0;\n    }\n  }\n  return $numbers;\n}\n", "    foreach ($numbers as $key\
    \ => $number) {\n        $numbers[$key] = ($number - min($numbers)) / (max($numbers)\
    \ - min($numbers));\n    }\n    return $numbers;\n}\n", "  $min = min($numbers);\n\
    \  $max = max($numbers);\n  $scale = ($max - $min);\n  return array(0, $min /\
    \ $scale, $max / $scale, $scale, $scale);\n}\n\n", "    foreach ($numbers as $number\
    \ => $rescaled_number) {\n        if ($rescaled_number < 0.0) throw new InvalidArgumentException(\"\
    $rescaled_number must be non-negative\");\n        if ($rescaled_number > 1.0)\
    \ throw new InvalidArgumentException(\"$rescaled_number must be <= 1\");\n   \
    \     $numbers[$number] = $rescaled_number;\n    }\n\n    $sum = 0.0;\n    foreach\
    \ ($numbers as $number) {\n        $sum += $number;\n    }\n    if ($sum < 1.0)\
    \ throw new InvalidArgumentException(\"sum must be positive\");\n\n    $scale\
    \ = 1.0 / $sum;\n    foreach ($numbers as $number) {\n        $numbers[$number]\
    \ *= $scale;\n    }\n\n    return $numbers;\n}\n", "  $min = min($numbers);\n\
    \  $max = max($numbers);\n  return array($min == 0.0 ? 0.0 : floor($min / $max),\
    \ $max != 0.0 ? 1.0 : ((1.0 - $min) / (1.0 - $max)));\n}\n", "    $min = array_shift($numbers);\n\
    \    $max = array_shift($numbers);\n\n    $factor = pow($max, 1.0) / pow($min,\
    \ 1.0);\n\n    return array_map(function($number) use ($factor) {\n        return\
    \ $number * $factor;\n    }, $numbers);\n}\n", "    // Find highest and lowest\
    \ numbers in the array\n    $high = array_reduce($numbers, function($highest,\
    \ $number) { return max($highest, $number); }, 0);\n    $low  = array_reduce($numbers,\
    \ function($lowest, $number) { return min($lowest, $number); }, 0);\n\n    //\
    \ Normalize the numbers in the array\n    $numbers = array_map(function($number)\
    \ { return ($number - $low) / ($high - $low); }, $numbers);\n\n    return $numbers;\n\
    }", "  if (!count($numbers)) {\n    return array(array());\n  }\n\n  $smallest\
    \ = min(array_keys($numbers));\n  $largest = max(array_keys($numbers));\n\n  foreach\
    \ ($numbers as &$number) {\n    $number -= $smallest;\n  }\n\n  return array(array_fill($smallest,\
    \ 1, $largest), array_fill($largest, 0, $smallest));\n}\n", "    $smallest_number\
    \ = min($numbers);\n    $max_number = max($numbers);\n    $normalized_numbers\
    \ = array();\n\n    for ($i = 0; $i < count($numbers); $i++) {\n        $normalized_numbers[$i]\
    \ = ($numbers[$i] - $smallest_number) / ($max_number - $smallest_number);\n  \
    \  }\n\n    return $normalized_numbers;\n}\n</code>\n<|/ a dscore=1 tags=php,algorithm,math\
    \ |>\n<| a |>\nThe first step is to define the range of values you expect to see.\n\
    The second step is to define the range of the values you expect to see and to\
    \ define your desired output range.\nThe third step is to find the desired output\
    \ range.\nThe fourth step is to compare the expected output range to each possible\
    \ output range.\nThe fifth step is to compare the expected output range to the\
    \ actual output range.\nSo we might expect to see something like this in PHP:\n\
    <code>\n$expected_output = array(\n    array(0,0.25),\n    array(0.25,0.5),\n\
    \    array(0.5,0.75),\n    array(0.75,1),\n);\n\n$actual_output = array(\n   \
    \ array(0,1),\n    array(1,0),\n    array(1,0),\n    array(1,0),\n);\n\n$expected_output\
    \ == $actual_output\n</code>\nWe can then compare the expected output to each\
    \ possible output to find the correct one.\n<code>\n$expected_output_length =\
    \ count($expected_output);\n\n$actual_output_length = count($actual_output);\n\
    \nfor ($i = 0; $i < $expected_output_length; $i++) {\n    $expected_output[$i][0]\
    \ = $expected_output[$i][0];\n    $actual_output[$i][0] = $actual_output[$i][0];\n\
    }\n\nfor ($j = 1; $j < $actual_output_length; $j++) {\n    for ($i = 0; $i < $expected_output_length;\
    \ $i++) {\n        if ($expected_output[$i][$j] < $actual_output[$i][$j]) {\n\
    \            $expected_output[$i][$j] = $actual_output[$i][$j];\n        }\n \
    \   }\n}\n\n$output_range = array($expected_output);\n\nfor ($i = 0; $i < $actual_output_length;\
    \ $i++) {\n    if ($expected_output == $actual_output) {\n        $output_range[]\
    \ = array($actual_output[$i]);\n    } else {\n        foreach ($expected_output\
    \ as $expected_output) {\n            if ($expected_output == $actual_output)\
    \ {\n                $output_range[] = array($actual_output[$i]);\n          \
    \  }\n        }\n    }\n}\n\n$output_range\n</code>\nResults:\n<code>\nArray\n\
    (\n    [0] => Array\n        (\n            ", "    if (!is_array($numbers)) {\n\
    \        return FALSE;\n    }\n    $largest = max($numbers);\n    $smallest =\
    \ min($numbers);\n    if ($largest == $smallest) {\n        return $numbers;\n\
    \    }\n    $scale = ($largest - $smallest) / 2;\n    $scaled_numbers = array();\n\
    \    foreach ($numbers as $number) {\n        $scaled_numbers[] = round($number\
    \ / $scale) * $scale;\n    }\n    return $scaled_numbers;\n}\n</code>\n<|/ a tags=math,php\
    \ |>\n<| c |>\n`array(0.25, 0.5, 0.75, 1.0)` makes more sense.\n<|/ c |>\n<| c\
    \ |>\nActually, that would make them not even numerically differentiable.  But\
    \ that's not what is being asked for, so I changed it.\n<|/ c |>\n<| c |>\nAh.\
    \ Right. Didn't realize that about linear scaling. Oh well.\n<|/ c |>\n<| c |>\n\
    Agreed. My bad.\n<|/ c |>\n<| c |>\nYep, I agree with you on this. This was just\
    \ a quick test to see what kind of result I needed to get. But, I'll use this\
    \ for sure. Thanks!\n<|/ c |>\n<| a dscore=2 |>\nIf you have the mean and variance\
    \ (which you can get from array_sum and array_sum_sd) you can calculate the result\
    \ you want:\n<code>\n$input  = array(1.0, 2.0, 3.0, 4.0, 5.0);\n$mean   = array_sum($input)\
    \ / count($input);\n$var    = array_sum(array_diff($input, array($mean))) / count($input)\
    \ - $mean * $mean;\n$result = (1 - $var) * $mean + $var;\n\nvar_dump($result);\n\
    </code>\nhttps://3v4l.org/BVygQ\n<|/ a tags=math,php |>\n<| c |>\nI did something\
    \ similar to this with your code. Thanks!\n<|/ c |>\n<| a |>\n<code>\n<?php",
  "  // Find the minimum number\n  $min = array_shift($numbers);\n  // Find the maximum\
    \ number\n  $max = array_shift($numbers);\n  // Find the mean of the numbers\n\
    \  $mean = $min + $max;\n  // Scale the numbers so that their mean is $mean\n\
    \  $numbers = array_map(\n    function($number) use ($mean) {\n      return $number\
    \ * $mean / 0.5;\n    },\n    $numbers\n  );\n  // Return the result\n  return\
    \ $numbers;\n}\n", "  list($minimum, $maximum) = array_pad(array_filter(array_min($numbers),\
    \ $numbers), 2, 0);\n  return array($minimum, 1 - $maximum);\n}\n", "    list($min_value,\
    \ $max_value) = array_pad($numbers, 2, 0);\n\n    if ($min_value < $max_value)\
    \ {\n        $min_value /= 100;\n        $max_value /= 100;\n    } else {\n  \
    \      $min_value *= 100;\n        $max_value *= 100;\n    }\n\n    $range = $max_value\
    \ - $min_value;\n    $min_value = round($min_value * (1 - 1 / $range));\n    $max_value\
    \ = round($max_value * (1 - 1 / $range));\n\n    return array_map(function($n)\
    \ { return round($n * $range + $min_value); }, $numbers);\n}\n\n/**\n * Resize\
    \ an image\n *\n * @param $src\n * @param $dst\n * @param int|null $width\n *\
    \ @param int|null $height\n * @param string    $mode\n */", "  // Make sure all\
    \ numbers are of the same type\n  foreach ($numbers as &$number) {\n    $number\
    \ = is_numeric($number) ? $number : 0;\n  }\n\n  // Sum all numbers up and subtract\
    \ min from sum\n  $sum = array_sum($numbers);\n  return array(\n    $sum / array_sum(array_map(function($number)\
    \ { return pow($number, 2); }, $numbers)),\n  );\n}\n", "  if (!$numbers || count($numbers)\
    \ < 2) {\n    return $numbers;\n  }\n  // Find the lowest and highest numbers\n\
    \  $lowest_number = array_shift($numbers);\n  $highest_number = array_pop($numbers);\n\
    \  // Return an empty array if the input is the same as the output\n  if ($lowest_number\
    \ == $highest_number) {\n    return $numbers;\n  }\n\n  // Calculate the difference\
    \ between the highest and lowest numbers\n  $min_diff = $highest_number - $lowest_number;\n\
    \  // Return the difference rounded upwards if it's an integer\n  return array(ceil($min_diff\
    \ * 10) / 10);\n}\n</code>\nAnd finally, the functional test:\n<code>", "    if\
    \ (count($numbers) < 2) {\n        return $numbers;\n    }\n\n    $minimum = min($numbers);\n\
    \    $maximum = max($numbers);\n\n    $output = $numbers;\n    for ($i = 0; $i\
    \ < count($numbers); ++$i) {\n        $output[$i] = (($output[$i] - $minimum)\
    \ / ($maximum - $minimum));\n    }\n\n    return $output;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nI appreciate this a lot but that isn't my solution. I need it to\
    \ be a linear transform that increases the smallest numbers to 0 and decreases\
    \ the largest numbers to 1. I didn't mention this in my question because I thought\
    \ it was implied, but it was a mistake. Sorry for the confusion.\n<|/ c |>\n<|\
    \ c |>\nYeah, that's unfortunate. Linear transforms tend to make things look better\
    \ in some cases, and I don't see why this wouldn't work just as well. However,\
    \ I may have misunderstood your problem (I thought you meant the numbers in the\
    \ array were already in that range).\n<|/ c |>\n<| a dscore=0 tags=php,math,algorithm\
    \ |>\nThis code seems to work fine, even on huge arrays, although it's not the\
    \ most efficient:\n<code>\n$array = [1, 5, 2, 7, 3, 4, 5];\nsort($array);\n$max\
    \ = $array[0];\n$min = $array[count($array) - 1];\n$scale = 1;\n\nfor ($i = 0;\
    \ $i < count($array); $i++) {\n    $scale = $scale / ($max - $min);\n    $array[$i]\
    \ = $min + ($array[$i] - $min) * $scale;\n}\n</code>\n<|/ a |>\n<| c |>\nThanks\
    \ for the response. This is what I originally tried but since it isn't the most\
    \ efficient it took much longer to output the results.\n<|/ c |>\n<| a dscore=0\
    \ |>\nI wrote my own function based on answers given by others. But I also wanted\
    \ to keep the original array as is. I didn't want to modify it since I have other\
    \ functions that use this array and I don't want to alter them. But since I didn't\
    \ want to change these functions, I made a copy and then made this function to\
    \ work on that copy.\nI made a copy and then I used the function below to make\
    \ the changes to the copy. Because the original array is being altered during\
    \ the loop, I can't just use array_map() since I need to keep the original array\
    \ intact.\n<code>\n<?php", "  $min = min($numbers);\n  $max = max($numbers);\n\
    \  return array_map(function ($number) use ($min, $max) {\n    return $number\
    \ - ($number % $max - $min) / $max;\n  }, $numbers);\n}\n", "    $rescaled_numbers\
    \ = array();\n    $smallest_number = array_pop($numbers);\n    $largest = array_pop($numbers);\n\
    \    foreach ($numbers as $number) {\n        $rescaled_numbers[] = $smallest_number\
    \ + ($number / $largest) * (1 - $smallest_number);\n    }\n    return $rescaled_numbers;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nNo, that's the wrong approach. You're\
    \ going to end up with a bunch of numbers less than 1, as they're not scaled up\
    \ by the max value. The `max()` function isn't helpful.\n<|/ c |>\n<| c |>\nYes,\
    \ this approach is wrong, sorry. I've edited my answer.\n<|/ c |>\n<| a dscore=0\
    \ |>\nSo you want a random distribution of numbers between 0 and 1? I'd do this:\n\
    <code>\n$total = array_sum($data);\n$random = array();\nwhile ($total > 0) {\n\
    \   $i = rand(0, $total-1);\n   $random[] = $data[$i];\n   $total -= $data[$i];\n\
    }\n</code>\n<|/ a tags=php,numbers |>\n<| a |>\nThe answer provided is correct,\
    \ but I wanted to offer this more verbose and efficient solution:\n<code>", " \
    \ return array_map(function ($number) { return max(0, min(1, $number)); }, $numbers);\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks for your answer. I'll give it a\
    \ try as soon as I'm back at my computer tomorrow. One question though: why did\
    \ you use `array_map` instead of `array_walk`?\n<|/ c |>\n<| c |>\nI guess array_map\
    \ would do exactly the same thing (array_walk calls the callback function with\
    \ each element), except that array_map returns an array, so you can reuse the\
    \ array that array_map returns, whereas array_walk returns nothing.\n<|/ c |>\n\
    <| c |>\nAh, I see. That's really clever. I've never seen that function before.\
    \ Thanks for sharing. :)\n<|/ c |>\n<| a |>\nHere's a solution using array_map:\n\
    <code>", "  if (empty($numbers)) {\n    return $numbers;\n  }\n  $min = $numbers[0];\n\
    \  $max = array_reduce($numbers, 'max');\n  return array_map(function ($x) use\
    \ ($min, $max) {\n    return $x - $min < 0 ? ($max - $min) / $x : 1;\n  }, $numbers);\n\
    }\n", "    if (empty($numbers) || count($numbers) < 2) {\n        return $numbers;\n\
    \    }\n\n    $min_number = array_reduce($numbers, 'min');\n    $max_number =\
    \ array_reduce($numbers, 'max');\n\n    $factor = ($max_number - $min_number)\
    \ / count($numbers);\n\n    return array_map(function($number) use ($factor) {\
    \ return ($number * $factor) + $min_number; }, $numbers);\n}\n</code>\n<|/ a |>\n\
    <| c |>\nI didn't know about `array_reduce`, thank you for that tip. I updated\
    \ my answer to use it.\n<|/ c |>\n<| a dscore=0 |>\n<code>\n<?php\n", "  $min\
    \ = min($numbers);\n  $max = max($numbers);\n  return array(\n    intval($min\
    \ / 0.1),\n    intval($max / 0.1),\n  );\n}\n", "    return array_map(function\
    \ ($num) { return $num / $num[0]; }, $numbers);\n}\n</code>\n<|/ a tags=math,php\
    \ |>\n<| c |>\nThanks for the code. I'm going to test it out when I get home later\
    \ today or tomorrow.\n<|/ c |>\n<| c |>\nIt's not working. I'm getting a blank\
    \ array. I'm getting two blank arrays. `Array\n(\n    [0] => Array\n        (\n\
    \        )\n\n    [1] => Array\n        (\n        )\n)`\n<|/ c |>\n<| c |>\n\
    Can you show us what `$numbers` looks like? Also, what is the `var_dump($numbers)`\
    \ output?\n<|/ c |>\n<| c |>\nI added my code to the question, and I replaced\
    \ $numbers with $numbers, $number1, $number2, $number3, $number4 in that order\
    \ (with each of them containing an array of numbers).\n<|/ c |>\n<| c |>\nMy code\
    \ outputs the following: `Array\n(\n    [0] => Array\n        (\n        )\n\n\
    \    [1] => Array\n        (\n        )\n\n    [2] => Array\n        (\n     \
    \   )\n\n    [3] => Array\n        (\n        )\n\n    [4] => Array\n        (\n\
    \        )\n\n)`\n<|/ c |>\n<| a tags=math,php |>\nAssuming you have an array\
    \ of numbers, I wrote an answer that might help you do what you're looking for.\
    \ It will find the maximum value in the array and scale it so that the maximum\
    \ value remains the same.\n<code>", "    foreach ($numbers as &$n) {\n       \
    \ $n = $n * 1.0;\n    }\n\n    return $numbers;\n}", "    $min = min($numbers);\n\
    \    $max = max($numbers);\n    return array_map(function ($number) {\n      \
    \  return $number - $min;\n    }, array_values($numbers));\n}\n", "  $min = array_shift($numbers);\n\
    \  $max = array_shift($numbers);\n  $result = [];\n  for ($i = 0; $i < count($numbers);\
    \ $i++) {\n    $result[$i] = $numbers[$i] / $max;\n  }\n  return $result + [1\
    \ - $min / $max];\n}", "    if (count($numbers) < 2) {\n        return array();\n\
    \    }\n\n    $new_min = min(array_map('min', $numbers));\n    $new_max = max(array_map('max',\
    \ $numbers));\n\n    return array_map(function ($number) use ($new_min, $new_max)\
    \ {\n        return $number / $new_max - $new_min + $new_min;\n    }, $numbers);\n\
    }\n", "    $smallest = $numbers[0];\n    $largest = $numbers[0];\n    foreach\
    \ ($numbers as $number) {\n        if ($number < $smallest) {\n            $smallest\
    \ = $number;\n        }\n        if ($number > $largest) {\n            $largest\
    \ = $number;\n        }\n    }\n\n    return array($smallest, ($smallest - $largest)\
    \ / ($numbers[0] - $largest));\n}\n", "  $min = min($numbers);\n  $max = max($numbers);\n\
    \n  $numbers = array(\n    $min < 0 ? 0 : $min,\n    $max < 0 ? 0 : $max,\n  );\n\
    \n  return $numbers;\n}\n", "  if (count($numbers) < 2) {\n    return $numbers;\n\
    \  }\n\n  sort($numbers);\n  $smallest = array_shift($numbers);\n  $largest =\
    \ array_pop($numbers);\n  $range_length = ($largest - $smallest);\n  $range =\
    \ array();\n  $i = 0.0;\n  $length = count($numbers);\n  for ($j=0; $j < $length;\
    \ $j++) {\n    $range[$j] = $i / $length * ($numbers[$j] - $smallest);\n    $i++;\n\
    \  }\n\n  $smallest_zero = ($smallest == 0.0);\n  $largest = 1;\n  foreach ($range\
    \ as $key => $value) {\n    if ($smallest_zero && ($value == 0.0)) {\n      $smallest\
    \ = 0;\n    }\n    if ($value == 1.0) {\n      $largest = 1;\n    } else if ($value\
    \ == $range[$key]+1) {\n      $largest = $value;\n    } else {\n      $largest\
    \ = $range[$key];\n    }\n  }\n  $range[$length] = $largest;\n  return $range;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nthanks for your answer, but i want to\
    \ use the function on a specific array (for example $numbers = array(0.0, 0.25,\
    \ 0.5, 0.75, 1.0)) i want to keep this array in the function and just use it to\
    \ get the result from that function\n<|/ c |>\n<| c |>\nThe function should return\
    \ a new array with the result of the transformation. If you just want to apply\
    \ the transformation to `$numbers` you can just use the code above. `rescale_to_unit(array(0.0,\
    \ 0.25, 0.5, 0.75, 1.0))` should return `array(0.0, 0.25, 0.5, 0.75, 1.0)`. Have\
    \ you tried it?\n<|/ c |>\n<| a tags=php,arrays |>\n<code>\n$numbers = array(0.0,\
    \ 0.25, 0.5, 0.75, 1.0);\n$new_numbers = array();\n$size = count($numbers);\n\
    for ($i = 0; $i < $size; $i++) {\n    $new_numbers[] = round($numbers[$i] / $size\
    \ * ($size - 1));\n}\nprint_r($new_numbers);\n</code>\n<|/ a dscore=2 |>\n<| c\
    \ |>\nthanks for your answer, but i want to use the function on a specific array\
    \ (for example $numbers = array(0.0, 0.25, 0.5, 0.75, 1.0)) i want to keep this\
    \ array in the function and just use it to get the result from that function\n\
    <|/ c |>\n<| c |>\nOk, I'll edit my answer accordingly.\n<|/ c |>\n<| a |>\n<code>\n\
    $numbers = array(0.0, ", "\t$smallest = $numbers[0];\n\t$largest = $numbers[0];\n\
    \tforeach ($numbers as $number) {\n\t\tif ($number < $smallest) {\n\t\t\t$smallest\
    \ = $number;\n\t\t}\n\t\tif ($number > $largest) {\n\t\t\t$largest = $number;\n\
    \t\t}\n\t}\n\n\t$range = array(\n\t\t'smallest' => $smallest,\n\t\t'largest' =>\
    \ $largest,\n\t);\n\n\t// If smallest == largest, there is nothing to do.\n\t\
    if ($range['smallest'] == $range['largest']) {\n\t\treturn array();\n\t}\n\n\t\
    $scale = array(\n\t\t'smallest' => min($range['smallest'], $range['largest']),\n\
    \t\t'largest' => max($range['smallest'], $range['largest']),\n\t);\n\n\t// If\
    \ the smallest and largest are the same, scale is 1.\n\tif ($scale['smallest']\
    \ == $scale['largest']) {\n\t\treturn array($scale['smallest']);\n\t}\n\n\t//\
    \ Divide all numbers in the range by the scale\n\t// and multiply by 100 to get\
    \ the number of\n\t// percentages to scale by.\n\t$resultingPercentages = array();\n\
    \tforeach ($numbers as $number) {\n\t\t$resultingPercentages[] = $number / $scale['smallest']\
    \ * 100;\n\t}\n\n\t// Now multiply all the percentage numbers by the scale\n\t\
    // and get the smallest number by taking the sum.\n\t$smallestPercentage = array_sum($resultingPercentages);\n\
    \t$smallestPercentage = round($smallestPercentage);\n\t$smallestPercentage = ($smallestPercentage\
    \ / 100) * $scale['smallest'];\n\n\t// Now that we've calculated the smallest\
    \ percentage,\n\t// we need to reset the array of percentages to get\n\t// the\
    \ largest percentage.\n\t$resultingPercentages = array();\n\tforeach ($numbers\
    \ as $number) {\n\t\t$resultingPercentages[] = $number / $scale['largest'] * 100;\n\
    \t}\n\t$largestPercentage = array_sum($resultingPercentages);\n\t$largestPercentage\
    \ = round($largestPercentage);\n\t$largestPercentage = ($largestPercentage / 100)\
    \ * $scale['largest'];\n\n\t// The smallest percentage doesn't really matter in\
    \ our case.\n\t// Just multiply by 100 to get the number of percentages.\n\tarray_unshift($resultingPercentages,\
    \ ($smallestPercentage));\n\n\t// Now multiply all the percentage numbers by the\
    \ scale\n\t// and get the largest number by taking the sum.\n\t$largestPercentage\
    \ = array_sum($resultingPercentages);\n\t$largest", "    sort($numbers);\n   \
    \ return array_map(function ($x) {\n        return $x / $numbers[0];\n    }, $numbers);\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI really need to use `array_map()`. Otherwise\
    \ this doesn't work. Your `rescale_to_unit()` function does work, though. I just\
    \ have to modify it so that it can handle arrays with multiple elements.\n<|/\
    \ c |>\n<| c |>\n, `array_map` will accept multiple arrays just fine, it just\
    \ doesn't return an array. I've updated the example to show how you can do that\
    \ with your function.\n<|/ c |>\n<| c |>\n, also, I've added a more functional\
    \ way to do this with array_reduce, which may be more elegant for your use.\n\
    <|/ c |>\n<| c |>\nI really don't understand how `array_reduce()` would work,\
    \ but I haven't tried it yet. Maybe this time I'll do some research. Thanks for\
    \ the answer.\n<|/ c |>\n<| c |>\n, I looked it up, and it works by taking the\
    \ return value of array_reduce (in this case, a sum) and dividing each element\
    \ by the sum. array_reduce takes two arguments: a function and an initial value.\
    \ The initial value should be the sum, which is then repeated for each item in\
    \ the array. The return value of array_reduce is the sum of the elements in the\
    \ array. So in this case, we're taking the sum of the array and dividing it by\
    \ the sum of the elements. It's kind of like doing a `foreach` loop and adding\
    \ all the elements to a sum variable, then dividing it by the number of elements\
    \ in the array.\n<|/ c |>\n<| a dscore=0 |>\nYou can use this function which I\
    \ found from php.net:\n<code>", "    $min = array_shift($numbers);\n    foreach\
    \ ($numbers as $key => $num) {\n        $numbers[$key] = $num / $min;\n    }\n\
    \    return $numbers;\n}\n</code>\n<|/ a dscore=4 |>\n<| a tags=numbers,math,arrays,php,division\
    \ |>\nFor anyone looking for a simple solution to array division for numbers in\
    \ ranges, this is what I came up with:\n<code>\n$range = [0, 10, 20];\n$numbers\
    \ = [10, 5, 20, 40];\n\n$nums = array_map(function($num) use ($range) {\n    return\
    \ $num / array_reduce($range, function ($prev, $cur) {\n        return $prev +\
    \ $cur;\n    }, 0);\n}, $numbers);\n\nprint_r($nums);\n</code>\nResult:\n<code>\n\
    Array\n(\n    [0] => 0.2\n    [1] => 0.3\n    [2] => 0.4\n)\n</code>\n<|/ a dscore=3\
    \ |>\n<| a tags=numbers,math,arrays,php,division |>\n<code>", "    if (count($numbers)\
    \ < 2) {\n        return $numbers;\n    }\n\n    // If it's already in the range\
    \ [0, 1] and is close to 0 or 1, then just return the numbers as is\n    if ($numbers[0]\
    \ >= 0.0 && $numbers[0] <= 1.0 && $numbers[1] >= 0.0 && $numbers[1] <= 1.0) {\n\
    \        return $numbers;\n    }\n\n    $min = min(array($numbers[0], $numbers[1]));\n\
    \    $max = max(array($numbers[0], $numbers[1]));\n    $range = max($max - $min);\n\
    \n    return $numbers[0] - ($range * $numbers[0] / $range);\n}", "  $min = $numbers[0];\n\
    \  $max = $numbers[0];\n  foreach ($numbers as $number) {\n    if ($number < $min)\
    \ {\n      $min = $number;\n    }\n    if ($number > $max) {\n      $max = $number;\n\
    \    }\n  }\n\n  $min_abs = abs($min);\n  $min_percent = $min_abs / array_sum($numbers);\n\
    \  $scale = array_reduce($numbers, function ($acc, $item) {\n    return $acc +\
    \ 1 / $item;\n  }, $min_percent);\n  return array_map(function ($number) {\n \
    \   return $number * $scale;\n  }, $numbers);\n}\n", "    if (empty($numbers))\
    \ {\n        return array();\n    }\n    $smallest = min($numbers);\n    $largest\
    \ = max($numbers);\n    if ($smallest == $largest) {\n        return $numbers;\n\
    \    }\n\n    $range = $largest - $smallest;\n    if ($range == 0.0) {\n     \
    \   return array($smallest);\n    }\n\n    $number_of_units = round($range / $smallest);\n\
    \    if ($number_of_units == 1) {\n        return array($smallest);\n    }\n\n\
    \    $units = array();\n    $unit = ($range / $number_of_units);\n    for ($i\
    \ = 0; $i < $number_of_units; $i++) {\n        $units[] = $unit * ($i + 1);\n\
    \    }\n\n    return $units;\n}\n</code>\n<|/ a tags=arrays,php,math,array-formulas,algorithm\
    \ |>\n<| c |>\nThe code is actually correct, if you add $smallest = 1; $largest\
    \ = count($numbers); before the for($i = 0...) loop and $smallest = $numbers[0];\
    \ $largest = $numbers[count($numbers)-1]; after the loop, it will work as expected.\n\
    <|/ c |>\n<| a dscore=1 |>\nThis question has already been answered here: https://stackoverflow.com/a/954612/1727693\n\
    <code>\n/**\n * $numbers List of numbers to scale\n * $min Minimum value of the\
    \ new scale\n * $max Maximum value of the new scale\n * $step Increment between\
    \ each element\n * $output Array to return with the new scale\n * $output will\
    \ be modified directly\n * \n * $numbers[] $output\n */", "    $min = array_shift($numbers);\n\
    \    return array_map(function($num) use ($min) {\n        return $num / max($min,\
    \ $num);\n    }, $numbers);\n}\n</code>\n<|/ a tags=linear-algebra,math,php,algorithm,arrays\
    \ |>\n<| c |>\nThis is a very good idea, but in practice it doesn't work very\
    \ well (especially when applied to an array), since it rescales the numbers to\
    \ integers instead of floats (which are not exactly the same thing). I've added\
    \ a quick and dirty fix to my original answer, which you can find in the edit\
    \ history.\n<|/ c |>\n<| c |>\n- Thanks for the heads-up. I've updated the answer\
    \ so that it doesn't use the `intval` function but instead just converts all numbers\
    \ to floats.\n<|/ c |>\n<| c |>\nThis is indeed a great answer, and I upvoted\
    \ it. But I decided to go with a different approach that uses [Haskell](http://stackoverflow.com/questions/16351875/algorithm-for-in-place-rescaling-of-array-of-numbers-into-a-new-array-of-numbers).\n\
    <|/ c |>\n<| c |>\n- I understand where you're coming from, but I feel that a\
    \ quick and simple approach is much better than using Haskell for something like\
    \ this.\n<|/ c |>\n<| a |>\nThe function below rescales the values in $numbers\
    \ to fit into the $min and $max range.\n<code>", "    $max = (count($numbers)\
    \ > 1) ? max($numbers) : 1;\n    return array_map(function ($number) { return\
    \ $number * $max; }, $numbers);\n}\n", "  if (empty($numbers)) {\n    return array();\n\
    \  }\n\n  return array_map(function ($x) {\n    return round($x / min(1.0, max(0.0,\
    \ $x)));\n  }, $numbers);\n}\n</code>\nNow your function will be something like:\n\
    <code>", "  $min = min($numbers);\n  $max = max($numbers);\n  $range = range($min,\
    \ $max);\n\n  return array_map(function($number) use ($range) {\n    return $number\
    \ / $range;\n  }, $numbers);\n}", "  $scales = array();\n  foreach ($numbers as\
    \ $k => $v) {\n    if (is_numeric($v)) {\n      $scales[$k] = $v;\n    } else\
    \ {\n      $scales[$k] = 0.0;\n    }\n  }\n  return $scales;\n}\n\n/**\n * Given\
    \ an array of numbers, return an array of their logs.\n * If any number has a\
    \ log of 0 or less, it is changed to a 0.\n * If all numbers are negative, they\
    \ are also changed appropriately.\n *\n * NOTE: This function is not entirely\
    \ robust. Negative zero is not always 0.\n *\n * @param array $numbers Array of\
    \ numbers to take the log of\n * @return array Array of logs of all of the numbers,\
    \ or an empty array if none.\n */", "    $min = min($numbers);\n    $max = max($numbers);\n\
    \    $range = max($max, $min);\n    if ($range == 0.0 && count($numbers) == 2)\
    \ {\n        return array(1.0, 1.0);\n    }\n    return array($min / $range, $max\
    \ / $range);\n}\n", "    if (count($numbers) < 2) {\n        return $numbers;\n\
    \    }\n    $min = min($numbers);\n    $max = max($numbers);\n    return array(($min\
    \ - floor($min)), ($max - floor($max)), ($max - $min), $max, $min);\n}\n", " \
    \ $smallest = min($numbers);\n  $largest = max($numbers);\n  return array_map(function\
    \ ($val) use ($smallest, $largest) {\n    return $val * ($largest / $smallest);\n\
    \  }, $numbers);\n}\n", "  $min = min($numbers);\n  $max = max($numbers);\n  $output\
    \ = [];\n  for ($i = $min; $i <= $max; $i += 0.25) {\n    $output[] = ($i - $min)\
    \ / ($max - $min);\n  }\n  return $output;\n}\n", "    $min = min($numbers);\n\
    \    $max = max($numbers);\n    $diff = abs($max - $min);\n    // The first number\
    \ will be zero because the difference is negative (so min/max will also be 0)\n\
    \    // In that case we'll just have to divide by the difference\n    // If there's\
    \ no difference, we'll just have to divide by 1\n    return $diff === 0 ? array($numbers[0]\
    \ / $diff) \n                       : array((0.0 - $min) / $diff, \n         \
    \                        (1.0 - $min) / $diff);\n}\n</code>\n<|/ a tags=math,algorithm,php,statistics,scaling\
    \ dscore=4 |>\n<| c |>\nThis isn't the answer, but it is useful nonetheless, so\
    \ I will upvote it. Unfortunately, it isn't what I asked for. I was hoping for\
    \ a solution that was a mathematical equation that would handle all cases. I appreciate\
    \ the input though.\n<|/ c |>\n<| c |>\n: I'm not aware of any formulas that work\
    \ better than what I've put there, although it would be nice if they did. Your\
    \ requirements aren't particularly clear, so I've had to make an arbitrary assumption:\
    \ that numbers are positive (even negative). I don't know if that is really a\
    \ requirement of the problem you're solving, and if it is, then my answer won't\
    \ work.\n<|/ c |>\n<| a tags=math,algorithm,php,statistics,scaling |>\nThis is\
    \ a function which will scale the values between -1 and 1. The function will return\
    \ a value that is the most similar number between your input array.\n<code>",
  "  $min = min($numbers);\n  $max = max($numbers);\n  if ($min == $max) {\n    return\
    \ array($min);\n  }\n  $diff = abs($min - $max);\n  $scale = ($diff == 0.0) ?\
    \ 1.0 : ($diff / $min);\n  $offset = $min * $scale;\n  return array($offset +\
    \ ($max - $min) * $scale);\n}\n", "    if (count($numbers) <= 1) return $numbers;\n\
    \    $range = array_diff(range(min(array_keys($numbers)), max(array_keys($numbers))),\
    \ array_keys($numbers));\n    $rescaled = array();\n    foreach ($numbers as $number)\
    \ {\n        $rescaled[] = ($number - min(array_keys($numbers)) * 1.0 / count($range))\
    \ * 1.0 / count($range);\n    }\n    return $rescaled;\n}\n</code>\n<|/ a dscore=4\
    \ |>\n<| c |>\nThis solution is awesome! I used it for my own application. Great\
    \ work\n<|/ c |>\n<| a dscore=3 |>\n<code>", "    if (count($numbers) <= 1) return\
    \ $numbers;\n\n    $scales = array_shift($numbers);\n    sort($numbers);\n\n \
    \   // Find the smallest and largest\n    $smallest = $numbers[0];\n    $largest\
    \ = array_pop($numbers);\n\n    // Get the difference between smallest and largest\n\
    \    $delta = $largest - $smallest;\n\n    // Multiply each number by the difference\n\
    \    foreach($numbers as $number) {\n        $number *= $delta;\n    }\n\n   \
    \ // Add smallest and largest\n    array_unshift($numbers, $smallest);\n    array_push($numbers,\
    \ $largest);\n\n    return $numbers;\n}\n</code>\n<|/ a dscore=5 tags=arrays,math,php\
    \ |>\n<| c |>\nThis one is actually the only one that actually works - thank you.\
    \ Should be the accepted answer.\n<|/ c |>\n<| c |>\nThis should be the accepted\
    \ answer. The accepted answer fails when dealing with negative numbers. I edited\
    \ my answer to include a more complex `array_combine`-based solution.\n<|/ c |>\n\
    <| c |>\nI like this solution the best. It's also very simple, and I didn't need\
    \ to alter it for negative numbers. All you have to do is subtract `abs($smallest)`\
    \ from the numbers and it should work.\n<|/ c |>\n<| c |>\nThis is by far the\
    \ most elegant solution. Thank you for sharing.\n<|/ c |>\n<| c |>\nIf you're\
    \ looking for an alternative to `array_combine`, there's a simpler version: `$result\
    \ = array();\n$smallest = $largest = 0;\nforeach ($numbers as $number)\n{ \n \
    \   $smallest = $number < $smallest ? $number : $smallest;\n    $largest = $number\
    \ > $largest ? $number : $largest;\n    $result[] = $number - $smallest / $largest;\n\
    }\nreturn $result;`\n<|/ c |>\n<| a |>\n<code>\n$numbers = array();\nforeach($numbers\
    \ as $n) $numbers[] = $n - array_sum($numbers) / count($numbers);\n</code>\n<|/\
    \ a tags=arrays,math,php dscore=5 |>\n<| c |>\nThis solution is very simple and\
    \ elegant.  Thank you.\n<|/ c |>\n<| c |>\nIt doesn't work for negative numbers,\
    \ as [Jonathan H's answer](https://stackoverflow.com/a/5228759/183258) does.\n\
    <|/ c |>\n<| ", "    if (count($numbers) < 2) {\n        return array(0.0);\n\
    \    }\n    $a = min($numbers);\n    $b = max($numbers);\n    $n = count($numbers);\n\
    \    $k = 0;\n    $result = array();\n    while ($k++ < $n) {\n        // compute\
    \ linear slope\n        $m = $b;\n        $c = 0;\n        while ($m >= $numbers[$k])\
    \ {\n            $m -= $numbers[$k];\n            $c += $numbers[$k];\n      \
    \  }\n        $result[$k] = $c / $m;\n        // compute new b\n        $m = $a\
    \ - $numbers[$k];\n        $c = 0;\n        while ($m <= $b) {\n            $m\
    \ += $numbers[$k];\n            $c += $numbers[$k];\n        }\n        $result[$k]\
    \ = $c / $m;\n        // compute new a\n        $m = $b;\n        $c = 0;\n  \
    \      while ($m >= $numbers[$k]) {\n            $m -= $numbers[$k];\n       \
    \     $c += $numbers[$k];\n        }\n        $result[$k + 1] = $c / $m;\n   \
    \ }\n    return array($a, $b, $result[0], $result[1], $result[2]);\n}\n", "  \
    \  list($xMin, $xMax, $yMin, $yMax) = $numbers;\n    $scale = 1.0 / min($xMax,\
    \ $yMax);\n    return array((float)($xMin * $scale), (float)($xMax * $scale),\
    \ (float)($yMin * $scale), (float)($yMax * $scale));\n}\n", "\t$new_min = min($numbers);\n\
    \t$new_max = max($numbers);\n\t$new_range = array();\n\tforeach ($numbers as $number)\
    \ {\n\t\t$new_range[] = pow(($number - $new_min) / ($new_max - $new_min), 2.0);\n\
    \t}\n\treturn $new_range;\n}\n", "  $min = $numbers[0];\n  $max = $numbers[0];\n\
    \  foreach ($numbers as $number) {\n    if ($min > $number) {\n      $min = $number;\n\
    \    }\n    if ($max < $number) {\n      $max = $number;\n    }\n  }\n  if ($min\
    \ == $max) {\n    return $numbers;\n  }\n  return array((float) $min, (float)\
    \ $max);\n}\n", "  $min = min($numbers);\n  $max = max($numbers);\n  return array($min\
    \ / $max, $max / $min);\n}\n", "  if (count($numbers) < 2) {\n    return $numbers;\n\
    \  }\n  $min = min($numbers);\n  $max = max($numbers);\n  $range = array();\n\
    \  foreach ($numbers as $number) {\n    $range[] = ($max - $min) * $number / $min\
    \ + $min;\n  }\n  return $range;\n}\n", "    $min = min($numbers);\n    $max =\
    \ max($numbers);\n    $diff = $max - $min;\n    $scale = $diff == 0 ? 0 : ($diff\
    \ / $diff);\n    return array((int)$min + ($numbers[0] - $min) * $scale, (int)$max\
    \ + ($numbers[1] - $max) * $scale);\n}\n", "  $min = min($numbers);\n  $max =\
    \ max($numbers);\n  $range = array();\n\n  // If $min < 0, set $min to 0 so that\
    \ $min < 0 will be true\n  if ($min < 0) {\n    $min = 0;\n  }\n\n  // If $max\
    \ is negative, set it to 0\n  if ($max < 0) {\n    $max = 0;\n  }\n\n  // If $max\
    \ is greater than or equal to $min, set $max to 1\n  if ($max >= $min) {\n   \
    \ $max = 1;\n  }\n\n  // If $min > 0, set $min to 0 so that $min < 0 will be true\n\
    \  if ($min > 0) {\n    $min = 0;\n  }\n\n  // For every number in the array,\
    \ set the range to $min to $max\n  for ($i = 0; $i < count($numbers); $i++) {\n\
    \    $range[$i] = array($numbers[$i], $min, $max);\n  }\n\n  // Sort the array\
    \ by smallest to largest\n  usort($range, 'range_cmp');\n\n  // Return the array\
    \ with smallest to largest values\n  return $range;\n}\n", "  // Sort numbers\
    \ to ensure determinism.\n  sort($numbers);\n\n  // Avoid division by zero.\n\
    \  $smallest = 0.0;\n  if (count($numbers) >= 2) {\n    $smallest = $numbers[0];\n\
    \  }\n\n  // Avoid division by zero.\n  $largest = 1.0;\n  if (count($numbers)\
    \ > 1) {\n    $largest = $numbers[1];\n  }\n\n  // Sum up all numbers.\n  $total\
    \ = 0.0;\n  foreach ($numbers as $number) {\n    $total += $number;\n  }\n\n \
    \ // Return array as normalized result.\n  return array($total - $smallest, $total\
    \ - $largest);\n}\n", "  $min = min($numbers);\n  $max = max($numbers);\n  if\
    \ ($min != 0.0) {\n    $factor = $max / $min;\n    foreach ($numbers as $number)\
    \ {\n      $number *= $factor;\n    }\n  }\n  return $numbers;\n}", "    if (count($numbers)\
    \ <= 1)\n        return $numbers;\n\n    $min = $numbers[0];\n    foreach ($numbers\
    \ as $n)\n        $min = ($n < $min) ? $min : $n;\n\n    $max = max($numbers);\n\
    \    foreach ($numbers as $n)\n        $max = ($n > $max) ? $max : $n;\n\n   \
    \ return array($min * 1.0 / $max, $max * 1.0 / $min);\n}\n", "  $min = min($numbers);\n\
    \  $max = max($numbers);\n  // Scale the numbers in the range [min, max] to the\
    \ range [0, 1]\n  $numbers = array_map(\n    function ($x) { return $x / $max;\
    \ },\n    $numbers\n  );\n  return array_map(\n    function ($x) { return $x -\
    \ $min; },\n    $numbers\n  );\n}\n", "  // If numbers is empty, return empty\
    \ array\n  if (!$numbers) return array();\n\n  // If the smallest number is 0\
    \ and the largest is 1, return an empty array\n  if ($numbers[0] == 0.0 && $numbers[1]\
    \ == 1.0) return array();\n\n  // If the smallest is 0, the second smallest is\
    \ 1, and the largest is 1, return an array with 0 as the smallest and 1 as the\
    \ largest\n  if ($numbers[0] == 0.0) {\n    $numbers[] = 0.0;\n    $numbers[1]\
    \ = 1.0;\n  }\n  if ($numbers[1] == 1.0) return array();\n\n  // If the smallest\
    \ is greater than 0 and second smallest is less than 1, the third smallest is\
    \ 0, and the largest is 1, return an array with 0 as the smallest and 1 as the\
    \ largest\n  if ($numbers[0] > 0.0 && $numbers[1] < 1.0) {\n    $numbers[] = 0.0;\n\
    \    $numbers[2] = 0.0;\n  }\n\n  if ($numbers[2] > 1.0) return array();\n\n \
    \ // If all numbers are within the range 0 to 1, return an array with 0 as the\
    \ smallest and 1 as the largest\n  return array($numbers[0], 1.0);\n}\n", "  $sums\
    \ = array_sum($numbers);\n  $max = max($numbers);\n  $results = [];\n  foreach\
    \ ($numbers as $number) {\n    $results[] = $number / $sums;\n  }\n  sort($results);\n\
    \  unset($results[0]);\n  return $results;\n}", "    return array_reduce(\n  \
    \      $numbers,\n        static function (array $result, float $number) {\n \
    \           if ($number <= 0.0) {\n                return $result;\n         \
    \   }\n\n            $min = $result[0];\n            $max = $result[1];\n    \
    \        $newMax = $max > $number ? $max : $number;\n\n            $newMin = $min\
    \ < $number ? $min : $number;\n\n            return [$newMin, $newMax];\n    \
    \    },\n        [0, 1.0]\n    );\n}\n</code>\n<|/ a |>\n<| a dscore=3 |>\nI needed\
    \ a way to scale a percentage value to between 0 and 1. Here's an adapted version\
    \ from Honza's answer:\n<code>", "  $min = min(array_values($numbers));\n  $max\
    \ = max(array_values($numbers));\n  return array_map(\n    function ($number)\
    \ use ($min, $max) {\n      return ($number - $min) / ($max - $min);\n    },\n\
    \    $numbers\n  );\n}\n\n/**\n * Return the minimum value of a list.\n *\n *\
    \ @param array $array The input list.\n * @return mixed The minimum value of all\
    \ items in $array.\n */", "    // Normalize each number between 0 and 1\n    //\
    \ NOTE: This may introduce small errors if numbers are very close to their boundaries\
    \ (e.g. 0.0001).\n    // The error is proportional to the magnitude of the numbers\
    \ in the array, though, so this may still cause some errors.\n    // See https://math.stackexchange.com/questions/1377054/why-does-floating-point-number-addition-produce-inaccurate-results-for-two-numbers-whos-magnitudes-are-similar\n\
    \    $min = min($numbers);\n    $max = max($numbers);\n    $magnitudes = array_map(function\
    \ ($number) {\n        return abs($number);\n    }, $numbers);\n    $summands\
    \ = array_map(function ($number) {\n        return $number - $min;\n    }, $numbers);\n\
    \    $scaled = array_map(function ($number, $index) use ($summands, $magnitudes)\
    \ {\n        return ($summands[$index] / $magnitudes[$index]) * ($max - $min)\
    \ + $min;\n    }, $numbers, array_keys($numbers));\n\n    return $scaled;\n}\n\
    </code>\n<|/ a dscore=0 tags=arrays,numbers,php |>\n<| a tags=arrays,numbers,php\
    \ |>\nI've tried this approach\n<code>\n<?php\n$arr = array(1.1,2.1,3.1,4.1);\n\
    $arr = array_filter($arr, function($var) {\n    return $var > 0.1;\n});\n$arr\
    \ = array_map(function($var) {\n    $var = ($var-0.1)/0.1;\n    return $var;\n\
    }, $arr);\necho '<pre>';\nprint_r($arr);\necho '</pre>';\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 tags=arrays,numbers,php |>\n<code>\n<?php\n$nums = array(1.1,\
    \ 2.1, 3.1, 4.1);\n\nforeach ($nums as $key => $val) {\n    if ($val < 0.1) continue;\n\
    \    $nums[$key] = ($val-0.1)/0.1;\n}\nvar_dump($nums);\n</code>\nOutput\n<code>\n\
    array(5) { [0]=> float(0) [1]=> float(0.25) [2]=> float(0.5) [3]=> float(0.75)\
    \ [4]=> float(1) }\n</code>\n<|/ a |>\n<| a tags=arrays,numbers,php |>\nI created\
    \ this function that accepts an array and returns the values you want to be in\
    \ the array.\n<code>", "  $min = min($numbers);\n  $max = max($numbers);\n  return\
    \ array_map(function($x) use ($min, $max) { return $x-$min; }, $numbers);\n}\n",
  "  if (count($numbers) <= 2) {\n    return $numbers;\n  }\n  // Find minimum\n \
    \ $min = $numbers[0];\n  foreach ($numbers as $number) {\n    if ($number < $min)\
    \ {\n      $min = $number;\n    }\n  }\n  // Find maximum\n  $max = $numbers[0];\n\
    \  foreach ($numbers as $number) {\n    if ($number > $max) {\n      $max = $number;\n\
    \    }\n  }\n  $range = array($max - $min);\n  foreach ($numbers as $number) {\n\
    \    $range = array($range * ($number - $min) / $range, $range);\n  }\n  return\
    \ $range;\n}", "  return array_map(\n    function($number) {\n      return ($number\
    \ > 0) ? floor($number / 2) : ceil($number / 2);\n    },\n    $numbers\n  );\n\
    }\n</code>\n<|/ a tags=arrays,php |>\n<| a dscore=2 |>\nHere's a functional version:\n\
    <code>\n/**\n * Rescale an array of numbers from 0 to 1 so that the largest number\
    \ will be 1.0\n *\n * array $numbers\n * array\n */", "  // If there are no numbers,\
    \ return empty array (will also return 0 when there are no elements)\n  if (empty($numbers))\
    \ {\n    return array();\n  }\n  $first_number = min($numbers);\n  // If all numbers\
    \ are equal, return the first number\n  if (count($numbers) == 1) {\n    return\
    \ array($first_number);\n  }\n  $second_number = max($numbers);\n  // Get maximum\
    \ distance between first and second number\n  $max_difference = abs($first_number\
    \ - $second_number);\n  // Create array of length $max_difference and fill with\
    \ zeros\n  $arr = array();\n  for ($i = 0; $i < $max_difference; $i++) {\n   \
    \ $arr[] = 0;\n  }\n  // Now fill the array with values between first and second\
    \ number\n  for ($i = 0; $i < count($numbers); $i++) {\n    $arr[$i] = $numbers[$i]\
    \ - $first_number;\n  }\n  return $arr;\n}\n", "  $smallestElement = min($numbers);\n\
    \  $largestElement = max($numbers);\n  foreach ($numbers as $number) {\n    $result[]\
    \ = $number - ($smallestElement * $largestElement);\n  }\n  return $result;\n}",
  "    $min = array_shift($numbers);\n    $max = array_shift($numbers);\n    return\
    \ array_map(\n        function($number) use ($min, $max) {\n            return\
    \ ($number - $min) / ($max - $min);\n        },\n        $numbers\n    );\n}\n\
    </code>\n<|/ a tags=arrays,php,rescale |>\n<| a dscore=1 |>\nHere is a solution\
    \ using the array_walk function.\n<code>", "    if (!is_array($numbers)) {\n \
    \       throw new InvalidArgumentException('Expected an array');\n    }\n    if\
    \ (!array_filter($numbers, 'is_numeric')) {\n        throw new InvalidArgumentException('All\
    \ values in the array must be numeric');\n    }\n    $range = array_fill(0, count($numbers),\
    \ 0);\n    foreach ($numbers as $number) {\n        $range[min($range)] = max($range);\n\
    \        $range[max($range)] = min($range) + 1;\n    }\n    return array_map(function\
    \ ($number) {\n        return $number / $range[$number];\n    }, $numbers);\n\
    }\n</code>\n<|/ a |>\n<| a dscore=0 |>\nYou need this function\n<code>", "   \
    \ if (!$numbers) {\n        return array();\n    }\n\n    $min_number = array_pop($numbers);\n\
    \    $max_number = array_shift($numbers);\n\n    $numbers = array_map(function($value)\
    \ use ($min_number, $max_number) {\n        $value = $value - $min_number;\n \
    \       return ($value * $max_number) / $min_number;\n    }, $numbers);\n\n  \
    \  return $numbers;\n}\n", "  $max = 0;\n  $min = 0;\n  $minKey = null;\n  $maxKey\
    \ = null;\n  foreach ($numbers as $num) {\n    if ($max < $num) {\n      $max\
    \ = $num;\n      $maxKey = $num;\n    }\n    if ($min > $num) {\n      $min =\
    \ $num;\n      $minKey = $num;\n    }\n  }\n\n  if ($minKey === null || $maxKey\
    \ === null) {\n    // Nothing to rescale\n    return $numbers;\n  }\n\n  $diff\
    \ = $max - $min;\n  $scale = 1 / $diff;\n  foreach ($numbers as $i => $num) {\n\
    \    $numbers[$i] = $num * $scale;\n  }\n  return $numbers;\n}\n</code>\nSo this\
    \ produces something like this:\n<code>\narray(\n  0 => 1.0,\n  1 => 1.25,\n \
    \ 2 => 1.5,\n  3 => 1.75,\n  4 => 2.0,\n  5 => 2.25,\n  6 => 2.5,\n  7 => 2.75,\n\
    \  8 => 3.0,\n  9 => 3.25,\n  10 => 3.5,\n  11 => 3.75,\n  12 => 4.0,\n  13 =>\
    \ 4.25,\n  14 => 4.5,\n  15 => 4.75,\n  16 => 5.0,\n  17 => 5.25,\n  18 => 5.5,\n\
    \  19 => 5.75,\n  20 => 6.0,\n  21 => 6.25,\n  22 => 6.5,\n  23 => 6.75,\n  24\
    \ => 7.0,\n  25 => 7.25,\n  26 => 7.5,\n  27 => 7.75,\n  28 => 8.0,\n  29 => 8.25,\n\
    \  30 => 8.5,\n  31 => 8.75,\n  32 => 9.0,\n  33 => 9.25,\n  34 => 9.5,\n  35\
    \ => 9.75,\n  36 => 10.0,\n  37 => 10.25,\n  38 => 10.5,\n  39 => 10.75,\n  40\
    \ => 11.0,\n  41 => 11.25,\n  42 => 11.5,\n  43 => 11.75,\n  44 => 12.0,\n  45\
    \ => 12.25,\n  46 => 12.5,\n  47 => 12.75,\n  48 => 13.0,\n  49 => 13.25,\n  50\
    \ => 13.5,\n  51 => 13.75,\n  52 => 14.0,\n  53 => 14.25,\n  54 ", "  if (count($numbers)\
    \ < 2) {\n    return $numbers;\n  }\n  // Find the minimum\n  $min_number = min($numbers);\n\
    \  // Find the maximum\n  $max_number = max($numbers);\n  // Find the factor\n\
    \  $factor = $max_number / $min_number;\n  // Multiply the array by the factor\n\
    \  return array_map(function ($n) use ($factor) { return $n * $factor; }, $numbers);\n\
    }\n</code>\n<|/ a tags=math,php,algorithm |>\n<| a tags=math,php,algorithm |>\n\
    I like 's answer, but his answer doesn't scale to all numbers. Here, I scale to\
    \ both 0 and 1 with linear interpolation:\n<code>\n<?php\n$numbers = array(0.2,\
    \ 0.8, 0.7, 0.4, 1.3, 1.5, 1.7);\n$numbers = array_reverse($numbers);\n$largest\
    \ = max($numbers);\n$smallest = min($numbers);\n$diff = abs($largest - $smallest);\n\
    $factor = $diff / count($numbers);\n$new_numbers = array();\n$last_value = $smallest;\n\
    foreach ($numbers as $number) {\n  $new_numbers[] = $last_value + ($number - $smallest)\
    \ * $factor;\n  $last_value = $number;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1\
    \ |>\n<code>\n$num = array(0.2,0.8, 0.7, 0.4, 1.3, 1.5, 1.7);\n$num = array_reverse($num);\n\
    $largest = max($num);\n$smallest = min($num);\n$diff = abs($largest - $smallest);\n\
    $factor = $diff / count($num);\n$new_num = ($num - $smallest) * $factor;\n$new_num\
    \ = array_reverse($new_num);\n</code>\n<|/ a tags=math,php,algorithm |>\n<| a\
    \ dscore=0 |>\nIn case someone is looking for something that can scale between\
    \ 0 and 1 without loosing precision.\n<code>", "    $min = min(count($numbers),\
    \ 1);\n    $max = max(count($numbers), 1);\n    foreach ($numbers as $key => $value)\
    \ {\n        $numbers[$key] = ($value - min) / ($max - min);\n    }\n    return\
    \ $numbers;\n}", "  $min = min($numbers);\n  $max = max($numbers);\n  if ($min\
    \ == $max) {\n    return array($min);\n  }\n  $range = array(0, 1);\n  foreach\
    \ ($numbers as $i => $v) {\n    if ($v - $min > $max - $min) {\n      $range[$i]\
    \ = 0;\n    } else {\n      $range[$i] = $v - $min;\n    }\n  }\n  return $range;\n\
    }\n", "  $min = min($numbers);\n  $max = max($numbers);\n  if ($min == $max) {\n\
    \    return array($min);\n  }\n  $range = array();\n  for ($i = $min; $i <= $max;\
    \ $i++) {\n    $range[] = $i;\n  }\n  return array_map(function($number) {\n \
    \   return $number * (count($numbers) / max(1.0, count($range)));\n  }, $numbers);\n\
    }\n\n\n/**\n * Computes the sum of a set of numbers, ignoring errors and 0s.\n\
    \ *\n * @param array $numbers An array of numbers.\n *\n * @return float\n */",
  "    foreach ($numbers as $key => $number) {\n        if ($number === 0) {\n   \
    \         $numbers[$key] = 0.0;\n        }\n    }\n    return $numbers;\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| a |>\nYou can add these two functions to your app:\n<code>\n\
    /**\n * Transform an array of numbers to an interval between 0 and 1.\n * \n *\
    \ array $numbers\n * array\n */", "    $minimum = min(array(reset($numbers), end($numbers)));\n\
    \    $maximum = max(array(reset($numbers), end($numbers)));\n    if ($minimum\
    \ == $maximum) {\n        return $minimum;\n    }\n    return $minimum + $maximum\
    \ * 0.1;\n}\n", "\t$length = count($numbers);\n\tif ($length < 2) {\n\t\treturn\
    \ $numbers;\n\t}\n\t$min = min($numbers);\n\t$max = max($numbers);\n\t$center\
    \ = ($min + $max) / 2;\n\tfor ($i = 0; $i < $length; $i++) {\n\t\t$numbers[$i]\
    \ -= $center;\n\t}\n\treturn $numbers;\n}\n\n/**\n * Return the minimum value\
    \ of a set of numbers.\n *\n * @param array $numbers the set of numbers to be\
    \ examined\n * @return float $min minimum value found in $numbers\n */", "  //\
    \ Sort the numbers to ensure smallest to largest\n  sort($numbers);\n  // Normalize\
    \ the numbers\n  $normalized = array_map('round', $numbers);\n  return $normalized;\n\
    }\n", "    $min = min($numbers);\n    $max = max($numbers);\n\n    // Round to\
    \ avoid weird PHP error in case the min and max are floats\n    $min = $min -\
    \ (int) $min;\n    $max = $max - (int) $max;\n\n    if ($min == $max) {\n    \
    \    // Avoid dividing by 0\n        $numbers[] = 0.0;\n        $numbers[] = 1.0;\n\
    \        return $numbers;\n    }\n\n    // Normalize so largest value becomes\
    \ 1.0\n    $norm = (float) $max / (float) $min;\n\n    foreach ($numbers as $i\
    \ => $number) {\n        $numbers[$i] = (float) $number * $norm;\n    }\n\n  \
    \  return $numbers;\n}", "  $smallest = min($numbers);\n  $largest = max($numbers);\n\
    \  return array_map(function($number) {\n    return ($number / $largest) - ($number\
    \ / $smallest);\n  }, $numbers);\n}", "    $smallest = Math.min($numbers);\n \
    \   $largest = Math.max($numbers);\n    return array($smallest, $largest - $smallest);\n\
    }\n", "    $min = min($numbers);\n    $max = max($numbers);\n    $range = $max\
    \ - $min;\n    if ($range == 0) {\n        $min = 0;\n    }\n    $output = [];\n\
    \    for ($i = 0; $i < count($numbers); $i++) {\n        $output[$i] = ($numbers[$i]\
    \ - $min) / $range;\n    }\n    return $output;\n}\n", "  $min = min($numbers);\n\
    \  $max = max($numbers);\n  if ($min == $max) {\n    return $numbers;\n  }\n \
    \ $scale = 1 / ($max - $min);\n  return array_map(\n    function ($number) {\n\
    \      return round($number * $scale);\n    },\n    $numbers\n  );\n}\n", "  \
    \  list($smallest) = array_map('min', $numbers);\n    list($largest) = array_map('max',\
    \ $numbers);\n    return array(\n        0 => $smallest + ($largest - $smallest)\
    \ / 2,\n        1 => $largest - ($largest - $smallest) / 2,\n    );\n}\n</code>\n\
    <|/ a tags=php,arrays,linear-algebra |>\n<| a dscore=3 tags=php,arrays,linear-algebra\
    \ |>\nI had a similar problem but in Python where I was doing simple linear interpolation\
    \ between two data sets with different ranges. I needed a function that could\
    \ handle the differences in ranges of numbers that I had and was able to cope\
    \ with these differences gracefully.\nI ended up using this solution:\n<code>\n\
    def linearInterpolation(data1, data2, xi, yi, interp):\n    \"\"\"\n    data1\
    \ and data2 are arrays containing the x and y coordinates of the points.\n   \
    \ xi and yi are the x and y values of the point whose position in the data2 array\
    \ is to be\n    determined.\n    interp is the name of the function to be used\
    \ for interpolation.\n    \"\"\"\n    \n    x1 = data1[0]\n    y1 = data1[1]\n\
    \    \n    x2 = data2[0]\n    y2 = data2[1]\n    \n    xind = xi - (x2 - x1)/2.0\n\
    \    xind2 = xi + (x2 - x1)/2.0\n    \n    yind = yi - (y2 - y1)/2.0\n    yind2\
    \ = yi + (y2 - y1)/2.0\n    \n    if xind2 < xind or xind < xind2:\n        xind\
    \ = xind2\n        xind2 = xind\n    \n    if yind2 < yind or yind < yind2:\n\
    \        yind = yind2\n        yind2 = yind\n    \n    xint = xind - x1\n    yint\
    \ = yind - y1\n    \n    diff = abs(xint) + abs(yint)\n    \n    if diff == 0:\n\
    \        return (xi, yi)\n    else:\n        xint = -xint\n        yint = -yint\n\
    \    \n    \n    \n    \n    if interp == \"linear\":\n        xi1 = x1 + xint\
    \ * diff\n        yi1 = y1 + yint * diff\n        \n        xi2 = x1 + xint *\
    \ diff\n        yi2 = y1 + yint * diff\n        \n        if xind >= xind2:\n\
    \            xi1 = xi + diff*(xind2 - xind)\n            xi2 = xi + diff*(xind\
    \ - xind2)\n            \n", "  $length = count($numbers);\n  if (!$length) {\n\
    \    return array();\n  }\n  $largest = max($numbers);\n  $smallest = min($numbers);\n\
    \  $scale = ($largest - $smallest) / $largest;\n  $numbers = array();\n  for ($i\
    \ = 0; $i < $length; $i++) {\n    $numbers[$i] = round($numbers[$i] * $scale);\n\
    \  }\n  return $numbers;\n}", "    $min = min($numbers);\n    $max = max($numbers);\n\
    \    return $numbers - ($min < $max ? $min : -1) * ($max - $min) / ($max - $min);\n\
    }\n", "    $min = min($numbers);\n    $max = max($numbers);\n    $newArray = array();\n\
    \n    foreach ($numbers as $number) {\n        $newArray[] = ($number - $min)\
    \ / ($max - $min);\n    }\n\n    return $newArray;\n}\n", "    if (!count($numbers))\
    \ {\n        return array();\n    }\n\n    $min = reset($numbers);\n    $max =\
    \ end($numbers);\n    $diff = abs($max - $min);\n\n    // We need to keep track\
    \ of the smallest unit change we might find before\n    // rescaling so that we\
    \ can restore it afterwards. When we rescale\n    // from 10% to 10%, the smallest\
    \ unit change will be 10% already\n    // so we need to keep track of that.\n\
    \    $smallest_unit_change = 0;\n\n    // This variable holds the result of the\
    \ rescaling operation.\n    $result = array();\n\n    // Handle the smallest unit\
    \ change separately\n    if ($diff == 0) {\n        $result[] = $min;\n    } else\
    \ {\n        $smallest_unit_change = $diff / $max;\n\n        // Now handle all\
    \ the other elements\n        foreach ($numbers as $key => $number) {\n      \
    \      if ($number == $max) {\n                $result[] = 1;\n            } elseif\
    \ ($number == $min) {\n                $result[] = 0;\n            } elseif ($number\
    \ > $max) {\n                $result[] = ($number - $min) / $diff;\n         \
    \   } elseif ($number < $min) {\n                $result[] = (($max - $number)\
    \ / $diff) + $smallest_unit_change;\n            } else {\n                $result[]\
    \ = $number;\n            }\n        }\n    }\n\n    return $result;\n}\n</code>\n\
    You can test it out with the following code:\n<code>\n$numbers = array(\n    1,\
    \ 2, 3, 4, 5, 6,\n);\n\nvar_dump(rescale_to_unit($numbers));\n\n/*\narray(5) {\n\
    \  [0]=>\n  int(0)\n  [1]=>\n  int(0)\n  [2]=>\n  int(0)\n  [3]=>\n  int(0.25)\n\
    \  [4]=>\n  int(0.50)\n  [5]=>\n  int(0.75)\n}\n*/\n</code>\n<|/ a tags=math,mathematical-optimization,algorithm,php\
    \ |>\n<| c |>\nI don't think this is correct. You're not rescaling to the closest\
    \ value, but to the closest percentage value. What you get with your function\
    \ is `array(0.0, 0.25, 0.5, 0.75, 1.0)`, which is not what the OP wants. The OP\
    \ wants `array(0.0, 0.25, 0.5, 0.75, 1.0)`, a percentage. Your function would\
    \ return `array(1.0, 2.0, 3.0, 4.0, 5.0)` if you pass it `array(1.0, 2.0, 3.0,\
    \ 4.0, 5.0)`.\n<|/ c |>\n<| c |>\nI believe this is correct. I'm going to edit\
    \ the answer to reflect this. Thank you for noticing that!\n<|/ c |>\n<| c |>\n\
    Your answer ", "  // We have to do some validation here, otherwise we will throw\
    \ an exception below.\n  $array_count = count($numbers);\n  if ($array_count <\
    \ 2) {\n    return array($numbers[0]);\n  }\n  $total_number = array_sum($numbers);\n\
    \  $rescaled_numbers = array();\n  foreach ($numbers as $key => $value) {\n  \
    \  $rescaled_numbers[$key] = ($value / $total_number) * 0.9999999;\n  }\n  return\
    \ $rescaled_numbers;\n}\n", "  $smallest = $numbers[0];\n  $largest = $numbers[0];\n\
    \n  for ($i = 1; $i < count($numbers); $i++) {\n    if ($numbers[$i] < $smallest)\
    \ {\n      $smallest = $numbers[$i];\n    } else if ($numbers[$i] > $largest)\
    \ {\n      $largest = $numbers[$i];\n    }\n  }\n\n  $scale = min($smallest /\
    \ $largest, 1.0);\n\n  for ($i = 0; $i < count($numbers); $i++) {\n    $numbers[$i]\
    \ = $numbers[$i] * $scale;\n  }\n\n  return $numbers;\n}\n", "    $min = $numbers[0];\n\
    \    $max = $numbers[0];\n    foreach ($numbers as $value) {\n        if ($value\
    \ < $min) {\n            $min = $value;\n        } else if ($value > $max) {\n\
    \            $max = $value;\n        }\n    }\n    $new_array = array();\n   \
    \ foreach ($numbers as $value) {\n        $new_array[] = ($value - $min) / ($max\
    \ - $min);\n    }\n    return $new_array;\n}\n", "  // Sort numbers descending\n\
    \  $numbers = array_reverse($numbers);\n  // Initialize min/max to first number\n\
    \  $min = reset($numbers);\n  $max = end($numbers);\n  // Return array of min/max\
    \ scaled to 1/(max-min)\n  return array((float)($max - $min) / (float)min(1.0,\
    \ max(0.0, $min)), $min, max(0.0, $max));\n}\n", "    $sum    = 0;\n    $length\
    \ = count($numbers);\n    for ($i = 0; $i < $length; ++$i) {\n        $sum +=\
    \ $numbers[$i];\n    }\n    if ($sum > 0.0) {\n        return array_map(function($x)\
    \ {\n            return $x / $sum;\n        }, $numbers);\n    } else {\n    \
    \    return array_map(function($x) {\n            return 1.0;\n        }, $numbers);\n\
    \    }\n}\n</code>\n<|/ a |>\n<| c |>\nThat is a nice function. I am having trouble\
    \ implementing the function on my site. I need to know how the function can be\
    \ implemented on a Wordpress site in order to troubleshoot. I tried copying your\
    \ function but am getting a white screen when I open the page. Any suggestions\
    \ on how to troubleshoot?\n<|/ c |>\n<| c |>\nNevermind, I was able to figure\
    \ it out with some trial and error. Thanks!\n<|/ c |>\n<| c |>\nThis does not\
    \ give the right answer when $x is 0 it returns 1 which is not correct. Example\
    \ - rescale_to_unit(array(0.0, 0.25, 0.5, 0.75, 1.0)); returns array(1.0, 1.0,\
    \ 1.0, 0.0, 1.0)\n<|/ c |>\n<| a |>\n<code>", "  $min = min($numbers);\n  $max\
    \ = max($numbers);\n  $range = range($min, $max);\n  return array_map(function($a)\
    \ use($range) {\n    return $range[array_search($a, $range)] * ($a / $min);\n\
    \  }, $numbers);\n}\n\n", "    $min = $numbers[0];\n    $max = $numbers[0];\n\
    \    foreach ($numbers as $number) {\n        if ($number < $min) $min = $number;\n\
    \        if ($number > $max) $max = $number;\n    }\n    return array_map(function\
    \ ($number) {\n        return ($number - $min) / ($max - $min);\n    }, $numbers);\n\
    }\n</code>\n<|/ a tags=math,php |>\n<| c |>\nOh wow, that's really a nice function,\
    \ thanks for sharing!\n<|/ c |>\n<| a tags=math,php |>\nYou can do that by multiplying\
    \ the elements of the array by the inverse of the array length, i.e. 1/array.length\n\
    <|/ a dscore=1 |>\n<| a tags=math,php |>\nOne of the great things about math is\
    \ it applies to everything from physical quantities to computer code.\nSo you\
    \ can solve this problem by looking at it from a graphical point of view:\n\n\
    The red points are the numbers you want to scale and the blue points are the number\
    \ you want to scale. Just divide each number by the number above it. And your\
    \ numbers will be between 0-1 as expected.\nIn php, divide your number by the\
    \ previous number:\n<code>\n$numbers = array(1.0, 2.4, 3.3, 4.8);\n$numbers_scaled\
    \ = array_map(function ($number) use (&$numbers) {\n    return $number / $numbers[count($numbers)\
    \ - 1];\n}, $numbers);\n\nvar_dump($numbers_scaled);\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nNice solution. I think it's worth mentioning that the anonymous\
    \ function is not necessary, and the `use` keyword is more readable than a global\
    \ (which is what I tend to do anyway).\n<|/ c |>\n<| c |>\nYeah, I saw the anonymous\
    \ function and changed my mind about that at some point. Thanks for the input.\n\
    <|/ c |>\n<| a |>\nOne method is to divide each number by the largest number in\
    \ the array:\n<code>\n$array = array(1,2,3,4,5);\n$result = array_map(function($el){\n\
    \    return $el / max($array);\n}, $array);\n</code>\nThis approach has problems\
    \ when one of the elements has a large absolute value, because it gives a division\
    \ by zero error if $array[0] > $array[1]. This can be avoided by setting $result\
    \ = array_map( function( $el ) { return ($el / max($array)); }, $array); at the\
    \ start, to set all values in the array to zero, then adding the values before\
    \ dividing. This works because:\n\nThe largest ", "    if (count($numbers) <=\
    \ 1) {\n        return $numbers;\n    }\n    $min = min($numbers);\n    $max =\
    \ max($numbers);\n    $scale = ($max - $min) / count($numbers);\n    $rescaled\
    \ = array();\n    foreach ($numbers as $i => $number) {\n        $rescaled[$i]\
    \ = $min + $number * $scale;\n    }\n    return $rescaled;\n}\n</code>\n<|/ a\
    \ dscore=4 |>\n<| c |>\nHi Patrick, thanks for your reply! I appreciate it!\n\
    <|/ c |>\n<| c |>\nNice.  I did not know about rescale_to_unit().  However, I\
    \ like the fact that this does not require the use of libraries.  +1 for this.\n\
    <|/ c |>\n<| a |>\nTry this :\n<code>\narray_map(\"round\", array($arr));\n</code>\n\
    <|/ a tags=math,php,arrays dscore=2 |>\n<| a |>\n<code>\n$array = array(7.0, 8.0,\
    \ 9.0, 10.0);\n$array = array_map('round', $array);\n</code>\n<|/ a dscore=1 tags=math,php,arrays\
    \ |>\n<| a |>\nHere's a more generic solution that will scale any array from 0\
    \ to 1 and will maintain it's original keys:\n<code>\n/**\n * Scale array from\
    \ 0 -> 1\n * \n * $arr\n * int $scale\n * array\n */", "  $smallest = null;\n\
    \  $largest = null;\n  foreach ($numbers as $n) {\n    if ($smallest === null\
    \ || $smallest > $n) {\n      $smallest = $n;\n    }\n    if ($largest === null\
    \ || $largest < $n) {\n      $largest = $n;\n    }\n  }\n  return array_map(function\
    \ ($n) {\n    return $smallest * (1 - $n) + $largest * $n;\n  }, $numbers);\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThe question is about `numpy`. It's not\
    \ clear to me how you came up with the values you got in your plots. Also, I think\
    \ this solution is overly complicated. A simple linear transform would suffice.\n\
    <|/ c |>\n<| c |>\nI used a combination of linear transforms to get something\
    \ similar but with less noise. I think the question is a bit confusing though.\
    \ Do you have a dataset you're testing this on or are you just trying to get this\
    \ to work?\n<|/ c |>\n<| c |>\nHi there. I added a working example to the question.\
    \ I was testing this on the sample data included in the question. I added a comment\
    \ in the question, saying that I needed the function to work on arrays larger\
    \ than 2 elements.\n<|/ c |>\n<| c |>\nI'm sorry but I don't really understand\
    \ your question. What do you mean by a linear transform? Do you mean just dividing\
    \ by 100? That will get you the closest to what you want but it will not make\
    \ you sound more or less \"happy\" because you're going to have a different number\
    \ of elements. Do you just want to play a little bit with the numbers? You could\
    \ do that by applying a scaling function to the input numbers to try to make them\
    \ sound more or less \"happy\".\n<|/ c |>\n<| c |>\nHi, thanks for adding an example\
    \ to the question. I'm afraid I don't understand your comment. Maybe I should\
    \ rephrase my question: What is the input to the function? What is the expected\
    \ output?\n<|/ c |>\n<| a tags=numpy,python,arrays |>\n<code>\ndef rescale_to_unit(arr):\n\
    \    largest = max(arr)\n    smallest = min(arr)\n    return [float(v)/largest\
    \ for v in arr]\n\narr = rescale_to_unit([1.5, 1.5, 1.5, 1.5, 2.5, 2.5, 2.5, 2.5,\
    \ 2.5])\nprint(arr)\n</code>\nprints:\n<code>\n[0.075, 0.075, 0.075, 0.075, 0.075,\
    \ 0.075, 0.075, 0.075]\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nJust use ",
  "    if (count($numbers) <= 2) {\n        return $numbers;\n    }\n    $min = min($numbers);\n\
    \    $max = max($numbers);\n    $scale = 1.0 - $min / $max;\n    return array(0,\
    \ $scale * $max, $scale * $min, $scale * $max);\n}\n</code>\n<|/ a |>\n<| a tags=math,php,arrays,algorithm\
    \ |>\n<code>\n<?php", "    // make sure there's at least two numbers\n    if (count($numbers)\
    \ < 2) {\n        return $numbers;\n    }\n\n    $smallest = $numbers[0];\n  \
    \  $largest = $numbers[0];\n    for ($i = 1; $i < count($numbers); $i++) {\n \
    \       $smallest = ($smallest > $numbers[$i]) ? $smallest : $numbers[$i];\n \
    \       $largest = ($largest < $numbers[$i]) ? $largest : $numbers[$i];\n    }\n\
    \n    $diff = $largest - $smallest;\n    $diff /= count($numbers) - 1;\n    $diff\
    \ = ($diff > 0) ? floor($diff) : 0;\n\n    // rescale the numbers\n    for ($i\
    \ = 1; $i < count($numbers); $i++) {\n        $numbers[$i] = $diff * $numbers[$i\
    \ - 1] + $smallest;\n    }\n\n    return $numbers;\n}\n", "  $min = array_shift($numbers);\n\
    \  $max = array_shift($numbers);\n\n  if ($min == $max) {\n    $min = $min ==\
    \ 0 ? 0.0 : 1.0;\n    return $numbers;\n  }\n\n  $min = ($min < 0) ? 0.0 : $min;\n\
    \  $max = ($max < 0) ? 0.0 : $max;\n\n  return array($min + ($numbers[0] - $min)\
    \ / ($max - $min) * ($max - $min), $max - ($numbers[1] - $min) / ($max - $min)\
    \ * ($max - $min));\n}\n</code>\n<|/ a |>\n<| c |>\nThis doesn't always give the\
    \ correct output when $min = 0.0, $max = 1.0. From your examples, 0.0 is mapped\
    \ to 0, 0.5 to 0.25, 0.75 to 0.5, 1.0 is mapped to 1.\n<|/ c |>\n<| c |>\n- No,\
    \ in the example above, the lowest value is mapped to 0, the highest to 1.\n<|/\
    \ c |>\n<| c |>\nNo, your example is wrong, try this one: \n`array(0.0, 0.51,\
    \ 0.65, 0.8, 1.0) `\n<|/ c |>\n<| c |>\n- You're right, I missed that in my tests.\
    \ I've updated my answer to take that into account.\n<|/ c |>\n<| a |>\n<code>",
  "    $largest = max($numbers);\n    $smallest = min($numbers);\n    $range = range($smallest,\
    \ $largest);\n    array_walk($range, function(&$number) { $number -= $smallest;\
    \ });\n    array_walk($range, function(&$number) { $number *= 1./count($range);\
    \ });\n    return $range;\n}\n", "    return array(\n        min(rescale_array($numbers,\
    \ 0, 1)),\n        max(rescale_array($numbers, 0, 1)),\n    );\n}\n", "    foreach\
    \ ($numbers as $number) {\n        $number /= min(1.0, max(0.0, $number));\n \
    \   }\n    return $numbers;\n}\n", "    foreach ($numbers as &$number) {\n   \
    \     $number = $number / max(1, abs($number));\n    }\n    return $numbers;\n\
    }\n", "    $sum = array_sum($numbers);\n    if ($sum == 0) {\n        return $numbers;\n\
    \    }\n    $norm = array_sum($numbers / $sum);\n    return array_map(function\
    \ ($num) use ($norm) { return $num / $norm; }, $numbers);\n}\n</code>\n<|/ a tags=arrays,php\
    \ |>\n<| c |>\nI agree with you, this isn't a trivial task to solve. This is a\
    \ very helpful function to have in my toolbelt, thank you!\n<|/ c |>\n<| c |>\n\
    I just came across this answer while trying to solve the same problem myself.\
    \ For anyone who wants to use the code, please note that the function doesn't\
    \ perform the transformation on negative values.\n<|/ c |>\n<| c |>\nI have an\
    \ issue. In the above code, if you give a negative number in array, the output\
    \ will be 0.\n<|/ c |>\n<| c |>\nHow does this handle negative numbers?\n<|/ c\
    \ |>\n<| c |>\n- I just added a note to my answer, stating that the function doesn't\
    \ handle negative numbers in the array.\n<|/ c |>\n<| a |>\nJust use the min and\
    \ max array functions, they take an optional parameter of which value to compare\
    \ the array values against.  So, for example, to get the minimum element from\
    \ an array of numbers, use:\n<code>\nmin(array(1, 2, 3, 4, 5));\n</code>\nTo get\
    \ the maximum element from an array of numbers, use:\n<code>\nmax(array(1, 2,\
    \ 3, 4, 5));\n</code>\n<|/ a tags=arrays,php dscore=5 |>\n<| c |>\nThat was a\
    \ really simple solution and much easier than I thought. Thank you!\n<|/ c |>\n\
    <| c |>\nJust a note: `min()` and `max()` don't return `null` if they cannot find\
    \ the minimum element or maximum element, respectively.\n<|/ c |>\n<| c |>\nIf\
    \ you use `array_shift` or `array_pop` to pop an element off, you'll need to use\
    \ a `!is_null()` check for the `min` / `max` array functions. It's safe to assume\
    \ that `min()` or `max()` will never return `null`.\n<|/ c |>\n<| c |>\nNote that\
    \ these functions always return float or int values so you must cast the array\
    \ value to a float / int if you want it to work with decimal values. E.g. `min((float)\
    \ $array)` or `max((float) $array)`.\n<|/ c |>\n<| a tags=arrays,php |>\nOne way\
    \ to do this is by using the array_min() and array_max() functions. For example:\n\
    <code>\n$array = array(1, 2, 3, 4, 5);\n\n", "  if (count($numbers) < 2) {\n \
    \   return array();\n  }\n  return array_map(function ($n) { return $n - min(0.0,\
    \ max(0.0, $n)); }, $numbers);\n}\n</code>\n<|/ a dscore=2 |>\n<| a |>\nIn Swift,\
    \ you can get this to work like so:\n<code>\nlet arr: [CGFloat] = ...\nlet min:\
    \ CGFloat = arr.reduce(0, {$0 + $1}) // minimum value in arr\nlet max: CGFloat\
    \ = arr.reduce(1, {$0 + $1}) // maximum value in arr\nlet res: CGFloat = max -\
    \ min // res from 0 to 1\nlet scaled: CGFloat = arr.reduce(0.0, {$0 + $1/res})\n\
    </code>\n<|/ a tags=math,algorithm dscore=1 |>\n<| a dscore=1 |>\nI recently had\
    \ to do this in my current project and came up with the following solution that\
    \ requires no external libraries.\n<code>\n/**\n * Scale an array of numbers to\
    \ [0, 1].\n * If only a single number is provided, it will return it as-is.\n\
    \ * \n * array $values\n * float\n */", "  $min = min($numbers);\n  $max = max($numbers);\n\
    \  $new_array = array();\n  for ($i = 0; $i < count($numbers); $i++) {\n    $new_array[$i]\
    \ = ($numbers[$i] - $min) / ($max - $min);\n  }\n  return $new_array;\n}\n", " \
    \ return $numbers[$numbers < array_shift($numbers)] ? array_map(function ($n)\
    \ {\n    return ($n - array_min($numbers)) / array_max($numbers);\n  }, $numbers)\
    \ : $numbers;\n}\n</code>\nNow lets make an interface to access our data without\
    \ having to worry about how the data is stored or fetched. This should make the\
    \ code more testable/reusable.\n<code>\ninterface IDataInterface {\n\n  /**\n\
    \   * Gets all data from the data source\n   * array\n   */\n  public function\
    \ getData();\n\n  /**\n   * Gets a single row of the data source\n   * string\
    \ $id\n   * array\n   */\n  public function getRow($id);\n\n  /**\n   * Get a\
    \ single column of the data source\n   * string $id\n   * array\n   */\n  public\
    \ function getColumn($id);\n\n}\n</code>\nNow lets make an abstract class for\
    \ the data sources that will implement this interface:\n<code>\nabstract class\
    \ DataSource implements IDataInterface {\n\n  /**\n   * Gets all data from the\
    \ data source\n   * array\n   */\n  public function getData() {\n    return $this->getRows(null);\n\
    \  }\n\n  /**\n   * Gets a single row of the data source\n   * string $id\n  \
    \ * array\n   */\n  public function getRow($id) {\n    return $this->getRows($id);\n\
    \  }\n\n  /**\n   * Get a single column of the data source\n   * string $id\n\
    \   * array\n   */\n  public function getColumn($id) {\n    $rows = $this->getRows($id);\n\
    \    return array_map(function ($row) {\n      return $row[$id];\n    }, $rows);\n\
    \  }\n\n  /**\n   * Gets a set of rows from the data source\n   * string|null\
    \ $id\n   * array\n   */\n  abstract public function getRows($id = null);\n}\n\
    </code>\nAnd then we can make our own custom data source:\n<code>\nclass CustomDataSource\
    \ extends DataSource {\n\n  public function getRows($id = null) {\n    $rows =\
    \ [\n      'id1' => ['id' => 1, 'name' => 'foo', 'location' => 'bar', 'price'\
    \ => 12.99],\n      'id2' => ['id' => 2, 'name' => 'bar', 'location' => 'bar',\
    \ 'price' => 11.99],\n      'id3' => ['id' => 3, 'name' => 'foo', 'location' =>\
    \ 'bar', 'price' => 13.99],\n    ];\n\n    if (null !== $id) {\n      return array_filter($rows,\
    \ function ($row) use ($id) {\n        return $row['id'] === $id;\n      });\n\
    \    }\n\n    return $rows;\n  }\n\n}\n</code>\nNow lets make our interface:\n\
    <code>\ninterface IDataInterfaceFactory {\n\n  /**\n   * ", "  $max = max($numbers);\n\
    \  $min = min($numbers);\n\n  foreach ($numbers as &$number) {\n    if ($number\
    \ < 0.0) {\n      $number *= 1.0/(max(0.0, $min) - $min);\n    } else {\n    \
    \  $number *= 1.0/(max(0.0, $max) - $max);\n    }\n  }\n\n  return $numbers;\n\
    }\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThanks for this answer but why does it\
    \ not work for arrays like this?\n\narray(\n  0 => array( 0 => 1, 1 => 2, 2 =>\
    \ 3, 3 => 4, 4 => 5),\n  1 => array( 0 => 6, 1 => 7, 2 => 8, 3 => 9, 4 => 10),\n\
    );\n<|/ c |>\n<| c |>\nThe code does not work because you have the `min` and `max`\
    \ as `0`. I will update the answer to show an example\n<|/ c |>\n<| c |>\nI changed\
    \ the answer to use `min(...)` and `max(...)` instead of `min()` and `max()`\n\
    <|/ c |>\n<| c |>\nI fixed the example. Thank you\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work for `array( 0 => 0, 1 => 0, 2 => 0, 3 => 0, 4 => 0, 5 => 0)`\n<|/ c |>\n\
    <| a |>\nThis is a slightly modified version of Jonathan Sampson's code but it\
    \ is more concise and allows for multiple elements per sub-array (as of PHP 7).\n\
    <code>", "  $max_value = array_pop($numbers);\n  return $max_value / $numbers;\n\
    }\n", "    // Initialize output array\n    $result = array();\n    // Find min\
    \ and max\n    $min = reset($numbers);\n    $max = end($numbers);\n    // Apply\
    \ scaling factors to each number\n    foreach ($numbers as $number) {\n      \
    \  $result[] = ($number - $min) / ($max - $min);\n    }\n    return $result;\n\
    }\n", "    sort($numbers);\n    $min = reset($numbers);\n    $max = end($numbers);\n\
    \    for ($i = 0; $i < count($numbers); $i++) {\n        if ($numbers[$i] < $min)\
    \ {\n            $numbers[$i] = 0;\n        }\n        if ($numbers[$i] > $max)\
    \ {\n            $numbers[$i] = 1;\n        }\n    }\n    return $numbers;\n}\n\
    </code>\n<|/ a tags=sorting,php,multidimensional-array,arrays |>\n<| a tags=sorting,php,multidimensional-array,arrays\
    \ |>\n<code>\n$array = array(\n    array(1, 2, 3, 4, 5, 6, 7, 8, 9),\n    array(10,\
    \ 11, 12, 13, 14, 15, 16, 17, 18),\n);\n", "  if (!count($numbers) || count($numbers)\
    \ < 2) {\n    return $numbers;\n  }\n\n  $min = min($numbers);\n  $max = max($numbers);\n\
    \n  return array(\n    ($numbers[0] - $min) / ($max - $min),\n    ($numbers[1]\
    \ - $min) / ($max - $min),\n  );\n}\n", "  // Sort numbers so that the smallest\
    \ number is 0\n  sort($numbers);\n  return array_map(\n    function($value) {\n\
    \      if ($value < 1) {\n        $value = $value * .5;\n      }\n      return\
    \ $value;\n    },\n    $numbers\n  );\n}\n", "  $min = min($numbers);\n  $max\
    \ = max($numbers);\n  return array_map(function ($n) use ($min, $max) {\n    return\
    \ $n - $min / ($max - $min);\n  }, $numbers);\n}\n", "    $minimum = min($numbers);\n\
    \    $maximum = max($numbers);\n\n    if ($minimum == $maximum) {\n        return\
    \ $numbers;\n    }\n\n    return array($minimum, $maximum);\n}\n", "  if (count($numbers)\
    \ < 2) {\n    return $numbers;\n  }\n  $min = array_shift($numbers);\n  $max =\
    \ array_pop($numbers);\n  if ($min == $max) {\n    return $numbers;\n  }\n  //\
    \ Make sure that we don't lose precision in the transformation\n  $min = (float)\
    \ $min;\n  $max = (float) $max;\n  $scale = floatval($max - $min);\n  $scale =\
    \ min($scale, count($numbers) * 0.1);\n  for ($i = 0; $i < count($numbers); $i++)\
    \ {\n    $numbers[$i] = ($numbers[$i] - $min) / $scale;\n  }\n  return $numbers;\n\
    }", "    // Sort the array\n    sort($numbers);\n    // Find minimum number in\
    \ the array\n    $min_number = $numbers[0];\n    // Start at the 2nd number\n\
    \    $i = 1;\n    foreach ($numbers as $number) {\n        if ($number < $min_number)\
    \ {\n            $min_number = $number;\n            $i = $i - 1;\n        }\n\
    \    }\n    // Get difference between min number and rest of the numbers\n   \
    \ $diff = $min_number - $numbers[$i];\n    // Return rescaled array\n    return\
    \ array_map(function ($number) {\n        return $number / $diff;\n    }, $numbers);\n\
    }", "    $min = min($numbers);\n    $max = max($numbers);\n    $scale = ($max\
    \ - $min) * 0.01;\n    return $min + ($numbers - $min) / $scale;\n}\n", "    $minimum\
    \ = min($numbers);\n    $maximum = max($numbers);\n    $range_difference = abs($maximum\
    \ - $minimum);\n    $scale = 1 / $range_difference;\n    if ($minimum > 0) {\n\
    \        return array($scale * $minimum, $scale * $maximum);\n    }\n    return\
    \ array($scale * $minimum, $scale * $maximum);\n}\n", "\t$min = min(array_map('round',\
    \ $numbers));\n\t$max = max(array_map('round', $numbers));\n\treturn array_map(function\
    \ ($n) use ($min, $max) {\n\t\treturn $n + ($n - $min) / ($max - $min);\n\t},\
    \ $numbers);\n}\n\n\n/**\n * Turns an array of numbers into a number string.\n\
    \ *\n * @param array $numbers an array of numbers to process\n * @return string\
    \ number string\n */", "    if (count($numbers) < 2) {\n        return $numbers;\n\
    \    }\n    $minimum = min(array_keys($numbers));\n    $maximum = max(array_keys($numbers));\n\
    \    foreach ($numbers as $key => $value) {\n        $result[$key] = $value -\
    \ $minimum;\n    }\n    foreach ($numbers as $key => $value) {\n        $result[$key]\
    \ = $result [$key] / $maximum;\n    }\n    return $result;\n}\n</code>\n<|/ a\
    \ dscore=5 tags=php,algorithm,math |>\n<| c |>\nI'm so sorry that I edited the\
    \ answer to add another edit. It's now only in one edit. Thanks.\n<|/ c |>\n<|\
    \ c |>\nThank you for the edit but this answer still works. I added a couple of\
    \ comments to explain why it works. It's still a great solution, though. Upvote\
    \ it :)\n<|/ c |>\n<| c |>\nI like this solution, especially since it is so short\
    \ and concise.\n<|/ c |>\n<| c |>\nI tested this and it works nicely, but when\
    \ I tried to use it in a for loop, it goes wrong sometimes. For example when I\
    \ tried it on a set of about 500 numbers, it kept returning a value larger than\
    \ the original array. Is there a better way to handle it?\n<|/ c |>\n<| c |>\n\
    It's worth mentioning that if your array has negative numbers, the function will\
    \ return the array with the negative values unchanged.\n<|/ c |>\n<| a dscore=4\
    \ tags=php,algorithm,math |>\nThis one will also work and it looks nice:\n<code>",
  "  if (!$numbers) {\n    return $numbers;\n  }\n  if (count($numbers) < 2) {\n \
    \   return $numbers;\n  }\n  $min_value = min($numbers);\n  $max_value = max($numbers);\n\
    \n  // If all numbers are the same, return an array with 1 element\n  if ($min_value\
    \ == $max_value) {\n    return array($min_value);\n  }\n\n  // Otherwise, return\
    \ an array with 1 element (representing the min) and\n  // 1 element (representing\
    \ the max - min) spanned\n  return array($min_value, $max_value);\n}\n</code>\n\
    <|/ a tags=php,math,arrays |>\n<| c |>\nThe only problem with this solution is\
    \ that it will return an array with 2 elements, not 1. Not sure how to change\
    \ it to return 1 element with an array inside containing both min and max values.\n\
    <|/ c |>\n<| a tags=php,math,arrays dscore=5 |>\n<code>\n$arr = [1,2,3,4,5,6];\n\
    \n$min_value = min($arr);\n$max_value = max($arr);\n\n$range = array_combine($arr,\
    \ range($min_value, $max_value));\n</code>\n<|/ a |>\n<| c |>\nNice one but in\
    \ PHP 7 you'll need to use `range()`: `$range = array_combine($arr, range($min_value,\
    \ $max_value));`\n<|/ c |>\n<| c |>\nNice one :) but what if I want to get the\
    \ minimum & maximum value of a 2D array. for example: $arr1 = [1,2,3,4,5]; $arr2\
    \ = [1,3,5,7,9]; min($arr1); and max($arr2);\n<|/ c |>\n<| c |>\n`array_combine`\
    \ will create one dimensional array. Not sure if this is desired behaviour.\n\
    <|/ c |>\n<| c |>\nThis doesn't seem to work for the case where there are values\
    \ like `1,000,000` and the min is `1`, but max is `2`\n<|/ c |>\n<| c |>\nwhat\
    \ happens if there is a negative number in the array ?\n<|/ c |>\n<| a tags=php,math,arrays\
    \ dscore=5 |>\nIn PHP 7 you can use\n<code>\n$min  = min($arr);\n$max  = max($arr);\n\
    $range = array_combine($arr, $range + [1 => 1]);\n</code>\nOr use\n<code>\n$min\
    \  = min($arr);\n$max  = max($arr);\n$range = [$min, $max];\n$range[] = 1;\n</code>\n\
    <|/ a |>\n<| c |>\nThe second method worked ", "  $min = array_shift($numbers);\n\
    \  $max = array_shift($numbers);\n  foreach ($numbers as $number) {\n    $number\
    \ = $number / $max;\n    $number *= $min;\n    $number += 0.5;\n  }\n  return\
    \ $numbers;\n}\n</code>\n<|/ a tags=php |>\n<| a dscore=3 |>\nThe PHP function\
    \ array_map() allows you to apply a function to all elements in an array. \n<code>\n\
    $array = [1, 2, 3, 4, 5];\n$array2 = array_map('ceil', $array);\nprint_r($array2);\n\
    </code>\nResult:\n<code>\nArray\n(\n    [0] => 1\n    [1] => 2\n    [2] => 3\n\
    \    [3] => 4\n    [4] => 5\n)\n</code>\n<|/ a tags=php |>\n<| a dscore=3 tags=php\
    \ |>\nThis is an extension of Rob Jones answer.\n<code>\n$numbers = [1,3,5];\n\
    $max = $numbers[0];\n$numbers = array_map('array_sum', $numbers);\n\n$total =\
    \ 0;\nforeach ($numbers as $number) {\n    $total += $number / $max;\n}\n\necho\
    \ $total;\n</code>\n<|/ a |>\n<| a dscore=3 |>\nHere is my answer that doesn't\
    \ need any loops or functions. This one will give the correct result even for\
    \ arrays that have one element or less (by rounding).\n<code>\n$numbers = [1.2,\
    \ 1.5, 2.2];\n\n$largest = max($numbers);\n$smallest = min($numbers);\n$sum =\
    \ $smallest / $largest;\n$numbers = array($sum * $largest);\n$numbers = array_values($numbers);\n\
    \nprint_r($numbers);\n</code>\nOutput is:\n<code>\nArray\n(\n    [0] => 2.0\n\
    \    [1] => 2.5\n    [2] => 2.8\n)\n</code>\n<|/ a tags=php |>\n<| a |>\nUse this\
    \ simple function\n<code>", "  $min = $numbers[0];\n  $max = min($numbers);\n\
    \  return array_map(function($n) use($min, $max) {\n    return ($n - $min) / ($max\
    \ - $min);\n  }, $numbers);\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nFor a linear\
    \ scale, this is actually pretty good. However, for some reason `array_map` didn't\
    \ work for me (I had to call it with a callable that accepts the element) - but\
    \ then again, my PHP version is pretty old.\n<|/ c |>\n<| c |>\n`array_map` works\
    \ for me just fine (PHP 5.3.3). I think it must be some weird `array_map` bug\
    \ (the docs say \"A callback function for [...] element-by-element array **mapping**\
    \ that is provided by array_map\". Maybe some kind of strict typing?). Not sure\
    \ what's causing it, but `array_reduce` works fine (with callback).\n<|/ c |>\n\
    <| c |>\nOh, that's strange: it works for me with PHP 5.2.6, but 5.3.3 gives me\
    \ an error. Maybe it's some weird bug in PHP 5.3.3? I can only test it on 5.3.3\
    \ though.\n<|/ c |>\n<| a tags=php,arrays,scaling |>\nUse array_map to scale the\
    \ value\n<code>", "    list($smallest, $largest) = $numbers;\n    if ($smallest\
    \ == $largest) {\n        return array($smallest);\n    }\n\n    $scale = 1.0\
    \ / ($largest - $smallest);\n\n    return array_map(function ($number) use ($scale)\
    \ {\n        return $number * $scale;\n    }, $numbers);\n}\n", "  // if there's\
    \ no input, just return an empty array\n  if(!isset($numbers[0])) return array();\n\
    \  // get the min and max values\n  $min = min($numbers);\n  $max = max($numbers);\n\
    \  // get the difference between max and min\n  $difference = $max - $min;\n \
    \ // get the size of the new array\n  $size = count($numbers);\n  // calculate\
    \ the new values\n  $return = array();\n  for($i=0; $i<$size; $i++) {\n    $return[$i]\
    \ = $numbers[$i] / $difference;\n  }\n  // return the array of the new values\n\
    \  return $return;\n}\n", "  if (count($numbers) <= 1) return $numbers;\n  $min\
    \ = reset($numbers);\n  $max = end($numbers);\n  $scale = max(1, $min / $max);\n\
    \  return array($min * $scale, $max * $scale);\n}\n", "  $min = array_reduce($numbers,\
    \ min);\n  $max = array_reduce($numbers, max);\n\n  $rescaled_numbers = array();\n\
    \  for ($i = count($numbers) - 1; $i >= 0; $i--) {\n    $rescaled_numbers[] =\
    \ $numbers[$i] / ($max - $min);\n  }\n\n  return $rescaled_numbers;\n}\n</code>\n\
    <|/ a tags=php,arrays |>\n<| c |>\nI believe this does not work if the array is\
    \ empty, e.g. `array(0)` => `array(1)` => `array(0)`\n<|/ c |>\n<| c |>\nHmm,\
    \ yeah, good point. I wonder why I thought it did. Fixed now.\n<|/ c |>\n<| c\
    \ |>\nWorks perfectly! Thanks mate.\n<|/ c |>\n<| a tags=php,arrays dscore=1 |>\n\
    Try something like this...\n<code>\n$array = array(1,2,3,4,5,6);\n$numbers = array_map('array_filter',\
    \ $array);\n$min = min(array_map('array_min', $numbers));\n$max = max(array_map('array_max',\
    \ $numbers));\n$range = array();\nforeach($numbers as $n){\n    $range[] = ($n\
    \ - $min) / $max;\n}\n</code>\n<|/ a |>\n<| a |>\nHere is another way to do it\
    \ but with array_reduce():\n<code>\n<?php", "  $min = min($numbers);\n  $max =\
    \ max($numbers);\n  if ($min == $max) {\n    return array($min);\n  }\n\n  $new_numbers\
    \ = array();\n  for ($i = 0; $i < count($numbers); ++$i) {\n    $new_numbers[$i]\
    \ = $numbers[$i] / $max;\n  }\n  return $new_numbers;\n}\n", "    // If there\
    \ are no numbers, assume that they are 0\n    if (!isset($numbers[0])) {\n   \
    \     return array(0.0, 1.0);\n    }\n    // If there is just one number, assume\
    \ that the unit does not change\n    if (count($numbers) <= 1) {\n        return\
    \ array($numbers[0], $numbers[0]);\n    }\n    // Calculate minimum number as\
    \ maximum of the first two numbers\n    $min = $numbers[0];\n    $min = ($min\
    \ < $numbers[1]) ? $min : $numbers[1];\n    // Calculate the maximum number from\
    \ the two numbers\n    $max = $numbers[0];\n    $max = ($max > $numbers[1]) ?\
    \ $max : $numbers[1];\n    // Calculate scaling factor\n    $factor = $max - $min;\n\
    \    // Normalize array elements by subtracting smallest from largest\n    //\
    \ For some reason PHP can't handle division if the numbers are integers\n    //\
    \ So we need to cast $factor to an int and divide it by 1, instead of just dividing\
    \ it\n    return array($min + (int)($factor * 1.000001), $max - (int)($factor\
    \ * 1.000001), $max);\n}\n"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
