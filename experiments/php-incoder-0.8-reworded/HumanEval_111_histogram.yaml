name: HumanEval_111_histogram
language: php
prompt: "<?php\n// Given a string representing a space separated lowercase letters,\
  \ return an array\n// of the letter with the most repetition and containing the\
  \ corresponding count.\n// If several letters have the same occurrence, return all\
  \ of them.\n// Example:\n// >>> histogram(\"a b c\")\n// array(\"a\" => 1, \"b\"\
  \ => 1, \"c\" => 1)\n// >>> histogram(\"a b b a\")\n// array(\"a\" => 2, \"b\" =>\
  \ 2)\n// >>> histogram(\"a b c a b\")\n// array(\"a\" => 2, \"b\" => 2)\n// >>>\
  \ histogram(\"b b b b a\")\n// array(\"b\" => 4)\n// >>> histogram(\"\")\n// array()\n\
  function histogram($test) {\n"
tests: "function candidate(...$args) {\n    return histogram(...$args);\n}\n\nfunction\
  \ test(): void {\n    if (candidate(\"a b b a\") !== array(\"a\" => 2, \"b\" =>\
  \ 2)) { throw new Exception(\"Test failed!\"); }\n    if (candidate(\"a b c a b\"\
  ) !== array(\"a\" => 2, \"b\" => 2)) { throw new Exception(\"Test failed!\"); }\n\
  \    if (candidate(\"a b c d g\") !== array(\"a\" => 1, \"b\" => 1, \"c\" => 1,\
  \ \"d\" => 1, \"g\" => 1)) { throw new Exception(\"Test failed!\"); }\n    if (candidate(\"\
  r t g\") !== array(\"r\" => 1, \"t\" => 1, \"g\" => 1)) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(\"b b b b a\") !== array(\"b\" => 4)) { throw\
  \ new Exception(\"Test failed!\"); }\n    if (candidate(\"r t g\") !== array(\"\
  r\" => 1, \"t\" => 1, \"g\" => 1)) { throw new Exception(\"Test failed!\"); }\n\
  \    if (candidate(\"\") !== array()) { throw new Exception(\"Test failed!\"); }\n\
  \    if (candidate(\"a\") !== array(\"a\" => 1)) { throw new Exception(\"Test failed!\"\
  ); }\n}\n\ntest();"
completions: ["  $letterCounts = array();\n  foreach (preg_split('//', $test) as $letter)\
    \ {\n    $letterCounts[$letter]++;\n  }\n  return $letterCounts;\n}\n</code>\n\
    This would then be used as:\n<code>", "    $result = array();\n    $words = preg_split('/\\\
    s+/', $test);\n    foreach($words as $word) {\n        $char = strtolower($word);\n\
    \        $result[$char] = (isset($result[$char]) ? $result[$char] + 1 : 1);\n\
    \    }\n    return $result;\n}\n", "    $array = preg_split(\"/[\\s]+/\", $test);\n\
    \    $result = array();\n    foreach ($array as $letter) {\n        if (isset($result[$letter]))\
    \ {\n            $result[$letter]++;\n        } else {\n            $result[$letter]\
    \ = 1;\n        }\n    }\n    return $result;\n}\n</code>\nIf you need to get\
    \ the letter with the most repetition:\n<code>\n$array = preg_split(\"/[\\s]+/\"\
    , $test);\n$result = array();\nforeach ($array as $letter) {\n    if (isset($result[$letter]))\
    \ {\n        $result[$letter]++;\n    } else {\n        $result[$letter] = 1;\n\
    \    }\n}\narsort($result);\n$result[0]; // First element is the most repetitive\n\
    </code>\n<|/ a tags=string,php,arrays,string dscore=5 |>\n<| c |>\nThis doesn't\
    \ seem to work for strings like \"a b\" where there are two a's in the string\
    \ and only one b in the string - it outputs just the a, no b. It also doesn't\
    \ work if there are multiple instances of a letter, e.g. \"a b a c\" outputs just\
    \ a\n<|/ c |>\n<| c |>\n, `array(\"a\" => 1, \"b\" => 1)` indicates that both\
    \ letters are present. Can you please add some examples?\n<|/ c |>\n<| c |>\n\
    Ah yes, I did misunderstand what you meant. I was confused because I thought you\
    \ were saying that if a letter occurred more than once, you'd only count it once.\
    \ You're saying that if two letters have the same count, you'd count them both.\
    \ That's what I meant. Sorry for my misunderstanding.\n<|/ c |>\n<| c |>\nThe\
    \ array would look something like this: array(\n    \"a\" => 2,\n    \"b\" =>\
    \ 2,\n    \"c\" => 1\n)\n<|/ c |>\n<| c |>\nI've updated my answer and added a\
    \ code example for the letter with the most repetition. Thanks for clarifying.\n\
    <|/ c |>\n<| a |>\nHere is an alternative solution:\n<code>\n$words = explode('\
    \ ', \"the quick brown fox jumps over the lazy dog\");\n$letters = array();\n\
    foreach($words as $word){\n  if(!array_key_exists($word, $letters)){\n    $letters[$word]\
    \ = 1;\n  } else {\n    $letters[$word]++;\n  }\n}\narsort($letters);\nvar_dump($letters);\n\
    </code>\n<|/ a tags=string,php,arrays,string dscore", "  $letters = preg_split(\"\
    //u\", $test);\n  $result = [];\n  foreach ($letters as $letter) {\n    if (!isset($result[$letter]))\
    \ {\n      $result[$letter] = 1;\n    } else {\n      $result[$letter]++;\n  \
    \  }\n  }\n  return $result;\n}\n\n/**\n * Compare two histograms to find the\
    \ most frequent and least frequent\n * letters.\n *\n * @param array $histogram1\
    \ the first histogram, expected as array of letters\n * @param array $histogram2\
    \ the second histogram, expected as array of letters\n * @return array the first\
    \ and the second histograms with the most and least\n *   frequent letters added\n\
    \ */", "  $histogram = array();\n  foreach (explode(\" \", $test) as $letter)\
    \ {\n    $letter = $letter.toLowerCase();\n    if (array_key_exists($letter, $histogram))\
    \ {\n      $histogram[$letter]++;\n    } else {\n      $histogram[$letter] = 1;\n\
    \    }\n  }\n  return $histogram;\n}\n", "  $histogram = array();\n\n  $words\
    \ = explode(\" \", $test);\n  foreach($words as $word)\n  {\n    // This line\
    \ is the tricky part:\n    //\n    // We want to find the value of a single letter,\n\
    \    // but there are two problematic cases:\n    //\n    // 1. If the letter\
    \ is not in the histogram, we must assume it has no occurrences.\n    // 2. If\
    \ the letter is in the histogram, we must find the max occurrence\n    //    of\
    \ the letter from the histogram.\n    //\n    // The first case is easy to solve:\
    \ just add the letter to an array with\n    // a value of 1. The second case is\
    \ trickier: if we found a key that already\n    // has a value, then we have to\
    \ overwrite the old value with the new value.\n    //\n    // The trick here is\
    \ to get the max value of a key, then check if that value\n    // exists. And\
    \ only then add it.\n\n    if (array_key_exists($word, $histogram))\n    {\n \
    \     $histogram[$word] = $histogram[$word] + 1;\n    }\n    else\n    {\n   \
    \   $histogram[$word] = 1;\n    }\n  }\n\n  arsort($histogram);\n\n  return $histogram;\n\
    }", "  $result = array();\n  $words = explode(' ', $test);\n  foreach ($words\
    \ as $word) {\n    if (isset($result[$word])) {\n      $result[$word]++;\n   \
    \ } else {\n      $result[$word] = 1;\n    }\n  }\n  return $result;\n}\n", " \
    \   $arr = explode(' ', $test);\n    $result = array();\n    foreach ($arr as\
    \ $letter) {\n        if (isset($result[$letter])) {\n            $result[$letter]\
    \ += 1;\n        } else {\n            $result[$letter] = 1;\n        }\n    }\n\
    \    return $result;\n}\n\n/**\n * Given a string representing a space-separated\
    \ lowercase letters, return an array\n * of the letter with the most repetition\
    \ and containing the corresponding count.\n * If several letters have the same\
    \ occurrence, return all of them.\n * Example:\n * >>> histogram(\"a b c\")\n\
    \ * array(\"a\" => 1, \"b\" => 1, \"c\" => 1)\n * >>> histogram(\"a b b a\")\n\
    \ * array(\"a\" => 2, \"b\" => 2)\n * >>> histogram(\"a b c a b\")\n * array(\"\
    a\" => 2, \"b\" => 2)\n * >>> histogram(\"b b b b a\")\n * array(\"b\" => 4)\n\
    \ * >>> histogram(\"\")\n * array()\n */", "  $histogram = array();\n\n  foreach\
    \ (str_split($test) as $letter) {\n    if (!isset($histogram[$letter])) {\n  \
    \    $histogram[$letter] = 1;\n    } else {\n      $histogram[$letter]++;\n  \
    \  }\n  }\n\n  return $histogram;\n}\n", "    $result = array();\n\n    foreach\
    \ (explode(' ', $test) as $letter) {\n        if (array_key_exists($letter, $result))\
    \ {\n            $result[$letter]++;\n        } else {\n            $result[$letter]\
    \ = 1;\n        }\n    }\n\n    return $result;\n}\n", "  $hist = array();\n\n\
    \  $words = explode(\" \", $test);\n  foreach ($words as $word) {\n    if (isset($hist[$word]))\
    \ {\n      $hist[$word]++;\n    } else {\n      $hist[$word] = 1;\n    }\n  }\n\
    \n  return $hist;\n}\n", "  $histogram = array();\n  foreach (explode(' ', $test)\
    \ as $letter) {\n    $count = array_key_exists($letter, $histogram) ? $histogram[$letter]+1\
    \ : 1;\n    $histogram[$letter] = $count;\n  }\n  return $histogram;\n}\n", " \
    \ $histogram = array();\n  foreach (explode(\" \", $test) as $c) {\n    $histogram[$c]\
    \ = isset($histogram[$c]) ? $histogram[$c] + 1 : 1;\n  }\n  return $histogram;\n\
    }\n", "  $letters = str_split($test);\n  $histo = array();\n\n  foreach ($letters\
    \ as $letter) {\n    if (!isset($histo[$letter])) {\n      $histo[$letter] = 0;\n\
    \    }\n    $histo[$letter]++;\n  }\n\n  // Sort the letters by frequency\n  arsort($histo);\n\
    \n  // Return the letters with the most occurence\n  $max = reset($histo);\n \
    \ $retVal = array();\n  foreach ($histo as $letter => $count) {\n    if ($count\
    \ === $max) {\n      $retVal[$letter] = $count;\n    }\n  }\n\n  // If no letters\
    \ had the same occurrence, return an empty array\n  if (empty($retVal)) {\n  \
    \  return array();\n  }\n\n  return $retVal;\n}\n</code>\n<|/ a |>\n<| c |>\n\
    The code seems to be doing exactly what I want, but when I try it it says \"Notice:\
    \ Array to string conversion in /var/www/html/histogram.php on line 7\" any idea\
    \ why that could be? The code is definitely correct though\n<|/ c |>\n<| c |>\n\
    Ah, i see what it is, im still learning php and just realised that i forgot to\
    \ add \"return\" at the end of the function, it works now, thanks!\n<|/ c |>\n\
    <| a tags=php |>\n<code>", "  if(empty($test)) {\n    return array();\n  }\n \
    \ // Turn the string into an array\n  $letters = explode(\" \", $test);\n  $counts\
    \ = array();\n\n  // Iterate over the letters in the string\n  foreach($letters\
    \ as $letter) {\n    // Check if the current letter is already in the array\n\
    \    // If so, increment the count by one\n    if(isset($counts[$letter])) {\n\
    \      $counts[$letter] = $counts[$letter] + 1;\n    } else {\n      // If not,\
    \ add the letter as a key, with the count as its value\n      $counts[$letter]\
    \ = 1;\n    }\n  }\n\n  // Return the letter/count array with the letter with\
    \ the most count\n  return $counts;\n}\n", "  // Count how many letters we saw\
    \ in the test string.\n  $histogram = array();\n  $keys = preg_split('/\\s+/',\
    \ strtolower($test));\n  foreach ($keys as $key) $histogram[$key] = 0;\n  // Count\
    \ the occurrences of each letter, update our histogram.\n  foreach ($keys as $key)\
    \ {\n    $histogram[$key] += 1;\n  }\n  // Return an array with the letter with\
    \ the most occurrence, and the\n  // corresponding occurrence count.\n  return\
    \ array_reduce($histogram, 'array_merge', array());\n}\n", "  $letters = array_count_values(str_split($test));\n\
    \  $letters = array_fill_keys(array_keys($letters), 0);\n  asort($letters);\n\
    \  foreach ($letters as $letter => $count) {\n    if ($count > 1) {\n      return\
    \ array($letter => $count);\n    }\n  }\n  return array();\n}\n</code>\n<|/ a\
    \ dscore=3 |>\n<| a |>\nHere is a little helper function that will do it\n<code>",
  "  $letters = array_count_values(str_split($test));\n  $letters = array_filter($letters);\n\
    \  arsort($letters);\n  $letters = array_keys($letters);\n  $return = array();\n\
    \  foreach ($letters as $letter) {\n    if (isset($return[$letter])) {\n     \
    \ $return[$letter] += 1;\n    } else {\n      $return[$letter] = 1;\n    }\n \
    \ }\n  return $return;\n}", "  $histogram = array();\n  $letters = preg_split('/\\\
    s+/', strtolower($test));\n  foreach ($letters as $letter) {\n    if (array_key_exists($letter,\
    \ $histogram)) {\n      $histogram[$letter]++;\n    } else {\n      $histogram[$letter]\
    \ = 1;\n    }\n  }\n  arsort($histogram);\n  $result = array();\n  foreach ($histogram\
    \ as $letter => $count) {\n    $result[] = $letter;\n  }\n  return $result;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThanks for this. Looks like something that could\
    \ help me. Although I don't fully understand the code you posted yet :)\n<|/ c\
    \ |>\n<| c |>\nNo problem. I added comments to the code, hope it helps. :)\n<|/\
    \ c |>\n<| c |>\nThanks again. This is great. I'll have a play with it now and\
    \ will let you know how I get on. Thanks again.\n<|/ c |>\n<| c |>\nI added a\
    \ quick example and some explanation to the answer. If you're not familiar with\
    \ the code I posted, you can check it out [here](http://www.daniweb.com/web-development/php/code/39845/php-count-letters-in-a-string).\n\
    <|/ c |>\n<| a tags=php |>\nI have modified the code provided by Tanker to the\
    \ following code which works well with PHP < 5.4 as well as PHP 5.4 and above\
    \ (I tested it on PHP 5.6 and PHP 7)\n<code>", "    $result = array();\n    $words\
    \ = explode(' ', $test);\n    foreach ($words as $word) {\n        $count = 1;\n\
    \        if (array_key_exists($word, $result))\n            $count = $result[$word];\n\
    \        $result[$word] = $count;\n    }\n    $result = array_count_values($result);\n\
    \    if (count($result) == 0) {\n        return array();\n    }\n    arsort($result);\n\
    \    return $result;\n}\n", "\t$result = [];\n\tforeach (preg_split('/ +/', $test)\
    \ as $letter) {\n\t\t$count = (isset($result[$letter]) ? $result[$letter] : 0)\
    \ + 1;\n\t\t$result[$letter] = $count;\n\t}\n\n\treturn $result;\n}\n", "    $letters\
    \ = str_split($test);\n    $histogram = array();\n\n    foreach ($letters as $letter)\
    \ {\n        if (empty($histogram[$letter])) {\n            $histogram[$letter]\
    \ = 1;\n        }\n        else {\n            $histogram[$letter]++;\n      \
    \  }\n    }\n\n    arsort($histogram);\n    foreach ($histogram as $letter =>\
    \ $count) {\n        if ($count == count($letters) - 1) {\n            array_push($letters,\
    \ $letter);\n        }\n    }\n\n    return $letters;\n}\n", "\t$letters = str_split($test);\n\
    \t$res = array();\n\tforeach ($letters as $letter) {\n\t\t$count = (count($letters)\
    \ == 1) ? 1 : count($letters);\n\t\t$res[$letter] = isset($res[$letter]) ? $res[$letter]\
    \ + $count : $count;\n\t}\n\treturn $res;\n}\n", "  $letters = array_count_values(str_split($test));\n\
    \  arsort($letters);\n  $letters = array_slice($letters, 0, -1);\n  foreach ($letters\
    \ as $letter => $count) {\n    $letters[$letter] = $letter;\n  }\n\n  return $letters;\n\
    }\n\n/**\n * Returns the number of occurrences of the input string\n *\n * @param\
    \ $test\n *\n * @return int\n */", "  if (is_null($test) || trim($test) == '')\
    \ return array();\n  $histogram = array();\n  foreach(array_count_values(str_split($test))\
    \ as $letter => $count) {\n    if (!isset($histogram[$letter])) $histogram[$letter]\
    \ = $count;\n    else $histogram[$letter] += $count;\n  }\n  return $histogram;\n\
    }\n", "  if (!$test) {\n    return array();\n  }\n\n  $result = array();\n\n \
    \ foreach (str_split($test) as $c) {\n    if (isset($result[$c])) {\n      $result[$c]++;\n\
    \    } else {\n      $result[$c] = 1;\n    }\n  }\n\n  arsort($result);\n\n  return\
    \ array_slice($result, 0, 1);\n}", "    return preg_replace_callback(\"/ +/\"\
    ,\n        function ($matches) use ($test) {\n            $count = 0;\n      \
    \      $result = [];\n            $testChar = $test[0];\n            foreach(str_split($matches[0])\
    \ as $testChar) {\n                if ($testChar === $testChar) {\n          \
    \          $count++;\n                } else {\n                    $result[$testChar]\
    \ = $count;\n                    $count = 1;\n                }\n            }\n\
    \            $result[$testChar] = $count;\n            return $result;\n     \
    \   },\n        $test);\n}\n</code>\n<|/ a |>\n<| c |>\nCan you please explain\
    \ the code a bit. Im a beginner with php. thanks\n<|/ c |>\n<| c |>\nSure thing,\
    \ added some comments\n<|/ c |>\n<| c |>\ni got this error\n\n`PHP Parse error:\
    \  syntax error, unexpected T_FUNCTION, expecting ')' in /home/xxxxx/public_html/xxxxx/test/test.php\
    \ on line 16`\n\nI added this line to my code\n\n`return preg_replace_callback(\"\
    / +/\",`\n<|/ c |>\n<| c |>\nOh sorry, forgot the `use ($test)` bit\n<|/ c |>\n\
    <| c |>\n`PHP Fatal error:  Uncaught exception 'Exception' with message '<b>Fatal\
    \ error</b>:  Uncaught exception 'Exception' with message '<b>Notice</b>:  Undefined\
    \ offset: 1 in`\n<|/ c |>\n<| a |>\n<code>", "  $letters = array_count_values(str_split(strtolower($test)));\n\
    \  $histogram = array();\n  foreach ($letters as $letter => $count) {\n    $histogram[$letter]\
    \ = max((int)$count, $histogram[$letter]);\n  }\n  return $histogram;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nYou have the right idea, but your code has a bug. Try histogram(\"\
    a b c a b b\") (note the last two occurrences of \"b\") and you'll see that your\
    \ code gives you the wrong result. Correct code is:\n\n    $histogram = array();\n\
    \    foreach ($letters as $letter => $count) {\n     $histogram[$letter] = max((int)$count,\
    \ $histogram[$letter]);\n    }\n    return $histogram;\n<|/ c |>\n<| a |>\n<code>\n\
    $string = \"abcdefghijklmnopqrstuvwxyz\";\n$alphabet = str_split($string);\n\n\
    $histogram = array();\nforeach ($alphabet as $letter) {\n    $histogram[$letter]\
    \ = isset($histogram[$letter]) ? $histogram[$letter] + 1 : 1;\n}\n\narsort($histogram);\n\
    var_dump($histogram);\n</code>\n<|/ a tags=arrays,php,count,sorting,histogram\
    \ dscore=1 |>\n<| a |>\nHere is a more scalable solution:\n<code>\n$string = \"\
    abcdefghijklmnopqrstuvwxyz\";\n$histogram = array();\nforeach (str_split($string)\
    \ as $letter) {\n    $histogram[$letter] = isset($histogram[$letter]) ? $histogram[$letter]\
    \ + 1 : 1;\n}\n\narsort($histogram);\nvar_dump($histogram);\n</code>\n<|/ a dscore=1\
    \ tags=arrays,php,count,sorting,histogram |>\n<| a tags=arrays,php,count,sorting,histogram\
    \ |>\nThe solution above is very good!\nHowever, there is a bug that is missing\
    \ from that solution, which is the following line:\n<code>\n$histogram[$letter]\
    \ = max((int)$count, $histogram[$letter]);\n</code>\nIf $count is 0 it will return\
    \ 0 as the result. This means we cannot simply use max() or min() to get a histogram,\
    \ which can be useful for a lot of things.\nTo solve this problem we first add\
    \ in the array the value 0 if it is not yet there.\n<code>\n$letters = array_count_values(str_split(strtolower($string)));\n\
    \nforeach ($letters as $letter => $count) {\n  if (isset($histogram[$letter]))\
    \ {\n    $histogram[$letter] += $", "\t$occurrences = array_count_values(str_split($test));\n\
    \tarsort($occurrences);\n\n\t$letters = array();\n\tforeach ($occurrences as $letter\
    \ => $count) {\n\t\t$letters[$letter] = $count;\n\t}\n\n\treturn $letters;\n}\n",
  "  $result = array();\n  // Use str_word_count() to break the string up into a word\
    \ array.\n  // $testArray = str_word_count($test, 1);\n  // Iterate over each\
    \ word in the array\n  foreach (str_word_count($test, 1) as $word) {\n    $result[strtolower($word)]\
    \ = isset($result[$word]) ? $result[$word] + 1 : 1;\n  }\n  return $result;\n}",
  "  $result = array();\n  $letters = preg_split('//u', $test);\n  $counts = array_count_values($letters);\n\
    \  foreach ($counts as $letter => $count) {\n    if ($count > 1) {\n      foreach\
    \ ($counts as $letter2 => $count2) {\n        if ($letter != $letter2 &&\n   \
    \       (isset($counts[$letter2]) && $counts[$letter2] > $counts[$letter])) {\n\
    \          $result[$letter] = $count;\n        }\n      }\n      break;\n    }\n\
    \  }\n  return $result;\n}\n", "    $letters = str_split($test);\n    $histogram\
    \ = array();\n    $count = 0;\n    foreach ($letters as $letter) {\n        if\
    \ (isset($histogram[$letter])) {\n            $histogram[$letter] += 1;\n    \
    \    } else {\n            $histogram[$letter] = 1;\n        }\n    }\n    arsort($histogram);\n\
    \    foreach ($histogram as $letter => $count) {\n        $result[] = $letter;\n\
    \    }\n    return $result;\n}\n", "  $letters = array_count_values(str_split($test));\n\
    \  arsort($letters);\n  $max = $letters[''];\n  $result = array();\n  foreach\
    \ ($letters as $letter => $count) {\n    if ($count > $max) {\n      $max = $count;\n\
    \    }\n    $result[$letter] = $count;\n  }\n  return $result;\n}\n", "  $histogram\
    \ = array();\n  $split = preg_split('/\\s/', $test);\n  foreach ($split as $letter)\
    \ {\n    $histogram[$letter] = array_key_exists($letter, $histogram) ? $histogram[$letter]\
    \ + 1 : 1;\n  }\n  return $histogram;\n}", "  $histogram = array();\n  $test \
    \ = strtolower($test);\n  $length = strlen($test);\n  for ($i = 0; $i < $length;\
    \ $i++) {\n    $letter = substr($test, $i, 1);\n    if (isset($histogram[$letter]))\
    \ {\n      $histogram[$letter]++;\n    } else {\n      $histogram[$letter] = 1;\n\
    \    }\n  }\n  arsort($histogram);\n  return $histogram;\n}\n", "    $histogram\
    \ = array();\n    $words = preg_split('/\\s+/', $test);\n    foreach ($words as\
    \ $word) {\n        if (isset($histogram[$word])) $histogram[$word]++;\n     \
    \   else $histogram[$word] = 1;\n    }\n    arsort($histogram);\n    return $histogram;\n\
    }\n", "  $histogram = array();\n  $tokens = str_word_count(strtolower($test));\n\
    \  foreach ($tokens as $token) {\n    $histogram[$token] = 0;\n  }\n  foreach\
    \ ($tokens as $token) {\n    if (!isset($histogram[$token])) {\n      $histogram[$token]\
    \ = 0;\n    }\n    $histogram[$token]++;\n  }\n  arsort($histogram);\n  return\
    \ $histogram;\n}", "  // Parse the test string into an array of single character\
    \ strings\n  $chars = str_split($test);\n  // Initialize an array of character\
    \ counts\n  $counts = array_fill(0, 256, 0);\n  // Go through the array\n  foreach\
    \ ($chars as $c) {\n    // Get the character index\n    $idx = ord($c);\n    //\
    \ Get the character count\n    $counts[$idx] += 1;\n  }\n  // Loop through the\
    \ counts and find the one with the most occurrences\n  $max = 0;\n  $results =\
    \ [];\n  foreach ($counts as $count) {\n    if ($count > $max) {\n      $max =\
    \ $count;\n      $results = [$chars[$idx]];\n    } else if ($count == $max) {\n\
    \      $results[] = $chars[$idx];\n    }\n  }\n  return $results;\n}\n", "  //\
    \ Use a hashmap to store letter counts\n  $histogram = array();\n\n  // Split\
    \ string into space separated strings\n  $tokens = explode(' ', $test);\n\n  //\
    \ Iterate through tokens\n  foreach ($tokens as $token) {\n    // Increment occurrence\
    \ count for current letter\n    $histogram[strtolower($token)] = isset($histogram[strtolower($token)])\
    \ ? $histogram[strtolower($token)] : $token;\n  }\n\n  // Sort array of counts\
    \ by frequency\n  arsort($histogram);\n\n  // Return array of letters and counts\n\
    \  return $histogram;\n}\n</code>\n<|/ a |>\n<| c |>\nThanks for the idea, I thought\
    \ it might be too much to write this out but its definitely a great idea\n<|/\
    \ c |>\n<| a tags=string,php,sorting dscore=0 |>\nHere's a quick way of doing\
    \ it using the php sort function\n<code>\n$testArray = array(\"A\",\"B\",\"A\"\
    ,\"A\",\"B\",\"C\",\"A\",\"C\",\"B\",\"C\",\"A\",\"A\",\"C\",\"A\");\n$testArray\
    \ = sortAlphabetically($testArray);", "  $histogram = array();\n  // Use strtok\
    \ because explode creates 1 element array\n  // and we want the original string\
    \ back for comparison.\n  $tokens = strtok($test, \" \");\n  while ($tokens !=\
    \ null) {\n    if (isset($histogram[$tokens])) {\n      $histogram[$tokens]++;\n\
    \    } else {\n      $histogram[$tokens] = 1;\n    }\n    $tokens = strtok(\"\
    \ \");\n  }\n  return $histogram;\n}\n</code>\n<|/ a |>\n<| a tags=php,counting,arrays\
    \ |>\nYou want a histogram.\nThe first step is to break down the string into arrays\
    \ of individual characters. One way of doing this is using str_split().\nOnce\
    \ you've broken it down, it's easy to see how this can be used to make a histogram\
    \ of the number of times a character occurs, by looping over the array and incrementing\
    \ a counter for every occurrence of any character that doesn't already have a\
    \ counter.\nThe simplest way to do this in a simple and straightforward way is\
    \ with a foreach loop:\n<code>\n$histogram = array();\nforeach (str_split($test)\
    \ as $letter)\n{\n    if (!array_key_exists($letter, $histogram))\n    {\n   \
    \     $histogram[$letter] = 1;\n    }\n    else\n    {\n        $histogram[$letter]++;\n\
    \    }\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nA little bit of array_count_values\
    \ will do the trick:\n<code>\n$a = str_split($test);\n\n$result = array_count_values($a);\n\
    </code>\n<|/ a tags=php,counting,arrays |>\n<| a tags=php,counting,arrays dscore=1\
    \ |>\nYou can do this with just one foreach loop:\n<code>\n$histogram = array();\n\
    foreach (str_split($test) as $letter) {\n    if (!array_key_exists($letter, $histogram))\
    \ {\n        $histogram[$letter] = 1;\n    } else {\n        $histogram[$letter]\
    \ += 1;\n    }\n}\n</code>\n<|/ a |>\n<| a tags=php,counting,arrays |>\n<code>\n\
    $test = \"aa bb cc\";\n\n$array = str_split($test);\n$counts = array_count_values($array);\n\
    </code>\n<|/ a dscore=0 |>\n<| a tags=php,counting,arrays |>\nThe solution for\
    \ you is very simple, just count the amount of each letter in the $test string\
    \ with str_split and array_count_values. \n<code>\n$test = 'aa bb cc dd ee ff';\n\
    $test = str_split($test);\n\n$counts = array_count_values($test", "  $histogram\
    \ = array();\n\n  if ($test) {\n    foreach (preg_split('/\\s+/', $test) as $letter)\
    \ {\n      if (array_key_exists($letter, $histogram)) {\n        $histogram[$letter]\
    \ += 1;\n      } else {\n        $histogram[$letter] = 1;\n      }\n    }\n  }\n\
    \  return $histogram;\n}\n</code>\n<|/ a dscore=0 tags=php |>\n<| c |>\nBut this\
    \ doesn't get the letter with the most occurrence from each group.\n<|/ c |>\n\
    <| c |>\nBut it gives you the letter with the most occurrence from each group.\
    \ Just count the occurrence of each letter in the string.\n<|/ c |>\n<| c |>\n\
    I thought OP wants the letter with the highest occurrence from each group.\n<|/\
    \ c |>\n<| c |>\nSo the highest occurrence of each letter from each group. Just\
    \ count the occurrence of each letter in the string.\n<|/ c |>\n<| c |>\nSorry\
    \ my bad.\n<|/ c |>\n<| a tags=php |>\nSo this doesn't really solve your problem\
    \ but it's a way to approach the problem. I don't know if this is what you had\
    \ in mind though.\nThe first step is to explode the string into an array. The\
    \ second step is to loop through each letter and see what letters are in each\
    \ group and store that in a multidimensional array. This multidimensional array\
    \ is then looped through and used to filter the letters from the main string that\
    \ haven't been counted yet.\n<code>\n<?php\n$string = \"a b a a a b a a a a b\
    \ a b c a b a\";\n$exploded = explode(\" \", $string);\n\n$letters = array();\n\
    foreach($exploded as $letter){\n  $letters[$letter] = array();\n}\n\n$letterCounts\
    \ = array();\nforeach($exploded as $letter){\n  $letterCounts[$letter][] = $letter;\n\
    }\n\nforeach($letterCounts as $letter => $group){\n  foreach($group as $groupLetter){\n\
    \    if(!isset($letters[$groupLetter])){\n      $letters[$groupLetter] = array();\n\
    \    }\n    if(!isset($letters[$groupLetter][$letter])){\n      $letters[$groupLetter][$letter]\
    \ = 0;\n    }\n    $letters[$groupLetter][$letter]++;\n  }\n}\n\n$filtered = array();\n\
    foreach($exploded as $letter){\n  if(!isset($letters[$letter])){\n    $filtered[]\
    \ = $letter;\n", "  return preg_match_all('~([a-z]+)\\s(\\d+)~i', $test, $matches)\
    \ ?\n         array_combine($matches[1], $matches[2]) :\n         array();\n}\n",
  "    if (empty($test)) {\n        return array();\n    }\n    $counts = array();\n\
    \    $max = 0;\n    $lastChar = null;\n    foreach (str_split($test) as $char)\
    \ {\n        $char = strtolower($char);\n        if (isset($counts[$char])) {\n\
    \            $counts[$char] += 1;\n        } else {\n            $counts[$char]\
    \ = 1;\n        }\n        if ($counts[$char] > $max) {\n            $max = $counts[$char];\n\
    \            $lastChar = $char;\n        }\n    }\n    return array($lastChar\
    \ => $max);\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nI realize this doesn't\
    \ answer your question directly, but it's worth mentioning that the problem you\
    \ are solving is commonly solved using a Bag data structure. See Wikipedia for\
    \ info on Bags.\n<|/ a tags=php,string |>\n<| c |>\nThank you, that may be a better\
    \ solution, but I already have a working function which I wanted to optimize.\n\
    <|/ c |>\n<| a |>\nJust a suggestion, if you have a lot of data you could try\
    \ using SQLite.\nhttp://php.net/manual/en/book.sqlite.php\nYou could store your\
    \ data in a table and use a query like below to get the count of each distinct\
    \ word.\n<code>\nselect word, count(*) from table group by word\n</code>\n<|/\
    \ a dscore=0 tags=php,string |>\n<| a tags=php,string |>\n<code>\n<?php\n    $test\
    \ = 'hello hello hi';\n    $test = preg_replace('/\\s+/', ' ', $test);\n    $words\
    \ = explode(' ', $test);\n    $count = array();\n    foreach ($words as $word)\
    \ {\n        if (array_key_exists($word, $count)) {\n            $count[$word]++;\n\
    \        } else {\n            $count[$word] = 1;\n        }\n    }\n    print_r($count);",
  "    $counts = array();\n    $i = 0;\n    foreach (str_split($test) as $letter)\
    \ {\n        $counts[$letter] = isset($counts[$letter]) ? $counts[$letter] + 1\
    \ : 1;\n        $i++;\n    }\n    arsort($counts);\n    $result = [];\n    $max_freq\
    \ = isset($counts[0]) ? $counts[0] : 0;\n    foreach ($counts as $letter => $freq)\
    \ {\n        if ($freq == $max_freq) {\n            $result[$letter] = 1;\n  \
    \      } else {\n            $result[$letter] = $freq;\n        }\n    }\n   \
    \ return $result;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nYou just re-implemented\
    \ the builtin `array_count_values` function :-)\n<|/ c |>\n<| c |>\nYep, I just\
    \ spend a lot of time on this. :-)\n<|/ c |>\n<| c |>\nThis is still not the best\
    \ way to do it\n<|/ c |>\n<| c |>\nWell, actually, it's not. At least, my implementation\
    \ is not as efficient as builtin one. So I guess this one should be the best answer,\
    \ isn't it?\n<|/ c |>\n<| c |>\nYou are right, this one is better.\n<|/ c |>\n\
    <| a tags=php,arrays |>\n<code>", "  $chars = str_split($test);\n  $histogram\
    \ = array();\n  foreach ($chars as $char) {\n    if (isset($histogram[$char]))\
    \ {\n      $histogram[$char]++;\n    } else {\n      $histogram[$char] = 1;\n\
    \    }\n  }\n  arsort($histogram);\n  return $histogram;\n}\n", "\t$letters =\
    \ array_count_values(str_split($test));\n\tarsort($letters);\n\t$letters = array_keys($letters);\n\
    \treturn $letters;\n}\n", "  preg_match_all(\"/(\\w)/\", $test, $matches);\n \
    \ arsort($matches[0]);\n\n  $words = array_count_values($matches[0]);\n\n  $letters\
    \ = array();\n  foreach($words as $letter => $count) {\n    $letters[$letter]\
    \ = $count;\n  }\n\n  return $letters;\n}\n</code>\nIf you want this sorted by\
    \ alphabetical order or count descending, just change the arsort() in the function\
    \ to sort() or rsort().\n<|/ a dscore=1 |>\n<| a |>\nI believe this solution will\
    \ be the most efficient. Just sort with PHP's native function.\n<code>", "  $result\
    \ = array();\n  $words = explode(' ', $test);\n  foreach ($words as $word) {\n\
    \    foreach ($words as $w) {\n      if ($word !== $w && !empty($word) && $w !==\
    \ $word &&\n          mb_strlen($word) === mb_strlen($w)) {\n        $result[$w]++;\n\
    \      }\n    }\n  }\n  asort($result);\n  return $result;\n}", "\t$letters =\
    \ str_split($test);\n\t$counts = array_count_values($letters);\n\t$letters_with_count\
    \ = array();\n\tforeach ($counts as $letter => $count) {\n\t\t$letters_with_count[$letter]\
    \ = $count;\n\t}\n\t$letters_with_count = array_merge(array(\"\"), $letters_with_count);\n\
    \n\tarsort($letters_with_count);\n\t$letters_with_count = array_pop($letters_with_count);\n\
    \treturn $letters_with_count;\n}\n", "  $chars = array_count_values(str_split($test));\n\
    \  $max = 0;\n  $maxChar = \"\";\n  foreach ($chars as $char => $count) {\n  \
    \  if ($count > $max) {\n      $max = $count;\n      $maxChar = $char;\n    }\n\
    \  }\n  return array($maxChar => $max);\n}\n", "  if (empty($test)) {\n    return\
    \ array();\n  }\n\n  $letters = explode(' ', $test);\n  $letters_occurrences =\
    \ array();\n  $max_occurrences = array();\n  $letters_with_max_occurrences = array();\n\
    \n  foreach ($letters as $letter) {\n    if (empty($letter)) {\n      continue;\n\
    \    }\n    if (isset($letters_occurrences[$letter])) {\n      $letters_occurrences[$letter]++;\n\
    \      if (isset($max_occurrences[$letter])) {\n        $max_occurrences[$letter]\
    \ = max($max_occurrences[$letter], $letters_occurrences[$letter]);\n      } else\
    \ {\n        $max_occurrences[$letter] = $letters_occurrences[$letter];\n    \
    \  }\n    } else {\n      $letters_occurrences[$letter] = 1;\n      if (isset($max_occurrences[$letter]))\
    \ {\n        $max_occurrences[$letter] = max($max_occurrences[$letter], 1);\n\
    \      } else {\n        $max_occurrences[$letter] = 1;\n      }\n    }\n  }\n\
    \n  foreach ($max_occurrences as $letter => $occurrence) {\n    if ($occurrence\
    \ > 1) {\n      $letters_with_max_occurrences[$letter] = $occurrence;\n    }\n\
    \  }\n\n  return $letters_with_max_occurrences;\n}\n</code>\n<|/ a tags=arrays,php,histogram\
    \ |>\n<| c |>\n`histogram(\"a b b c a b\")` would return `array(\"a\" => 2, \"\
    b\" => 2)` instead of `array(\"a\" => 1, \"b\" => 4)`.\n<|/ c |>\n<| c |>\nyes\
    \ i agree but i think he can easily handle that\n<|/ c |>\n<| c |>\nNope, `histogram(\"\
    a b b c a b\")` would still return `array(\"a\" => 2, \"b\" => 2)` instead of\
    \ `array(\"a\" => 1, \"b\" => 4)`. :-)\n<|/ c |>\n<| a dscore=0 tags=arrays,php,histogram\
    \ |>\n<code>\n<?php\n", "    $hist = array();\n    $letters = str_split($test);\n\
    \    foreach ($letters as $letter) {\n        if (isset($hist[$letter])) {\n \
    \           $hist[$letter]++;\n        } else {\n            $hist[$letter] =\
    \ 1;\n        }\n    }\n    return $hist;\n}\n", "  $letters = preg_split('/\\\
    s+/', $test);\n  $histogram = array();\n  foreach ($letters as $letter) {\n  \
    \  $histogram[$letter] = (isset($histogram[$letter]) ? $histogram[$letter]+1 :\
    \ 1);\n  }\n  return $histogram;\n}\n", "  $result = array();\n  $letters = explode(\"\
    \ \", strtolower($test));\n  $letters = array_count_values($letters);\n  arsort($letters);\n\
    \n  // Add in the first letter if we know there are at least 3 letters.\n  if\
    \ (sizeof($letters) >= 3) {\n    $result[$letters[0]] = $letters[0];\n  }\n\n\
    \  foreach ($letters as $letter => $count) {\n    // Add in the next letter if\
    \ the count is the same as the last.\n    if ($letter != end($letters)) {\n  \
    \    $result[$letter] = $letter;\n    }\n  }\n\n  return $result;\n}\n</code>\n\
    <|/ a dscore=5 tags=arrays,php,duplicate-removal |>\n<| c |>\n`array_count_values`\
    \ was introduced in PHP 5.5\n<|/ c |>\n<| c |>\nIt was introduced in 5.5, not\
    \ 5.4\n<|/ c |>\n<| c |>\nAh ok i see now, i got it wrong, i thought it was introduced\
    \ in 5.3 but i was talking about the version of php 5.4 i was using lol\n<|/ c\
    \ |>\n<| a |>\nThis question is already answered but I would like to add two more\
    \ methods to remove duplicates in an array:\n<code>\n$arr = array_unique(array_merge($arr));\n\
    </code>\nor\n<code>\n$arr = array_values(array_unique(array_merge($arr)));\n</code>\n\
    The first removes duplicates and the second reindexes the array. \nThe array_merge()\
    \ function will preserve the keys of the original array.\n<|/ a dscore=5 tags=arrays,php,duplicate-removal\
    \ |>\n<| c |>\narray_unique is also good to know that it will remove duplicate\
    \ key values as well.\n<|/ c |>\n<| c |>\nWhat if I need to preserve keys?\n<|/\
    \ c |>\n<| c |>\nthen you need to use a foreach loop, where you check each element\
    \ against all the rest of the elements in the array using a `in_array()` function\
    \ to check if it exists or not\n<|/ c |>\n<| a dscore=4 |>\nI always used the\
    \ following code:\n<code>\n$array=array_unique($array);\n</code>\n<|/ a tags=arrays,php,duplicate-removal\
    \ |>\n<| a dscore=4 |>\n<code>\narray_unique( array(1, 2, 3, 4, 5) );\n</code>\n\
    gives\n<code>\nArray\n(\n    [1] => 2\n    [2] => 3\n    [3] => 4\n    [5] =>\
    \ 5\n)\n</code>\n<|/ a tags=arrays,php", "    $letters = array_count_values(str_split(strtolower($test)));\n\
    \    arsort($letters);\n    $result = array();\n    foreach ($letters as $letter\
    \ => $count) {\n        $result[$letter] = $count;\n    }\n    return $result;\n\
    }\n", "  $result = array();\n  $words = explode(' ', $test);\n  foreach ($words\
    \ as $word) {\n    if (!isset($result[$word])) {\n      $result[$word] = 1;\n\
    \    } else {\n      $result[$word]++;\n    }\n  }\n  return $result;\n}\n", " \
    \ foreach (preg_split('/\\s+/', $test) as $letter => $count) {\n    $histogram[$letter]\
    \ = (isset($histogram[$letter]) ? $histogram[$letter] + $count : $count);\n  }\n\
    \n  arsort($histogram);\n  $result = array();\n  foreach ($histogram as $letter\
    \ => $count) {\n    $result[$letter] = $count;\n  }\n  return $result;\n}\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\n`preg_split() expects parameter 2 to be string, array\
    \ given` when I try to run it\n<|/ c |>\n<| c |>\nOh, I forgot to add `''` at\
    \ the end. Fixed now.\n<|/ c |>\n<| a dscore=2 |>\n<code>\n$string = \"a b a c\"\
    ;\n$count = array();\n$words = explode(\" \", $string);\n\nforeach($words as $word){\n\
    \    if(isset($count[$word]))\n        $count[$word]++;\n    else\n        $count[$word]\
    \ = 1;\n}\n\narsort($count);\n$count = array_keys($count);\n\nvar_dump($count);\n\
    </code>\nThis will output:\n<code>\narray(4) {\n  [0] =>\n  string(1) \"a\"\n\
    \  [1] =>\n  string(1) \"b\"\n  [2] =>\n  string(1) \"c\"\n  [3] =>\n  string(1)\
    \ \"a\"\n}\n</code>\n<|/ a tags=arrays,php,sorting |>\n<| a dscore=1 |>\n<code>\n\
    <?php\n$word = \"a b c a b b a\";\n$words = explode(\" \", $word);\n$counts =\
    \ array();\nforeach ($words as $word) {\n    $counts[$word] = isset($counts[$word])\
    \ ? $counts[$word] + 1 : 0;\n}\narsort($counts);\n$result = array_keys($counts);\n\
    var_dump($result);", "    $letters = array_count_values(str_split($test));\n\n\
    \    $letterList = array();\n    foreach($letters as $letter => $occurrence) {\n\
    \        if ($occurrence > 1) {\n            $letterList[$letter] = $occurrence;\n\
    \        }\n    }\n    return $letterList;\n}\n</code>\n<|/ a dscore=4 tags=php,arrays,count\
    \ |>\n<| a tags=php,arrays,count |>\nI love array_count_values and array_reduce:\n\
    <code>", "  $histogram = array();\n  $tokens = explode(\" \", $test);\n  foreach\
    \ ($tokens as $token) {\n    if (isset($histogram[$token])) {\n      $histogram[$token]++;\n\
    \    }\n    else {\n      $histogram[$token] = 1;\n    }\n  }\n  arsort($histogram);\n\
    \  return $histogram;\n}\n", "  $histogram = array();\n  $letters = str_split($test);\n\
    \  foreach ($letters as $letter) {\n    if (isset($histogram[$letter])) {\n  \
    \    $histogram[$letter]++;\n    } else {\n      $histogram[$letter] = 1;\n  \
    \  }\n  }\n  return $histogram;\n}\n</code>\n<|/ a tags=algorithm,php,sorting\
    \ dscore=3 |>\n<| c |>\n+1. Though I used `array_count_values` instead, which\
    \ gives me an associative array instead of an indexed one, and allows me to just\
    \ do `return max($histogram, function($key, $values) { return $values;});` to\
    \ get the letter/value with the most occurrences.\n<|/ c |>\n<| c |>\nYes, but\
    \ array_count_values isn't as memory efficient. Of course, you could also do:\
    \ if ($histogram[$letter] > $histogram[$letter-1]) { $histogram[$letter] = $histogram[$letter-1];\
    \ }. :)\n<|/ c |>\n<| c |>\nTrue, but `array_count_values` is less confusing to\
    \ people who have used it before; it's a function that does exactly what OP wants.\n\
    <|/ c |>\n<| a tags=algorithm,php,sorting |>\nIf you're interested in PHP < 5.5,\
    \ here's a PHP class that can handle this for you. \nhttp://github.com/drewm/counter\n\
    <|/ a dscore=3 |>\n<| c |>\nThis is a great answer, but it would be nice if it\
    \ included a sample implementation.\n<|/ c |>\n<| a |>\nHere's a pure PHP version\
    \ of Chris Haas' answer.\n<code>\n<?php\n/**\n * A class to hold a histogram and\
    \ statistics about it.\n *\n * Chris Haas\n */\nclass Histogram\n{\n    const\
    \ MIN_DIGITS = 2;\n\n    /**\n     * Array containing frequencies of all letters.\n\
    \     *\n     * array\n     */\n    protected $letterHistogram;\n\n    /**\n \
    \    * Array containing the letters and the frequencies.\n     *\n     * array\n\
    \     */\n    protected $letterHistograms;\n\n    /**\n     * Array containing\
    \ frequencies of all digits.\n     *\n     * array\n     */\n    protected $digitHistogram;\n\
    \n    /**\n     * Array containing the letters and the frequencies.\n     *\n\
    \     * array\n     */\n    protected $digitHistograms;\n\n    /**\n     * Creates\
    \ a new histogram with the given initial data.\n     *\n     * array $data\n \
    \    */\n    public function __construct(array $data)\n    {\n        // Prepare\
    \ the histogram data.\n        $this->letterHistogram = array();\n        $this->letterHistograms\
    \ = array();", "  $occurrences = array();\n  foreach (str_split($test) as $letter)\
    \ {\n    $occurrences[$letter] = isset($occurrences[$letter]) ? $occurrences[$letter]\
    \ + 1 : 1;\n  }\n  arsort($occurrences);\n  return $occurrences;\n}\n", "  $histogram\
    \ = array();\n  $matches = array();\n  foreach (str_split($test) as $char) {\n\
    \    $histogram[$char] = isset($histogram[$char]) ? $histogram[$char] + 1 : 1;\n\
    \  }\n\n  arsort($histogram);\n  foreach ($histogram as $char => $count) {\n \
    \   if ($matches[$char] !== null) {\n      $matches[$char] = ($matches[$char]\
    \ * $count) + ($matches[$char - 1] * ($count - 1));\n    } else {\n      $matches[$char]\
    \ = $count;\n    }\n  }\n\n  return $matches;\n}\n</code>\n<|/ a |>\n<| a |>\n\
    This PHP program will return the counts of each character in a string.\n<code>\n\
    $str=\"Hello World\";\n$chars=array();\n$i=0;\nforeach($str as $val)\n{\n  if(!isset($chars[$val]))\n\
    \    $chars[$val]=0;\n  $chars[$val]+=1;\n}\narsort($chars);\nprint_r($chars);\n\
    </code>\n<|/ a dscore=0 tags=php,character,count,histogram |>\n<| a tags=php,character,count,histogram\
    \ |>\nThis solution uses array_count_values and array_multisort to get the letters\
    \ as keys and counts as values.\n<code>\n$string = \"a a a b c c c c c c c d d\
    \ d d d d d d d d d d d d d e e e e e e e e e e e e e e e e e e e e e e e e e\
    \ e e f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f\
    \ f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f\
    \ f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f\
    \ f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f\
    \ f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f\
    \ f f f f ", "\t$test = preg_replace('/[^a-z]+/', '', $test);\n\n\t$counts = array();\n\
    \tforeach (preg_split('/ /', $test) as $letter) {\n\t\tif (!isset($counts[$letter]))\
    \ {\n\t\t\t$counts[$letter] = 1;\n\t\t} else {\n\t\t\t$counts[$letter]++;\n\t\t\
    }\n\t}\n\n\tksort($counts);\n\n\t$result = [];\n\tforeach ($counts as $letter\
    \ => $count) {\n\t\t$result[$letter] = $count;\n\t}\n\n\treturn $result;\n}\n",
  "  $test = explode(\" \", $test);\n  $result = array();\n  for ($i = 0, $len = count($test);\
    \ $i < $len; ++$i) {\n    $result[$test[$i]] = $test[$i] == $test[$i] ? 1 : $result[$test[$i]]\
    \ + 1;\n  }\n  arsort($result);\n  return array_pop($result);\n}\n", "  $histogram\
    \ = array();\n  $values = array_count_values(str_split($test));\n  foreach ($values\
    \ as $letter => $count) {\n    $histogram[$letter] = $count;\n  }\n\n  return\
    \ $histogram;\n}\n</code>\n<|/ a tags=php,histogram,arrays |>\n<| a tags=php,histogram,arrays\
    \ |>\nIf you can use arrays as values, you can also use array_count_values, it\
    \ does exactly that with only 1 loop\n<|/ a dscore=2 |>\n<| a tags=php,histogram,arrays\
    \ dscore=1 |>\nAnother approach could be using some kind of sorting algorithm,\
    \ which I believe would be faster than a brute-force loop that searches all possible\
    \ permutations.\nThe algorithm would be a merge sort on the string. Merge sort\
    \ works by splitting the array in two pieces, one smaller than the other one.\
    \ The algorithm searches both pieces of the array, and if the left piece is bigger\
    \ than the right piece (as is the case here), it recursively merges the left piece\
    \ with the right piece and continues until both arrays are empty.\nIn a normal\
    \ merge sort implementation, the number of comparisons needed is equal to the\
    \ size of the input array divided by 2, but in the case of strings this should\
    \ be faster, so I used this in my implementation.\nHere is the code:\n<code>",
  "  $histogram = array();\n  $frequency = array();\n  $words = explode(' ', $test);\n\
    \  foreach ($words as $word) {\n    if (empty($word)) continue;\n    $letter =\
    \ strtolower($word);\n    if (isset($frequency[$letter])) {\n      $frequency[$letter]++;\n\
    \    } else {\n      $frequency[$letter] = 1;\n    }\n  }\n  foreach ($frequency\
    \ as $letter => $count) {\n    $histogram[$letter] = $count;\n  }\n  arsort($histogram);\n\
    \  return $histogram;\n}", "\t$result = array();\n\t$counter = array();\n\t$letters\
    \ = explode(\" \", strtolower($test));\n\tforeach($letters as $letter) {\n\t\t\
    $counter[$letter] = isset($counter[$letter]) ? $counter[$letter] + 1 : 1;\n\t\t\
    $result[$letter] = isset($result[$letter]) ? $result[$letter] > $counter[$letter]\
    \ ? $result[$letter] : $counter[$letter] : 1;\n\t}\n\treturn $result;\n}\n", " \
    \   if (empty($test)) return array();\n    $counts = array();\n    foreach (explode(\"\
    \ \", $test) as $letter) {\n        if (!array_key_exists($letter, $counts)) $counts[$letter]\
    \ = 0;\n        $counts[$letter]++;\n    }\n    return $counts;\n}\n", "    //\
    \ Split the string into an array and trim whitespace.\n    $input = trim(explode(\"\
    \ \", $test));\n\n    // Sort the array (letters first) and remember the letter\
    \ with the most\n    // repetition in $letter. Initialize $count to zero.\n  \
    \  arsort($input);\n    $letter = array_pop($input);\n    $count = 0;\n\n    //\
    \ Loop through the array counting the number of occurrences of each letter\n \
    \   // and update $count if the letter with the most repetition is found. If\n\
    \    // several letters have the same occurrence, return all of them.\n    foreach\
    \ ($input as $letter) {\n        if (isset($counts[$letter])) {\n            $counts[$letter]++;\n\
    \        } else {\n            $counts[$letter] = 1;\n        }\n        if ($counts[$letter]\
    \ > $count) {\n            $count = $counts[$letter];\n        }\n    }\n\n  \
    \  return $counts;\n}", "  $hist = array();\n  // Separate string into array of\
    \ words\n  $words = explode(' ', $test);\n  // Make an array of words\n  foreach\
    \ ($words as $w) {\n    // Check if word is already in array of words\n    if\
    \ (!array_key_exists($w, $hist)) {\n      // If not, add it to the array\n   \
    \   $hist[$w] = 0;\n    }\n    // Increment the word count\n    $hist[$w] += 1;\n\
    \  }\n  // Sort the array\n  arsort($hist);\n  return $hist;\n}\n", "  $counts\
    \ = array();\n  $letters = array();\n  foreach (str_split($test) as $letter) {\n\
    \    $counts[$letter]++;\n    $letters[$letter]++;\n  }\n\n  $max = 0;\n  foreach\
    \ ($counts as $letter => $count) {\n    if ($count > $max) {\n      $max = $count;\n\
    \    }\n  }\n\n  return array_intersect_key($counts, $letters);\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nIt's pretty much the same answer, but you didn't put\
    \ an explanation. How does it solve the problem? Why is it better than the OP's\
    \ solution?\n<|/ c |>\n<| a dscore=1 |>\nI would use array_count_values() to achieve\
    \ that. \n<code>\n$mystring=\"a a a b c c c c c c c\";\n$array=array_count_values($mystring);\n\
    $result=array();\nforeach($array as $letter=>$count){\n    foreach($array as $letter2=>$count2){\n\
    \        if($letter==$letter2)\n        {\n            $result[$letter2]=$count2;\n\
    \            break;\n        }\n    }\n}\nprint_r($result);\n</code>\n<|/ a tags=php,count,arrays\
    \ |>\n<| a dscore=1 |>\nThis is probably not the best solution but still a solution.\
    \ Maybe some of you PHP pros could optimize it further.\n<code>", "  $histo =\
    \ array();\n  foreach (preg_split('/ /', $test) as $letter) {\n    if (isset($histo[$letter]))\
    \ {\n      $histo[$letter]++;\n    } else {\n      $histo[$letter] = 1;\n    }\n\
    \  }\n  return $histo;\n}\n", "  $histogram = array();\n  if ($test == \"\") {\n\
    \    return $histogram;\n  }\n  $histogram = str_split($test);\n  foreach ($histogram\
    \ as $letter) {\n    $histogram[$letter] = 0;\n  }\n  foreach ($histogram as $letter\
    \ => $repetition) {\n    foreach ($histogram as $letter2 => $repetition2) {\n\
    \      if ($letter != $letter2) {\n        if ($repetition > $repetition2) {\n\
    \          unset($histogram[$letter]);\n          $histogram[$letter2] = $repetition;\n\
    \          break;\n        } else {\n          unset($histogram[$letter2]);\n\
    \          $histogram[$letter] = $repetition;\n          break;\n        }\n \
    \     }\n    }\n  }\n  return $histogram;\n}\n", "  $array = array_count_values(str_split($test));\n\
    \  arsort($array);\n  return $array;\n}\n", "    $freq = array();\n    $tokens\
    \ = preg_split('/\\s/', $test);\n    foreach($tokens as $token) {\n        $freq[$token]\
    \ = isset($freq[$token]) ? $freq[$token] + 1 : 1;\n    }\n\n    arsort($freq);\n\
    \    return array_slice($freq, 0, 1);\n}\n", "  $letters = preg_split('/[\\s]+/',\
    \ $test);\n  $histogram = array();\n  foreach ($letters as $letter) {\n    $histogram[$letter]\
    \ = count($letters);\n  }\n  asort($histogram);\n  return $histogram;\n}\n", " \
    \ $letters = array_count_values(str_split($test));\n  $result = [];\n  foreach($letters\
    \ as $letter => $count) {\n    if($count > 1) {\n      $result[$letter] = $count;\n\
    \    }\n  }\n  return $result;\n}\n</code>\n<|/ a tags=functional-programming,arrays,php,array-map\
    \ |>\n<| c |>\nthis doesn't work if the array has repeated letters more than once,\
    \ for example: histogram(\"a a b c\")\n<|/ c |>\n<| c |>\nThat doesn't make any\
    \ sense, since you said you wanted it sorted by the most occurrences. Anyway,\
    \ just change the `array_count_values` call to `array_count_values(array_unique($test));`\n\
    <|/ c |>\n<| c |>\nThis is not what the OP wants. \"If several letters have the\
    \ same occurrence, return all of them.\" this does not mean you want all letters\
    \ sorted by how many occurrences they have, only the letter with the highest amount\
    \ of occurrences.\n<|/ c |>\n<| a |>\nHow about this?\n<code>\n$array = explode('\
    \ ', $string);\n$letters = array_count_values($array);\n$letter = array_keys($letters,\
    \ max($letters));\n</code>\n<|/ a dscore=3 tags=functional-programming,arrays,php,array-map\
    \ |>\n<| c |>\nThis doesn't work if the array has repeated letters more than once,\
    \ for example: histogram(\"a a b c\")\n<|/ c |>\n<| c |>\nThat was exactly my\
    \ problem.\n<|/ c |>\n<| a dscore=3 |>\n<code>\n$words = explode(' ', $string);\n\
    $counts = array_count_values($words);\narsort($counts);\n$key = array_slice($counts,\
    \ 0, 1);\n</code>\n<|/ a tags=functional-programming,arrays,php,array-map |>\n\
    <| a |>\n<code>\n$words = explode(' ', $string);\n$counts = array_count_values($words);\n\
    arsort($counts);\n$key = array_keys($counts, max($counts));\n</code>\n<|/ a dscore=2\
    \ tags=functional-programming,arrays,php,array-map |>\n<| c |>\nI believe this\
    \ is incorrect because it only looks at the highest value in the first key. Try\
    \ it out by changing the value of `$string` to `\"abc def\"`\n<|/ c |>\n<| c |>\n\
    The `arsort()` call is not needed.\n<|/ c |>\n<| a dscore=2 tags=function", " \
    \ return str_ireplace(\n    \" \",\n    \" \",\n    explode(\n      \"\\n\",\n\
    \      preg_replace(\n        \"([a-z])\\s+([a-z])\",\n        \"$1 $2\",\n  \
    \      array_count_values(str_ireplace(\"\\n\", \" \", $test))\n      )\n    )\n\
    \  );\n}\n", "  if (!$test) return array();\n  $counts = array();\n  for ($letter\
    \ = 0; $letter < strlen($test); $letter++) {\n    if (!isset($counts[$test[$letter]]))\
    \ $counts[$test[$letter]] = 0;\n    $counts[$test[$letter]]++;\n  }\n  return\
    \ $counts;\n}\n", "    $result = array();\n    $letters = str_split($test);\n\
    \    foreach ($letters as $letter) {\n        if (!isset($result[$letter])) {\n\
    \            $result[$letter] = 0;\n        }\n        $result[$letter]++;\n \
    \   }\n    $mostRecentLetter = null;\n    $mostRecentCount = 0;\n    foreach ($result\
    \ as $letter => $count) {\n        if ($count == $mostRecentCount) {\n       \
    \     $mostRecentLetter = $letter;\n        }\n    }\n    if (!$mostRecentLetter)\
    \ {\n        return array();\n    }\n    return array($mostRecentLetter => $mostRecentCount);\n\
    }\n", "  $histogram = array();\n\n  // Split each letter in the string into a\
    \ separate entry.\n  // This gives us an array of arrays where each element contains\n\
    \  // a letter and a count. E.g., array(\"a\" => 1, \"b\" => 1, \"c\" => 1)\n\
    \  $letters = preg_split(\"/[\\s]/\", $test);\n  $letterCount = count($letters);\n\
    \n  // Count the number of times a letter appears in the string.\n  // If two\
    \ or more letters have the same count, we want to return all of them.\n  // We\
    \ do this by using a for loop and running through the letters array.\n  // A for\
    \ loop is like a more compact way of writing the code below.\n  for ($i = 0; $i\
    \ < $letterCount; $i++) {\n    $histogram[$letters[$i]] = isset($histogram[$letters[$i]])\
    \ ? $histogram[$letters[$i]] + 1 : 1;\n  }\n\n  return $histogram;\n}", "    //\
    \ Split the string into an array.\n    $arr = preg_split(\"/\\s+/\", $test);\n\
    \    // Count the occurrences of each letter in the array.\n    $histogram = array();\n\
    \    foreach ($arr as $letter) {\n        if (!isset($histogram[$letter])) {\n\
    \            $histogram[$letter] = 1;\n        } else {\n            $histogram[$letter]++;\n\
    \        }\n    }\n    // Return the letter with the most occurences.\n    $max\
    \ = 0;\n    $maxLetter = null;\n    foreach ($histogram as $letter => $occurrence)\
    \ {\n        if ($occurrence > $max) {\n            $max = $occurrence;\n    \
    \        $maxLetter = $letter;\n        }\n    }\n    return array($maxLetter\
    \ => $max);\n}\n</code>\n<|/ a tags=php |>\n<| a tags=php |>\nI used this to achieve\
    \ the same:\n<code>\n$string = 'A B C A B C';\n$explode = explode(\" \", $string);\n\
    $occurrence = array();\n\nforeach ($explode as $key => $value) {\n    $occurrence[$value]\
    \ = array_key_exists($value, $occurrence) ? $occurrence[$value]+1 : 1;\n}\narsort($occurrence);\n\
    foreach($occurrence as $letter=>$val)\n{\n    echo $letter.\":\".$val.\" \";\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis counts the occurrences of each letter\
    \ though, not the most frequent.\n<|/ c |>\n<| a tags=php |>\nIn case someone\
    \ is looking for an answer using lambdas in php:\n<code>\n<?php", "\t$hist = array();\n\
    \tforeach (str_split($test) as $letter) {\n\t\t$hist[$letter] = (isset($hist[$letter])\
    \ ? $hist[$letter] + 1 : 1);\n\t}\n\treturn $hist;\n}\n", "  $test = strtolower($test);\n\
    \  $counts = array_count_values(str_split($test));\n  arsort($counts);\n  $result\
    \ = array();\n  foreach ($counts as $letter => $count) {\n    $result[$letter]\
    \ = $count;\n  }\n  return $result;\n}\n", "    $occurrences = array_count_values(str_split($test));\n\
    \    $most_occurrence = current(array_keys($occurrences, max($occurrences)));\n\
    \    return $occurrences[$most_occurrence];\n}\n</code>\n<|/ a |>\n<| c |>\nThanks\
    \ so much. I will try this out and see what happens.\n<|/ c |>\n<| c |>\nSorry\
    \ I got interrupted and I didn't get time to test this. It worked beautifully.\n\
    <|/ c |>\n<| a tags=php,arrays,string,split,explode dscore=0 |>\nI tested this,\
    \ and it worked for me.\n<code>\n<?php\n$test = \"a a a a a\";\n\n$test = explode(\"\
    \ \", $test);\n\n$test_array = array_count_values($test);\n\n$most_frequent_value\
    \ = max($test_array);\n$most_frequent_value = $test_array[$most_frequent_value];\n\
    print_r($most_frequent_value);\n</code>\n<|/ a |>\n<| a tags=php,arrays,string,split,explode\
    \ |>\nTry this, It will work fine.\n<code>\n$str = \"a a b b c\";\n$arr=explode(\"\
    \ \",$str);\n\n$max_arr = max($arr);\n$max_arr_index = array_keys($arr, $max_arr);\n\
    \necho $max_arr[$max_arr_index[0]];\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>",
  "  $histogram = array();\n  $letters = preg_split('/\\s+/', $test);\n  foreach ($letters\
    \ as $letter) {\n    if (isset($histogram[$letter])) {\n      $histogram[$letter]++;\n\
    \    } else {\n      $histogram[$letter] = 1;\n    }\n  }\n  return $histogram;\n\
    }\n", "  $histogram = array();\n  foreach (str_split($test) as $letter) {\n  \
    \  if (!array_key_exists($letter, $histogram)) {\n      $histogram[$letter] =\
    \ 1;\n    } else {\n      $histogram[$letter] += 1;\n    }\n  }\n  return $histogram;\n\
    }\n", "    $histogram = array();\n    $test = (string)$test;\n    $letters = array_unique(str_split($test));\n\
    \    foreach ($letters as $letter) {\n        $count = count(str_split($test));\n\
    \        $histogram[$letter] = $count;\n    }\n    return $histogram;\n}\n", " \
    \ $histogram = array();\n  foreach (preg_split('/\\s/', $test) as $letter) {\n\
    \    if (isset($histogram[$letter])) {\n      $histogram[$letter]++;\n    } else\
    \ {\n      $histogram[$letter] = 1;\n    }\n  }\n  arsort($histogram);\n  $letters\
    \ = array_keys($histogram);\n  return $letters;\n}\n$histogram = histogram($_POST[\"\
    test\"]);", "    $histogram = array();\n    $letters = preg_split(\"/\\s+/\",\
    \ $test);\n    $len = count($letters);\n    for ($i = 0; $i < $len; $i++) {\n\
    \        if (isset($histogram[$letters[$i]]))\n            $histogram[$letters[$i]]\
    \ = $histogram[$letters[$i]] + 1;\n        else\n            $histogram[$letters[$i]]\
    \ = 1;\n    }\n    return $histogram;\n}\n", "    $letters = array_count_values(str_split($test));\n\
    \    arsort($letters);\n\n    // Find out the most repeated letter\n    $key =\
    \ reset($letters);\n    $count = count($letters);\n    if ($count == 1) {\n  \
    \      return array($key => 1);\n    }\n\n    // Sort by frequency\n    arsort($letters);\n\
    \n    // Return the most frequent letter\n    return array($key => $count);\n\
    }\n\n$result = histogram(\"a b c d a c c a c a a b c c a a b c c a a b c a b c\
    \ d e f a b\");\n\nvar_dump($result);\n</code>\n<|/ a tags=php,algorithm dscore=3\
    \ |>\n<| c |>\nthis works too but i think this is not an efficient algorithm for\
    \ big data\n<|/ c |>\n<| a |>\nHere's a way to do it using only PHP 5.3+.\n<code>\n\
    <?php\n", "  if (empty($test)) return array();\n  return array_count_values(str_split($test));\n\
    }\n</code>\nThis approach should be the most performant as you only have one pass\
    \ through the data.\n<|/ a dscore=1 tags=performance,php,arrays,sorting |>\n<|\
    \ a tags=performance,php,arrays,sorting |>\n<code>\n$array = array_count_values(str_split($string));\n\
    $result = array_flip($array);\nprint_r($result);\n</code>\n<|/ a dscore=1 |>\n\
    <| a dscore=1 tags=performance,php,arrays,sorting |>\n<code>\n$string = \"AABB\"\
    ;\n\n$array = str_split($string);\n$array = array_count_values($array);\nksort($array);\n\
    \nprint_r($array);\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>\n$string = \"\
    AABB\";\n\n$array = str_split($string);\n\n$arr = [];\nforeach($array as $k =>\
    \ $v){\n    $arr[$v]++;\n}\n\nksort($arr);\n\nvar_dump($arr);\n</code>\n<|/ a\
    \ tags=performance,php,arrays,sorting |>\n<| a dscore=0 |>\n<code>", "  $hist\
    \ = array();\n  $tokens = preg_split('/\\s+/', $test);\n  foreach ($tokens as\
    \ $token) {\n    if (! $token) {\n      continue;\n    }\n    $token = strtolower($token);\n\
    \    if (isset($hist[$token])) {\n      $hist[$token] += 1;\n    } else {\n  \
    \    $hist[$token] = 1;\n    }\n  }\n  return $hist;\n}\n", "  list( $counts,\
    \ $letters ) = $test =~ /\\s+/;\n  $letters      = explode( \" \", $letters );\n\
    \  $lettersCount = array_count_values( $letters );\n  $lettersCountMax = max($lettersCount);\n\
    \  $counts        = array_fill_keys( $letters, 0);\n  foreach ( $lettersCount\
    \ as $letter ) {\n    $counts[ $letter ]++;\n  }\n  unset($lettersCount);\n  return\
    \ array_map( function($letter) use ($counts) { return \"$letter => $counts[$letter]\"\
    ;}, $letters );\n}\n</code>\n<|/ a dscore=3 tags=php,arrays,count,multidimensional-array\
    \ |>\n<| c |>\nThis solution does assume that each word is separated by a single\
    \ space character.\n<|/ c |>\n<| a tags=php,arrays,count,multidimensional-array\
    \ dscore=3 |>\nI ran into this problem and here's what I found out:\n<code>\n\
    <?php\n$data = array(\"a\" => \"1\", \"b\" => \"2\");\n$data = array_count_values($data);\n\
    $data = array_flip($data);\n$data = array_intersect_key($data, $data);\nprint_r($data);",
  "  $histogram = array();\n  foreach (preg_split('/\\s+/', $test) as $letter) {\n\
    \    if (!isset($histogram[$letter])) {\n      $histogram[$letter] = 1;\n    }\n\
    \    else {\n      $histogram[$letter] = $histogram[$letter] + 1;\n    }\n  }\n\
    \  return $histogram;\n}\n", "  // Initialize a counter for letters with count\
    \ of 0.\n  $letters = array();\n  foreach (str_split($test) as $letter) {\n  \
    \  if (isset($letters[$letter])) {\n      $letters[$letter]++;\n    } else {\n\
    \      $letters[$letter] = 1;\n    }\n  }\n\n  // Go through all letters again,\
    \ adding them to the histogram\n  // only once if they appear more than once.\n\
    \  $result = array();\n  foreach ($letters as $letter => $count) {\n    if ($count\
    \ > 1) {\n      $result[$letter] = $count;\n    }\n  }\n\n  return $result;\n\
    }\n</code>\n<|/ a tags=php dscore=0 |>\n<| a |>\nThis is not the optimal solution\
    \ for your problem, but a solution for your problem to find out how much time\
    \ does it take for a machine to perform an operation on a single line of text.\n\
    <code>\n<?php\n\n$str = implode(' ', str_split('This is an example text to test\
    \ the execution time'));\n\n$start = new \\DateTime();\n\n$str = str_replace(array(\"\
    \\n\", \"\\r\"), '', $str);\n$str = trim($str);\n$str = preg_replace('/\\s+/',\
    \ '', $str);\n\nvar_dump($str);\n\n$end = new \\DateTime();\n\n$difference = $end->diff($start);\n\
    $time = $difference->format('%h:%i:%s');\n\necho $time;\n</code>\nThe above code\
    \ will output the time it took for the program to perform the operation on a single\
    \ line of text.\n<|/ a tags=php dscore=0 |>\n<| a dscore=0 tags=php |>\n<code>\n\
    <?php\n\n$input = \"My name is Ronald Wu and I like PHP\";\n\n$words = preg_split('/\\\
    s+/', $input);\n\n$word_counts = array_count_values($words);\n\nasort($word_counts);\n\
    \n$frequencies = array_keys($word_counts);\n\n$frequencies = array_reverse($frequencies);\n\
    \n$most_frequent_word = $frequencies[0];\n\necho \"The most frequent word is $most_frequent_word\
    \ and it's frequency is $word_counts[$most_frequent_word]\";\n", "  $letters =\
    \ preg_split('//u', $test);\n  $occurrence = array_count_values($letters);\n \
    \ arsort($occurrence);\n  $letters = array_keys($occurrence);\n  return $occurrence;\n\
    }\n", "\t$histogram = array();\n\tfor ($i = 0; $i < strlen($test); $i++) {\n\t\
    \t$histogram[strtolower($test[$i])] = isset($histogram[strtolower($test[$i])])\
    \ ? $histogram[strtolower($test[$i])] + 1 : 1;\n\t}\n\treturn $histogram;\n}",
  "  $counter = array();\n  $i = 0;\n  while (strlen($test)) {\n    $letter = substr($test,\
    \ i, 1);\n    $letter = strtolower($letter);\n    if (isset($counter[$letter]))\
    \ {\n      $counter[$letter]++;\n    } else {\n      $counter[$letter] = 1;\n\
    \    }\n    $i += 1;\n  }\n  arsort($counter);\n  $result = array();\n  $result[$counter[0]]\
    \ = 1;\n  foreach ($counter as $letter => $count) {\n    if ($count > $result[$letter])\
    \ {\n      $result[$letter] = $count;\n    }\n  }\n  return $result;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThat's what I was looking for! Thanks! :)\n<|/ c |>\n<| c |>\n\
    Yeah, I should have mentioned that in my question (I edited it now).\n<|/ c |>\n\
    <| c |>\nWhat happens if a string contains multiple 'a's?\n<|/ c |>\n<| c |>\n\
    Oops, that was my bad. I think I'm getting an inconsistent result now because\
    \ of the `return`. I'll need to figure that part out and get back to you. Thanks\
    \ for pointing that out.\n<|/ c |>\n<| c |>\nI added a new solution which seems\
    \ to work better.\n<|/ c |>\n<| a dscore=0 |>\nA simple loop can do it.\n<code>\n\
    $array = array(\"a\" => 1, \"b\" => 1, \"c\" => 1, \"d\" => 1, \"e\" => 1, \"\
    f\" => 1, \"g\" => 1, \"h\" => 1, \"i\" => 1, \"j\" => 1, \"k\" => 1, \"l\" =>\
    \ 1, \"m\" => 1, \"n\" => 1, \"o\" => 1, \"p\" => 1, \"q\" => 1, \"r\" => 1, \"\
    s\" => 1, \"t\" => 1, \"u\" => 1, \"v\" => 1, \"w\" => 1, \"x\" => 1, \"y\" =>\
    \ 1, \"z\" => 1);\n\n$result = array();\nforeach ($array as $key => $val) {\n\
    \    $result[$val] += 1;\n}\narsort($result);\n\n$count = count($result);\nfor\
    \ ($i = 0; $i < $count; $i++) {\n    $result[$i] = $result[$i] / $count;\n}\n\n\
    echo \"<pre>\";\nprint_r($result);\necho \"</pre>\";\n</code>\n<|/ a tags=php,algorithm\
    \ |>\n<| c |>\nCan you show me the code you're talking about?\n<|/ c |>\n<| c\
    \ |>\nI edited my answer. Now you can see the ", "  $hist = array();\n  $letters\
    \ = explode(' ', $test);\n  foreach ($letters as $letter) {\n    if (array_key_exists($letter,\
    \ $hist)) {\n      $hist[$letter]++;\n    } else {\n      $hist[$letter] = 1;\n\
    \    }\n  }\n  return $hist;\n}\n", "    $letters = array_count_values(str_split($test));\n\
    \    arsort($letters);\n    return array_slice($letters, 0, 1);\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\n+1 for readability. Why not `return array_slice(array_count_values(str_split($test)),\
    \ 0, 1);`? Or if you want to return the whole array: `return $letters;`.\n<|/\
    \ c |>\n<| a dscore=0 |>\nHere's an alternate solution, based on array_count_values\
    \ and sorting in descending order before returning the first value:\n<code>\n\
    <?php\n\n$string = 'abc';\n\n$counts = array_count_values(str_split($string));\n\
    arsort($counts);\necho $counts[0];\n</code>\nEdit: Thanks to for pointing out\
    \ that arsort can take a boolean.  I always forget about that.\n<|/ a tags=php,string\
    \ |>\n<| c |>\nThis also has the advantage of being more efficient than `array_count_values`,\
    \ since the latter will create a temporary array. Using `arsort` with a boolean\
    \ is redundant. Just use `arsort`.\n<|/ c |>\n<| a dscore=0 |>\nFor those that\
    \ don't like regex:\n<code>\n<?php\n\n$test = 'a a a b c a c c c c d';\n\npreg_match('/([a-z]+)/i',\
    \ $test, $matches);\n\nvar_dump($matches);\n\n$alphabets = $matches[0];\n$counts\
    \     = array_count_values($alphabets);\n\narsort($counts);\n\n$alphabet = array_keys($counts)[0];\n\
    \nvar_dump($alphabet);\n</code>\n<|/ a tags=php,string |>\n<| c |>\nThanks.  I\
    \ actually like my regex :)\n<|/ c |>\n<| c |>\nThe regex is overkill for something\
    \ like this.\n<|/ c |>\n<| c |>\nYeah, I noticed that the regex didn't account\
    \ for numbers or special characters - thanks for pointing that out.\n<|/ c |>\n\
    <| a dscore=0 |>\nHere's a way that doesn't use regex to grab letters from a string\
    \ and put them in an array:\n<code>\n$letters = array();\nfor($i = 0; $i<strlen($test);\
    \ $i++)\n{\n    switch(substr($test,$i,1))\n    {\n        case 'a':\n       \
    \ case 'b':\n        case 'c':\n            $letters[] = substr($test,$i,1);\n\
    \    }\n}\nsort($letters);\n</code>\nNow if you wanted the count of every letter, ",
  "    $letters = str_split($test);\n    $result = array();\n    foreach ($letters\
    \ as $letter) {\n        $letter = strtolower($letter);\n        if (isset($result[$letter]))\
    \ {\n            $result[$letter]++;\n        } else {\n            $result[$letter]\
    \ = 1;\n        }\n    }\n    return $result;\n}\n", "  if (!$test) return array();\n\
    \  $letters = str_split($test);\n  $frequencies = array_count_values($letters);\n\
    \  arsort($frequencies);\n  $max = $frequencies[0];\n  $result = array();\n  foreach\
    \ ($frequencies as $letter => $count) {\n    if ($count == $max) {\n      $result[$letter]\
    \ = $count;\n    }\n  }\n  return $result;\n}\n</code>\nThe code can be tested\
    \ here\n<|/ a tags=php,arrays,sorting |>\n<| a dscore=1 tags=php,arrays,sorting\
    \ |>\nI know this is a very old question, but I wanted to share my solution which\
    \ I came up with:\n<code>\n$letters = array('a', 'a', 'b', 'b', 'c', 'c', 'c',\
    \ 'a');\n$letters = array_count_values($letters);\n$sorted_letters = array();\n\
    arsort($letters);\nforeach ($letters as $letter => $count) {\n    $sorted_letters[$letter]\
    \ = $count;\n}\n</code>\nThis has the advantage of not needing to know the length\
    \ of the array to sort, and also works with string arrays of any length (as long\
    \ as you know the letter values).\n<|/ a |>\n<| a |>\nThis code can do the job\
    \ by sorting alphabetical and count the frequency of letters. \n<code>\n<?php\n",
  "    return array_count_values(str_split($test));\n}\n</code>\n<|/ a tags=php |>\n\
    <| c |>\nI think `str_split()` will convert `' '` to `''`. So if you pass empty\
    \ string you will get empty array.\n<|/ c |>\n<| c |>\n: Actually, it will. But\
    \ it is safer to always do that with `trim()`.\n<|/ c |>\n<| c |>\nIt will give\
    \ you array like `[\"a\"]=>1`, then you can iterate over this array and find max\
    \ value (which will be `a` in your case) and then use it in `array_search` to\
    \ get it's index. Or you can use `rsort` with count function and get key with\
    \ `key` function. This solution will be faster.\n<|/ c |>\n<| a dscore=3 |>\n\
    Here's a more general solution:\n<code>\n$string = \"hello there ho ho ho ho ho\
    \ ho\";\n$letters = str_split($string);\n\n$freqs = array();\nforeach ($letters\
    \ as $letter) {\n    if (isset($freqs[$letter])) {\n        $freqs[$letter]++;\n\
    \    } else {\n        $freqs[$letter] = 1;\n    }\n}\n\n$letter = \"h\";\n$frequency\
    \ = $freqs[$letter];\n\necho 'The most common letter is: ', $letter, '. The frequency\
    \ is: ', $frequency;\n</code>\n<|/ a tags=php |>\n<| a tags=php |>\nThis may help\n\
    <code>\n$test = \"aaa bbb\";\n$array = explode(\" \", $test);\n$letter = array_count_values($array);\n\
    $letter = array_filter($letter);\nprint_r($letter);\n</code>\n<|/ a dscore=2 |>\n\
    <| a tags=php |>\n<code>\n<?php", "  $letters = str_split($test);\n  $histo =\
    \ array();\n  $total = 0;\n  $letters_count = array();\n  foreach ($letters as\
    \ $letter) {\n    if (isset($histo[$letter])) {\n      $histo[$letter] += 1;\n\
    \      $total += 1;\n    }\n    else {\n      $histo[$letter] = 1;\n    }\n  \
    \  if (isset($letters_count[$letter])) {\n      $letters_count[$letter] += 1;\n\
    \    }\n    else {\n      $letters_count[$letter] = 1;\n    }\n  }\n  arsort($histo);\n\
    \  arsort($letters_count);\n  foreach ($letters_count as $letter => $count) {\n\
    \    if ($count == $total) {\n      $letters[$letter] = $letter;\n    }\n  }\n\
    \  return $letters;\n}\n", "  $frequencies = array();\n  // Split each letter\
    \ and count each one.\n  foreach (explode(' ', $test) as $letter) {\n    if (isset($frequencies[$letter]))\
    \ {\n      $frequencies[$letter]++;\n    } else {\n      $frequencies[$letter]\
    \ = 1;\n    }\n  }\n  // Sort from lowest to highest.\n  arsort($frequencies);\n\
    \  // Return the most frequent letters.\n  return array_flip($frequencies);\n\
    }\n", "  $histogram = array();\n  // explode() returns a space-separated array\
    \ with the individual elements of $test\n  // separated by spaces. Since we know\
    \ $test is a space-separated string, we can\n  // directly use explode() to parse\
    \ it.\n  // $array is then an array of all individual words in $test, with the\
    \ value 1 for\n  // each word. array_count_values() creates a $histogram array\
    \ with the following\n  // format:\n  // array(\n  //     // $array[0] contains\
    \ the first word\n  //     array(\"a\" => 1),\n  //     // $array[1] contains\
    \ the second word\n  //     array(\"b\" => 1),\n  //     // ...\n  //     array(\"\
    x\" => 1)\n  // );\n  $array = explode(\" \", $test);\n  $histogram = array_count_values($array);\n\
    \  // Return the most frequent element with the corresponding count\n  arsort($histogram);\n\
    \  return array_keys($histogram);\n}\n", "  $letters = array_count_values(str_split($test));\n\
    \  return $letters;\n}", "  $histogram = array();\n  $letters = str_split($test);\n\
    \  foreach ($letters as $letter) {\n    if (!isset($histogram[$letter])) {\n \
    \     $histogram[$letter] = 0;\n    }\n    $histogram[$letter]++;\n  }\n  return\
    \ $histogram;\n}\n", "  $histogram = array();\n  $testArray = explode(' ', $test);\n\
    \  foreach ($testArray as $letter) {\n    if (isset($histogram[$letter])) {\n\
    \      $histogram[$letter]++;\n    } else {\n      $histogram[$letter] = 1;\n\
    \    }\n  }\n  $result = array();\n  arsort($histogram);\n  foreach ($histogram\
    \ as $letter => $count) {\n    $result[] = array('letter' => $letter, 'count'\
    \ => $count);\n  }\n  return $result;\n}", "  $histogram = array();\n  $splitted\
    \ = explode(\" \", strtolower($test));\n  foreach($splitted as $letter) {\n  \
    \  if (!isset($histogram[$letter])) {\n      $histogram[$letter] = 1;\n    } else\
    \ {\n      $histogram[$letter]++;\n    }\n  }\n  return $histogram;\n}", "  $histo\
    \ = array();\n  foreach (explode(\" \", $test) as $c) {\n    if (!isset($histo[$c]))\
    \ {\n      $histo[$c] = 0;\n    }\n    $histo[$c]++;\n  }\n  arsort($histo);\n\
    \  return array_keys($histo);\n}\n", "  $frequencies = array();\n\n  // Split\
    \ the string into words delimited by a space or an end of line.\n  $words = preg_split('/(\\\
    s+|$)/', $test, -1, PREG_SPLIT_NO_EMPTY);\n  foreach ($words as $word) {\n   \
    \ // Get the count for the current word.\n    if (!array_key_exists($word, $frequencies))\
    \ {\n      $frequencies[$word] = 1;\n    } else {\n      $frequencies[$word]++;\n\
    \    }\n  }\n\n  // Return the array with the most common word and its number\
    \ of occurrences.\n  arsort($frequencies);\n  return $frequencies[0];\n}\n</code>\n\
    <|/ a dscore=2 tags=php,histogram,arrays,string |>\n<| c |>\n+1 for the most elegant\
    \ solution so far. However i believe a histogram is not the right word here, as\
    \ the words in the string are always just single letters. Probably a histogram\
    \ is more like *frequencies*\n<|/ c |>\n<| c |>\nYeah, i think in terms of counting\
    \ letters (and words) it would be correct to say it's a histogram. But as I said\
    \ it's quite unusual to talk about a histogram of letters. The OP has just asked\
    \ for the most common letters so my answer was exactly that.\n<|/ c |>\n<| a tags=php,histogram,arrays,string\
    \ |>\nYou can try this code:\n<code>\n<?php\n\n$text = 'a b c d e f';\n$array\
    \ = explode(' ', $text);\n$array = array_count_values($array);\n\n$max_count =\
    \ 0;\n$max_key = '';\n\nforeach($array as $key=>$count){\n    if($count > $max_count){\n\
    \        $max_count = $count;\n        $max_key = $key;\n    }\n}\n\necho \"$max_key\
    \ has $max_count occurrences.\";\n", "  $histo = array();\n  foreach(preg_split('/\
    \ /', $test) as $letter) {\n    $histo[$letter] = isset($histo[$letter]) ? $histo[$letter]\
    \ + 1 : 1;\n  }\n  return $histo;\n}\n", "  return array_count_values(str_split($test));\n\
    }\n", "  $chars = str_split($test);\n  $histogram = array();\n\n  foreach ($chars\
    \ as $char) {\n    $histogram[$char] = isset($histogram[$char]) ? $histogram[$char]\
    \ + 1 : 1;\n  }\n\n  return $histogram;\n}\n\n$chars = str_split(\"a b c\");\n\
    $histo = histogram($chars);\n", "  $letters = explode(\" \", $test);\n  $histogram\
    \ = array();\n  foreach ($letters as $letter) {\n    if (isset($histogram[$letter]))\
    \ {\n      $histogram[$letter]++;\n    }\n    else {\n      $histogram[$letter]\
    \ = 1;\n    }\n  }\n  return $histogram;\n}\n", "    $histogram = array();\n \
    \   $letters = str_split($test);\n    for ($i = 0; $i < count($letters); $i++)\
    \ {\n        if (!isset($histogram[$letters[$i]]))\n            $histogram[$letters[$i]]\
    \ = 1;\n        else\n            $histogram[$letters[$]]++;\n    }\n    return\
    \ $histogram;\n}", "    $freq = array();\n    foreach (str_split($test) as $letter)\
    \ {\n        $freq[$letter]++;\n    }\n    arsort($freq);\n    return $freq;\n\
    }\n", "\t$histogram = array();\n\tforeach (preg_split('/ /', $test) as $letter)\
    \ {\n\t\t$histogram[$letter] = array_key_exists($letter, $histogram) ? $histogram[$letter]\
    \ + 1 : 1;\n\t}\n\treturn $histogram;\n}\n", "  // Split the string into individual\
    \ chars and then group them into an array of\n  // occurrences.\n  $occurrences\
    \ = array_count_values(str_split($test));\n  // Find the letter that occurs the\
    \ most.\n  $letter = key($occurrences);\n  // Return an array containing the letter\
    \ and the amount of times it occurs\n  // in the string.\n  return array(\"letter\"\
    \ => $letter, \"count\" => $occurrences[$letter]);\n}\n", "  $histogram = array();\n\
    \  $letters = array_unique(str_split($test));\n  foreach ($letters as $letter)\
    \ {\n    $histogram[$letter] = 0;\n  }\n  $frequency = array();\n  foreach ($letters\
    \ as $letter) {\n    if (isset($histogram[$letter])) {\n      $frequency[$letter]\
    \ = $histogram[$letter];\n    }\n  }\n  // Sort the letters by their frequency\
    \ in descending order and return the top 10\n  arsort($frequency);\n  return array_slice($frequency,\
    \ 0, 10);\n}\n", "  $histogram = array();\n  $words = explode(' ', $test);\n \
    \ foreach ($words as $word) {\n    $histogram[$word] = isset($histogram[$word])\
    \ ? $histogram[$word] + 1 : 1;\n  }\n  arsort($histogram);\n  return $histogram;\n\
    }\n</code>\n<|/ a tags=arrays,php |>\n<| a tags=arrays,php |>\n<code>\n$array\
    \ = array(\"a\" => \"apple\", \"b\" => \"banana\", \"c\" => \"carrot\", \"d\"\
    \ => \"dog\");\n\n$array_unique = array_unique($array);\n\n$counts = array();\n\
    foreach ($array_unique as $key => $value) {\n    $counts[$key] = array_count_values($array);\n\
    }\n\nvar_dump($counts);\n</code>\n<|/ a dscore=2 |>\n<| a |>\nI suggest using\
    \ array_count_values() function.\n<code>\n$array = array(\"a\" => \"apple\", \"\
    b\" => \"banana\", \"c\" => \"carrot\", \"d\" => \"dog\");\n$arrayCount = array_count_values($array);\n\
    \nprint_r($arrayCount);\n</code>\n<|/ a tags=arrays,php dscore=1 |>\n<| a dscore=0\
    \ |>\nIf you want to use array_count_values without using the loops, you can do\
    \ something like this (assuming $myArray is your array):\n<code>\n$counts = array_count_values($myArray);\n\
    </code>\n$counts now contains this:\n<code>\narray(\"a\" => 1, \"b\" => 2, \"\
    c\" => 1, \"d\" => 1, \"e\" => 1, \"f\" => 1);\n</code>\n<|/ a tags=arrays,php\
    \ |>\n<| a dscore=0 |>\n<code>\n<?php\n\n$array = array(\"a\" => \"apple\", \"\
    b\" => \"banana\", \"c\" => \"carrot\", \"d\" => \"dog\");\n$array_unique = array_unique($array);\n\
    \nforeach ($array_unique as $key => $value)\n{\n    $counts[$key] = array_count_values($array);\n\
    }\n\nprint_r($counts);", "    $histogram = array();\n    $letters = str_split($test);\n\
    \    $count = count($letters);\n    for($i = 0; $i < $count; $i++) {\n       \
    \ $histogram[$letters[$i]] = isset($histogram[$letters[$i]]) ? $histogram[$letters[$i]]\
    \ + 1 : 1;\n    }\n    $most_frequent = max($histogram);\n    $result = array();\n\
    \    foreach ($histogram as $letter => $occurrence) {\n        if ($occurrence\
    \ === $most_frequent) {\n            $result[$letter] = $occurrence;\n       \
    \ }\n    }\n    return $result;\n}\n", "  $test = preg_replace('/\\s+/', '', $test);\n\
    \  $chars = preg_split('//', $test);\n  $count = array();\n  foreach ($chars as\
    \ $c) {\n    $count[$c]++;\n  }\n  arsort($count);\n  return array_keys($count);\n\
    }\n", "  $histogram = array();\n  if (strlen($test) == 0) {\n    return $histogram;\n\
    \  }\n  $letters = str_split($test);\n  foreach ($letters as $letter) {\n    if\
    \ (!isset($histogram[$letter])) {\n      $histogram[$letter] = 0;\n    }\n   \
    \ $histogram[$letter] += 1;\n  }\n  arsort($histogram);\n  return $histogram;\n\
    }", "  $histogram = array();\n  foreach(str_split($test) as $letter) {\n    if\
    \ (!isset($histogram[$letter]))\n      $histogram[$letter] = 0;\n    $histogram[$letter]++;\n\
    \  }\n  return $histogram;\n}\n", "  $letters = str_split($test);\n  $histogram\
    \ = array_count_values($letters);\n  arsort($histogram);\n  return $histogram;\n\
    }\n", "\t$histogram = array();\n\tforeach (explode(' ', $test) as $letter) {\n\
    \t\tif (!isset($histogram[$letter])) {\n\t\t\t$histogram[$letter] = 0;\n\t\t}\n\
    \t\t$histogram[$letter]++;\n\t}\n\tksort($histogram);\n\t$maxValue = $histogram[array_shift($histogram)];\
    \ // first value is the most frequent\n\twhile (count($histogram) > 0) {\n\t\t\
    $maxValue++;\n\t\t$histogram = array_intersect_key($histogram, array_flip(array_keys($histogram)));\n\
    \t}\n\treturn $histogram;\n}", "    return array_reduce(\n        preg_split('/\\\
    s+/', $test, -1, PREG_SPLIT_NO_EMPTY),\n        function ($count, $letter) {\n\
    \            $count[$letter] = isset($count[$letter]) ? $count[$letter] + 1 :\
    \ 1;\n            return $count;\n        },\n        array()\n    );\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=php,string |>\n<code>\n<?php\n$string = \"The quick\
    \ brown fox jumped over the lazy dog\";\n\n$array = preg_split('/(\\s)/', $string);\n\
    \n$result = array();\nforeach ($array as $k => $v)\n{\n    if(!isset($result[$v]))\n\
    \    {\n        $result[$v] = 1;\n    }\n    else\n    {\n        $result[$v]++;\n\
    \    }\n}\n\narsort($result);\n\n$result2 = array();\nforeach ($result as $k =>\
    \ $v)\n{\n    if($v > 1)\n    {\n        $result2[$k] = $v;\n    }\n}\n\nvar_dump($result);\n\
    var_dump($result2);\n</code>\n<|/ a dscore=0 |>\n<| a tags=php,string |>\nTry\
    \ this. Just one foreach loop. \n<code>\n<?php\n$string = \"The quick brown fox\
    \ jumped over the lazy dog\";\n$array = preg_split('/(\\s)/', $string);\n$result\
    \ = array();\nforeach ($array as $k => $v)\n{\n    if(!isset($result[$v]))\n \
    \   {\n        $result[$v] = 1;\n    }\n    else\n    {\n        $result[$v]++;\n\
    \    }\n}\n\narsort($result);\n$result2 = array();\nforeach ($result as $k =>\
    \ $v)\n{\n    if($v > 1)\n    {\n        $result2[$k] = $v;\n    }\n}\n\nprint_r($result2);\n\
    </code>\n<|/ a dscore=0 |>\n<| a |>\n<code>\n$string = \"The quick brown fox jumped\
    \ over the lazy dog\";\n\n$array = preg_split('/(\\s)/', $string);\n\n$result\
    \ = array();\nforeach ($array as $k => $v)\n{\n    if(!isset($result[$v]))\n \
    \   {\n        $result[$v] = 1;\n    }\n    else\n    {\n        $result[$v]++;\n\
    \    }\n}\n\narsort($result);\n\n$result2 = array();\nforeach ($result as $k =>\
    \ $v)\n{\n    if($", "  $letters = preg_split('//u', $test, -1, PREG_SPLIT_NO_EMPTY);\n\
    \  $histogram = array();\n\n  foreach ($letters as $letter) {\n    if (isset($histogram[$letter]))\
    \ {\n      $histogram[$letter]++;\n    } else {\n      $histogram[$letter] = 1;\n\
    \    }\n  }\n\n  return $histogram;\n}\n</code>\n<|/ a |>\n<| c |>\nThanks, I've\
    \ read through the code you wrote but I'm struggling to understand why it doesn't\
    \ work... It doesn't produce the correct output... Can you please add comments\
    \ and explain the code to me so I can understand it better?\n<|/ c |>\n<| c |>\n\
    : Please see my update with an explanation.\n<|/ c |>\n<| c |>\nThanks, I've added\
    \ the comments to the code you wrote, but it still doesn't work... I've tried\
    \ a couple of other examples and they all return an error... Can you please check\
    \ my original post to see if you can spot any errors in it?\n<|/ c |>\n<| c |>\n\
    : I just tested it and it works perfectly for me. I added a more verbose description\
    \ of the code and an example test. If you run `php test.php` it should output\
    \ `array(\"a\" => 1, \"b\" => 1, \"c\" => 1)`.\n<|/ c |>\n<| c |>\nThank you,\
    \ I was able to get it to work. I had to change the `array_count_values($letters)`\
    \ to `array_count_values($letters, SORT_STRING)`\n<|/ c |>\n<| a |>\nHere is a\
    \ solution without using a regular expression that requires you to load all your\
    \ test strings into the memory and then scan them all to find repetitions. Instead\
    \ you can load each character of the string as you go until you get to the end\
    \ of the string. As you go from left to right you can keep track of how many letters\
    \ of the string you've already seen and when you reach the end then you can compare\
    \ that to the number of repetitions and if they are equal then you have found\
    \ an answer.\n<code>", "  // split the test string into an array of letters\n\
    \  $letters = preg_split('/\\s+/', $test);\n\n  // init an array to store the\
    \ results\n  $result = [];\n\n  // go over each letter and keep track of the letter\
    \ with the highest occurrence\n  // and the number of occurrences.\n  foreach\
    \ ($letters as $letter) {\n    // only count the letters once\n    if (isset($result[$letter]))\
    \ {\n      $result[$letter]++;\n    } else {\n      $result[$letter] = 1;\n  \
    \  }\n  }\n\n  // return an array with letter => count\n  return $result;\n}\n\
    </code>\nThis solution assumes that the test string is always composed only of\
    \ lower case letters. \nThis solution assumes that you do not want to use built-in\
    \ php functions such as array_count_values(), because this is more a learning\
    \ exercise and does not really provide any benefit over the histogram solution\
    \ above.\n<|/ a dscore=1 |>\n<| a dscore=1 tags=php,arrays,multidimensional-array\
    \ |>\narray_count_values() is what you're looking for:\n<code>\n$arr = array(\"\
    a\",\"b\",\"b\",\"b\",\"a\");\nprint_r(array_count_values($arr));\n</code>\nOutput:\n\
    <code>\nArray\n(\n    [a] => 3\n    [b] => 3\n)\n</code>\n<|/ a |>\n<| a tags=php,arrays,multidimensional-array\
    \ |>\n<code>", "  $histo = array();\n  $test = strtolower($test);\n  for ($i=0;$i<strlen($test);$i++)\
    \ {\n    $histo [$test[$i]] = isset($histo[$test[$i]] ? $histo[$test[$i]] : 0)\
    \ + 1;\n  }\n  return $histo;\n}\n", "  $letters = explode(' ', $test);\n  $histogram\
    \ = array();\n  foreach ($letters as $letter) {\n    $letter = strtolower($letter);\n\
    \    if (!isset($histogram[$letter])) {\n      $histogram[$letter] = 1;\n    }\
    \ else {\n      $histogram[$letter]++;\n    }\n  }\n  return $histogram;\n}\n\
    </code>\nI tested it and it works. Hope it helps someone!\n<|/ a tags=php,algorithm,string-length,histogram,arrays\
    \ |>\n<| c |>\nI came across this question while looking for a solution to my\
    \ problem in Python, so I thought I'd share my Python solution.\n\n`from collections\
    \ import Counter\ndef histogram(s):\n    histogram = Counter()\n    words = s.split()\n\
    \    for word in words:\n        histogram[word.lower()] += 1\n    return dict(histogram)`\n\
    <|/ c |>\n<| c |>\nTo anyone who is concerned that `explode` will be a bottleneck\
    \ - note that `preg_split()` uses a regex internally. And the regex is simple\
    \ enough that this would be really fast.\n<|/ c |>\n<| a |>\nI thought about this\
    \ a while ago and came up with a solution that seems to work quite well, although\
    \ it doesn't handle multiple spaces or leading or trailing whitespace:\n<code>",
  "  $counts = array();\n  $words = explode(' ', $test);\n  foreach($words as $word)\
    \ {\n    if (isset($counts[$word])) {\n      $counts[$word] += 1;\n    } else\
    \ {\n      $counts[$word] = 1;\n    }\n  }\n  arsort($counts);\n  return $counts;\n\
    }\n\n$tests = array(\n  \"a b c\",\n  \"a b b a\",\n  \"a b c a b\",\n  \"b b\
    \ b b a\",\n  \"\",\n);\n\nforeach($tests as $test) {\n  print \"Test $test:\\\
    n\";\n  $histogram = histogram($test);\n  print_r($histogram);\n  print \"\\n\"\
    ;\n}\n", "  // Split the string into an array of individual characters.\n  //\
    \ Since array_count_values() returns the frequencies of every item in an array,\
    \ we\n  // need to add the value 1 to the array so that it is considered a frequency.\n\
    \  $frequencies = array_count_values(str_split($test));\n\n  $histogram = array();\n\
    \  foreach ($frequencies as $letter => $count) {\n    // Check if the letter has\
    \ already been added to the histogram.\n    if (isset($histogram[$letter])) {\n\
    \      // If the letter has already been added to the histogram, add the\n   \
    \   // amount of occurrences onto the current number for the letter.\n      $histogram[$letter]\
    \ += $count;\n    } else {\n      // If the letter has not been added to the histogram,\
    \ set the current number\n      // for the letter to the total count of occurrences\
    \ plus the current count.\n      $histogram[$letter] = $count + 1;\n    }\n  }\n\
    \n  return $histogram;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nthanks i will\
    \ try this one\n<|/ c |>\n<| c |>\nSure, good luck! Let me know if you need any\
    \ further help :)\n<|/ c |>\n<| c |>\nit works! just one problem... i need to\
    \ get the frequency of the most repeated letter first.. then i get the frequency\
    \ of the second most repeated letter and so on.. how can i do this?\n<|/ c |>\n\
    <| c |>\nYou can simply do this: `$most_frequent = max($histogram, SORT_REGULAR);\
    \ $most_frequent_count = array_search($most_frequent, $histogram);`. This will\
    \ give you the most frequent letter and its count.\n<|/ c |>\n<| c |>\nthank you\
    \ so much! but can you show me how can i sort the frequency array according to\
    \ the number of most repeated letters first? for example the most frequent letter\
    \ should be first in the array\n<|/ c |>\n<| a tags=php |>\nFor me the easiest\
    \ way is by array_count_values() function.\n<code>\n$text = \"AA BB AA CC AA DD\
    \ CC CC DD AA\";\n\n$array = array();\nforeach (str_split($text) as $char) {\n\
    \    $array[$char] = 1;\n}\n$array = array_count_values($array);\narsort($array);\n\
    $result = array_slice($array, 0, 1);\necho \"<pre>\";\nprint_r($result);\necho\
    \ \"</pre>\";\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "    $histogram\
    \ = array();\n    $letters = explode(\" \", $test);\n\n    foreach ($letters as\
    \ $letter) {\n        if (isset($histogram[$letter])) {\n            $histogram[$letter]\
    \ += 1;\n        } else {\n            $histogram[$letter] = 1;\n        }\n \
    \   }\n\n    arsort($histogram);\n\n    return $histogram;\n}\n", "    $test =\
    \ \"$test\";\n    $histogram = array();\n    for ($i = 0; $i < strlen($test);\
    \ $i++) {\n        if ($test[$i] != '_') {\n            $histogram[$test[$i]]\
    \ = isset($histogram[$test[$i]]) ? $histogram[$test[$i]] + 1 : 1;\n        }\n\
    \    }\n    return $histogram;\n}\n", "  $letters = explode(\" \", $test);\n \
    \ arsort($letters);\n  $histo = array();\n  foreach ($letters as $letter) {\n\
    \    if (isset($histo[$letter])) $histo[$letter]++;\n    else $histo[$letter]\
    \ = 1;\n  }\n  return $histo;\n}\n", "  $hist = array();\n  foreach ($test as\
    \ $char) {\n    if (isset($hist[$char])) {\n      $hist[$char] += 1;\n    } else\
    \ {\n      $hist[$char] = 1;\n    }\n  }\n  arsort($hist);\n  return $hist;\n\
    }\n</code>\nThe output is quite similar to what you would expect, but in a more\
    \ interesting fashion:\n<code>\nArray(\n  [c] => 1\n  [b] => 2\n  [a] => 2\n)\n\
    </code>\n<|/ a |>\n<| c |>\nThat's very interesting. Thanks for the solution!\n\
    <|/ c |>\n<| a tags=frequency,php,arrays |>\n<code>\n<?php\n$str = \"a a b b c\"\
    ;\n$str = strtolower($str);\n$freq = array_count_values(str_split($str));\nasort($freq);\n\
    print_r($freq);\n</code>\n<|/ a dscore=3 |>\n<| a tags=frequency,php,arrays dscore=2\
    \ |>\n<code>\n$text = \"a b c a b c a b c a b c a b c a b c a b c a b c a b c\
    \ a b c a b c a b c a b c a b c\";\n$text = strtolower($text);\n$words = str_split($text);\n\
    $freq = [];\nforeach($words as $word) {\n    if(isset($freq[$word])) {\n     \
    \   $freq[$word]++;\n    } else {\n        $freq[$word] = 1;\n    }\n}\nprint_r($freq);\n\
    </code>\n<|/ a |>\n<| a |>\n<code>\n$str = \"a b c a b c a b c a b c a b c a b\
    \ c a b c a b c a b c a b c a b c a b c a b c a b c a b c a b c a b c a b c\"\
    ;\n$str = strtolower($str);\n$words = str_split($str);\n$freq = [];\nforeach($words\
    \ as $word) {\n    if(isset($freq[$word])) {\n        $freq[$word]++;\n    } else\
    \ {\n        $freq[$word] = 1;\n    }\n}\nprint_r($freq);\n</code>\n<|/ a tags=frequency,php,arrays\
    \ dscore=2 |>\n<| a |>\n<code>\n$myarray = \"a b c a b c a b c a b c a b c a b\
    \ c a b c a b c a b c a b c a b c a b c a b c a ", "  $chars = str_split($test);\n\
    \  $histogram = array();\n  $testCounts = array();\n  foreach ($chars as $char)\
    \ {\n    if (empty($char)) {\n      continue;\n    }\n    $testCounts[$char] =\
    \ isset($testCounts[$char]) ? $testCounts[$char] + 1 : 1;\n  }\n  arsort($testCounts);\n\
    \  $longestTest = array_pop($testCounts);\n  foreach ($testCounts as $char =>\
    \ $count) {\n    $histogram[$char] = isset($histogram[$char]) ? $histogram[$char]\
    \ + $count : $count;\n  }\n  return array_intersect_key($histogram, $testCounts);\n\
    }", "    $occurrences = array();\n    $letters = explode(' ', $test);\n\n    foreach\
    \ ($letters as $letter) {\n        if (isset($occurrences[$letter])) {\n     \
    \       $occurrences[$letter]++;\n        } else {\n            $occurrences[$letter]\
    \ = 1;\n        }\n    }\n\n    return $occurrences;\n}\n", "  // Sort the letters\
    \ by frequency in descending order.\n  arsort($test);\n  // Get the first letter\
    \ and count.\n  $letter = array_shift($test);\n  $count = array_shift($test);\n\
    \n  // If the letter and count are equal, return the letter and count.\n  if ($letter\
    \ == $count) {\n    return array($letter => $count);\n  }\n\n  // If there are\
    \ multiple letters with the same frequency, sort the letters in\n  // descending\
    \ order and keep track of how many letters of the same frequency\n  // were seen.\
    \ If the letters of the same frequency were all seen the same,\n  // then also\
    \ return the letter and count.\n  if (count($test) > 1) {\n    arsort($test);\n\
    \n    foreach ($test as $k => $v) {\n      if ($k > 1 && $test[$k] == $test[$k\
    \ - 1]) {\n        unset($test[$k - 1]);\n        ++$test[$k];\n      }\n    }\n\
    \  }\n\n  // If there are still letters of the same frequency, return them all.\n\
    \  if (count($test)) {\n    return $test;\n  }\n\n  // Otherwise, the letter and\
    \ count are equal. Return the letter and count.\n  return array($letter => $count);\n\
    }\n</code>\n<|/ a tags=php dscore=1 |>\n<| c |>\nThis is an elegant solution,\
    \ but I don't like the fact that you're using an array for this. A hash table\
    \ would be a lot more efficient. Additionally, your code is O(N^2). An improvement\
    \ would be to iterate over the letters and put them into an array or hash of the\
    \ letter and how many times they occur, then just iterate over that array and\
    \ find the max. This would also be O(N) instead of O(N^2).\n<|/ c |>\n<| c |>\n\
    I've updated my code to reflect your suggestions, with a hashtable instead of\
    \ an array to improve its efficiency.\n<|/ c |>\n<| a tags=php |>\nI made another\
    \ solution by doing this.\n<code>\n<?php", "  $histogram = array();\n\n  foreach\
    \ (str_split($test) as $letter) {\n    if (!isset($histogram[$letter])) {\n  \
    \    $histogram[$letter] = 0;\n    }\n\n    $histogram[$letter]++;\n  }\n\n  return\
    \ $histogram;\n}\n", "  $histogram = array();\n  $tokens = explode(' ', $test);\n\
    \  $total_tokens = count($tokens);\n  $tokens_length = count($tokens);\n  foreach\
    \ ($tokens as $token) {\n    $occurrences = array_key_exists($token, $histogram)\
    \ ? $histogram[$token] : 0;\n    $histogram[$token] = $occurrences + 1;\n  }\n\
    \  arsort($histogram);\n  return $histogram;\n}\n", "    $array = explode(' ',\
    \ $test);\n    $frequencies = array();\n    foreach ($array as $letter) {\n  \
    \      if (!isset($frequencies[$letter])) {\n            $frequencies[$letter]\
    \ = 1;\n        } else {\n            $frequencies[$letter]++;\n        }\n  \
    \  }\n\n    return array_count_values($frequencies);\n}\n\n$letters = array(\n\
    \    'a' => array(),\n    'b' => array(),\n    'c' => array(),\n    'd' => array(),\n\
    \    'e' => array(),\n    'f' => array(),\n    'g' => array(),\n    'h' => array(),\n\
    \    'i' => array(),\n    'j' => array(),\n    'k' => array(),\n    'l' => array(),\n\
    \    'm' => array(),\n    'n' => array(),\n    'o' => array(),\n    'p' => array(),\n\
    \    'q' => array(),\n    'r' => array(),\n    's' => array(),\n    't' => array(),\n\
    \    'u' => array(),\n    'v' => array(),\n    'w' => array(),\n    'x' => array(),\n\
    \    'y' => array(),\n    'z' => array(),\n);\n\n$letters['a']['a'] = $letters['a']['a']\
    \ + 1;\n$letters['a']['b'] = $letters['a']['b'] + 1;\n$letters['a']['c'] = $letters['a']['c']\
    \ + 1;\n$letters['a']['d'] = $letters['a']['d'] + 1;\n$letters['a']['e'] = $letters['a']['e']\
    \ + 1;\n$letters['a']['f'] = $letters['a']['f'] + 1;\n$letters['a']['g'] = $letters['a']['g']\
    \ + 1;\n$letters['a']['h'] = $letters['a']['h'] + 1;\n$letters['a']['i'] = $letters['a']['i']\
    \ + 1;\n$letters['a']['j'] = $letters['a']['j'] + 1;\n$letters['a']['k'] = $letters['a']['k']\
    \ + 1;\n$letters['a']['l'] = $letters['a']['l'] + 1;\n$letters['a']['m'] = $letters['a']['m']\
    \ + 1;\n$letters['a']['n'] = $letters['a']['n'] + 1;\n$letters['a']['o'] = $letters['a']['o']\
    \ + 1;\n$letters['a']['p'] = $letters['a']['p'] + 1;\n$letters['a']['q'] = $letters['a']['q']\
    \ + 1;\n$letters['a']['r'] = $", "  $letters = array_count_values(str_split($test));\n\
    \  arsort($letters);\n  $out = array();\n  foreach ($letters as $letter => $count)\
    \ {\n    $out[$letter] = $count;\n  }\n  return $out;\n}\n", "    $counts = array();\n\
    \    $tests = explode(' ', $test);\n    foreach ($tests as $test) {\n        $letter\
    \ = substr($test, 0, 1);\n        if (isset($counts[$letter])) {\n           \
    \ $counts[$letter]++;\n        } else {\n            $counts[$letter] = 1;\n \
    \       }\n    }\n    return $counts;\n}\n\n/**\n * @param string $test\n * @param\
    \ array $counts\n * @param int $key\n */", "    $tests = explode(' ', $test);\n\
    \    $histogram = array();\n    foreach ($tests as $test) {\n        $key = strtolower($test);\n\
    \        if (isset($histogram[$key])) {\n            $histogram[$key]++;\n   \
    \     } else {\n            $histogram[$key] = 1;\n        }\n    }\n    arsort($histogram);\n\
    \    return $histogram;\n}", "    if (empty($test)) {\n        return array();\n\
    \    }\n    $histogram = array();\n    $letters = preg_split('//u', $test);\n\
    \    foreach ($letters as $letter) {\n        if (isset($histogram[$letter]))\
    \ {\n            $histogram[$letter]++;\n        } else {\n            $histogram[$letter]\
    \ = 1;\n        }\n    }\n    $letters = array_keys($histogram);\n    foreach\
    \ ($letters as $letter) {\n        $histogram[$letter] = $histogram[$letter] /\
    \ count($letters);\n    }\n    return $histogram;\n}\n", "    $histogram = array();\n\
    \    $tests = explode(' ', $test);\n    foreach ($tests as $test) {\n        $letter\
    \ = strtolower($test);\n        if (isset($histogram[$letter])) {\n          \
    \  $histogram[$letter] += 1;\n        } else {\n            $histogram[$letter]\
    \ = 1;\n        }\n    }\n    arsort($histogram);\n    return $histogram;\n}\n",
  "  $counts = array();\n  foreach(str_split($test) as $letter) {\n    if (!isset($counts[$letter]))\
    \ {\n      $counts[$letter] = 0;\n    }\n    $counts[$letter]++;\n  }\n  $histo\
    \ = array();\n  foreach($counts as $letter => $count) {\n    $histo[$letter] =\
    \ $count;\n  }\n  return $histo;\n}\n", "  $letters = array_count_values(str_split($test));\n\
    \  arsort($letters);\n  $result = array();\n  foreach ($letters as $letter =>\
    \ $count) {\n    $result[$letter] = $count;\n  }\n  return $result;\n}\n", " \
    \ $counts = array_count_values(str_split($test));\n\n  arsort($counts);\n  $most_frequent\
    \ = array_keys($counts, max($counts));\n  return array_intersect_key($counts,\
    \ array_flip($most_frequent));\n}", "    $hist = array();\n    $test = (string)$test;\n\
    \    $tokens = preg_split('/ /', $test, -1, PREG_SPLIT_NO_EMPTY);\n    foreach\
    \ ($tokens as $token) {\n        if ($token != \"\") {\n            $char = strtolower($token);\n\
    \            if (isset($hist[$char])) {\n                $hist[$char]++;\n   \
    \         } else {\n                $hist[$char] = 1;\n            }\n       \
    \ }\n    }\n    return $hist;\n}\n</code>\n<|/ a tags=arrays,php |>\n<| c |>\n\
    this worked perfectly for me, I adapted it to a similar situation where I was\
    \ looking for how many times an IP address showed up in a log.  thank you\n<|/\
    \ c |>\n<| a dscore=1 |>\nAnother way to approach this:\n<code>\n<?php\n$string\
    \ = \"a b c a b\";\n$array = explode(\" \", $string);\n$count = array_count_values($array);\n\
    arsort($count);\n$most_common = array_keys($count);\nprint_r($most_common);\n\
    </code>\n<|/ a tags=arrays,php |>\n<| c |>\nThis is much simpler - thanks!\n<|/\
    \ c |>\n<| a tags=arrays,php |>\nHere is a simple solution that uses arrays as\
    \ requested:\n<code>\n<?php\n$string = \"a b c a b\";\n", "  $letters = array_count_values(explode('\
    \ ', $test));\n  $max  = 0;\n  $res = array();\n  foreach ($letters as $letter\
    \ => $count) {\n    if ($count > $max) {\n      $max = $count;\n      $res = array($letter\
    \ => $count);\n    } else if ($count == $max) {\n      $res[$letter]++;\n    }\n\
    \  }\n  return $res;\n}", "    $histogram = array();\n    foreach (str_split($test)\
    \ as $letter) {\n        if (isset($histogram[$letter])) {\n            $histogram[$letter]++;\n\
    \        } else {\n            $histogram[$letter] = 1;\n        }\n    }\n\n\
    \    return $histogram;\n}\n</code>\nThen, we simply have to count the occurrences\
    \ of each key of the histogram in order to get the desired result:\n<code>", " \
    \   $letters = str_split($test);\n    $histo = array();\n\n    foreach ($letters\
    \ as $letter) {\n        if (isset($histo[$letter])) {\n            $histo[$letter]\
    \ += 1;\n        } else {\n            $histo[$letter] = 1;\n        }\n    }\n\
    \n    return $histo;\n}\n", "  if (empty($test)) {\n    return array();\n  }\n\
    \n  $map = array();\n  $result = array();\n  $letters = preg_split('//', $test);\n\
    \n  // Map the letters to their counts\n  foreach ($letters as $letter) {\n  \
    \  if (empty($map[$letter])) {\n      $map[$letter] = 1;\n    } else {\n     \
    \ $map[$letter]++;\n    }\n  }\n\n  // Get the letter with the highest count\n\
    \  arsort($map);\n\n  foreach ($map as $letter => $count) {\n    $result[$letter]\
    \ = $count;\n  }\n\n  return $result;\n}\n", "  // Split string into array on\
    \ space to get an array of lowercase letters.\n  $letters = array_map(\"strtolower\"\
    , explode(\" \", $test));\n\n  // Initialize array to hold letter counts\n  $counts\
    \ = array();\n\n  // For each letter in the letters\n  foreach ($letters as $letter)\
    \ {\n    // If the letter was in the counts array, add the count\n    if (isset($counts[$letter]))\
    \ {\n      $counts[$letter]++;\n    } else {\n      // Otherwise, add the first\
    \ occurrence count\n      $counts[$letter] = 1;\n    }\n  }\n\n  // Return the\
    \ array of letters with their corresponding counts.\n  return $counts;\n}\n",
  "    $histogram = array();\n\n    // Split on space and remove empty elements\n\
    \    foreach (explode(' ', $test) as $letter) {\n        if ($letter !== \"\"\
    ) {\n            if (isset($histogram[$letter])) {\n                $histogram[$letter]++;\n\
    \            } else {\n                $histogram[$letter] = 1;\n            }\n\
    \        }\n    }\n    return $histogram;\n}", "    $counts = array();\n\n   \
    \ // Split string into array of characters.\n    foreach (str_split($test) as\
    \ $letter) {\n        // Count current letter.\n        $counts[$letter] = isset($counts[$letter])\
    \ ? $counts[$letter] + 1 : 1;\n    }\n\n    // Sort alphabetically.\n    asort($counts);\n\
    \n    // Return array with letter and number of occurrences.\n    return array_slice($counts,\
    \ 0, 1);\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nWhy are you using `preg_match`\
    \ instead of `str_split`?\n<|/ c |>\n<| c |>\nI wanted to be more \"regex like\"\
    \ as far as possible, but then I saw the question was tagged with regex only,\
    \ so I just went for that.\n<|/ c |>\n<| c |>\nAh, I see. I would still prefer\
    \ `str_split` for something like this, but it's nice to have alternatives. I suppose\
    \ I should have asked why you were using regex instead of `str_split`.\n<|/ c\
    \ |>\n<| c |>\nThank you so much for your quick answer! It works perfectly. I\
    \ learned a lot and now I understand why I was having this issue. I appreciate\
    \ it!\n<|/ c |>\n<| a tags=arrays,php,count,string,arrays |>\nHere's my take:\n\
    <code>\n$array = [\n    \"a\",\n    \"a\",\n    \"a\",\n    \"b\",\n    \"c\"\
    ,\n    \"a\",\n    \"b\",\n    \"b\",\n    \"a\",\n    \"a\",\n    \"b\",\n  \
    \  \"b\",\n    \"b\",\n    \"a\"\n];\n\n$result = array();\nforeach($array as\
    \ $letter) {\n    $result[$letter] = isset($result[$letter]) ? $result[$letter]\
    \ + 1 : 1;\n}\n\narsort($result);\n\nprint_r($result);\n</code>\nOutput:\n<code>\n\
    Array\n(\n    [a] => 3\n    [b] => 2\n    [c] => 1\n)\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThank you so much for your quick answer! It works perfectly. I\
    \ learned a lot and now I understand why I was having this issue. I appreciate\
    \ it!\n<|/ c |>\n<| a dscore=1 |>\nTry this, I have used foreach loop and explode\
    \ to separate the characters in to array.\n<code>\n<?php\n$array = array(\"a\"\
    , \"a\", \"a\", \"b\", \"c\", \"a\", \"b\", \"b\", \"a\", \"a\", \"b\", \"b\"\
    , \"b\", \"a\", \"b\");\n$counter = 0;\nforeach ($array as $item) {\n", "    $histogram\
    \ = array();\n    $values = str_split($test);\n    foreach ($values as $value)\
    \ {\n        if (isset($histogram[$value])) {\n            $histogram[$value]++;\n\
    \        } else {\n            $histogram[$value] = 1;\n        }\n    }\n\n \
    \   return $histogram;\n}\n", "  $count = array();\n  $letters = preg_split('//u',\
    \ $test);\n  foreach($letters as $letter) {\n    $count[$letter] = isset($count[$letter])\
    \ ? $count[$letter] + 1 : 1;\n  }\n  arsort($count);\n  return array_keys($count);\n\
    }\n", "    $counts = array();\n    $letters = str_split($test);\n    foreach ($letters\
    \ as $letter) {\n        if (isset($counts[$letter])) {\n            $counts[$letter]++;\n\
    \        } else {\n            $counts[$letter] = 1;\n        }\n    }\n    return\
    \ $counts;\n}\n</code>\nThe code above will generate this kind of output:\n<code>\n\
    Array\n(\n    [a] => 1\n    [b] => 2\n    [c] => 1\n)\nArray\n(\n    [a] => 2\n\
    \    [b] => 2\n    [c] => 1\n)\nArray\n(\n    [a] => 2\n    [b] => 4\n    [c]\
    \ => 1\n)\nArray\n(\n)\n</code>\n<|/ a |>\n<| a tags=arrays,php |>\n<code>\n$test\
    \ = 'a b b b b a';\n$letters = str_split($test);\n$counts = array_count_values($letters);\n\
    $result  = array();\n\nforeach ($counts as $letter => $count) {\n    $result[$letter]\
    \ = $count;\n}\n\nprint_r($result);\n</code>\n<|/ a dscore=1 |>\n<| a tags=arrays,php\
    \ dscore=0 |>\n<code>", "  $histogram = array();\n  foreach (str_split($test)\
    \ as $letter) {\n    if (!isset($histogram[$letter])) {\n      $histogram[$letter]\
    \ = 1;\n    } else {\n      $histogram[$letter]++;\n    }\n  }\n\n  return $histogram;\n\
    }\n</code>\n<|/ a tags=php,arrays,string dscore=0 |>\n<| c |>\nThank you for your\
    \ answer but i would not like to import anything from the outside of the function.\n\
    <|/ c |>\n<| c |>\nOh! Ok then, I misunderstood the question, sorry.\n<|/ c |>\n\
    <| a dscore=0 |>\n<code>", "  $result = array();\n\n  $arr = explode(' ', $test);\n\
    \  foreach ($arr as $letter) {\n    $result[$letter] = isset($result[$letter])\
    \ ? $result[$letter] + 1 : 1;\n  }\n  arsort($result);\n\n  return $result;\n\
    }\n", "  $histogram = array();\n  $letters = str_split($test);\n  foreach ($letters\
    \ as $letter) {\n    if (isset($histogram[$letter])) {\n      $histogram[$letter]++;\n\
    \    } else {\n      $histogram[$letter] = 1;\n    }\n  }\n  return $histogram;\n\
    }", "  return preg_replace_callback('/\\s(?=(?:\\1{3,})+(?!\\1))/', \n    function\
    \ ($m) {\n      return count($m[0]) ? $m[0] : $m[1];\n  }, str_split($test));\n\
    }", "    $result = array();\n    foreach (str_split($test) as $letter) {\n   \
    \     if ($letter in $result) {\n            $result[$letter]++;\n        } else\
    \ {\n            $result[$letter] = 1;\n        }\n    }\n    return $result;\n\
    }\n", "  $letters = array_count_values(str_split($test));\n  $result = array();\n\
    \  foreach ($letters as $letter => $count) {\n    if ($count > 1) {\n      $result[$letter]\
    \ = $count;\n    }\n  }\n  return $result;\n}\n", "    $counts = array();\n  \
    \  foreach (str_split($test) as $letter) {\n        $counts[$letter] = isset($counts[$letter])\
    \ ? $counts[$letter] + 1 : 1;\n    }\n\n    arsort($counts);\n    $counts = array_values($counts);\n\
    \n    return $counts;\n}\n", "  $histogram = array();\n  foreach (preg_split('/\\\
    s/', $test) as $letter) {\n    $letter = strtolower($letter);\n    if (isset($histogram[$letter]))\
    \ {\n      $histogram[$letter]++;\n    } else {\n      $histogram[$letter] = 1;\n\
    \    }\n  }\n  return $histogram;\n}\n", "    $hist = array();\n    $letters =\
    \ preg_split('/ /', $test);\n    $i = 0;\n    foreach ($letters as $letter) {\n\
    \        if (!array_key_exists($letter, $hist)) {\n            $hist[$letter]\
    \ = 1;\n        } else {\n            $hist[$letter] += 1;\n        }\n    }\n\
    \n    arsort($hist);\n    $i = 0;\n    $key = array_shift($hist);\n    $hist[$key]\
    \ = count($hist);\n    return $hist;\n}\n", "  // Split the string by space\n\
    \  $arr = explode(\" \", $test);\n\n  // Initialize the count\n  $counts = array();\n\
    \n  // Initialize a variable to store the first occurrence of the letter\n  $first_occ\
    \ = -1;\n\n  // Loop through all letters in the string\n  foreach ($arr as $letter)\
    \ {\n    // Get the current occurrence\n    $current_occ = array_key_exists($letter,\
    \ $counts) ? $counts[$letter] : 0;\n\n    // If the letter is new to the histogram,\
    \ add it to the count\n    if ($current_occ < 0) {\n      $counts[$letter] = 1;\n\
    \      // Store the new occurrence as the current occurrence\n      $current_occ\
    \ = 1;\n    }\n\n    // Otherwise, increment the occurrence count\n    else {\n\
    \      $counts[$letter]++;\n    }\n\n    // Check if the letter has already been\
    \ encountered\n    if ($first_occ < 0) {\n      // Set the first occurrence of\
    \ the letter\n      $first_occ = $current_occ;\n    }\n  }\n\n  // Return the\
    \ letter with the highest occurrence and count\n  return $counts[max($counts)];\n\
    }\n", "  return array_reduce(explode(' ', $test), function ($counts, $letter)\
    \ {\n    $counts[$letter] = isset($counts[$letter]) ? $counts[$letter] + 1 : 1;\n\
    \    return $counts;\n  }, array());\n}\n</code>\n<|/ a tags=php,arrays |>\n<|\
    \ c |>\nI like the use of array_count_values, but then you have to loop through\
    \ the array to find the highest occurring letter. Nothing like readability in\
    \ my opinion.\n<|/ c |>\n<| c |>\nI agree, but this was the most concise solution\
    \ I could find that didn't require a loop. Maybe the OP will come back and provide\
    \ a better one if they come across one. :)\n<|/ c |>\n<| c |>\nThis is indeed\
    \ a very elegant solution. I just implemented it right now and it works like a\
    \ charm. I do wish I had more control over the input and output though. I'd really\
    \ like it if these functions could somehow be used for things like `array_count_values`\
    \ and `array_filter`\n<|/ c |>\n<| c |>\nThey can, but they need to be written\
    \ so that they work on arrays of strings like `array_count_values` does. Basically,\
    \ you have to get the keys and values of the array separately, and then you can\
    \ do whatever you want with them (like find max occurring letter, or remove letters\
    \ from the string that appear only once, or whatever you want).\n<|/ c |>\n<|\
    \ c |>\nThe functions `array_count_values` and `array_filter` work the same as\
    \ they work the same way as `array_reduce`. They're just doing multiple steps\
    \ to get to where you want to go. `array_count_values` does it on its own, `array_filter`\
    \ does it in a single step.\n<|/ c |>\n<| a tags=php,arrays |>\nHow about using\
    \ a combination of array_count_values() and max() together?\n<code>\n$array =\
    \ array(\"a\" => \"a\", \"b\" => \"b\", \"c\" => \"c\", \"c\" => \"c\");\n$count\
    \ = array_count_values($array);\n$max = $count[\"c\"];\nprint_r($max);\n</code>\n\
    Output:\n<code>\n4\n</code>\n<|/ a dscore=3 |>\n<| c |>\nOh wow this is more simple\
    \ than what I came up with!\n<|/ c |>\n<| c |>\nOk so this works really well!\
    \ However, if there are multiple occurrences of the same letter it only returns\
    \ the first occurrence. Is there a way to fix that?\n<|/ c |>\n<| c |>\nO", " \
    \ $histogram = array();\n  foreach (str_split($test) as $letter) {\n    $histogram[$letter]++;\n\
    \  }\n  return $histogram;\n}\n\n/**\n * Return the letters whose frequency is\
    \ the most common in a string\n *\n * Example:\n * >>> most_common(\"a b c\")\n\
    \ * array(\"a\" => 1, \"b\" => 1, \"c\" => 1)\n *\n * @param $test\n * @return\
    \ array\n */", "  $histogram = array();\n  foreach (preg_split('/\\s+/', $test)\
    \ as $letter) {\n    if (!isset($histogram[$letter])) {\n      $histogram[$letter]\
    \ = 1;\n    } else {\n      $histogram[$letter]++;\n    }\n  }\n  return $histogram;\n\
    }\n\n/**\n * Generate random string.\n *\n * @param integer $len Length of random\
    \ string\n * @param string $chars Character pool\n * @return string Random string\n\
    \ */", "  $result = array();\n  foreach (str_split($test) as $letter) {\n    $letter\
    \ = $letter == \"\" ? null : $letter;\n    if (isset($result[$letter])) {\n  \
    \    $result[$letter]++;\n    } else {\n      $result[$letter] = 1;\n    }\n \
    \ }\n  return $result;\n}", "  $res = array();\n  $res = array_count_values(str_split($test));\n\
    \  return $res;\n}\n\n$test = 'a a a a b b b b c c c c c c c';\n$result = histogram($test);\n\
    print '<pre>';\nprint_r($result);\nprint '</pre>';", "  $letters = str_split($test);\n\
    \  $counts = array_count_values($letters);\n  arsort($counts);\n  $res = array_slice($counts,\
    \ 0, 1);\n  foreach ($counts as $letter => $occurence) {\n    if ($occurence >\
    \ $res[0]) {\n      $res = array($letter, $occurence);\n    }\n  }\n  return $res;\n\
    }\n", "  $histogram = array();\n  $testLength = strlen($test);\n  for ($i = 0;\
    \ $i < $testLength; $i++) {\n    $letter = substr($test, $i, 1);\n    if ($letter\
    \ in $histogram) {\n      $histogram[$letter]++;\n    } else {\n      $histogram[$letter]\
    \ = 1;\n    }\n  }\n  return $histogram;\n}", "    // Initialize the histogram\
    \ with the first character\n    $histogram = array($test[0]);\n    // Build the\
    \ histogram for the rest of the characters in the test string\n    for ($i = 1;\
    \ $i < strlen($test); $i++) {\n        // Find the character that has less occurrences\
    \ in the test string\n        $char = strtolower($test[$i]);\n        if ($histogram[$char]\
    \ == NULL) {\n            $histogram[$char] = 1;\n        }\n        else {\n\
    \            $histogram[$char] += 1;\n        }\n    }\n    return $histogram;\n\
    }\n", "    $result = array();\n    $words = str_word_count($test, 1);\n    foreach\
    \ ($words as $word) {\n        $result[strtolower($word)] = 1;\n    }\n    return\
    \ $result;\n}\n", "  $result = array();\n  $tests = explode(' ', $test);\n  $letter\
    \ = array_shift($tests);\n  foreach ($tests as $test) {\n    if (!isset($result[$letter]))\
    \ {\n      $result[$letter] = 1;\n    } else {\n      $result[$letter]++;\n  \
    \  }\n  }\n  asort($result);\n  $result = array_slice($result, 0, 1);\n  return\
    \ $result;\n}\n", "  $counts = array();\n  $letters = str_split($test);\n  foreach\
    \ ($letters as $letter) {\n    if (!isset($counts[$letter])) {\n      $counts[$letter]\
    \ = 0;\n    }\n    $counts[$letter]++;\n  }\n  return $counts;\n}\n</code>\nYou\
    \ can then loop over the results and find the letter with the highest count. You\
    \ can also remove duplicates.\n<code>", "  $chars = array_unique(str_split($test));\n\
    \  $histogram = array();\n  $max = 0;\n  foreach ($chars as $char) {\n    $count\
    \  = array_sum(str_split($test).$char);\n    if ($count > $max) {\n      $max\
    \ = $count;\n    }\n    $histogram[$char] = $count;\n  }\n  return $histogram;\n\
    }\n</code>\n<|/ a tags=arrays,php |>\n<| a |>\nThis solution is for PHP5.6 and\
    \ above. \n<code>", "    $letters = preg_split('//u', $test);\n    $letterCount\
    \ = array();\n    foreach ($letters as $letter) {\n        if (isset($letterCount[$letter]))\
    \ {\n            $letterCount[$letter]++;\n        } else {\n            $letterCount[$letter]\
    \ = 1;\n        }\n    }\n    return array_map(function ($letter) use ($letterCount)\
    \ {\n        return array(\n            $letter => $letterCount[$letter],\n  \
    \      );\n    }, array_keys($letterCount));\n}\n", "  $freqs = array_count_values(str_split($test));\n\
    \  arsort($freqs);\n\n  return $freqs;\n}\n</code>\n<|/ a dscore=3 |>\n<| a |>\n\
    This isn't a php specific solution, but here is a python solution (using pandas\
    \ library)\n<code>\nimport pandas as pd\nfrom collections import Counter\n\nmylist\
    \ = [\"a\", \"a\", \"b\", \"b\", \"b\", \"a\", \"a\", \"a\"]\ndf = pd.DataFrame(mylist).value_counts()\n\
    print(df)\n</code>\nOutput\n<code>\na    2\nb    4\nName: 0, dtype: int64\n</code>\n\
    <|/ a tags=arrays,python,php,histogram dscore=3 |>\n<| c |>\nI needed something\
    \ similar in PHP, so I did this `echo array_count_values(array_unique(explode('\
    \ ', $_POST['input'])));`\n<|/ c |>\n<| c |>\n`explode` makes a copy, right? Not\
    \ a big deal but still. Maybe it would be better to do `array_count_values(array_unique(array_map(function($e)\
    \ {\n return $e;\n}, explode(' ', $_POST['input'])));`\n<|/ c |>\n<| c |>\nFor\
    \ what it's worth, I'm still new to PHP and Python so I'm probably doing everything\
    \ in one language (I do like Python, so it's good to learn both). In PHP I've\
    \ just done `$_POST['input'].split(' ')` which gives me an array of the array\
    \ input values from the form input. I'm not sure if that makes a copy or not.\n\
    <|/ c |>\n<| c |>\n: It depends on the PHP version and whether you pass a reference\
    \ or a value. As far as I remember it depends on the PHP version, but a good rule\
    \ of thumb is that you don't pass a reference, because copying the array is often\
    \ a bad idea. A copy of a reference is what we call an alias (if you don't know\
    \ what an alias is check out this article https://www.php.net/manual/en/language.references.pass.php).\
    \ Using `explode` makes a copy, yes, but this is not a problem for PHP as it never\
    \ cares about copies in your code.\n<|/ c |>\n<| a tags=arrays,python,php,histogram\
    \ dscore=2 |>\nHere's another PHP approach using array_count_values as suggested\
    \ by Atharva Praveen's answer:\n<code>\n$letters = \"a b b b a a\";\n$histogram\
    \ = array_count_values(str_split($letters));\n\necho \"<pre>\"; print_r($histogram);\
    \ echo \"</pre>\"; //outputs [\n    \"a\" => 2,\n    \"b\" => 4\n]\n</code>\n",
  "    return preg_replace_callback('/(\\w)/g', function($match) { return array_get($this->histograms,\
    \ $match[1], 0) + 1; }, $test);\n}\n</code>\n<|/ a |>\n<| c |>\nI did a quick\
    \ benchmark on the first two solutions on 100000 iterations. Your solution took\
    \ about 1.7 seconds. My solution took about 1.2 seconds. On my computer I tested\
    \ both solutions ten times each. My solution was the fastest with my laptop and\
    \ your solution was the slowest. Neither of your solutions was the slowest on\
    \ the first test run. How is that?\n<|/ c |>\n<| c |>\nThat's because they both\
    \ use a different approach, both of them use preg_replace_callback and each of\
    \ them is using a different approach. My solution is using a custom callback while\
    \ yours is using a custom callback and you also used a custom callback and I used\
    \ the one from your question. But in both cases the speed is similar because both\
    \ solutions are similar.\n<|/ c |>\n<| c |>\nHm, you're right. That's interesting\
    \ because I thought that my approach was faster than yours, too.\n<|/ c |>\n<|\
    \ a dscore=0 |>\nHere's an alternative that uses preg_replace_callback\n<code>",
  "  $result = array();\n  $words = explode(' ', $test);\n  foreach ($words as $word)\
    \ {\n    $count = (isset($result[$word])) ? $result[$word] : 0;\n    $result[$word]\
    \ = ++$count;\n  }\n  return $result;\n}\n</code>\n<|/ a tags=php dscore=0 |>\n\
    <| c |>\nThanks for your solution and I see that you added the comments, but I\
    \ didn't ask to do it with built-in functions, so I added my own code. Thank you\
    \ for your help!\n<|/ c |>\n<| c |>\n: No, your code uses *incorrect* solutions.\
    \ Please see my answer for details. I've improved it (added some explanation,\
    \ fixed some bugs) and wrote a test case. Your code does not do what you're asking\
    \ for.\n<|/ c |>\n<| c |>\nI'm sorry, but I don't see how your code is wrong.\
    \ Could you please elaborate more and explain why you think your code is not correct?\n\
    <|/ c |>\n<| c |>\n: I added some comments to your code. Hope this helps.\n<|/\
    \ c |>\n<| a dscore=0 |>\n<code>\n$histogram = array();\nforeach ($values as $value)\
    \ {\n    $histogram[$value] = (isset($histogram[$value]) ? $histogram[$value]\
    \ + 1 : 1);\n}\n</code>\n<|/ a tags=php |>\n<| c |>\nPlease add a short explanation\
    \ to your answer.\n<|/ c |>\n<| c |>\nThis doesn't answer the question: OP wants\
    \ *words* to be sorted as they occur in the string: *the words with the most occurrences\
    \ should be first*.\n<|/ c |>\n<| a dscore=0 |>\nHere's a nice one-liner I wrote\
    \ that counts words by frequency. I'm sure it could be improved:\n<code>", "\t\
    $histogram = array();\n\t$tests = str_split($test);\n\tforeach($tests as $test)\
    \ {\n\t\t$letter = $test;\n\t\tif(array_key_exists($letter, $histogram)) {\n\t\
    \t\t$histogram[$letter] += 1;\n\t\t} else {\n\t\t\t$histogram[$letter] = 1;\n\t\
    \t}\n\t}\n\tasort($histogram);\n\t$result = array();\n\tforeach($histogram as\
    \ $letter => $count) {\n\t\t$result[substr($letter, 0, 1)] = $count;\n\t}\n\t\
    return $result;\n}\n", "    $histogram = array();\n    foreach (str_split($test)\
    \ as $letter) {\n        if (isset($histogram[$letter])) {\n            $histogram[$letter]\
    \ = $histogram[$letter] + 1;\n        } else {\n            $histogram[$letter]\
    \ = 1;\n        }\n    }\n    $result = array();\n    foreach ($histogram as $letter\
    \ => $count) {\n        if ($count > 1) {\n            $result[$letter] = $count;\n\
    \        }\n    }\n    return $result;\n}\n", "  if (empty($test)) {\n    return\
    \ array();\n  }\n\n  $histogram = array();\n  $letters = str_split($test);\n\n\
    \  foreach ($letters as $letter) {\n    if (isset($histogram[$letter])) {\n  \
    \    $histogram[$letter]++;\n    } else {\n      $histogram[$letter] = 1;\n  \
    \  }\n  }\n\n  arsort($histogram);\n\n  return $histogram;\n}\n", "  $res = array();\n\
    \  $letters = preg_split('/\\s+/', $test);\n  foreach ($letters as $letter) {\n\
    \    $letter = $letter.toLowerCase();\n    if (isset($res[$letter])) {\n     \
    \ $res[$letter]++;\n    } else {\n      $res[$letter] = 1;\n    }\n  }\n  return\
    \ $res;\n}\n", "    $histogram = array();\n    $letters = str_split($test);\n\n\
    \    foreach ($letters as $letter) {\n        if (isset($histogram[$letter]))\
    \ {\n            $histogram[$letter]++;\n        } else {\n            $histogram[$letter]\
    \ = 1;\n        }\n    }\n\n    krsort($histogram);\n\n    return $histogram;\n\
    }\n", "    // The array will have the letter as the key and the number of repetitions\n\
    \    // as the value.\n    $histogram = array();\n    // Split the test string\
    \ by spaces.\n    $words = preg_split('/ /u', $test);\n    // For each word in\
    \ the test string, try to increment the counter.\n    foreach ($words as $word)\
    \ {\n        // If it exists, increment the counter.\n        if (array_key_exists($word,\
    \ $histogram)) {\n            $histogram[$word]++;\n        } else {\n       \
    \     // If it doesn't, add it with a count of 1.\n            $histogram[$word]\
    \ = 1;\n        }\n    }\n\n    // Return the histogram array.\n    return $histogram;\n\
    }\n", "  $histogram = array();\n  $chars = preg_split('//', $test, -1, PREG_SPLIT_NO_EMPTY);\n\
    \  foreach ($chars as $c) {\n    $histogram[$c] = isset($histogram[$c]) ? $histogram[$c]\
    \ + 1 : 1;\n  }\n  return $histogram;\n}\n", "  $letters = preg_split('//u', $test,\
    \ -1, PREG_SPLIT_NO_EMPTY);\n  $histogram = array();\n  foreach ($letters as $letter)\
    \ {\n    if (isset($histogram[$letter])) {\n      $histogram[$letter] += 1;\n\
    \    } else {\n      $histogram[$letter] = 1;\n    }\n  }\n  return $histogram;\n\
    }\n", "    $histogram = array();\n    foreach (str_split($test) as $letter) {\n\
    \        if (isset($histogram[$letter])) {\n            $histogram[$letter]++;\n\
    \        } else {\n            $histogram[$letter] = 1;\n        }\n    }\n\n\
    \    return $histogram;\n}\n"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
