name: HumanEval_156_int_to_mini_roman
language: php
prompt: "<?php\n// Given a positive integer, obtain its roman numeral equivalent as\
  \ a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n\
  // Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n\
  // \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunction int_to_mini_roman($number)\
  \ {\n"
tests: "function candidate(...$args) {\n    return int_to_mini_roman(...$args);\n\
  }\n\nfunction test(): void {\n    if (candidate(19) !== \"xix\") { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(152) !== \"clii\") { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(251) !== \"ccli\") { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(426) !== \"cdxxvi\") { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(500) !== \"d\") { throw new Exception(\"Test\
  \ failed!\"); }\n    if (candidate(1) !== \"i\") { throw new Exception(\"Test failed!\"\
  ); }\n    if (candidate(4) !== \"iv\") { throw new Exception(\"Test failed!\");\
  \ }\n    if (candidate(43) !== \"xliii\") { throw new Exception(\"Test failed!\"\
  ); }\n    if (candidate(90) !== \"xc\") { throw new Exception(\"Test failed!\");\
  \ }\n    if (candidate(94) !== \"xciv\") { throw new Exception(\"Test failed!\"\
  ); }\n    if (candidate(532) !== \"dxxxii\") { throw new Exception(\"Test failed!\"\
  ); }\n    if (candidate(900) !== \"cm\") { throw new Exception(\"Test failed!\"\
  ); }\n    if (candidate(994) !== \"cmxciv\") { throw new Exception(\"Test failed!\"\
  ); }\n    if (candidate(1000) !== \"m\") { throw new Exception(\"Test failed!\"\
  ); }\n}\n\ntest();"
completions: ["    $int_str = dechex($number);\n\n    // Convert from decimal to base\
    \ 36\n    $int_str = str_replace('a', '', dechex($number - 10));\n    $int_str\
    \ = str_replace('b', '', dechex($number - 10));\n    $int_str = str_replace('c',\
    \ '', dechex($number - 10));\n    $int_str = str_replace('d', '', dechex($number\
    \ - 10));\n    $int_str = str_replace('e', '', dechex($number - 10));\n    $int_str\
    \ = str_replace('f', '', dechex($number - 10));\n    $int_str = str_replace('g',\
    \ '', dechex($number - 10));\n    $int_str = str_replace('h', '', dechex($number\
    \ - 10));\n    $int_str = str_replace('i', 'xx', dechex($number - 10));\n    $int_str\
    \ = str_replace('j', 'xxx', dechex($number - 10));\n    $int_str = str_replace('k',\
    \ 'xxx', dechex($number - 10));\n    $int_str = str_replace('l', 'xxx', dechex($number\
    \ - 10));\n    $int_str = str_replace('m', 'xxx', dechex($number - 10));\n   \
    \ $int_str = str_replace('n', 'xxx', dechex($number - 10));\n    $int_str = str_replace('o',\
    \ 'xxx', dechex($number - 10));\n    $int_str = str_replace('p', 'xxx', dechex($number\
    \ - 10));\n    $int_str = str_replace('q', 'xxx', dechex($number - 10));\n   \
    \ $int_str = str_replace('r', 'xxx', dechex($number - 10));\n    $int_str = str_replace('s',\
    \ 'xxx', dechex($number - 10));\n    $int_str = str_replace('t', 'xxx', dechex($number\
    \ - 10));\n    $int_str = str_replace('u', 'xxx', dechex($number - 10));\n   \
    \ $int_str = str_replace('v', 'xxx', dechex($number - 10));\n    $int_str = str_replace('w',\
    \ 'xxx', dechex($number - 10));\n    $int_str = str_replace('x', 'xxx', dechex($number\
    \ - 10));\n    $int_str = str_replace('y', 'xxx', dechex($number - 10));\n   \
    \ $int_str = str_replace('z', 'xxx', dechex($number - 10));\n\n    // Convert\
    \ from base 36 to base 10\n    $int_str = str_split($int_str, strlen($int_str)\
    \ - ", "  if ($number < 1 || $number > 1000) {\n    return null;\n  }\n  $result\
    \ = '';\n  for ($i = 1; $i <= $number; $i++) {\n    $last_digit = floor($number\
    \ / $i);\n    $rest = floor($number % $i);\n    if ($last_digit > 0) {\n     \
    \ $result .= roman_numeral($last_digit);\n    }\n    if ($rest > 0) {\n      $result\
    \ .= roman_numeral($rest);\n    }\n  }\n  return strtolower($result);\n}\n", " \
    \ $roman = \"\";\n\n  for ($i = 0; $i < $number; $i++) {\n    $n = $number % 1000;\n\
    \    $number = floor($number / 1000);\n    $roman .= romanDigit($n);\n  }\n\n\
    \  return $roman;\n}\n", "  if ($number < 1 || $number > 1000) throw new RangeException;\n\
    \  if ($number == 100) return 'M';\n  if ($number == 50) return 'D';\n  if ($number\
    \ == 4) return 'C';\n  if ($number == 10) return 'L';\n  if ($number == 9) return\
    \ 'X';\n\n  $numstr = '';\n  for ($i = 0; $i < $number; $i++) {\n    $numstr .=\
    \ int_to_roman($i);\n  }\n  return $numstr;\n}\n", "  // Convert integer to its\
    \ binary equivalent.\n  // For example: 194 -> \"1100100\".\n  // For any number\
    \ above 999, first divide it by 1000 and then multiply it by 10 (1000\n  // has\
    \ 10 binary digits).\n  $binary_number = decbin($number);\n  $binary_number =\
    \ str_pad($binary_number, 8, \"0\", STR_PAD_LEFT);\n  // Split the binary number\
    \ into groups of three digits, where the first\n  // digit of the group is the\
    \ most-significant digit.\n  $binary_number = preg_split('//', $binary_number);\n\
    \  // We must take care of special cases:\n  // If the binary number is only one\
    \ or two digits, we should return it as is.\n  // If the binary number is 3 digits\
    \ or more, we should add \"M\" to the return\n  // string, to indicate that the\
    \ number should be treated as a roman\n  // numeral.\n  // If the binary number\
    \ is 4 digits or more, we should add \"CM\" to the return\n  // string, to indicate\
    \ that the number should be treated as a cyrilic\n  // numeral.\n  if (count($binary_number)\
    \ <= 1) {\n    return $binary_number;\n  }\n  if (count($binary_number) == 3)\
    \ {\n    return $binary_number[0] . $binary_number[1] . \"M\";\n  }\n  return\
    \ $binary_number[0] . $binary_number[1] . $binary_number[2] . \"CM\";\n}\n", " \
    \   $roman = '';\n    $number = abs($number);\n    $integer = floor($number);\n\
    \n    for ($i = 0; $integer >= 1000; $i++) {\n        $roman .= 'm';\n       \
    \ $integer -= 1000;\n    }\n\n    for ($i = 0; $integer >= 900; $i++) {\n    \
    \    $roman .= 'c';\n        $integer -= 900;\n    }\n\n    for ($i = 0; $integer\
    \ >= 500; $i++) {\n        $roman .= 'l';\n        $integer -= 500;\n    }\n\n\
    \    for ($i = 0; $integer >= 400; $i++) {\n        $roman .= 'x';\n        $integer\
    \ -= 400;\n    }\n\n    for ($i = 0; $integer >= 100; $i++) {\n        $roman\
    \ .= 'v';\n        $integer -= 100;\n    }\n\n    if ($i == 0) {\n        $roman\
    \ .= 'f';\n    }\n\n    for ($i = 0; $integer >= 50; $i++) {\n        $roman .=\
    \ 'i';\n        $integer -= 50;\n    }\n\n    if ($i == 0) {\n        $roman .=\
    \ 'v';\n    }\n\n    if ($i == 0) {\n        $roman .= 'i';\n    }\n\n    if ($number\
    \ > 1000) {\n        $roman .= 'n';\n        $number -= 1000;\n    }\n\n    return\
    \ $roman;\n}\n\n/**\n * Given a positive integer, convert it to its English equivalent,\
    \ as a\n * string.\n * Restrictions: 1 <= num <= 1000000000\n * Examples:\n *\
    \ >>> int_to_english(12)\n * \"twelve\"\n * >>> int_to_english(22)\n * \"twenty\
    \ two\"\n * >>> int_to_english(101)\n * \"one hundred one\"\n * >>> int_to_english(101)\n\
    \ * \"one hundred one\"\n */", "\t$roman = '';\n\tdo {\n\t\t$div = $number % 1000;\n\
    \t\t$number -= $div;\n\t\t$roman .= $div_in_roman[$div];\n\t} while ($number >\
    \ 0);\n\treturn $roman;\n}\n", "    if (!is_numeric($number)) {\n        throw\
    \ new \\InvalidArgumentException(\n            sprintf('Not a valid number: \"\
    %s\"', (string) $number)\n        );\n    }\n\n    // Roman numerals are typically\
    \ not consecutive.\n    // There is an additional restriction for roman numerals\
    \ starting from I,\n    // for which no equivalent in lower case exists.\n   \
    \ // See https://en.wikipedia.org/wiki/Roman_numerals#Additional_restrictions\n\
    \    if ($number < 1 || $number > 3999) {\n        throw new \\InvalidArgumentException(\n\
    \            sprintf('Not a valid number: \"%s\"', (string) $number)\n       \
    \ );\n    }\n\n    // Roman numerals need special handling.\n    // They may start\
    \ from I, for which no equivalent in lower case exists.\n    // See https://en.wikipedia.org/wiki/Roman_numerals#Additional_restrictions\n\
    \    if ($number < 500) {\n        return chr(ceil(($number - 1) / 4)) + chr(floor($number\
    \ / 4));\n    }\n\n    if ($number < 1000) {\n        return chr(ceil(($number\
    \ - 1) / 100)) .\n            chr(floor(($number - 1) % 100 / 10)) .\n       \
    \     chr(floor(($number - 1) % 100 % 10));\n    }\n\n    // Roman numerals always\
    \ end in V.\n    // See https://en.wikipedia.org/wiki/Roman_numerals\n    return\
    \ chr(ceil(($number - 1) / 400)) + chr(floor(($number - 1) % 400 / 10)) .\n  \
    \      chr(floor(($number - 1) % 400 % 10));\n}\n", "  global $MINI_ROMAN_ALPHABET;\n\
    \n  $out = '';\n  for ($i = 1; $i <= 1000; $i++) {\n    $out = $MINI_ROMAN_ALPHABET[$i\
    \ - 1] * $number + $out;\n    if ($number >= $i) {\n      break;\n    }\n  }\n\
    \n  return strtolower($out);\n}\n\n\n/**\n * Create a number from its unicode\
    \ code point representation.\n * Code points are strings like 'U+E5AB'.\n * Uses\
    \ mb_convert_kana() to convert.\n *\n * @param $code (string) Unicode code point\n\
    \ * @return (string) Roman number\n * @access private\n */", "  $roman = '';\n\
    \  while ($number >= 1000) {\n    $roman .= int_to_mini_roman($number / 100) .\
    \ int_to_mini_roman($number % 100);\n    $number = $number % 1000;\n  }\n  return\
    \ $roman . int_to_mini_roman($number);\n}\n", "  $roman = '';\n  for ($i = 0;\
    \ $i < $number; $i++) {\n    $roman .= int_to_roman($number);\n  }\n  return strtolower($roman);\n\
    }\n", "  if ($number < 1 || $number > 3999) {\n    return null;\n  }\n\n  $roman_numeral\
    \ = array();\n  for ($i = 0; $i < $number; $i++) {\n    $roman_numeral[$i] = roman_numeral_value($i);\n\
    \  }\n\n  return implode('', $roman_numeral);\n}\n", "    $roman = \"\";\n   \
    \ $k = -1;\n    $numeral = strval($number);\n\n    // If $number is negative,\
    \ add 'i' before returning it.\n    if ($number < 0) {\n        $numeral = \"\
    i$numeral\";\n    }\n\n    // Add an extra i if numeral is even, e.g. \"i6\",\
    \ \"iII\" or \"i3\"\n    if ($number{0} == 1) {\n        $numeral = \"i$numeral\"\
    ;\n    }\n\n    // Add an extra i if numeral is larger than 9, e.g. \"i10\" instead\
    \ of \"iIX\"\n    if (mb_strlen($numeral) > 1) {\n        $numeral = \"i$numeral\"\
    ;\n    }\n\n    // For every integer from 1 to 9, add a 'm' after the first 'i'\n\
    \    for ($i = 1; $i <= mb_strlen($numeral); $i++) {\n        if ($i == mb_strlen($numeral)\
    \ - 1) {\n            $roman .= \"m$numeral\";\n            break;\n        }\n\
    \        $roman .= \"m$numeral\";\n        if ($i == (mb_strlen($numeral) - 2))\
    \ {\n            $roman .= \"m\";\n        }\n    }\n\n    // If the number is\
    \ bigger than 9, add a 'f' before the 'i's\n    if (mb_strlen($numeral) > 9) {\n\
    \        $roman .= \"f$numeral\";\n    }\n\n    // If $number was negative, negate\
    \ the roman numeral and add an 'i'\n    if ($number < 0) {\n        $roman = \"\
    i$roman\";\n    }\n    return $roman;\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\n\
    The same can be done with the PHP function `roman_to_int`:\nhttps://www.php.net/manual/en/function.roman-numeral.php\n\
    <|/ c |>\n<| c |>\nJust to mention the function roman_to_int is deprecated and\
    \ it's better to use roman_numeral_to_int.\n<|/ c |>\n<| c |>\nThis should be\
    \ the top answer. This is the only one that actually uses the modern string formatting\
    \ methods and should be the accepted answer.\n<|/ c |>\n<| c |>\nI like the fact\
    \ that the only reason to use \"f\" is to prevent double counting if there are\
    \ extra spaces inside the string. Very nice! You just saved me a bunch of time.\n\
    <|/ c |>\n<| c |>\nWhat about for integers over 1000?\n<|/ c |>\n<| a tags=php,php-7\
    \ |>\nUsing a map like this is probably ", "  return roman_to_int($number);\n\
    }\n", "    if ($number < 1 || $number > 1000)\n        return false;\n    if ($number\
    \ == 0)\n        return 'zero';\n    $roman = array('M' => 1000, 'D' => 500, 'C'\
    \ => 100, 'L' => 50, 'X' => 10, 'V' => 5, 'I' => 1);\n    $decimals = $number\
    \ - (int) floor($number);\n    $numeral = $roman[substr($decimals, 0, 2)];\n \
    \   return str_pad($numeral, strlen($decimals), '0', STR_PAD_LEFT);\n}", "  $roman\
    \ = '';\n  for ($i = 0; $i < $number; $i++) {\n    $roman .= int_to_roman($i);\n\
    \  }\n  return strtolower($roman);\n}\n", "  $str = '';\n  for ($i = 0; $i < $number;\
    \ $i++) {\n    $str .= chr(roman($i));\n  }\n  return strtolower($str);\n}", " \
    \ if ($number <= 0)\n    return null;\n  if ($number < 10)\n    return $number;\n\
    \  if ($number < 26)\n    return int_to_mini_roman($number - 10) + int_to_mini_roman(1);\n\
    \  $roman = '';\n  if ($number >= 1000) {\n    $roman = int_to_mini_roman($number\
    \ / 100);\n    $roman .= int_to_mini_roman($number / 10) % 10 + int_to_mini_roman($number\
    \ % 10);\n  }\n  return $roman;\n}", "  // Initialize variables\n  $roman = '';\n\
    \  $suffix = '';\n  // Get the integer part and the suffix\n  $integer = $number\
    \ - intval($number);\n  // Determine the suffix\n  switch (true) {\n    case $integer\
    \ < 4:\n      $suffix = 'IV';\n      break;\n    case $integer < 9:\n      $suffix\
    \ = 'IX';\n      break;\n    case $integer < 14:\n      $suffix = 'XL';\n    \
    \  break;\n    case $integer < 19:\n      $suffix = 'XC';\n      break;\n    case\
    \ $integer < 24:\n      $suffix = 'CD';\n      break;\n    case $integer < 29:\n\
    \      $suffix = 'CM';\n      break;\n    case $integer < 34:\n      $suffix =\
    \ 'M';\n      break;\n    case $integer < 39:\n      $suffix = 'D';\n      break;\n\
    \    case $integer < 44:\n      $suffix = 'CD';\n      break;\n    case $integer\
    \ < 49:\n      $suffix = 'CM';\n      break;\n    case $integer < 54:\n      $suffix\
    \ = 'M';\n      break;\n    case $integer < 59:\n      $suffix = 'D';\n      break;\n\
    \    case $integer < 64:\n      $suffix = 'CD';\n      break;\n    case $integer\
    \ < 69:\n      $suffix = 'CM';\n      break;\n    case $integer < 74:\n      $suffix\
    \ = 'M';\n      break;\n    case $integer < 79:\n      $suffix = 'D';\n      break;\n\
    \    case $integer < 84:\n      $suffix = 'CD';\n      break;\n    case $integer\
    \ < 89:\n      $suffix = 'CM';\n      break;\n    case $integer < 94:\n      $suffix\
    \ = 'M';\n      break;\n    case $integer < 99:\n      $suffix = 'D';\n      break;\n\
    \    case $integer < 104:\n      $suffix = 'CD';\n      break;\n    case $integer\
    \ < 109:\n      $suffix = 'CM';\n      break;\n    case $integer < 114:\n    \
    \  $suffix = 'M';\n      break;\n    case $integer < 119:\n      $suffix = 'D';\n\
    \      break;\n    case $integer < 124:\n      $suffix = 'CD';\n      break;\n\
    \    case $integer < 129:\n      $suffix = 'CM';\n      break;\n    case $integer\
    \ < 134:\n      $suffix = 'M';\n      break;\n    case $integer < 139:\n     \
    \ $suffix = 'D';\n      break;\n    case $integer < 144:\n      $suffix = 'CD';\n\
    \      break;\n    case $integer < 149:\n      $suffix = 'CM';\n      break;\n\
    \    case $integer < 154:\n      $suffix = 'M';\n      break;\n    case $integer\
    \ < 159:\n      $suffix = '", "    $result = '';\n\n    // Handle negatives.\n\
    \    if ($number < 0) {\n        $number = -$number;\n        $sign = '-';\n \
    \   } else {\n        $sign = '';\n    }\n\n    // Determine the minimum number\
    \ of digits to format.\n    $numDigits = abs($number);\n    $minDigits = min(3,\
    \ $numDigits);\n\n    // Round up to the minimum number of digits.\n    $number\
    \ = ceil($number / 10**$minDigits) * 10**$minDigits;\n\n    // Round down to the\
    \ nearest multiple of 1000:\n    $number = floor($number/1000) * 1000;\n\n   \
    \ // Convert to the largest numeral unit that will fit.\n    while (preg_match('/\\\
    b(M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})|I{0,3})\\b/', $number,\
    \ $match)) {\n        $minDigits++;\n        $number = floor($number / 10**$minDigits)\
    \ * 10**$minDigits;\n    }\n\n    // Remove any trailing zeros:\n    $number =\
    \ rtrim($number, '0');\n\n    // Output the numeral system name.\n    $numeralSystem\
    \ = \"\";\n    if ($numDigits == 3) {\n        $numeralSystem = \"c\";\n    }\
    \ elseif ($numDigits == 4) {\n        $numeralSystem = \"cc\";\n    } elseif ($numDigits\
    \ == 6) {\n        $numeralSystem = \"cd\";\n    } elseif ($numDigits == 9) {\n\
    \        $numeralSystem = \"ccc\";\n    } elseif ($numDigits == 10) {\n      \
    \  $numeralSystem = \"cdc\";\n    } elseif ($numDigits == 12) {\n        $numeralSystem\
    \ = \"ccc\";\n        $number = rtrim($number, '0');\n    } elseif ($numDigits\
    \ == 14) {\n        $numeralSystem = \"ccc\";\n        $number = rtrim($number,\
    \ '0');\n    } elseif ($numDigits == 16) {\n        $numeralSystem = \"cdc\";\n\
    \    }\n\n    // Output the numeral.\n    $result = \"$sign $number$numeralSystem\"\
    ;\n\n    return $result;\n}\n</code>\n<|/ a tags=php,roman |>\n<| c |>\nThanks\
    \ for the code, works great for most of the numbers but fails for the number 144\
    \ which should be IV. My code should handle this case.\n<|/ c |>\n<| c |>\nI fixed\
    \ this bug in my code.  There was a mistake in the first line which I corrected.\
    \  Now it should work for ", "  $result = '';\n\n  while (true) {\n    $remainder\
    \ = $number % 10;\n    $number = floor($number / 10);\n    if ($remainder ===\
    \ 0) {\n      $result = $result . int_to_roman_digit($number);\n      break;\n\
    \    }\n\n    $result = $result . int_to_roman_digit($remainder) . roman_digit_to_int($remainder);\n\
    \  }\n\n  return $result;\n}\n", "  $roman = \"\";\n  $base = array(\"M\", \"\
    CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\"\
    , \"I\");\n  if ($number < 0 || $number > 1000) return false;\n  for ($i = strlen($roman)\
    \ - 1; $i > 0; $i -= 1) {\n    $count = $number % $base[$i];\n    $roman .= $base[$i];\n\
    \    if ($count == 0 && $i > 0) {\n      $roman = $roman.$base[$i];\n      break;\n\
    \    }\n    $number -= $count;\n  }\n  return $roman;\n}\n", "  if ($number <\
    \ 1 || $number > 1000)\n    return 'Error!';\n  $roman = '';\n  while ($number\
    \ > 1000) {\n    $roman .= int_to_roman($number % 1000).' ';\n    $number /= 1000;\n\
    \  }\n  $roman .= int_to_roman($number);\n  return $roman;\n}\n", "  $result =\
    \ '';\n  for ($i = 0; $i < strlen($number); $i++) {\n    $result .= int_to_roman($number[$i]);\n\
    \  }\n\n  return strtolower($result);\n}\n", "    $roman = '';\n    while (0 <\
    \ $number) {\n        if ($number >= 1000) {\n            $roman .= 'M';\n   \
    \         $number = $number / 1000;\n        } else {\n            $roman .= $roman_name[$number\
    \ % 10];\n            $number = floor($number / 10);\n        }\n    }\n    return\
    \ strtolower($roman);\n}", "  static $roman_numerals = array(\n    100  => \"\
    M\", // 1000\n    9    => \"CM\", // 900\n    6    => \"D\", // 600\n    5   \
    \ => \"CD\", // 500\n    4    => \"C\", // 400\n    3    => \"XC\", // 300\n \
    \   2    => \"L\", // 200\n    1    => \"XL\", // 100\n    0    => \"X\", // 100\n\
    \  );\n\n  if (!$number)\n    return \"\";\n\n  if ($number < 0 || $number >=\
    \ 1000)\n    return \"\";\n\n  // Find highest set bit and remove it from the\
    \ number\n  $number = ($number & -$number) + 1;\n  // Divide all following numbers\
    \ by that bit\n  $number = intval($number / 5) * 5 + intval($number / 10);\n\n\
    \  // Convert it to an array\n  $result = [];\n  while (round($number, 2) == $number)\
    \ {\n    $result[] = $roman_numerals[intval($number / 10)];\n    $number %= 10;\n\
    \  }\n\n  return array_reverse($result);\n}\n</code>\n<|/ a tags=php,math,roman-numerals\
    \ |>\n<| c |>\nI feel like this is more difficult than it needs to be.  The problem\
    \ seems to be that `1001` should be `MCMXCIX` rather than `MMCCCXIV`.\n<|/ c |>\n\
    <| c |>\nYour comment is totally valid and I agree with you. I edited my answer\
    \ to include a method of doing this with some additional restrictions. I hope\
    \ it helps.\n<|/ c |>\n<| c |>\nThis is incorrect. `1001` should be `MMCCCXIV`.\
    \ Your solution only works with multiples of ten.\n<|/ c |>\n<| a tags=php,math,roman-numerals\
    \ |>\n<code>\n<?php\n", "\t$result = \"\";\n\tdo {\n\t\t$rom = ($number % 1000)\
    \ * 100;\n\t\t$number -= $rom;\n\t\t$result += roman_numeral_to_alphabet($rom);\n\
    \t} while ($number > 0);\n\treturn $result;\n}", "    // $return = \"\";\n   \
    \ // $num = $number;\n    // $first = $num % 10;\n    // $rest = ($num - $first)\
    \ / 10;\n    // if ($rest == 0) {\n    //     return $first;\n    // }\n    //\
    \ $return = $first . int_to_mini_roman($rest);\n    // if ($return.endsWith(\"\
    .\")) {\n    //     $return = substr($return, 0, -1);\n    // }\n    // return\
    \ $return;\n}\n", "\tif ($number < 1 || $number > 1000) return false;\n\t$roman_number\
    \ = array();\n\t$roman_number['M'] = 1000; $roman_number['D'] = 500; $roman_number['C']\
    \ = 100;\n\t$roman_number['L'] = 50; $roman_number['XC'] = 10;\n\t$roman_number['XL']\
    \ = 5; $roman_number['IX'] = 1;\n\t$roman_number['IV'] = 4; $roman_number['I']\
    \ = 1;\n\twhile (true) {\n\t\tif ($number < $roman_number['M']) break;\n\t\t$number\
    \ -= $roman_number['M'];\n\t\t$roman_number['M'] /= 10;\n\t\t$roman_number['I']\
    \ /= 10;\n\t}\n\twhile (true) {\n\t\tif ($number < $roman_number['D']) break;\n\
    \t\t$number -= $roman_number['D'];\n\t\t$roman_number['D'] /= 10;\n\t\t$roman_number['XC']\
    \ /= 10;\n\t}\n\twhile (true) {\n\t\tif ($number < $roman_number['C']) break;\n\
    \t\t$number -= $roman_number['C'];\n\t\t$roman_number['C'] /= 10;\n\t\t$roman_number['XL']\
    \ /= 10;\n\t\t$roman_number['XC'] /= 10;\n\t}\n\twhile (true) {\n\t\tif ($number\
    \ < $roman_number['L']) break;\n\t\t$number -= $roman_number['L'];\n\t\t$roman_number['L']\
    \ /= 10;\n\t\t$roman_number['XL'] /= 10;\n\t\t$roman_number['IX'] /= 10;\n\t}\n\
    \twhile (true) {\n\t\tif ($number < $roman_number['XC']) break;\n\t\t$number -=\
    \ $roman_number['XC'];\n\t\t$roman_number['XC'] /= 10;\n\t\t$roman_number['IX']\
    \ /= 10;\n\t\t$roman_number['IV'] /= 10;\n\t}\n\twhile (true) {\n\t\tif ($number\
    \ < $roman_number['XL']) break;\n\t\t$number -= $roman_number['XL'];\n\t\t$roman_number['IX']\
    \ /= 10;\n\t\t$roman_number['IV'] /= 10;\n\t\t$roman_number['I'] /= 10;\n\t}\n\
    \twhile (true) {\n\t\tif ($number < $roman_number['IX']) break;\n\t\t$number -=\
    \ $roman_number['IX'];\n\t\t$roman_number['I'] /= 10;", "  // Validate input value\n\
    \  $number = intval($number);\n  if (!is_integer($number)) {\n    return false;\n\
    \  }\n  if ($number < 1 || $number > 1000) {\n    return false;\n  }\n\n  // Initialize\
    \ an empty array of roman numerals and corresponding values\n  $roman = array();\n\
    \  $value = array('M' => 1000,\n                 'CM' => 900,\n              \
    \   'D' => 500,\n                 'CD' => 400,\n                 'C' => 100,\n\
    \                 'XC' => 90,\n                 'L' => 50,\n                 'XL'\
    \ => 40,\n                 'X' => 10,\n                 'IX' => 9,\n         \
    \        'V' => 5,\n                 'IV' => 4,\n                 'I' => 1);\n\
    \n  // Add each numeral to the array\n  for ($i = 0; $i <= 9; $i++) {\n    $roman[$value[$i]]\
    \ = $i;\n  }\n\n  // Add the tens\n  for ($i = 0; $i < 10; $i++) {\n    $roman[$value[$i]\
    \ * 10] = $i;\n  }\n\n  // Add the hundreds\n  for ($i = 0; $i < 100; $i++) {\n\
    \    $roman[$value[$i] * 100] = $i;\n  }\n\n  // Add the thousands\n  $roman[$value['M']\
    \ / 10] = 'M';\n  $roman[$value['M'] % 10] = 'MM';\n\n  // Add the hundreds\n\
    \  for ($i = 0; $i < 100; $i++) {\n    $roman[$value[$i] * 1000] = str_pad($i,\
    \ 3, '0', STR_PAD_LEFT);\n  }\n\n  // Pad the roman numeral\n  $roman = str_pad($roman,\
    \ 3, '0', STR_PAD_LEFT);\n\n  // Return the resulting roman numeral\n  return\
    \ strtolower($roman);\n}\n</code>\n<|/ a tags=php dscore=4 |>\n<| c |>\nWhat is\
    \ the purpose of `$roman[$value[$i]] = $i;` in your first for loop?\n<|/ c |>\n\
    <| c |>\nThe $value array was meant to map the numbers to their corresponding\
    \ romannumerals. If you had a dictionary where you could look up the number by\
    \ its roman numeral, this was a way to go. Not necessary in this case, as PHP\
    \ already provides them :)\n<|/ c |>\n<| c |>\nTo be honest, I never knew that\
    \ the array could be used like that to map numbers to romans.\n<|/ c |>\n<| c\
    \ |>\nVery impressive.  But doesn't this require a lot of RAM since this array\
    \ is just too big? On a ", "  // TODO: Implement int_to_mini_roman() here\n\n\
    }\n", "  $str = '';\n  $k = 1000;\n  do {\n    $str .= (1000 - $k) . chr($number\
    \ % $k);\n    $number = floor($number / $k);\n    $k--;\n  } while (0 < $number);\n\
    \  return strtolower($str);\n}\n", "    $roman = '';\n\n    for ($i = 0; $i <\
    \ $number; $i++) {\n        $num = $number-$i;\n        $r = strtoupper(base_convert($num,\
    \ 10, 2));\n        $rlen = strlen($r);\n\n        $roman .= $r;\n        if ($i\
    \ < $number - 1) {\n            $roman .= 'i';\n        }\n    }\n\n    return\
    \ $roman;\n}\n", "  $roman = '';\n  for ($i = 0; $i < $number; $i++) {\n    $roman\
    \ .= roman2int($i);\n  }\n  return strtolower($roman);\n}\n", "  if ($number <\
    \ 1 || $number > 1000) return false;\n\n  $num_roman = \"\";\n  for ($i = 0; $i\
    \ < $number; $i++) {\n    $num_roman .= roman($i);\n  }\n\n  return strtolower($num_roman);\n\
    }", "  $result = \"\";\n  if ($number == 0) {\n    return \"0\";\n  }\n  for ($i\
    \ = 0; $i < count($roman_numbers); $i++) {\n    if ($number < $roman_numbers[$i])\
    \ {\n      break;\n    }\n    if ($i == count($roman_numbers) - 1) {\n      if\
    \ ($number == $roman_numbers[$i]) {\n        $result .= $roman_numbers[$i];\n\
    \      }\n      break;\n    }\n    if ($number > $roman_numbers[$i]) {\n     \
    \ $result += $roman_numbers[$i + 1];\n      break;\n    }\n  }\n  return $result;\n\
    }\n", "    $roman = \"\";\n    do {\n        if ($number >= 1000) {\n        \
    \    $roman .= 'M';\n            $number = $number % 1000;\n        }\n      \
    \  $roman .= $number%10;\n        $number = $number / 10;\n    } while ($number\
    \ > 0);\n    return strtolower($roman);\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\n\
    This works, but the output is not in lowercase (as it should be for roman numerals).\n\
    <|/ c |>\n<| c |>\nI thought this was the case but after testing with my examples,\
    \ it seems that it's not quite right. `int_to_mini_roman(152)` returns `\"CLi\"\
    ` instead of `\"cLi\"`. Also, this is a problem with Roman numerals (the OP is\
    \ talking about Roman numerals) and not a problem with the code.\n<|/ c |>\n<|\
    \ c |>\nI see you edited your answer. I think the code in your edit is pretty\
    \ much identical to the one in my answer, and it still doesn't work. I'm guessing\
    \ you edited it to make another function call that's different. I'll have to try\
    \ it out and see what happens.\n<|/ c |>\n<| c |>\n: Nope, my edit was to change\
    \ `int_to_roman($number)` to `int_to_mini_roman($number)`. If I were to change\
    \ my edit again, I wouldn't need to put that code in my answer anymore (as I already\
    \ had the function definition in my edit).\n<|/ c |>\n<| c |>\nI realized that\
    \ the problem was that my \"numbers\" were actually `int`, not `string`. I fixed\
    \ my original code accordingly.\n<|/ c |>\n<| a dscore=4 tags=php |>\nHere's a\
    \ quick function that converts a number into it's roman equivalent (all lowercase):\n\
    <code>", "  $roman_roman = array(\"I\", \"IV\", \"III\", \"II\", \"V\", \"VI\"\
    , \"VII\", \"IIII\");\n  $roman = '';\n  foreach ($roman_roman as $roman => $number)\
    \ {\n    $number = $number / 10;\n    if ($number >= $number) {\n      $roman\
    \ = $roman;\n    }\n  }\n  $result = '';\n  do {\n    if ($number >= 100) {\n\
    \      $result += $roman;\n      $number -= 100;\n    } else if ($number >= 9)\
    \ {\n      $result += $roman;\n      $number -= 9;\n    } else if ($number >=\
    \ 5) {\n      $result += $roman;\n      $number -= 5;\n    }\n    $result += $number;\n\
    \  } while ($number);\n  return $result;\n}", "    if ($number < 1 || $number\
    \ > 1000) {\n        return false;\n    }\n    $str = '';\n    if ($number ==\
    \ 0) {\n        $str = 'c';\n    } else if ($number < 4) {\n        $str .= $number\
    \ * 10;\n        if ($number < 100) {\n            $str .= $number % 10;\n   \
    \     }\n        $str .= int_to_mini_roman($number / 10);\n    } else {\n    \
    \    $str .= int_to_mini_roman($number / 10);\n        if ($number % 10 == 0)\
    \ {\n            $str .= $number % 10;\n        } else {\n            $str .=\
    \ $number % 10 * 10 . $number % 10;\n        }\n    }\n    return strtolower($str);\n\
    }\n", "  $roman = '';\n\n  // Convert $number to a roman numeral.\n  if ($number\
    \ < 1 || $number > 3999) {\n    throw new InvalidArgumentException('$number must\
    \ be between 1 and 3999.');\n  }\n\n  do {\n    $remainder = $number % 10;\n\n\
    \    // If the remainder of dividing $number by 10 is zero (i.e. the number\n\
    \    // is evenly divisible by 10), add an 'i' before the number\n    // and increase\
    \ $number by 1.\n    if ($remainder === 0) {\n      $roman .= 'i';\n      $number++;\n\
    \    }\n\n    // Otherwise, the number is in the range 1 to 9, so add 'vi'\n \
    \   // before the number.\n    else {\n      $roman .= 'vi';\n    }\n\n    //\
    \ Divide the number by 10.\n    $number = floor($number / 10);\n  } while ($number\
    \ > 0);\n\n  // Return the roman numeral in lowercase.\n  return strtolower($roman);\n\
    }", "  $nums = array('','','','','','','','','','','','','','','','','','','','','','','','',\n\
    \                 '','','','','','','','','','','','','','','','','','','','','','','','',\n\
    \                 '','','','','','','','','','','','','','','','','','','','','','','','',\n\
    \                 '','','','','','','','','','','','','','','','','','','','','','','','','',\n\
    \                 '','','','','','','','','','','','','','','','','','','','','','','','','',\n\
    \                 '','','','','','','','','','','','','','','','','','','','','','','','','',\n\
    \                 '','','','','','','','','','','','','','','','','','','','','','','','','',\n\
    \                 '','','','','','','','','','','','','','','','','','','','','','','','','',\n\
    \                 '','','','','','','','','','','','','','','','','','','','','','','','','',\n\
    \                 '','','','','','','','','','','','','','','','','','','','','','','','','',\n\
    \                 '','','','','','','','','','','','','','','','','','','','','','','','','',\n\
    \                 '','','','','','','','','','','','','','','','','','','','','','','','',\n\
    \                 '','','','','','','','','','','','','','','','','','','','','','','','',\n\
    \                 '','','','','','','','','','','','','','','','','','','','','','','','',\n\
    \                 '','','','','','','','','','','','','','','','','','','','','','','','',\n\
    \                 '','','','','','','','','','','','','','','','','','','','','','','','',\n\
    \                 '','','','','','','','','','','','','','','','','','','','','','','','',\n\
    \                 '','','','','','','','','','','','','','','','','','','','','','','','',\n\
    \                 '','','','','','','','','','','','','','','','','','','','','','','',\n\
    \                 '','','','','','','", "  $roman_numerals = array(\n    'M' =>\
    \ 1000,\n    'CM' => 900,\n    'D' => 500,\n    'CD' => 400,\n    'C' => 100,\n\
    \    'XC' => 90,\n    'L' => 50,\n    'XL' => 40,\n    'X' => 10,\n    'IX' =>\
    \ 9,\n    'V' => 5,\n    'IV' => 4,\n    'I' => 1\n  );\n\n  return roman_to_mini_roman($number,\
    \ $roman_numerals);\n}\n", "    // Limit input from 1 to 1000\n    $number = max(1,min(1000,$number));\n\
    \n    $roman = '';\n    if ($number > 400) {\n        $roman = $roman.int_to_mini_roman($number/400);\n\
    \        $number = $number%400;\n    }\n\n    if ($number > 100) {\n        $roman\
    \ = $roman.int_to_mini_roman($number/100);\n        $number = $number%100;\n \
    \   }\n\n    if ($number > 10) {\n        $roman = $roman.int_to_mini_roman($number/10);\n\
    \        $number = $number%10;\n    }\n\n    $roman = $roman.int_to_mini_roman($number);\n\
    \n    return strtolower($roman);\n}\n", "  // Romans have more than 400 characters\n\
    \  if ($number > 400) {\n    $number = $number % 400;\n  }\n  // Use roman_number_to_int()\
    \ to convert the number\n  // to a Roman number and then convert it back to a\
    \ decimal\n  // for returning to our caller.\n  return roman_number_to_int($number);\n\
    }\n", "\t$roman = '';\n\tfor ($i = 0; $i < strlen($number); $i++) {\n\t\t$char\
    \ = substr($number, $i, 1);\n\t\tif ($char == 'I') {\n\t\t\t$roman .= 'I';\n\t\
    \t} else {\n\t\t\t$roman .= int_to_roman_number($char);\n\t\t}\n\t}\n\treturn\
    \ mb_strtolower($roman);\n}\n", "  if (!is_int($number)) {\n    throw new InvalidArgumentException(\"\
    Argument should be a positive integer.\");\n  }\n  $roman = \"\";\n  $numeral\
    \ = str_split($number);\n  foreach ($numeral as $value) {\n    switch ($value)\
    \ {\n      case 0:\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n\
    \      case 5:\n      case 6:\n      case 7:\n      case 8:\n      case 9:\n \
    \       $roman .= \"m{$value}\";\n        break;\n      case 10:\n      case 11:\n\
    \      case 12:\n      case 13:\n      case 14:\n      case 15:\n      case 16:\n\
    \      case 17:\n      case 18:\n        $roman .= \"l{$value}\";\n        break;\n\
    \      case 19:\n        $roman .= \"c{$value}x\";\n        break;\n      case\
    \ 20:\n      case 21:\n      case 22:\n      case 23:\n      case 24:\n      case\
    \ 25:\n      case 26:\n      case 27:\n      case 28:\n      case 29:\n      case\
    \ 30:\n      case 31:\n        $roman .= \"d{$value}c\";\n        break;\n   \
    \   case 32:\n      case 33:\n      case 34:\n      case 35:\n      case 36:\n\
    \      case 37:\n      case 38:\n      case 39:\n        $roman .= \"c{$value}s\"\
    ;\n        break;\n      case 40:\n      case 41:\n      case 42:\n      case\
    \ 43:\n      case 44:\n      case 45:\n      case 46:\n      case 47:\n      case\
    \ 48:\n      case 49:\n        $roman .= \"c{$value}f\";\n        break;\n   \
    \   case 50:\n      case 51:\n      case 52:\n      case 53:\n      case 54:\n\
    \      case 55:\n      case 56:\n      case 57:\n      case 58:\n      case 59:\n\
    \        $roman .= \"c{$value}p\";\n        break;\n      case 60:\n      case\
    \ 61:\n      case 62:\n      case 63:\n      case 64:\n      case 65:\n      case\
    \ 66:\n      case 67:\n      case 68:\n      case 69:\n        $roman .= \"c{$value}j\"\
    ;\n        break;\n      case 70:\n      case 71:\n      case 72:\n      case\
    \ 73:\n      case 74:\n      case 75:\n      case 76:\n      case 77:\n      case\
    \ 78:\n      case 79:\n        $roman .= \"c{$value}v\";\n        break;\n   \
    \   case 80:\n      case 81:\n      case 82:\n      case 83:\n      case 84:\n\
    \      case 85:\n      case 86:\n      case 87:\n      case 88:\n      case 89:\n\
    \        $roman .= \"c{$value}g\";", "    $romans = array(\n        'I' => 1,\n\
    \        'IV' => 5,\n        'V' => 10,\n        'IX' => 10,\n        'X' => 50,\n\
    \        'XL' => 50,\n        'L' => 100,\n        'XC' => 100,\n        'C' =>\
    \ 500,\n        'CD' => 500,\n        'D' => 1000,\n        'CM' => 1000,\n  \
    \  );\n    $letters = array();\n    $letters_count = count($romans);\n    $i =\
    \ 0;\n    foreach ($romans as $roman => $number) {\n        while ($number >=\
    \ $i) {\n            $letters[] = $roman;\n            $number -= $i;\n      \
    \  }\n        $i++;\n    }\n    // If only one letter, return it.\n    if (count($letters)\
    \ == 1) {\n        return $letters[0];\n    }\n    return implode('', $letters);\n\
    }\n\n/**\n * Takes a string and returns the same string in reverse order.\n *\n\
    \ * Example:\n * >>> str_reverse('Hello world!')\n * '!dlrow olleH'\n *\n * @param\
    \ string $str\n *   The string to reverse\n *\n * @return string\n *   The same\
    \ string in reverse order.\n */", "  if ($number < 1 || $number > 1000) {\n  \
    \  return FALSE;\n  }\n\n  $result = '';\n  for ($i = 0; $i < strlen($roman[$number]);\
    \ ++$i) {\n    $result .= $roman[$number][$i];\n  }\n\n  return strtolower($result);\n\
    }\n", "  // assert(is_int($number));\n  $roman = '';\n  for ($i = 0; $i < $number;\
    \ $i++) {\n    $roman .= roman($i);\n  }\n  return strtolower($roman);\n}\n",
  "  // Return an empty string if the number is out of bounds.\n  if ($number < 1\
    \ || $number > 1000) return '';\n\n  // Initialize the result string to empty.\n\
    \  $result = '';\n\n  // Loop through each digit of the number, starting from\
    \ the right and going\n  // through the digits.\n  for ($i = count($number) -\
    \ 1, $j = 0; $i >= 0; $i -= 1, $j++) {\n    // If the number we are working with\
    \ is greater than the value which is\n    // currently in the result string, append\
    \ it to the result string.\n    if ($number >= $result[$j]) {\n      $result .=\
    \ $j == 0 ? '' : self::$roman[$j];\n      $j--;\n    }\n  }\n\n  // Return the\
    \ result string.\n  return $result;\n}\n", "    $roman = array(\"\", \"i\", \"\
    ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\");\n    $num =\
    \ $number < 1 ? 0 : 1;\n    foreach ($roman as $key => $value) {\n        if ($num\
    \ > 0 && $num % $key == 0 && $num / $key >= $num) {\n            return $value;\n\
    \        }\n        $num *= 10;\n    }\n    return $num < 1 ? '0' : '';\n}\n",
  "  if ($number < 1 || $number > 1000) {\n    return false;\n  }\n  $roman = '';\n\
    \  $int = $number;\n  while (true) {\n    $remainder = $int % 10;\n    $int =\
    \ $int / 10;\n    if ($int <= 0) {\n      break;\n    }\n    $roman = $roman.$romans[$remainder];\n\
    \  }\n  return strtolower($roman);\n}\n", "  $roman = '';\n  $roman_numbers =\
    \ range(1,1000);\n  $max_roman_number = count($roman_numbers);\n  for ($i = 1;\
    \ $i <= $max_roman_number; $i++) {\n    if ($number >= $roman_numbers[$i]) {\n\
    \      $roman .= $roman_numbers[$i];\n      $number = $number - $roman_numbers[$i];\n\
    \    }\n  }\n  return $roman;\n}\n", "  $roman = '';\n  if ($number < 0 || $number\
    \ > 3999) {\n    return $number;\n  }\n  $denominators = [1000, 900, 500, 400,\
    \ 100, 90, 50, 40, 10, 9, 5, 4, 1];\n  $denominators += array_fill(0, 1000 - $number,\
    \ 1);\n  $num = $number;\n  for ($i = count($denominators) - 1, $j = 0; $i >=\
    \ 0; $i--, $j++) {\n    $num *= $denominators[$i];\n    if ($num >= i) {\n   \
    \   $roman .= chr($num % i);\n      $num = ($num - $i) / i;\n    }\n  }\n  return\
    \ $roman;\n}\n", "    if ($number < 1 || $number > 1000) {\n        return false;\n\
    \    }\n    $roman = \"\";\n    $roman_letters = array('M'=>1000,'CM'=>900,'D'=>500,'CD'=>400,'C'=>100,'XC'=>90,'L'=>50,'XL'=>40,'X'=>10,'IX'=>9,'V'=>5,'IV'=>4,'I'=>1);\n\
    \    do {\n        $current_number = $number;\n        $roman .= $roman_letters[$roman\
    \ ? $roman[0] : 'M'];\n        $number -= $current_number;\n    } while ($number\
    \ > 0);\n    return strtolower($roman);\n}\n", "    if ($number < 1 || $number\
    \ > 1000) {\n        return FALSE;\n    }\n\n    if ($number < 3) {\n        return\
    \ intval($number);\n    }\n\n    $roman = 'M';\n    $result = array();\n    for\
    \ ($i = 2; $i < $number; $i++) {\n        $roman *= $i;\n        $roman = $roman.strtoupper($roman);\n\
    \        $result[] = $roman;\n    }\n\n    return join('', $result);\n}", "  \
    \  $result = \"\";\n    $firstRoman = (int)($number / 1000);\n    $firstDigit\
    \ = (int)(($number % 1000) / 100);\n    $secondDigit = $number % 100;\n    $result\
    \ .= $firstRoman[$firstDigit];\n    if ($secondDigit >= 100) {\n        $secondDigit\
    \ -= 100;\n        $firstDigit += 10;\n        $result .= $firstRoman[$firstDigit];\n\
    \    }\n    $result .= $firstRoman[$secondDigit];\n    return $result;\n}\n",
  "    $roman = '';\n    if ($number < 1 || $number > 1000) {\n        return $roman;\n\
    \    }\n    do {\n        $remainder = $number % 10;\n        $number    = floor($number\
    \ / 10);\n        $roman.= $remainder == 0 ? '' : ($remainder < 4 ? $remainder\
    \ - 2 : $remainder - 1);\n    } while ($number > 0);\n    return $roman;\n}\n",
  "    $roman = '';\n    while ($number >= 1000) {\n        $roman .= 'm';\n     \
    \   $number -= 1000;\n    }\n    if ($number >= 500) {\n        $roman .= 'd';\n\
    \        $number -= 500;\n    }\n    if ($number >= 100) {\n        $roman .=\
    \ 'c';\n        $number -= 100;\n    }\n    if ($number >= 50) {\n        $roman\
    \ .= 'l';\n        $number -= 50;\n    }\n    if ($number >= 10) {\n        $roman\
    \ .= 'x';\n        $number -= 10;\n    }\n    if ($number >= 5) {\n        $roman\
    \ .= 'v';\n        $number -= 5;\n    }\n    if ($number >= 1) {\n        $roman\
    \ .= 'i';\n        $number -= 1;\n    }\n    return $roman;\n}", "  $number_to_roman\
    \ = str_split($number);\n  $roman =  array();\n  for ($i = 0; $i < count($number_to_roman);\
    \ $i++) {\n    $roman[$i] = array_shift($number_to_roman);\n  }\n\n  // Get the\
    \ starting index\n  $start_index = 1;\n  for ($i = 1; $i < count($roman); $i++)\
    \ {\n    $current_index = $roman[$i];\n    if ($current_index != 1000) {\n   \
    \   $start_index = $i;\n      break;\n    }\n  }\n\n  // Build the string\n  $mini_roman\
    \ = array();\n  for ($i = $start_index; $i < count($roman); $i++) {\n    $mini_roman[$i]\
    \ = $roman[$i];\n  }\n\n  // Add ending zeros\n  for ($i = $start_index; $i <\
    \ count($roman); $i++) {\n    $mini_roman[$i] = 0;\n  }\n\n  return implode('',\
    \ $mini_roman);\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nThis should\
    \ do it:\n<code>", "    $ret = \"\";\n    while ($number >= 1000) {\n        $roman\
    \ =  $number % 1000;\n        $number = $number / 1000;\n        $ret .= \"M{$roman}\"\
    ;\n    }\n    $roman =  $number % 1000;\n    $ret .= \"C{$roman}\";\n    if ($number\
    \ > 0)\n        $ret .= int_to_mini_roman($number);\n    else\n        $ret .=\
    \ \"M\";\n    return $ret;\n}\n", "    $roman = '';\n    $roman_numerals = array('M'\
    \ => 1000, 'D' => 500, 'C' => 100, 'L' => 50, 'X' => 10, 'V' => 5, 'I' => 1);\n\
    \    $numeral = array_search($number, $roman_numerals);\n    if ($numeral !==\
    \ false) {\n        $roman = $roman_numerals[$numeral];\n    }\n    return $roman;\n\
    }\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis does what I was looking for - thank\
    \ you for posting it. Unfortunately, it does not work for large numbers e.g. 1053.\
    \ Also, the code has some typos - it should read \"C\" instead of \"Cs\" for example.\n\
    <|/ c |>\n<| c |>\nThis answer is wrong. Try with input \"1053\"\n<|/ c |>\n<|\
    \ c |>\nYou should be using BigInteger instead of float. Otherwise it's quite\
    \ easy to pass floats into this function.\n<|/ c |>\n<| a |>\nYou can do this\
    \ using PHP string manipulation functions:\n<code>\n<?php\n", "  if ($number <\
    \ 1 || $number > 1000) {\n    return \"\";\n  }\n\n  if ($number < 3999) {\n \
    \   return roman($number);\n  }\n\n  $first_hundreds = floor($number / 1000);\n\
    \  $hundreds = floor($first_hundreds / 100);\n\n  $remainder = floor($first_hundreds\
    \ % 100);\n\n  $next_hundreds = floor($remainder / 100);\n\n  $remainder_next_hundreds\
    \ = floor($remainder % 100);\n\n  $roman = \"\";\n\n  if ($hundreds > 0) {\n \
    \   $roman .= roman($hundreds) . \" \";\n  }\n\n  $roman .= roman($next_hundreds)\
    \ . \"\";\n\n  if ($remainder_next_hundreds > 0) {\n    $roman .= roman($remainder_next_hundreds);\n\
    \  }\n\n  return $roman;\n}\n", "  $numerals = [\"\", \"i\", \"ii\", \"iii\",\
    \ \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n  $numerals[1000] = \"m\"\
    ;\n  $numerals[900] = \"m\";\n  $numerals[500] = \"l\";\n  $numerals[400] = \"\
    l\";\n  $numerals[100] = \"c\";\n  $numerals[90] = \"c\";\n  $numerals[50] = \"\
    x\";\n  $numerals[40] = \"x\";\n  $numerals[10] = \"l\";\n  $numerals[9] = \"\
    l\";\n  $numerals[5] = \"x\";\n  $numerals[4] = \"x\";\n  $numerals[1] = \"\"\
    ;\n  $numerals[2] = \"m\";\n  $numerals[3] = \"m\";\n  $numerals[4] = \"l\";\n\
    \  $numerals[5] = \"l\";\n  $numerals[6] = \"l\";\n  $numerals[7] = \"c\";\n \
    \ $numerals[8] = \"c\";\n  $numerals[9] = \"c\";\n  $numerals[10] = \"c\";\n \
    \ $numerals[11] = \"l\";\n  $numerals[12] = \"l\";\n  $numerals[13] = \"l\";\n\
    \  $numerals[14] = \"l\";\n  $numerals[15] = \"l\";\n  $numerals[16] = \"l\";\n\
    \  $numerals[17] = \"x\";\n  $numerals[18] = \"x\";\n  $numerals[19] = \"x\";\n\
    \  $numerals[20] = \"c\";\n  $numerals[21] = \"c\";\n  $numerals[22] = \"c\";\n\
    \  $numerals[23] = \"c\";\n  $numerals[24] = \"c\";\n  $numerals[25] = \"c\";\n\
    \  $numerals[26] = \"c\";\n  $numerals[27] = \"c\";\n  $numerals[28] = \"c\";\n\
    \  $numerals[29] = \"c\";\n  $numerals[30] = \"c\";\n  $numerals[31] = \"c\";\n\
    \  $numerals[32] = \"c\";\n  $numerals[33] = \"c\";\n  $numerals[34] = \"c\";\n\
    \  $numerals[35] = \"c\";\n  $numerals[36] = \"c\";\n  $numerals[37] = \"c\";\n\
    \  $numerals[38] = \"c\";\n  $numerals[39] = \"c\";\n  $numerals[40] = \"c\";\n\
    \  $numerals[41] = \"c\";\n  $numeral", "    $roman = '';\n    $roman_array =\
    \ [\n        'M' => 1000, 'CM' => 900, 'D' => 500, 'CD' => 400, 'C' => 100, 'XC'\
    \ => 90, 'L' => 50, 'XL' => 40, 'X' => 10, 'IX' => 9, 'V' => 5, 'IV' => 4, 'I'\
    \ => 1\n    ];\n    for ($i = 1; $i <= 3; $i++) {\n        if ($number >= $roman_array['M'])\
    \ {\n            $roman .= $roman_array['M'];\n            $number -= $roman_array['M'];\n\
    \        }\n        else if ($number >= $roman_array['CM']) {\n            $roman\
    \ .= $roman_array['CM'];\n            $number -= $roman_array['CM'];\n       \
    \ }\n        else if ($number >= $roman_array['D']) {\n            $roman .= $roman_array['D'];\n\
    \            $number -= $roman_array['D'];\n        }\n        else if ($number\
    \ >= $roman_array['CD']) {\n            $roman .= $roman_array['CD'];\n      \
    \      $number -= $roman_array['CD'];\n        }\n        else if ($number >=\
    \ $roman_array['C']) {\n            $roman .= $roman_array['C'];\n           \
    \ $number -= $roman_array['C'];\n        }\n        else if ($number >= $roman_array['XC'])\
    \ {\n            $roman .= $roman_array['XC'];\n            $number -= $roman_array['XC'];\n\
    \        }\n        else if ($number >= $roman_array['L']) {\n            $roman\
    \ .= $roman_array['L'];\n            $number -= $roman_array['L'];\n        }\n\
    \        else if ($number >= $roman_array['XL']) {\n            $roman .= $roman_array['XL'];\n\
    \            $number -= $roman_array['XL'];\n        }\n        else if ($number\
    \ >= $roman_array['X']) {\n            $roman .= $roman_array['X'];\n        \
    \    $number -= $roman_array['X'];\n        }\n        else if ($number >= $roman_array['IX'])\
    \ {\n            $roman .= $roman_array['IX'];\n            $number -= $roman_array['IX'];\n\
    \        }\n        else if ($number >= $roman_array['V']) {\n            $roman\
    \ .= $roman_array['V'];\n            $number -= $roman_array['V'];\n        }\n\
    \        else if ($number >= $roman_", "    if ($number < 1 || $number > 1000)\
    \ {\n        return false;\n    }\n    static $one = array('', 'I', 'II', 'III',\
    \ 'IV', 'V', 'VI', 'VII', 'VIII', 'IX');\n    static $ten = array('', 'X', 'XX',\
    \ 'XXX', 'XL', 'L', 'LX', 'LXX', 'LXXX', 'XC');\n    static $hund = array('',\
    \ 'C', 'CC', 'CCC', 'CD', 'D', 'DC', 'DCC', 'DCCC', 'CM');\n    static $thousand\
    \ = array('M', 'MM', 'MMM');\n    static $roman = array('', 'I', 'II', 'III',\
    \ 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X');\n    $num = $number;\n    $numeral\
    \ = strval($num);\n    $str = '';\n    while (count($num) > 0) {\n        if (count($num)\
    \ > 3) {\n            list($num, $hund, $thousand) = array_pop($num);\n      \
    \      $str .= $thousand[$num[0]];\n        }\n        if (count($num) > 0) {\n\
    \            list($num, $one) = array_pop($num);\n            $str .= $one[$num[0]];\n\
    \        }\n        if (count($num) > 1) {\n            list($num) = array_pop($num);\n\
    \            $str .= $roman[$num[0]];\n        }\n    }\n    return strtolower($str);\n\
    }\n", "    $roman = \"\";\n    $roman = str_pad(substr($roman, -1, 1), 9, '0',\
    \ STR_PAD_RIGHT);\n    if ($number < 1000) {\n        $roman = substr($roman,\
    \ 0, -1 * strlen($number % 1000)) . $number % 1000;\n    } else {\n        $roman\
    \ = substr($roman, 0, -1 * strlen($number / 1000)) . roman_numerals($number /\
    \ 1000);\n    }\n    return strtolower($roman);\n}\n", "  $roman = \"\";\n  for\
    \ ($i = 0; $i < $number; $i++) {\n    $r = floor($number/$i);\n    $roman = ($i\
    \ > 0) ? $roman[$r-1].($roman[$r] ? \"\" : $roman[$r]) : $roman[$r];\n  }\n  return\
    \ $roman;\n}\n", "  $roman = \"\";\n  $nnum = intval($number);\n  if (!is_numeric($nnum)\
    \ || $nnum < 1 || $nnum > 1000) {\n    throw new Exception(\"Invalid number\"\
    );\n  }\n  for ($i = 1; $i <= $nnum; $i++) {\n    $roman .= int_to_roman($i);\n\
    \  }\n  return mb_strtolower($roman);\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\n\
    Here's a one-liner:\n<code>\nreturn str_replace(\"X\",'',substr(preg_replace(\"\
    /\\d/\",'',str_repeat(\"M\",1000)),0,100));\n</code>\nBut I'm not sure it works\
    \ in all cases:\n<code>\n> echo int_to_mini_roman(12)\ncm\n> echo int_to_mini_roman(22)\n\
    cc\n> echo int_to_mini_roman(999)\ncmcm\n> echo int_to_mini_roman(1000)\ncmcmcm\n\
    > echo int_to_mini_roman(1992)\ncmXc\n</code>\n<|/ a tags=php,roman-numerals,string\
    \ |>\n<| a dscore=0 tags=php,roman-numerals,string |>\nHere is an answer using\
    \ recursion:\n<code>", "\tif ($number < 1 || $number > 1000)\n\t\tthrow new RangeException;\n\
    \t$roman = '';\n\tfor ($n = 1; $n < $number; $n++) {\n\t\t$roman .= int_to_roman_character($n);\n\
    \t}\n\treturn strtolower($roman);\n}\n", "    if ($number > 1000 || $number <\
    \ 0) {\n        return \"\";\n    }\n    $roman = \"\";\n    $lookup = array();\n\
    \    for ($i = 1; $i < $number; $i++) {\n        $roman_num = $i * 100;\n    \
    \    $lookup[$roman_num] = $roman;\n        $roman = $lookup[$roman_num] . $roman;\n\
    \    }\n    return $roman;\n}\n</code>\n<|/ a tags=php,math,bignum |>\n<| c |>\n\
    You don't need to store the entire string in memory just to find the index to\
    \ delete.\n<|/ c |>\n<| c |>\nThat's true, but if you're looking to use it in\
    \ multiple places, this is a better solution. My comment was more of a \"I like\
    \ one-liners\" thing.\n<|/ c |>\n<| c |>\nHm, I didn't know that was possible.\
    \ I'll try implementing it when I get to the office. Thanks for the suggestion.\n\
    <|/ c |>\n<| c |>\nI'm just looking at this in a browser, so it doesn't seem to\
    \ be working, but I'll look into it more tomorrow morning and try to get it to\
    \ work.\n<|/ c |>\n<| c |>\nThanks for this, I'll give this a shot.\n<|/ c |>\n\
    <| a |>\nHere is my attempt at a function that would do that:\n<code>", "    $int_string\
    \ = '';\n\n    for ($i = 0; $i < strlen($number); $i++) {\n        if ($number[$i]\
    \ >= '0' && $number[$i] <= '9') {\n            $int_string .= $number[$i];\n \
    \       } else {\n            $int_string .= str_ireplace('0', 'x', $number[$i]);\n\
    \        }\n    }\n\n    return $int_string;\n}\n</code>\n<|/ a |>\n<| c |>\n\
    I tried to run this code but I am getting following error:\nFatal error: Call\
    \ to undefined function str_ireplace() in E:\\xampp\\htdocs\\php\\number_to_roman.php\
    \ on line 16\n<|/ c |>\n<| c |>\nI believe it should be `str_ireplace` instead\
    \ of `str_ireplace`. I've fixed the answer.\n<|/ c |>\n<| c |>\nThanks Pekka,\
    \ it worked very well\n<|/ c |>\n<| c |>\n`str_ireplace` has been deprecated since\
    \ PHP 5.3, so you should be using `str_replace` instead, unless you are in PHP\
    \ 5.2 where `str_ireplace` still works.\n<|/ c |>\n<| c |>\nThe code was written\
    \ for PHP 5.3 or older. I've added an update to my answer to point out that str_ireplace\
    \ is deprecated in PHP 5.3, and suggests str_replace instead.\n<|/ c |>\n<| a\
    \ |>\nA PHP implementation of the Tomani's algorithm:\n<code>\n/**\n * int   $input\
    \   the number to be converted\n * string $baseStr the string representation of\
    \ the base\n * bool  $lower   whether to perform the conversion in lower case\
    \ or not\n * string $output  the converted number\n */", "    if (!$number) throw\
    \ new InvalidArgumentException;\n    if ($number < 1 || $number > 1000)\n    \
    \    throw new InvalidArgumentException('Value must be between 1 and 999.');\n\
    \    $roman = '';\n    while (100 * $number >= 100) {\n        $roman .= 'm';\n\
    \        $number -= 100;\n    }\n    while (100 * $number >= 10) {\n        $roman\
    \ .= 'c';\n        $number -= 10;\n    }\n    while (10 * $number >= 1) {\n  \
    \      $roman .= 'x';\n        $number -= 1;\n    }\n    return strtolower($roman);\n\
    }\n</code>\n<|/ a dscore=2 tags=php,string,function,numbers,formatting |>\n<|\
    \ a tags=php,string,function,numbers,formatting |>\n<code>\n<?php\n$x = 1;\necho\
    \ roman_numeral($x);\n", "    $roman = '';\n    // Handle negative numbers.\n\
    \    if ($number < 0) {\n        $number = abs($number);\n        $negative =\
    \ true;\n    } else {\n        $negative = false;\n    }\n    // Convert to a\
    \ large integer to avoid integer overflow.\n    // We don't use floats here, in\
    \ order to avoid integer overflow when multiplying by 4.\n    // This makes the\
    \ largest number we work with about 3 times bigger than the theoretical upper\
    \ limit of PHP's \"int\" type.\n    $number = $number * (int) (\"1000000000000\"\
    );\n    // Divide the number into four parts, alternating between even and odd\
    \ numbers.\n    for ($i = 1; ; ++$i) {\n        // Round down the current large\
    \ integer to the nearest integer.\n        // We add one to the modulus of the\
    \ integer division because we want\n        // to round down, not up.\n      \
    \  $current_large_integer = floor($number / intval(\"1000000000000\"));\n    \
    \    // Check to see if we should stop.\n        if ($current_large_integer <=\
    \ intval(\"1000000000000\")) {\n            break;\n        }\n        // If we're\
    \ at or just below 1000, stop.\n        if ($i < 10) {\n            $roman .=\
    \ 'M';\n        } elseif ($i < 100) {\n            $roman .= 'CM';\n        }\
    \ elseif ($i < 1000) {\n            $roman .= 'D';\n        } elseif ($i < 1000000)\
    \ {\n            $roman .= 'CD';\n        } elseif ($i < 1000000000) {\n     \
    \       $roman .= 'C';\n        } elseif ($i < 1000000000000) {\n            $roman\
    \ .= 'XC';\n        } elseif ($i < 1000000000000000) {\n            $roman .=\
    \ 'L';\n        } elseif ($i < 10000000000000000) {\n            $roman .= 'XL';\n\
    \        } elseif ($i < 100000000000000000) {\n            $roman .= 'X';\n  \
    \      } elseif ($i < 1000000000000000000) {\n            $roman .= 'IX';\n  \
    \      } elseif ($i < 1000000000000000000000) {\n            $roman .= 'V';\n\
    \        } elseif ($i < 1000000000000000000000000) {\n            $roman .= 'IV';\n\
    \        } elseif ($i < 1000000000000000000000000000) {\n            $roman .=\
    \ 'I';\n        } else {\n            // We have a non-integer larger than that.\
    \ Round up.\n            $number -= intval(\"1000000000000\");\n        }\n  \
    \  }\n    // Add the negative symbol if necessary.\n    if ($negative) {\n   \
    \     $roman = '-' . $roman;\n    }\n    return $roman;\n}\n", "  if (!is_numeric($number)\
    \ || $number < 1 || $number > 1000) {\n    throw new InvalidArgumentException(sprintf(\n\
    \      'Given value \"%s\" is not a positive integer or out of range.',\n    \
    \  (string) $number\n    ));\n  }\n\n  $roman = '';\n  for ($i = 1; $i < $number;\
    \ ++$i) {\n    $roman .= mini_roman($i);\n  }\n\n  return strtolower($roman);\n\
    }\n\n/**\n * Returns the roman numeral equivalent of a decimal number.\n *\n *\
    \ @param int $number\n *\n * @return string\n *\n * @throws InvalidArgumentException\n\
    \ */", "  $roman = '';\n  $num = $number;\n\n  for ($i = 0; $i < strlen($num);\
    \ $i++) {\n    $remainder = $num % 10;\n    $num = $num / 10;\n\n    if ($remainder\
    \ == 0) {\n      $roman .= $romans[$i];\n    }\n    if ($remainder > 4) {\n  \
    \    $roman .= $romans[$i];\n    }\n  }\n\n  return strtolower($roman);\n}\n",
  "    $roman = '';\n    $value = 0;\n    while ($number > 0) {\n        $value =\
    \ $number % 10;\n        $roman .= roman_number[$value];\n        $number = floor($number\
    \ / 10);\n    }\n    return $roman;\n}\n", "  if (!$number) return false;\n  $result\
    \ = \"\";\n  for ($i = 1; $i <= 99; $i += 5) {\n    $remainder = $number % $i;\n\
    \    if ($remainder == 0) {\n      $result = str_pad($i, 5, $result . \"v\", STR_PAD_BOTH);\n\
    \      $number /= $i;\n    } else {\n      $result = str_pad($i, 5, $result .\
    \ \"vi\", STR_PAD_BOTH);\n      $number /= $i;\n    }\n  }\n  return $result;\n\
    }\n", "  if ($number < 1 || $number > 1000) {\n    return FALSE;\n  }\n  if ($number\
    \ == 1000) {\n    return 'i';\n  }\n  // $number > 1 must be taken into account.\n\
    \  $roman = '';\n  for ($i = 1; $i <= $number; ++$i) {\n    $roman .= roman($i);\n\
    \  }\n  return $roman;\n}\n\n/**\n * Return the name of a language as translatable\
    \ string.\n *\n * @param string $lang name of language in English, e.g. 'French',\
    \ 'Chinese'\n */", "  $roman = '';\n  $number = abs($number);\n  for ($i = 1;\
    \ $i <= 1000; $i++) {\n    $roman = ($number % 1000 == 0) ?\n        roman_numeral($i)\
    \ : roman_numeral(1000);\n    $number = floor($number / 1000);\n    $roman .=\
    \ $number;\n  }\n  return $roman;\n}\n", "    $roman = '';\n    while (0 <= $number)\
    \ {\n        $roman .= mini_roman($number % 10);\n        $number /= 10;\n   \
    \ }\n    return mb_strtolower($roman, 'utf-8');\n}\n", "    $roman = \"\";\n \
    \   while ($number >= 100) {\n        $roman .= \"m\";\n        $number -= 100;\n\
    \    }\n    while ($number >= 90) {\n        $roman .= \"c\";\n        $number\
    \ -= 90;\n    }\n    while ($number >= 50) {\n        $roman .= \"l\";\n     \
    \   $number -= 50;\n    }\n    while ($number >= 40) {\n        $roman .= \"xl\"\
    ;\n        $number -= 40;\n    }\n    while ($number >= 10) {\n        $roman\
    \ .= \"x\";\n        $number -= 10;\n    }\n    return $roman . int_to_roman($number);\n\
    }\n", "  $roman = '';\n\n  for ($i = 1; $i < $number; $i++) {\n    $roman = $roman\
    \ . 'i';\n  }\n  return $roman;\n}\n", "    $str = \"\";\n    for ($i = 0; $i\
    \ <= $number; $i++) {\n        $str .= roman($i);\n    }\n    return mb_strtolower($str,\
    \ \"UTF-8\");\n}\n", "    if ($number < 0 || $number > 1000) {\n        return\
    \ null;\n    }\n\n    // special case\n    if ($number == 100) {\n        return\
    \ \"x\";\n    }\n\n    $roman = \"\";\n    for ($i = 1; $i < $number; $i++) {\n\
    \        $numeral = $number - $i;\n        $roman = $roman + roman_numeral($numeral);\n\
    \    }\n\n    return $roman;\n}\n", "    if ($number < 1 || $number > 1000) {\n\
    \        throw new InvalidArgumentException(sprintf(\n            'The number\
    \ should be a positive integer greater than %d and less than 1000 - %d.',\n  \
    \          1,\n            1000\n        ));\n    }\n\n    if ($number < 3999)\
    \ {\n        $num = array_merge(\n            str_split('MCMXCIX'),\n        \
    \    str_split('mdcxvii')\n        );\n        /** @var array $roman Array of\
    \ valid roman-numerals. */\n        $roman = array('M' => 1, 'CM' => 2, 'D' =>\
    \ 3, 'CD' => 4, 'C' => 5, 'XC' => 6, 'L' => 7,\n            'XL' => 8, 'X' =>\
    \ 9, 'IX' => 10, 'V' => 11, 'IV' => 12, 'I' => 13);\n\n        $roman_number =\
    \ '';\n        foreach ($num as $i => $digit) {\n            if ($digit > 'J'\
    \ && $digit < 'N') {\n                $roman_number .= $roman[$digit - 'J'];\n\
    \            } elseif ($digit > 'N' && $digit < 'A') {\n                $roman_number\
    \ .= 'IV';\n            } elseif ($digit > 'A' && $digit < 'V') {\n          \
    \      $roman_number .= 'IX';\n            } elseif ($digit > 'V' && $digit <\
    \ 'I') {\n                $roman_number .= 'X';\n            } elseif ($digit\
    \ > 'I' && $digit < 'X') {\n                $roman_number .= 'L';\n          \
    \  } elseif ($digit > 'X' && $digit < 'C') {\n                $roman_number .=\
    \ 'C';\n            } elseif ($digit > 'C' && $digit < 'M') {\n              \
    \  $roman_number .= 'M';\n            }\n        }\n\n        return mb_strtolower($roman_number);\n\
    \    }\n\n    return '';\n}\n", "    if ($number > 1000 || $number < 0) {\n  \
    \      return '?';\n    }\n    $roman = '';\n    while ($number > 0) {\n     \
    \   if ($number % 10 == 0) {\n            $roman .= $number % 10;\n          \
    \  $number /= 10;\n        } else {\n            $roman .= 'm';\n        }\n \
    \   }\n    return strtolower($roman);\n}\n</code>\nAnd here is the Javascript/HTML:\n\
    <code>", "\t$roman = '';\n\t$numerals = range(1, 1000);\n\n\tforeach ($numerals\
    \ as $numeral) {\n\t\tif ($number % $numeral == 0) {\n\t\t\t$roman .= $numeral;\n\
    \t\t\t$number /= $numeral;\n\t\t} else {\n\t\t\t$roman .= $numeral . ' ';\n\t\t\
    }\n\t}\n\n\treturn strtolower($roman);\n}\n", "    $roman = \"\";\n    $num_range\
    \ = range(0,1000);\n    foreach ($num_range as $range) {\n        if ($number\
    \ >= $range) {\n            $value = $range;\n            $num = $number - $value;\n\
    \            if ($num > 0) {\n                for ($i = 0; $i < $num; $i++) {\n\
    \                    $roman .= \"$value\";\n                }\n            } else\
    \ {\n                for ($i = 0; $i < $num; $i++) {\n                    $roman\
    \ .= \"$value \";\n                }\n            }\n            break;\n    \
    \    }\n    }\n    $roman = strtolower($roman);\n    return $roman;\n}\n", " \
    \ // Validate parameters\n  if ($number < 1 || $number > 1000) {\n    return \"\
    \";\n  }\n\n  // Get an array with each digit of the number, and their corresponding\n\
    \  // position in the decimal system\n  $digits_array = array();\n  for ($i =\
    \ 0; $i < strlen($number); $i++) {\n    $digits_array[] = intval($number{$i});\n\
    \  }\n\n  // Sort the array in descending order and group it by position in the\
    \ decimal system\n  rsort($digits_array);\n  $digits_array = array_slice($digits_array,\
    \ 0, -1); // remove last entry\n  $result = array(); // initialize the result\
    \ array\n  $j = 0;\n\n  // Build the result\n  foreach ($digits_array as $digit)\
    \ {\n    // If this is the first digit in the array, push it to result and continue\n\
    \    if ($j == 0) {\n      $result[] = $digit;\n      continue;\n    }\n\n   \
    \ // Else, push the digit to the correct position in the result array\n    switch\
    \ ($digits_array[$j - 1]) {\n      case 0:\n      case 2:\n        $result[$j\
    \ - 1] .= \"M\";\n        break;\n      case 1:\n      case 3:\n        $result[$j\
    \ - 1] .= \"CM\";\n        break;\n      case 4:\n      case 5:\n        $result[$j\
    \ - 1] .= \"D\";\n        break;\n      case 6:\n      case 7:\n        $result[$j\
    \ - 1] .= \"CD\";\n        break;\n      case 8:\n      case 9:\n        $result[$j\
    \ - 1] .= \"C\";\n        break;\n      case 10:\n      case 11:\n        $result[$j\
    \ - 1] .= \"XC\";\n        break;\n      case 12:\n      case 13:\n        $result[$j\
    \ - 1] .= \"L\";\n        break;\n      case 14:\n      case 15:\n        $result[$j\
    \ - 1] .= \"XL\";\n        break;\n      case 16:\n      case 17:\n        $result[$j\
    \ - 1] .= \"X\";\n        break;\n      case 18:\n      case 19:\n        $result[$j\
    \ - 1] .= \"IX\";\n        break;\n      case 20:\n      case 21:\n        $result[$j\
    \ - 1] .= \"V\";\n        break;\n      case 22:\n      case 23:\n        $result[$j\
    \ - 1] .= \"IV\";\n        break;\n      case 24:\n      case 25:\n        $result[$j\
    \ - 1] .= \"I\";\n        break;\n      case 26:\n      case 27:\n        $result[$j\
    \ - 1] .= \"IU\";\n        break;\n      case 28:\n      case 29:\n        $result[$j\
    \ - 1] .= \"E\";\n        break;\n      case 30:\n      case 31:\n        $result[$j\
    \ - 1] .= \"EN\";\n        break;\n      case 32:\n      case 33:\n        $result[$j\
    \ - 1] .= \"O", "  $roman = \"\";\n  for ($i = 1; $i <= 999; $i++) {\n    $char\
    \ = roman_numeral_encode($number, $i);\n    $roman .= $char;\n  }\n  return mb_strtolower($roman);\n\
    }\n</code>\n<|/ a |>\n<| a tags=algorithm,php,ruby,ruby-on-rails |>\n<code>",
  "    if ($number < 1 || $number > 1000) throw new InvalidArgumentException('number\
    \ must be between 1 and 999');\n    if ($number == 100) return 'M';\n    if ($number\
    \ == 10) return 'CM';\n    if ($number == 9) return 'D';\n    if ($number == 5)\
    \ return 'D';\n    if ($number == 4) return 'CD';\n    if ($number == 3) return\
    \ 'C';\n    if ($number == 2) return 'XC';\n    if ($number == 1) return 'X';\n\
    \    if ($number == 0) return 'I';\n\n    // SI system. Check for negative numbers.\n\
    \    if ($number < 0)\n        throw new InvalidArgumentException('number must\
    \ be >= 0');\n\n    // We perform a binary search, since it's faster than looping\
    \ through\n    // the numbers from smallest to largest.\n    $index = 0;\n   \
    \ $result = array();\n    $lengths = array('M' => 1000, 'CM' => 100, 'D' => 10,\
    \ 'CD' => 10, 'C' => 9, 'XC' => 9, 'X' => 5, 'I' => 1);\n    while (true) {\n\
    \        // We add a new result if we found a new index. Otherwise we just look\n\
    \        // at the current index.\n        $result[] = $lengths[$numbers[$index]];\n\
    \        if ($index >= count($numbers)) break;\n        $index++;\n    }\n   \
    \ return implode('', $result);\n}\n", "    $roman_array = array_fill(1, 26, 'M');\n\
    \    $number = (int) $number;\n    if ($number < 1) {\n        return false;\n\
    \    }\n    $roman_array[1][1] = 'I';\n    do {\n        $value = floor($number\
    \ / 1000);\n        if ($value >= 1000) {\n            $value -= 1000;\n     \
    \       $roman_array[$value][1] = array_shift($roman_array[$value]);\n       \
    \ }\n        $roman_array[$value][0]++;\n        if ($number > 9000) {\n     \
    \       $number -= 1000;\n        }\n        $number %= 1000;\n    } while (0\
    \ < $number);\n    $roman_array[1][0]++;\n    $roman_array[1][1] = array_shift($roman_array[1]);\n\
    \    return implode('', $roman_array);\n}\n", "  $roman = '';\n  $denominators\
    \ = array(5, 3);\n  $num = $number;\n\n  while (0 < $num) {\n    $roman .= int_to_roman($num\
    \ % 10);\n    $num /= 10;\n  }\n  do {\n    $roman .= $numerals[$roman];\n  }\
    \ while (0 < $num);\n\n  return $roman;\n}", "  $result = '';\n  $roman_numeral\
    \ = array('', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX');\n  for\
    \ ($i = 0; $i < count($roman_numeral); ++$i) {\n    // Divide by 1-1000 and round\
    \ down.\n    $result += $roman_numeral[$i] . ($number / (1000 * $i));\n    //\
    \ Divide by 1000 and round down.\n    $number -= $number / (1000 * $i);\n  }\n\
    \  return $result;\n}\n", "  // Ensure that the input is a positive integer\n\
    \  if($number < 1) {\n    return FALSE;\n  }\n  $roman = '';\n  for($i = 1; $i\
    \ <= 1000; $i++) {\n    if($number >= $i) {\n      $roman .= $i;\n      $number\
    \ = $number - $i;\n    }\n  }\n  return str_ireplace(array(\"i\", \"ii\"), array(\"\
    ii\", \"iv\"), $roman);\n}\n", "  $roman = '';\n  for ($i = 1; $i < $number; $i++)\
    \ {\n    $roman .= iconv('UTF-8', 'ASCII//TRANSLIT', $roman_name);\n  }\n  return\
    \ $roman;\n}\n", "  if ($number < 1 || $number > 1000) {\n    return null;\n \
    \ }\n\n  // special cases\n  if ($number < 500) {\n    return intdiv(int_to_roman($number),\
    \ 100);\n  }\n\n  // given a number in roman, return its int equivalent\n  $roman\
    \ = int_to_roman($number);\n  return intval(intval($roman, 8) * 1000);\n}\n",
  "  return str_split(int_to_mini_roman_helper($number));\n}\n", "  if($number < 1\
    \ || $number > 1000) {\n    return null;\n  }\n  if($number < 1000) {\n    return\
    \ number_format($number, 0, '.', '');\n  }\n\n  // Fill the string with roman\
    \ numerals\n  $mini_roman = '';\n  $romans = ['', 'I', 'II', 'III', 'IV', 'V',\
    \ 'VI', 'VII', 'VIII', 'IX', 'X', 'XI', 'XII', 'XIII', 'XIV', 'XV', 'XVI', 'XVII',\
    \ 'XVIII', 'XIX', 'XX'];\n  for($i = 0; $i < $number; $i++) {\n    $mini_roman\
    \ .= $romans[$i];\n  }\n  return $mini_roman;\n}\n", "  if ($number > 1000) {\n\
    \    return \"invalid\";\n  }\n  if ($number == 0) {\n    return \"zero\";\n \
    \ }\n  $roman = \"\";\n  for ($i = 0; $i < $number; $i++) {\n    $roman .= get_roman($i);\n\
    \  }\n  return $roman;\n}\n", "    // Fail if $number is not 1 or 1000 or greater\n\
    \    if ($number <= 1 || $number > 1000) {\n        throw new Exception(\"Invalid\
    \ input '$number'.\");\n    }\n\n    // Initialize an array of the 26 roman numbers\n\
    \    // and initialize $output to be an empty string\n    $roman = array(\"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\");\n\n    $roman_string\
    \ = \"\";\n    $int_to_roman($number, $roman);\n\n    // Convert each roman number\
    \ to a string and append it to the output string\n    foreach ($roman as $roman\
    \ => $value) {\n        $roman_string .= $value;\n    }\n\n    // Return the $roman_string\
    \ in lowercase string\n    return mb_strtolower($roman_string);\n}\n", "  $result\
    \ = '';\n  while (true) {\n    $remainder = $number % 52;\n    $number = floor($number\
    \ / 52);\n    if ($number <= 1) {\n      break;\n    }\n    $result = ($result\
    \ ? $result . chr(64 + $remainder) : $remainder) . chr(64 + $number);\n  }\n \
    \ return strtolower($result);\n}\n</code>\n<|/ a |>\n<| c |>\nI got this error\
    \ when running your code: Parse error: syntax error, unexpected '?' (T_CONSTANT_ENCAPSED_STRING),\
    \ expecting ',' or ')' in C:\\xampp\\htdocs\\test\\inc\\functions.php on line\
    \ 43\n<|/ c |>\n<| c |>\nI fixed the code so that it passes the tests. It looks\
    \ like a bug in the version I used when I wrote it. I wrote it in 2013, and I\
    \ haven't had a chance to check it in a while. You may want to check it out and\
    \ see if it can still be run.\n<|/ c |>\n<| c |>\nthanks again, now it works.\
    \ I still wonder if there is a way to optimize my code.\n<|/ c |>\n<| a |>\nI\
    \ got another option:\n<code>", "  if ($number < 1 || $number > 1000) die(\"number\
    \ out of range\");\n  // map of the unary numeral system\n  $roman_map = array(\n\
    \    \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"\
    ix\"\n  );\n  // map of the binary numeral system\n  $mini_roman_map = array();\n\
    \  for ($i = 0; $i < 5; $i++) $mini_roman_map[$i] = $roman_map[$i];\n  while ($number\
    \ > 0) {\n    $mini_roman_map[$number] = $roman_map[$number % 5];\n    $number\
    \ /= 5;\n  }\n  return array_reverse(array_reverse($mini_roman_map));\n}\n", " \
    \ $roman = '';\n  // Add 'i' to the left of the number, then count through the\
    \ thousands increments.\n  for ($i = 0; $number >= 1000; $i++) {\n    // Add 'ii'\
    \ to the left.\n    $roman .= 'i';\n    $number -= 1000;\n  }\n  // Add the remaining\
    \ thousands increments.\n  for ($i = 0; $number >= 100; $i++) {\n    // Add 'vi'\
    \ to the left.\n    $roman .= 'v';\n    $number -= 100;\n  }\n  // Add the remaining\
    \ hundreds increments.\n  for ($i = 0; $number >= 10; $i++) {\n    // Add 'x'\
    \ to the left.\n    $roman .= 'x';\n    $number -= 10;\n  }\n  // Add the remaining\
    \ digits.\n  for ($i = 0; $number >= 1; $i++) {\n    // Add 'i' to the left.\n\
    \    $roman .= 'i';\n    $number -= 1;\n  }\n  return $roman;\n}\n", "    $roman\
    \ = '';\n    // Only accept positive integers\n    if ($number < 1 || $number\
    \ > 1000) {\n        return $roman;\n    }\n    // Build up an array of single\
    \ char roman numerals that we can\n    // convert from.\n    $roman_array = array('',\
    \ 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII',\n                         'VIII',\
    \ 'IX', 'X', 'XI', 'XII');\n    // Initialize $i\n    $i = 1;\n    // While $i\
    \ <= $number:\n    do {\n        // Convert the current $i to a roman numeral\
    \ using the\n        // array of single-char roman numerals, then concatenate\
    \ it to\n        // $roman.\n        $roman .= $roman_array[$i];\n        $i++;\n\
    \        // Stop when we reach the number we started with, which\n        // happens\
    \ to be $number.\n    } while ($i <= $number);\n    // Lower case the resulting\
    \ string.\n    return strtolower($roman);\n}\n", "  $roman = '';\n  if ($number\
    \ <= 3999) {\n    $roman = 'x';\n  }\n  while ($number >= 1000 && $number >= 100)\
    \ {\n    $roman .= 'v';\n    $number -= 100;\n  }\n  while ($number >= 100) {\n\
    \    $roman .= 'l';\n    $number -= 100;\n  }\n  while ($number >= 10 && $number\
    \ < 19) {\n    $roman .= 'c';\n    $number -= 10;\n  }\n  while ($number >= 9\
    \ && $number < 20) {\n    $roman .= 'x';\n    $number -= 9;\n  }\n  while ($number\
    \ >= 5 && $number < 40) {\n    $roman .= 'l';\n    $number -= 5;\n  }\n  while\
    \ ($number >= 4 && $number < 59) {\n    $roman .= 'c';\n    $number -= 4;\n  }\n\
    \  while ($number >= 4 && $number < 99) {\n    $roman .= 'x';\n    $number -=\
    \ 4;\n  }\n  while ($number >= 4 && $number < 140) {\n    $roman .= 'v';\n   \
    \ $number -= 4;\n  }\n  while ($number >= 5 && $number < 150) {\n    $roman .=\
    \ 'l';\n    $number -= 5;\n  }\n  while ($number >= 5 && $number < 190) {\n  \
    \  $roman .= 'c';\n    $number -= 5;\n  }\n  while ($number >= 5 && $number <\
    \ 199) {\n    $roman .= 'x';\n    $number -= 5;\n  }\n  while ($number >= 6 &&\
    \ $number < 200) {\n    $roman .= 'v';\n    $number -= 5;\n  }\n  while ($number\
    \ >= 6 && $number < 269) {\n    $roman .= 'l';\n    $number -= 6;\n  }\n  while\
    \ ($number >= 6 && $number < 300) {\n    $roman .= 'c';\n    $number -= 6;\n \
    \ }\n  while ($number >= 7 && $number < 301) {\n    $roman .= 'x';\n    $number\
    \ -= 7;\n  }\n  while ($number >= 7 && $number < 399) {\n    $roman .= 'v';\n\
    \    $number -= 7;\n  }\n  while ($number >= 8 && $number < 400) {\n    $roman\
    \ .= 'l';\n    $number -= 8;\n  }\n  while ($number >= 8 && $number < 599) {\n\
    \    $roman .= 'c", "    $roman = array('', 'M', 'D', 'C', 'X', 'L', 'I', 'V',\
    \ 'M');\n    $mini = array('', $roman[0], 'M', $roman[1], 'D', $roman[2], 'C',\
    \ $roman[3],\n            $roman[4], $roman[5], $roman[6]);\n    return $mini[(int)\
    \ $number];\n}\n", "  // assert(is_int($number));\n  if ($number < 1 || $number\
    \ > 1000) {\n    return '';\n  }\n\n  $result = '';\n  $numberString = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\
    \  $numberLength = $numberString - '0';\n\n  for ($i = $numberLength; $i > 0;\
    \ $i--) {\n    $remainder = $number % $i;\n    $result = $numberString[$remainder]\
    \ . $result;\n    $number -= $remainder;\n  }\n\n  return $result;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nWow, thats awesome! I did some digging and found a good example\
    \ here as well: https://gist.github.com/russellin/3719471\n<|/ c |>\n<| a dscore=4\
    \ |>\nAn alternative (similar to what said) to Roman's answer:\n<code>\n<?php",
  "  global $int_to_mini_roman;\n  if ($number < 1 || $number > 1000)\n    return\
    \ '';\n  $roman = '';\n  while ($number >= 1000) {\n    $roman .= $int_to_mini_roman($number\
    \ % 1000);\n    $number -= $number % 1000;\n  }\n  return $int_to_mini_roman($number)\
    \ + $roman;\n}\n", "  $roman = '';\n\n  while (1000 <= $number) {\n    $roman\
    \ .= chr(($number % 1000) + 400);\n    $number /= 1000;\n  }\n\n  return $roman;\n\
    }\n", "\t$roman = \"\";\n\twhile ($number > 0) {\n\t\t$remainder = $number % 10;\n\
    \t\t$number = floor($number / 10);\n\t\t$roman .= roman_numeral($remainder);\n\
    \t}\n\treturn $roman;\n}", "\t$roman =  \"MCMXCIV\";\n\t$result = '';\n\tfor ($i\
    \ = 0; $i < $number; $i++) {\n\t\t$multiplier = ($number - $i) * 100;\n\t\t$digit\
    \ = $roman [$i % 6];\n\t\t$result  .= $digit . $multiplier;\n\t}\n\treturn strtolower($result);\n\
    }", "  if ($number < 1 || $number > 1000) {\n    throw new InvalidArgumentException(\"\
    Invalid input for 'int_to_mini_roman': $number\");\n  }\n\n  $roman = '';\n  //\
    \ Roman numerals are represented as an array from 1000 to 900.\n  // Add 100 to\
    \ get the required number of positions for the final roman\n  // numeral.\n  $romanNumbers\
    \ = [\n    1000,\n    900,\n    500,\n    400,\n    100,\n    90\n  ];\n  $total\
    \ = 0;\n\n  for ($i = 0; $i < $number; $i++) {\n    $position = $romanNumbers[$total\
    \ + $i];\n    $roman .= str_pad(substr($position, $number, 1), 4, '0', STR_PAD_LEFT);\n\
    \  }\n\n  return mb_strtolower($roman, 'UTF-8');\n}\n", "    if ($number < 0 ||\
    \ $number > 1000) {\n        throw new RangeException(\"Expected a positive integer\"\
    );\n    }\n\n    // Only works for integers no greater than 1000.\n    $roman\
    \ = (string) ($number);\n    $roman = strrev($roman);\n    $roman = preg_replace('/(.)(\\\
    d)/', \"$1$2\", $roman);\n    $roman = preg_replace('/(\\d)(.)/', \"$1$2\", $roman);\n\
    \n    return strtolower($roman);\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\n`return\
    \ str_ireplace([ 'I','X' ], 'v', str_ireplace([ 'V', 'I', 'I', 'I', 'X' ], 'V',\
    \ str_ireplace([ 'I', 'V', 'I', 'V', 'X' ], 'I', str_ireplace([ 'X', 'I', 'V',\
    \ 'I', 'X' ], 'X', str_ireplace([ 'I', 'I', 'I', 'I', 'X' ], 'X', str_ireplace([\
    \ 'I', 'I', 'I', 'X' ], 'I', str_ireplace([ 'X', 'I', 'I', 'X' ], 'X', str_ireplace([\
    \ 'I', 'I', 'X' ], 'I', str_ireplace([ 'X', 'I', 'X' ], 'X', str_ireplace([ 'I',\
    \ 'X' ], 'I', str_ireplace([ 'X', 'X' ], 'X', str_ireplace([ 'X' ], 'X', str_ireplace([\
    \ 'X' ], 'X', str_ireplace([ 'X' ], 'X', str_ireplace([ 'X' ], 'X', str_ireplace([\
    \ 'X' ], 'X', str_ireplace([ 'X' ], 'X', str_ireplace([ 'X' ], 'X', str_ireplace([\
    \ 'X' ], 'X', str_ireplace([ 'X' ], 'X', str_ireplace([ 'X' ], 'X', str_ireplace([\
    \ 'X' ], 'X', str_ireplace([ 'X' ], 'X', str_ireplace([ 'X' ], 'X', str_ireplace([\
    \ 'X' ], 'X', str_ireplace([ 'X' ], 'X', str_ireplace([ 'X' ], 'X', str_ireplace([\
    \ 'X' ], 'X', str_ireplace([ 'X' ], 'X', str_ireplace([ 'X' ], 'X', str_ireplace([\
    \ 'X' ], 'X', str_ireplace([ 'X' ], 'X', str_ireplace([ 'X' ], 'X', str_ireplace([\
    \ 'X' ], 'X', str_ireplace([ 'X' ], 'X', str_ire", "    // Limit the input to\
    \ 1000 as it's about 10x slower.\n    $number = max(1000, $number);\n\n    //\
    \ Create the string we're going to return.\n    $roman = '';\n    $base   = array(\n\
    \        1000  => 'M',\n        900   => 'CM',\n        500   => 'D',\n      \
    \  400   => 'CD',\n        100   => 'C',\n        90    => 'XC',\n        50 \
    \   => 'L',\n        40    => 'XL',\n        10    => 'X',\n        9     => 'IX',\n\
    \        5     => 'V',\n        4     => 'IV',\n        1     => 'I',\n    );\n\
    \n    // The input number can be negative or positive.\n    $negative = ($number\
    \ < 0);\n    if ($negative) {\n        $number = abs($number);\n    }\n\n    //\
    \ Start from the big numbers and work downwards.\n    for ($i = 0; $i < $number;\
    \ $i++) {\n        // Add each new value to the current roman value.\n       \
    \ $roman .= $base[$i];\n    }\n\n    // If the input number was negative, we need\
    \ to invert the string.\n    if ($negative) {\n        $roman = mb_substr($roman,\
    \ 0, -1);\n    }\n\n    // Now we have a roman string. Lowercase it.\n    return\
    \ mb_strtolower($roman);\n}\n</code>\nIt only works with positive integers.\n\
    <|/ a dscore=4 |>\n<| c |>\nThanks a lot, this helped me a lot! I added one more\
    \ example as well.\n<|/ c |>\n<| c |>\n`str_split` with `$split = str_split($roman);\n\
    \    for($i = 0; $i < count($split); $i++) {\n        list($n1, $n2) = explode('',\
    \ $split[$i]);\n        $split[$i] = $n1 . $n2; // Combine the two values.\n \
    \   }\n    $roman = implode('', $split); // And give back the modified string.`\n\
    <|/ c |>\n<| c |>\nI'm impressed by how well this works. But I've tested with\
    \ some more examples and it doesn't seem to work correctly. I put them in my answer.\
    \ Please see and let me know what I'm doing wrong.\n<|/ c |>\n<| c |>\nThis seems\
    \ to work well with my tests. I've added some examples that work.\n<|/ c |>\n\
    <| c |>\nThe problem is when you have more than 3 digits in the number, e.g. \"\
    1001\" gives us \"MCMXC\" but \"1009\" gives us \"MCD", "  $roman = '';\n  for\
    \ ($i = 0; $i < $number; $i++) {\n    $roman .= roman_numeral_to_roman($i);\n\
    \  }\n  return strtolower($roman);\n}\n", "    if ($number < 1 || $number > 1000)\
    \ {\n        return '';\n    }\n    // If the number is 1-9, return it directly\
    \ (don't romp).\n    if ($number <= 9) {\n        return $number;\n    }\n   \
    \ // Find the highest power of the number that can be represented in roman\n \
    \   // without going over. Then, we can just divide by that power and round down.\n\
    \    $max_roman_digit = $number + 9;\n    $max_roman_digit_power = log($max_roman_digit)\
    \ / log(10);\n    // $max_roman_digit_power === floor(log($max_roman_digit) /\
    \ log(10)) (ceiling log($max_roman_digit) / log(10))\n    $roman_digit_power =\
    \ floor($max_roman_digit_power);\n    // Round down, so the digits are all powers\
    \ of 10.\n    $roman_digits = $max_roman_digit - $roman_digit_power;\n    // We\
    \ know that $roman_digits must be between 1 and 4, because it is multiplied\n\
    \    // by 10, so we'll also know that $roman_digits_power must be between 1 and\
    \ 3\n    // and can thus be safely divided by 10.\n    // Therefore, $roman_digits\
    \ will always be < 10 and $roman_digits_power will always\n    // be < 3.\n  \
    \  // This is important for us to be able to test if the number is within the\
    \ valid\n    // range. For example, if we have an integer number that would be\
    \ outside the\n    // range [1, 1000], we'll need to add a leading 0 to it to\
    \ get it within the range.\n    // For example, to make a number between 0 and\
    \ 1000:\n    // >>> int_to_mini_roman(119)\n    // \"00x\"\n    // >>> int_to_mini_roman(1000)\n\
    \    // \"1000\"\n    if ($roman_digits < 1 || $roman_digits > 4) {\n        $roman_digits\
    \ = 1;\n    }\n    if ($roman_digits_power < 1 || $roman_digits_power > 3) {\n\
    \        $roman_digits_power = 1;\n    }\n    // Now that we have our variables\
    \ set up for our loop, we simply need to do some\n    // logic to determine what\
    \ roman numerals to return.\n    // We know that each roman numeral is between\
    \ 1 and 4, and that each roman numeral\n    // is made up of some number of identical\
    \ digits, so we'll start off with a\n    // for loop from 1 through 4 (inclusive).\n\
    \    $roman_numerals = array();\n    for ($i = 1; $i <= 4; $i++) {\n        //\
    \ Multiply the original number by 10 using the $i digit we found to form a\n \
    \       // new number.\n        // For example, if ", "  $roman = '';\n  while\
    \ (1) {\n    // Get remainder and update number\n    $remainder = $number % 1000;\n\
    \    $number = floor($number / 1000);\n    if ($number === 0) {\n      break;\n\
    \    }\n    $roman .= roman($remainder);\n  }\n  return strtolower($roman);\n\
    }\n\n/**\n * A simple function for formatting numbers into a string\n * for printing.\n\
    \ *\n * Example:\n *\n * <code>\n * echo format_number(1234.56);     // 12,345.00\n\
    \ * echo format_number(1234.56, 2); // 12,346\n * echo format_number(1234.56,\
    \ 2); // 12,35\n * echo format_number(1234.56, 2, '.'); // 12.35\n * echo format_number(1234.56,\
    \ 2, '-'); // 12-35\n * </code>\n *\n * @param double $number\n *   A floating\
    \ point number to format.\n * @param int $precision\n *   The number of digits\
    \ to display.\n * @param string $thousands_sep\n *   (optional) The character\
    \ to use as thousands separator. Defaults to\n *   an empty string.\n * @param\
    \ string $decimal_point\n *   (optional) The character to use as decimal point.\
    \ Defaults to a\n *   period.\n *\n * @return string Formatted number string.\n\
    \ */", "\t$int_num = $number;\n\twhile ($int_num > 1000) {\n\t\t$int_num -= 1000;\n\
    \t\t$mini_roman_numerals[] = 'M';\n\t}\n\twhile ($int_num >= 1000) {\n\t\t$int_num\
    \ -= 1000;\n\t\t$mini_roman_numerals[] = 'CM';\n\t}\n\twhile ($int_num >= 500)\
    \ {\n\t\t$int_num -= 500;\n\t\t$mini_roman_numerals[] = 'D';\n\t}\n\twhile ($int_num\
    \ >= 100) {\n\t\t$int_num -= 100;\n\t\t$mini_roman_numerals[] = 'CD';\n\t}\n\t\
    while ($int_num >= 50) {\n\t\t$int_num -= 50;\n\t\t$mini_roman_numerals[] = 'C';\n\
    \t}\n\twhile ($int_num >= 10) {\n\t\t$int_num -= 10;\n\t\t$mini_roman_numerals[]\
    \ = 'XC';\n\t}\n\twhile ($int_num >= 5) {\n\t\t$int_num -= 5;\n\t\t$mini_roman_numerals[]\
    \ = 'L';\n\t}\n\twhile ($int_num >= 1) {\n\t\t$int_num -= 1;\n\t\t$mini_roman_numerals[]\
    \ = 'XL';\n\t}\n\tif ($int_num > 1) {\n\t\t$mini_roman_numerals[] = 'X';\n\t}\n\
    \tif ($int_num > 0) {\n\t\t$mini_roman_numerals[] = 'I';\n\t}\n\tsort($mini_roman_numerals);\n\
    \treturn join('', array_reverse(explode(' ', join('', array_reverse($mini_roman_numerals)))))->toLower();\n\
    }", "  $result = '';\n  $k = 1000;\n  while (true) {\n    if ($number >= $k) {\n\
    \      $result += $number % $k;\n      $number /= $k;\n    } else {\n      break;\n\
    \    }\n    $k *= 10;\n  }\n  $result = (strlen($result) == 1) ? $result : ''\
    \ . strtolower($result);\n  return $result;\n}\n", "  $roman = '';\n  $roman_numerals\
    \ = array('', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X', 'XI',\
    \ 'XII', 'XIII', 'XIV', 'XX', 'XXI', 'XXII', 'XIIXX');\n  $i = 0;\n  while($number\
    \ >= 1000) {\n    $number -= 1000;\n    $roman .= $roman_numerals[$i];\n    ++$i;\n\
    \  }\n  while($number >= 100) {\n    $number -= 100;\n    $roman .= $roman_numerals[$i].'C';\n\
    \    ++$i;\n  }\n  while($number >= 10) {\n    $number -= 10;\n    $roman .= $roman_numerals[$i].'D';\n\
    \    ++$i;\n  }\n  while($number >= 1) {\n    $roman .= $roman_numerals[$i].'M';\n\
    \    ++$i;\n    $number -= 1;\n  }\n  return $roman;\n}\n", "  if (!is_int($number)\
    \ || $number < 1 || $number > 1000) {\n    return '';\n  }\n  $roman_numerals\
    \ = array(\n    1000,\n    900,\n    500,\n    400,\n    100,\n    90,\n    50,\n\
    \    4,\n    10,\n    9,\n    5,\n    4,\n    1,\n    9,\n    5,\n    4,\n   \
    \ 10,\n    9,\n    5,\n    4,\n    1,\n    9,\n    5,\n    4,\n    10,\n    9,\n\
    \    5,\n    4,\n    1,\n    9,\n    5,\n    4,\n    10,\n    9,\n    5,\n   \
    \ 4,\n    1,\n    9,\n    5,\n    4,\n    10,\n    9,\n    5,\n    4,\n    1,\n\
    \    9,\n    5,\n    4,\n    10,\n    9,\n    5,\n    4,\n    1,\n    9,\n   \
    \ 5,\n    4,\n    10,\n    9,\n    5,\n    4,\n    1,\n    9,\n    5,\n    4,\n\
    \    10,\n    9,\n    5,\n    4,\n    1,\n    9,\n    5,\n    4,\n    10,\n  \
    \  9,\n    5,\n    4,\n    1,\n    9,\n    5,\n    4,\n    10,\n    9,\n    5,\n\
    \    4,\n    1,\n    9,\n    5,\n    4,\n    10,\n    9,\n    5,\n    4,\n   \
    \ 1,\n    9,\n    5,\n    4,\n    10,\n    9,\n    5,\n    4,\n    1,\n    9,\n\
    \    5,\n    4,\n    10,\n    9,\n    5,\n    4,\n    1,\n    9,\n    5,\n   \
    \ 4,\n    10,\n    9,\n    5,\n    4,\n    1,\n    9,\n    5,\n    4,\n    10,\n\
    \    9,\n    5,\n    4,\n    1,\n    9,\n    5,\n    4,\n    10,\n    9,\n   \
    \ 5,\n    4,\n    1,\n    9,\n    5,\n    4,\n    10,\n    9,\n    5,\n    4,\n\
    \    1,\n    9,\n    5,\n    4,\n    10,\n    9,\n    5,\n    4,\n    1,\n   \
    \ 9,\n    5,\n    4,\n    10,\n    9,\n    5,\n    4,\n    1,\n    9,\n    5,\n\
    \    4,\n    10,", "    if ($number < 1 || $number > 1000)\n        return \"\"\
    ;\n    $roman = \"\";\n    $counter = 1;\n    // Convert each numeral in $number\
    \ to a character\n    foreach (str_split($number, 1) as $key => $numeral) {\n\
    \        // If the numeral is between 1 and 9, append the numeral to the $roman\n\
    \        // string, separated by a space.\n        if ($key < 2) {\n         \
    \   $roman .= $numeral;\n        // If it's between 10 and 99, append the numeral\
    \ to the $roman string,\n        // followed by an 'i' character.\n        } elseif\
    \ ($key >= 2 && $key <= 5) {\n            $roman .= $numeral . \" \";\n      \
    \  // If it's between 100 and 999, append the numeral to the $roman string\n \
    \       // followed by the letter 'x', followed by an 'i' character.\n       \
    \ } elseif ($key >= 6) {\n            $roman .= $numeral . \"x\";\n        //\
    \ If it's between 1000 and 9999, append the numeral to the $roman\n        //\
    \ string followed by the letter 'c', followed by an 'i' character.\n        }\
    \ elseif ($key >= 7 && $key <= 8) {\n            $roman .= $numeral . \"c\";\n\
    \        // If it's over 9999, just append the numeral to the $roman string.\n\
    \        } else {\n            $roman .= $numeral;\n        }\n        // Add\
    \ the $counter value to $counter and increment it.\n        $counter++;\n    }\n\
    \    return $roman;\n}", "    $roman = '';\n    while ($number >= 1000) {\n  \
    \      $roman .= 'M';\n        $number -= 1000;\n    }\n    if ($number >= 100)\
    \ {\n        $roman .= 'C';\n        $number -= 100;\n    }\n    if ($number >=\
    \ 10) {\n        $roman .= 'L';\n        $number -= 10;\n    }\n    if ($number\
    \ >= 1) {\n        $roman .= 'X';\n    }\n    return $roman;\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nThanks for sharing your code. I have used it, but I got the following\
    \ error\n`Fatal error: Uncaught Error: Call to undefined function int_to_mini_roman()\
    \ in C:\\xampp\\htdocs\\new\\php\\functions.php:2 Stack trace: #0 {main} thrown\
    \ in C:\\xampp\\htdocs\\new\\php\\functions.php on line 2`\n<|/ c |>\n<| c |>\n\
    I have tested this code and it works for me with PHP 7.1.3 .\n<|/ c |>\n<| a dscore=2\
    \ tags=php,mysql,wordpress |>\nThis was inspired by this post: https://stackoverflow.com/a/27881678/3287283.\n\
    I needed to implement a solution for all integers in the range 1 to 999. This\
    \ means that it only works for integers in the range 1 to 999, inclusive.\nThe\
    \ solution is as follows:\n<code>\n<?php\n/**\n * Convert integers to roman numerals.\n\
    \ * \n * int $number The integer to convert to roman numeral.\n * string\n */",
  "    if ($number < 1 || $number > 1000) {\n        throw new \\InvalidArgumentException(\"\
    Invalid number: {$number}\");\n    }\n\n    // The array is initialized in reverse\
    \ order (because the last elements are\n    // the least significant ones).\n\
    \    $roman = [];\n    $nstr = str_pad($number, \"9\", STR_PAD_LEFT);\n\n    $istr\
    \ = $nstr;\n    $c = 0;\n    for ($i = 1; $i <= strlen($nstr); $i++) {\n     \
    \   $str = $istr[$i];\n        $numeral = array_shift($roman);\n        if ($str\
    \ == 'I') {\n            $numeral *= 2;\n            $numeral += array_shift($roman);\n\
    \        }\n        $c = $numeral;\n\n        // The last two elements are stored\
    \ in another array because the\n        // least significant have to be subtracted\
    \ from the number before\n        // they can be added to the next character.\n\
    \        $digits = str_split($nstr[$i-1]);\n        array_unshift($digits, $digits[count($digits)-1]);\n\
    \        array_unshift($digits, array_shift($roman));\n        $str = $c . implode($digits);\n\
    \        if ($i < strlen($nstr) - 1) {\n            $str .= array_shift($roman);\n\
    \        }\n        $roman[] = $str;\n    }\n\n    return implode(\"\", $roman);\n\
    }\n", "  $roman = array('',\n    'M',\n    'CM',\n    'D',\n    'CD',\n    'C',\n\
    \    'XC',\n    'L',\n    'XL',\n    'X',\n    'IX',\n    'V',\n    'IV',\n  \
    \  'I');\n  $numeral = '';\n  $position = 0;\n  while ($number >= 1000) {\n  \
    \  $number -= 1000;\n    $numeral .= $roman[$position];\n    $position++;\n  }\n\
    \  $numeral .= $roman[$position];\n  while ($number >= 100) {\n    $number -=\
    \ 100;\n    $numeral .= $roman[$position];\n    $position++;\n  }\n  $numeral\
    \ .= $roman[$position];\n  while ($number >= 10) {\n    $number -= 10;\n    $numeral\
    \ .= $roman[$position];\n    $position++;\n  }\n  $numeral .= $roman[$position];\n\
    \  $position = 0;\n  while ($number > 0) {\n    $numeral .= $roman[$position];\n\
    \    $number--;\n    $position++;\n  }\n  return strtolower($numeral);\n}\n",
  "  // Special case for zero\n  if ($number === 0) {\n    return \"zero\";\n  }\n\
    \  // If the number is negative, add 100 to it\n  $negative = $number < 0 ? 1\
    \ : 0;\n  $number += $negative * 100;\n  // Limit to two decimal places\n  $number\
    \ = number_format($number, 2);\n  $result = '';\n  while ($number > 0) {\n   \
    \ $remainder = $number % 10;\n    $number = floor($number / 10);\n    $result\
    \ = str_pad($result, $remainder, chr(ord('A') + $remainder - 1), STR_PAD_LEFT);\n\
    \  }\n  // Special case for the last character\n  return $result . str_pad('',\
    \ $number, '', STR_PAD_RIGHT);\n}\n", "  $roman = array(\"i\", \"ii\", \"iii\"\
    , \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\");\n  $result = \"\";\n  if\
    \ ($number < 0 || $number > 1000) {\n    // Outside allowed range.\n    return\
    \ \"\";\n  }\n  do {\n    $remainder = $number % 10;\n    $result   = array_shift($roman)\
    \ . $result;\n    $number   = $remainder > 0 ? $number / 10 : 0;\n  } while ($number\
    \ > 0);\n  return $result;\n}\n", "\tstatic $romans = array(\n\t\t1000,\n\t\t\
    900,\n\t\t500,\n\t\t400,\n\t\t100,\n\t\t90,\n\t\t50,\n\t\t40,\n\t\t10,\n\t\t9,\n\
    \t\t5,\n\t\t4,\n\t\t3,\n\t\t2,\n\t\t1,\n\t);\n\t$result = '';\n\n\tdo {\n\t\t\
    if ($number >= $romans[$i]) {\n\t\t\t$result .= $romans[$i];\n\t\t\t$number =\
    \ $number % $romans[$i];\n\t\t} else {\n\t\t\t$result += $number%10;\n\t\t\t$number\
    \ = floor($number/10);\n\t\t}\n\t} while (0 < $number);\n\n\treturn $result;\n\
    }", "    $roman = array('M','CM','D','CD','C', 'XC','L','XL','X','IX','V','IV','I');\n\
    \    // Special case for 10\n    if ($number == 10) {\n        return 'X';\n \
    \   }\n    // Special case for 9\n    if ($number == 9) {\n        return 'IX';\n\
    \    }\n    // Special case for 4\n    if ($number == 4) {\n        return 'IV';\n\
    \    }\n    // Special case for 9\n    if ($number > 4 && $number < 9) {\n   \
    \     return $roman[$number-4];\n    }\n    // Normal case\n    $result = \"\"\
    ;\n    while (1) {\n        if ($number >= 1000) {\n            $result .= $roman[$number%100];\n\
    \            $number /= 100;\n        } else {\n            $result .= $roman[$number];\n\
    \            break;\n        }\n    }\n    return $result;\n}", "  $roman = \"\
    \";\n  $lookup = array(\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"\
    XC\", \"C\", \"CD\", \"D\", \"CM\");\n  do {\n    $roman .= $lookup[(int)($number\
    \ % 10)];\n    $number /= 10;\n  } while ($number > 0);\n  return strtolower($roman);\n\
    }\n", "  $result = '';\n  $numerals = [\n    1 => 'i', 2 => 'ii', 3 => 'iii',\
    \ 4 => 'iv', 5 => 'v', 6 => 'vi', 7 => 'vii',\n    8 => 'viii', 9 => 'ix', 10\
    \ => 'x', 11 => 'xii', 12 => 'xiii', 13 => 'xiv', 14 => 'xv',\n    15 => 'xvi',\
    \ 16 => 'xvii', 17 => 'xviii', 18 => 'xix', 19 => 'x', 20 => 'xi',\n    30 =>\
    \ 'xiii', 40 => 'xiv', 50 => 'xv', 60 => 'xvi', 70 => 'xvii', 80 => 'xviii', 90\
    \ => 'xix',\n    100 => 'x', 200 => 'xi', 300 => 'xii', 400 => 'xiv', 500 => 'xv',\
    \ 600 => 'xvi', 700 => 'xvii',\n    800 => 'xviii', 900 => 'xix', 1000 => 'x',\
    \ 10000 => 'xi', 100000 => 'xii', 1000000 => 'x',\n    10000000 => 'xi', 100000000\
    \ => 'xii', 1000000000 => 'xiv', 10000000000 => 'xv', 100000000000 => 'xvi',\n\
    \    1000000000000 => 'xvii', 10000000000000 => 'xviii', 100000000000000 => 'xix',\
    \ 1000000000000000 => 'xi',\n    10000000000000000 => 'xiii', 1000000000000000000\
    \ => 'xiv', 10000000000000000000 => 'xv', 100000000000000000000 => 'xvi',\n  \
    \  1000000000000000000000 => 'xvii', 10000000000000000000000 => 'xviii', 100000000000000000000000\
    \ => 'xix',\n  ];\n  if ($number < 1 || $number >= 1000000) {\n    return '?';\n\
    \  }\n  for ($i = 0; $i < $number; ++$i) {\n    $result .= $numerals[$i];\n  }\n\
    \  return mb_strtolower($result);\n}", "  $roman = '.';\n  $roman_to_int = array(\n\
    \    'M' => 1000000,\n    'CM' => 10000,\n    'D' => 1000,\n    'CD' => 100,\n\
    \    'C' => 10,\n    'XC' => 1,\n    'L' => 10,\n    'XL' => 5,\n    'X' => 1,\n\
    \    'IX' => 10,\n    'V' => 5,\n    'IV' => 4,\n    'I' => 1,\n  );\n\n  foreach\
    \ ($roman_to_int as $roman => $int) {\n    while ($number >= $int) {\n      $roman\
    \ .= 'M';\n      $number -= $int;\n    }\n  }\n\n  return $roman;\n}\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nHaving looked at both answers, this seems cleaner\n\
    <|/ c |>\n<| c |>\nThis is by far the most elegant solution to this question.\
    \ Thanks so much!\n<|/ c |>\n<| c |>\nThis solution does not work well with large\
    \ numbers (like 1000000).\n<|/ c |>\n<| c |>\nGreat solution, even better than\
    \ [this one](http://stackoverflow.com/a/1055337/67332).\n<|/ c |>\n<| c |>\nAwesome\
    \ solution\n<|/ c |>\n<| a dscore=5 |>\nUsing RecursiveIteratorIterator\n<code>",
  "  // Check to see if the number is too large or not a number\n  if (!is_int($number)\
    \ || $number < 1 || $number > 1000) {\n    return \"\";\n  }\n\n  // Create an\
    \ array of thousand and hundreds\n  $thousands = floor($number / 1000);\n  $hundreds\
    \ = floor($number % 1000);\n  $hundreds = ($hundreds < 10 ? \"0\" : \"\") . $hundreds;\n\
    \n  // Create the array of numeral values\n  $numeral = array();\n\n  for ($i\
    \ = 0; $i < 3; $i++) {\n    $numeral[$i] = ($thousands > 0 ? '' : ($hundreds >\
    \ 0 ? \"v\" : \"i\"));\n    $thousands = floor($thousands / 1000);\n    $hundreds\
    \ = floor($hundreds / 1000);\n  }\n\n  return array_sum($numeral);\n}\n", "  //\
    \ Validate input\n  if (!is_int($number) || $number < 1 || $number > 1000) return\
    \ null;\n  $roman = array('M' => 'MM', 'CM' => 'CC', 'C' => 'XC', 'X' => 'XL',\
    \ 'L' => 'X',\n                 'D' => 'CD', 'D' => 'CM', 'C' => 'IV', 'I' =>\
    \ 'V');\n  $result = '';\n\n  // Convert large numbers to strings\n  if ($number\
    \ > 1000000000) {\n    $number /= 1000000000;\n    $result .= $roman['M'] . str_repeat('MMMM',\
    \ floor($number / 1000000000));\n    $number %= 1000000000;\n  }\n  if ($number\
    \ > 1000000) {\n    $number /= 1000000;\n    $result .= $roman['MM'] . str_repeat('MMM',\
    \ floor($number / 1000000));\n    $number %= 1000000;\n  }\n  if ($number > 1000)\
    \ {\n    $number /= 1000;\n    $result .= $roman['M'] . str_repeat('MM', floor($number\
    \ / 1000));\n    $number %= 1000;\n  }\n  if ($number > 100) {\n    $number /=\
    \ 100;\n    $result .= $roman['D'] . str_repeat('D', floor($number / 100));\n\
    \    $number %= 100;\n  }\n  if ($number > 10) {\n    $number /= 10;\n    $result\
    \ .= $roman['C'] . str_repeat('C', floor($number / 10));\n    $number %= 10;\n\
    \  }\n  $result .= $roman[$number];\n  return $result;\n}", "    $int_length =\
    \ strlen($number);\n    $mini_roman_length = strlen($roman_to_int);\n    \n  \
    \  // Round down to nearest 1000\n    $number = floor($number/1000) * 1000;\n\
    \    \n    // Round down to nearest 1,000\n    $number = floor($number/100) *\
    \ 100;\n    \n    // Round down to nearest 10,000\n    $number = floor($number/10)\
    \ * 10;\n    \n    // Round down to nearest 1,000,000\n    $number = floor($number/1)\
    \ * 1;\n    \n    // Now just loop through the string of roman numerals and return\n\
    \    // the first match\n    for ($i = 0; $i < $mini_roman_length; $i++) {\n \
    \       if ($roman_to_int[$i] == $number) {\n            if ($i == 0) {\n    \
    \            $mini_roman = $roman_to_int[$i];\n            } else {\n        \
    \        $mini_roman .= $roman_to_int[$i];\n            }\n            break;\n\
    \        }\n    }\n    \n    // Handle special cases\n    if ($number < 1000)\
    \ {\n        $mini_roman = chr($number);\n    } else if ($number == 1000) {\n\
    \        $mini_roman = 'mi';\n    } else if ($number == 1000000) {\n        $mini_roman\
    \ = 'mmm';\n    } else {\n        $int_length = strlen($number);\n        \n \
    \       // Find tens\n        $tens = 0;\n        $tens_index = 0;\n        \n\
    \        for ($i = 0; $i < $int_length; $i++) {\n            if ($number[$i] ==\
    \ 10) {\n                $tens_index = $i;\n                break;\n         \
    \   }\n        }\n        \n        // Find units\n        $units = $int_length\
    \ - $tens_index;\n        \n        $tens_amount = floor($units/3);\n        \n\
    \        if ($tens_amount > 0) {\n            $tens = 0;\n            $tens_index\
    \ = 0;\n            for ($i = 0; $i < $tens_amount; $i++) {\n                if\
    \ ($units-$tens_index == 2) {\n                    $tens = $tens * 10;\n     \
    \               $tens_index = $i;\n                    break;\n              \
    \  }\n            }\n        }\n        \n        $units = $units - $tens_amount\
    \ - 1;\n        \n        // Find hundreds\n        $hundreds = 0;\n        $hundreds_index\
    \ = 0;\n        \n        for ($i = 0; $i < $int_length; $i++) {\n           \
    \ if ($number[$i] == 100) {\n                $hundreds_index = $i;\n         \
    \       break;\n            }\n        }\n        \n        // Find tens to hundreds\n\
    \        $tens_hundreds = 0;\n        $tens_hundred", "  $roman =  \"\";\n\n \
    \ // check for zero\n  if ($number <= 0) return $roman;\n\n  // check for negative\
    \ number\n  if ($number < 0) return $roman;\n\n  // base cases\n  if ($number\
    \ == 1) { return \"x\"; }\n  if ($number == 2) { return \"x\"; }\n  if ($number\
    \ > 100) { return $roman; }\n\n  // get last 3 digits\n  $roman = (string) $number;\n\
    \  $lastThree = substr($roman, -3);\n\n  // get rid of first set of numerals\n\
    \  $roman = substr($roman, 0, -3);\n\n  // check for I\n  if ($lastThree == \"\
    I\") {\n    $roman = \"v\"; }\n  // check for V\n  elseif ($lastThree == \"V\"\
    ) {\n    $roman = \"iv\"; }\n  // check for X\n  elseif ($lastThree == \"X\")\
    \ {\n    $roman = \"iv\"; }\n  // check for L\n  elseif ($lastThree == \"L\")\
    \ {\n    $roman = \"i\"; }\n\n  return $roman;\n}\n", "\tif ($number < 1 || $number\
    \ > 1000) {\n\t\tthrow new Exception('Invalid integer: ' . $number);\n\t}\n\t\
    $roman = '';\n\t$numerals = [\n\t\t1000   => 'M',\n\t\t900    => 'CM',\n\t\t500\
    \    => 'D',\n\t\t400    => 'CD',\n\t\t100    => 'C',\n\t\t90     => 'XC',\n\t\
    \t50     => 'L',\n\t\t40     => 'XL',\n\t\t10     => 'X',\n\t\t9      => 'IX',\n\
    \t\t5      => 'V',\n\t\t4      => 'IV',\n\t\t1      => 'I'\n\t];\n\n\tdo {\n\t\
    \t$roman .= $numerals[$number % 10];\n\t\t$number = floor($number / 10);\n\t}\
    \ while ($number > 0);\n\n\treturn $roman;\n}\n", "  if ($number < 1 || $number\
    \ > 1000)\n    return '';\n\n  $str = '';\n  for ($i = 1; $i < $number; ++$i)\
    \ {\n    $str .= MiniRoman::lookup($i);\n  }\n\n  return strtolower($str);\n}\n",
  "  $roman = '';\n  $value = 0;\n  if ($number < 1 || $number > 1000) {\n    return\
    \ $roman;\n  }\n\n  // special case for zero\n  if ($number == 0) {\n    return\
    \ 'x';\n  }\n\n  // special case for one\n  if ($number == 1) {\n    return 'x';\n\
    \  }\n\n  $last_value = 0;\n  for ($i = 0; $i < $number; $i++) {\n    // get current\
    \ value from the array\n    $value = $digits[$i];\n    if ($last_value != $value)\
    \ {\n      $roman .= $values[$value];\n    }\n    // save current value\n    $last_value\
    \ = $value;\n  }\n\n  return $roman;\n}", "  // $number > 0 to avoid weird PHP\
    \ errors for negative numbers\n  if ($number > 0){\n    $number = 100 * $number\
    \ + 1;\n    $str = \"\";\n    while ($number > 0){\n      $str = int_to_mini_roman($number\
    \ % 10);\n      $number = floor($number / 10);\n      $str .= $str;\n    }\n \
    \   return $str;\n  }\n  return \"0\";\n}\n", "  if ($number < 1 || $number >\
    \ 1000) {\n    die(\"int_to_mini_roman() called with invalid argument\");\n  }\n\
    \n  $roman = \"\";\n  for ($i = 1; $i < $number; $i++) {\n    $roman = roman($i).$roman;\n\
    \  }\n  return mb_strtolower($roman);\n}\n", "\tassert(is_integer($number));\n\
    \tassert($number > 0);\n\tassert($number <= 1000);\n\t$roman_romans_table = array(\n\
    \t\t100\t=> 'M',\n\t\t900\t=> 'CM',\n\t\t500\t=> 'D',\n\t\t400\t=> 'CD',\n\t\t\
    100\t=> 'C',\n\t\t90\t=> 'XC',\n\t\t50\t=> 'L',\n\t\t40\t=> 'XL',\n\t\t10\t=>\
    \ 'X',\n\t\t9\t=> 'IX',\n\t\t5\t=> 'V',\n\t\t4\t=> 'IV',\n\t\t1\t\t=> 'I');\n\t\
    foreach($roman_romans_table as $roman => $roman_roman) {\n\t\t$number_of_romans\
    \ = count($roman_romans_table);\n\t\t$total_number_of_romans = $number_of_romans\
    \ + 1;\n\t\tif ($number == 1) {\n\t\t\treturn $roman_roman;\n\t\t}\n\t\t$max_roman_value\
    \ = $total_number_of_romans - 1;\n\t\tif ($number == $max_roman_value) {\n\t\t\
    \treturn $roman_roman . $roman_roman;\n\t\t}\n\t\tif ($number % $number_of_romans\
    \ == 0) {\n\t\t\t$rest = floor($number / $number_of_romans);\n\t\t\t$rest = floor($rest\
    \ * $number_of_romans);\n\t\t\t$rest = floor($rest) + $roman_roman;\n\t\t\treturn\
    \ $roman_roman . $rest;\n\t\t}\n\t}\n\treturn '?';\n}\n", "  $roman = '';\n  for\
    \ ($i = 0; $i < strlen($roman); $i++) {\n    $roman .= int_to_roman($number, $i);\n\
    \  }\n  return $roman;\n}\n", "    if ($number < 1 || $number > 1000) {\n    \
    \    throw new InvalidArgumentException('Given number must be between 1 and 1000');\n\
    \    }\n    $roman = \"\";\n    for ($i = 1; $i <= $number; ++$i) {\n        $numeral\
    \ = get_numeral_by_roman($i);\n        $roman .= $numeral;\n    }\n    return\
    \ strtolower($roman);\n}\n", "    $roman = '';\n\n    while ($number > 0) {\n\
    \        $roman .= $romans[$number % 10];\n        $number -= $romans[$number\
    \ % 10];\n    }\n\n    return $roman;\n}\n", "  $roman = '';\n  $num   = abs($number);\n\
    \  $lower = ($num < 10);\n\n  if ($lower) {\n    // The given number is between\
    \ 10 and 99 -- i.e., no leading zero.\n    if ($num > 9) {\n      $roman = $roman.$romans[$num\
    \ - 10];\n    }\n  } else {\n    // The given number is between 100 and 999 --\
    \ i.e., no leading zero.\n    if ($num > 99) {\n      $roman = $romans[($num -\
    \ 100) / 10] + $roman;\n    }\n\n    // The given number is between 1000 and 9999\
    \ -- i.e., leading zero.\n    if ($num > 999) {\n      $roman = ($num - 1000)\
    \ / 100 + $roman;\n    }\n  }\n\n  return $roman;\n}\n", "    $roman = '';\n \
    \   if ($number < 1 || $number > 1000) {\n        return false;\n    }\n    while\
    \ ($number >= 1000) {\n        $number -= 1000;\n        $roman .= 'm';\n    }\n\
    \    while ($number >= 100) {\n        $number -= 100;\n        $roman .= 'c';\n\
    \    }\n    while ($number >= 10) {\n        $number -= 10;\n        $roman .=\
    \ 'l';\n    }\n    $roman .= $number;\n    $roman = strtolower($roman);\n    return\
    \ $roman;\n}\n</code>\n<|/ a |>\n<| a tags=php |>\nTry this:\n<code>\n<?php",
  "  $nums_roman = ['','i','ii','iii','iv','v','vi','vii','viii','ix'];\n  if($number\
    \ == 0) return $nums_roman[0];\n  $result = '';\n  while($number >= 1000) {\n\
    \    $number -= 1000;\n    $result .= $nums_roman[$number%10];\n    $number /=\
    \ 10;\n  }\n  return $result . nums_roman[$number];\n}\n", "  // Initialize $roman_string\
    \ as empty string\n  $roman_string = \"\";\n  // Initialize $roman_array as empty\
    \ array\n  $roman_array = array();\n\n  // Use a while loop to keep track of the\
    \ numeral equivalent\n  while($number != 0) {\n    // $temp_number is initially\
    \ equal to $number\n    $temp_number = $number;\n    // Use a while loop to keep\
    \ track of how many times the numeral equivalent \n    // needs to be divided\n\
    \    $count = 0;\n    // Use a while loop to keep track of the numeral equivalent\
    \ in reverse order\n    while($temp_number > 0) {\n      // If $temp_number is\
    \ divisible by 10, add 'x' to the numeral equivalent string\n      if($temp_number\
    \ % 10 == 0) {\n        // $count++ is equal to $count + 1 after this line\n \
    \       $count++;\n        // Append 'x' to the numeral equivalent string\n  \
    \      $roman_string = $roman_string . 'x';\n      // If $temp_number is divisible\
    \ by 100 and less than 1000, subtract 100 \n      // from $temp_number\n     \
    \ } elseif($temp_number % 100 < 10) {\n        $temp_number = $temp_number - 100;\n\
    \        // $count++ is equal to $count + 1 after this line\n        $count++;\n\
    \        // Append 'i' to the numeral equivalent string\n        $roman_string\
    \ = $roman_string . 'i';\n      // If $temp_number is divisible by 100 and greater\
    \ than 1000, subtract 10 \n      // from $temp_number and add 'x' to the numeral\
    \ equivalent string\n      } else {\n        $temp_number = $temp_number - 10;\n\
    \        // $count++ is equal to $count + 1 after this line\n        $count++;\n\
    \        // Append 'v' to the numeral equivalent string\n        $roman_string\
    \ = $roman_string . 'v';\n      }\n    }\n    // Append $count times the numeral\
    \ equivalent to the numeral equivalent string\n    $roman_string = $roman_string\
    \ . $count;\n    // Use a while loop to keep track of the numeral equivalent in\
    \ reverse order\n    $temp_number = $number;\n    while($temp_number > 0) {\n\
    \      if($temp_number % 10 == 0) {\n        $count++;\n        $roman_string\
    \ = $roman_string . 'x';\n      } elseif($temp_number % 100 < 10) {\n        $temp_number\
    \ = $temp_number - 100;\n        $count++;\n        $roman_string = $roman_string\
    \ . 'i';\n      } elseif($temp_number % 100 > 100) {\n        $temp_number = $temp_number\
    \ - 10;\n        $count++;\n        $roman_string = $roman_string . 'v';\n", " \
    \ // Round to nearest hundredth\n  $number = floor($number / 100);\n\n  if ($number\
    \ == 0) {\n    return \"0\";\n  }\n\n  $str = \"\";\n  $i = 0;\n  while (isset($romans[$i])\
    \ && $romans[$i] <= $number) {\n    $i++;\n  }\n\n  // Add the letter for the\
    \ number we found to the string\n  $str .= $romans[$i];\n\n  // If the next number\
    \ is greater than $number,\n  // we're done and have just the one letter to return.\n\
    \  if (isset($romans[$i])) {\n    $i++;\n  }\n  while ($romans[$i] <= $number)\
    \ {\n    $i++;\n  }\n\n  // Add the remaining letters for the remaining numbers\n\
    \  // to the string\n  for (; $i < 5; $i++) {\n    $str .= $romans[$i];\n  }\n\
    \n  return mb_strtolower($str);\n}\n", "    $result = '';\n    $base = 100000000;\n\
    \    while ($number >= $base) {\n        $result .= $number % $base;\n       \
    \ $number /= $base;\n    }\n    return $result;\n}\n", "    $roman = '';\n   \
    \ $num2rom = array(\n        1000, 'M', 'MM',\n        900, 'CM', 'D',\n     \
    \   500, 'D', 'CD',\n        400, 'C', 'XC',\n        100, 'L', 'XL',\n      \
    \  90  , 'X', 'XC',\n        50  , 'L', 'CD',\n        40  , 'C', 'M',\n     \
    \   10  , 'V', 'IV',\n        9   , 'IV', 'I',\n        5   , 'I', 'V',\n    \
    \    4   , 'V', 'X',\n        1   , 'I', 'X',\n        1   , 'X', 'I',\n     \
    \   1   , 'I', 'V',\n        1   , 'V', 'X',\n        0   , 'X', 'L',\n      \
    \  0   , 'X', 'X',\n        0   , 'I', 'V',\n        0   , 'V', 'IV',\n      \
    \  0   , 'V', 'X',\n        0   , 'V', 'XC',\n        0   , 'L', 'XL',\n     \
    \   0   , 'L', 'CD',\n        0   , 'D', 'CD',\n        0   , 'D', 'M',\n    \
    \    0   , 'C', 'M',\n        0   , 'C', 'XC',\n        0   , 'C', 'IV',\n   \
    \     0   , 'C', 'IX',\n        0   , 'C', 'III',\n        0   , 'C', 'II',\n\
    \        0   , 'C', 'I',\n        0   , 'C', 'X',\n        0   , 'C', 'IV',\n\
    \        0   , 'C', 'V',\n        0   , 'C', 'III',\n        0   , 'C', 'X',\n\
    \        0   , 'C', 'XC',\n        0   , 'C', 'IV',\n        0   , 'C', 'IX',\n\
    \        0   , 'C', 'X',\n        0   , 'C', 'XC',\n        0   , 'C', 'V',\n\
    \        0   , 'C', 'IV',\n        0   , 'C', 'IX',\n        0   , 'C', 'II',\n\
    \        0   , 'C', 'I',\n        0   , 'C', 'III',\n        0   , 'C', 'X',\n\
    \        0   , 'C', 'XC',\n        0   , 'C', 'V',\n        0   , 'C', 'IX',\n\
    \        0   , 'C', 'X',\n        0   , 'C', 'IV',\n        0   , 'C', 'III',\n\
    \        0   , 'C', 'X',\n        0   , 'C', 'XC',\n        0   , 'C', 'V',\n\
    \        0   , 'C', 'IV',\n        0   , 'C', 'IX',\n        0   , 'C', 'II',\n\
    \        0   , 'C', 'I',\n        0   , 'C', 'III", "  list($base, $integer) =\
    \ explode('-', $number);\n  $alphabet = array('', 'M', 'CM', 'D', 'CD', 'C', 'XC',\
    \ 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I');\n  $roman = '';\n  do {\n    $roman .=\
    \ $alphabet[$integer % 10];\n    $integer /= 10;\n  } while($integer > 0);\n \
    \ return $roman . '' . $base;\n}", "  $roman = '';\n  $base = [1000, 900, 500,\
    \ 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n  $exponents = [-1, -1, 0, 1, 1, 1,\
    \ 2, 2, 3,\n                3, 4, 5, 6];\n  $num = $number;\n\n  while ($num >\
    \ 0) {\n    $r = floor($num / $base[$i]);\n    $num = $num - $r * $base[$i];\n\
    \    if ($num < 0) {\n      $roman = '';\n      break;\n    }\n    $roman = $roman\
    \ . $romans[$i];\n    $i += 1;\n  }\n\n  return $roman;\n}", "    $roman = '';\n\
    \    while ($number > 0) {\n        $remainder = $number % 10;\n        $number\
    \ = floor($number / 10);\n        $roman .= $remainder == 5 ? 'm' : 'D';\n   \
    \ }\n    return $roman;\n}\n", "  $roman = array('M','CM','D','CD','C', 'XC','L','XL','X','IX','V','IV','I');\n\
    \  $result = '';\n  for ($i = $number; $i > 0; $i /= 10)\n    $result .= $roman[$i];\n\
    \  return strtolower($result);\n}\n", "  $roman = '';\n  $index = 0;\n  while\
    \ (1) {\n    $value = floor($number / 1000) + $index++;\n    // If value has more\
    \ than one digit, use the next one.\n    if ($value > 9) {\n      $value %= 100;\n\
    \      if ($value == 0)\n        break;\n    }\n    $roman .= $value;\n    $number\
    \ %= 1000;\n  }\n  return $roman;\n}\n", "  if ($number < 1 || $number > 1000)\
    \ {\n    return FALSE;\n  }\n  $roman = '';\n  for ($i = 1; $i < $number - 1;\
    \ $i++) {\n    $roman .= 'M';\n  }\n  return $roman;\n}\n", "    $mini_roman =\
    \ '';\n    if ($number < 0 || $number > 999) {\n        return $mini_roman;\n\
    \    }\n    if ($number < 100) {\n        $mini_roman .= 'x';\n        $number\
    \ = $number + 100; // 100 is not a special case\n    }\n    $str = '';\n    while\
    \ ($number > 0) {\n        if ($number % 10 == 1) {\n            $mini_roman .=\
    \ 'i';\n            $number -= 10;\n        } else if ($number % 10 == 2) {\n\
    \            $mini_roman .= 'ii';\n            $number -= 10;\n        } else\
    \ if ($number % 10 == 3) {\n            $mini_roman .= 'iii';\n            $number\
    \ -= 10;\n        } else if ($number % 10 == 4) {\n            $mini_roman .=\
    \ 'iv';\n            $number -= 10;\n        } else if ($number % 10 == 5) {\n\
    \            $mini_roman .= 'v';\n            $number -= 10;\n        } else if\
    \ ($number % 10 == 6) {\n            $mini_roman .= 'vi';\n            $number\
    \ -= 10;\n        } else if ($number % 10 == 7) {\n            $mini_roman .=\
    \ 'vii';\n            $number -= 10;\n        } else if ($number % 10 == 8) {\n\
    \            $mini_roman .= 'viii';\n            $number -= 10;\n        } else\
    \ if ($number % 10 == 9) {\n            $mini_roman .= 'ix';\n            $number\
    \ -= 10;\n        } else if ($number % 10 == 1) {\n            $mini_roman .=\
    \ 'x';\n            $number -= 10;\n        }\n        $str .= $mini_roman;\n\
    \    }\n    return $str;\n}\n", "  if ($number < 1 || $number > 1000) {\n    throw\
    \ new Exception($number, 1);\n  }\n  $roman = '';\n  for ($i = 1; $i <= 9; ++$i)\
    \ {\n    $roman .= roman_numeral($number, $i);\n  }\n  return strtolower($roman);\n\
    }\n\n/**\n * Convert a roman numeral to a positive integer.\n * Restrictions:\n\
    \ *   The input string must be valid.\n *   The input string must be minimal,\
    \ i.e. only contain numeric\n *   characters.\n *   The input string must not\
    \ contain leading zeroes.\n *   The input string must be no longer than one character.\n\
    \ *   The input string must be unique, i.e. no two consecutive characters\n *\
    \   can appear in the same position.\n *   The input string must not have consecutive\
    \ duplicates.\n * An example of a valid input string is: \"MCMXCIV\"\n * An example\
    \ of a valid input string is: \"MMM\"\n * An example of a valid input string is:\
    \ \"III\"\n * An example of a valid input string is: \"CC\"\n * An example of\
    \ a valid input string is: \"VIII\"\n * An example of a valid input string is:\
    \ \"IV\"\n * An example of a valid input string is: \"V\"\n * An example of a\
    \ valid input string is: \"IX\"\n * An example of a valid input string is: \"\
    IV\"\n * An example of a valid input string is: \"IIII\"\n * An example of a valid\
    \ input string is: \"LXXXIV\"\n * An example of a valid input string is: \"LXXXV\"\
    \n * An example of a valid input string is: \"IIII\"\n * An example of a valid\
    \ input string is: \"XIII\"\n * An example of a valid input string is: \"XII\"\
    \n * An example of a valid input string is: \"XXXIII\"\n * An example of a valid\
    \ input string is: \"XXXII\"\n * An example of a valid input string is: \"XXXI\"\
    \n * An example of a valid input string is: \"XXIX\"\n * An example of a valid\
    \ input string is: \"LXXXVII\"\n * An example of a valid input string is: \"LXXXVI\"\
    \n * An example of a valid input string is: \"XXXIX\"\n * An example of a valid\
    \ input string is: \"XXXIV\"\n * An example of a valid input string is: \"VIIII\"\
    \n * An example of a valid input string is: \"VIII\"\n * An example of a valid\
    \ input string is: \"IIII\"\n * An example of a valid input string is: \"III",
  "    $roman_numerals = array('I' => 1, 'V' => 5, 'X' => 10, 'L' => 50, 'C' => 100,\
    \ 'D' => 500, 'M' => 1000);\n    $roman = '';\n    $int = (int)$number;\n    $decimals\
    \ = $int % 1;\n    $int = floor($int);\n    $int_roman = $int % 10;\n    $int_roman\
    \ = str_pad($int_roman, 3, '0', STR_PAD_LEFT);\n    $roman_numeral = $roman_numerals[$int_roman];\n\
    \    if ($decimal != 0) {\n        $roman_numeral = $roman_numeral.$decimals;\n\
    \    }\n    $roman = $roman_numeral;\n    return $roman;\n}", "    if ($number\
    \ < 1 || $number > 1000) {\n        echo \"invalid input\";\n        exit;\n \
    \   }\n\n    $roman = array('M' => 1000, 'CM' => 900, 'D' => 500, 'CD' => 400,\n\
    \                   'C' => 100, 'XC' => 90,  'L' => 50, 'XL' => 40,\n        \
    \           'X' => 10, 'IX' => 9,  'V' => 5,  'IV' => 4,\n                   'I'\
    \ => 1);\n\n    $result = '';\n    $number *= 10;\n\n    for ($i = $number - 1;\
    \ $i >= 0; $i /= 10) {\n        $result += $roman[$i % 10];\n    }\n\n    return\
    \ mb_strtolower($result);\n}\n", "    // TODO: Add some error checking to ensure\
    \ that the number is between 1 and 1000.\n    // Or add some sanity checking to\
    \ ensure that the input is an integer?\n\n    $roman_numerals = array();\n   \
    \ $denominators = array(1000, 500, 100, 50, 10, 5, 1);\n\n    $roman_numerals[1000]\
    \ = \"M\";\n    $roman_numerals[500] = \"D\";\n    $roman_numerals[100] = \"C\"\
    ;\n    $roman_numerals[50] = \"L\";\n    $roman_numerals[10] = \"X\";\n    $roman_numerals[5]\
    \ = \"V\";\n    $roman_numerals[1] = \"I\";\n\n    $remainder = 0;\n    $result\
    \ = '';\n\n    foreach ($denominators as $key => $denominator) {\n        while\
    \ ($remainder >= $denominator) {\n            $remainder = $remainder - $denominator;\n\
    \            $result = $roman_numerals[$remainder] . $result;\n        }\n   \
    \ }\n    return $result;\n}\n</code>\n<|/ a |>\n<| c |>\nThanks, you really saved\
    \ my life!\n<|/ c |>\n<| c |>\nThis is perfect ! Thank you !\n<|/ c |>\n<| a tags=php,numbers,math\
    \ dscore=2 |>\nI thought I would post the solution I came up with, as I believe\
    \ it is more readable than the other solutions posted:\n<code>\n/**\n * Convert\
    \ a number to a numeric string representing the numeral\n * equivalent of the\
    \ number.\n *\n * string $number\n *\n * string\n */", "  // Using an associative\
    \ array instead of an if statement for speed since we\n  // will be using this\
    \ function for lots of numbers.\n  $roman = array(\n    1000,\n    900,\n    500,\n\
    \    400,\n    100,\n    90,\n    50,\n    4,\n    10,\n    9,\n    5,\n    4,\n\
    \    10,\n    9,\n    5,\n    4,\n    10,\n    9,\n    5,\n    4,\n    10,\n \
    \   9,\n    5,\n    4,\n    10,\n    9,\n    5,\n    4,\n    10,\n    9,\n   \
    \ 5,\n    4,\n    10,\n    9,\n    5,\n    4,\n    10,\n    9,\n    5,\n    4,\n\
    \    10,\n    9,\n    5,\n    4,\n    10,\n    9,\n    5,\n    4,\n    10,\n \
    \   9,\n    5,\n    4,\n    10,\n    9,\n    5,\n    4,\n    10,\n    9,\n   \
    \ 5,\n    4,\n    10,\n    9,\n    5,\n    4,\n    10,\n    9,\n    5,\n    4,\n\
    \    10,\n    9,\n    5,\n    4,\n    10,\n    9,\n    5,\n    4,\n    10,\n \
    \   9,\n    5,\n    4,\n    10,\n    9,\n    5,\n    4,\n    10,\n    9,\n   \
    \ 5,\n    4,\n    10,\n    9,\n    5,\n    4,\n    10,\n    9,\n    5,\n    4,\n\
    \    10,\n    9,\n    5,\n    4,\n    10,\n    9,\n    5,\n    4,\n    10,\n \
    \   9,\n    5,\n    4,\n    10,\n    9,\n    5,\n    4,\n    10,\n    9,\n   \
    \ 5,\n    4,\n    10,\n    9,\n    5,\n    4,\n    10,\n    9,\n    5,\n    4,\n\
    \    10,\n    9,\n    5,\n    4,\n    10,\n    9,\n    5,\n    4,\n    10,\n \
    \   9,\n    5,\n    4,\n    10,\n    9,\n    5,\n    4,\n    10,\n    9,\n   \
    \ 5,\n    4,\n    10,\n    9,\n    5,\n    4,\n    10,\n    9,\n    5,\n    4,\n\
    \    10,\n    9,\n    5,\n    4,\n    10,\n    9,\n    5,\n    4,\n    10,", " \
    \   $roman = '';\n    while (true) {\n        $remainder = $number % 10;\n   \
    \     $number = floor($number / 10);\n        if ($number == 0) {\n          \
    \  break;\n        }\n        $roman .= $roman_number[$remainder];\n    }\n  \
    \  return strtolower($roman);\n}\n", "    $number  = intval($number);\n    $result\
    \ = \"\";\n    $letters = \"IVXLCDM\";\n    $upCase  = 1;\n    // Convert int\
    \ to an array of digits\n    for ($i = strlen($number); $i > 0; $i -= 3) {\n \
    \       $digits = substr($number, $i - 3, 3);\n        $result += $letters[array_search($digits,\
    \ $letters)] * $upCase;\n        $upCase *= 2;\n    }\n    return $result;\n}\n",
  "\t$roman = \"\";\n\t$roman_value = $number % 1000;\n\t$roman_digit =\t$number -\
    \ $roman_value;\n\twhile($roman_digit >= 1000) {\n\t\t$roman .= \"m\";\n\t\t$roman_digit\
    \ -= 1000;\n\t}\n\twhile($roman_digit >= 100) {\n\t\t$roman .= \"cm\";\n\t\t$roman_digit\
    \ -= 100;\n\t}\n\twhile($roman_digit >= 10) {\n\t\t$roman .= \"dl\";\n\t\t$roman_digit\
    \ -= 10;\n\t}\n\twhile($roman_digit >= 1) {\n\t\t$roman .= \"cd\";\n\t\t$roman_digit\
    \ -= 1;\n\t}\n\treturn $roman;\n}\n", "  // Convert integers to strings for the\
    \ easy arithmetic.\n  $romanString = (string) $number;\n\n  // Create a lookup\
    \ array that translates the roman-string to the digit-string.\n  $romanToDigit\
    \ = array('M' => 0, 'CM' => 1, 'D' => 2, 'CD' => 3, 'C' => 4,\n    'XC' => 5,\
    \ 'L' => 6, 'XL' => 7, 'X' => 8, 'IX' => 9, 'V' => 10, 'IV' => 11,\n    'I' =>\
    \ 12, 'IU' => 13, 'UU' => 14, 'UUU' => 15);\n  $digits = array_keys($romanToDigit);\n\
    \n  // Create a lookup array that translates the digit-string to the ordinal.\n\
    \  $digitToOrdinal = array('I' => 1, 'V' => 2, 'X' => 3, 'L' => 4, 'C' => 5,\n\
    \    'D' => 6, 'M' => 7, 'IU' => 8, 'UU' => 9, 'UUU' => 10, 'IV' => 11,\n    'M'\
    \ => 12, 'CM' => 13, 'CD' => 14, 'C' => 15, 'XC' => 16, 'XL' => 17,\n    'X' =>\
    \ 18);\n  $ordinals = array_values($digitToOrdinal);\n\n  // Translate the roman-string\
    \ to the digit-string in the appropriate place.\n  for ($i = 0; $i < strlen($romanString);\
    \ $i++) {\n    $digit = $romanToDigit[$romanString[$i]];\n    $ordinal = $ordinals[$digit];\n\
    \    $romanString = str_replace($romanString[$i], $digits[$digit], $romanString);\n\
    \  }\n\n  // Convert the digit-string back to a roman numeral.\n  return str_ireplace($digits,\
    \ $ordinals, $romanString);\n}\n", "    $return = '';\n    if ($number < 1 ||\
    \ $number > 1000) {\n        return $return;\n    }\n\n    $numStr = sprintf('%05d',\
    \ $number);\n    $numLen = strlen($numStr);\n    $numerals = array('',\n     \
    \   'M',\n        'MM',\n        'MMM',\n        'MMMM');\n    foreach ($numerals\
    \ as $numeral) {\n        if ($numLen > strlen($numeral)) {\n            $return.=\
    \ $numeral;\n        } else {\n            $return.= str_replace($numStr, $numeral,\
    \ $numStr);\n        }\n    }\n\n    return mb_strtolower($return);\n}\n", " \
    \   if ($number < 1 || $number > 999) {\n        throw new \\InvalidArgumentException('Invalid\
    \ argument to int_to_mini_roman()');\n    }\n\n    $roman = '';\n    for ($i =\
    \ 1; $i < $number; $i++) {\n        $roman = strtoupper(\n            $roman.\n\
    \            roman_from_nibble($i).\n            roman_to_letter()\n        );\n\
    \    }\n    return $roman;\n}\n", "    $number = intval($number);\n    $roman\
    \ = '';\n    do {\n        $remainder = $number % 1000;\n        $number -= $remainder;\n\
    \        $roman .= self::int_to_roman($remainder);\n    } while ($number >= 1000);\n\
    \n    return $roman;\n}\n", "  if($number < 1)\n    return null;\n  else if($number\
    \ < 10)\n    return chr($number);\n  else if($number < 100)\n    return chr($number\
    \ - 10) + int_to_mini_roman($number % 10);\n  else if($number < 1000)\n    return\
    \ chr($number / 10) + int_to_mini_roman($number % 10) + int_to_mini_roman($number\
    \ % 100);\n  else\n    return null;\n}", "  if ($number <= 0) return '';\n\n \
    \ $str = '';\n\n  for ($i = 1; $i <= $number / 1000; ++$i) {\n    $str .= mini_roman($i).'vi';\n\
    \  }\n  return substr($str, 0, -1);\n}\n", "\t$roman = \"\";\n\n\tfor ($i = 0;\
    \ $i < strlen($number); $i++) {\n\t\t$roman .= $number[$i];\n\n\t\t$numeral =\
    \ $number[$i];\n\t\t$numeral_value = 0;\n\t\t$numeral_base = 0;\n\n\t\twhile ($numeral\
    \ > 0) {\n\t\t\t$numeral_value = ($numeral_value * 10) + $numeral;\n\t\t\t$numeral_base++;\n\
    \t\t\t$numeral -= $numeral * $numeral_base;\n\t\t}\n\n\t\tif ($numeral_base >\
    \ 1) {\n\t\t\t$numeral_value = ($numeral_value * 10) + $numeral_base;\n\t\t}\n\
    \n\t\tif ($numeral_base == 1) {\n\t\t\t$numeral_value = ($numeral_value * 10)\
    \ + $numeral_base;\n\t\t}\n\n\t\t$roman .= roman_digit_to_letter_ext($numeral_value);\n\
    \t}\n\n\treturn strtolower($roman);\n}\n", "  $roman_numerals = array('',\n  \
    \                        '',\n                          'iix',\n             \
    \             'v',\n                          'vi',\n                        \
    \  'vii',\n                          'ix',\n                          'l');\n\
    \  if ($number < 0 || $number > 1000) {\n    return '?';\n  }\n  $str = '';\n\
    \  do {\n    $remainder = $number % 10;\n    $str = $roman_numerals[$remainder]\
    \ . $str;\n    $number = floor($number / 10);\n  } while ($number > 0);\n  return\
    \ strtolower($str);\n}\n", "    $roman = '';\n\n    while (true) {\n        $remainder\
    \ = $number % 52;\n        if ($remainder == 0) {\n            break;\n      \
    \  }\n        ++$number;\n        if ($number > 1000) {\n            $number -=\
    \ 100;\n            $roman .= 'v';\n        }\n        if ($number > 500) {\n\
    \            $number -= 500;\n            $roman .= 'l';\n        }\n        if\
    \ ($number > 100) {\n            $number -= 100;\n            $roman .= 'x';\n\
    \        }\n        if ($number > 50) {\n            $number -= 50;\n        \
    \    $roman .= 'c';\n        }\n        if ($number > 10) {\n            $number\
    \ -= 10;\n            $roman .= 'd';\n        }\n        if ($number > 5) {\n\
    \            $number -= 5;\n            $roman .= 'm';\n        }\n        if\
    \ ($number > 1) {\n            $roman .= 's';\n        }\n        $roman .= $remainder;\n\
    \    }\n\n    return strtolower($roman);\n}\n", "    $roman = '';\n    while ($number\
    \ >= 1000) {\n        $roman .= 'M';\n        $number -= 1000;\n    }\n    while\
    \ ($number >= 500) {\n        $roman .= 'D';\n        $number -= 500;\n    }\n\
    \    while ($number >= 100) {\n        $roman .= 'C';\n        $number -= 100;\n\
    \    }\n    while ($number >= 50) {\n        $roman .= 'L';\n        $number -=\
    \ 50;\n    }\n    while ($number >= 10) {\n        $roman .= 'X';\n        $number\
    \ -= 10;\n    }\n    while ($number >= 5) {\n        $roman .= 'V';\n        $number\
    \ -= 5;\n    }\n    while ($number >= 1) {\n        $roman .= 'I';\n        $number\
    \ -= 1;\n    }\n    return $roman;\n}", "  $roman = array();\n  // Iterate through\
    \ all numbers 0 through thousands, inclusive.\n  for ($i = 0; $i < 100; $i++)\
    \ {\n    // Determine if $number modulo 1000 is equal to zero.\n    if ($number\
    \ % 1000 == 0) {\n      // If so, add a new entry to the array containing the\
    \ roman number\n      // corresponding to the hundreds place of the number and\
    \ the tens place.\n      $roman[] = str_pad($number, 100, '0', STR_PAD_LEFT);\n\
    \      // Divide $number by 1000 so that the hundreds place remains unchanged.\n\
    \      $number = floor($number / 1000);\n    } else {\n      // Otherwise, divide\
    \ the hundreds place by 10.\n      $number = floor($number / 10);\n    }\n  }\n\
    \n  // Iterate through the array from largest to smallest, to determine the correct\n\
    \  // numeral for each number.\n  foreach ($roman as $key => $value) {\n    $roman[$key]\
    \ = array_reverse(str_split($value, 2));\n    $roman[$key] = array_merge($roman[$key],\
    \ array_reverse($roman[$key][0]));\n  }\n\n  return $roman;\n}\n", "  $result\
    \ = \"\";\n  if ($number < 1 || $number > 1000) {\n    return false;\n  }\n  for\
    \ ($i = 1; $i < $number; $i++) {\n    $result = $result . \"x\";\n  }\n  return\
    \ strtolower($result);\n}\n", "    $roman = '';\n    $int_num = (int)$number;\n\
    \    $len = strlen(\"$int_num\");\n\n    if ($int_num >= 1000) {\n        $roman\
    \ = int_to_mini_roman($int_num / 1000);\n        $int_num = $int_num % 1000;\n\
    \    }\n\n    if ($int_num > 0) {\n        if ($len <= 3) {\n            $roman\
    \ = str_pad($roman, 3, '0', STR_PAD_LEFT);\n        }\n        $roman = str_pad($roman,\
    \ 3, '0', STR_PAD_BOTH);\n        $roman .= $int_num % 10;\n    }\n\n    return\
    \ $roman;\n}\n", "  static $romans = array(\n    100   => 'M',\n    500   => 'D',\n\
    \    1000  => 'CM',\n    5000  => 'CD',\n    10000 => 'CCL',\n    50000 => 'CCDL',\n\
    \    100000 => 'CMCL',\n    500000 => 'CDA',\n    1000000 => 'CLD',\n    2500000\
    \ => 'CCLD',\n    100000000 => 'XC',\n    2500000000 => 'XL',\n    1000000000000\
    \ => 'XD',\n    1000000000000000 => 'XCD'\n  );\n  return $romans[$number];\n\
    }\n", "  return \"ilv\"[($number/100)%10]\n         .int_to_mini_roman($number/10)\n\
    \         .($number%10);\n}", "  $roman = $number; // default\n  // If num is\
    \ negative, give the lowercase roman numeral for the minus number\n  if ($number\
    \ < 0) {\n    $roman = str_repeat('M', $number + 1);\n    $roman = str_replace('M',\
    \ 'm', $roman);\n  } else {\n    $roman = str_repeat('M', abs($number - 1));\n\
    \    $roman = str_replace('M', 'm', $roman);\n  }\n  return $roman;\n}\n", " \
    \ if ($number < 1) {\n    return false;\n  }\n\n  // Initialize the string with\
    \ leading zeros, if necessary.\n  $num_string = str_pad($number, 3, '0', STR_PAD_LEFT);\n\
    \n  // Initialize $numeral with leading zeros, if necessary.\n  $numeral = str_pad('',\
    \ $number, '0');\n\n  // Convert the number to the required base.\n  $num_digits\
    \ = strlen($num_string);\n  for ($i = $num_digits; $i > 0; $i--) {\n    $numeral[$num_digits-$i]\
    \ = $num_string[$i];\n  }\n\n  return $numeral;\n}\n", "  $roman = '';\n  $num\
    \ = $number;\n\n  while ($num >= 1000) {\n    $roman .= 'M';\n    $num -= 1000;\n\
    \  }\n  $num = $num;\n\n  while ($num >= 100) {\n    $roman .= 'C';\n    $num\
    \ -= 100;\n  }\n  $num = $num;\n\n  while ($num >= 10) {\n    $roman .= 'D';\n\
    \    $num -= 10;\n  }\n  $num = $num;\n\n  while ($num >= 1) {\n    $roman .=\
    \ 'C';\n    $num -= 1;\n  }\n  if ($num != 0) {\n    $roman .= 'I';\n  }\n  return\
    \ $roman;\n}\n", "    // Convert to decimal and divide by 100\n    $number = (int)\
    \ ($number * 100);\n    // Initialize the result to an empty string\n    $result\
    \ = '';\n    // If the number gets too big, return only the lowest term\n    if\
    \ ($number > 1000) {\n        return $result;\n    }\n    // Loop through the\
    \ number dividing it by each of its corresponding values\n    // and adding it\
    \ to the result\n    for ($i = 1; $i <= $number; $i += 100) {\n        $result\
    \ = roman($i).$result;\n    }\n    // Return the result in lowercase\n    return\
    \ mb_strtolower($result);\n}\n", "  $roman = '';\n  do {\n    if ($number >= 1000)\
    \ {\n      $roman .= 'M';\n      $number -= 1000;\n    }\n    if ($number >= 900)\
    \ {\n      $roman .= 'CM';\n      $number -= 900;\n    }\n    if ($number >= 500)\
    \ {\n      $roman .= 'D';\n      $number -= 500;\n    }\n    if ($number >= 400)\
    \ {\n      $roman .= 'CD';\n      $number -= 400;\n    }\n    if ($number >= 100)\
    \ {\n      $roman .= 'C';\n      $number -= 100;\n    }\n    if ($number >= 90)\
    \ {\n      $roman .= 'XC';\n      $number -= 90;\n    }\n    if ($number >= 50)\
    \ {\n      $roman .= 'L';\n      $number -= 50;\n    }\n    if ($number >= 40)\
    \ {\n      $roman .= 'XL';\n      $number -= 40;\n    }\n    if ($number >= 10)\
    \ {\n      $roman .= 'X';\n      $number -= 10;\n    }\n    if ($number >= 9)\
    \ {\n      $roman .= 'IX';\n      $number -= 9;\n    }\n    if ($number >= 5)\
    \ {\n      $roman .= 'V';\n      $number -= 5;\n    }\n    if ($number >= 4) {\n\
    \      $roman .= 'IV';\n      $number -= 4;\n    }\n    if ($number >= 1) {\n\
    \      $roman .= 'I';\n      $number -= 1;\n    }\n  } while ($number > 0);\n\
    \  return strtolower($roman);\n}\n", "  global $minroman, $minlen;\n\n  if (!preg_match('/^\\\
    d+$/', $number)) {\n    return false;\n  }\n\n  $roman = '';\n  $len = 0;\n\n\
    \  // Convert the number into an array of digits\n  for ($i = 0; $i < strlen($number);\
    \ ++$i) {\n    $roman .= $number[$i];\n  }\n\n  // Determine minimum length of\
    \ roman equivalent\n  for ($i = 0; $i < strlen($roman); ++$i) {\n    $minroman[$i]\
    \ = strlen($roman[$i]);\n  }\n\n  // Fill in blanks\n  for ($i = 0; $i < strlen($roman);\
    \ ++$i) {\n    if ($i < strlen($roman) - 1) {\n      if ($minroman[$i] < $minroman[$i\
    \ + 1]) {\n        $minroman[$i] = $minroman[$i + 1];\n      }\n    }\n  }\n\n\
    \  // Determine maximum length of roman equivalent\n  $maxlen = 0;\n  for ($i\
    \ = 0; $i < strlen($roman); ++$i) {\n    if ($minroman[$i] > $maxlen) {\n    \
    \  $maxlen = $minroman[$i];\n    }\n  }\n\n  // Determine minimum length of resulting\
    \ string\n  $minlen = 0;\n  for ($i = 0; $i < strlen($roman); ++$i) {\n    if\
    \ ($minroman[$i] < $minlen) {\n      $minlen = $minroman[$i];\n    }\n  }\n\n\
    \  // Construct resulting string\n  do {\n    $len--;\n    $roman .= array_shift($minroman);\n\
    \  } while ($len > 0);\n\n  return strtolower($roman);\n}", "  $roman = array(\"\
    \", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\");\n\
    \  // Make sure num is positive.\n  $number = abs($number);\n  // Find the closest\
    \ larger power of 10.\n  $exp = floor(log10($number) / log10(2));\n  $number /=\
    \ pow(10, $exp);\n  // Do some special cases to cope with negative numbers.\n\
    \  if ($number < 0) {\n    // Negative numbers can't easily be converted to roman\
    \ numerals.\n    // Convert to positive numbers and try again.\n    $number =\
    \ -$number;\n    $exp = floor(log10($number) / log10(2));\n    $number /= pow(10,\
    \ $exp);\n  }\n  while ($number > 10) {\n    $roman []= \"m\";\n    $number /=\
    \ 10;\n  }\n  $roman []= $roman[$exp];\n  while ($number > 0) {\n    $roman []=\
    \ $roman[(int)log($number, 10)];\n    $number /= 10;\n  }\n  return implode(\"\
    \", $roman);\n}\n\n/**\n * Given a string, return a string of all characters in\
    \ the string,\n * capitalized.\n * If multiple capitalization styles are possible\
    \ (either upper or lower),\n * pick lower case as the capitalization style.\n\
    \ * Examples:\n * >>> cap_first_letter(\"\")\n * \"\"\n * >>> cap_first_letter(\"\
    MARY\")\n * \"mary\"\n * >>> cap_first_letter(\"MARy\")\n * \"Mary\"\n * >>> cap_first_letter(\"\
    MARY\")\n * \"Mary\"\n * >>> cap_first_letter(\"   MARY \")\n * \"Mary\"\n * @param\
    \ $str The string to be capitalized.\n */", "  $roman = '';\n  while ($number\
    \ > 0) {\n    $roman .= roman_to_int('vi', $number % 10);\n    $number /= 10;\n\
    \  }\n  return strtolower($roman);\n}\n", "  $roman = array('',\n    'M',\n  \
    \  'CM',\n    'D',\n    'CD',\n    'C', 'XC', // ?\n    'L',\n    'XL',\n    'X',\n\
    \    'IX',\n    'V',\n    'IV',\n    'I');\n  return $roman[$number];\n}\n", " \
    \ // Fail if num is too large.\n  if ($number > 1000) {\n    return '';\n  }\n\
    \n  // Fail if num is negative.\n  if ($number < 0) {\n    return '';\n  }\n\n\
    \  // Initialize numStr and totalStr to empty strings.\n  $numStr = '';\n  $totalStr\
    \ = '';\n\n  // Initialize a variable to be the number converted to roman.\n \
    \ $var = $number;\n\n  // Convert num to the hundreds place using integer division.\n\
    \  // Divide num by 100 until num is no longer divisible by 100.\n  while (floor($var\
    \ / 100) != $var) {\n    $numStr .= 'C';\n    $var %= 100;\n  }\n\n  // Convert\
    \ num to the tens place using integer division.\n  // Divide num by 10 until num\
    \ is no longer divisible by 10.\n  while (floor($var / 10) != $var) {\n    $numStr\
    \ .= 'L';\n    $var %= 10;\n  }\n\n  // Add numStr and var to the totalStr.\n\
    \  $totalStr .= $numStr;\n  $totalStr .= $var;\n\n  // Convert totalStr to lower\
    \ case.\n  $totalStr = strtolower($totalStr);\n\n  // Return the total roman.\n\
    \  return $totalStr;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nHere's\
    \ a solution without using arrays. I find it hard to understand why the solution\
    \ doesn't use arrays though. Could someone explain?\n<code>", "    if ($number\
    \ < 1 || $number > 1000) {\n        return FALSE;\n    }\n\n    $roman = '';\n\
    \    while ($number > 0) {\n        $roman .= $number%10;\n        $number /=\
    \ 10;\n    }\n    return $roman;\n}", "  static $roman_numerals = array(\n   \
    \ 100   => 'M',\n    1000  => 'CM',\n    10000 => 'D',\n    100000 => 'CD',\n\
    \    1000000 => 'CCL',\n    10000000 => 'XC',\n    100000000 => 'XL',\n    1000000000\
    \ => 'L',\n    10000000000 => 'XD',\n    100000000000 => 'IX',\n    1000000000000\
    \ => 'V',\n    10000000000000 => 'IV',\n    100000000000000 => 'I',\n    1000000000000000000\
    \ => 'X',\n    10000000000000000000 => 'IV'\n  );\n\n  $roman = '';\n  $negative\
    \ = ($number < 0);\n  if ($negative) {\n    $number = abs($number);\n  }\n\n \
    \ // Get dividend / 1000\n  $number = floor($number / 1000);\n  $dividend = 1000;\n\
    \n  // Iterate through all numbers, from dividend to 99999\n  foreach (range($dividend,\
    \ $number - 1) as $number) {\n    $count = $roman_numerals[$number];\n    $roman\
    \ .= $count;\n  }\n\n  // If there is a remainder, add it to the roman.\n  $rem_count\
    \ = $roman_numerals[$number];\n  if ($number > 0 && $number < $dividend && $number\
    \ >= $rem_count) {\n    $roman .= $rem_count;\n  }\n\n  // Return string in lowercase\n\
    \  return strtolower($roman);\n}\n\n/**\n * Given a mini roman numeral, return\
    \ its corresponding positive integer.\n * Restrictions: Only strings containing\
    \ only letters and/or numbers are allowed.\n * Examples:\n * >>> mini_roman_to_int(`c`)\n\
    \ * `100`\n * >>> mini_roman_to_int(`c` + `i`)\n * `101`\n * >>> mini_roman_to_int(`c`\
    \ + `i` + `x`)\n * `102`\n * >>> mini_roman_to_int(`c` + `i` + `x` + `l`)\n *\
    \ `103`\n * >>> mini_roman_to_int(`c` + `i` + `x` + `l` + `o`)\n * `104`\n * >>>\
    \ mini_roman_to_int(`c` + `i` + `x` + `l` + `o` + `d`)\n * `105`\n * >>> mini_roman_to_int(`c`\
    \ + `i` + `x` + `l` + `o", "  $roman = \"\";\n  // Only use every third position\n\
    \  for($i = 0; $i < strlen($number); $i++) {\n    $count = $number[$i];\n    $roman\
    \ = $roman + ($count == 1 ? $romans[$i] : ($romans[$i] . $romans[$i+1]));\n  \
    \  $roman = ($romans[$i+1] != $romans[$i]) ? $romans[$i] . $roman : $romans[$i];\n\
    \  }\n  return $roman;\n}\n", "  $roman = '';\n\n  while ($number > 0) {\n   \
    \ $remainder = $number % 10;\n    $roman = ($roman) ? $roman . strtoupper(substr($roman,\
    \ 0, -1))\n      : strtoupper(substr($roman, 0, -1));\n    $number = floor($number\
    \ / 10);\n  }\n\n  return $roman . strtolower(substr($roman, -1));\n}\n", "  \
    \  $roman = '';\n\n    if ($number < 0 || $number > 1000) {\n        return false;\n\
    \    }\n\n    $base = [\n        1000,\n        900,\n        500,\n        400,\n\
    \        100,\n        90,\n        50,\n        40,\n        10,\n        9,\n\
    \        5,\n        4,\n        1,\n        0.1,\n        0.01,\n        0.001,\n\
    \        0.009,\n        0.005,\n        0.05,\n        0.04,\n        0.03,\n\
    \        0.02,\n        0.01,\n        0.001,\n        0.009,\n        0.005,\n\
    \        0.05,\n        0.04,\n        0.03,\n        0.02,\n        0.01,\n \
    \       0.001,\n        0.009,\n        0.005,\n        0.05,\n        0.04,\n\
    \        0.03,\n        0.02,\n        0.01,\n    ];\n\n    $denominator = array_reduce($base,\
    \ 'array_sum');\n\n    while (true) {\n        $num = $number % $denominator;\n\
    \        if ($num == 0 || $num > $denominator) {\n            break;\n       \
    \ }\n\n        $roman .= $num;\n        $number -= $num;\n    }\n\n    return\
    \ $roman;\n}\n", "  if ($number < 1 || $number > 1000) {\n    throw new Exception('Invalid\
    \ argument');\n  }\n\n  if ($number == 1000 || $number == 1000000) {\n    return\
    \ $number == 1000000 ? $number : $number . \" crore \" . \"(cdxxvi)\";\n  }\n\n\
    \  $roman = \"\";\n  $roman = str_ireplace([1,2,5,6,8,10,11,12,16,20,22,23,24,32,35,36,37,38,39,40,44],\n\
    \                       [1,2,5,6,8,10,11,12,16,20,22,23,24,32,33,34,35,36,37,38,39,40,41,42],\n\
    \                       $roman);\n  $roman = str_ireplace([3,4,7,9,12,14,15,17,21,24,35,36,37,38,39,44],\n\
    \                       [3,4,5,6,8,10,11,12,16,20,22,23,24,33,34,35,36,37,38,39,40],\n\
    \                       $roman);\n  $roman = str_ireplace([5,10,15,20,25,30,40,45],\n\
    \                       [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44],\n\
    \                       $roman);\n  $roman = str_ireplace([1,5,9,14,21,27,32,40,49],\n\
    \                       [1,2,3,5,8,10,11,13,14,16,17,19,20,22,23,25,26,28,29,30,31,33,34,36,37,39,40,42,44],\n\
    \                       $roman);\n  $roman = str_ireplace([4,9,14,23,30,36,43,51],\n\
    \                       [4,5,6,8,10,11,12,14,15,17,18,20,22,23,25,27,30,31,32,34,36,37,40,42,44],\n\
    \                       $roman);\n  $roman = str_ireplace([7,14,21,28,35,42,49],\n\
    \                       [7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40],\n\
    \                       $roman);\n  $roman = str_ireplace([2,4,6,10,16,24,35,40],\n\
    \                       [2,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45],\n\
    \                       $roman);\n  $roman = str_ireplace([9,14,23,30,36,43,51],\n\
    \                       ["]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
