name: HumanEval_33_sort_third
language: php
prompt: "<?php\n// This function takes an array l and returns an array l' such that\n\
  // l' is identical to l in the indicies that are not divisible by three, while its\
  \ values at the indicies that are divisible by three are equal\n// to the values\
  \ of the corresponding indicies of l, but sorted.\n// >>> sort_third(array(1, 2,\
  \ 3))\n// array(1, 2, 3)\n// >>> sort_third(array(5, 6, 3, 4, 8, 9, 2))\n// array(2,\
  \ 6, 3, 4, 8, 9, 5)\nfunction sort_third($l) {\n"
tests: "function candidate(...$args) {\n    return sort_third(...$args);\n}\n\nfunction\
  \ test(): void {\n    if (candidate(array(5, 6, 3, 4, 8, 9, 2)) !== array(2, 6,\
  \ 3, 4, 8, 9, 5)) { throw new Exception(\"Test failed!\"); }\n    if (candidate(array(5,\
  \ 8, 3, 4, 6, 9, 2)) !== array(2, 8, 3, 4, 6, 9, 5)) { throw new Exception(\"Test\
  \ failed!\"); }\n    if (candidate(array(5, 6, 9, 4, 8, 3, 2)) !== array(2, 6, 9,\
  \ 4, 8, 3, 5)) { throw new Exception(\"Test failed!\"); }\n    if (candidate(array(5,\
  \ 6, 3, 4, 8, 9, 2, 1)) !== array(2, 6, 3, 4, 8, 9, 5, 1)) { throw new Exception(\"\
  Test failed!\"); }\n}\n\ntest();"
completions: ["    $third = array();\n    for ($i = 0, $n = count($l); $i < $n; $i++)\n\
    \    {\n        if ($i % 3 == 0)\n        {\n            $third[] = $l[$i];\n\
    \        }\n        else\n        {\n            $third[] = $l[$i];\n        }\n\
    \    }\n    return $third;\n}\n", "  sort($l, SORT_NUMERIC);\n  for ($i = sizeof($l)\
    \ - 2; $i >= 0; $i--) if ($l[$i] % 3 == 0) array_splice($l, $i, 2);\n  return\
    \ $l;\n}\n", "\tfor($i = 0; $i < count($l); $i++) {\n\t\tif($i % 3 == 0) {\n\t\
    \t\t$l[$i] = $l[$i];\n\t\t}\n\t\telse if($i % 3 != 0) {\n\t\t\t$k = $i;\n\t\t\t\
    while($k != 0 && $k % 3 != 0) {\n\t\t\t\t$l[$k] = $l[$k - 1];\n\t\t\t\t$k--;\n\
    \t\t\t}\n\t\t\t$l[$k] = $l[$i];\n\t\t}\n\t}\n\treturn $l;\n}\n", "    $len = count($l);\n\
    \    $outarr = array();\n    for ($i = 0; $i < $len; $i++) {\n        if ($i %\
    \ 3 === 0) {\n            $outarr[] = $l[$i];\n        }\n    }\n    sort($outarr);\n\
    \    return $outarr;\n}\n", "\t$l2 = [];\n\tfor ($i = 0; $i < count($l); $i+=3)\
    \ {\n\t\tif ($i+2 < count($l)) {\n\t\t\t$l2[$i] = $l[$i];\n\t\t\t$l2[$i+1] = $l[$i+1];\n\
    \t\t\t$l2[$i+2] = $l[$i+2];\n\t\t} else {\n\t\t\t$l2[$i] = $l[$i];\n\t\t\t$l2[$i+1]\
    \ = $l[$i+1];\n\t\t\t$l2[$i+2] = $l[$i+1];\n\t\t}\n\t}\n\treturn $l2;\n}", " \
    \ $len = count($l);\n  for ($i = 0; $i < $len; $i++) {\n    $count = 0;\n    $j\
    \ = $i + 1;\n    while ($j < $len && $l[$i] === $l[$j]) {\n      $count++;\n \
    \     $j++;\n    }\n    if ($count % 3 === 0) {\n      unset($l[$i]);\n    }\n\
    \    else {\n      $l[$i] = $l[$j];\n    }\n  }\n  return $l;\n}\n", "    sort($l);\n\
    \    $l = [];\n    foreach ($l as $key => $value) {\n        if ($key % 3 == 0)\
    \ {\n            $l[$key] = $value;\n        }\n    }\n    return $l;\n}", "\t\
    foreach ($l as $key => $value) {\n\t\tif ($value % 3 == 0) {\n\t\t\t$l[$key] =\
    \ $value;\n\t\t\tunset($l[$key - 1]);\n\t\t}\n\t}\n\tusort($l, \"cmp\");\n\treturn\
    \ $l;\n}", "    $l = array_merge($l);\n    $l = array_reverse($l);\n    $l = array_chunk($l);\n\
    \    foreach ($l as $k=>$v) {\n        $l[$k] = $v[2] ? $v[0] => $v[1] : $v[1];\
    \ // move element with key 2 to position 0\n        unset($l[$k][2]);\n    }\n\
    \    return $l;\n}\n</code>\n<|/ a |>\n<| c |>\nThis is a great answer. I'm just\
    \ wondering if it would be possible to have it so it'd work for arrays bigger\
    \ than three elements? I know there's a `array_chunk()` function, but that doesn't\
    \ seem to be enough.\n<|/ c |>\n<| c |>\nWell, I can't think of a way to do it\
    \ without having to resort to recursion. I'll have a think about it and see if\
    \ I can come up with a way to do it.\n<|/ c |>\n<| c |>\nOkay, I'll get to work\
    \ on it when I get to my PC and post an update.\n<|/ c |>\n<| c |>\nI added an\
    \ answer to my question that has a `sort_third` function which may be more appropriate\
    \ for your needs.\n<|/ c |>\n<| a |>\nYou can sort an array using multiple criteria.\n\
    I believe what you want is something like this:\n<code>\n$input = array(1, 2,\
    \ 3, 4, 5, 4, 3, 2, 1);\n$result = array();\n$key = null;\n$temp = null;\nforeach($input\
    \ as $i => $value)\n{\n    if ($key != null)\n    {\n        if ($key == $i %\
    \ 3)\n        {\n            $temp[$i] = $value;\n        }\n        else\n  \
    \      {\n            $result[$key] = $temp;\n            $key = null;\n     \
    \       $temp = array();\n        }\n    }\n    else\n    {\n        $key = $i\
    \ % 3;\n        $temp[$i] = $value;\n    }\n}\n$result[$key] = $temp;\n</code>\n\
    <|/ a dscore=2 tags=php,arrays,sorting |>\n<| a dscore=2 |>\nYou can use the array_multisort\
    \ function, as stated here\nAnd here's an example, taken straight from there:\n\
    <code>\n<?php\n$data = array();\n$data[] = array(1, 4, 3);\n$data[] = array(2,\
    \ 4, 5);\n$data[] = array(3, 5, 6);\n$data[] = array(7, 4, 1);\n\n$data[] = array(0,\
    \ 2, 4);\n$data[] = array(3, 6, 7);\n$data[] = array(5, 2, 9);\n$data[] = array(4,\
    \ 8, 0);\n\n$sort = array();\n$sort[0] = 'name';", "  if (count($l) == 0)\n  \
    \  return $l;\n\n  $first_three = array_slice($l, 0, 3);\n  $second_three = array_slice($l,\
    \ 3, 3);\n\n  for ($i = 0; $i < count($first_three); $i++) {\n    $first_three[$i]\
    \ = $first_three[$i] - ($i & 1) ? $first_three[$i] % 3 : 0;\n  }\n\n  for ($i\
    \ = 0; $i < count($second_three); $i++) {\n    $second_three[$i] = $second_three[$i]\
    \ - ($i & 1) ? $second_three[$i] % 3 : 0;\n  }\n\n  return array_merge($first_three,\
    \ $second_three);\n}\n", "    $llength = count($l);\n    $third = $llength % 3;\n\
    \    for($i=0; $i < $third; $i++) {\n        $j = $i+1;\n        $l[$i] = $l[$j];\n\
    \    }\n    $third = $llength % 3;\n    for($i=$third; $i < $llength; $i++) {\n\
    \        $j = $i+1;\n        $l[$i] = $l[$j];\n    }\n    $third = $llength %\
    \ 3;\n    for($i=$third; $i < $llength; $i++) {\n        $j = $i+1;\n        $l[$i]\
    \ = $l[$j];\n    }\n    return $l;\n}\n", "  // Sort the indexes in the array\
    \ by value\n  $l = array_intersect_key($l, array_flip($l));\n\n  // Put the indexes\
    \ in the array that are divisible by three in their correct position\n  array_walk($l,\
    \ create_function('&$v', '$v = ($v%3 == 0) ? 0 : $v;'));\n\n  return $l;\n}\n",
  "  sort($l);\n  reset($l);\n  $l2 = array();\n  foreach ($l as $k => $v) {\n   \
    \ if ($v % 3 == 0) {\n      $l2[] = $v;\n    } else {\n      $l2[] = $k;\n   \
    \ }\n  }\n  return $l2;\n}\n", "    foreach ($l as $key => $value) {\n       \
    \ $new[$key] = 3 * $key + 1;\n        if ($new[$key] % 3 == 1) {\n           \
    \ $new[$key]++;\n        }\n    }\n    $new2 = array();\n    foreach ($new as\
    \ $key => $value) {\n        $new2[$value] = $key;\n    }\n    return $new2;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nYou can use array_search() to\
    \ find the third element. \n<code>\n$keys = array(1,2,3,4,5,6,7,8,9,10);\n$result\
    \ = array_search(3, $keys, true);\nprint_r($result);\n</code>\n<|/ a tags=php,arrays\
    \ |>\n<| a tags=php,arrays |>\n<code>\n$arr=array('1','2','3','4','5','6','7','8','9','10');\n\
    $key=0;\nfor($i=0;$i<count($arr);$i++){\n    if($arr[$i]==$arr[$i]){\n       \
    \ $key=$i+1;\n    }\n}\necho $key;\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ tags=php,arrays |>\nyou can also try \n<code>\n$arr=array('1','2','3','4','5','6','7','8','9','10');\n\
    \n$key = array_search(3, $arr);\necho $key;\n</code>\n<|/ a |>\n<| a tags=php,arrays\
    \ |>\n<code>\n<?php\n$arr = array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n$n = count($arr);\n\
    $third = $n - 1;\n$third = $third+2;\nfor ($i = 0; $i < $third; $i++) {\n    $arr[$i]\
    \ = $arr[$i];\n}", "\t$l = array_map( 'intval', $l);\n\t\n\t// Find the index\
    \ of the value that needs to be moved\n\t$move = array_search( $l[3], $l);\n\t\
    // If the value is not found (or is found, but is at the end), set it to the end\n\
    \tif ( $move === false || $move === count($l) - 1 ) {\n\t\t$move = count($l) -\
    \ 1;\n\t}\n\t\n\t// Swap the two values at the positions we want to move\n\tarray_splice(\
    \ $l, $move, 2, $l[$move - 1], $l[$move]);\n\t\n\t// Sort the other values that\
    \ are divisible by three\n\tarray_multisort($l, SORT_DESC);\n\t\n\t// Return the\
    \ original array with the value at the position of move swapped\n\treturn $l;\n\
    }", "    $l1 = array_filter($l, function ($e) { return ($e % 3) == 0; });\n  \
    \  $l2 = array_filter($l, function ($e) { return ($e % 3) == 1; });\n    $l3 =\
    \ array_filter($l, function ($e) { return ($e % 3) == 2; });\n    $l4 = array_merge($l1,\
    \ $l2);\n    $l5 = array_merge($l3, $l4);\n    return $l5;\n}\n</code>\n<|/ a\
    \ |>\n<| c |>\nAh, I see. Thanks for the explanation!\n<|/ c |>\n<| c |>\nThis\
    \ answer is awesome but is really unreadable due to the lack of `{}` formatting\
    \ and the need to manually add indentation. Can you help me improve on it?\n<|/\
    \ c |>\n<| a |>\nThe most efficient way for me to do it was:\n<code>\n$array1\
    \ = array(1, 2, 3, 4, 5);\n$array2 = array(1, 2, 3, 4, 5);\n$array3 = array(1,\
    \ 2, 3, 4, 5);\n\n$array4= array();\n", "    $result=array();\n    $keys=array();\n\
    \    foreach ($l as $k => $v) {\n        if ($k%3===0) {\n            $result[$k]=$v;\n\
    \            $keys[]=$k;\n        } else if ($k%3!==0) {\n            foreach\
    \ ($keys as $k2) {\n                $result[$k2]=max($result[$k2], $v);\n    \
    \        }\n        }\n    }\n    return $result;\n}", "  $l2 = array();\n  foreach\
    \ ($l as $i => $j){\n    if ($i % 3 != 0) $l2[$i] = $j;\n  }\n  arsort($l2);\n\
    \  return $l2;\n}\n", "  if (count($l) == 0) {\n    return $l;\n  }\n\n  $l[$l[$l[0]\
    \ / 3] + 1] = $l[$l[0] / 3] + 1;\n  if ($l[0] % 3 == 0) {\n    $l[$l[0] / 3 +\
    \ 2] = $l[$l[0] / 3 + 2];\n  }\n  $l[$l[0] / 3 + 1] = $l[$l[0] / 3 + 1];\n  if\
    \ ($l[0] % 3 == 1) {\n    $l[$l[0] / 3 + 2] = $l[$l[0] / 3 + 2];\n  }\n  $l[$l[0]\
    \ / 3 + 1] = $l[$l[0] / 3 + 1];\n\n  foreach (array_chunk($l, 3) as $k => $v)\
    \ {\n    ksort($v);\n    $l[$k] = $v;\n  }\n\n  return $l;\n}", "  for ($n = count($l);\
    \ $n-- > 1; ) {\n    for ($k = 0; $k < ( 2 * $n ); $k += 3) {\n      if ($l[$k]\
    \ > $l[$k + 1]) {\n        $temp = $l[$k];\n        $l[$k] = $l[$k + 1];\n   \
    \     $l[$k + 1] = $temp;\n      }\n    }\n  }\n  return $l;\n}\n\n/**\n * Prints\
    \ out a table with given data. Each column is aligned at the left.\n * Data should\
    \ be a list of lists whose inner lists are the given columns.\n *\n * @param $data\n\
    \ * @param $cols\n */", "  // Create a variable to hold the final sorted array\n\
    \  $result = array();\n  // Loop over each item in the input array\n  foreach\
    \ ($l as $k => $v) {\n    // If the current item is divisible by three, add it\
    \ to the result and continue\n    if ($v % 3 === 0) {\n      // If we're adding\
    \ the current item to the result array, then add it to the result array with a\
    \ key of $k and a value of $k+1 so the current item is sorted into position\n\
    \      $result[$k + 1] = $v;\n      // Else, add this current item to the result\
    \ array with a key of $k+1 but no value so the current item is put at the end\n\
    \    } else {\n      // Add the current item to the result array with a key of\
    \ $k but no value so this item is put in the beginning\n      $result[$k] = $v;\n\
    \    }\n  }\n  // Return the result array\n  return $result;\n}\n", "  $l2 = [];\n\
    \  for ($i = 0; $i < count($l); $i++)\n  {\n    if (!($i % 3))\n    {\n      $l2[$i]\
    \ = $l[$i];\n    }\n    else\n    {\n      $k2[$i / 3] = $l[$i];\n    }\n  }\n\
    \  $l3 = [];\n  for ($i = 0; $i < count($l2); $i++)\n  {\n    if (!($i % 3))\n\
    \    {\n      $l3[$i] = $l2[$i];\n    }\n    else\n    {\n      $k3[$i / 3] =\
    \ $l2[$i];\n    }\n  }\n  ksort($k3);\n  ksort($k2);\n  ksort($k1);\n  return\
    \ array_merge($l1, $l2, $l3);\n}\n", "\t$l1 = $l2 = $l3 = $l4 = $l5 = $l6 = $l7\
    \ = $l8 = $l9 = $l10 = $l11 = $l12 = $l13 = $l14 = $l15 = $l16 = $l17 = $l18 =\
    \ $l19 = $l20 = $l21 = 0;\n\t$l3 = array_slice($l, 3);\n\tforeach ($l as $k =>\
    \ $v) {\n\t\tif (($k & 1) !== 0) {\n\t\t\t$l1[$k] = $v;\n\t\t} else {\n\t\t\t\
    $l2[$k] = $v;\n\t\t}\n\t\tif ($k & 2) {\n\t\t\t$l3[$k] = $v;\n\t\t}\n\t\tif ($k\
    \ & 4) {\n\t\t\t$l4[$k] = $v;\n\t\t}\n\t\tif ($k & 8) {\n\t\t\t$l5[$k] = $v;\n\
    \t\t}\n\t\tif ($k & 16) {\n\t\t\t$l6[$k] = $v;\n\t\t}\n\t\tif ($k & 32) {\n\t\t\
    \t$l7[$k] = $v;\n\t\t}\n\t\tif ($k & 64) {\n\t\t\t$l8[$k] = $v;\n\t\t}\n\t\tif\
    \ ($k & 128) {\n\t\t\t$l9[$k] = $v;\n\t\t}\n\t\tif ($k & 256) {\n\t\t\t$l10[$k]\
    \ = $v;\n\t\t}\n\t\tif ($k & 512) {\n\t\t\t$l11[$k] = $v;\n\t\t}\n\t\tif ($k &\
    \ 1024) {\n\t\t\t$l12[$k] = $v;\n\t\t}\n\t\tif ($k & 2048) {\n\t\t\t$l13[$k] =\
    \ $v;\n\t\t}\n\t\tif ($k & 4096) {\n\t\t\t$l14[$k] = $v;\n\t\t}\n\t\tif ($k &\
    \ 8192) {\n\t\t\t$l15[$k] = $v;\n\t\t}\n\t\tif ($k & 16384) {\n\t\t\t$l16[$k]\
    \ = $v;\n\t\t}\n\t\tif ($k & 32768) {\n\t\t\t$l17[$k] = $v;\n\t\t}\n\t\tif ($k\
    \ & 65536) {\n\t\t\t$l18[$k] = $v;\n\t\t}\n\t\tif ($k & 131072) {\n\t\t\t$l19[$k]\
    \ = $v;\n\t\t}\n\t\tif ($k & 262144) {\n\t\t\t$l20[$k] = $v;\n\t\t}\n\t\tif ($k\
    \ & 524288) {\n\t\t\t$l21[$k] = $v;\n\t\t}\n\t}\n\treturn array_merge($l1, $l2,\
    \ $l3, $l4, $l5, $l6, $l7, $l8, ", "    $l3 = array_filter($l);\n    sort($l3);\n\
    \    $third = array_slice($l3, 0, count($l)/3);\n    $l3a = array_slice($l3, 0,\
    \ count($l)/3);\n    array_push($l3, $third);\n    array_push($l3a, $l);\n   \
    \ return $l3a;\n}", "  return array_merge(\n    array_slice($l, 0, count($l) %\
    \ 3),\n    array_slice($l, count($l) % 3, count($l)),\n    array_slice($l, count($l),\
    \ count($l))\n  );\n}", "  $l_size = count($l);\n  $l_third = array();\n  for\
    \ ($i = 0; $i < $l_size; $i++) {\n    if ($i % 3 === 0) {\n      $l_third[$i]\
    \ = $l[$i];\n    }\n  }\n\n  // Sort the remaining indicies that are not divisible\
    \ by three\n  sort($l_third);\n  // Set the indicies that are not divisible by\
    \ three to the value of the indicies that are\n  // divisible by three\n  for\
    \ ($i = 0; $i < $l_size; $i++) {\n    if ($i % 3 !== 0) {\n      $l[$i] = $l_third[$i];\n\
    \    }\n  }\n\n  return $l;\n}\n", "\t$l = array_filter($l);\n\tfor($i = 0; $i\
    \ < count($l); $i++) {\n\t\tif($i % 3 == 0) {\n\t\t\t$l[$i] = $l[$i-1];\n\t\t\
    } else {\n\t\t\t$l[$i] = $l[$i-1];\n\t\t}\n\t}\n\treturn $l;\n}\n", "\tforeach($l\
    \ as $i => $val) {\n\t\tif ($val % 3 != 0) {\n\t\t\tunset($l[$i]);\n\t\t}\n\t\
    }\n\tksort($l);\n\treturn $l;\n}\n", "    // Initialize an array l' of size l\
    \ that initially contains l\n    $lLength = count($l);\n    $lKeys = array_keys($l);\n\
    \    $lValues = array_values($l);\n    $lLenthMax = max($lLength, $lKeys);\n \
    \   $lKeysMin = min(count($l), $lKeys);\n\n    // If the size of the sorted array\
    \ is less than or equal to l's original size, we simply return l\n    if ($lKeysMin\
    \ <= $lLength) {\n        return $l;\n    }\n\n    // Initialize an array l' of\
    \ size lMax such that l' is exactly equal to l\n    $lMax = $lKeysMin;\n    $lMaxValue\
    \ = $lValues[$lMax];\n    $lMin = count($l) - 1;\n\n    // Initialize a loop variable\
    \ i to zero and initialize a running variable j to lMax\n    $i = 0;\n    $j =\
    \ $lMax;\n    $k = 0;\n    $currentValue = $lValues[0];\n    $currentKey = $lKeys[0];\n\
    \n    // Loop until i is greater than lMin\n    while ($i < $lMin) {\n       \
    \ // If l contains all elements with the same value, we simply return l\n    \
    \    if ($currentValue == $lValues[$i]) {\n            return $l;\n        }\n\
    \n        // If l contains no elements with the same value, we simply increment\
    \ i and j\n        if ($currentValue != $lValues[$i]) {\n            $i++;\n \
    \           $j = $i;\n            $currentValue = $lValues[$j];\n            $currentKey\
    \ = $lKeys[$j];\n        }\n\n        // If l contains all elements with the same\
    \ key, we simply increment i and j and increment k\n        if ($currentKey ==\
    \ $lKeys[$i]) {\n            $k++;\n            $j++;\n            $i = $j + 1;\n\
    \            $currentValue = $lValues[$j];\n            $currentKey = $lKeys[$j];\n\
    \        }\n\n        // If l contains no elements with the same key, we simply\
    \ increment i and j and increment k\n        if ($currentKey != $lKeys[$i]) {\n\
    \            $i++;\n            $j = $i;\n            $k++;\n            $currentValue\
    \ = $lValues[$j];\n            $currentKey = $lKeys[$j];\n        }\n\n      \
    \  // If l contains all elements that have the same key, we simply increment i\
    \ and j and increment k\n        if ($currentKey == $lKeys[$i]) {\n          \
    \  $k++;\n            $j++;\n            $i = $j + 1;\n            $currentValue\
    \ = $lValues[$j];\n            $currentKey = $lKeys[$j];\n", "  $l = $l;\n  $lt\
    \ = array();\n  $lc = array();\n  $t = 0;\n  for ($i = 0; $i < count($l); $i++)\
    \ {\n    if ($i % 3 == 0) {\n      $lt[$t] = $l[$i];\n      $t++;\n    } else\
    \ {\n      $lc[$i] = $l[$i];\n    }\n  }\n  $i = 0;\n  for ($i = 0; $i < count($lc);\
    \ $i++) {\n    foreach ($lt as $k) {\n      if ($lc[$i] == $k) {\n        $l[$i]\
    \ = $k;\n        unset($lt[$k]);\n        break;\n      }\n    }\n  }\n  return\
    \ $l;\n}\n", "  $lsize = count($l);\n  for($i=0; $i<$lsize; $i++) {\n    for($j=$i+1;\
    \ $j<$lsize; $j++) {\n      if($l[$i] % 3 != $l[$j] % 3) {\n        $t = $l[$i];\n\
    \        $l[$i] = $l[$j];\n        $l[$j] = $t;\n      }\n    }\n  }\n  for($i=0;\
    \ $i<$lsize; $i++) {\n    if($l[$i] % 3 == 0) {\n      for($j=$i+1; $j<$lsize;\
    \ $j++) {\n        if($l[$j] % 3 == 0) {\n          $t = $l[$i];\n          $l[$i]\
    \ = $l[$j];\n          $l[$j] = $t;\n        }\n      }\n    }\n  }\n  return\
    \ $l;\n}", "    $lprime = array();\n    $count = count($l);\n    for ($i=0; $i<$count;\
    \ $i++) {\n        if ($i % 3 == 0) {\n            $lprime[] = $l[$i];\n     \
    \   }\n    }\n    return sort($lprime);\n}", "\tusort($l, function ($a, $b) {\n\
    \t\tif ($a % 3 === 0) {\n\t\t\treturn -1;\n\t\t} else if ($b % 3 === 0) {\n\t\t\
    \treturn 1;\n\t\t} else {\n\t\t\treturn $a - $b;\n\t\t}\n\t});\n\treturn $l;\n\
    }\n", "    $newl = [];\n    foreach ($l as $index => $value) {\n        $mod =\
    \ $index % 3;\n        if ($mod === 0) {\n            $newl[$index] = $value;\n\
    \        } else if ($mod === 1) {\n            $i = $index - $mod;\n         \
    \   if ($i >= 0 && $i < count($newl)) {\n                $newl[$i] = $value;\n\
    \            }\n        } else if ($mod === 2) {\n            $j = $index - $mod;\n\
    \            if ($j >= 0 && $j < count($newl)) {\n                $j = $j + $mod\
    \ - 1;\n                if ($j >= 0 && $j < count($newl)) {\n                \
    \    $newl[$j] = $value;\n                }\n            }\n        }\n    }\n\
    \    return $newl;\n}\n", "\t$len = count($l);\n\tif ($len < 3) {\n\t\treturn\
    \ $l;\n\t}\n\t$len2 = $len/2;\n\tfor ($i = 0; $i < $len2; $i++) {\n\t\t$l[$i]\
    \ = $l[$i];\n\t}\n\tfor ($i = 0; $i < $len; $i += 3) {\n\t\tif ($l[$i] > $l[$i+1])\
    \ {\n\t\t\t$l[$i] = $l[$i+1];\n\t\t}\n\t}\n\tfor ($i = 0; $i < $len; $i += 3)\
    \ {\n\t\tif ($l[$i] == $l[$i+1]) {\n\t\t\tif ($l[$i] > $l[$i+2]) {\n\t\t\t\t$l[$i]\
    \ = $l[$i+2];\n\t\t\t}\n\t\t}\n\t}\n\treturn $l;\n}", "    $llength = count($l);\n\
    \    $third = $llength / 3;\n    $thirdindex = 0;\n    $thirdvalues = array();\n\
    \    for ($i = 0; $i < $llength; $i++) {\n        if (!($i % 3)) {\n         \
    \   $thirdvalues[$thirdindex] = $l[$i];\n            $thirdindex++;\n        }\n\
    \    }\n    ksort($thirdvalues);\n    return array_merge(array($l[0]), $thirdvalues,\
    \ array($l[$llength - 1]));\n}", "    $l = array_flip($l);\n    foreach ($l as\
    \ $k => $v) {\n        if ($k % 3 == 0) {\n            $l[$k] = $k;\n        }\n\
    \    }\n    ksort($l);\n    return $l;\n}", "  array_multisort(array_intersect_key($l,\
    \ array_flip(range(0, count($l)-1, 3)), SORT_DESC, SORT_NUMERIC);\n  return $l;\n\
    }\n", "  foreach ($l as $index => $value) {\n    if ($index % 3 == 0) {\n    \
    \  if ($value <= $l[$index + 1]) {\n        $l[$index + 1] = $value;\n      }\n\
    \    }\n  }\n  return $l;\n}\n", "\tforeach($l as $index => $value) {\n\t\tif\
    \ ($index % 3 !== 0) {\n\t\t\t$l[$index] .= $l[$index % 3];\n\t\t\tunset($l[$index\
    \ % 3]);\n\t\t}\n\t}\n\tksort($l);\n\treturn $l;\n}\n", "    foreach ($l as $index\
    \ => $value) {\n        if ($index % 3 != 0) {\n            $l[$index] = $value;\n\
    \        }\n    }\n    return array_unique($l);\n}\n", "\tfor ($i = 0, $j = count($l);\
    \ $i < $j; $i += 3) {\n\t\t$l[$i] = $l[$i + 1];\n\t\t$l[$i + 1] = $l[$i];\n\t\
    }\n\treturn $l;\n}\n", "  $n = count($l);\n  foreach (range(0, $n - 3) as $i)\
    \ {\n    $j = $i + 1;\n    while ($j < $n && $j % 3 == 0) {\n      $l[$j - 1]\
    \ = $l[$j];\n      $j++;\n    }\n    $l[$i - 1] = $l[$i];\n  }\n  return $l;\n\
    }\n", "    $lcopy = array();\n    $keys = array_keys($l);\n    $i = 0;\n    foreach($keys\
    \ as $key) {\n        if($i%3) {\n            $lcopy[$key] = $l[$key];\n     \
    \   } else {\n            $i++;\n        }\n    }\n    return $lcopy;\n}", " \
    \   $l = array_slice($l, 1);\n    $l2 = array_slice($l, 1);\n    $l3 = array_slice($l,\
    \ 1);\n    foreach ($l3 as $i => $a) {\n        $l2[$i] -= 1;\n        if ($l2[$i]\
    \ == 0) {\n            unset($l2[$i]);\n            $l2[] = $a;\n        }\n \
    \   }\n    return array_merge($l2, $l3);\n}\n</code>\n<|/ a dscore=0 |>\n<| c\
    \ |>\nWow, thanks! I will have to do some more testing but this appears to work\
    \ perfectly. I will let you know if I can implement it into my code and mark it\
    \ as the correct answer.\n<|/ c |>\n<| c |>\nIt works as expected with test cases\
    \ I made up. I'll need to do a little more testing with my actual data.\n<|/ c\
    \ |>\n<| a tags=php,arrays,sorting |>\nI believe this is what you're looking for:\n\
    <code>\n<?php\n$input = array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n\n$output = array();\n\
    foreach($input as $value) {\n    if($value % 3 === 0) {\n        array_push($output,\
    \ 3);\n        array_push($output, 2);\n        array_push($output, 1);\n    }\n\
    \    else {\n        array_push($output, $value);\n    }\n}\n\nprint_r($output);",
  "    foreach($l as $i => $val) {\n        if($i%3 == 0 && $i != 0)\n           \
    \ $l[$i] = $l[$i-1];\n    }\n    return $l;\n}\n</code>\nThe output of this script\
    \ is:\n<code>\n$ php sort_third.php \narray(1, 2, 3)\narray(2, 3, 4, 6, 8, 5,\
    \ 9)\n</code>\n<|/ a |>\n<| a dscore=2 tags=php,algorithm |>\nIf you just want\
    \ to sort the array in ascending order (as in the examples), then you can use\
    \ the array_multisort() function\n<code>\n<?php\n$input = array(1, 2, 5, 6, 3,\
    \ 8, 4, 9);\narray_multisort($input, SORT_ASC, SORT_REGULAR);\n\nprint_r($input);\n\
    </code>\n<|/ a |>\n<| a tags=php,algorithm |>\n<code>\n<?php\n$ar = array(\n \
    \   1 => 10,\n    2 => 8,\n    3 => 5,\n    4 => 7,\n    5 => 6,\n    6 => 4,\n\
    \    7 => 3,\n    8 => 2,\n    9 => 1\n);\n</code>\nUsing array_multisort() and\
    \ asort() you can sort it using the following code :\n<code>\narray_multisort(\
    \ asort($ar), $ar);\nvar_dump($ar);\n</code>\n<|/ a dscore=1 |>\n<| a |>\nYou\
    \ can simply use asort function \n<code>\n<?php\n$array=array(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16);\n\
    asort($array);\nprint_r($array);\n</code>\n<|/ a tags=php,algorithm dscore=1 |>\n\
    <| a |>\nA simple solution:\n<code>", "  sort($l);\n  $third = [];\n  $i = -1;\n\
    \  while (++$i < count($l)) {\n    if (($l[$i] % 3) == 0) {\n      $third[] =\
    \ $l[$i];\n    }\n  }\n  return $third;\n}\n</code>\nFor each item in l that is\
    \ a multiple of 3, we append it to the end of third.\n<|/ a |>\n<| a dscore=0\
    \ |>\n<code>\n<?php", "    for ($i = 0; $i < count($l); $i++) {\n        for ($j\
    \ = $i + 1; $j < count($l); $j++) {\n            $k = $j + 2;\n            $l[$j\
    \ + 1] = array($l[$j], $l[$k]);\n            $l[$j + 1][0] = $j;\n        }\n\
    \    }\n    return $l;\n}\n", "    $result = array();\n    foreach ($l as $key\
    \ => $value) {\n        if ($key % 3 == 0)\n            $result[$key] = $value;\n\
    \        else\n            $result[$key] = $value;\n    }\n    asort($result);\n\
    \    return $result;\n}\n", "    $l2 = array_slice($l, 0, 3);\n    $l3 = array_slice($l,\
    \ 3);\n\n    // array_slice returns the whole array if its parameters are smaller\
    \ than the array's size\n    // This happens because array_slice is designed to\
    \ work with arrays of any size. Not just 3, though.\n    if (count($l3) == count($l2))\
    \ {\n        return $l2;\n    } else {\n        return array_merge(sort_third($l2),\
    \ $l3);\n    }\n}", "    $third = array();\n    $index = 0;\n    foreach ($l as\
    \ $key => $value) {\n        if ($index % 3 == 0 && $key < $index) {\n       \
    \     $third[$key] = $l[$key];\n        } elseif ($index % 3 == 1) {\n       \
    \     $third[$key] = $value;\n        } elseif ($index % 3 == 2) {\n         \
    \   $third[$key] = $l[$index];\n            $index = $index + 1;\n        }\n\
    \        $index++;\n    }\n    return $third;\n}\n", "    $third = 0;\n    $l2\
    \ = $l;\n    foreach ($l as $k => $v) {\n        if ($v % 3 == 0) $third[$k] =\
    \ $v;\n        else {\n            $t2 = 0;\n            $k2 = $k;\n         \
    \   foreach ($l2 as $k2 => $v2) {\n                if ($v % 3 == 0) $t2[$k2] =\
    \ $v2;\n                if ($t2 == $k2) $l2[$k2] += $v;\n            }\n     \
    \   }\n    }\n    return $l2;\n}\n", "    foreach ($l as $i => $e) {\n       \
    \ if ($e % 3 == 0) {\n            $temp = array_keys($l, $e);\n            $l[$temp[0]]\
    \ = $e;\n            unset($l[$i]);\n        }\n    }\n    return $l;\n}\n", " \
    \   // First sort the array so that all the values not divisible by 3 are next\
    \ to each other\n    sort($l);\n\n    $len = count($l);\n    $result = [];\n \
    \   $index = 0;\n    $lsum = $l[0];\n    $result[$index] = $l[0];\n\n    for ($i\
    \ = 1; $i < $len; ++$i) {\n        if ($l[$i] % 3 != 0) {\n            if ($lsum\
    \ < $l[$i]) {\n                $lsum = $l[$i];\n                $index = $i;\n\
    \            }\n        }\n    }\n\n    $result[$index] = $l[$i];\n    $j = 0;\n\
    \    while ($j < $len) {\n        if ($l[$j] % 3 == 0) {\n            if ($l[$j]\
    \ > $l[$index]) {\n                $l[$index] = $l[$j];\n                $index\
    \ = $j;\n            }\n        } else {\n            $result[$index] = $l[$j];\n\
    \            $index++;\n        }\n        $j++;\n    }\n\n    return $result;\n\
    }\n</code>\n<|/ a tags=php,arrays,sorting |>\n<| c |>\nWhy not sort the array\
    \ first then use array_search to find the indices?\n<|/ c |>\n<| c |>\narray_search\
    \ doesn't sort the array and array_search isn't fast at large arrays.\n<|/ c |>\n\
    <| c |>\nThe function returns true if the value is not found in the array. So,\
    \ if you wanted to do that, you could just do a `return !array_search(...)`\n\
    <|/ c |>\n<| c |>\nThis is an excellent solution and works well. I've been trying\
    \ to get this working for a while.  Thank you!\n<|/ c |>\n<| a tags=php,arrays,sorting\
    \ dscore=4 |>\nHere is my take.\n<code>\n$array = array(1, 2, 3, 4, 5);\n\n$thirdArr\
    \ = array_filter($array, function ($x) { return ($x % 3 != 0); });\n\nsort($thirdArr);\n\
    $result = array_combine(range(0,count($thirdArr)-1), $thirdArr);\n\nprint_r($result);\n\
    </code>\n<|/ a |>\n<| c |>\nI believe array_filter would filter the array based\
    \ on the return value of a function - which is not what OP needs.\n<|/ c |>\n\
    <| c |>\narray_filter only removes values from the array, it does not sort the\
    \ array.\n<|/ c |>\n<| c |>\nYes, I read his question wrong.  I thought he wanted\
    \ to sort the array based on the results of the filter which would be a lot faster\
    \ than sorting the ", "    $l2 = $l;\n    // sort the indicies of the array so\
    \ that when the values at the indicies that are not divisible by three are equal\n\
    \    // the corresponding indicies are also equal\n    for ($i = 0; $i < count($l);\
    \ $i++) {\n        if ($i % 3 === 0) {\n            array_push($l2, $l[$i]);\n\
    \        }\n    }\n    // sort again by using the values of those indicies that\
    \ are divisible by three\n    sort($l2, SORT_NUMERIC);\n    return $l2;\n}\n",
  "    sort($l);\n    $tl = array();\n    $j = 0;\n    foreach ($l as $k => $v) {\n\
    \        if ($k % 3 === 0) {\n            $tl[$j] = $v;\n        }\n        $j++;\n\
    \    }\n    return $tl;\n}", "  sort($l, SORT_NUMERIC);\n  $l2 = array();\n  for\
    \ ($i = 0; $i < count($l); $i += 3) {\n    $l2[] = $l[$i];\n  }\n  return $l2;\n\
    }\n$list = array(1, 2, 3);\nprint 'Sorted list: ' . join(', ', sort_third($list))\
    \ . \"\\n\";", "\t// Make sure l is actually an array\n\tif (!is_array($l)) {\n\
    \t\tthrow new InvalidArgumentException('sort_third expects an array');\n\t}\n\n\
    \t// Make sure the size of the l array is 3\n\tif (count($l) != 3) {\n\t\tthrow\
    \ new InvalidArgumentException('sort_third expects a three-element array');\n\t\
    }\n\n\t// Make sure the elements of the array are all different from each other\n\
    \tforeach ($l as $k => $v) {\n\t\t$l[$k] = $k;\n\t}\n\n\t// Create a new array\
    \ with the same number of indicies as l, with one more element than l\n\t$len\
    \ = $l[0] + 1;\n\t$lplus = array();\n\n\t// Add elements to the new array that\
    \ are not divisible by three\n\tfor ($i = 0; $i < $len; $i++) {\n\t\t$lplus[$i]\
    \ = $l[0];\n\t}\n\n\t// Find the indicies of the unsorted array\n\tforeach ($l\
    \ as $k => $v) {\n\t\tif ($k % 3 != 0) {\n\t\t\t$lplus[$k] = $k;\n\t\t}\n\t}\n\
    \n\t// Sort the unsorted array\n\tsort($lplus);\n\n\t// Create a new array with\
    \ the same number of indicies as l, with one less element than l\n\t$len = $len\
    \ - 1;\n\t$newarray = array();\n\n\t// Copy all the elements from the unsorted\
    \ array to the new array \n\tforeach ($l as $k => $v) {\n\t\t$newarray[$lplus[$k]]\
    \ = $v;\n\t}\n\n\t// Return the new array\n\treturn $newarray;\n}\n", "    for\
    \ ($i = 0; $i < count($l); $i++) {\n        $l = array_merge($l, $l); //flattens\
    \ array into 1d array\n        sort($l, SORT_NUMERIC);\n        $thirdIndex =\
    \ $i % 3;\n        $l[$thirdIndex] = $l[$thirdIndex] * 100; //divides index by\
    \ 100 to get integer value between 0 and 100\n        unset($l[$thirdIndex]);\
    \ //removes index from original array \n        $l[$i] /= 100; //divides index\
    \ by 100 again to get original value between 0 and 100\n    }\n    return $l;\n\
    }\n", "    $l2 = array();\n    foreach ($l as $i => $val) {\n        if (($i &\
    \ 1) == 1) {\n            $l2[$i] = $val;\n        } else {\n            if ($val\
    \ % 3 == 0) {\n                for ($j = $i + 1; $j < count($l); $j++) {\n   \
    \                 if ($l[$j] % 3 == 0) {\n                        $l[$j] = $l[$j];\n\
    \                        $l2[$j] = $l[$j];\n                    }\n          \
    \      }\n            } else {\n                $l2[$i] = $val;\n            }\n\
    \        }\n    }\n    return $l2;\n}\n", "    for ($i = 0, $j = count($l) - 1;\
    \ $i < $j; $i++, $j--) {\n        if ($l[$i] % 3 != $l[$j] % 3) {\n          \
    \  array_push($l, $l[$i], $l[$j]);\n        }\n    }\n    return $l;\n}\n</code>\n\
    <|/ a dscore=3 tags=php,arrays |>\n<| c |>\nThis one works well for me. My array\
    \ is sorted according to a number that I use to sort the other array. I used array_map\
    \ to sort a number array to match the sorted array numbers. Thanks.\n<|/ c |>\n\
    <| a |>\nI have found a more elegant solution:\n<code>\n<?php\n$array = array(1,\
    \ 3, 3, 4, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 8);", "\tforeach ($l as $key => $value)\
    \ {\n\t\tif ($key%3 == 0) unset($l[$key]);\n\t}\n\tarray_multisort($l, SORT_DESC);\n\
    \treturn $l;\n}", "    foreach ($l as $i => $j) {\n        if ($j % 3 !== 0) {\n\
    \            $l[$i] = $j;\n        }\n    }\n    asort($l);\n    foreach ($l as\
    \ $i => $j) {\n        if ($j % 3 === 0) {\n            $l[$i] = $j;\n       \
    \ }\n    }\n    return $l;\n}\n</code>\n<|/ a |>\n<| c |>\nI feel like the answer\
    \ here would be a lot more informative if it also explained what you did.\n<|/\
    \ c |>\n<| c |>\nThanks, this is exactly what I was looking for. Thanks for the\
    \ detailed explanation as well. Definitely made things clear.\n<|/ c |>\n<| a\
    \ dscore=2 |>\nMy solution to this problem:\n<code>\n<?php\n$input = array(1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);\n", "\tforeach ($l as $key\
    \ => $value) {\n\t\tif ($key % 3 === 0 && $key !== 0 && $key % 5 !== 1) {\n\t\t\
    \t$new[$key] = $value;\n\t\t}\n\t}\n\tsort($new);\n\treturn $new;\n}\n", "\tusort($l,\
    \ 'sort_by_third');\n\treturn $l;\n}\n", "    sort($l, SORT_NUMERIC);\n    for($i\
    \ = 0; $i < count($l); $i += 3) {\n        $l[$i + 1] = $l[$i];\n    }\n    return\
    \ $l;\n}\n</code>\nNow we do the same for the even numbers, we sort the list from\
    \ smallest to largest, and then we loop through each value and compare it to its\
    \ 3 neighbours. If they are equal, we put the new value at its 3 neighbour index.\
    \ \n<code>\n<?php", "    // Copy $l to avoid changing it\n    $l2 = $l;\n    //\
    \ Get the index of the first element to sort\n    $i = count($l) - 1;\n    while\
    \ ($i > 0) {\n        // See if it is a multiple of three\n        if ($i % 3\
    \ === 0) {\n            // If so, swap the indicies in the $l and $l2\n      \
    \      $t = $l[$i % 3];\n            $l[$i % 3] = $l2[--$i];\n            $l2[$i]\
    \ = $t;\n        } else {\n            // If not, move on to the previous element\n\
    \            --$i;\n        }\n    }\n    // Return the new array\n    return\
    \ $l;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\n`sort` does not take an arbitrary\
    \ function. `sort` sorts by one element at a time and then moves to the next element\
    \ in the list until it gets to the end. Your algorithm sorts by every other element,\
    \ and `sort` keeps swapping the last two elements in the list until the list is\
    \ sorted.\n<|/ c |>\n<| c |>\n`sort` sorts using the `<` operator. Your algorithm\
    \ swaps `1` and `2` as they both have index `0`, then sorts `3` as the next element.\
    \ Your algorithm swaps `4` and `5` as they both have index `1`, and then sorts\
    \ `6` as the next element.\n<|/ c |>\n<| c |>\nI see what you mean, I got confused\
    \ because you used `<`, but then you changed it to `==`. It's still not clear\
    \ what you mean by \"The way the algorithm sorts is by every other element\",\
    \ though.\n<|/ c |>\n<| c |>\nThe way the algorithm sorts is by every other element\
    \ means it sorts by every other element before swapping elements (and in reverse\
    \ order). So it starts by comparing `1` and `2`, and swaps `3` and `4`, then sorts\
    \ `5` and `6`, swaps `7` and `8`, and sorts `9` and `10`, and so on.\n<|/ c |>\n\
    <| c |>\nAh, but that's what you're doing with the `if`: `$i % 3 === 0`. You're\
    \ checking whether `i` is a multiple of three. Did you try `i` with `1` as your\
    \ example?\n<|/ c |>\n<| a |>\n<code>\n<?php\n/* sort array in place\n * \n *\
    \ $array - array to be sorted\n * $sort - string with operator: \n *         \
    \       + for ascending order \n *                - for descending order\n * \
    \               * for multiplication of elements on same position \n *       \
    \         / for division", "  $l2 = $l; // copy in array l\n  foreach ($l2 as\
    \ $key => $value) {\n    if ($value % 3 === 0) {\n      $l2[$key] = $value;\n\
    \    }\n  }\n  $l3 = array();\n  foreach ($l2 as $key => $value) {\n    if ($value\
    \ % 3 !== 0) {\n      $l3[$key] = $value;\n    }\n  }\n  return $l3;\n}", "  \
    \  foreach ($l as $i => $value) {\n        if ($value % 3 !== 0) {\n         \
    \   $l[$i] = $value;\n        }\n    }\n    array_multisort($l, SORT_ASC);\n \
    \   return $l;\n}", "    $l2 = [];\n    for ($i = 0, $n = count($l); $i < $n;\
    \ $i++) {\n        $l2[($i % 3 == 0)][] = $l[$i];\n    }\n    return $l2;\n}",
  "  $length = count($l);\n  $third = array_fill(0, $length, array_fill(0, $length,\
    \ 0));\n  for ($i = 0; $i < $length; ++$i) {\n    if ($i % 3 == 0) {\n      for\
    \ ($j = 0; $j < $length; ++$j) {\n        if ($j % 3 == 0) {\n          if ($j\
    \ > $i) {\n            $third[$i][$j] = $l[$j];\n          }\n          else {\n\
    \            $third[$i][$j] = $l[$j + 1];\n          }\n        }\n      }\n \
    \   }\n  }\n\n  for ($i = 0; $i < $length; ++$i) {\n    asort($third[$i]);\n \
    \ }\n  return $third;\n}\n</code>\nNote that this assumes your list is sorted\
    \ by increasing number. I've written it so it can be used for any list though.\n\
    <|/ a tags=arrays,php,multidimensional-array |>\n<| a |>\nIf you use PHP 5.6 or\
    \ above, you can use the array_chunk() function and array_combine() functions:\n\
    <code>\n$chunks = array_chunk($array, 3);\n\n$combined = array_combine(array_keys($chunks),\
    \ $chunks);\n</code>\nThe result will be like this:\n<code>\nArray\n(\n    [0]\
    \ => Array\n        (\n            [0] => 1\n            [1] => 2\n          \
    \  [2] => 3\n        )\n\n    [1] => Array\n        (\n            [0] => 5\n\
    \            [1] => 6\n            [2] => 4\n        )\n\n    [2] => Array\n \
    \       (\n            [0] => 9\n            [1] => 8\n            [2] => 7\n\
    \        )\n\n    [3] => Array\n        (\n            [0] => 11\n           \
    \ [1] => 10\n            [2] => 5\n        )\n\n    [4] => Array\n        (\n\
    \            [0] => 13\n            [1] => 12\n            [2] => 4\n        )\n\
    \n    [5] => Array\n        (\n            [0] => 15\n            [1] => 14\n\
    \            [2] => 3\n        )\n\n    [6] => Array\n        (\n            [0]\
    \ => 17\n            [1] => 16\n            [2] => 2\n        )\n)\n</code>\n\
    <|/ a dscore=4 tags=arrays,php,multidimensional-array |>\n<| a dscore=3 |>\nI\
    \ have made a helper function using array_map and array_merge:\n<code>", "   \
    \ $l = array_slice($l, 0, 3);\n    foreach ($l as $i => $v) {\n        if ($i\
    \ % 3 != 0) {\n            sort($l[$i], $l[$i - 1], SORT_NUMERIC);\n        }\n\
    \    }\n    return $l;\n}\n", "    $third = array();\n    $count = 0;\n    $l\
    \ = array_unique($l);\n    foreach ($l as $i => $v) {\n        $count += ($v %\
    \ 3 == 0 ? 0 : 1);\n        $third[$i] = $v;\n    }\n    ksort($third);\n    return\
    \ array_intersect_key($l, $third);\n}\n", "\t// copy l into new array (so we can\
    \ modify l)\n\t$l2 = $l;\n\t// sort the new array\n\tsort($l2);\n\t// make new\
    \ array the same length as old array\n\t$l = $l2;\n\t// make the indicies divisible\
    \ by three zero\n\tfor ($i = 0; $i < count($l); $i += 3) {\n\t\t// if the current\
    \ index is divisible by three, copy the value from the current index to the next-to-last\
    \ index, and delete the current index\n\t\tif ($i / 3 == $i % 3) {\n\t\t\t$l[$i\
    \ + 2] = $l[$i];\n\t\t\tunset($l[$i]);\n\t\t}\n\t}\n\t// return the new array\n\
    \treturn $l;\n}", "    foreach ($l as $index => $value) {\n        $remainder\
    \ = $index % 3;\n        if ($remainder == 0) {\n            $l[$index] = $value;\n\
    \        } else if ($remainder == 1) {\n            unset($l[$index]);\n     \
    \       $l[++$index] = $value;\n        }\n    }\n    return $l;\n}", "    $l\
    \ = array_reverse($l);\n    foreach ($l as $k => $v) {\n        if ($k%3 == 0)\n\
    \            $l[$k] = $v;\n    }\n    sort($l);\n    return $l;\n}\n", "    $lsorted\
    \ = $l;\n    for ($i = 0; $i < count($l); $i++) {\n        $lsorted[$i] = $l[$i];\n\
    \    }\n    for ($i = 0; $i < count($l); $i += 3) {\n        $lsorted[$i] = $lsorted[$i]\
    \ + $lsorted[$i + 1] + $lsorted[$i + 2];\n        unset($lsorted[$i + 1], $lsorted[$i\
    \ + 2]);\n    }\n    return $lsorted;\n}\n", "    $l2 = array();\n    for($i =\
    \ 0; $i < count($l); $i++) {\n        if(($i % 3) == 0) {\n            $l2 = array_merge($l2,\
    \ array_slice($l, $i, 2));\n        } else {\n            $l2[$i] = $l[$i];\n\
    \        }\n    }\n    return $l2;\n}\n", "\tforeach ($l as $key => $value) {\n\
    \t\tif ($key % 3 == 0) {\n\t\t\t$l[$key] = $l;\n\t\t}\n\t\telse {\n\t\t\t$l =\
    \ $l;\n\t\t}\n\t}\n\treturn $l;\n}", "    $len  = count($l);\n    $third = array_fill(0,\
    \ $len, 3);\n    for ($i = 0; $i < $len; $i++) {\n        $third[$i] = $l[$i]\
    \ % 3;\n    }\n    usort($l, 'sort_third_compare');\n    $sorted = array_fill(0,\
    \ $len, 0);\n    for ($i = 0; $i < $len; $i++) {\n        $sorted[$i] = $third[$i];\n\
    \        $sorted[$i] = $l[$i];\n        $sorted[$i] += $third[$i];\n    }\n  \
    \  return $sorted;\n}\n", "    $l = array_merge($l);\n    $len = count($l);\n\
    \    for ($i = 1; $i < $len; $i++) {\n        foreach (array_chunk($l, 3) as $chunk)\
    \ {\n            sort($chunk);\n        }\n        foreach (array_chunk($l, 3)\
    \ as $chunk) {\n            $l[] = $chunk[0];\n        }\n    }\n    return $l;\n\
    }\n</code>\n<|/ a dscore=3 tags=php |>\n<| c |>\nThis also works well for cases\
    \ where there are other items in the array that would require special handling.\
    \ For instance if OP wanted to use different sorting orders for certain items\
    \ in the array.\n<|/ c |>\n<| c |>\nI agree. There are more elegant solutions\
    \ though.\n<|/ c |>\n<| c |>\nVery nice idea, thanks. I modified the function\
    \ a little as I wanted to sort it by a custom order and I added another parameter.\n\
    <|/ c |>\n<| a tags=php |>\n<code>\n$arr = array(1, 2, 3);\n$newArr = array();\n\
    $count = 0;\nforeach ($arr as $key => $value) {\n   if ($count%3 == 0 && $count\
    \ != 0) {\n      array_push($newArr, $value);\n   }\n   $count++;\n}\nprint_r($newArr);\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nThis one also works but is more complicated\
    \ than the other solutions. Thanks.\n<|/ c |>\n<| c |>\nIt's not complicated,\
    \ it's a simple loop.\n<|/ c |>\n<| c |>\nOk, that makes sense. But the code is\
    \ longer than other solutions. Thanks for explaining.\n<|/ c |>\n<| c |>\nIt might\
    \ be longer but it's easier to understand and maintain.  It also uses less memory\
    \ than most solutions.  If you use something like this often enough, you might\
    \ consider putting it in a function and making it a helper method.\n<|/ c |>\n\
    <| a |>\nThis is my variant for sorting\n<code>\n$arr = array(1, 2, 3, 4, 5);\n\
    array_walk($arr, function(&$v, $k) {\n    $k++;\n    $k%3 ? $v = $k+1 : $v = $k;\n\
    });\nprint_r($arr);\n</code>\n<|/ a dscore=2 tags=php |>\n<| a |>\n<code>\n$input\
    \ = array(1, 2, 3, 4, 5);\n$result = array();\n$i = 0;\nwhile($i <= count($input)){\n\
    \  if($i%3 == 0){\n    if($i == 0){", "  $l = list($l); $l[0] = array_shift($l);\
    \ sort($l);\n  $l2 = array(); $l2 = $l;\n  for($i=0; $i<count($l); $i++) $l2[$i]\
    \ = $l[$i%3];\n  return $l2;\n}", "  if (count($l) <= 1) return $l;\n  // l' is\
    \ identical to l in the indicies that are not divisible by three, while its values\
    \ at the indicies that are divisible by three are equal\n  // to the values of\
    \ the corresponding indicies of l, but sorted.\n  for ($i = count($l) - 2 ; $i\
    \ >= 0 ; $i -= 3) {\n    for ($j = $i + 1 ; $j < count($l) ; $j += 1) {\n    \
    \  if ($l[$i] < $l[$j]) {\n        list($l[$i], $l[$j]) = array($l[$j], $l[$i]);\n\
    \      }\n    }\n  }\n  return $l;\n}\n", "  sort($l);\n  $third_divisible_by_three\
    \ = array();\n  foreach ($l as $key => $value) {\n    if ($key % 3 === 0) $third_divisible_by_three[$key\
    \ / 3] = $value;\n  }\n  return array_merge($third_divisible_by_three, array_slice($l,\
    \ 0, count($l) / 3));\n}\n", "  usort($l, function($a, $b) {\n    return $a%3\
    \ == $b%3? $a - $b : $a%3 - $b%3 == 0 ? $a - $b :\n      ($a%3 == $b%3? $a - $b\
    \ : $a%3 - $b%3 == 0 ? $a - $b : $a - $b);\n  });\n  return $l;\n}\n\n$l = array(1,2,3);\n\
    $l2 = sort_third($l);\n$l3 = sort_third($l);", "  // Sort the l array\n  $l2 =\
    \ array();\n  foreach ($l as $i => $v) {\n    if ($i % 3 == 0) {\n      // Add\
    \ all values that are divisible by three\n      $l2[$i] = $v;\n    } else {\n\
    \      // Add all values that are not divisible by three\n      $l2[$i] = $l[$i];\n\
    \    }\n  }\n  // Return the array l' such that l' is identical to l and all its\
    \ values at its indicies that are divisible by three are equal to the values at\
    \ its indicies that are divisible by three.\n  return $l2;\n}\n$l = array(1, 2,\
    \ 3);\n$l2 = sort_third($l);", "  $l1 = array();\n  $l2 = array();\n\n  for ($i\
    \ = 0; $i < count($l); $i++) {\n    if ($i % 3 == 0) {\n      $l1[$i] = $l[$i];\n\
    \    }\n    else {\n      $l2[$i] = $l[$i];\n    }\n  }\n\n  ksort($l1);\n  ksort($l2);\n\
    \n  $l3 = array_merge($l1, $l2);\n\n  return $l3;\n}\n", "\tforeach($l as $k =>\
    \ $v)\n\t\t$l[$k] = $k%3 == 0 ? $v : $v;\n\t\n\tsort($l);\n\t\n\tforeach($l as\
    \ $k => $v)\n\t\t$l[$k] %= $k;\n\t\n\treturn $l;\n}", "    // sort the array (as\
    \ described in question 2)\n    sort($l);\n    // get the indicies that do not\
    \ divisible by three\n    $indicies = array_search($l[0], array_keys($l));\n \
    \   // put all values at the same indicies that do not divisible by three into\
    \ the array that is returned by the function\n    return array_intersect_key($l,\
    \ array_flip($indicies));\n}", "    $third = $l;\n    for ($i = 0; $i < count($third);\
    \ $i ++) {\n        $j = 0;\n        $temp = $third[$i];\n        while ($j <\
    \ count($third) && $third[$j] % 3 != 0) {\n            $third[$j + 1] = $third[$j];\n\
    \            $j++;\n        }\n        $third[$j + 1] = $temp;\n    }\n    return\
    \ $third;\n}\n</code>\n<|/ a tags=sorting,arrays,php |>\n<| c |>\nHow does this\
    \ answer the question?\n<|/ c |>\n<| c |>\n: It sorts the indicies of the array\
    \ while keeping the values of the elements where they are divisible by 3 equal.\n\
    <|/ c |>\n<| c |>\n: I've edited my answer to include a solution without using\
    \ recursive functions, but still uses two for loops.\n<|/ c |>\n<| c |>\nI've\
    \ added an answer that avoids recursive functions, but still uses two for loops.\n\
    <|/ c |>\n<| a |>\n<code>\n$new_array = array();\nforeach ($array as $key=>$value){\n\
    \    if($value % 3 == 0){\n        $new_array[$key] = $value;\n    }\n}\nreturn\
    \ $new_array;\n</code>\n<|/ a dscore=1 tags=sorting,arrays,php |>\n<| c |>\nHe\
    \ wants to keep those values sorted as well, so the array should end up being\
    \ 1, 2, 3, 4, 5, 6, 7, 8 and 9.\n<|/ c |>\n<| c |>\nIt should still be 1, 2, 3,\
    \ 4, 5, 6, 7, 8 and 9. He wants them in ascending order, so the array should be\
    \ sorted like `1, 4, 7, 2, 5, 8, 3, 6, 9`.\n<|/ c |>\n<| a tags=sorting,arrays,php\
    \ |>\n<code>\n$a = array(1,2,3,4,5,6,7,8,9);\nfor($i=0;$i<count($a);$i++){\n \
    \   $b = $a[$i];\n    while($b%3 != 0){\n        $b++;\n    }\n    $temp = $a[$i];\n\
    \    $a[$i] = $a[$b];\n    $a[$b] = $temp;\n}\n\nvar_dump($a);\n</code>\n<|/ a\
    \ dscore=1 |>\n<| a |>\n<code>\n<?php\n$a = array(1,2,3,4,5,6,7,8,9);\nsort($a);\n\
    print_r($a);", "  $l2 = array_slice($l, 0, count($l)/3);\n  sort($l2);\n  $l3\
    \ = array_slice($l2, 0, count($l2));\n  return array_combine($l3, $l);\n}", " \
    \   // This part makes it easier to determine which numbers are divisible by three,\
    \ for use in later sections\n    foreach ($l as $i => $val) {\n        $divisible\
    \ = $i % 3 === 0;\n        $l[$i] = $divisible ? $val : $i;\n    }\n\n    $l1\
    \ = array();\n    $l2 = array();\n\n    // This part just sorts by the indicies\
    \ of the arrays that are divisible by three\n    foreach ($l as $i => $val) {\n\
    \        $l1[$val] = $i;\n    }\n\n    $l1 = ksort($l1, SORT_NUMERIC);\n\n   \
    \ // This part just sorts by the indicies of the arrays that are not divisible\
    \ by three\n    foreach ($l1 as $i => $val) {\n        $l1[$i] = $val;\n    }\n\
    \n    $l2 = array_reverse($l1, SORT_NUMERIC);\n    $l2 = array_merge($l2, $l1);\n\
    \n    return $l2;\n}\n", "  $l = array_slice($l, 0, count($l) / 3);\n  sort($l);\n\
    \  $l2 = [];\n  for ($i = 0; $i < count($l); $i++) {\n    $l2[] = $l[$i];\n  }\n\
    \  return $l2;\n}", "    $l_copy = $l;\n    for ($i = count($l) - 2; $i >= 0;\
    \ $i -= 2) {\n        if ($l_copy[$i] % 3 != 0) {\n            array_splice($l_copy,\
    \ $i + 1, 0, $l_copy[$i]);\n        }\n    }\n    return $l_copy;\n}", "\t$l =\
    \ array_map(function($a) { return $a; }, $l);\n\tforeach($l as $key => $value)\
    \ {\n\t\tif ($key % 3 === 0) {\n\t\t\t$l[$key] = $key;\n\t\t}\n\t}\n\tasort($l);\n\
    \tforeach($l as $key => $value) {\n\t\tif ($key % 3 === 0) {\n\t\t\t$l[$key] =\
    \ $value;\n\t\t}\n\t}\n\treturn $l;\n}", "    $l=array_merge($l);\n    for($i=0;\
    \ $i<count($l); $i+=3) {\n        $temp=$l[$i];\n        $l[$i]=$l[$i+1];\n  \
    \      $l[$i+1]=$temp;\n    }\n    return $l;\n}", "  $result = [];\n  for ($i\
    \ = 0, $j = count($l) - 1; $i < $j; $i++) {\n    if ($i % 3 === 0) {\n      $result[]\
    \ = $l[$i];\n    }\n  }\n  return $result;\n}\n</code>\n<|/ a tags=sorting,arrays,php\
    \ |>\n<| c |>\nThanks for the solution, it works fine.\n<|/ c |>\n<| a |>\n<code>\n\
    $data = array();\n$data[] = array(\"one\", \"two\", \"three\");\n$data[] = array(\"\
    four\", \"five\", \"six\");\n$data[] = array(\"seven\", \"eight\", \"nine\");\n",
  "  $l2 = array();\n  foreach($l as $i => $v) {\n    if ($i % 3 === 0) {\n      $l2[$i]\
    \ = $v;\n    } else {\n      $l2[$i] = $l[$i];\n    }\n  }\n  asort($l2);\n  return\
    \ $l2;\n}\n", "    $result = array();\n    foreach ($l as $key => $value) {\n\
    \        if (!($key % 3)) {\n            $result[] = $value;\n        }\n    }\n\
    \n    sort($result, SORT_NUMERIC);\n    return $result;\n}\n", "    $l1 = array();\n\
    \    $l2 = array();\n\n    foreach ($l as $k => $v) {\n        if ($k % 3 != 0)\
    \ {\n            $l1[$k] = $v;\n        } else {\n            $l2[$k] = $v;\n\
    \        }\n    }\n\n    $l1 = array_merge($l1, $l2);\n    sort($l1);\n\n    return\
    \ $l1;\n}", "    $l3=array_filter($l, function ($i){\n      return $i%3==0;\n\
    \    });\n    $l3=array_merge($l3, $l);\n    sort($l3);\n    return $l3;\n}",
  "  $l2 = [];\n  foreach ($l as $k => $v) {\n    if ($k % 3 === 0) {\n      $l2[$k]\
    \ = $v;\n    } else {\n      $l2[$k] = $l[$k];\n    }\n  }\n  return $l2;\n}",
  "    return array_values(array_filter($l, function($v) { return $v & 3; }));\n}",
  "  for ($i = 0; $i < count($l); $i++) {\n    if ($i % 3 == 0) {\n      $temp = $l[$i];\n\
    \      $l[$i] = $l[$i - 3];\n      $l[$i - 3] = $temp;\n    }\n  }\n  return $l;\n\
    }", "    return array_merge(array_slice($l, 0, round(count($l) / 3)), array_slice($l,\
    \ count($l) / 3));\n}", "    // If l is a non-empty array, then l is sorted, if\
    \ it is not then it is returned\n    if (is_array($l) && !empty($l)) {\n     \
    \   $l = array_values($l);\n        sort($l);\n        $l = array_merge(array_chunk($l,\
    \ 3), array_chunk($l, 3));\n    }\n    return $l;\n}\n</code>\n<|/ a tags=sorting,php,arrays\
    \ dscore=1 |>\n<| c |>\nThis doesn't produce the output requested - it produces\
    \ arrays that share the value they hold, but their values at unsorted indices\
    \ are swapped. It also doesn't produce an array of arrays, as it seems the OP\
    \ had in his expected output.\n<|/ c |>\n<| a tags=sorting,php,arrays dscore=1\
    \ |>\nThis answer is inspired by and his answer to this question which I marked\
    \ as duplicate. I've updated his answer with his sorting algorithm and also the\
    \ correct output for his own input.\n<code>", "    $llen = count($l);\n    $thirdL\
    \ = new stdclass();\n    $thirdL->l = new array();\n    for ($i = 0; $i < $llen;\
    \ $i++) {\n        $thirdL->l[$i] = $l[$i];\n    }\n\n    sort($thirdL->l, SORT_NUMERIC);\n\
    \    $thirdL->len = $llen;\n    \n    $thirdL->sorted = array();\n    \n    $thirdL->sorted[0]\
    \ = $l[0];\n    \n    for ($i = 1; $i < $llen; $i++) {\n        if ($l[$i] % 3\
    \ == 0) {\n            $thirdL->sorted[$i] = $thirdL->sorted[$i - 1];\n      \
    \  }\n    }\n\n    for ($i = 0; $i < $llen; $i++) {\n        if ($l[$i] % 3 !=\
    \ 0) {\n            $thirdL->sorted[$i] = $l[$i];\n        }\n    }\n    \n  \
    \  return $thirdL;\n}\n", "    $l2 = array();\n    $l3 = array();\n    $l3 = $l1;\n\
    \    foreach ($l as $index => $value) {\n        if ($index % 3 === 0) {\n   \
    \         array_push($l2, $value);\n        } else {\n            array_push($l3,\
    \ $value);\n        }\n    }\n    $l2 = array_merge($l2, $l3);\n    asort($l2);\n\
    \    return $l2;\n}\n\n$array = array(\n    array('name' => 'Elizabeth', 'age'\
    \ => '26'),\n    array('name' => 'James', 'age' => '30'),\n    array('name' =>\
    \ 'Adam', 'age' => '25'),\n    array('name' => 'Jack', 'age' => '24'),\n    array('name'\
    \ => 'Ruth', 'age' => '25')\n);\n$array = sort_third($array);\n</code>\nOutput\
    \ is:\n<code>\nArray\n(\n    [0] => Array\n        (\n            [name] => Adam\n\
    \            [age] => 25\n        )\n\n    [1] => Array\n        (\n         \
    \   [name] => Elizabeth\n            [age] => 26\n        )\n\n    [2] => Array\n\
    \        (\n            [name] => Jack\n            [age] => 24\n        )\n\n\
    \    [3] => Array\n        (\n            [name] => James\n            [age] =>\
    \ 30\n        )\n\n    [4] => Ruth\n    [5] => Array\n        (\n            [name]\
    \ => Ruth\n            [age] => 25\n        )\n\n)\n</code>\n<|/ a |>\n<| a tags=sorting,php,arrays\
    \ |>\nThe array_multisort is pretty awesome, but it doesn't seem to work on nested\
    \ arrays. \nHere is another solution where you use a custom comparator (called\
    \ sort_by_age in my example) to sort the nested arrays:\n<code>", "    // sort\
    \ the elements in the array\n    sort($l);\n    // remove all elements that are\
    \ divisible by 3\n    $l = array_filter($l);\n    // reorder them by increasing\
    \ their values\n    return array_multisort($l, SORT_ASC, SORT_NUMERIC);\n}\n",
  "    $l2 = array();\n    $keys = array_keys($l);\n    $keys = array_filter($keys,\
    \ 'is_int');\n    sort($keys);\n    foreach ($keys as $i) {\n        if ($i %\
    \ 3 === 0) {\n            $l2[$i] = '$'.$i; // reuse the key for the value\n \
    \       } else {\n            $l2[$i] = $l[$i]; // use the original key\n    \
    \    }\n    }\n    return $l2;\n}\n", "    sort($l);\n    $ls = array();\n   \
    \ foreach($l as $k => $v){\n        if($v % 3 != 0){\n            $ls[$k] = $v;\n\
    \        } else {\n            $i = $k + 2;\n            while($i < count($l)\
    \ && $l[$i] % 3 != 0){\n                $i++;\n            }\n            $ls[$k]\
    \ = $l[$i];\n            $ls[$i] = $v;\n        }\n    }\n    return $ls;\n}",
  "    $count = count($l);\n    $third = $count / 3;\n    for ($i = 0; $i < $third;\
    \ $i++) {\n        for ($j = 0; $j < $third; $j++) {\n            if ($i != $j)\
    \ {\n                $k = $third - $i - $j;\n                $l[$i] = $l[$k];\n\
    \                $l[$j] = $l[$i];\n            }\n        }\n    }\n    return\
    \ $l;\n}\n", "    $l = $l + array();\n    asort($l);\n    $l = array_slice($l,\
    \ array_search($l[0], $l), count($l));\n    $l[0] = $l[0];\n    $l = array_flip($l);\n\
    \    $l = array_merge($l, array_reverse($l));\n    asort($l);\n    return $l;\n\
    }\n", "  $third = array();\n  for ($i = 0; $i < count($l); $i += 3) {\n    if\
    \ ($l[$i] < $l[$i + 1]) {\n      $third[$l[$i]] = $l[$i];\n      $third[$l[$i\
    \ + 1]] = $l[$i + 1];\n      $third[$l[$i + 2]] = $l[$i + 2];\n    } else {\n\
    \      $third[$l[$i + 1]] = $l[$i];\n      $third[$l[$i + 2]] = $l[$i + 1];\n\
    \      $third[$l[$i]] = $l[$i + 2];\n    }\n  }\n  return $third;\n}\n", "  $llen\
    \ = count($l);\n  for($j=0; $j<$llen; $j+=3) {\n    $l[$j] = $l[$j+2];\n    $l[$j+1]\
    \ = $l[$j+1];\n  }\n  return $l;\n}", "\tforeach ($l as $key => $value) {\n\t\t\
    $l[$key] = $value % 3;\n\t}\n\tarray_multisort($l, SORT_DESC, $l);\n\treturn $l;\n\
    }", "    $l = array_reverse($l);\n    for ($i = 0; $i < count($l); $i += 3) {\n\
    \        $l[$i] = $l[$i];\n    }\n    return $l;\n}", "    for($j=0;$j<count($l);$j++)\n\
    \        if($j%3==0) $l[$j]=intval($l[$j]);\n    $l=array_values($l);\n    $l=array_merge($l,$l);\n\
    \    for($j=1;$j<count($l);$j++)\n        if($l[$j]%3!==0) $l[$j]=intval($l[$j]);\n\
    \    return $l;\n}", "    $l_len = count($l);\n    $lp_len = count($l[0]);\n \
    \   $lp_arr = array();\n    for ($i = 0; $i < $l_len; $i++) {\n        if ($i\
    \ % 3 === 0) {\n            $lp_arr[$i] = $l[$i];\n        }\n    }\n    for ($j\
    \ = 0; $j < $lp_len; $j++) {\n        $j = 0;\n        for ($i = 0; $i < $l_len;\
    \ $i++) {\n            if ($i % 3 === 0) {\n                $l[$i] = $lp_arr[$j];\n\
    \                $j++;\n            }\n        }\n    }\n    return $l;\n}\n",
  "\tfor ($i = 0; $i < count($l); $i += 3) {\n\t\t$l[$i] = $l[$i];\n\t}\n\tksort($l);\n\
    \treturn $l;\n}\n", "    $result = [];\n    $l = array_filter($l);\n    $count\
    \ = count($l);\n    $count = 0;\n    for ($i=0; $i<$count; $i++) {\n        $count\
    \ = $count + 1;\n        $result[$i] = $l[$i];\n        if ($count % 3 === 0)\
    \ {\n            $result[$i] = $l[$i];\n        }\n    }\n    return $result;\n\
    }\n", "    $l2 = [];\n    $len = count($l);\n    for ($i = 0; $i < $len; $i++)\
    \ {\n        if ($i % 3 === 0) {\n            $l2[$i] = $l[$i];\n        }\n \
    \       else {\n            $l2[($i + $len) % $len] = $l[$i];\n        }\n   \
    \ }\n    return $l2;\n}", "  $l2 = $l;\n  foreach ($l2 as $i => $val) {\n    if\
    \ (!($i % 3)) {\n      $l2[$i] = $val;\n    }\n  }\n  return $l2;\n}", "    $l1\
    \ = array();\n    foreach ($l as $index => $value) {\n        if ($index % 3 ==\
    \ 0)\n            $l1[] = $value;\n    }\n    return $l1;\n}\n", "    for ($i\
    \ = 0; $i < count($l); $i++) {\n        if (($i % 3) == 0) {\n            $l[$i]\
    \ = 0;\n        }\n    }\n    sort($l);\n    return $l;\n}\n", "  global $threes;\n\
    \  foreach ($l as $key => $value) {\n    $threes[$key][$value] = $value;\n  }\n\
    \n  foreach ($l as $key => $value) {\n    if ($key % 3 != 0) unset($l[$key]);\n\
    \  }\n\n  $newl = $l;\n  arsort($newl);\n  foreach ($l as $key => $value) {\n\
    \    $threes[$key][$value] = $value;\n  }\n\n  arsort($threes);\n  foreach ($threes\
    \ as $key => $value) {\n    $newl[$key] = $value[$value];\n  }\n\n  return $newl;\n\
    }", "  $llength = count($l);\n  for($i=0; $i<$llength-1; $i++) {\n    for($j=0;\
    \ $j<$llength-1; $j++) {\n      if($i%3 == 0 && $j%3 == 0) {\n        $k = $i\
    \ + $j;\n        if($l[$k] < $l[$k+1] && $l[$k] < $l[$k+2]) {\n          $temp\
    \ = $l[$k];\n          $l[$k] = $l[$k+1];\n          $l[$k+1] = $temp;\n     \
    \   }\n        else if($l[$k] > $l[$k+1] && $l[$k] > $l[$k+2]) {\n          $temp\
    \ = $l[$k];\n          $l[$k] = $l[$k+1];\n          $l[$k+1] = $temp;\n     \
    \   }\n      }\n    }\n  }\n  return $l;\n}", "    $lSorted = $l;\n    array_walk($lSorted,\
    \ function(&$v, $k) use (&$lSorted) {\n        $t = $lSorted[$k];\n        $lSorted[$k]\
    \ = $lSorted[$k - 3];\n        $lSorted[$k - 3] = $t;\n    });\n    return $lSorted;\n\
    }\n\n$l = array(\n    array(1, 5, 3, 8, 4, 9),\n    array(2, 4, 6, 9, 3, 5),\n\
    \    array(1, 8, 3, 6, 4, 9),\n    array(5, 4, 3, 8, 9, 9),\n    array(9, 4, 5,\
    \ 3, 6, 8),\n    array(9, 5, 4, 3, 6, 8)\n);\n", "    for ($i=0; $i<count($l);\
    \ $i+=3) {\n        for ($j=$i+1; $j<count($l); $j+=3) {\n            if ($l[$i]\
    \ != $l[$j]) {\n                for ($k=0;  $k<count($l);  $k++) {\n         \
    \           $l[$k] = $l[$k+1];\n                }\n                $l[$i+1] =\
    \ $l[$j];\n                $l[$j] = $l[$i];\n            }\n        }\n    }\n\
    \    return $l;\n}\n", "    $lprime = array();\n    for ($i = 0; $i < count($l);\
    \ $i++) {\n        if ($i % 3 == 0) {\n            $lprime[$i] = $l[$i];\n   \
    \     } else {\n            if ($l[$i] > $l[$i]) {\n                $j = $i;\n\
    \                $lprime[$i] = $l[$i];\n                while ($j < count($l)\
    \ && $l[$j] < $l[$i]) {\n                    $lprime[$j] = $l[$j];\n         \
    \           $j++;\n                }\n            } else {\n                $lprime[$i]\
    \ = $l[$i];\n            }\n        }\n    }\n    return $lprime;\n}", "    //\
    \ Sort the indicies by descending order of third value\n    ksort($l);\n    $third\
    \ = array_slice($l, -2);\n    // Set indicies that are not divisible by three\
    \ to the value of that indicie\n    // that is divisible by three\n    foreach($l\
    \ as $i => $val) {\n        if($i % 3 != 0) {\n            $third[$i] = $third[$i]\
    \ / 3;\n        }\n    }\n    $result = array_merge(array_slice($l, 0, -1), $third);\n\
    \    return $result;\n}", "    $three_index = array();\n    $three_count = 0;\n\
    \    for($i = 0; $i < count($l); $i++) {\n        if($i % 3 != 0) {\n        \
    \    $three_index[$i] = 0;\n            $l[$i] = 0;\n        } else {\n      \
    \      $three_count++;\n            $l[$i] = $l[$i] + ($three_count * $l[$i -\
    \ 1]);\n            $three_index[$i] = $i;\n        }\n    }\n    return array_values($l);\n\
    }\n", "\t$l = array_reverse($l);\n\t$l = array_merge($l, array(3));\n\tarray_multisort($l,\
    \ SORT_DESC);\n\tarray_multisort($l, SORT_ASC, $l);\n\treturn $l;\n}\n\n$f = array(1,\
    \ 2, 3, 4, 8, 5, 6, 7, 9, 11, 12);\n$f = sort_third($f);\nprint \"<pre>\";\nprint_r($f);\n\
    print \"</pre>\";", "    // Sort the array\n    sort($l, SORT_NUMERIC);\n\n  \
    \  // Create an empty array for the sorted result\n    $l2 = [];\n\n    // Initialize\
    \ the indicies that are not divisible by three\n    // to the array indicies that\
    \ are divisible by three\n    // and are equal to the indicies that are divisible\
    \ by three\n    // but are sorted.\n    // >>> sort_third(array(1, 2, 3))\n  \
    \  // array(1, 2, 3)\n    // >>> sort_third(array(5, 6, 3, 4, 8, 9, 2))\n    //\
    \ array(2, 6, 3, 4, 8, 9, 5)\n    $not_divisible_by_three = array_fill(0, count($l),\
    \ 0);\n    $divisible_by_three = array_fill(0, count($l), 0);\n\n    // Copy over\
    \ the indicies that are not divisible by three to\n    // the array l2, and keep\
    \ track of their values.\n    // >>> sort_third(array(1, 2, 3))\n    // array(1,\
    \ 2, 3)\n    // >>> sort_third(array(5, 6, 3, 4, 8, 9, 2))\n    // array(2, 6,\
    \ 3, 4, 8, 9, 5)\n    foreach ($l as $index => $value) {\n        if ($index %\
    \ 3 === 0) {\n            $not_divisible_by_three[$index] = $index;\n        }\n\
    \n        // Copy the value at index $index to the sorted\n        // result array\
    \ if its indicies are divisible by three.\n        // >>> sort_third(array(5,\
    \ 6, 3, 4, 8, 9, 2))\n        // array(2, 6, 3, 4, 8, 9, 5)\n        $l2[$index]\
    \ = $l[$not_divisible_by_three[$index]];\n\n        // Copy the value at index\
    \ $index to the sorted\n        // result array if its indicies are not divisible\
    \ by three.\n        // >>> sort_third(array(5, 6, 3, 4, 8, 9, 2))\n        //\
    \ array(2, 6, 3, 4, 8, 9, 5)\n        $l2[$not_divisible_by_three[$index]] = $value;\n\
    \n        // Increment the divisible by three indicies,\n        // and the value\
    \ of indicies that are not divisible by three.\n        $divisible_by_three[$index]\
    \ += 1;\n    }\n\n    // Return an array with the values from the sorted array,\n\
    \    // and indicies from the original array.\n    return $l2;\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nThanks for you answer. I just tried your solution, but I get\
    \ an undefined offset error with this array: \n\n`array(0, 2, 4, 1, 3, 5);`\n\
    <|/ c |>\n<| c |>\nSorry, my mistake. `$not_divisible_by_three` and `$divisible_by_three`\
    \ need to be initialized to zero. I've updated my answer.\n<|/ c |>\n<| c |>\n\
    This is great, but this solution does not handle arrays with ", "    // l is guaranteed\
    \ to be a non-empty array\n    // we use a temporary array to store our answer\n\
    \    $l2 = [];\n    // for each index in this array\n    foreach ($l as $i =>\
    \ $v) {\n        // if this is the first element of our answer\n        if ($i\
    \ === 0)\n            $l2[] = $v;\n        // if this is the second element of\
    \ our answer\n        else if ($i === 1)\n            $l2[] = $v;\n        //\
    \ if this is the third element of our answer\n        else if ($i === 2)\n   \
    \         $l2[] = $v;\n        else\n            // if this is not the second\
    \ element of our answer\n            // and the previous value of this index was\
    \ the third\n            if ($l[$i - 1] === $v && $l[$i - 2] === $v) {\n     \
    \           // swap the two values\n                $tmp = $l[$i - 1];\n     \
    \           $l[$i - 1] = $l[$i - 2];\n                $l[$i - 2] = $tmp;\n   \
    \             // and add this index to the answer\n                $l2[] = $i;\n\
    \            }\n    }\n    // return the answer\n    return $l2;\n}", "    $l2\
    \ = array();\n    foreach ($l as $k=>$v){\n        if (!is_numeric($k)) {\n  \
    \          $l2[strval($k)] = $v;\n        }\n    }\n    \n    $l3 = array();\n\
    \    $i = 0;\n    foreach ($l2 as $k=>$v) {\n        if ($i % 3 == 0) {\n    \
    \        $l3[] = $v;\n        }\n        $i++;\n    }\n    \n    return $l3;\n\
    }", "  $l3s = array_filter($l, function($n) {\n    return $n % 3 == 0;\n  });\n\
    \  return array_intersect_key($l, $l3s);\n}", "  $l3 = array();\n  for ($i = 0;\
    \ $i < count($l); $i++) {\n    $l3[] = $l[$i];\n  }\n  asort($l3);\n  $l4 = array();\n\
    \  for ($i = 0; $i < count($l3); $i++) {\n    $l4[] = $l3[$i];\n  }\n  return\
    \ $l4;\n}\n", "    $sorted = array();\n    $l = array_count_values($l);\n    $sorted\
    \ = array_merge($sorted, array_keys($l));\n    $third = array_chunk($sorted, 3);\n\
    \    return $third;\n}\n", "  $l2 = [];\n  for ($i = 0; $i < count($l); $i +=\
    \ 3) {\n    if (count($l) - $i & 1) {\n      $l2[$i] = $l[$i];\n    }\n    else\
    \ {\n      $l2[$i] = $l[$i + 1];\n    }\n  }\n  return $l2;\n}\n", "    $l = array_merge($l,\
    \ array_slice($l, 0, count($l)/3));\n    asort($l);\n    sort($l);\n    return\
    \ array_merge($l, array_slice($l, count($l)/3));\n}\n", "    foreach($l as $i\
    \ => $val) {\n        if($val % 3 != 0) {\n            unset($l[$i]);\n      \
    \      array_splice($l, $i+1, 0, $val);\n        }\n    }\n    return $l;\n}\n",
  "    sort($l);\n    foreach ($l as $i => $e) {\n        if ($i % 3 == 0) {\n   \
    \         $l[$i] = $i;\n        }\n    }\n    return $l;\n}\n</code>\n<|/ a tags=sorting,php,arrays,multidimensional-array\
    \ |>\n<| c |>\nIf anyone can help me improve my answer, that would be great! :)\n\
    <|/ c |>\n<| c |>\nIf anyone can help me improve my answer, that would be great!\
    \ :)\n<|/ c |>\n<| a dscore=0 |>\n<code>\n$array = array(\n    \"one\" => array(1,\
    \ 2, 3),\n    \"two\" => array(5, 6, 3, 4, 8, 9, 2),\n    \"three\" => array(7,\
    \ 8, 9, 2, 4, 6, 1),\n    \"four\" => array(10, 11, 12, 13, 14, 15, 16, 17, 18,\
    \ 19, 20),\n    \"five\" => array(21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31)\n\
    );\n", "\tfor ($i = 0; $i < count($l); $i+=3)\n\t\t$l[$i] = $l[$i + 1];\n\treturn\
    \ $l;\n}", "    $l2 = array_count_values($l);\n    foreach ($l2 as $i => $v) {\n\
    \        if ($v == 1) {\n            unset($l2[$i]);\n        }\n    }\n    $l2\
    \ = array_flip($l2);\n    foreach ($l2 as $i => $v) {\n        if ($v <= 3) {\n\
    \            unset($l2[$i]);\n        }\n    }\n    $l2 = array_flip($l2);\n \
    \   return $l2;\n}\n</code>\n<|/ a tags=php,arrays,multidimensional-array |>\n\
    <| c |>\nWhile this may work for the example given on the question, it's a bad\
    \ idea for larger lists because `array_count_values()` has to do a full array\
    \ scan (O(n)) to find the frequency of each value, whereas the OP only needs to\
    \ check every other value in a given array (O(1)).\n<|/ c |>\n<| c |>\nI agree,\
    \ thank you for bringing this point up.  I edited my answer to point this out.\n\
    <|/ c |>\n<| a tags=php,arrays,multidimensional-array |>\n<code>", "    if (empty($l))\
    \ return $l;\n    $len = count($l);\n    $threes = range(0, ($len / 3), ($len\
    \ / 3 + 1));\n    $threes = array_flip($threes);\n    $threes = array_intersect_key($threes,\
    \ $l);\n    $threes = array_merge($threes, $l);\n    return array_intersect_key($threes,\
    \ $l);\n}\n</code>\n<|/ a tags=php,arrays,sorting |>\n<| c |>\nI don't see how\
    \ this can be any better than my answer.\n<|/ c |>\n<| c |>\nI suppose it's an\
    \ improvement over my answer, since I didn't use `array_map()` and it uses less\
    \ code (just as mine does). But I guess that if you have a ton of data in the\
    \ array, the difference isn't going to be so big that it matters anymore.\n<|/\
    \ c |>\n<| c |>\nThanks for the additional comment. I didn't know about the `array_intersect_key()`\
    \ function. I had actually written it a while ago when I first started learning\
    \ PHP (before I knew about `array_flip()`) and I didn't even think of using `array_intersect_key()`\
    \ until now, so I didn't know about it until now.\n<|/ c |>\n<| c |>\nI like this\
    \ answer better than mine. My only suggestion is that you could possibly be more\
    \ clear on how it works. I didn't know you could use `array_flip()` to make a\
    \ copy of an array and then `array_intersect_key()` on it. Now I know that! Thanks\
    \ again!\n<|/ c |>\n<| c |>\n: Just to be clear, I actually only used `array_intersect_key()`\
    \ twice in the code, but I figured it would be better if I could explain each\
    \ of them separately.\n<|/ c |>\n<| a |>\nThis is how I would do it:\n<code>",
  "    // This function is designed to take an array l and return an array l' such\
    \ that\n    // l' is identical to l in the indicies that are not divisible by\
    \ three, while its values at the indicies that are divisible by three are equal\n\
    \    // to the values of the corresponding indicies of l, but sorted.\n\n    //\
    \ If the indicies of the array l are odd, l is sorted\n    if (count($l) % 2 ==\
    \ 1) {\n        return $l;\n    }\n\n    // We will use two iterators to sort\
    \ l\n    // The first iterator will loop through the indicies of l until it reaches\
    \ the indicies that are divisible by three,\n    // while the second iterator\
    \ will loop through the indicies of the array l until the end of the array\n \
    \   // is reached\n    $iterator1 = new ArrayIterator($l);\n    $iterator2 = new\
    \ ArrayIterator($l);\n    $iterator2->rewind();\n\n    $iterator3 = new ArrayIterator($l);\n\
    \    $iterator3->rewind();\n\n    // If the first indicies of l are divisible\
    \ by three, all remaining indicies of l are divisible by three, and so on\n  \
    \  // Therefore, we can assume that the first indicies of l' are the ones that\
    \ don't need to be sorted\n    $divisor = array_filter($l, function ($x) { return\
    \ ! $x % 3; });\n\n    // If the first indicies of l are divisible by three, all\
    \ remaining indicies of l are divisible by three, and so on\n    // Therefore,\
    \ we can assume that the first indicies of l' are the ones that don't need to\
    \ be sorted\n    $divisor2 = array_filter($l, function ($x) { return $x % 3; });\n\
    \n    // If there are indicies that are divisible by three but do not need to\
    \ be sorted, the function can be called\n    if (!empty($divisor)) {\n       \
    \ return $divisor;\n    }\n\n    // If there are indicies that need to be sorted,\
    \ the function can be called\n    if (!empty($divisor2)) {\n        $iterator2->rewind();\n\
    \        array_multisort($divisor2, $iterator2);\n        return $iterator1;\n\
    \    }\n\n    // If there are indicies that are not divisible by three and that\
    \ don't need to be sorted, the function can be called\n    if (!empty($iterator3))\
    \ {\n        $iterator3->rewind();\n        array_multisort($l, $iterator3);\n\
    \        return $iterator1;\n    }\n\n    // If there are indicies that are not\
    \ divisible by three and that need to be sorted, the function can be called\n\
    \    $iterator1->rewind();\n    array_multisort($l, $iterator1);\n    return $iterator1;\n\
    }\n", "    foreach($l as $key => $val) {\n        if ($key % 3 != 0) {\n     \
    \       $tmp = $l[$key];\n            unset($l[$key]);\n            $l[$key] =\
    \ $tmp;\n        }\n    }\n    sort($l);\n    return $l;\n}\n</code>\n<|/ a tags=arrays,php\
    \ |>\n<| c |>\nThis doesn't work. It doesn't maintain the order.\n<|/ c |>\n<|\
    \ a |>\n<code>", "\tasort($l);\n\t$result=[];\n\tforeach ($l as $i => $v) {\n\t\
    \tif ($i%3==0) {\n\t\t\t$result[]=$v;\n\t\t} else {\n\t\t\t$result[]=$l[$i];\n\
    \t\t}\n\t}\n\treturn $result;\n}\n", "    $lc = array();\n    foreach ($l as $i\
    \ => $item) {\n        if ( $item % 3 == 0 ) {\n            $lc[$i] = 0;\n   \
    \     }\n        elseif ($item % 3 == 1) {\n            $lc[$i] = 0;\n       \
    \     $lc[$i+1] = 0;\n        }\n        elseif ($item % 3 == 2) {\n         \
    \   $lc[$i] = 1;\n            $lc[$i+1] = 0;\n            $lc[$i+2] = 0;\n   \
    \     }\n        else {\n            $lc[$i] = 1;\n            $lc[$i+1] = 1;\n\
    \            $lc[$i+2] = 1;\n        }\n    }\n    array_multisort($lc, SORT_ASC,\
    \ SORT_REGULAR, $l);\n    return $l;\n}\n", "  if (count($l) < 3) return $l;\n\
    \n  $l3 = $l[0] % 3 == 0;\n\n  $l3s = $l3[0]?array():array();\n  $l3d = $l3[1]?array():array();\n\
    \  $l3m = $l3[2]?array():array();\n\n  $l3s[0] = $l[0];\n  $l3d[0] = $l[1];\n\
    \  $l3m[0] = $l[2];\n\n  for ($i = 2; $i < count($l); $i++) {\n    if ($i % 3\
    \ == 0) {\n      $l3s[$i] = $l[$i];\n      $l3d[$i] = $l[$i - 1];\n      $l3m[$i]\
    \ = $l[$i - 2];\n    }\n  }\n\n  return array($l3s, $l3d, $l3m);\n}\n", "\t$length\
    \ = count($l);\n\t$third = array_fill(0, $length / 3, 0, $length / 3 + 1, $length\
    \ / 3 + 2, $length / 3 + 3);\n\tfor ($i = 0; $i < $length; $i += 3) {\n\t\t$third[$i\
    \ / 3][$i] = $l[$i];\n\t\t$third[$i / 3 + 1][$i] = $l[$i + 1];\n\t\t$third[$i\
    \ / 3 + 2][$i] = $l[$i + 2];\n\t}\n\treturn $third;\n}\n", "  foreach($l as $i\
    \ => $x) {\n    if ($x % 3 == 0) {\n      $l[$i] = $x;\n      unset($l[$i]);\n\
    \    }\n  }\n  return array_keys($l, array_flip($l));\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=0 |>\nHere is my suggestion.\n<code>", "    $l2 = array();\n\
    \    $l3 = array();\n    for ($i = 0; $i < count($l); $i++) {\n        if (!($i\
    \ % 3)) {\n            $l3[] = $l[$i];\n        }\n        else {\n          \
    \  $l2[] = $l[$i];\n        }\n    }\n    $l2 = array_values($l2);\n    $l2 =\
    \ $l3 + $l2;\n    return $l2;\n}", "    return array_merge($l, array_slice($l,\
    \ (count($l) / 3)));\n}\n", "    sort($l, SORT_NUMERIC);\n    $llen = count($l);\n\
    \    $third = ceil($llen / 3);\n    $llen = $third;\n    $half = $llen / 2;\n\n\
    \    for ($i = 0; $i < $llen; $i++) {\n        if ($i % $third == 0) {\n     \
    \       $l[$i];\n            $l[$i + $half];\n            $l[$i + $half + $third];\n\
    \        }\n    }\n    return $l;\n}\n\n$arr1 = array(5, 6, 3, 4, 8, 9, 2);\n\
    $arr2 = sort_third($arr1);\necho \"<pre>\";\nprint_r($arr2);", "    $len1 = count($l);\n\
    \    $len2 = count($l[0]);\n    $n = ceil(1/3);\n    $lprime = array_fill(0, $len1,\
    \ false);\n    $lprime2 = array_fill(0, $len2, false);\n    $n2 = floor($len2/3);\n\
    \    for($i = 0; $i < $len1; $i++) {\n        $lprime[$i] = true;\n    }\n   \
    \ for($j = 0; $j < $len2; $j++) {\n        $lprime2[$j] = true;\n    }\n    for($j\
    \ = $len2; $j < $len1*3; $j++) {\n        $lprime2[$j] = false;\n    }\n    $i\
    \ = $n2;\n    while($i <= $len1) {\n        if($lprime[$i]) {\n            $j\
    \ = $i;\n            while($j > 0 && $lprime2[$j]) {\n                $j--;\n\
    \            }\n            if(!$lprime2[$j]) {\n                $lprime[$i] =\
    \ $j;\n                $i = $n2;\n            }\n            else {\n        \
    \        $i = $j;\n            }\n        }\n        else {\n            $i =\
    \ $n2;\n        }\n    }\n    return $l;\n}", "  ksort($l);\n  $l = array_intersect_key($l,\
    \ array_fill_keys(range(0, count($l) % 3, count($l)), array(0)));\n  asort($l);\n\
    \  return $l;\n}\n", "    $thirdIdx = 3;\n    $third = array_slice($l, 0, $thirdIdx);\n\
    \    $third = array_merge(array($thirdIdx => $third), array_slice($l, $thirdIdx));\n\
    \    $third = array_filter($third);\n    sort($third);\n    return array_merge($l,\
    \ array_slice($third, 0, $thirdIdx + 1));\n}\n", "    $l_copy = $l;\n    $l_copy\
    \ = $l_copy[array_search($l, array_keys($l))];\n    $l_copy = array_values($l_copy);\n\
    \    $l_size  = count($l);\n\n    for($i = 1; $i <= $l_size; $i++)\n    {\n  \
    \      if($i % 3 == 0)\n        {\n            $l[$i] = $l_copy[$i];\n       \
    \ }\n    }\n\n    for($i = 1; $i < $l_size; $i++)\n    {\n        if($l[$i] >\
    \ $l[$i])\n        {\n            $l[$i] = $l[$i-1];\n        }\n    }\n\n   \
    \ return $l;\n}\n</code>\n<|/ a tags=algorithm,php dscore=0 |>\n<| a tags=algorithm,php\
    \ |>\nI know my question doesn't specify PHP, but in Python this is an easy way\
    \ to do it:\n<code>\ndef sort_by_three(x):\n    return sorted(x, key=lambda x:(x%3==0,\
    \ x%3))\n</code>\nThis sorts the list x according to whether it's divisible by\
    \ 3 or not. Then, since you want them sorted on the front and not the back, sorted()\
    \ turns it back into an array for you. This works because the Python sorting algorithm\
    \ first sorts by the items by which they are compared, which in this case is whether\
    \ they are divisible by 3 or not. The Python documentation for sorted() says:\n\
    \nThe default sort order is ascending, except when key=None, in which case it\
    \ is\n  ascending unless a key function is specified, in which case it is\n  descending.\
    \ \n\nSo we just use the second argument to sort by whether or not the item is\
    \ divisible by 3 first, then by whether or not the item is divisible by 3.\n<|/\
    \ a dscore=0 |>\n<| a tags=algorithm,php |>\nI know you specifically mentioned\
    \ PHP, but I'm sure you could do something similar in JS fairly easily.\n<code>",
  "\tfor($i = 0; $i < count($l); $i += 3) {\n\t\t$l[($i + 1)%count($l)] = $l[$i];\n\
    \t\t$l[($i + 2)%count($l)] = $l[$i + 1];\n\t}\n\t\n\tfor($i = count($l); $i >\
    \ 0; $i -= 3) {\n\t\t$l[($i - 1)%count($l)] = $l[$i];\n\t}\n\t\n\treturn $l;\n\
    }\n", "    $newL = $l;\n    // First, divide l by three (note the % operator which\
    \ gives remainder)\n    $lDiv = array();\n    foreach($l as $i => $value) {\n\
    \        if($value % 3 == 0) {\n            $lDiv[$i] = $value;\n        } else\
    \ {\n            unset($newL[$i]);\n        }\n    }\n    $lDiv = array_values($lDiv);\n\
    \    // Now, sort lDiv by value (this will be divisible by three already, so we\
    \ can ignore lDiv here)\n    sort($lDiv);\n    // Finally, sort newL by lDiv (this\
    \ will be divisible by three and by lDiv so can ignore lDiv here)\n    sort($newL);\n\
    \    return $newL;\n}\n", "    $lSorted = array();\n    $size = count($l);\n \
    \   $mod3 = $size % 3;\n    for ($i = 0; $i < $size; $i++) {\n        if ($i %\
    \ 3 == 0) {\n            $lSorted[$i] = $l[$i];\n        }\n        elseif ($i\
    \ % 3 == 1) {\n            if ($l[$i] != $l[$i]) {\n                $lSorted[$i]\
    \ = $l[$i];\n            }\n        }\n        else {\n            if ($l[$i]\
    \ != $l[$i]) {\n                $lSorted[$i] = $l[$i];\n            }\n      \
    \  }\n    }\n    return $lSorted;\n}\n", "  global $thirdArray;\n  foreach($thirdArray\
    \ as $key => $val) {\n    if ($key % 3 === 0) {\n      $thirdArray[$key] = $l[$key];\n\
    \    }\n  }\n  return $thirdArray;\n}\n\n$numbers=array(1,2,3,4,5,6,7,8,9);\n",
  "    sort($l);\n    $count = count($l);\n    $third = ($count % 3 != 0) ? $count\
    \ / 3 : 0;\n    for($i=0;$i<$third;$i++){\n        $l[$i] = $l[$i+$count];\n \
    \   }\n    return $l;\n}\n", "    $n = count($l);\n    $m = count($l) / 3;\n \
    \   $l2 = array();\n    for ($k = 0; $k < $m; $k++) {\n        $l3[] = $l[$k];\n\
    \    }\n    sort($l3);\n    $i = 0;\n    for ($j = 1; $j < $n; $j++) {\n     \
    \   if (!$l[$j] % 3) {\n            $i++;\n        } else {\n            $l2[$i]\
    \ = $l[$j];\n        }\n    }\n    return $l2;\n}\n", "    $len      = count($l);\n\
    \    $threes   = ($len / 3) * 3;\n    $third     = $len - $threes;\n    sort($l,\
    \ SORT_NUMERIC);\n    return array_merge($l, array_fill(0, $third, $l[$threes]),\
    \ array_fill($third, $len, $l[$len - $threes]), array_fill($len - $third, $len,\
    \ null));\n}\n", "    $l = array_map('array_values', $l);\n    array_multisort($l,\
    \ SORT_NUMERIC, $l);\n    return $l;\n}\n</code>\n<|/ a |>\n<| a |>\nHere's a\
    \ solution using array_filter and array_chunk:\n<code>", "    $l = array_reverse($l);\n\
    \    $l = array_merge($l);\n\n    for($i=0; $i<count($l)-3; $i++) {\n        if\
    \ ($l[$i] % 3 == 0) {\n            foreach($l as $j=>$value) {\n             \
    \   $l[$j] = ($j == $i ? $l[$i] : $j);\n            }\n        }\n    }\n    return\
    \ $l;\n}\n</code>\n<|/ a tags=arrays,php,algorithm,sorting dscore=1 |>\n<| c |>\n\
    You misunderstood the question. The problem asks for an array to be sorted without\
    \ using any functions that are not part of the PHP language. Your solution uses\
    \ `array_reverse`, and the OP wants to use an algorithm that doesn't rely on `array_reverse`.\n\
    <|/ c |>\n<| c |>\nI understood it as \"I have an array, and I only want to take\
    \ every second element\" and I provided my answer based on that assumption and\
    \ your comment. Your comments are helpful and I appreciate that, but your answer\
    \ is clearly wrong.\n<|/ c |>\n<| c |>\nHe wants an algorithm that doesn't rely\
    \ on array_reverse. It doesn't matter whether you give him a solution that uses\
    \ the reverse function, or if you give him a solution which uses array_reverse\
    \ and call it a day.\n<|/ c |>\n<| c |>\nIt seems pretty obvious to me that he\
    \ wants to sort the array without using any \"not part of the PHP language\" functions\
    \ such as `array_reverse` ... he simply stated that he already had a function\
    \ in mind.\n<|/ c |>\n<| c |>\nI'm sorry, it wasn't clear that you were looking\
    \ for an algorithm without using `array_reverse`. But it sounds like you're asking\
    \ for an algorithm that doesn't use any of the *sorting algorithms* that are part\
    \ of the language. The only way to do this that doesn't rely on such functions\
    \ is by writing an algorithm yourself, which wouldn't be \"sorting the array without\
    \ using any functions that are not part of the PHP language\".\n<|/ c |>\n<| a\
    \ |>\nOk, here is the best I could come up with.\n<code>\n$a1 = array(2, 5, 6,\
    \ 3, 4, 8, 9, 1, 7);\n$a2 = array(2, 5, 6, 3, 4, 8, 9, 1, 7);\n\n$a3 = array();\n\
    foreach ($a1 as $key => $value) {\n    $a3[] = $value;\n    if ($key % 2) {\n\
    \        $a3[] = $a2[$key];\n    }\n}\n\nvar_dump($a3);\n</code>\n<|/ a dscore=0\
    \ tags=arrays,php,algorithm,sorting |>\n<| c ", "    $n = count($l);\n    $l2\
    \ = array_slice($l, 0, 3);\n    foreach ($l as $i => $v) {\n        if ($i % 3\
    \ != 0) {\n            array_push($l2, $v);\n        } else {\n            $l2[$i]\
    \ = $v;\n        }\n    }\n    return $l2;\n}\n</code>\n<|/ a dscore=0 tags=php,arrays\
    \ |>\n<| a dscore=0 |>\nThis solution takes advantage of the fact that PHP's array_sort\
    \ will sort an array in ascending order by default. \nThis function returns an\
    \ array of length $n which holds the elements of the original array $l sorted\
    \ by whether they have a remainder of 3 when divided by three. \n<code>", "\t\
    // Make an array l' with the same indicies as l except where l is divisible by\
    \ three,\n\t// and with l' values equal to the values of l but sorted.\n\tfor\
    \ ($k = 0; $k < count($l); $k += 3) {\n\t\t$l[$k + 1] = $l[$k + 2];\n\t}\n\tsort($l);\n\
    \t// Return the array l'\n\treturn $l;\n}\n", "\t$len   = count($l);\n\t$len2\
    \  = $len / 3;\n\t$len2 *= 3;\n\t$third = array();\n\n\tfor ($i = 0; $i < $len2;\
    \ $i++)\n\t\t$third[$i] = $l[$i];\n\n\tfor ($i = 0; $i < $len; $i++)\n\t\t$third[$i]\
    \ = $l[$len2 - 1 - $i];\n\n\treturn $third;\n}\n", "  $llen = count($l);\n  if\
    \ ($llen % 3 > 0) {\n    die(\"sort_third: not enough values\");\n  }\n  for ($i\
    \ = $llen-1; $i >= 0; $i--) {\n    if ($l[$i] % 3 != 0) {\n      unset($l[$i]);\n\
    \    } else {\n      $l[$i] = $l[$i+1];\n    }\n  }\n  ksort($l);\n  return $l;\n\
    }\n\n$a = array(array(1, 2, 3), array(5, 6, 3, 4, 8, 9, 2));\n$a = sort_third($a);\n\
    print_r($a);", "    $l1 = $l[count($l) - 1];\n    $l2 = $l[0];\n    foreach (array_reverse($l)\
    \ as $i2 => $value2) {\n        $is_third = ($i2 % 3 == 0) ? true : false;\n \
    \       foreach (array_reverse($l) as $i1 => $value1) {\n            if ($i1 %\
    \ 3 == 0) {\n                if ($is_third) {\n                    $l1[$i2] =\
    \ $value2;\n                    unset($l[$i2]);\n                } else {\n  \
    \                  $l1[$i2] = $value1;\n                    unset($l[$i1]);\n\
    \                }\n            }\n        }\n    }\n    return $l1;\n}\n", "\t\
    $l_size = count($l);\n\tfor ($i = 0; $i < $l_size; $i++) {\n\t\tif (($i % 3) ==\
    \ 0)\n\t\t\t$l[$i] = $l[$i];\n\t}\n\tfor ($i = 0; $i < $l_size; $i += 3) {\n\t\
    \tif ($l[$i] == $l[$i + 1])\n\t\t\t$l[$i] .= $l[$i + 2];\n\t\telse if ($l[$i]\
    \ == $l[$i - 1])\n\t\t\t$l[$i] .= $l[$i];\n\t\telse if ($l[$i] == $l[$i - 2])\n\
    \t\t\t$l[$i] .= $l[$i + 1];\n\t}\n\tfor ($i = 0; $i < $l_size; $i++)\n\t\t$l[$i]\
    \ = intval($l[$i]);\n\treturn $l;\n}\n", "\t$l2 = $l;\n\tforeach(array_slice($l,\
    \ 1) as $key => $value) {\n\t\tif($key % 3 == 0) {\n\t\t\t$l2[($key-1)/3] = $value;\n\
    \t\t}\n\t\telse {\n\t\t\t$l2[$key] = $value;\n\t\t}\n\t}\n\treturn $l2;\n}\n",
  "  $l2 = array();\n  for ($k = 0; $k < count($l); $k++) {\n    if ($k % 3 === 0)\
    \ {\n      $l2[$k] = $l[$k];\n    }\n  }\n  asort($l2);\n  $l3 = array();\n  for\
    \ ($k = 0; $k < count($l2); $k++) {\n    $l3[$k] = $l[$k];\n  }\n  return $l3;\n\
    }\n", "\t$l3_values = array();\n\tforeach ($l as $k1 => $v1) {\n\t\tif ($k1 %\
    \ 3 == 0) {\n\t\t\t$l3_values[] = $v1;\n\t\t}\n\t}\n\tif (empty($l3_values)) {\n\
    \t\treturn $l;\n\t}\n\tsort($l3_values);\n\t$l3_values = array_combine(array_keys($l),\
    \ $l3_values);\n\t$l3 = array();\n\tforeach ($l as $k2 => $v2) {\n\t\tif ($k2\
    \ % 3 == 0) {\n\t\t\t$l3[$k2] = $l3_values[$k2];\n\t\t}\n\t}\n\treturn $l3;\n\
    }\n", "\tlist($l[0], $l[1], $l[2]) = array_values($l);\n\tksort($l);\n\treturn\
    \ $l;\n}\n\n/**\n * Return the product of the array elements. The values in the\
    \ array are\n * assumed to not be negative.\n * >>> array_product_of(array(1,\
    \ 2, 3))\n * 6\n */", "\tforeach ($l as $index => $value) {\n\t\tif ($index %\
    \ 3 == 0) {\n\t\t\t$l[$index] = $l;\n\t\t}\n\t}\n\n\t// sort the array that has\
    \ already been turned into the third array (the values at the indicies that are\
    \ divisible by three are equal)\n\tksort($l);\n\n\t// get the indicies of the\
    \ values that are divisible by three, and unset them from the array\n\t$threes\
    \ = array_keys($l, 3);\n\n\tforeach ($threes as $three_index) {\n\t\tunset($l[$three_index]);\n\
    \t}\n\n\treturn $l;\n}", "    $l1 = array_slice($l, 0, floor(count($l) / 3));\n\
    \    $l2 = array_slice($l, floor(count($l) / 3), floor(count($l) / 3));\n    $l3\
    \ = array_slice($l, floor(count($l) / 3), floor(count($l) / 3) + (floor(count($l)\
    \ / 3) % 3));\n    $l3 = sort($l3);\n    $l2 = sort($l2);\n    $l1 = sort($l1);\n\
    \    return array_merge($l3, $l2, $l1);\n}", "    $l = sort($l);\n    $l = array_values($l);\n\
    \    $d = array_chunk($l, 3);\n    for ($i = 0; $i < count($d); $i++) {\n    \
    \    $d[$i] = array_merge($d[$i][$i],\n                             array_slice($d[$i],\n\
    \                                         0,\n                               \
    \          $i + 1));\n    }\n    return $d;\n}\n", "    $lSorted = array();\n\
    \    $lSorted[$l[0]] = $l[0];\n    $lSorted[$l[1]] = $l[1];\n    $lSorted[$l[2]]\
    \ = $l[2];\n    for($i = 2; $i < sizeof($l); $i++) {\n        if(!($i % 3)) {\n\
    \            $lSorted[$l[i]] = $l[i];\n        } else {\n            $lSorted[$l[$i]]\
    \ = $l[$i];\n        }\n    }\n    return $lSorted;\n}\n\n$arr = [10, 4, 6, 3,\
    \ 9, 8, 2, 7];\n$sortArr = sort_third($arr);\nprint_r($sortArr);\n", "    $l =\
    \ array_filter($l);\n    ksort($l);\n    $l2 = array_flip($l);\n    foreach ($l\
    \ as $key => $value) {\n        $l[$key] = $l2[($key + 3)%7];\n    }\n    return\
    \ $l;\n}\n$testcases = array(\n    array(array(1, 4, 3), array(3, 1, 4)),\n  \
    \  array(array(0, 1, 2, 3, 4, 5, 6), array(3, 6, 2, 5, 1, 4, 0)),\n    array(array(2,\
    \ 1, 2, 3, 3, 4, 5), array(4, 3, 5, 2, 6, 1, 0)),\n    array(array(1, 3, 2, 1,\
    \ 2, 3, 3, 4, 4, 5, 5, 6), array(5, 6, 4, 3, 1, 2, 2, 6, 1, 3, 0)),\n    array(array(1,\
    \ 2, 4, 5, 6, 0, 1), array(6, 5, 4, 2, 1, 4, 3, 2, 1, 2, 3, 0)),\n    array(array(1,\
    \ 1, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 6, 6, 7, 8, 9), array(8, 9, 7, 6, 5, 4, 3,\
    \ 2, 1, 2, 3, 4, 5)),\n    array(array(2, 1, 2, 3, 3, 3, 3, 3, 4, 4, 5, 5, 6,\
    \ 6, 7, 8, 9, 9, 10, 11, 12, 13), array(13, 12, 9, 10, 8, 6, 7, 5, 3, 6, 4, 2,\
    \ 3, 1, 10, 9, 11)),\n    array(array(2, 1, 2, 3, 3, 3, 3, 3, 4, 4, 5, 5, 6, 6,\
    \ 7, 8, 9, 9, 10, 11, 12, 13, 14, 15, 16), array(16, 15, 14, 12, 13, 10, 11, 8,\
    \ 9, 3, 6, 4, 2, 5, 1, 7, 9, 11, 16)),\n    array(array(3, 2, 3, 3, 5, 5, 6, 6,\
    \ 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20), array(20, 19, 18, 17,\
    \ 16, 15, 14, 13, 12, 11, 9, 10, 8, 7, 6, 5, 4)),\n    array(array(5, 8, 7, 8,\
    \ 11, 12, 15, 16, 17, 18, 19, 20, 21, 22, 23), array(23, 22, 21, 20, 19, 18, 17,\
    \ 16, 15, 14, 13, 12, 11, 9, 10, 8, 7, 6, 5)),\n);\nforeach ($testcases as $test)\
    \ {\n    $test = \"sort_third('$test')\";\n    $testResult = sort_third($test[0]);\n\
    \    if ($testResult != $test[1]) {\n        print 'Error in test ', $test, ':\
    \ expected ', $test[1], ', got ', $testResult, \"\\n\";\n    }\n}", "    if (count($l)\
    \ != 3) {\n        return $l;\n    }\n    $ls = array($l[0], $l[1], $l[2]);\n\
    \    ksort($ls);\n    for ($i = 0; $i < 3; $i++) {\n        if ($ls[$i] % 3 ==\
    \ 0) {\n            $ls[$i] -= 1;\n        }\n    }\n    return $ls;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=1 tags=php,arrays,function |>\n<code>", "  foreach\
    \ ($l as $i => $v) {\n    if ($i % 3 === 0) {\n      ksort($l);\n      return\
    \ $l;\n    }\n  }\n  return $l;\n}\n</code>\nIn your case, you may use that function\
    \ like this:\n<code>\n<?php\n  $third = array();\n  $threes = array();\n  foreach\
    \ ($links as $link) {\n    $third = sort_third($link);\n    foreach ($third as\
    \ $i => $v) {\n      $threes[$i] = $v;\n    }\n  }\n  var_dump($threes);\n</code>\n\
    <|/ a dscore=0 tags=php,arrays |>\n<| a dscore=0 tags=php,arrays |>\nThis may\
    \ help you. Just pass your array to this function. This will do all the work for\
    \ you.\n<code>", "    return array_merge(\n        array_slice($l, 0, floor(count($l)/3)),\n\
    \        array_slice($l, floor(count($l)/3))\n    );\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nYou didn't understand the question, I've already done that. My\
    \ problem is I need to know how to use `array_slice` in such a way that the values\
    \ in the new array are equal to the values in the original array if and only if\
    \ the indicies of the new array are divisible by three and are equal to the indicies\
    \ of the original array if and only if the indicies of the new array are not divisible\
    \ by three.\n<|/ c |>\n<| a dscore=0 |>\n<code>\n<?php\n", "    $lsorted = array();\n\
    \    $llen = count($l);\n    for($i = 0; $i < $llen; ++$i) {\n        if($i %\
    \ 3 != 0) {\n            $lsorted[$i] = $l[$i];\n        }\n    }\n\n    sort($lsorted);\n\
    \    $sorted = array();\n    foreach($l as $index => $value) {\n        if($index\
    \ % 3 != 0) {\n            $sorted[$index] = $value;\n        }\n    }\n    return\
    \ $lsorted;\n}\n", "  return array_intersect_key($l, array_flip(array_filter(array_count_values($l),\
    \ 'is_int')));\n}", "    $third = array();\n    for ($i=0; $i < count($l); $i+=3)\
    \ {\n        $third[] = $l[$i];\n    }\n    sort($third);\n    $l3 = array();\n\
    \    for ($i=0; $i < count($l); $i+=3) {\n        $l3[] = $l[$i];\n    }\n   \
    \ $third = array_merge(array(), $third);\n    $l3 = array_merge($l3, array(array()));\n\
    \    sort($l3);\n    return array_merge($l3, $third);\n}", "    $lcopy = array();\n\
    \    $lcopy[] = $l[0];\n    $lcopy[] = $l[1];\n    $lcopy[] = $l[2];\n    for\
    \ ($i = 0; $i < count($l) - 3; $i++) {\n        if ($i % 3 == 0) {\n         \
    \   $lcopy[] = $l[$i];\n            $lcopy[] = $l[$i+1];\n            $lcopy[]\
    \ = $l[$i+2];\n        } else {\n            $lcopy[] = $l[$i];\n            $lcopy[]\
    \ = $l[$i+1];\n            $lcopy[] = $l[$i+2];\n            $lcopy[] = $l[$i+3];\n\
    \            $lcopy[] = $l[$i+4];\n            $lcopy[] = $l[$i+5];\n        }\n\
    \    }\n    for ($i = count($l) - 2; $i >= 0; $i -= 3) {\n        if ($i % 3 ==\
    \ 0) {\n            $lcopy[] = $l[$i];\n            $lcopy[] = $l[$i+1];\n   \
    \         $lcopy[] = $l[$i+2];\n        }\n    }\n    return $lcopy;\n}\n", " \
    \   $llength = count($l);\n    for ($i = 1; $i < $llength; $i++) {\n        for\
    \ ($j = $i; $j < $llength; $j++) {\n            if ($i % 3 != $j % 3) {\n    \
    \            $temp = $l[$i];\n                $l[$i] = $l[$j];\n             \
    \   $l[$j] = $temp;\n            }\n        }\n    }\n    return $l;\n}\n", " \
    \ $l_copy = array_slice($l, 1);\n  return array_merge(\n    array_merge(\n   \
    \   array_slice($l, 0, 1),\n      array_slice($l_copy, 0, -1)\n    ),\n    $l_copy\n\
    \  );\n}\n", "  foreach ($l as $key=>$value) {\n    if ($key%3 == 0){\n      if\
    \ ($value%3 == 0) {\n        $l[$key] = $value;\n      }\n      else {\n     \
    \   $l[$key] = $l[$key] + ($l[$key-1] + $l[$key-2]);\n      }\n    }\n  }\n  return\
    \ $l;\n}\n\n$l= array(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20);\n$l=sort_third($l);\n\
    echo \"<PRE>\";\nprint_r($l);\necho \"</PRE>\";\n", "    $l = array_slice($l,\
    \ 0);\n    sort($l);\n    sort($l);\n    return $l;\n}\n\n$arr1 = array('a', 'b',\
    \ 'c', 'd');\n$arr2 = array('a', 'b', 'c', 'd');\n$arr3 = sort_third($arr1);\n\
    $arr4 = sort_third($arr2);\nassert($arr1 === $arr3, \"Arrays should be sorted\
    \ third\");\nassert($arr2 === $arr4, \"Arrays should be sorted third\");\n\n$arr1\
    \ = array();\n$arr2 = array();\n$arr3 = sort_third($arr1);\n$arr4 = sort_third($arr2);\n\
    assert($arr1 === $arr3, \"Arrays should be sorted third\");\nassert($arr2 ===\
    \ $arr4, \"Arrays should be sorted third\");\n\n$arr1 = array('a', 'b', 'c', 'd');\n\
    $arr2 = array('a', 'b', 'c', 'd');\n$arr3 = sort_third($arr1);\n$arr4 = sort_third($arr2);\n\
    assert($arr1 === $arr3, \"Arrays should be sorted third\");\nassert($arr2 ===\
    \ $arr4, \"Arrays should be sorted third\");\n\n$arr1 = array('a', 'b', 'c', 'd');\n\
    $arr2 = array('a', 'b', 'c');\n$arr3 = sort_third($arr1);\n$arr4 = sort_third($arr2);\n\
    assert($arr1 === $arr3, \"Arrays should be sorted third\");\nassert($arr2 ===\
    \ $arr4, \"Arrays should be sorted third\");\n\n$arr1 = array();\n$arr2 = array();\n\
    $arr3 = sort_third($arr1);\n$arr4 = sort_third($arr2);\nassert($arr1 === $arr3,\
    \ \"Arrays should be sorted third\");\nassert($arr2 === $arr4, \"Arrays should\
    \ be sorted third\");\n", "    $l = array_reverse($l);\n    $ln = count($l);\n\
    \    for ($i = 0; $i < $ln; $i ++)\n    {\n        if ($i % 3 === 0)\n       \
    \ {\n            $l[$i] .= $l[$i];\n        }\n    }\n    $l = array_reverse($l);\n\
    \    return $l;\n}", "    list($l2, $l3) = $l;\n    if ($l3 != 0) {\n        $l2[count($l2)\
    \ - 1] = $l3;\n        $l3 = 0;\n    }\n    foreach ($l as $k => $v) {\n     \
    \   if (!$k) {\n            $l2 = $v;\n        } else {\n            $l3 = $v;\n\
    \            $l2[$k - 1] = $v[$k - 1];\n        }\n    }\n    return array($l2,\
    \ $l3);\n}\n", "    return array_merge(\n        array_slice($l, 0, array_search($l[0],\
    \ $l)),\n        array_slice($l, array_search($l[0], $l)),\n        array_slice($l,\
    \ array_search($l[0], $l) + 1)\n    );\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    Thanks so much, will look at this and see if it works. I assume that \"array l'\
    \ \" means \"array l\"?\n<|/ c |>\n<| c |>\nYes - sorry, I used the word \"array\"\
    \ a lot in this answer, I just mean that it makes it more understandable for people\
    \ who are not familiar with the term \"array\".\n<|/ c |>\n<| a |>\nTry this out:\n\
    <code>\n<?php\n", "    $sorted = array();\n    foreach ($l as $key => $value)\
    \ {\n        if ($value % 3 === 0) {\n            $sorted[$key] = $value;\n  \
    \      } else {\n            $third = $key + ($value / 3);\n            while\
    \ (isset($l[$third])) {\n                $sorted[$key] = $value;\n           \
    \     $third++;\n            }\n        }\n    }\n    return $sorted;\n}\n\n$array\
    \ = array();\n$array = array(\n    array(\n        'name' => 'Test1',\n      \
    \  'data' => array(\n            'value1' => 500,\n            'value2' => 600,\n\
    \            'value3' => 700,\n            'value4' => 800,\n            'value5'\
    \ => 900,\n            'value6' => 920,\n            'value7' => 1000,\n     \
    \       'value8' => 1020,\n            'value9' => 1030,\n            'value10'\
    \ => 1050,\n            'value11' => 1080,\n            'value12' => 1200\n  \
    \      )\n    ),\n    array(\n        'name' => 'Test2',\n        'data' => array(\n\
    \            'value1' => 300,\n            'value2' => 400,\n            'value3'\
    \ => 500,\n            'value4' => 600,\n            'value5' => 700,\n      \
    \      'value6' => 800,\n            'value7' => 900,\n            'value8' =>\
    \ 1000,\n            'value9' => 1010,\n            'value10' => 1200,\n     \
    \       'value11' => 1300,\n            'value12' => 1400,\n            'value13'\
    \ => 1500,\n            'value14' => 1600,\n            'value15' => 1700,\n \
    \           'value16' => 1800\n        )\n    ),\n    array(\n        'name' =>\
    \ 'Test3',\n        'data' => array(\n            'value1' => 300,\n         \
    \   'value2' => 400,\n            'value3' => 500,\n            'value4' => 600,\n\
    \            'value5' => 700,\n            'value6' => 800,\n            'value7'\
    \ => 900,\n            'value8' => 1000,\n            'value9' => 1010,\n    \
    \        'value10' => 1200,\n            'value11' => 1300,\n            'value12'\
    \ => 1400,\n            'value13' => 1500,\n            'value14' => 1600,\n \
    \           'value15' => 1700,\n            'value16' => 1800\n        )\n   \
    \ )\n);\n$newArray = array();\n\nforeach ($array as $key => $value) {\n    foreach\
    \ ($value['data'] as $key2 => $value2) {\n        array_push($newArray, $value['data']);\n\
    \    }\n}\n\n$sortedData = sort_third($newArray);\n\necho '<pre>';\nprint_r($sortedData);\n",
  "    $l2 = [];\n    $j = 0;\n    foreach ($l as $k => $v) {\n        if ($v % 3\
    \ === 0) {\n            $l2[$j] = $v;\n        }\n        $j++;\n    }\n\n   \
    \ $sorted = [];\n    foreach ($l2 as $k => $v) {\n        $sorted[$k] = $k;\n\
    \    }\n\n    return $sorted;\n}"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
