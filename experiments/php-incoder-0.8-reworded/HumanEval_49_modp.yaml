name: HumanEval_49_modp
language: php
prompt: "<?php\n// Return 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n\
  // 3\n// >>> modp(1101, 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n\
  // 8\n// >>> modp(100, 101)\n// 1\nfunction modp($n, $p) {\n"
tests: "function candidate(...$args) {\n    return modp(...$args);\n}\n\nfunction\
  \ test(): void {\n    if (candidate(3, 5) !== 3) { throw new Exception(\"Test failed!\"\
  ); }\n    if (candidate(1101, 101) !== 2) { throw new Exception(\"Test failed!\"\
  ); }\n    if (candidate(0, 101) !== 1) { throw new Exception(\"Test failed!\");\
  \ }\n    if (candidate(3, 11) !== 8) { throw new Exception(\"Test failed!\"); }\n\
  \    if (candidate(100, 101) !== 1) { throw new Exception(\"Test failed!\"); }\n\
  \    if (candidate(30, 5) !== 4) { throw new Exception(\"Test failed!\"); }\n  \
  \  if (candidate(31, 5) !== 3) { throw new Exception(\"Test failed!\"); }\n}\n\n\
  test();"
completions: ["  $i = 1; // Initialization\n  $m = 1; // Initialization\n  $p2 = $p\
    \ * $p; // p^2\n  for ($i = 0; $i < $n; $i++, $p2 = $p2 * $p) {\n    $m = ($m\
    \ + ($p / $p2)) % $p;\n  }\n  return $m;\n}", "    return bcmod($n, bcpow('2',\
    \ $p, true));\n}", "\t$n = $n & ~0x3FFFFFFF;\n\t$p = $p & ~0x3FFFFFFF;\n\twhile\
    \ ($n > $p) {\n\t\t$n = ($n<<1) ^ (($n&1) ? 0xE0 : 0xE1);\n\t}\n\treturn $n &\
    \ 0x3FFFFFFF;\n}\n", "\t$i = 1;\n\twhile (true) {\n\t\tif (($n >> $i) % $p ==\
    \ 0) {\n\t\t\treturn $i;\n\t\t}\n\t\t$i++;\n\t}\n}\n", "    return pow($p, $n)\
    \ % $p;\n}\n", "  $mod = pow(2, $p);\n  return $n % $mod;\n}\n", "  return $n%$p;\n\
    }\n\n$result = array();", "\treturn (~ ( $n & $p )) & ( ~ ( $n | ( 1 << ( ( log(\
    \ $p ) + 1 ) - log( $n ) ) ) );\n}\n", "\t$r = $n >> 31;\n\t$n = (int)($n & 077);\n\
    \tif ($n !== (int)($n >> 31)) {\n\t\treturn $n ^ ($p - 1);\n\t}\n\tif ($n !==\
    \ 0) {\n\t\treturn (int)($p + $r * ($n >> 31));\n\t}\n\treturn 1;\n}\n", "  $result\
    \ = 0;\n  for ($i = 0; $i < strlen($n); ++$i) {\n    $result = $result * 10 +\
    \ ord($n[$i]) - ord($p[$i]);\n  }\n  return $result % $p;\n}\n", "    return ($n\
    \ % $p) + ($n % $p == 0 ? 1 : 0);\n}\n", "    return (int) ($n % $p);\n}\n", " \
    \ if ($p < 0) {\n    // Ensure $p is a positive integer.\n    $p = (int) floor($p\
    \ + 1);\n  }\n  return $n % $p;\n}\n", "  return ($n % $p) + (($n % $p) !== 0\
    \ ? modp($n / $p, $p) : 0);\n}", "    if ($p == 0) return 1;\n    if ($n == $p)\
    \ return 0;\n    $p = $p - 1;\n    $x = $p * $p + $n;\n    if ($x < $p) {\n  \
    \      $x = $x + $p;\n    }\n    return $n % $p;\n}\n", "    $n = $n % $p;\n \
    \   if ($n == 0) {\n        return $p;\n    }\n    if ($n < $p) {\n        return\
    \ modp($n - $p, $p) + $p;\n    } else {\n        return modp($n, $p);\n    }\n\
    }\n", "  while ($n % $p) {\n    $n -= $p;\n    if ($n < $p) {\n      return $n;\n\
    \    }\n    $n = $n % $p;\n  }\n  return $n;\n}\n", "  return $n - ($n % $p);\n\
    }\n", "  if (!is_int($p) || $n < 0 || $p < 1 || $p > mt_getrlimit(RLIMIT_NDIV))\
    \ {\n    throw new InvalidArgumentException(\"p must be an integer between 1 and\
    \ \".\n      mt_getrlimit(RLIMIT_NDIV).\" inclusive.\");\n  }\n  return pow($n,\
    \ $p);\n}\n\n/**\n * Returns the number of seconds left before the given time\
    \ would expire.\n * Subtracting two dates returns the difference in time between\
    \ the two dates\n * in any fractional part. E.g:\n * 3 days and 9 hours -> 0.596\
    \ days\n *\n * @param int $time an UNIX timestamp\n * @return int\n * @throws\
    \ InvalidArgumentException\n */", "    return ($n % $p) + $p;\n}\n", "  $n = intval($n);\n\
    \  $p = intval($p);\n  if ($p === 0) {\n    return 1;\n  }\n  if ($n === 0) {\n\
    \    return 0;\n  }\n  if ($p > $n) {\n    $temp = $p;\n    $p = $n;\n    $n =\
    \ $temp;\n  }\n  // return ($n % $p + $p) % $p;\n  return ($n % $p + $p) % $p;\n\
    }", "  if ($n < 0 || $p < 0) {\n    throw new Error('Arguments must be positive.');\n\
    \  }\n\n  if ($p === 0) {\n    return 0;\n  }\n\n  return bcmod($n, $p, 256);\n\
    }\n```\n\n```", "\treturn (1 << $n) % $p;\n}\n", "    return ($n % $p) + (($n\
    \ % $p) == 0 ? 0 : 1);\n}\n", "    $n = (int) $n;\n    $p = (int) $p;\n    if\
    \ ($p == 0)\n        return $n;\n    while ($p < 5) {\n        $p <<= 1;\n   \
    \     if ($p >= 1 << 30)\n            die(\"modp overflow\");\n    }\n    if ($n\
    \ <= $p)\n        return 0;\n    while ($n >= $p) {\n        $n -= $p;\n     \
    \   $p &= $p - 1;\n    }\n    return $n;\n}\n", "  $n = intval($n);\n  $p = intval($p);\n\
    \  if ($n == 0)\n    return 0;\n  if ($p < 0)\n    return ($n & $p) + modp($n\
    \ ^ $p + 1 >> 1, $p);\n  return $n % $p;\n}", "    return ($n % $p) + $p;\n}\n\
    \n$i = 3;\n$p = 5;\necho modp($i, $p) . \"\\n\";\n</code>\nIt can be further improved\
    \ by using modpow() but that won't help you with $i = 3 since that would result\
    \ in 2^3, which is not what you want.\n<|/ a tags=php |>\n<| c |>\nI actually\
    \ got this far from a similar answer given here http://stackoverflow.com/questions/1824790/modular-exponentiation-with-php-problems.\
    \ I only got stuck at what to put instead of `3` so that it works with any number\
    \ and any power.\n<|/ c |>\n<| c |>\n: You need `modp($i, $p)` instead of `pow($i,\
    \ $p)` (which uses `pow()` internally). If $i is already an integer you don't\
    \ need to call modp, just call `pow($i, $p)`.\n<|/ c |>\n<| c |>\nThat doesn't\
    \ work if $i is 3. It should return 8, not 2.\n<|/ c |>\n<| c |>\n: Right, didn't\
    \ see that before. Updated my answer.\n<|/ c |>\n<| c |>\n: No problem, but I'm\
    \ sure there is something similar in Python, too... :)\n<|/ c |>\n<| a tags=php\
    \ dscore=2 |>\nHere is a PHP version of Laurent's answer that works in PHP >=\
    \ 5.2.0:\n<code>", "  return bcmod($n, $p, 0, BCMOD_PHP);\n}", "    if ($p ==\
    \ 0) {\n        return 1;\n    }\n    $n = intval($n);\n    $p = intval($p);\n\
    \    if ($n == 0) {\n        return 0;\n    }\n    if ($p < 0) {\n        $p =\
    \ $p + $p;\n        $n = $n % $p;\n        $p = -$p;\n    } else {\n        $n\
    \ = $n % $p;\n    }\n    return $n % $p;\n}\n", "  return ($n % (int) $p) / $p;\n\
    }", "    return ($n % $p) + floor($n / $p);\n}", "  if (!$p) return $n;\n  if\
    \ (!$n || !$p) return 0;\n  return gmp_init(pow($n, $p / 2) % $p);\n}\n\n/**\n\
    \ * Returns 'e' (mod p), 'e' (mod (p-1)), and 'e' (mod (p-2)).\n * @param $n\n\
    \ * @param $p\n * @return string 3 chars\n */", "\treturn $n % $p == 0 ? $n :\
    \ ($n % $p == 1 ? $p - 1 : modp($n - $p, $p));\n}\n", "    return pow($n, $p -\
    \ floor($p / 2), $p);\n}\n", "    if ($p <= 0) {\n        return 0;\n    }\n\n\
    \    if ($n < 0) {\n        return modp(abs($n), $p);\n    }\n\n    if ($p > 0)\
    \ {\n        return modp($n - (int) $n, $p);\n    }\n\n    if ($p == 1) {\n  \
    \      return 1;\n    }\n\n    $n = $n - (int) $n;\n    $n = (int) $n;\n    $n\
    \ -= 1;\n    $n2 = $n * $n;\n    $n2 = $n2 * $n;\n    return $n2 - (int) $n2;\n\
    }\n", "  return bcmod($n, $p);\n}\n", "    return ($n / $p) % $p;\n}", "    if\
    \ ($n < 0 || $p <= 0) {\n        return 0;\n    }\n    if ($p > 0) {\n       \
    \ $n0 = $n; // (n + p/2) | 0\n        $p0 = $p; // (p + p/2) | 0\n    } else {\n\
    \        $n0 = $n; // (n + p/2) | 0\n        $p0 = $p; // (p - p/2) | 0\n    }\n\
    \    $n1 = $n0 - $p0;\n    if ($n1 == 0) {\n        return 1;\n    }\n    $m =\
    \ 1;\n    while ($n1 != 0) {\n        $m = $m * $p0 + $n1;\n        $n1 = $n0\
    \ - $p0;\n    }\n    return $m % $p;\n}\n\n$tests = [\n    [7, 4, 3],\n    [6,\
    \ 5, 4],\n    [7, 4, 0],\n    [7, 4, 1],\n    [7, 4, 2],\n    [7, 4, 3],\n   \
    \ [7, 4, 3],\n    [7, 5, 6],\n    [7, 4, 3],\n    [7, 4, 3],\n    [7, 4, 3],\n\
    \    [7, 4, 3],\n    [7, 4, 3],\n    [7, 4, 3],\n    [7, 4, 3],\n    [7, 4, 3],\n\
    \    [7, 4, 3],\n    [7, 4, 3],\n    [7, 4, 3],\n    [7, 4, 3],\n    [7, 4, 3],\n\
    \    [7, 4, 3],\n    [7, 4, 3],\n    [7, 4, 3],\n    [7, 4, 3],\n    [7, 4, 3],\n\
    \    [7, 4, 3],\n    [7, 4, 3],\n    [7, 4, 3],\n    [7, 4, 3],\n    [7, 4, 3],\n\
    \    [7, 4, 3],\n    [7, 4, 3],\n    [7, 4, 3],\n    [7, 4, 3],\n    [7, 4, 3],\n\
    \    [7, 4, 3],\n    [7, 4, 3],\n    [7, 4, 3],\n    [7, 4, 3],\n    [7, 4, 3],\n\
    \    [7, 4, 3],\n    [7, 4, 3],\n    [7, 4, 3],\n    [7, 4, 3],\n    [7, 4, 3],\n\
    \    [7, 4, 3],\n    [7, 4, 3],\n    [7, 4, 3],\n    [7, 4, 3],\n    [7, 4, 3],\n\
    \    [7, 4, 3],\n    [7, 4, 3],\n    [7, 4, 3],\n    [7, 4, 3],\n    [7, 4, 3],\n\
    \    [7, 4, 3],\n    [7, 4, 3],\n    [7, 4, 3],\n    [7, 4, 3],\n    [7, 4, 3],\n\
    \    [7, 4, 3],\n    [7, 4, 3],\n    [7, 4, 3],\n    [7, 4, 3],\n    [7, 4, 3],\n\
    \    [7, 4, 3],\n    [7, 4, 3],\n    [7, 4, 3],\n    [7, 4, 3],\n    [7, 4, 3],\n\
    \    [7, 4, 3],\n    [7, 4, 3],\n    [7, 4, ", "\t$n = (int) $n;\n\t$p = (int)\
    \ $p;\n\tif ($p == 0)\n\t\treturn 1;\n\tif ($n == 0)\n\t\treturn 0;\n\tif ($n\
    \ == $p)\n\t\treturn 1;\n\tif ($n % $p == 0)\n\t\treturn $n;\n\treturn modp($n\
    \ / $p, $p);\n}\n", "    $k = array_keys($p);\n    if ($p[$k[0]] <= $n) {\n  \
    \      if ($p[$k[0]] == $n) {\n            return $k[0];\n        }\n        return\
    \ $k[0];\n    }\n    return $k[0];\n}\n", "    return ($n % $p == 0) ? $n : ($n\
    \ % $p == ($p - 1)) ? $n % $p : $n % $p + 1;\n}\n", "  if ($n == $p) {\n    return\
    \ 1;\n  }\n  $r = 1;\n  for ($i = 0; $i < $n; $i++) {\n    $r *= $p;\n    if ($r\
    \ > $p) {\n      return $r;\n    }\n  }\n  return $r;\n}\n\n/**\n * @returns string\
    \ String of bytes in hex\n */", "  // p is negative.\n  if ($n < $p || $p <= 0)\
    \ {\n    return 1;\n  }\n\n  // p is positive.\n  if ($p > $n) {\n    return $n\
    \ % $p;\n  }\n\n  $d = $p;\n  while (true) {\n    if ($n % $d == 0) {\n      return\
    \ $d;\n    }\n    $d = $d << 1;\n    if ($d <= 0) {\n      return $n % $p;\n \
    \   }\n  }\n}\n", "    if ($p == 0) return 0;\n    if ($n == 0) return $p;\n \
    \   return $n % $p;\n}\n", "  $p = (int)$p;\n  if ($n >= $p) return 1;\n  if ($n\
    \ < 0 || $p < 0 || $p > $n) return 1;\n  $n = $n - $p;\n  $p = ($p | ~$p) + 1;\
    \ // Ensure $p is odd.\n  $p *= $p; // Ensure $p doesn't go over the modulus.\n\
    \  for ($i = 1; $n >= $p; $i++) {\n    $n = $n >> 1;\n    $p *= $p;\n  }\n  return\
    \ $p % $n;\n}\n", "  return (int) ($n - ($n % $p));\n}\n", "    if ($n < 0 ||\
    \ $p <= 0) {\n        return 0;\n    }\n    return ($n%$p);\n}\n", "  return $n\
    \ % $p;\n}\n", "    return $n%$p;\n}\n", "\treturn ($n >= $p) ? (($n % $p) + $p)\
    \ % $p : $n % $p;\n}\n", "    if ($n === 0) {\n        return 0;\n    }\n    if\
    \ ($n >= $p) {\n        return $n % $p;\n    }\n    return ($n % $p) + $p;\n}\n",
  "\tif ($n == 0) {\n\t\treturn 1;\n\t}\n\n\t$result = $n % $p;\n\tif ($result ==\
    \ 0) {\n\t\t$result = $p - $result;\n\t\tif ($result < 0) {\n\t\t\t$result = $result\
    \ + $p;\n\t\t}\n\t}\n\treturn $result;\n}\n", "    return bcmod(pow(2, $n, $p),\
    \ $p);\n}\n</code>\n<|/ a |>\n<| a dscore=1 |>\nA couple of years ago, I was writing\
    \ a script to generate HTML pages in PHP and found this question with a similar\
    \ requirement.\nMy solution was to generate an inverse lookup table for a large\
    \ base (say base 36).\n<code>\n$base = 36;\n$lookup = array();\n", "  if ($n ==\
    \ 0 || $p == 0)\n    return 1;\n  $res = 1;\n  while ($n > $p) {\n    $res *=\
    \ $p;\n    $n -= $p;\n  }\n  return $n % $p;\n}", "\tif ($n % $p === 0) {\n\t\t\
    return $n;\n\t} else {\n\t\treturn ($n - $n % $p) % $p;\n\t}\n}", "  return intval(pow(2,\
    \ $n, $p));\n}", "  return ltrim(str_pad(base_mod((int) $n, (int) $p, (bool) $p),\
    \ $p - strlen(rtrim($n, ' ')), ' ', STR_PAD_RIGHT), '0');\n}\n</code>\n<|/ a tags=algorithm,modulus,php,math\
    \ dscore=3 |>\n<| c |>\nNice solution. Just want to add that you can use the `base_mod()`\
    \ function in PHP instead of `ltrim()`, `rtrim()` and `str_pad()`.\n<|/ c |>\n\
    <| c |>\n`base_mod` is available in PHP 5.3+\n<|/ c |>\n<| c |>\nNice solution,\
    \ although `base_mod` returns a float and doesn't work with negative numbers,\
    \ unlike `mod`. Using `floor` solves this: `return floor($n * $p / $q);`\n<|/\
    \ c |>\n<| a dscore=2 tags=algorithm,modulus,php,math |>\nHere is my solution:\n\
    <code>", "  $n   = $n * PHP_INT_SIZE / $p;\n  $z   = intval($n) % $p;\n  return\
    \ $z == 0 ? $p : $z;\n}\n\n/**\n * Check if number of bits set in binary string\
    \ equals target.\n *\n * Note: PHP_INT_SIZE == 8\n *\n * @param  string  $haystack\n\
    \ * @param  string  $target\n * @param  integer $offset\n * @return boolean\n\
    \ */", "  $r = 1;\n  for ($i = 0; $i < $p; $i++) {\n    $r *= $n;\n    $r -= $n\
    \ % $p;\n    $n = (int) ($n / $p);\n  }\n  return $r;\n}\n\n/**\n * Returns true\
    \ if the given number is even.\n */", "  if ($p == 0 || $p == 1)\n    return $n;\n\
    \  if ($p == 1)\n    return 1;\n  if ($p == 2)\n    return 3;\n  return (int)\
    \ ($n % (int) pow(2, $p));\n}\n", "  if ($p < 0) {\n    throw new InvalidArgumentException('$p\
    \ must be a nonnegative integer.');\n  }\n\n  if ($n < 0) {\n    throw new InvalidArgumentException('$n\
    \ must be a nonnegative integer.');\n  }\n\n  if ($p === $n) {\n    return 1;\n\
    \  }\n\n  if ($p === 0) {\n    return 0;\n  }\n\n  if ($n === 0) {\n    return\
    \ $p;\n  }\n\n  return ($n % $p + modp($n / $p, $p)) % $p;\n}\n", "    return\
    \ $n % $p !== 0;\n}\n", "    if ($n%$p != 0) {\n        return $n%$p\n    }\n\
    \    while ($p /= 10) {\n        if ($n%$p == 0) {\n            return $n;\n \
    \       }\n    }\n}", "  return (int)(((($n * $p) % $p) + $p) % $p);\n}\n", " \
    \   return $n%$p;\n}\n", "    return ($n % $p + $p) % $p;\n}\n", "  // http://book.pythontips.com/en/latest/special_operators.html\n\
    \  // + is faster\n  return ($n % $p) + $p;\n}", "    return $n & ($p-1);\n}\n",
  "  $n = $n & ~0x3FFFFFFF;\n  $n -= pow(2, (31-$p));\n  $n = ($n >> 16) & $p;\n \
    \ return $n % $p;\n}", "\treturn $n - $n * $p % $p;\n}\n", "    if ($n == 0) return\
    \ $p;\n    return $p - ($n % $p);\n}\n", "\t$n2 = $n * $n;\n\t$n4 = $n2 * $n;\n\
    \t$n8 = $n4 * $n;\n\t$p2 = $p * $p;\n\t$p4 = $p2 * $p;\n\t$p8 = $p4 * $p;\n\t\
    if ($p == 8) return $n8; // |p| < 1, return n^p\n\tif ($p2 == 8) return $n4 +\
    \ $n2; // |p| == 1, return n*(n+1)\n\tif ($p4 == 16) return $n8 + $n4 + $n2; //\
    \ |p| == 2, return n*(n+1)*(2n+1)\n\tif ($p8 == 24) return $n16 + $n8 + $n4 +\
    \ $n2;\n\tthrow new Exception(\"modp() not implemented for \" . $n . \" and \"\
    \ . $p);\n}\n", "  return ($n % $p) + $p;\n}\n", "  return ($n & ($p - 1)) * $p\
    \ + 1;\n}\n", "  return $n & (~(-pow(2, $p) & $n));\n}\n", "  if ($n === 0) {\n\
    \    return 1;\n  }\n  if ($n === $p) {\n    return 0;\n  }\n  if ($n !== $p -\
    \ 1) {\n    return modp($n - $p, $p) % $p;\n  }\n  $ln = log($p);\n  return ($p\
    \ === $ln) ? $n % $p : $n%$p;\n}\n\n/**\n * Calculates the negative modulo of\
    \ two numbers.\n * @param $x the number to take the modulo of\n * @param $y the\
    \ modulo\n * @return the resulting number\n */", "    if ($p == 0)\n        return\
    \ 0;\n\n    $n = intval($n);\n    $p = intval($p);\n\n    if ($p > $n || $p <\
    \ 0)\n        return 0;\n\n    if ($n == 0)\n        return 1;\n\n    if ($n ==\
    \ $p)\n        return 1;\n\n    if ($n % $p == 0)\n        return modp($n / $p,\
    \ $p);\n\n    return modp($p, $p * $n / $p);\n}\n", "  return ($p & -$n) ?\n \
    \     (($n ^ ($p ^ $n)) & -$n) :\n      (($n ^ ($p ^ $n)) & ($n - $p));\n}\n</code>\n\
    For a more general solution, see the comments by Craig Heckler in the original\
    \ question:\n\n\"If you can find an arbitrary modulus, the simplest thing is to\
    \ find an\n  arbitrary power of 2. That is just to compute the modulus. Subtract\n\
    \  the modulus from each element of N and then do N mod 2. You can then\n  just\
    \ use the bits of N which aren't a part of the modulus to get\n  your exponent.\
    \ Not sure how efficient this would be though.\"\n\n<code>", "  if ($p < 0) {\n\
    \    return ($p < 0)?-modp(abs($n),abs($p)):modp($n,$p);\n  }\n  if ($n < 0) {\n\
    \    return ($n < 0)?-modp(abs($n),abs($p)):modp($n,$p);\n  }\n\n  // $n and $p\
    \ should be integers.\n  if ($n == $p) {\n    return 1;\n  }\n\n  $n = $n * 2;\n\
    \  if ($n <= $p) {\n    return ($n % $p);\n  }\n  $r = $p % $n;\n  if ($r == 0)\
    \ {\n    return $n;\n  }\n  return modp($n, $r) + $r;\n}\n", "\treturn ($n % $p)\
    \ + $p;\n}\n", "    return $p % $n;\n}\n", "  return $n % $p;\n}\n", "  return\
    \ bcmod($n, $p);\n}\n", "    if (!isset($n)) {\n        return 1;\n    }\n\n \
    \   $modpow = pow($p, $n);\n    return $modpow % $p;\n}", "  $n = (integer) $n;\n\
    \  $p = (integer) $p;\n\n  if ($n < 0 || $p < 0) {\n    return null;\n  }\n\n\
    \  if ($n !== floor($n) || $p !== floor($p)) {\n    return null;\n  }\n\n  if\
    \ ($n !== ($n | 0) || $p !== ($p | 0)) {\n    return null;\n  }\n\n  if ($p ===\
    \ $n) {\n    return 1;\n  }\n\n  // Euclid's algorithm\n  $m = $n;\n  $r = $p;\n\
    \  for (;;) {\n    while ($m & 1) {\n      $m >>= 1;\n      $r = ($r + $p) % $p;\n\
    \    }\n    if ($r === 0) {\n      break;\n    }\n    $m = ($m - $r) % $p;\n \
    \   $p = ($p + $r) % $p;\n    $r = ($r - $m) / $p;\n  }\n  return $r;\n}\n", " \
    \   $n = (integer) $n;\n    $p = (integer) $p;\n\n    if ($n < 0) {\n        throw\
    \ new Exception(\"modp() only works for positive integers.\");\n    }\n\n    if\
    \ ($p < 0) {\n        throw new Exception(\"modp() only works for positive integers.\"\
    );\n    }\n\n    if ($p === 0) {\n        throw new Exception(\"modp() can't be\
    \ zero\");\n    }\n\n    if ($n > $p) {\n        return $n % $p;\n    }\n\n  \
    \  return ($n % $p) + $p;\n}\n", "    if ($n < 0 || $p <= 0) {\n        throw\
    \ new Exception('Parameters must be positive');\n    }\n    if ($p === 1) {\n\
    \        return $n;\n    }\n    $modpow = $p->modpow($n);\n    $rem = 0;\n   \
    \ while ($modpow->rem) {\n        $mod = $modpow->mod;\n        $modpow->mod *=\
    \ $p;\n        $rem += $mod;\n    }\n    return $rem;\n}\n", "    $res = $n %\
    \ ($p + 1);\n    return $res === 0 ? $n : $res;\n}\n", "  return ($n % $p) + $p;\n\
    }\n</code>\n<|/ a dscore=5 |>\n<| c |>\nWhat about negative numbers? Are they\
    \ allowed?\n<|/ c |>\n<| c |>\nYes, they are allowed. You can check this by running:\
    \ `modp(10, -3)`, which will return the negative of the number 10.\n<|/ c |>\n\
    <| c |>\nI used this answer to create a function that can calculate the factorial\
    \ without using any loops. `function factorial($x) {\n    if ($x == 0 || $x ==\
    \ 1) {\n        return 1;\n    } else {\n        return $x * factorial($x - 1);\n\
    \    }\n}`\n<|/ c |>\n<| c |>\nI got `Recursion on overflow allowed` with `$n\
    \ = 100` and `$p = 11`\n<|/ c |>\n<| c |>\nYou can do that by changing `intval($n,\
    \ 10)` to `floatval($n, 10)`.\n<|/ c |>\n<| a tags=modulo,php |>\n<code>", " \
    \ return ($n % $p == 0)\n       ? $n\n       : ($p - ($n % $p))*$p;\n}\n", " \
    \ if ($n == 0) {\n    return 0;\n  }\n  if ($p == 0) {\n    return $n;\n  }\n\
    \  if ($n < 0) {\n    return modp($-$n, $p);\n  }\n  if ($p < 0) {\n    return\
    \ -modp($n, $p);\n  }\n  $r = 1;\n  $t = 1;\n  for ($i = 0; $i <= $p; $i++) {\n\
    \    $r *= $t;\n    $t *= $n;\n  }\n  for ($i = 0; $i < $p; $i++) {\n    if ($t\
    \ % 2) {\n      $r += $n;\n    }\n    $t >>= 1;\n  }\n  return $r;\n}\n", "  return\
    \ $n & (-$p);\n}\n", "  return $n%$p;\n}\n", "    return ((($n % $p) + $p) % $p);\n\
    }\n</code>\n<|/ a |>\n<| c |>\nthis worked for me in php 5.3\n<|/ c |>\n<| a dscore=4\
    \ |>\nI came up with following solution:\n<code>", "  $r = $n % $p;\n  return\
    \ $p ? $r : $n - $r;\n}", "  if ($n<1)\n    return $n;\n  if ($p<1)\n    return\
    \ $n;\n  if ($n%$p==0)\n    return $p;\n  return modp($n/$p, $p)*$p;\n}\n\n/*\n\
    \ * Return the greatest common divisor of two or more integers.\n */", "\tif ($n\
    \ % $p != 0) {\n\t\treturn $n % $p;\n\t} else {\n\t\treturn $n;\n\t}\n}\n", "\t\
    if ($n < 0) {\n\t\t$n = -$n;\n\t\t$p = -$p;\n\t}\n\treturn $n % $p + $p;\n}\n\n\
    /**\n * Converts a hex value to an integer\n *\n * @param string $hex\n *   The\
    \ hex number\n *\n * @return int\n *   The integer value\n */", "    if ($n <\
    \ 0 || $p < 1 || $p > 20 || $n % $p != 0) {\n        return null;\n    }\n   \
    \ if ($n == $p) {\n        return 1;\n    }\n    if ($n%$p == 0) {\n        return\
    \ $n;\n    }\n    $k = $n;\n    while ($k%$p == 0) {\n        $k /= $p;\n    }\n\
    \    return $k;\n}\n", "    $n = $p - abs($n);\n    if ($n == 0) {\n        return\
    \ 1;\n    }\n    if ($n < 0) {\n        return modp($n * 2 + 1, $p) % $p;\n  \
    \  }\n    return modp($n / 2, $p) * 2;\n}\n", "  $n = $n % $p;\n  return ($n ==\
    \ 0) ? 1 : ($n) ? modp($n-1, $p) : 1;\n}", "    return ($n % $p + $p) % $p;\n\
    }\n", "    if ($n >= $p) return 0;\n    $r = $n % $p;\n    if ($r == 0) return\
    \ $p;\n    return modp($n - $r, $p) % $p;\n}", "  if ($n === 0) {\n    return\
    \ $p;\n  }\n  return $n % $p >= 0 ? modp($n / $p, $p) : 1;\n}\n\n/**\n * Returns\
    \ square of integer.\n * @link https://php.net/manual/en/function.decod.php\n\
    \ * @param $a float or double value\n * @param $b float or double value\n * @return\
    \ float or double value\n */", "  // >>> modp(1101, 101)\n  // 2\n  // >>> modp(3,\
    \ 11)\n  // 8\n  // >>> modp(100, 101)\n  // 1\n  if ($n < $p) {\n    return $n\
    \ % $p;\n  }\n  return ($n % $p) + $p;\n}\n</code>\n<|/ a tags=algorithm,php,math\
    \ |>\n<| c |>\nThis answer is wrong in many cases. Please see my other answer\
    \ for a case that proves it wrong.\n<|/ c |>\n<| c |>\n: It's not wrong. `modp(11,\
    \ 10)` is `1`, so `modp(1101, 101)` yields `0` which is wrong. The example given\
    \ in the question is wrong.\n<|/ c |>\n<| c |>\nNot the example given is wrong,\
    \ please see the following example: modp(1011, 100) = 1101; modp(1101, 101) =\
    \ 101, modp(1101, 101) = 101.\n<|/ c |>\n<| c |>\n: I understand that. My point\
    \ is that `modp()` will return the wrong answer in some cases. For example, `modp(1101,\
    \ 101)` returns `101` but `modp(1101, 11)` returns `10` because `10` doesn't fit\
    \ in a `10`.\n<|/ c |>\n<| a dscore=4 |>\nThis is an implementation of the modulus\
    \ operator, also known as the remainder operator. According to the wikipedia page\
    \ on modulus, it returns the remainder after division. Here's an example (python):\n\
    <code>\n>>> 3 % 5\n2\n</code>\nTo get the remainder of division (integer division\
    \ in this case), you can use:\n<code>\n>>> 3 // 5\n2\n</code>\n<|/ a tags=algorithm,php,math\
    \ |>\n<| c |>\nWhat about negative numbers?\n<|/ c |>\n<| c |>\n: Negatives are\
    \ already handled by the modulus operator (`%`)\n<|/ c |>\n<| c |>\nI mean that\
    \ when `3 % 5` is `2` it can be rewritten as `(3 - 1) // 5` which is `3`\n<|/\
    \ c |>\n<| c |>\n: You are correct. However I do think that the example given\
    \ is wrong. The example given is `modp(1101, 101)` which returns `101` but `modp(1101,\
    \ 11)` returns `10` because `10` doesn't fit in a `10`.\n<|/ c |>\n<| c |>\nOk,\
    \ I got it now. I just ", "  if ($n%$p)\n    return $n%$p;\n  $r = $p;\n  while\
    \ ($n%$r)\n    $r *= $r;\n  return $r;\n}\n", "    return ($n % $p) ~ ($p / $p);\n\
    }", "  return ($n % $p) ? ($n - ($n % $p)) : ($n % $p);\n}\n\n$str1 = \"one\"\
    ;\n$str2 = \"two\";\n$str3 = \"three\";\n$str4 = \"four\";\n$str5 = \"five\";\n\
    $str6 = \"six\";\n$str7 = \"seven\";\n$str8 = \"eight\";\n$str9 = \"nine\";\n\
    $str10 = \"ten\";\n$str11 = \"eleven\";\n$str12 = \"twelve\";\n$str13 = \"thirteen\"\
    ;\n$str14 = \"fourteen\";\n$str15 = \"fifteen\";\n$str16 = \"sixteen\";\n$str17\
    \ = \"seventeen\";\n$str18 = \"eighteen\";\n$str19 = \"nineteen\";\n$str20 = \"\
    twenty\";\n$str21 = \"twenty one\";\n$str22 = \"twenty two\";\n$str23 = \"twenty\
    \ three\";\n$str24 = \"twenty four\";\n$str25 = \"twenty five\";\n$str26 = \"\
    twenty six\";\n$str27 = \"twenty seven\";\n$str28 = \"twenty eight\";\n$str29\
    \ = \"twenty nine\";\n$str30 = \"thirty\";\n$str31 = \"thirty one\";\n$str32 =\
    \ \"thirty two\";\n$str33 = \"thirty three\";\n$str34 = \"thirty four\";\n$str35\
    \ = \"thirty five\";\n$str36 = \"thirty six\";\n$str37 = \"thirty seven\";\n$str38\
    \ = \"thirty eight\";\n$str39 = \"thirty nine\";\n$str40 = \"forty\";\n$str41\
    \ = \"forty one\";\n$str42 = \"forty two\";\n$str43 = \"forty three\";\n$str44\
    \ = \"forty four\";\n$str45 = \"forty five\";\n$str46 = \"forty six\";\n$str47\
    \ = \"forty seven\";\n$str48 = \"forty eight\";\n$str49 = \"forty nine\";\n$str50\
    \ = \"fifty\";\n$str51 = \"fifty one\";\n$str52 = \"fifty two\";\n$str53 = \"\
    fifty three\";\n$str54 = \"fifty four\";\n", "  return lcm($p, ($p % $n));\n}\n",
  "    if ($p == 0) {\n        return 1;\n    }\n    if ($n == 0) {\n        return\
    \ 0;\n    }\n    if ($n == $p) {\n        return 1;\n    }\n    if ($n == ($p\
    \ - 1)) {\n        return modp($n - 1, $p);\n    }\n    $n2 = pow($n, 2);\n  \
    \  $p2 = pow($p, 2);\n    $n3 = pow($n, 3);\n    $p3 = pow($p, 3);\n    if ($p3\
    \ == 0 || $p3 == 2) {\n        $k = 0;\n    } else {\n        $k = $n3 / $p3;\n\
    \        if ($p3 != $n3) {\n            $k++;\n        }\n    }\n    $p5 = pow($p,\
    \ 5);\n    $k = ($p5 * $k + $n2) % $p5;\n    return $k >= $n ? $k : $n + 1;\n\
    }\n", "  $modp = ($p % $n) + $n % $n;\n  return $modp < 0 ? $modp : $modp;\n}\n",
  "  if ($n % $p === 0) {\n    $nmod = $n % $p;\n    if ($nmod === 0) {\n      return\
    \ 0;\n    }\n    return $nmod;\n  }\n  return $n % $p;\n}\n", "    if ($p < 0)\
    \ {\n        $p = $p % -$p;\n    }\n    return ($n % $p) + ($p / $p);\n}\n\n/*\n\
    \  Convert a hex string to a decimal integer\n*/", "  if ($n < 0 || $p <= 0 ||\
    \ $n <= 0)\n    return 0;\n  if ($p === $n) {\n    return 1;\n  }\n\n  $n_p =\
    \ $n / $p;\n\n  // $n is power of $p ?\n  if ((($n_p & 1) === 0) || (($n_p & 2)\
    \ === 0))\n    return $p;\n\n  // $n is power of $p ?\n  if ((($n_p & 1) === 0)\
    \ || (($n_p & 3) === 0))\n    return pow($n, $p);\n\n  // $n is power of $p ?\n\
    \  if ((($n_p & 2) === 0) || (($n_p & 4) === 0))\n    return pow($n, $p * 2);\n\
    \n  // $n is power of $p ?\n  if ((($n_p & 2) === 0) || (($n_p & 8) === 0))\n\
    \    return pow($n, $p * 3);\n\n  // $n is power of $p ?\n  if ((($n_p & 4) ===\
    \ 0) || (($n_p & 16) === 0))\n    return pow($n, $p * 4);\n\n  // $n is power\
    \ of $p ?\n  if ((($n_p & 8) === 0) || (($n_p & 32) === 0))\n    return pow($n,\
    \ $p * 5);\n\n  // $n is power of $p ?\n  if ((($n_p & 16) === 0) || (($n_p &\
    \ 64) === 0))\n    return pow($n, $p * 6);\n\n  // $n is power of $p ?\n  if ((($n_p\
    \ & 32) === 0) || (($n_p & 128) === 0))\n    return pow($n, $p * 7);\n\n  // $n\
    \ is power of $p ?\n  if ((($n_p & 64) === 0) || (($n_p & 256) === 0))\n    return\
    \ pow($n, $p * 8);\n\n  // $n is power of $p ?\n  if ((($n_p & 128) === 0) ||\
    \ (($n_p & 1024) === 0))\n    return pow($n, $p * 9);\n\n  // $n is power of $p\
    \ ?\n  if ((($n_p & 256) === 0) || (($n_p & 2048) === 0))\n    return pow($n,\
    \ $p * 10);\n\n  // $n is power of $p ?\n  if ((($n_p & 2048) === 0) || (($n_p\
    \ & 4096) === 0))\n    return pow($n, $p * 11);\n\n  // $n is power of $p ?\n\
    \  if ((($n_p & 4096) === 0) || (($n_p & 8192) === 0))\n    return pow($n, $p\
    \ * 12);\n\n  // ", "\tif ($n < 0) {\n\t\treturn $n * modp(abs($n), $p);\n\t}\n\
    \treturn ($n % $p) + $p;\n}\n", "  return ($n % $p) == 0 && ($n % $p) != ($p -\
    \ 1);\n}\n</code>\n<|/ a tags=php,php-7,bitmask dscore=1 |>\n<| a dscore=1 tags=php,php-7,bitmask\
    \ |>\nAs others have said you can use the bitwise operator and to do this fairly\
    \ easily. Unfortunately it doesn't support unsigned numbers. As it happens PHP\
    \ does support unsigned numbers as of PHP 7.0 (although they do require that you\
    \ use an unsigned number in the first place).\nThis means you can easily get unsigned\
    \ bitwise AND for numbers without needing to manually check and convert each number\
    \ before you AND them. Here's a function that will take any number of arguments\
    \ and convert them to unsigned numbers:\n<code>", "  // Find p (the divisor)\n\
    \  while (true) {\n    if ($n === 0) {\n      return 0;\n    }\n    if ($n % $p\
    \ === 0) {\n      return $p;\n    }\n    $n = $n / $p;\n    $p++;\n  }\n}\n",
  "    if (!$n) return $p;\n    if (!$p) return $n;\n    $n = (int) $n;\n    $p =\
    \ (int) $p;\n    if ($n == $p) return $n;\n    if ($n < 0 or $p < 0)\n       \
    \ throw new Exception(\"Bad arguments: $n and $p\");\n    if ($n == 0)\n     \
    \   return 1;\n    if ($n == $p)\n        return $n;\n    if ($n > $p)\n     \
    \   return modp($p - $n, $p);\n    if ($p % $n == 0)\n        return $n / $p;\n\
    \    return modp($n, $p) % $p;\n}\n", "    if (!is_numeric($n) || !is_numeric($p))\
    \ return null;\n    return (int) ($n % $p == 0 && (!$p || !modp($p % $n, $p)));\n\
    }\n</code>\n<|/ a |>\n<| c |>\nI love how you wrote that and also how I implemented\
    \ it into my script. It works perfectly! Thanks! For those interested in the function,\
    \ I added my modified function to my original question. Thanks again!\n<|/ c |>\n\
    <| a tags=php,modulo,math |>\n<code>\npublic function mod($number, $mod) {\n \
    \   return $number % $mod;\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis does\
    \ not give the expected result in PHP. e.g. `mod(1, 5)` returns `1` instead of\
    \ `0`.\n<|/ c |>\n<| a |>\nFor what it's worth, there is a builtin function called\
    \ \"mod\"\n<code>", "  return $n % $p == 0 ? (int) pow($n, $p % $p, $p) : (int)\
    \ ($n % $p);\n}\n</code>\n<|/ a dscore=3 tags=php,modulus |>\n<| c |>\n\"to be\
    \ more precise\" - that's not precisely true, as there are ways to get modulo\
    \ powers more efficiently. But in any case, I think it's better to use the simplest\
    \ method - modulus - rather than to optimize for speed (which won't necessarily\
    \ give the correct result)\n<|/ c |>\n<| c |>\n: It should be noted that most\
    \ of the time these are actually not going to be significant.\n<|/ c |>\n<| c\
    \ |>\nI agree with. Why bother with modulus in the first place? It's not going\
    \ to be a performance issue, after all this code is run hundreds of times per\
    \ second. Using pow($n, $p % $p, $p) will always outperform this method and it's\
    \ going to be extremely easy to read and understand.\n<|/ c |>\n<| c |>\nIf you're\
    \ going to use pow, I'd suggest using bcpow\n<|/ c |>\n<| c |>\n: bcpow() is for\
    \ floating points, whereas pow() will result in an integer.\n<|/ c |>\n<| a tags=php,modulus\
    \ |>\n<code>\n$power = pow($num, 2);\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis\
    \ isn't correct. pow() returns the value of the base^exponent, not the exponent\
    \ itself. See http://php.net/manual/en/function.pow.php\n<|/ c |>\n<| c |>\nAh\
    \ yes, I see it now (I thought the OP was asking about the exponent itself). Yes,\
    \ this only returns the value of the base^exponent.\n<|/ c |>\n<| a |>\nUse PHP's\
    \ native pow() function: http://php.net/pow\n<code>\n<?php\n$num = 1;\n$pow =\
    \ pow($num, 2);\n\necho $pow;", "  if (!isinteger($n)) {\n    throw new InvalidArgumentError('modp():\
    \ First argument must be an integer.');\n  }\n  if (!isinteger($p)) {\n    throw\
    \ new InvalidArgumentError('modp(): Second argument must be an integer.');\n \
    \ }\n  if ($n < 0) {\n    throw new InvalidArgumentError('modp(): First argument\
    \ must be nonnegative.');\n  }\n  if ($p < 0) {\n    throw new InvalidArgumentError('modp():\
    \ Second argument must be nonnegative.');\n  }\n  if ($p === 0) {\n    throw new\
    \ InvalidArgumentError('modp(): Division by zero.');\n  }\n  $n = intval($n);\n\
    \  if ($n === 0) {\n    return 0;\n  }\n  $p = intval($p);\n  if ($n !== $p &&\
    \ $p !== 1) {\n    throw new InvalidArgumentError('modp(): p and n must satisfy\
    \ gcd(p, n) = 1.');\n  }\n  $x = 1;\n  $y = 1;\n  $m = 1;\n  while ($n > 1) {\n\
    \    $m *= $p;\n    $x %= $p;\n    // $m is now bigger than p, so $m divides n.\n\
    \    $y = $m / $n;\n    $m = $n % $p;\n    $n = $x;\n    $x = $y;\n  }\n  if ($n\
    \ === 0) {\n    return 0;\n  }\n  if ($m === 1) {\n    return $n;\n  }\n  return\
    \ $x % $p;\n}\n\n/**\n * Returns the greatest common divisor of a and b; a, b\
    \ and p are positive integers; n is nonnegative.\n * gcd(0, 0) = 0, gcd(x, 0)\
    \ = x, gcd(0, x) = x.\n *\n * @param int $a\n * @param int $b\n * @param int $p\n\
    \ * @return int\n * @internal\n */", "    $res = 1;\n    while ($n > $p) {\n \
    \       $res *= $p;\n        $n--;\n    }\n    return $res;\n}\n", "    return\
    \ (int)pow($n, ($p - 1) >> 26, ($p - 1) % $p);\n}\n", "    // n is a 32-bit integer.\n\
    \    // p is also a 32-bit integer.\n    // We return the 32-bit integer result\
    \ of the following computation:\n    // p * pow(2, 32-n) mod p.\n    return ($n->lShiftLeft(32-n)\
    \ | p->modPow(2, 32-n)) % p;\n}\n", "  return (($n % $p) + $p) % $p;\n}\n", " \
    \   if ($n < $p) {\n        return $n % $p;\n    }\n\n    return $p - $n % $p;\n\
    }\n", "  return $n % $p === 0 ?\n    ($n / $p) * $p :\n    modp($n % $p, $p);\n\
    }", "    $r = $n % $p;\n    return $r === 0 && $n !== $p ? $p : $r;\n}\n", " \
    \ return (int)(((int)$n * $p + 1) / $p);\n}", "  return $n * $p + $p - $n * floor($p\
    \ / $p);\n}\n", "  $n = (int) $n;\n  $p = (int) $p;\n  if ($n < 0) {\n    return\
    \ $n % $p;\n  }\n  return ($n % $p) / $p;\n}", "    return $n % $p == 0 ? (int)($n\
    \ / $p) : 0;\n}\n", "  return bcmod($n, $p) <> 0 ? bcmod($n, $p) : bcdiv($n, $p);\n\
    }\n", "    return $n % $p;\n}\n", "  if ($n >= $p || $n % $p != 0) {\n    return\
    \ $n % $p;\n  }\n  return $n;\n}\n", "  return ($n % ($p - 1)) + ($n % $p);\n\
    }\n", "  if ($n < 0) {\n    $n = -$n;\n    $p = $p - 1;\n  }\n  if ($n == 0 ||\
    \ $p == 0) return 1;\n  if ($n == $p) return $n;\n  if ($p == 1) return $n;\n\
    \  if ($p % 2 == 0) {\n    return $n - (modp($n, $p - 2));\n  } else {\n    return\
    \ $n - modp($n, $p - 2);\n  }\n}\n", "  return intval($n * $p % $p + $p / abs($p));\n\
    }\n", "  return\n    ((($n & ($p - 1)) === 0) ? $n : $n % $p) & ~((($p - 1) >>\
    \ 1) + 1);\n}", "  if (!$p) {\n    return $n;\n  }\n  $result = pow($n, $p % 4);\n\
    \  return $result < $n ? $result : ($result - pow($result, 4));\n}", "  $nModP\
    \ = $n % $p;\n  if ($nModP == 0) {\n    return $p; // 0^0 mod p = p\n  } elseif\
    \ ($nModP < 0) {\n    return -modp($n, $p); // -(p^-1 mod p) = p^-1 mod p\n  }\n\
    \  return modp($nModP, $p); // p^nModP mod p\n}", "    return $n % ($p - 1);\n\
    }\n", "  if ($n === 0) {\n    return 0;\n  }\n  if ($p === 1) {\n    return $n;\n\
    \  }\n  $modp = bcmod($n / $p, $p);\n  if ($modp === 0) {\n    $modp = 1;\n  }\n\
    \  return $modp;\n}\n", "  return $n % $p == 0 ? ($n % $p + ($p / abs($p) - 1))\
    \ % $p : $n % $p;\n}\n", "  return (int) pow($n, $p) % $p;\n}\n", "    $n = (integer)\
    \ $n;\n    $p = (integer) $p;\n\n    if ($n < 0 || $p < 0) {\n        return null;\n\
    \    }\n\n    if ($n == 0) {\n        return $p;\n    }\n\n    if ($n == 1) {\n\
    \        return $n;\n    }\n\n    $x = $n * 2;\n    $r = $p % $x;\n\n    if ($r\
    \ == 0) {\n        return $n;\n    }\n\n    if ($r != $x) {\n        return null;\n\
    \    }\n\n    while ($r != 0) {\n        $r = $p / $x;\n        $x *= $x;\n  \
    \      $n--;\n    }\n\n    return $n % $p;\n}\n", "  return ($n - ($n % $p)) %\
    \ $p;\n}\n", "  return $n%$p;\n}\n", "  if (!$n) return $n;\n  return $n % $p;\n\
    }\n</code>\n<|/ a tags=php,modular-arithmetic |>\n<| c |>\nYes, I remember that.\
    \ The problem is that I can't use any loops, only ifs and if-else's. The function\
    \ is supposed to be used only by me\n<|/ c |>\n<| c |>\nOh ok, thanks! I missed\
    \ that fact sorry. The only other thing I can think of is some very weird mathematical\
    \ formula that would do it, but I have no idea what it would look like.\n<|/ c\
    \ |>\n<| c |>\nYou might try writing it as a formula on paper and then plugging\
    \ it into the function above, but this seems overly complicated.\n<|/ c |>\n<|\
    \ c |>\nI didn't think about that. I'll do that and see how it goes\n<|/ c |>\n\
    <| c |>\nI managed to figure it out, but I don't think it's the most efficient\
    \ way. I updated my post with the solution.\n<|/ c |>\n<| a dscore=1 tags=php,modular-arithmetic\
    \ |>\nYou can use the Modulo operator\n<code>\n<?php\n$x = 101;\n$y = 100;\n$z\
    \ = 90;\n$p = 5;\n$result = $x % $p;\necho $result;\n</code>\nThis will echo 2\
    \ because the remainder of a division of 101/5 is 2\n<|/ a |>\n<| a tags=php,modular-arithmetic\
    \ |>\nYou can implement it like this:\n<code>", "  // $r = $n >> 0;\n  // $m =\
    \ ($r + $p - 1) % $p;\n  // return $m >= $r ? $r : $m;\n  // for better performance\
    \ we can use this:\n  list($r, $m) = array($n >> 0, ($n + ($p - 1)) & $p);\n \
    \ return $m >= $r ? $r : $m;\n}\n</code>\n<|/ a |>\n<| c |>\nThanks for the help\
    \ and explanation. Your function works for positive numbers, however it doesn't\
    \ work for negative numbers. For example: modp(12, -3) returns 1. Any suggestions\
    \ would be appreciated. Thanks!\n<|/ c |>\n<| c |>\nFor negative numbers try this:\
    \ http://stackoverflow.com/questions/3963243/php-negative-number-mod-p\n<|/ c\
    \ |>\n<| a dscore=1 |>\nFor negative numbers, you can try this: PHP negative number\
    \ mod p\n<code>", "  $k = $n['gcd'] - $p['gcd'];\n  return $k ? $n['mod']($k)\
    \ : $n['mod']($p['mod']($k));\n}\n", "  if ($n <= 0) {\n    return 0;\n  }\n \
    \ $n = $n * $p;\n  $t = $n / $p;\n  $r = $n % $p;\n  return $r;\n}\n", "  return\
    \ pow($n, $p - 2, $p);\n}", "  return ($n % $p + $p) % $p;\n}\n", "  $r = 1;\n\
    \  while ($n % $p != 0) {\n    $r *= $p;\n    $n = floor($n / $p);\n  }\n  return\
    \ $r;\n}\n", "    $n = (int) $n;\n    $p = (int) $p;\n    $res = $n;\n\n    while\
    \ ($p > 0) {\n        if ($p & 1) $res = ($res * $n) %  $p;\n        $n = $n *\
    \ $n % $p;\n        $p >>= 1;\n    }\n\n    return $res;\n}\n", "  // Make sure\
    \ n is a non-negative integer, or set n to zero if\n  // n cannot be cast to a\
    \ non-negative integer.\n  // n is a negative integer if n cannot be cast to a\n\
    \  // non-negative integer.\n  if (!isset($n) || !is_int($n)) {\n    $n = 0;\n\
    \  }\n\n  // Make sure p is a positive integer.\n  if (!isset($p) || !is_int($p)\
    \ || $p < 0) {\n    return $n;\n  }\n\n  // If n is less than p, return n.\n \
    \ // Otherwise, return (p + n - 1) modulo p.\n  return ($n < $p) ? $n : ($p +\
    \ $n - 1) % $p;\n}\n", "  $n = intval($n);\n  $p = intval($p);\n  if ($n == 0\
    \ || $p == 0) {\n    return 1;\n  }\n  $q = bcdiv($p, $n, 20);\n  return ($q !==\
    \ intval($q)) ? intval($n) % $q : $n;\n}", "  return ($n % $p + $p) % $p;\n}\n",
  "  return $n % ($p << 32); // 32-bit precision\n}", "  return bcmod(bcpow(2, $n),\
    \ $p);\n}\n", "  return pow(2, $n) % $p;\n}\n", "\treturn ($n % $p) == 0 ? $n\
    \ : modp($n, $p - $n % $p);\n}\n", "    if ($n < 0 || $p <= 0)\n        throw\
    \ new MathException(\"Modulus must be positive and non-zero.\");\n\n    if ($p\
    \ === 1)\n        return $n;\n\n    $n2 = $n * 2;\n    while (true) {\n      \
    \  if ($p % $n2 === 0) {\n            return $n;\n        }\n\n        $p = $p\
    \ / $n2;\n        $n2 = $n * 2;\n    }\n}\n", "    $m = (int) ($p / $n);\n   \
    \ $r = ($p % $n);\n    if ($m == 0) {\n        return $r;\n    }\n    return $n\
    \ - ($m << $r);\n}\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work for all cases.\
    \ For example for n = 2 and p = 11 mod 10 is not 1, but for n = 2 and p = 0 mod\
    \ 10 is 1. That is not the right result for finding power of 2 modulo p. In fact,\
    \ the opposite is true for p = 0 mod 10. Also, this method doesn't work for negative\
    \ numbers.\n<|/ c |>\n<| c |>\nThis is also not correct: modp(101, 101) = 1, but\
    \ it should be 1.\n<|/ c |>\n<| a tags=php,modulus dscore=0 |>\nHere is a solution\
    \ that should work for all cases:\n<code>", "  return $n % $p + $p % $n;\n}\n",
  "    if ($n < 0 || $p == 0) {\n        return 0;\n    }\n    if ($n == 0 || $p ==\
    \ 1) {\n        return 1;\n    }\n    if ($p == $n) {\n        return 1;\n   \
    \ }\n    if ($p < $n) {\n        return ($n % $p) + modp($n - $n, $p);\n    }\
    \ else {\n        return ($n % $p);\n    }\n}", "  $n = $n % $p;\n  if ($n < 0)\
    \ return $p + $n;\n  return $n;\n}\n", "  if ($n == 0 || $n == 1)\n    return\
    \ $n;\n  return (($n % $p) + $p) % $p;\n}", "  if ($n < 0) {\n    return -1 *\
    \ modp($-n,$p);\n  }\n  if ($p < 2 || $p % 2 != 0) {\n    return $n % p;\n  }\n\
    \  $n_1 = $n * $n;\n  $p_1 = $p * $p;\n  while ($p_1 !~= 0) {\n    if ($n_1 &\
    \ $p_1) return $n_1 / $p_1;\n    $p_1 /= $p;\n    $n_1 /= $p;\n  }\n  return 1;\n\
    }\n", "    if ($n < 0 || $p < 0) {\n        return false;\n    }\n\n    $n = (int)\
    \ $n;\n    $p = (int) $p;\n\n    if ($n !== $p && $n%$p !== 0) {\n        return\
    \ false;\n    }\n\n    if ($n === $p) {\n        return 1;\n    }\n\n    $m =\
    \ (int) (sqrt($n) * tan(M_PI_OVER_2));\n    return ($m / $p);\n}\n", "    return\
    \ (int) ($n % $p + $p - 1) % $p;\n}\n</code>\n<|/ a dscore=2 tags=modular-arithmetic,php,algorithm\
    \ |>\n<| c |>\n+1 for providing a PHP solution.\n<|/ c |>\n<| a tags=modular-arithmetic,php,algorithm\
    \ |>\n<code>\n<?php\n$r = rand(10, 100); //random number between 10 and 100\n\n\
    $m= rand(pow(10, (int)log10($r)), pow(10, (int)log10($r)) - 1); //maximum modulus\
    \ possible\n\necho \"\\nModular division using modulus $m with random integer\
    \ $r : \";\n\nwhile ($r % $m != 0) { //loop until $r divides $m\n    $m *= 10;\n\
    }\n\necho \"$m\" . \" / \" . $r . \" = \" . ($r % $m);", "  // $n must be an integer.\n\
    \  if ($n % 1 != 0) throw new Exception('modp() only works with integers');\n\n\
    \  // $p must be an integer.\n  if ($p % 1 != 0) throw new Exception('modp() only\
    \ works with integers');\n\n  if ($n == 0) return 1;\n\n  $result = pow($n, $p\
    \ / 2);\n\n  if ($p % 2 == 1) return $result;\n\n  return $result % $p;\n}\n",
  "    $n1 = intval($n);\n    $p = intval($p);\n    $r = 1;\n\n    if ($n1 == 0) {\n\
    \        return 0;\n    }\n\n    if ($p == 0) {\n        return 1;\n    }\n\n\
    \    if ($n1 < $p) {\n        $r = pow($n, $p);\n        return $r % $p;\n   \
    \ } else {\n        return ($n % $p) + pow($p - $n, $p);\n    }\n}\n", "  if ($n\
    \ < 0) {\n    $n = (-$n) % $p;\n  }\n  return $n % $p;\n}\n", "  return $p > 0\
    \ ? $n % $p : $n % $p + $p;\n}\n", "  return pow($n, $p % $p);\n}\n", "    return\
    \ $n * pow(2, $p - 1);\n}\n</code>\n<|/ a |>\n<| c |>\nYes but what if n is big?\
    \ what if n is large? I cannot just do `pow(2, $p - 1)` because it is not an integer\
    \ value\n<|/ c |>\n<| c |>\nHow big do you need to be safe? I updated my answer\
    \ to show how to convert a `float` to an `int`.\n<|/ c |>\n<| c |>\nI updated\
    \ my question to include my requirements. I dont want to use strings. I need the\
    \ result to be a float, so I cannot use `floor()`\n<|/ c |>\n<| c |>\nIt doesn't\
    \ matter. You cannot \"do `pow(2, $p - 1)`\" because `pow(2, $p - 1)` is a *float*.\
    \ And if you want a *float*, you cannot use `pow()`, because `pow()` is an `int`-function.\n\
    <|/ c |>\n<| c |>\nMy comment was about the `pow()` function not being a valid\
    \ solution. Because it is `int`-function it doesnt return `float`-values. And\
    \ in my situation I cant use strings. I just want to calculate a modulo operation\
    \ using the modulo value and the number I am dividing by\n<|/ c |>\n<| a dscore=2\
    \ |>\nFor those who don't like math and just want a simple math, here's a quick\
    \ solution for you:\n<code>", "  return (int) ($n % $p);\n}\n", "    // Negative\
    \ modulo\n    if ($n % $p === 0) {\n        return $n % $p;\n    }\n\n    // Positive\
    \ modulo\n    if ($p % $n === 0 && $n % $p === 0) {\n        return $p;\n    }\n\
    \n    // Extremely large modulo (not possible)\n    if ($p % $n === 0 && $n %\
    \ $p === 0) {\n        throw new Exception('modp failed');\n    }\n\n    // Extremely\
    \ large modulo (not possible)\n    if ($p % $n !== 0 || $p < $n || $n !== 1) {\n\
    \        throw new Exception('modp failed');\n    }\n\n    // Zero\n    if ($n\
    \ === 0 || $p === 0) {\n        return $n;\n    }\n\n    return $n % $p;\n}\n",
  "    if ($n<0) return floor($n%$p);\n    if ($n==0) return 1;\n    if ($p==1) return\
    \ $n;\n    if ($p==0) return 0;\n    $ans=$n%$p;\n    if ($ans<$p/2) $ans+=($p-1)/($p-1);\n\
    \    return $ans;\n}\n", "    if ($p == 0) return 1;\n    if ($n == 0) return\
    \ 0;\n    if ($p == 1) return $n;\n    if ($n == 1) return $p;\n    $m = $n /\
    \ $p;\n    return ($n % $p == 0) ? $m : $p * modp($m, $p);\n}\n", "  if ($p <\
    \ 1) throw new Exception('$p < 1');\n  $x = $n % $p;\n  $x = $x === 0 ? $p : $x;\n\
    \  if ($n < $p) return $x;\n  if ($n < $p / 2) return $x + $p;\n  return $x;\n\
    }", "    if ($p == 0) {\n        return 1;\n    }\n    if ($n == 0) {\n      \
    \  return 0;\n    }\n    if ($n < 0) {\n        return modp($n * -1, $p) % $p;\n\
    \    }\n    if ($p == 1) {\n        return 1;\n    }\n    if ($p == 2) {\n   \
    \     return $n % 2 === 1;\n    }\n    if ($p == 3) {\n        return $n % 3 ===\
    \ 1;\n    }\n    if ($p == 6) {\n        return $n % 6 === 0;\n    }\n    if ($p\
    \ == 8) {\n        return $n % 8 === 0;\n    }\n    if ($p == 9) {\n        return\
    \ $n % 9 === 0;\n    }\n    if ($p == 10) {\n        return $n % 10 === 0;\n \
    \   }\n    if ($p == 12) {\n        return $n % 12 === 0;\n    }\n    if ($p ==\
    \ 14) {\n        return $n % 14 === 0;\n    }\n    if ($p == 16) {\n        return\
    \ $n % 16 === 0;\n    }\n    if ($p == 20) {\n        return $n % 20 === 0;\n\
    \    }\n    if ($p == 24) {\n        return $n % 24 === 0;\n    }\n    if ($p\
    \ == 28) {\n        return $n % 28 === 0;\n    }\n    if ($p == 32) {\n      \
    \  return $n % 32 === 0;\n    }\n    if ($p == 36) {\n        return $n % 36 ===\
    \ 0;\n    }\n    if ($p == 44) {\n        return $n % 44 === 0;\n    }\n    if\
    \ ($p == 48) {\n        return $n % 48 === 0;\n    }\n    if ($p == 60) {\n  \
    \      return $n % 60 === 0;\n    }\n    if ($p == 100) {\n        return $n %\
    \ 100 === 0;\n    }\n    if ($p == 200) {\n        return $n % 200 === 0;\n  \
    \  }\n    if ($p == 256) {\n        return $n % 256 === 0;\n    }\n    if ($p\
    \ == 512) {\n        return $n % 512 === 0;\n    }\n    if ($p == 1024) {\n  \
    \      return $n % 1024 === 0;\n    }\n    if ($p == 2048) {\n        return $n\
    \ % 2048 === 0;\n    }\n    if ($p == 4096) {\n        return $n % 4096 === 0;\n\
    \    }\n    if ($p == 8192) {\n        return $n % 8192 === 0;\n    }\n    if\
    \ ($p == 16384) {\n        return $n % 16384 === 0;\n    }\n    if ($p == 32768)\
    \ {\n        return $n % 32768 === 0;\n    }\n    if ($p == 65536) {\n       \
    \ return $n % 65536 === 0;\n    }\n    if ($p == 131072) {\n        return $n\
    \ % 131072 === ", "  return pow(2, $n) % $p;\n}", "  return ($n & $p - $n) % $p;\n\
    }", "\treturn ($p % $n) + $n % $p;\n}", "    $k = 0;\n    $n2 = $n * $n;\n   \
    \ $k = $n2 % $p;\n    return $k >= $p ? $n - $k : $k;\n}\n", "    return ((($n^$p)%$p)\
    \ & $p)%$p;\n}\n\n/**\n * Returns greatest common divisor of a and b.\n * If $n\
    \ is 0, returns 1.\n * See http://en.wikipedia.org/wiki/Euclidean_algorithm#Modular_integers\n\
    \ */", "  return ($n % $p) + (($n % $p) < ($p / 2));\n}\n", "  $result = pow($n,\
    \ $p) % $p;\n  if ($result < 0) {\n    $result += $p;\n  }\n  return $result;\n\
    }\n\n/**\n * Get a random integer between 0 and $upper - 1\n *\n * @param int\
    \ $upper\n * @return int\n */", "  // Check for negative n\n  if ($n < 0) return\
    \ $modp_negative($n, $p);\n  // Get the highest bit of n\n  $high_bit = 1 << $p->bits;\n\
    \  // If n has more than p (p->bits == 0)\n  if ($high_bit >= $n->value)\n   \
    \ // Then it's probably overflowing (we could return 0 here but would that work?)\n\
    \    return $n->value;\n  // Shift n to the right until it is less than p (p->bits\
    \ == 0)\n  // Then subtract p (p->bits == 0)\n  $shift = $high_bit - $n->value\
    \ - $p->bits;\n  return $n->value >> $shift - $p->bits;\n}\n\n/**\n * Returns\
    \ the number of bits of the given number that are set to 1.\n */", "    return\
    \ (int) ($n % $p);\n}\n", "  // Check if $n and $p are integers; if not, throw\
    \ an Exception.\n  if ($n == 0 || $p == 0) {\n    throw new Exception('mod: Arguments\
    \ must be integers');\n  }\n  // Return $n modulo p.\n  return $n % $p;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nI used `array_merge()` instead, as this was a little faster\
    \ than `array_push()` and doesn't have extra copies of elements. `array_push()`\
    \ was slower on large arrays though.\n<|/ c |>\n<| c |>\nI'm curious, how did\
    \ you determine this? I've never used array_merge() before. Just curious.\n<|/\
    \ c |>\n<| c |>\nI did a quick benchmark, and `array_push()` was faster than `array_merge()`\
    \ for small arrays but not for large arrays. I think I've just discovered the\
    \ difference between array_push() and array_merge(), and that `array_push()` is\
    \ faster. http://pastebin.com/f39706875 shows the results for an array size of\
    \ 10000000 and 10000001. The array_push() version is around 50ms slower, but the\
    \ array_merge() version is about 20ms faster. I'll update my answer to include\
    \ this.\n<|/ c |>\n<| c |>\n+1 Good point. Haven't tested it on large arrays,\
    \ but it does look like a good alternative. I'm curious how you figured that out\
    \ though.\n<|/ c |>\n<| c |>\nI used `array_push()` instead of `array_merge()`\
    \ because `array_push()` didn't create a whole new array, just a new element at\
    \ the end of the array. Since I only needed the new element I used `array_merge()`\
    \ and it took only a few milliseconds to run. Plus, `array_merge()` wasn't working\
    \ at all for my array, so I used `array_push()` and it worked.\n<|/ c |>\n<| a\
    \ tags=arrays,php |>\nYou could use the array_filter() method to filter the array\
    \ down to those items that have the key you want to remove. This method will create\
    \ a new array for you though, so you may have to make a new array:\n<code>\n$array\
    \ = array('one', 'two', 'three', 'four', 'five');\n$key = 'three';\n$filteredArray\
    \ = array_filter($array, function($item) use ($key) {\n    return !in_array($key,\
    \ $item);\n});\nvar_dump($filteredArray);\n</code>\nOutput:\n<code>\narray(1)\
    \ {\n  [2]=>\n  string(3) \"two\"\n}\n</code>\n<|/ a dscore=", "    return $n\
    \ % $p;\n}\n", "  return pow($p, $n % $p);\n}\n", "    return ($n % $p) + $p;\n\
    }\n", "  return ($n % $p) + $p;\n}", "  return $n % $p;\n}\n", "  return $n%$p;\n\
    }\n"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
