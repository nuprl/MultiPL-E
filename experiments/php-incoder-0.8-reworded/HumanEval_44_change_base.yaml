name: HumanEval_44_change_base
language: php
prompt: "<?php\n// Change numerical base of input number x to base.\n// return string\
  \ representation after the conversion.\n// base numbers are less than 10.\n// >>>\
  \ change_base(8, 3)\n// \"22\"\n// >>> change_base(8, 2)\n// \"1000\"\n// >>> change_base(7,\
  \ 2)\n// \"111\"\nfunction change_base($x, $base) {\n"
tests: "function candidate(...$args) {\n    return change_base(...$args);\n}\n\nfunction\
  \ test(): void {\n    if (candidate(8, 3) !== \"22\") { throw new Exception(\"Test\
  \ failed!\"); }\n    if (candidate(9, 3) !== \"100\") { throw new Exception(\"Test\
  \ failed!\"); }\n    if (candidate(234, 2) !== \"11101010\") { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(16, 2) !== \"10000\") { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(8, 2) !== \"1000\") { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(7, 2) !== \"111\") { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(2, 3) !== \"2\") { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(3, 4) !== \"3\") { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(4, 5) !== \"4\") { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(5, 6) !== \"5\") { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(6, 7) !== \"6\") { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(7, 8) !== \"7\") { throw new Exception(\"\
  Test failed!\"); }\n}\n\ntest();"
completions: ["    $result = \"\";\n    while ($x > $base) {\n        $result .= ($x\
    \ % $base);\n        $x = floor($x / $base);\n    }\n    $result .= ($x);\n  \
    \  return $result;\n}\n", "    $digits = str_pad('', $base, '0', STR_PAD_LEFT);\n\
    \    $x = str_pad($x, $base, '0', STR_PAD_LEFT);\n    return $digits[intval($x\
    \ / $base)];\n}\n", "    return base_convert($x, 10, $base);\n}\n", "    if ($base\
    \ < 0 || $base > 9)\n        throw new Exception(\"Illegal base: $base\");\n\n\
    \    $n = 0;\n    $str = strval($x);\n    $len = strlen($str);\n    while($len)\
    \ {\n        $n = $n % $base;\n        $x = floor($x/$base);\n        $str = substr(\"\
    $str\", $n, 1).$x;\n        $len = strlen($str);\n    }\n\n    return $x;\n}",
  "  $num = base_convert($x, 10, $base);\n  return base_convert($num, 10, $base);\n\
    }\n\n$digits = str_pad('', strlen('111111111111'), '1') . str_pad('', strlen('111111111111'),\
    \ '1');\n$digits = str_replace('1', '0', $digits);\n$digits = str_replace('0',\
    \ '1', $digits);\n$digits = str_pad('', strlen('111111111111'), '1');\n$digits\
    \ = str_replace('1', '0', $digits);\n$digits = str_replace('0', '1', $digits);\n\
    $digits = str_pad('', strlen('111111111111'), '1');\n$digits = str_replace('1',\
    \ '0', $digits);\n$digits = str_replace('0', '1', $digits);\n$digits = str_pad('',\
    \ strlen('111111111111'), '1');\n$digits = str_replace('1', '0', $digits);\n$digits\
    \ = str_replace('0', '1', $digits);\n$digits = str_pad('', strlen('111111111111'),\
    \ '1');\n$digits = str_replace('1', '0', $digits);\n$digits = str_replace('0',\
    \ '1', $digits);\n$digits = str_pad('', strlen('111111111111'), '1');\n$digits\
    \ = str_replace('1', '0', $digits);\n$digits = str_replace('0', '1', $digits);\n\
    $digits = str_pad('', strlen('111111111111'), '1');\n$digits = str_replace('1',\
    \ '0', $digits);\n$digits = str_replace('0', '1', $digits);\n$digits = str_pad('',\
    \ strlen('111111111111'), '1');\n$digits = str_replace('1', '0', $digits);\n$digits\
    \ = str_replace('0', '1', $digits);\n$digits = str_pad('', strlen('111111111111'),\
    \ '1');\n$digits = str_replace('1', '0', $digits);\n$digits = str_replace('0',\
    \ '1', $digits);\n$digits = str_pad('', strlen('111111111111'), '1');\n$digits\
    \ = str_replace('1', '0', $digits);\n$digits = str_replace('0', '1', $digits);\n\
    $digits = str_pad('', strlen('111111111111'), '1');\n$digits = str_replace('1',\
    \ '0', $digits);\n$digits = str_replace('0', '1', $digits);\n$digits = str_pad('',\
    \ strlen('111111111111'), '1');\n$digits = str_replace('1', '0', $digits);\n$digits\
    \ = str_replace('0', '1', $digits);\n$digits = str_pad('', strlen('111111111111'),\
    \ '1');\n$digits = str_replace('1', '", "\t$s = \"\";\n\twhile (strlen($x) > 0)\
    \ {\n\t\t$s = str_pad(base_convert(substr($x, 0, 1), $base, 10), $base, $base,\
    \ $s);\n\t\t$x = substr($x, 1, -1);\n\t}\n\treturn $s;\n}\n", "  // Convert $x\
    \ to an array of digits in base $base.\n  $x = strrev($x);\n  $digits = strspn($x,\
    \ strrev($base));\n  $digits = str_pad('', $digits, '0', STR_PAD_LEFT);\n  $x\
    \ = str_pad('', strlen($x) + $digits, '0', STR_PAD_LEFT);\n\n  // Reverse the\
    \ digits to create the string.\n  $s = strrev($digits);\n\n  // Add leading zeros.\n\
    \  $s = str_pad($s, strlen($base) + strlen($x), '0', STR_PAD_LEFT);\n  return\
    \ strrev($s);\n}\n", "  if ($x < 10) return $x;\n  $r = $x;\n  for ($i = 1; $i\
    \ < $base; $i++) $r *= $base;\n  return $r;\n}\n", "  if ($base < 1 || $base >\
    \ 10) {\n    die(\"Base must be between 1 and 10.\");\n  }\n\n  return ($x - $base\
    \ * floor($x / $base));\n}", "    // Convert to a string to avoid errors with\
    \ floats.\n    $x = sprintf('%.0f', $x);\n    // Use logarithm to avoid rounding\
    \ errors while doing the math.\n    $x = log($x);\n    // Use decimal logarithm\
    \ to avoid rounding errors while doing the math.\n    $x = ldexp($x, $base);\n\
    \    // Convert back to a number.\n    return sprintf('%.0f', $x);\n}\n</code>\n\
    EDIT: Here is a test case for the above.  It seems to work fine for both negative\
    \ and positive numbers.  I have also added some comments to help explain what\
    \ each step is doing.\n<code>", "  $x = $x * $base;\n  if ($x < 0) {\n    $x +=\
    \ $base;\n  }\n  return $x;\n}", "  // base is the new base\n  global $base_tens;\n\
    \  if ($x < 10) {\n    if ($base_tens[$base][$x]) {\n      return $base_tens[$base][$x];\n\
    \    } else {\n      return '';\n    }\n  } else {\n    // base is a positive\
    \ number.\n    $negative = $x % $base;\n    if ($negative < 0) {\n      // x is\
    \ negative base ten.\n      return $change_base($negative, $base);\n    } else\
    \ {\n      // x is positive base ten.\n      // find smallest base.\n      $min\
    \ = 1;\n      for ($i = 0; $i < $base; $i++) {\n        if ($base_tens[$i][$x])\
    \ {\n          $min = $i;\n        }\n      }\n      // x is base ten, add $min.\n\
    \      if ($min == $base) {\n        return $base_tens[$min][$x];\n      } else\
    \ {\n        return $change_base($x + $min, $base);\n      }\n    }\n  }\n}\n",
  "    $str = $x;\n    while ($base > 1) {\n        if ($x > 0) {\n            $x\
    \ = $x/$base;\n            $str = (string)($x).$str;\n        }\n        $base\
    \ = $base/10;\n    }\n    return $str;\n}\n", "  $r = \"\";\n  $a = $x;\n  do\
    \ {\n    if ($a > 9) {\n      $r = $r . $a % $base;\n      $a = (int)($x / $base);\n\
    \    } else {\n      $r = $r . chr($a);\n      break;\n    }\n  } while ($a >\
    \ 0);\n  return $r;\n}\n", "  $base = intval($base);\n  if (!is_numeric($base)\
    \ || $base < 1 || $base > 10) {\n    return 'N/A';\n  }\n  if ($x == 0) {\n  \
    \  return 0;\n  }\n\n  $digits = '';\n  while ($x > 1) {\n    $divrem = ($x %\
    \ $base);\n    $digits = $base.$digits;\n    $x = floor($x / $base);\n  }\n  return\
    \ $digits . str_repeat('0', $x - $divrem);\n}\n</code>\n<|/ a |>\n<| a tags=converter,php,numbers\
    \ |>\nThe most elegant way would be to use PHP's string formatting:\n<code>\n\
    echo sprintf(\"%05d\", $number);\n</code>\nThe output will be of the format 00000001\n\
    <|/ a dscore=2 |>\n<| a tags=converter,php,numbers |>\n<code>\n<?php\n$number\
    \ = 12345;\necho sprintf(\"%05d\", $number);", "    if ($base >= 2 && $base <\
    \ 10) {\n        $x = strval($x * pow(10, $base));\n        $base = $base * 10;\n\
    \    } else if ($base > 10) {\n        return $x;\n    }\n    $x = intval($x /\
    \ $base);\n    $base = $base * 10;\n    return $x . $base;\n}\n", "    $digits\
    \ = str_split($x);\n    $newBase = str_split($base);\n\n    $newBase = array_fill(0,\
    \ count($digits), 0);\n\n    for ($i = 0; $i < count($digits); ++$i) {\n     \
    \   $newBase[$i] = $newBase[$i] + $digits[$i] * $newBase[count($newBase) - 1];\n\
    \    }\n\n    $res = \"\";\n    for ($i = count($newBase) - 1; $i >= 0; --$i)\
    \ {\n        $res .= chr($newBase[$i]);\n    }\n\n    return $res;\n}", "    $res\
    \ = $x;\n    while ($base) {\n        if ($base > 36) {\n            $base -=\
    \ 36;\n            $res *= $base;\n        } else {\n            $res *= $base;\n\
    \            break;\n        }\n    }\n    return $res;\n}", "    if ($base >\
    \ 0 && $base < 10) {\n        return base_convert($x, 10, $base);\n    }\n   \
    \ return null;\n}", "    $digits = '';\n    while ($x >= 0) {\n        $digits\
    \ = $x % $base;\n        $x = floor($x / $base);\n    }\n    $digits = str_pad($digits,\
    \ $base, '0', STR_PAD_BOTH);\n    return $digits;\n}\n</code>\n<|/ a tags=algorithm,php\
    \ |>\n<| a tags=algorithm,php |>\nHere is a simple solution.\n<code>\n<?php",
  "\t$str = strval($x);\n\t$len = strlen($str);\n\tif ($len < $base) {\n\t\t$len =\
    \ $base;\n\t}\n\tif ($len > $base) {\n\t\t$str = str_pad($str, $len, 0, '0');\n\
    \t}\n\treturn $str;\n}\n", "  $result = \"\";\n  // We use a loop to avoid a bug\
    \ in PHP where $x is converted to an int\n  // by adding zero, so that $x is now\
    \ the value \"017\" instead of \"17\".\n  for ($i = 0, $x_length = strlen($x);\
    \ $i < $x_length; $i++) {\n    $result = $base * $result + ord($x[$i]);\n  }\n\
    \  return $result;\n}\n\n$base = array('0', '1', '2', '3', '4', '5', '6', '7',\
    \ '8', '9');\n\n$base10 = array('0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\
    \ 'A', 'B', 'C', 'D', 'E', 'F');\n\n$base16 = array('0', '1', '2', '3', '4', '5',\
    \ '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z');\n", " \
    \   $_x = $x;\n    while($_x) {\n        $_x = $base * $_x + $_x%$base;\n    }\n\
    \    return $_x;\n}\n", "  $base = str_pad($base, $x, '0', STR_PAD_RIGHT);\n \
    \ $result = substr($x, strlen($base));\n  $result = (int) $result;\n  return $result;\n\
    }\n</code>\nI only tested the function with base 10, but you can easily adapt\
    \ the function to handle base of base 10. Feel free to ask any questions if you\
    \ need more help.\n<|/ a dscore=1 tags=php,numbers,base-conversion |>\n<| a |>\n\
    I took David's answer and made it a bit more generic, so you can choose the base\
    \ you want to work in. It also allows you to pass a string instead of an int,\
    \ which may be useful for calculating with strings in different bases.\n<code>",
  "  $x = strval($x); // \"08\" => \"08\"\n  return base_convert($x, 10, $base); //\
    \ \"22\" => 22\n}", "    $base = $base < 10 ? $base : 10;\n    $res = '';\n  \
    \  while ($x) { $res = base_convert($x, $base, $base) + $res; $x /= $base; }\n\
    \    return $res;\n}", "  $res = '';\n  for ($i = strlen($x); $i; $i--) {\n  \
    \  $res = $res * $base + $x{($i - 1)};\n  }\n  return $res;\n}\n", "  return ($x\
    \ < 10) ? ($x * $base) : ($x / $base);\n}", "    if ($x < 10) {\n        $result\
    \ = '' . $x;\n    } elseif ($x < 100) {\n        $result = $base . substr($x,\
    \ 1);\n        $x        = substr($x, 2);\n    } else {\n        $result = $base\
    \ . substr($x, 0, 2);\n        $x        = substr($x, 2);\n    }\n    $base  \
    \  = str_pad('', $base, '0', STR_PAD_LEFT);\n    $digits  = str_split($base);\n\
    \    $zeroes = 0;\n    foreach ($digits as $digit) {\n        $zeroes += $digit;\n\
    \    }\n    $zeroes++;\n    if ($zeroes > strlen($result)) {\n        $zeroes\
    \ = 1;\n    }\n    $result .= str_pad('', $zeroes, '0', STR_PAD_LEFT);\n    return\
    \ $result;\n}\n", "    $x = $x * $base;\n    $x0 = $x % $base;\n    $x1 = floor($x\
    \ / $base);\n    return $x1 . $x0;\n}\n", "    $sign = $x < 0 ? \"-\" :\"\";\n\
    \    $x *= $base;\n    $x = intval($x); // Convert to int to avoid float issues.\n\
    \    $decimals = strlen($x) - strrpos($x, \".\");\n    $decimals += strlen($x)\
    \ < abs($base) ? 0 : 1;\n    return $sign * $x . \"0\";\n}\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nI really like this one. It also has the benefit of being able to\
    \ handle floats.\n<|/ c |>\n<| c |>\nIt should be noted that this will return\
    \ an incorrect string if there is a decimal point in the input number. e.g. `change_base(8.3,\
    \ 2)` will return `8300` instead of `8.30`\n<|/ c |>\n<| c |>\n, thanks, I added\
    \ an update to address decimal point problems (I didn't notice it when I first\
    \ wrote the code).\n<|/ c |>\n<| c |>\nThanks so much! I added a base of 0 (for\
    \ hex) to deal with negative bases as well. I also added a check to see if $base\
    \ is < 0 and if it is, it prepends a minus sign.\n<|/ c |>\n<| c |>\nI made a\
    \ slight modification to this to allow for negative bases also\n<|/ c |>\n<| a\
    \ dscore=5 tags=base-conversion,base,php,number-formatting |>\nThis question doesn't\
    \ have a simple answer so I thought I'd post my own answer.\nHere's a PHP function\
    \ for converting a number from one base to another base. This is a simple implementation\
    \ that also supports negative numbers.\n<code>", "  $digits = str_split($x);\n\
    \  $new = $base;\n  foreach ($digits as $key => $digit) {\n    if ($digit < $base)\
    \ {\n      $new .= $digit . \"0\";\n    } else {\n      $new .= $digit . \"1\"\
    ;\n    }\n  }\n  return $new;\n}\n</code>\n<|/ a tags=math,php dscore=1 |>\n<|\
    \ a dscore=1 |>\nThis is a working solution for PHP7.\n<code>\n<?php", "  return\
    \ ltrim(base_convert($x, $base, '', ''), '0');\n}\n</code>\n<|/ a |>\n<| c |>\n\
    Thanks for your answer. I checked out the link and it helped me figure out how\
    \ to do this in javascript! I edited my post to include my solution. It also helped\
    \ me figure out how to do the base conversion using php (I used base_convert()).\n\
    <|/ c |>\n<| a tags=php,base-conversion |>\nI made this javascript function for\
    \ converting number between base 10 and base 36:\n<code>", "    $bases = array('10'\
    \ => '', 'b' => '', 'o' => '', 'e' => '', 'x' => '', '8' => '', '9' => '', 'a'\
    \ => '');\n    return $bases[$base][$x];\n}\n", "  $digits = strlen($x);\n  $base--;\n\
    \  if ($digits < $base) {\n    return $x;\n  }\n  $base = strlen($base);\n  $digits\
    \ = strlen($digits);\n  $ret = '';\n  for ($i = 0; $i < $digits; $i++) {\n   \
    \ $ret .= ($x[$i] / $base) % ($base == 10 ? 10 : $base);\n  }\n  return $ret;\n\
    }", "    $base = intval($base);\n    if ($base < 2 or $base > 10) {\n        return\
    \ $x;\n    }\n    $y = 0;\n    while ($x < $base) {\n        $y++;\n        $x\
    \ /= $base;\n    }\n    return $y;\n}\n", "    if ($x < 10) {\n        return\
    \ $x;\n    }\n    $n = array_reverse(str_split($x, $base - 1));\n    return implode($n);\n\
    }", "  $base = (int) $base;\n  $digits = str_split($x);\n  $res = \"\";\n  for\
    \ ($i = count($digits) - 1; $i >= 0; $i--) {\n    $res = $digits[$i] . $res;\n\
    \    if ($base < strlen($res)) {\n      return $res;\n    }\n    $res = substr($res,\
    \ 0, $base);\n  }\n  return $res;\n}", "    $ret = '';\n    $digits = intdiv($x,\
    \ $base);\n    $mod =  $x / $base;\n    do {\n        $mod = $mod * $base;\n \
    \       $ret = $digits + $ret;\n        $digits = intdiv($mod, $base);\n    }\
    \ while ($digits > 0);\n    return $ret;\n}\n</code>\n<|/ a tags=php,math |>\n\
    <| a |>\nI know this question is old, but I was looking for a simple way to do\
    \ this and found a way that works. \nMy solution was to convert the given number\
    \ to binary and then get the sum of the binary digits. \nI used this formula:\n\
    <code>\n$sumOfBinaryDigitsOfNumber = ($number - 1) % 2 + $number / 2;\n</code>\n\
    I hope this helps others.\n<|/ a tags=php,math dscore=3 |>\n<| c |>\nFor anyone\
    \ stumbling across this answer, here's a [PHP implementation](http://stackoverflow.com/a/18107761/1366033)\
    \ of this.\n<|/ c |>\n<| a |>\nI did this to check numbers between 1 and 1000\
    \ and it was the fastest way:\n<code>\n<?php\n", "\tglobal $php_errormsg;\n\t\
    static $num = null;\n\tstatic $num_base = array(\n\t\t1 => 0,\n\t\t2 => 1,\n\t\
    \t3 => 2,\n\t\t4 => 3,\n\t\t5 => 4,\n\t\t6 => 5,\n\t\t7 => 6,\n\t\t8 => 7,\n\t\
    \t9 => 8,\n\t\t10 => 9,\n\t\t11 => 10,\n\t\t12 => 11,\n\t\t13 => 12,\n\t\t14 =>\
    \ 13,\n\t\t15 => 14,\n\t\t16 => 15,\n\t\t17 => 16,\n\t\t18 => 17,\n\t\t19 => 18,\n\
    \t\t20 => 19,\n\t\t21 => 20,\n\t\t22 => 21,\n\t\t23 => 22,\n\t\t24 => 23,\n\t\t\
    25 => 24,\n\t\t26 => 25,\n\t\t27 => 26,\n\t\t28 => 27,\n\t\t29 => 28,\n\t\t30\
    \ => 29,\n\t\t31 => 30,\n\t\t32 => 31,\n\t\t33 => 32,\n\t\t34 => 33,\n\t\t35 =>\
    \ 34,\n\t\t36 => 35,\n\t\t37 => 36,\n\t\t38 => 37,\n\t\t39 => 38,\n\t\t40 => 39,\n\
    \t\t41 => 40,\n\t\t42 => 41,\n\t\t43 => 42,\n\t\t44 => 43,\n\t\t45 => 44,\n\t\t\
    46 => 45,\n\t\t47 => 46,\n\t\t48 => 47,\n\t\t49 => 48,\n\t\t50 => 49,\n\t\t51\
    \ => 50,\n\t\t52 => 51,\n\t\t53 => 52,\n\t\t54 => 53,\n\t\t55 => 54,\n\t\t56 =>\
    \ 55,\n\t\t57 => 56,\n\t\t58 => 57,\n\t\t59 => 58,\n\t\t60 => 59,\n\t\t61 => 60,\n\
    \t\t62 => 61,\n\t\t63 => 62,\n\t\t64 => 63,\n\t\t65 => 64,\n\t\t66 => 65,\n\t\t\
    67 => 66,\n\t\t68 => 67,\n\t\t69 => 68,\n\t\t70 => 69,\n\t\t71 => 70,\n\t\t72\
    \ => 71,\n\t\t73 => 72,\n\t\t74 => 73,\n\t\t75 => 74,\n\t\t76 => 75,\n\t\t77 =>\
    \ 76,\n\t\t78 => 77,\n\t\t79 => 78,\n\t\t80 => 79,\n\t\t81 => 80,\n\t\t82 => 81,\n\
    \t\t83 => ", "  $x = intval($x);\n  $base = intval($base);\n  if ($base > strlen($x))\
    \ {\n    throw new Exception(\"Base is greater than base($x).\");\n  }\n  $y =\
    \ 0;\n  while ($base > 0) {\n    $y = $y * 10 + ($x % $base);\n    $x = floor($x\
    \ / $base);\n    $base--;\n  }\n  return $y;\n}\n", "    if ($base < 2 || $base\
    \ > 10) {\n        $base = 10; // default\n    }\n    $basestr = '';\n    for\
    \ ($i = $base; $i >= 2; $i--) {\n        $basestr = ($i % 2 == 0) ? ($basestr\
    \ . '1') : ($basestr . '0');\n    }\n    $xstr = '';\n    for ($i = strlen($x);\
    \ $i >= 0; $i--) {\n        $xstr = ($x % $i) == 0 ? ($xstr . $basestr) : (($xstr\
    \ != 0) ? '1' : '');\n    }\n    return $xstr;\n}", "    $base2 = pow(10, $base);\n\
    \    return $base2 * $x - $base2;\n}\n", "  $base = $base < 0 ? 0 : $base;\n \
    \ $x    = intval($x);\n  $n    = $x - (intval($x) / intval($base));\n  return\
    \ $n * (pow($base, $base));\n}\n", "  $base = base_convert($x, $base, $base);\n\
    \  while($base >= 10) {\n    $x = floor($x/10);\n    $base = base_convert($x,\
    \ $base, $base);\n  }\n  return $base;\n}\n</code>\n<|/ a tags=php,algorithm |>\n\
    <| c |>\nThe base is *not* a power of 2. He is talking about converting decimal\
    \ numbers.\n<|/ c |>\n<| c |>\nOops, sorry, missed that in the question.  Updated.\n\
    <|/ c |>\n<| c |>\nThe base isn't a power of 2. He is talking about converting\
    \ decimal numbers.\n<|/ c |>\n<| c |>\nYou're right, I missed that.  Updated.\n\
    <|/ c |>\n<| c |>\n: I see - you beat me to it. Your solution works well enough\
    \ to accept decimal input (I haven't even looked at efficiency, but it is simple\
    \ and straightforward.)\n<|/ c |>\n<| a dscore=1 |>\nHere is another way (although\
    \ I'm not sure if it is more efficient or not):\n<code>", "  $base = min($base,\
    \ $x);\n  $num = '';\n  while ($base > 0) {\n    $num.=chr($x%$base);\n    $x\
    \ = floor($x/$base);\n    $base--;\n  }\n  $num.=chr($x);\n  return $num;\n}\n\
    </code>\n<|/ a tags=php |>\n<| c |>\nThis is probably the simplest way to do it,\
    \ but a little confusing since it converts strings instead of numbers. I'm also\
    \ not very familiar with recursive functions, but this may work as well. I'm going\
    \ to test it and see how it works out.\n<|/ c |>\n<| c |>\nThis was my first thought\
    \ too, but I figured that it would be a lot more efficient to just subtract the\
    \ base until the number is less than zero. O(log n) instead of O(n).\n<|/ c |>\n\
    <| c |>\nOk, I'll post my modified version for comparison.\n<|/ c |>\n<| c |>\n\
    I appreciate all your help. The first function you gave me was the easiest to\
    \ understand, even though I like the other recursive methods better.\n<|/ c |>\n\
    <| a dscore=2 tags=php |>\nIf you're trying to keep it simple and don't mind a\
    \ little bit of extra code, you could use a for loop:\n<code>", "  global $alphabet;\n\
    \n  if (!isset($alphabet[$base])) return 'Invalid base';\n\n  return base_convert($x,\
    \ 10, $alphabet[$base]);\n}\n\n/**\n * Convert base from number to string.\n *\
    \ base numbers are less than 10.\n * >>> convert_base(10, 2)\n * \"100\"\n * >>>\
    \ convert_base(8, 3)\n * \"22\"\n * >>> convert_base(16, 2)\n * \"10\"\n */",
  "    $base = (int) $base;\n    if ($base < 2) $base = array(2, 8, 10);\n    $digits\
    \ = array();\n    while ($x >= 0) {\n        $digits[] = $x % $base;\n       \
    \ $x = floor($x / $base);\n    }\n    return implode('', array_reverse($digits))\
    \ . $base[$base];\n}\n", "  global $digits;\n  if ($x < 10 && $base > 0)\n   \
    \ return $x;\n  $r = \"\";\n  while ($x != 0) {\n    $r = $digits[$x % $base]\
    \ + $r;\n    $x = floor($x / $base);\n  }\n  return $r;\n}\n", "    if ($x ==\
    \ 0) return \"0\";\n    if ($x < 0) $x = abs($x);\n    $result = '';\n    $factor\
    \ = 2;\n    while (true) {\n        if ($x >= $base) {\n            $result +=\
    \ $x % $base;\n            $x = floor($x / $base);\n            $factor *= $base;\n\
    \        } else {\n            $x = $x - $base * floor($x / $factor);\n      \
    \      if ($x == 0) break;\n            $result += $x;\n        }\n    }\n   \
    \ return $result;\n}\n", "    if ($x < 10) {\n        return $x;\n    }\n    $x_str\
    \ = (string) $x;\n    $base = int($base);\n    if ($base == 10) {\n        $base_str\
    \ = '';\n    }\n    else {\n        $base_str = str_repeat($base, $x_str);\n \
    \   }\n    return $base_str . ($x_str > $base ? 1 : 0);\n}\n", "  $divbase = intval($x\
    \ / $base);\n  return $base * $divbase;\n}\n", "  do {\n    $result = bcmod($x,\
    \ $base);\n    $x = bcdiv($x, $base, 0);\n  } while (bccomp($x, 0) == 0);\n  return\
    \ $result;\n}\n", "    $ret = '';\n    $len = strlen($x);\n    for ($i=0; $i<$len;\
    \ $i++) {\n        if ($x[$i] >= '0' && $x[$i] <= '9') {\n            $ret .=\
    \ $x[$i];\n        } else {\n            $ret .= $base;\n        }\n    }\n  \
    \  return $ret;\n}\n", "  $base_len = strlen($base);\n  $res = \"\";\n  do {\n\
    \    $d = floor($x / $base);\n    $res = $base * $d + $res;\n    $x -= $d * $base;\n\
    \  } while($x >= 1);\n  return $res;\n}", "    $str = base_convert($x, 10, $base);\n\
    \    return str_pad($str, strlen($str));\n}\n", "  $s = '';\n  while ($x > 0)\
    \ {\n    $last_digit = intval($x % $base);\n    $x = $x / $base;\n    $s = $last_digit\
    \ . $s;\n  }\n  return $s;\n}\n", "    $x *= $base;\n    $digits = preg_replace_callback(\"\
    /(\\d+)([a-z]+)/\", function ($matches) {\n        return ($matches[1] * $base)\
    \ + $matches[2];\n    }, $x);\n    return $digits;\n}\n", "  $base = 10; // Make\
    \ sure base is always 10\n  $result = $x / $base;\n  $digit = 0;\n  if ($result>0)\
    \ $digit++;\n  $result -= $digit * $base;\n  $base = $base * $base;\n  if ($result\
    \ >= $base) {\n    return $result;\n  } else {\n    return $digit + $base;\n \
    \ }\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\nI thought I'd share how I solved\
    \ this, which I admit, I was surprised I couldn't find the answer elsewhere.\n\
    It's an extremely simple one-liner (for me at least). And I did it using PHP 7.x\
    \ and the intl extension (which I have enabled in my php.ini file).\nI simply\
    \ created a new function called baseConvert() and called it like this:\n<code>\n\
    <?php\n    $num = baseConvert(\"10011112112222\");", "\t$newbase = 10**$base;\n\
    \treturn $newbase * $x;\n}\n", "    if ($x < 0 || $base < 0 || $base > 10) {\n\
    \        throw new \\InvalidArgumentException('Invalid value');\n    }\n    if\
    \ ($base == 10) {\n        return $x;\n    }\n    $x = $x / $base;\n    $remainder\
    \ = $x % $base;\n    return $base == 10 ? $x : (10 * $base + $remainder);\n}\n\
    </code>\n<|/ a tags=php |>\n<| c |>\nThank you for your answer. Your code is correct\
    \ and was my first solution but I asked for a solution without loops (just pure\
    \ mathematical operations). Anyway thank you for your help anyway.\n<|/ c |>\n\
    <| a dscore=0 |>\nHere is a functional version using the functional programming\
    \ library Haskell and the functions fromEnum and toEnum. These are from Data.Enum\
    \ where you can find documentation on how they are used.\n<code>\nimport Data.Function\
    \ (on)\n\ngetBase10 :: (Enum a => a) -> Int -> a\ngetBase10 x base = fromEnum\
    \ (x `on` toEnum base) :: Int\n\ngetBase10 7 2\n-- 1000\n\ngetBase10 7 3\n-- 1001\n\
    </code>\nHere is the same function with the Haskell syntax:\n<code>\nimport Data.Function\
    \ (on)\n\ngetBase10 :: (Enum a => a) -> Int -> a\ngetBase10 x base = fromEnum\
    \ (x `on` toEnum base) :: Int\n</code>\nHere is the same function using PHP:\n\
    <code>", "  if ($base < 2) return $x;\n  $str = strval($x);\n  $base = strval($base);\n\
    \  $digits = strlen($str) - 1;\n  if ($digits == 0) return $str;\n  $pow = strlen($base)\
    \ - 1;\n  $digits_before = strlen($str) - strlen(ltrim($str, '0'));\n  $digits_after\
    \ = strlen($str) - strlen(rtrim($str, '0'));\n  $res = '';\n  for ($i = 0; $i\
    \ < strlen($str); $i++) {\n    $d = $digits_before + $i;\n    $res .= str_pad(base_convert($str[$i],\
    \ $base, 10), $pow, 0, '0');\n  }\n  return $res;\n}", "\t$digits = (int)str_repeat('0',\
    \ $base);\n\tfor ($i = 0; $x < $digits; $i++) {\n\t\t$digits[$i] = $digits[$i]\
    \ . $x;\n\t}\n\treturn $digits;\n}\n", "    if ($x<0 || $x>9) {\n        return\
    \ \"\";\n    }\n    $sign = $x<0? \"-\":\"\";\n    $x = abs($x);\n    $base =\
    \ abs($base);\n    $str = '';\n    while ($x>0) {\n        $mod = (int)($x/$base);\n\
    \        $str = $mod*$base+$str+chr($mod+ord('0'));\n        $x = $mod;\n    }\n\
    \    return $sign+$str;\n}\n", "\t$digits = base_digits($x);\n\tif ($digits <\
    \ $base) {\n\t\t$x = $x - $digits*($base**$digits);\n\t}\n\treturn base_convert($x,\
    \ 10, $base);\n}", "    $ret = '';\n    if ($x < 10) {\n        $ret .= $x;\n\
    \    }\n    else {\n        while ($x >= $base) {\n            $x -= $base;\n\
    \            $ret .= $x;\n        }\n    }\n    return $ret;\n}\n</code>\n<|/\
    \ a tags=base,php,math |>\n<| c |>\nThe second `if` statement doesn't seem necessary\n\
    <|/ c |>\n<| a dscore=5 |>\nThe best solution that I came up with is:\n<code>",
  "    $r = $x % $base;\n    if ($r == 0) return $base;\n    if ($r > 0 && $r < $base)\
    \ return $base . $r;\n    return str_pad($r, $base - strlen($r), '0', STR_PAD_LEFT);\n\
    }\n", "    $baseStr = \"\"; // Base string will be \"0\"\n    $baseNum = 0;\n\
    \    while($baseNum <= 9) {\n        $baseStr .= chr($baseNum + 48);\n       \
    \ $baseNum++;\n    }\n    $numStr = (string)($x + $baseNum);\n    return ltrim($baseStr\
    \ . $numStr, '0');\n}", "    if ($base > 10) {\n        trigger_error('Invalid\
    \ base: ' . $base, E_USER_WARNING);\n        return null;\n    }\n    return sprintf(\"\
    %0{$base}d\", $x);\n}", "    if ($x === 0) {\n        return 0;\n    }\n    if\
    \ ($x % $base !== 0) {\n        return $x;\n    }\n    $y = $base;\n    while\
    \ (true) {\n        $remainder = $x / $y;\n        if ($remainder === 0) {\n \
    \           return $y;\n        }\n        $x = $remainder;\n        $y--;\n \
    \   }\n}", "  $base = 10**$base;\n  $result = $x / $base;\n  $result = $result\
    \ * $base;\n  return $result;\n}", "    $xl = strlen($x);\n    $n = $base;\n \
    \   $r = 0;\n    while ($xl > 0) {\n        $r = ($r * $base) + $x[$xl--];\n \
    \   }\n    return $r;\n}", "\t$x *= $base;\n\t$x = str_split($x);\n\t$x = array_pad($x,\
    \ strlen($x), '0');\n\treturn implode('', $x);\n}\n", "  $digits = base_convert($x,\
    \ 10, $base);\n  $mod = 10 ** strlen($digits) - 1;\n  return str_repeat(base_convert($digits,\
    \ 10, $base), $mod);\n}\n", "  if ($base > strlen($x)) $base = $base;\n  return\
    \ base_convert($x, 10, $base);\n}", "    $x = intval($x);\n    $base = intval($base);\n\
    \    $digits = pow($base, $x);\n    $numDigits = strlen($digits);\n    return\
    \ $digits;\n}\n</code>\n<|/ a dscore=3 tags=php,algorithm |>\n<| c |>\nYour code\
    \ is missing a return statement, I'm surprised it compiles.\n<|/ c |>\n<| c |>\n\
    The code I posted is actually an example from PHP 5.5 onwards, so it should compile\
    \ fine. I didn't test it thoroughly though.\n<|/ c |>\n<| c |>\nThe code I posted\
    \ is from the PHP documentation at http://php.net/manual/en/function.sprintf.php\n\
    <|/ c |>\n<| c |>\nYour code doesn't compile in PHP 5.4.0 because it doesn't recognize\
    \ `pow`. I'm surprised it compiles there, too. I assume that `pow` was introduced\
    \ in PHP 5.5 so I wondered about that too.\n<|/ c |>\n<| c |>\nHaven't checked\
    \ on 5.4, but yeah, `pow` was added in 5.5, and `strlen` was added in 5.6.\n<|/\
    \ c |>\n<| a dscore=2 |>\n<code>", "    // $x is non-negative number less than\
    \ base.\n    $base = (int) $base;\n    if ($x < 0 || $base < 0 || $base > 10)\
    \ {\n        return 'ERROR';\n    }\n    // find number of digits in base.\n \
    \   $digits_base = (string) base_convert($x, 10, $base);\n    // convert to binary\
    \ string.\n    $binary_base = (string) dechex($base);\n    // subtract digits\
    \ from base's binary representation.\n    // $binary_base's length must be equal\
    \ to digits_base.\n    $digits_binary = str_replace($binary_base, '', $digits_base);\n\
    \    // add leading zeros.\n    $digits_binary = str_pad($digits_binary, $digits_base,\
    \ '0', STR_PAD_LEFT);\n    // convert string to decimal number.\n    $number =\
    \ (float) base_convert($digits_binary, 2, $base);\n    // convert to string.\n\
    \    return (string) $number;\n}", "  return (string) base_convert($x, $base,\
    \ 10);\n}", "  // Handle zeros and negative numbers.\n  if ($x == '0' || $x ==\
    \ '-0') {\n    return $x;\n  }\n\n  $sign = $x[0] == '-' ? 1 : -1;\n  $x = ltrim($x,\
    \ '-');\n\n  $xlen = strlen($x);\n  $baselen = 1;\n  while ($baselen < $base)\
    \ {\n    $baselen *= $base;\n  }\n\n  $decimals = strlen($x) - $xlen;\n  $decimals\
    \ = ($decimals + $baselen - $base) / $base;\n\n  return ($sign * $x * pow(10,\
    \ $decimals));\n}\n\n$number = '-378.88';\n$newbase = change_base($number, 4);\n\
    $newnumber = change_base($number, 5);\n$newnumber = str_replace('0', '-', $newnumber);\n\
    $newnumber = str_pad($newnumber, 10, '0', STR_PAD_LEFT);\n", "    $res = \"\"\
    ;\n    while ($x >= base) {\n        $res = base_convert($x, $base, $base);\n\
    \        $x = $x % $base;\n    }\n    return base_convert($x, $base, $base) +\
    \ $res;\n}", "    $digits = (int) floor($x / $base);\n    if ($digits == 0)\n\
    \        return $x;\n    if ($digits == $base)\n        return \"0\" . $x;\n \
    \   return str_pad($x, strlen($x) - $digits, $base, '0');\n}\n", "    $sign =\
    \ ($x < 0) ? '-' : '';\n    if ($base >= 0 && $x < 10) {\n        return $sign\
    \ . base_convert($x, 10, $base);\n    } else if ($base < 0 && $x > 0) {\n    \
    \    return $sign . base_convert($x, 10, $base);\n    } else if ($base == 0) {\n\
    \        return $sign . '0';\n    } else {\n        $y = abs($x); // Yeah, this\
    \ could just be floor()\n        return $sign . base_convert($y, 10, $base);\n\
    \    }\n}\n", "    $a = $x;\n    $res = \"\";\n    while ($a > 0) {\n        $res\
    \ = $res * $base;\n        $a = floor($a / $base);\n    }\n    if ($res != 0)\
    \ {\n        return $res . $a * $base;\n    } else {\n        return $a * $base;\n\
    \    }\n}", "    $digits = intval($x / $base);\n    $remainder = $x % $base;\n\
    \    return base_convert($remainder, $base, $digits);\n}", "    $xstr= $x;\n \
    \   $basestr= $base;\n    while ( ($n = array_pop(str_split($xstr))) > 0 ){\n\
    \        $n= $basestr - $n;\n    }\n    array_push($xstr, $n);\n    return implode('',\
    \ $xstr);\n}", "\t$y = $x;\n\tif ($base > 10) {\n\t\tfor ($i = $base; $i >= 10;\
    \ $i--) {\n\t\t\t$y *= $i;\n\t\t}\n\t}\n\treturn (string) $y;\n}\n", "    $a =\
    \ pow(10, $base);\n    return $x * $a;\n}", "  $digits = base_convert($x, 10,\
    \ $base);\n  return $digits === false ? false : base_convert($digits, 10, $base);\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a tags=php,base,string |>\nI know this question\
    \ is old, but I want to share my solution here since there seems to be no answer\
    \ to this question here yet.\nMy solution, is very simple, just divide the number\
    \ by it's base and add 1 to the result.\n<code>\n<?php", "  $str = str_split($x);\n\
    \  for ($i = 1; $i <= strlen($str); $i++) {\n    $str[$i] = $base == $i ? $str[$i\
    \ - 1] : $str[$i];\n  }\n  return implode('', $str);\n}", "\t$digits = str_split($x);\n\
    \t$r = array();\n\tforeach ($digits as $key => $digit) {\n\t\t$r[$key] = ($digit>='0'\
    \ && $digit <='9') ? ($digit%$base+$base) : $digit;\n\t}\n\treturn implode('',\
    \ $r);\n}\n", "    $numdigits = strlen($x);\n    if ($numdigits == 0) {\n    \
    \    return \"0\";\n    }\n    $base = intval($base);\n    if ($base < 2) {\n\
    \        $base = 10;\n    }\n    $base = str_pad($base, strlen($x) + 1, $x[$numdigits\
    \ - 1] == '0' ? '0' : \"\", 'left');\n    $y = \"\";\n    $power = 0;\n    while\
    \ ($x != 0) {\n        if ($x % $base != 0) {\n            $digit = $x % $base;\n\
    \            $x = 0;\n            while ($digit != 0) {\n                $power\
    \ = $power * $base;\n                $digit = $digit / $base;\n              \
    \  $x = $x * $base;\n            }\n            $y = $y.$digit;\n        } else\
    \ {\n            $y = $y.$x[$numdigits - 1];\n        }\n    }\n    return $y.$power;\n\
    }", "    $str = strval($x);\n    $len = strlen($str);\n    $base = intval($base);\n\
    \    if ($base > 10) {\n        // Base greater than 10 not supported.\n     \
    \   return null;\n    }\n    if ($base == 10) {\n        return $str;\n    }\n\
    \    if ($base < 0 || $base > $len) {\n        // Base outside of supported range.\n\
    \        return null;\n    }\n    $digits = '';\n    // $dig is now the integer\
    \ part of $x, $rest-$dig is the remainder.\n    $rest = '';\n    for ($dig = 0;\
    \ $dig < $len; $dig++) {\n        $rest = str_pad($rest, $base, '0', STR_PAD_LEFT);\n\
    \        $digits = $digits + $rest[$dig];\n    }\n    return $digits;\n}\n", "\t\
    return (StringHelper::numberToString($x / $base, 8) * $base);\n}", "  $div = intval($x\
    \ / $base);\n  $rem = $x % $base;\n  return ($rem > 9 ? $div * $base + $rem :\
    \ $div * $base + 9) * $base + $rem;\n}\n</code>\n<|/ a tags=php,string |>\n<|\
    \ c |>\nI wrote the same answer :)\n<|/ c |>\n<| c |>\nNice solution. Also great\
    \ point about base < 10. Thanks!\n<|/ c |>\n<| c |>\nGood answer! I used base\
    \ of 10 and found that the last character of the string was always missing for\
    \ some reason. I realized that my `intval($x / $base)` needed to be done in base\
    \ 10 rather than base 10 and fixed that by changing `intval($x / $base)` to `ceil($x\
    \ / $base)`\n<|/ c |>\n<| a tags=php,string dscore=3 |>\nThe first solution is\
    \ very fast, but doesn't work for base above 10.\n<code>\n<?php\n", "    if ($x\
    \ < 0 || $base < 0 || $base > 36) return \"Invalid input\";\n    if ($base ==\
    \ 0) return \"0\";\n    if ($base > strlen($x)) return \"Base out of range\";\n\
    \    $s = strlen($x);\n    $result = '';\n    while ($s > 0) {\n        if ($x[$s-1]\
    \ < $base) break;\n        $result .= $x[$s-1];\n        $s--;\n    }\n    return\
    \ $result;\n}\n", "    if (!is_numeric($x) || !is_numeric($base)) return false;\n\
    \    $base = (int) $base;\n    if ($base < 1 || $base > 10) return false;\n  \
    \  $x = intval($x);\n    if ($x === 0) return 1;\n    if ($x == -1) return -1;\n\
    \    $y = $x; // Used as accumulator.\n    // Make sure base can be written as\
    \ integer as well.\n    $x = floor($x);\n    $x_log2 = intval($log($x, 2));\n\
    \    // Check if x is a power of two.\n    if ($x_log2 == intval($x_log2)) {\n\
    \        $x_log2++;\n    } else {\n        return false;\n    }\n    // Count\
    \ number of digits in the value of x.\n    $x_digits = $x_log2 + 1;\n    // If\
    \ base is 10 and $x is not a power of two, then $x_digits is zero\n    // and\
    \ $y is one. If $x_digits is zero and $x is a power of two, then\n    // $x is\
    \ one and $y is zero.\n    if ($base == 10 && $x_digits == 0) {\n        $y =\
    \ 1;\n    } elseif ($base == 10) {\n        $y = $base == $x ? 1 : 0;\n    } elseif\
    \ ($base < 10) {\n        $y = $x_digits * $base == $x ? 1 : 0;\n    }\n    return\
    \ $y;\n}", "    if ($x < 0 || $base < 2) {\n        $result = 'not number in base\
    \ ' . $base;\n    } else if ($base < 10) {\n        $result = str_pad(base_convert($x,\
    \ $base, '0', STR_PAD_LEFT), $base, '0');\n    } else {\n        $result = str_pad(base_convert($x,\
    \ $base, '0', STR_PAD_RIGHT), $base, '0');\n    }\n    return $result;\n}", " \
    \ $base = (int)$base;\n  $x = $x - floor($x / $base) * $base;\n  $digits = str_split(sprintf('%0'.$base.'d',\
    \ $x));\n  foreach ($digits as $key => $digit) {\n    if ($key < count($digits)\
    \ / 2) {\n      $digits[$key] = $digit * $base;\n    }\n  }\n  return implode('',\
    \ $digits);\n}\n", "    $a = bcdiv($x, $base);\n    $b = bcsub($x, $base);\n \
    \   return sprintf('%d', $a) . sprintf('%d', abs($a));\n}\n</code>\n<|/ a tags=php\
    \ |>\n<| c |>\nThanks, this is great for large numbers.\n<|/ c |>\n<| c |>\nThanks\
    \ I appreciate it! I just added an if statement to make sure that it doesn't give\
    \ a negative number to change_base\n<|/ c |>\n<| a |>\nThis solution will allow\
    \ you to multiply a decimal number by any factor by just replacing the \".\" with\
    \ the character you would like to use. For example, if \".\" was \"*\", then multiplying\
    \ \".2\" by \"2\" would give \"*2\" instead of \".2*2\". It will also allow you\
    \ to perform \"-\" instead of \"+\" or \"-\" instead of \"*\".\n<code>\n<?php",
  "  if ($base > strlen($x)) return null;\n  return ltrim(str_split(str_pad(str_repeat('0',\
    \ $base), $x-strlen($x), '0', $base), $base));\n}\n", "  // Check parameters.\n\
    \  if ($x < 0 || $base < 0 || $base > 10) {\n    return \"\";\n  }\n\n  // Convert\
    \ from string to an array.\n  $digits = str_split($x);\n\n  // Check base limits.\n\
    \  if ($base > strlen($digits) || $base < 0) {\n    return \"\";\n  }\n\n  //\
    \ Change bases.\n  for ($i = 0, $j = strlen($digits) - 1; $i < $base; $i++, $j--)\
    \ {\n    $digits[$j] = $digits[$i];\n  }\n\n  // Convert from array to string.\n\
    \  return implode('', $digits);\n}\n", "    if ($base > 9 || $base < 1) {\n  \
    \      throw new RangeException('Invalid base');\n    }\n    if ($base == 0) {\n\
    \        return $x;\n    }\n\n    $sign = $x < 0 ? '-' : '';\n    $x = abs($x);\n\
    \    $y = $base;\n    while ($x >= $y) {\n        $x = ($x / $y);\n        $y--;\n\
    \    }\n    return $sign . $y;\n}\n", "  $digits = str_repeat('0', strlen($x));\n\
    \  $base = str_pad($base, strlen($digits), '0', STR_PAD_LEFT);\n  $digits = str_split($digits);\n\
    \  $newDigits = array();\n  foreach ($digits as $k => $digit) {\n    if ($digit\
    \ === '0') {\n      continue;\n    }\n    if ($digit !== '1') {\n      continue;\n\
    \    }\n    $newDigits[$k] = substr($base, $k, 1);\n  }\n  $base = $newDigits;\n\
    \  return implode('', $base);\n}", "    $string = $x;\n    while (strlen($string)\
    \ < $base) {\n        $string = '0'.$string;\n    }\n    return $string;\n}\n\
    </code>\nThe only thing that needs explaining is the while loop in the change_base\
    \ function. The way it works is it goes through each character in the input string,\
    \ and when it hits one that isn't a 0 it pads it with 0s to equal the length of\
    \ the base (which is also the input string).\n<|/ a |>\n<| a tags=algorithm,php\
    \ dscore=3 |>\nHere's a solution in PHP:\n<code>\n<?php", "\t$x = $x * $base;\n\
    \treturn $x;\n}", "  if ($x == 0 || $x == 1)\n    return $x;\n  if ($base < 0\
    \ || $base > 62)\n    return 'Invalid base.';\n\n  $power = 0;\n  $n = 0;\n\n\
    \  while (true) {\n    if ($n >= strlen($base)) {\n      $n = 0;\n      ++$power;\n\
    \    }\n    if ($power == 0) {\n      $n = $n % $base;\n    } else {\n      $n\
    \ = $n / $base;\n      $power--;\n    }\n    if ($n < 0)\n      return '.';\n\
    \    $x = $x * $base;\n  }\n}\n", "    $x = $x + \"\";\n    $base = str_pad($base,\
    \ strlen($x), 0);\n    $base10 = \\unpack(\"H*\", $base);\n    $base = $base10[1];\n\
    \    $xstr = \"\";\n    $base10 = \\unpack(\"H*\", $x);\n    $x = $base10[1];\n\
    \    for ($i = strlen($x); $i > 0; $i /= $base) {\n        $xstr .= $x[$i - 1];\n\
    \    }\n    return $xstr;\n}\n", "  $res = '';\n  // If the base is 10, return\
    \ an actual number\n  if ($base == 10) {\n    return $x;\n  }\n  // Divide input\
    \ number by base\n  // If the remainder is 0, it means there is no remainder.\n\
    \  // So $quotient and $remainder are now the number of the base's factor.\n \
    \ // If the remainder is not 0, then it means there is a remainder.\n  // So $quotient\
    \ and $remainder are now the number of the base's factor.\n  $quotient = floor($x\
    \ / $base);\n  $remainder = $x % $base;\n  // Now multiply the quotient by base\n\
    \  $res = $quotient * $base;\n  // And add the remainder\n  $res += $remainder;\n\
    \  return $res;\n}", "    if ($x < 10) {\n        return $x;\n    }\n\n    if\
    \ ($base < 2 || $base > 10) {\n        return \"Invalid Base $base\";\n    }\n\
    \n    $str = base_convert($x, 10, $base);\n\n    if ($str[0] == '-') {\n     \
    \   $str = '+' . $str;\n    }\n\n    if ($str[0] == '0') {\n        $str = '1';\n\
    \    }\n\n    return $str;\n}\n", "    $digits = str_split($x);\n    $digits_count\
    \ = count($digits);\n    $digits_count_to_add = $base - $digits_count; // how\
    \ many times we need to add digits to reach base $base.\n    $digits_count_to_subtract\
    \ = $digits_count - $digits_count_to_add; // how many times we need to subtract\
    \ digits to reach base $base.\n    $result = \"\";\n    for ($i = 0; $i < $digits_count_to_add;\
    \ $i++) {\n        $result .= $digits[$i];\n    }\n    for ($i = 0; $i < $digits_count_to_subtract;\
    \ $i++) {\n        $result = $digits[$digits_count - $digits_count + $i] . $result;\n\
    \    }\n    return $result;\n}\n", "    if ($base > strlen($x)) {\n        return\
    \ $x;\n    }\n\n    $y = \"\";\n    $base = strlen($x) + $base;\n    for ($i =\
    \ 0; $i < $base; $i++) {\n        $y += $x[$i];\n    }\n\n    return $y;\n}\n",
  "    if ($x < 10) {\n        return $x;\n    }\n    $r = $x / $base;\n    $r = intval($r);\n\
    \    if ($r == 0) {\n        return $base;\n    }\n    $r = $r % $base;\n    return\
    \ change_base($r, $base);\n}", "    $str = str_split(sprintf('%u', $x));\n   \
    \ $x = array_shift($str);\n    $result = '';\n    foreach ($str as $n => $digit)\
    \ {\n        $result = base_convert($digit + $x, $base, $base) + $result;\n  \
    \  }\n    return $result;\n}\n", "    $r = array();\n    while ($x) {\n      \
    \  $r[] = intval($x % $base);\n        $x = intval($x / $base);\n    }\n    return\
    \ implode('', $r);\n}\n", "    $base = abs($base);\n    $base = ($base < 10) ?\
    \ 10 : ($base > 36) ? 36 : $base;\n    $result = $x / $base;\n    while ($result\
    \ < 1) {\n        $result *= $base;\n    }\n    while ($result > $base) {\n  \
    \      $result /= $base;\n    }\n    return $result;\n}\n", "    if ($x < 10)\
    \ {\n        $x = $x + 0;\n    }\n    $base = $base + 0;\n    if ($base < 2) {\n\
    \        return \"0\";\n    }\n    if ($base > 36) {\n        return \"0\";\n\
    \    }\n    if ($x >= 1000) {\n        $x = floor($x / 10);\n        $base++;\n\
    \    }\n    if ($x >= 10000) {\n        $x = floor($x / 10);\n        $base++;\n\
    \    }\n    if ($x >= 100000) {\n        $x = floor($x / 10);\n        $base++;\n\
    \    }\n    if ($base > 36) {\n        $base--;\n    }\n    if ($base > 9) {\n\
    \        $base--;\n    }\n    $res = \"\";\n    do {\n        $res = $x % $base;\n\
    \        $x = floor($x / $base);\n        $base--;\n    } while ($base > 0);\n\
    \    return $res == 0 ? \"0\" : $res;\n}\n", "    $r = \"\";\n    do {\n     \
    \   $remainder = $x % $base;\n        $x = floor($x / $base);\n        $r += str_pad(base_convert($remainder,\
    \ 10, $base), $base, 0, \"0\", STR_PAD_LEFT);\n    } while ($x != 0);\n    return\
    \ $r;\n}", "\t$base = (int)$base;\n\t$x = $x - intval($x/$base)*$base;\n\t$x =\
    \ $x + intval($x/$base);\n\treturn $x;\n}\n", "  $x_str = (string)$x;\n  $result\
    \ = 0;\n  for ($i = 0; $i < strlen($x_str); $i++) {\n    $digit = strpos($x_str,\
    \ '0', ($i + 1));\n    if ($digit === false) {\n      $digit = $x_str[$i];\n \
    \   }\n    $pow = strpos($x_str, '1', $i) - $digit;\n    for ($j = 0; $j < $base;\
    \ $j++) {\n      $result += (ord($x_str[$i]) - ord('0')) * pow($base, $j);\n \
    \   }\n  }\n  return $result;\n}\n", "  $digits = strval($x);\n  $digits = str_pad($digits,\
    \ strlen($digits), '0', STR_PAD_LEFT);\n  $digits = base_convert($digits, $base,\
    \ $base);\n  $digits = str_pad($digits, strlen($digits), '0', STR_PAD_LEFT);\n\
    \  $x = base_convert($digits, 10, $base);\n  return $x;\n}\n", "\t$res = \"\"\
    ;\n\t$digits = $x < 0 ? \"-\" : \"\";\n\t$x = abs($x);\n\twhile ($x >= $base)\
    \ {\n\t\t$x = $x / $base;\n\t\t$res .= $digits;\n\t}\n\t$res .= $x;\n\treturn\
    \ $res;\n}", "    $digits = (int) $x;\n    if ($digits == 0) {\n        return\
    \ 0;\n    }\n    if ($digits < 0) {\n        $digits = $x + $digits;\n       \
    \ if ($digits < 0) {\n            $digits = -$digits;\n        }\n    }\n    $digits\
    \ = (int) floor($digits);\n    $r = $digits % $base;\n    return ($digits - $r)\
    \ / $base;\n}", "    if ($x < 10) {\n        return $x;\n    }\n    return ($x\
    \ - 10) * pow($base, $x);\n}\n", "    $n = (int) ($x / $base);\n    $r = $n %\
    \ $base;\n    return $x * $base + $r;\n}\n", "    if ($x < 0) {\n        return\
    \ null;\n    }\n\n    if ($x == 0) {\n        return 0;\n    }\n\n    $base_two\
    \ = pow($base, 2);\n    if ($x > ($base_two / 2) && $x < ($base_two * 2)) {\n\
    \        return $base_two * $x + $base;\n    } else {\n        return ($x / $base)\
    \ * $base + $x;\n    }\n}\n</code>\n<|/ a tags=base-conversion,php |>\n<| c |>\n\
    This worked for me for converting hex to dec, but now how do I get the inverse\
    \ of this function, i.e. hex to dec?\n<|/ c |>\n<| a |>\nYou could use the dechex()\
    \ function for this\n<|/ a dscore=4 tags=base-conversion,php |>\n<| c |>\nThis\
    \ is the only one that worked for me. `dechex(base_convert($number, 10, 2))` worked\
    \ as I wanted, but `dechex(base_convert($number, 2, 10))` did not.\n<|/ c |>\n\
    <| c |>\nI love this solution, since `base_convert` doesn't support negative numbers.\
    \ `dechex` does, which is probably why it worked for OP\n<|/ c |>\n<| a dscore=4\
    \ |>\nYou can use bindec() and decbin() functions:\n<code>\n$dec = (int) decbin($hex);\n\
    $bin = bindec($dec);\n</code>\n<|/ a tags=base-conversion,php |>\n<| a tags=base-conversion,php\
    \ |>\nFor anyone coming across this question using PHP7 or above, you can also\
    \ use the built-in function bindec().\n<code>\n$hexValue = \"F\";\n$binValue =\
    \ bindec($hexValue);\necho $binValue;\n</code>\n<|/ a dscore=4 |>\n<| c |>\nbindec\
    \ is not available for PHP7 so this answer is outdated\n<|/ c |>\n<| a tags=base-conversion,php\
    \ |>\nIn case anyone is looking for a way to do this with negative values, I've\
    \ written a class to do it:\n<code>\nclass Base {\n    protected $integer;\n \
    \   protected $base;\n\n    public function __construct($integer, $base) {\n \
    \       $this->integer = $integer;\n        $this->base = $base;\n    }\n\n  \
    \  public function toBinary($asString = false) {\n        if ($asString) {\n \
    \           return $this->integer->bindec();\n        } else {\n            return\
    \ $this->integer->decbin();\n        }\n    }\n\n    public function toDecimal($asString\
    \ = false) {\n        if ($asString) {\n", "  // if base is 0 then just leave\
    \ $x as is\n  if ($base == 0) {\n    return $x;\n  }\n  // if base is negative\
    \ then get absolute value\n  if ($base < 0) {\n    $x = abs($x);\n    $base =\
    \ -$base;\n  }\n  // if base < 2 then just add $base to $x to make it positive\n\
    \  if ($base < 2) {\n    return $x + $base;\n  }\n  // else do string conversion\
    \ and apply the new base\n  return base_convert($x, 10, $base);\n}", "  if ($x\
    \ < 10 && $base < 10) {\n    $result = '';\n  } else if ($x < 10) {\n    $result\
    \ = $x.\"0\";\n  } else if ($base < 10) {\n    $result = $base;\n  }\n  while\
    \ ($x > 0 && $base > 0) {\n    $last_digit = $x % $base;\n    $x = floor($x /\
    \ $base);\n    $result = $base.$last_digit.$result;\n    $base = $base * 10;\n\
    \  }\n  return $result;\n}\n\n$hex = \"ff00\";\n$dec = \"255\";\n$bin = \"11111111\"\
    ;\n$oct = \"012\";\n$hex_bin = change_base($hex, 16);\n$hex_oct = change_base($hex,\
    \ 8);\n$hex_not = !$hex;\n$hex_not_bin = change_base($hex_not, 16);\n$hex_not_oct\
    \ = change_base($hex_not, 8);\n$hex_not_not = !$hex_not;\n$hex_not_dec = change_base($hex_not,\
    \ 10);\n$hex_dec = change_base($hex, 10);\n$dec = change_base($dec, 10);\n$bin\
    \ = change_base($bin, 10);\n$oct = change_base($oct, 10);\n$hex_oct = change_base($hex_oct,\
    \ 10);\n$hex_not = change_base($hex_not, 10);\n$hex_not_bin = change_base($hex_not_bin,\
    \ 16);\n$hex_not_oct = change_base($hex_not_oct, 8);\n$hex_not_not = change_base($hex_not_not,\
    \ 10);\n$hex_not_dec = change_base($hex_not_dec, 10);\n$hex_dec = change_base($hex_dec,\
    \ 10);\n$dec = change_base($dec, 10);\n$bin = change_base($bin, 10);\n$oct = change_base($oct,\
    \ 10);\n$hex_oct = change_base($hex_oct, 10);\n$hex_not = change_base($hex_not,\
    \ 10);\n$hex_not_bin = change_base($hex_not_bin, 16);\n$hex_not_oct = change_base($hex_not_oct,\
    \ 8);\n$hex_not_not = change_base($hex_not_not, 10);\n$hex_not_dec = change_base($hex_not_dec,\
    \ 10);\n$hex_dec = change_base($hex_dec, 10);\n\n$dec = \"255\";\n$bin = \"11111111\"\
    ;\n$oct = \"012\";\n$hex_bin = change_base($hex, 16);\n$hex_oct = change_base($hex,\
    \ 8);\n$hex_not = !$hex;\n$hex_not_bin = change_base($hex_not, ", "    $mod =\
    \ pow($base, $x);\n    return $mod == 0 ? $mod : $mod - intval($mod / $base);\n\
    }", "  $base = base_convert($x, 10, $base);\n  $tens = str_pad('', $base, '0');\n\
    \  return substr($tens, 0, $base);\n}", "  // $x is positive integer.\n  // $base\
    \ is positive integer.\n  // return string representation of $x after conversion\
    \ to $base.\n  // use str_replace to convert \"1\" from base 2 to base 10.\n \
    \ // use str_pad to convert \"0\" from base 10 to base 2.\n  // >>> change_base(2,\
    \ 3)\n  // \"11\"\n  // >>> change_base(3, 3)\n  // \"111\"\n  // >>> change_base(3,\
    \ 2)\n  // \"1111\"\n  return str_pad(base_convert($x, 10, $base), $base);\n}\n",
  "    $r = \"\";\n    while ($x > 10) {\n        $r = base_convert($x, 10, $base)\
    \ . $r;\n        $x = floor($x/$base);\n    }\n    $r = base_convert($x, 10, $base)\
    \ . $r;\n    return $r;\n}\n", "  $s = '';\n  do {\n    $tmp = intval($x / $base);\n\
    \    $s = $x % $base;\n    $x = $tmp;\n  } while ($x); // Remove zeroes after\
    \ the decimal\n  return $s + $base;\n}\n</code>\nThe final code with above function\
    \ and output from it is as follows:\n<code>\n$base = 3;\n$num = 50;\n$digits =\
    \ $num;\ndo {\n  $tmp = change_base($digits, $base);\n  $digits = $tmp;\n} while\
    \ (!is_int($digits));\n\n$digits = str_replace(array('0', '1', '2', '3', '4',\
    \ '5', '6', '7', '8', '9'), '', $digits);\nprintf(\"$base%d\\n\", $digits);\n\
    </code>\nThe above code outputs: 3125\n<|/ a dscore=4 |>\n<| c |>\nGreat solution,\
    \ thank you. Very compact and elegant - simple and sweet.\n<|/ c |>\n<| c |>\n\
    You solution works like a charm for base <= 10. but doesn't work for base > 10\
    \ like if base is 16, the output should be 160 but the code returns only 400.\
    \ what is the problem? thanks in advance.\n<|/ c |>\n<| c |>\nThanks i fixed the\
    \ problem by adding `$base++` after the `$digits = $tmp;` statement in the while\
    \ loop. thanks a lot.\n<|/ c |>\n<| a tags=php,number-systems dscore=3 |>\n<code>\n\
    <?php \n$num= 54;\n$num= ($num+9)/10; \necho $num;", "  $r = array();\n  while($x\
    \ > 0) {\n    $r[] = (int) ($x / $base);\n    $x = $x % $base;\n  }\n  return\
    \ implode('', $r);\n}\n", "  $x = abs($x); // Convert to positive number\n  while\
    \ ($x >= base) {\n    $x /= base;\n  }\n  return $x * base;\n}\n", "    $s = preg_replace(\"\
    /[0-8]/\", \"0\", base_convert((string) $x, 10, (string) $base));\n    return\
    \ base_convert((string) $s, 10, (string) $base);\n}", "    if ($base<2 || $base>36)\
    \ {\n        $base = 10;\n    }\n    if ($x>0) {\n        return $base * strval($x/$base);\n\
    \    } else {\n        return $x%$base;\n    }\n}", "    $x *= Math.pow(10, $base);\n\
    \    $x = floor($x);\n    $x /= Math.pow(10, $base);\n    return $x;\n}\n", " \
    \   $r = 1;\n    $base--;\n    while ($base >= 1) {\n        $r = $r * $x;\n \
    \       $base--;\n    }\n    $r = $x / $r;\n    $r = $r * $base;\n    return $r;\n\
    }\n</code>\n<|/ a |>\n<| a dscore=0 tags=c++,c |>\nSince you tagged this as both\
    \ C and C++ I am going to assume you meant C.\nThe most efficient way to do this\
    \ would be with long division.\n<code>", "  $a = $base;\n  while ($a > 0) {\n\
    \    $b = ($a - 1) % $base;\n    $a = $b * ($x + 1);\n  }\n  return $a;\n}\n",
  "  $sign = ($x < 0) ? '-' : '';\n  $x = abs($x);\n  $res = '';\n  while ($x >= $base)\
    \ {\n    $div = floor($x / $base);\n    $mod = $x % $base;\n    $res = $mod .\
    \ $res;\n    $x = $div;\n  }\n  $res = $sign . $res;\n  if (strlen($res) == 1)\
    \ {\n    $res = $base . $res;\n  }\n  return $res;\n}\n", "  $ret = \"\";\n  $len\
    \ = strlen($x);\n  while ($len > 0) {\n    if ($len < $base) {\n      $ret .=\
    \ \"0\";\n      $len--;\n    } else if ($len == $base) {\n      $ret .= \"0\"\
    ;\n      $len--;\n    } else {\n      $ret .= \"1\";\n      $len -= $base;\n \
    \   }\n  }\n  return $ret;\n}", "  $str = strval($x);\n  $mod = $str % $base;\n\
    \  $str = ($str - $mod) / $base;\n  return $str . '%' . str_pad('', $base, '0');\n\
    }\n\n$out = array();\n$in = $_POST['data'];\n$inlen = strlen($in);\nfor ($j=0;\
    \ $j<$inlen; $j+=4) {\n  $out = array_merge($out, array_reverse(explode(\",\"\
    ,\n    change_base($in[$j], $base) . change_base($in[$j+1], $base) . change_base($in[$j+2],\
    \ $base) . change_base($in[$j+3], $base))));\n}\n\necho implode(',', $out);",
  "  $x = intval($x);\n  $base = intval($base);\n  if ($base > 10) {\n    die(\"Invalid\
    \ base $base\");\n  }\n\n  if ($x == 0) {\n    return \"0\";\n  }\n\n  if ($x\
    \ < 0) {\n    $x = -$x;\n  }\n\n  $r = \"\";\n  do {\n    $r = base_convert($x\
    \ % $base, $base, 10);\n    $x = intval($x / $base);\n    $base--;\n  } while\
    \ ($base);\n\n  return $r . $r;\n}\n", "    if ($base < 1 || $base > 10) {\n \
    \       throw new \\Exception(\"base must be between 1 and 10\");\n    }\n   \
    \ if ($x < 1) {\n        return \"0\";\n    }\n\n    // Handle negative numbers.\n\
    \    if ($x > 0) {\n        $x = $x * $base;\n        $x = $x / $base;\n     \
    \   $x = $x - 1;\n    }\n\n    // Reverse the digits and add the digit.\n    $x\
    \ *= $base;\n    $sum = 0;\n    while (!is_int($x % $base)) {\n        $sum =\
    \ $sum * 10 + $x % $base;\n        $x = $x / $base;\n    }\n\n    // Return the\
    \ result.\n    return $sum;\n}\n</code>\n<|/ a tags=php,algorithm |>\n<| a dscore=1\
    \ |>\nI've done this in the past:\n<code>", "  $r = \"\";\n  $base_power = base_convert($x,\
    \ 10, $base);\n  $x = $x - $base_power;\n  while (0 > $x) {\n    $r = base_convert($r,\
    \ $base, $base) + 1;\n    $x = $x - 1;\n  }\n  return $r;\n}", "  if ($base <\
    \ 1 || $base > 10) {\n    die(\"Invalid number base. Base must be in [1, 10]\"\
    );\n  }\n  $basestr = \"\";\n  for ($i = 0; $i < $base; ++$i) {\n    $basestr\
    \ .= \"0\";\n  }\n  $x = abs($x);\n  $xstr = $x;\n  while ($x != 0) {\n    $t\
    \ = $x % $base;\n    $xstr = $basestr . $t;\n    $x = floor($x / $base);\n  }\n\
    \  return $xstr;\n}\n", "  // get string representation of number x\n  // remove\
    \ all characters that are not numbers from it\n  // convert string to number\n\
    \  $string = str_replace(['.', ',', ';', '!', '?'], '', (string) $x);\n  $number\
    \ = (float) str_pad($string, strlen($string) + ($base - 1), 0, STR_PAD_LEFT);\n\
    \  return $number;\n}\n", "  $r = \"\";\n  while ($x >= $base) {\n    $div = $x\
    \ / $base;\n    $r = floor($div + $r) * $base;\n    $x = $x - $div;\n  }\n  return\
    \ $r + $x;\n}", "  $r = \"\";\n  while (strlen($x) > 0) {\n    $r = str_repeat($base,\
    \ $x) . $r;\n    $x = strlen($x) - 1;\n  }\n  return $r;\n}", "\t$base = intval($base);\n\
    \tif ($base < 1 || $base > 10) {\n\t\treturn false;\n\t}\n\t$x = intval($x);\n\
    \tif ($x < 1 || $x % $base !== 0) {\n\t\treturn false;\n\t}\n\treturn \"$x\";\n\
    }\n", "  if ($base == 0) {\n    $base = 10;\n  }\n  $sign = ($x < 0);\n  $x =\
    \ abs($x);\n  $r = array();\n  for ($i = 0, $j = $base; $i < $base; $j = $i *\
    \ 2, $i++) {\n    $r[$i] = intdiv($x, $j);\n    $x = floor($x / $j);\n  }\n  return\
    \ $sign ? -$r[$i] : $r[$i];\n}\n", "    $x = strval($x);\n    $base = (int) $base;\n\
    \    if ($base < 1 || $base > 10) {\n        return '';\n    }\n    $result =\
    \ '';\n    while (0 <= $base) {\n        $result = base_convert($x, $base, $uppercase);\n\
    \        $lastDigit = $result[$base-1];\n        $x = $x - (int) $lastDigit;\n\
    \        $base = $base * 10;\n    }\n    return $result;\n}\n", "  if ($x < 10\
    \ && $base < 10) {\n    return $x;\n  }\n\n  if ($base < 2) {\n    return '';\n\
    \  }\n\n  if ($base == 10) {\n    return $x;\n  }\n\n  if ($x < 0 || $base > 10)\
    \ {\n    return $x;\n  }\n\n  $x_strlen = strlen($x);\n  $base = (int) $base;\n\
    \n  $y = $base;\n  $res = '';\n  while ($x_strlen) {\n    $res = base_convert($x_strlen\
    \ - 1, 10, $base) + $res;\n    $x_strlen--;\n  }\n\n  return $res + $x;\n}\n",
  "    if (!is_numeric($x)) {\n        return $x;\n    }\n\n    if (!is_numeric($base))\
    \ {\n        return $x;\n    }\n\n    if ($base < 1 || $base > 10) {\n       \
    \ return $x;\n    }\n\n    $base_to_digit_map = array(\n        1 => '1',\n  \
    \      2 => '2',\n        3 => '3',\n        4 => '4',\n        5 => '5',\n  \
    \      6 => '6',\n        7 => '7',\n        8 => '8',\n        9 => '9',\n  \
    \      10 => '0'\n    );\n\n    $xdigit = array();\n    $x_length = 0;\n    $x\
    \ = strrev($x);\n    for ($i = 0; $i < strlen($x); $i++) {\n        $x_length\
    \ = strlen($x[$i]);\n        if ($x_length >= $base) {\n            $xdigit[]\
    \ = $x[$i];\n        }\n    }\n\n    // If x is smaller than base, add 0's to\
    \ fill out base\n    if ($x_length < $base) {\n        for ($i = $x_length; $i\
    \ < $base; $i++) {\n            $xdigit[] = '0';\n        }\n    }\n\n    $x_string\
    \ = '';\n    foreach ($xdigit as $digit) {\n        if (array_key_exists($digit,\
    \ $base_to_digit_map)) {\n            $x_string .= $base_to_digit_map[$digit];\n\
    \        } else {\n            $x_string .= $digit;\n        }\n    }\n    return\
    \ $x_string;\n}\n", "  $base = min(9, max(1, $base));\n  if ($x < 0) {\n    $x\
    \ = floor($x / pow($base, $base));\n  } else {\n    $x = floor($x * pow($base,\
    \ $base - 1));\n  }\n  return $x * pow($base, $base);\n}\n</code>\n<|/ a tags=algorithm,php,math\
    \ |>\n<| c |>\nOk, I didn't know that PHP's `base_convert()` function could be\
    \ used like that. Cool!\n<|/ c |>\n<| c |>\nThanks for the info, but when I run\
    \ this through `base_convert()`, I get `'6'`, which isn't the right answer.\n\
    <|/ c |>\n<| c |>\nAh. Sorry, I read that wrong. PHP doesn't support arbitrary\
    \ bases, so it only works with base `2`. I've edited my answer with a workaround.\n\
    <|/ c |>\n<| c |>\nAha, thank you. I've rewritten my algorithm using that and\
    \ it works! I'll post my code in my answer.\n<|/ c |>\n<| c |>\nAwesome! Glad\
    \ I could help :)\n<|/ c |>\n<| a dscore=4 |>\nI couldn't get any of the other\
    \ solutions to work correctly in PHP 7.2.\nHere is what I came up with:\n<code>",
  "\t$n = $x;\n\tdo {\n\t\t$n *= $base;\n\t} while ($n>0);\n\t$n = $x;\n\tdo {\n\t\
    \t$n /= $base;\n\t} while ($n>0);\n\treturn $n;\n}", "\t$base = (int) $base;\n\
    \tif (!$base) {\n\t\treturn $x;\n\t} elseif ($base < 1 || $base > 10) {\n\t\t\
    return $x;\n\t}\n\t$x = intval($x);\n\t$ex = intval(log($x, $base));\n\t$y = $x\
    \ * pow(10, $ex - 1);\n\twhile ($ex--) {\n\t\t$y = $y * $base;\n\t}\n\treturn\
    \ $y;\n}", "  $digits = $x / $base;\n  $rest = $x % $base;\n  return str_pad($digits,\
    \ $base, '0', STR_PAD_LEFT).$rest;\n}\n</code>\nAnd now the code:\n<code>\n<?php",
  "  $string = $x;\n  while (strlen($string) > 0) {\n    $digit = intval(substr($string,\
    \ 0, 1), 10);\n    $string = substr($string, 1);\n    if ($digit < $base) {\n\
    \      $string = $digit . $string;\n    } else {\n      $string = ($digit - $base)\
    \ . $string;\n    }\n  }\n  return $string;\n}\n", "  $x = $x - 1;\n  $digits\
    \ = array();\n  while ($x >= 0) {\n    $digits[$x % $base] = $x / $base;\n   \
    \ $x = floor($x / $base);\n  }\n  return array_sum($digits);\n}\n\n$x = change_base(7,\
    \ 3);\n$y = change_base(8, 2);\n$z = $x + $y;\necho \"$x + $y = $z\";", "    if\
    \ ($base == 0) {\n        if ($x != 0)\n            return \"0\";\n        else\n\
    \            return \"\";\n    }\n    if ($x < 0)\n        $x = $x + $base;\n\
    \    $r = \"\";\n    while ($x > 0) {\n        $r = base_convert($x, 10, $base)\
    \ + $r;\n        $x -= $base;\n    }\n    return $r;\n}\n", "  global $numero_base;\n\
    \  $numero_base = $base;\n  $n = $x;\n  do {\n    $n *= $numero_base;\n    $n\
    \ -= intval($n/$numero_base);\n  } while($n>0);\n  return $x;\n}", "    $digits\
    \ = '';\n    if ($x < base) {\n        switch ($base) {\n            case 2: $digits\
    \ = '0'; break;\n            case 10: $digits = '1'; break;\n            case\
    \ 16: $digits = 'x'; break;\n            case 8: $digits = 'b'; break;\n     \
    \       case 21 : $digits = 'y'; break;\n            case 26: $digits = 'z'; break;\n\
    \            case 52 : $digits = 'A'; break;\n            case 10 : $digits =\
    \ 'a'; break;\n            case 16 : $digits = 'X'; break;\n            case 8\
    \  : $digits = 'B'; break;\n            case 21 : $digits = 'Y'; break;\n    \
    \        case 26 : $digits = 'Z'; break;\n            case 48 : $digits = '0';\
    \ break;\n            case 53 : $digits = '1'; break;\n            case 62 : $digits\
    \ = '2'; break;\n            case 93 : $digits = '3'; break;\n            case\
    \ 92 : $digits = '4'; break;\n            case 49 : $digits = '5'; break;\n  \
    \          case 63 : $digits = '6'; break;\n            case 94 : $digits = '7';\
    \ break;\n            case 91 : $digits = '8'; break;\n            case 50 : $digits\
    \ = '9'; break;\n        }\n    }\n    $x = $x - $base;\n    return $x . substr($digits,\
    \ strlen($digits));\n}", "  $sign = ($x < 0);\n  $x = abs($x);\n  $x = $sign ?\
    \ $x + $base : abs($x) - $base;\n  return $x;\n}\n", "    if ($base == 10) return\
    \ $x;\n    if ($base == 8) {\n        $y = 10;\n    } else if ($base == 7) {\n\
    \        $y = 11;\n    } else if ($base == 6) {\n        $y = 12;\n    } else\
    \ if ($base == 5) {\n        $y = 13;\n    } else if ($base == 4) {\n        $y\
    \ = 14;\n    } else if ($base == 3) {\n        $y = 15;\n    } else if ($base\
    \ == 2) {\n        $y = 16;\n    } else if ($base == 1) {\n        $y = 17;\n\
    \    } else {\n        echo \"Base \" . $base . \" not recognized.\";\n      \
    \  return null;\n    }\n\n    return $x * $y / $base;\n}", "\t$y = $x;\n\twhile\
    \ ($y > 10) {\n\t\t$y /= 10;\n\t}\n\tif ($y < 10) {\n\t\t$y = 10;\n\t}\n\t$x =\
    \ $y * $base;\n\treturn $x;\n}", "    $str = strval($x); // Ensure that numbers\
    \ are strings.\n    $base = intval($base);\n    $res = \"\";\n    while (strlen($str)\
    \ > 0) {\n        $lastChar = substr($str, -1);\n        if ($lastChar >= '0'\
    \ && $lastChar <= '9') {\n            // Numerical conversion.\n            $strLength\
    \ = strlen($str) - 1;\n            $num = $lastChar - ord('0');\n            $mult\
    \ = pow($base, $strLength);\n            $result = $num * $mult;\n           \
    \ if ($result == intval($result)) {\n                // Integer conversion.\n\
    \                $str = $str . '0';\n                $res = $str . $res;\n   \
    \         } else {\n                // Real number conversion.\n             \
    \   $str = $str . '.' . strval($result);\n                $res = $str . $res;\n\
    \            }\n        } else {\n            // Real number conversion.\n   \
    \         $str = $str . '0';\n            $res = $str . $res;\n        }\n   \
    \ }\n    return $res;\n}\n", "    $str = preg_replace(\"/([^0-9]*)([0-9]+)$/\"\
    , \"$1\" + $base, $x);\n    $str = preg_replace(\"/([^0-9]*)([0-9]+)/\", \"$1\"\
    \ + $base, $str);\n    return $str;\n}", "    $r = \"\";\n    while ($x > 10)\
    \ {\n        $r = ($x % 10 + $base * 10) + $r;\n        $x = floor($x / 10);\n\
    \    }\n    return $x + $r;\n}\n", "  return str_pad($x, $base, '0', STR_PAD_LEFT);\n\
    }", "  $x *= $base;\n  return ltrim(str_pad($x, $base, '0', STR_PAD_LEFT), '0');\n\
    }\n", "  $res = \"\";\n  for($i = 0; $i < strlen($x); $i++)\n  {\n    $res .=\
    \ $x[$i] * pow($base, $i);\n  }\n  return $res;\n}\n", "  return str_repeat('0',\
    \ strlen((string)$x)) . base_convert($x, $base, $base);\n}\n", "    $x = abs($x);\n\
    \    $base = $base < 0 ? -$base : $base;\n    if ($x == 0) {\n        return $x;\n\
    \    }\n    if ($x < base) {\n        // x too big to convert\n        return\
    \ '';\n    }\n    // cut it down to the first base\n    $r = $x / $base;\n   \
    \ $r = floor($r);\n    $rest = $x % $base;\n    $rest = $rest == 0 ? 0 : floor($rest);\n\
    \    $r = $r * $base;\n    $r = $r + $rest;\n    $r = $r < 0 ? -$r : $r;\n   \
    \ return $r;\n}", "    $base = max(2, min(9, (int)$base));\n    $power = log($x\
    \ / $base) / log(10);\n    return $base ** $power;\n}\n</code>\nTo find the remainder,\
    \ divide this number by base and round down (or up). You have to handle negative\
    \ numbers, though.\n<|/ a dscore=1 |>\n<| c |>\nIt's not a number though (it's\
    \ a string representation of a number). The base is irrelevant to the problem\
    \ though, since it is simply a visual representation on the screen. It doesn't\
    \ matter what it actually is, as long as it's in the right range. For example,\
    \ base 4 should work as well.\n<|/ c |>\n<| c |>\nHe is converting a number to\
    \ another number (base), not vice versa. He could just as well have a string representation\
    \ of the number in the given base (base 10 in this case). You might want to try\
    \ out your example with base 4, and see what it does.\n<|/ c |>\n<| c |>\nIn that\
    \ case, I'm wrong. I'll delete the comment, since you've already removed it.\n\
    <|/ c |>\n<| c |>\nThank you, this solves my problem perfectly. Do you know of\
    \ any way to get the \"remainder\" (what remains of a division by 10, in this\
    \ case)? For example, is there a way to get the decimal part of a division (after\
    \ dividing by 10)? I would have thought that if there was, this would be the solution,\
    \ but this doesn't seem to be the case.\n<|/ c |>\n<| c |>\nDivide by 10. If that\
    \ gives zero the number is integer and remainder is zero. If that gives one the\
    \ number is integer and remainder is the decimal part.\n<|/ c |>\n<| a dscore=1\
    \ |>\nHere is a purely mathematical way of doing it (this assumes you're using\
    \ an IEEE float rather than a decimal type.)\n<code>\nint div10(int number)\n\
    {\n    int base = 10;\n\n    int exponent = 0;\n\n    while (number / base !=\
    \ 0)\n    {\n        exponent++;\n        base *= 10;\n    }\n\n    return exponent;\n\
    }\n</code>\n<|/ a tags=php,base,division,math |>\n<| c |>\nThis answer is actually\
    \ wrong. Try it with 10. You'll get the exponent, which is not the same as the\
    \ decimal part.\n<|/ c |>\n<| c |>\nThe question explicitly states that \"the\
    \ base is irrelevant\". I've added a note at the top to clarify that this is an\
    \ IEEE floating point number rather than a decimal number.\n<|/ c |>\n<| a |>\n\
    <code>", "  $r = \"\";\n  while ($x > 1) {\n    $r = base_convert($x, $base, $base)\
    \ . $r;\n    $x /= $base;\n  }\n  return $r;\n}\n", "  $basestr = base_convert($x,\
    \ 10, $base);\n  $basestr = str_pad($basestr, $base, 0, '0');\n  return $basestr;\n\
    }", "    if ($x > 0) {\n        $x = $x / $base;\n    } else {\n        $x = 1\
    \ / $x;\n    }\n    return floor($x * $base);\n}", "    return base_convert($x,\
    \ 10, $base);\n}", "    return $x * pow(10, $base - 1);\n}\n</code>\nExample output\
    \ using the above function:\n<code>\nchange_base(80000, 3)", "  $str = base_convert($x,\
    \ $base);\n  $result = \"\";\n  for ($i = 0; $i < strlen($str); $i++) {\n    $result\
    \ = $str[$i] + $result;\n  }\n  return $result;\n}\n", "\tif ($base < 2) { $base\
    \ = 2; };\n\t\n\tswitch ($base) {\n\t\tcase 2:\n\t\tcase 3:\n\t\tcase 4:\n\t\t\
    \t$x = $x * 100;\n\t\t\tbreak;\n\t\t\n\t\tcase 5:\n\t\t\t$x = $x * 10;\n\t\t\t\
    break;\n\t\t\n\t\tcase 6:\n\t\t\t$x = $x * 1;\n\t\t\tbreak;\n\t\t\n\t\tdefault:\n\
    \t\t\t$x = $x;\n\t\t\tbreak;\n\t}\n\t\n\treturn $x;\n}", "\t$xstr = strval($x);\n\
    \t$basestr = strval($base);\n\t$xstr = str_pad($xstr, strlen($basestr), $basestr,\
    \ 'left');\n\t$xstr = base_convert($xstr, $base, $base);\n\treturn $xstr;\n}\n",
  "    $digits = $x / $base;\n    $rem    = $x % $base;\n    return $rem ? $digits\
    \ * $base + $rem : $digits;\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis helped\
    \ me a lot. Thanks!\n<|/ c |>\n<| a |>\nThe solution with divide and modulo (base^digits)\
    \ is very fast and simple. \nHowever it doesn't work in some cases. I came up\
    \ with another solution which works fast (on large numbers) and with more accuracy:\n\
    <code>\n$base = 10;\n$number = '100000000';\n\n$digits = strlen($number);\n$result\
    \ = [];\nfor ($i = 0; $i < $digits; $i++) {\n    $result[$i] = 0;\n}\n\nfor ($j\
    \ = 0; $j < strlen($number); $j++) {\n    $result[$j] ^= $number[$j] * pow($base,\
    \ $j);\n}\n\necho sprintf('%d%s', $result[0] , $number[$digits-1]);\n</code>\n\
    The idea is to use XOR to create the number in base 10. For example the number\
    \ 100000000 can be represented in binary as 001001010, which can be represented\
    \ in base 10 as:\n<code>\n001001010 ^ 001001010 = 00001110\n</code>\nSo the function\
    \ above will return the right value.\n<|/ a tags=algorithm,base-conversion,php\
    \ dscore=5 |>\n<| c |>\nThe solution by is much better in this case\n<|/ c |>\n\
    <| c |>\nThis answer is only correct for a number up to 99999999. Representing\
    \ a number like `100000000` in base 10 requires more than a hundred digits (`1110101111111110101000010111`).\
    \ So the other solutions are better.\n<|/ c |>\n<| c |>\nThanks, I've made a correction.\
    \ Yes, this is better answer, because you don't have to deal with numbers bigger\
    \ than `99999999`.\n<|/ c |>\n<| c |>\nThanks, I've made a correction.\n<|/ c\
    \ |>\n<| c |>\nThanks for the comment. I think it is true for bases up to 9, but\
    \ I haven't checked that. I am happy to learn something new!\n<|/ c |>\n<| a |>\n\
    A little bit faster:\n<code>", "  if ($x < 0 || $x != round($x)) {\n    $x = round($x);\n\
    \    $base = max(10, $base);\n    if ($base < 3) $base = 3;\n    $x = $base *\
    \ pow($base, $x - floor($x));\n  }\n  return $x;\n}", "  $y = $x;\n  do {\n  \
    \  $y = $y * $base;\n    $base = floor($base / 10);\n  } while ($y >= 10);\n \
    \ return $y;\n}", "    $base_digits = array_fill(0, $base, 1);\n    $result =\
    \ str_split(str_pade($x, $base_digits));\n    return implode('', $result);\n}\n",
  "  $digits = intval($x/$base);\n  return ($digits*$base)+$x%$base;\n}\n", "  if\
    \ ($x < 10) {\n    $digits = $x;\n  }\n  else {\n    $digits = base_convert($x,\
    \ $base, 10);\n  }\n  return $digits;\n}\n", "    $n = $x;\n    do {\n       \
    \ $n = ($n * $base) + 1;\n        $base /= 10;\n    } while ($base > 1);\n   \
    \ return $n;\n}\n", "    $xp = $x;\n    $basep = $base;\n    $res = '';\n    while\
    \ ($xp >= $basep) {\n        $mod = $xp % $basep;\n        $res = $basep . $mod\
    \ . $res;\n        $xp = ($xp - $mod) / $basep;\n    }\n    return $res;\n}\n\
    </code>\n<|/ a dscore=1 |>\n<| a |>\n<code>\n<?php\n$number = \"12112\";\n$base\
    \  = \"3\";\n$base2 = \"2\";\n$base3 = \"1\";\n$base4 = \"4\";\n$base5 = \"5\"\
    ;\n$base6 = \"6\";\n$base7 = \"7\";\n$base8 = \"8\";\n$base9 = \"9\";\n\n$number\
    \ = strrev($number);\n\n$digits = str_split($number);\n$newDigits = array();\n\
    \nfor ($i = 0; $i < count($digits); $i++) {\n    for ($j = 0; $j < strlen($base);\
    \ $j++) {\n        $newDigits[$i] = $digits[$i] . $base[$j];\n    }\n}\n\n$finalDigits\
    \ = array_map(function($a) { return array_reverse(str_split($a)); }, $newDigits);\n\
    $finalDigits = array_map(function($a) { return implode('', $a); }, $finalDigits);\n\
    \n$newBase = array();\nfor ($i = 0; $i < count($finalDigits); $i++) {\n    for\
    \ ($j = 0; $j < strlen($base); $j++) {\n        $newBase[$i] .= $finalDigits[$i][$j];\n\
    \    }\n}\n\n$finalBase = array_map(function($a) { return array_reverse(str_split($a));\
    \ }, $newBase);\n$finalBase = array_map(function($a) { return implode('', $a);\
    \ }, $finalBase);\n\n$newBase2 = array();\nfor ($i = 0; $i < count($finalBase);\
    \ $i++) {\n    for ($j = 0; $j < strlen($base2); $j++) {\n        $newBase2[$i]\
    \ .= $finalBase[$i][$j];\n    }\n}\n\n$finalBase2 = array_map(function($a) { return\
    \ array_reverse(str_split($a)); }, $newBase2);\n$finalBase2 = array_map(function($a)\
    \ { return implode('', $a); }, $finalBase2);\n\n$newBase3 = array();\nfor ($i\
    \ = 0; $i < count($finalBase2); $i++) {\n    for ($j = 0; $j < str", "  $base\
    \ = 10 ** $base;\n  if ($x < $base) {\n    return floor($x / $base) * $base;\n\
    \  }\n  return $x;\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nGreat answer! Just\
    \ a minor thing: you should be using `str_repeat` instead of `str_split` here\n\
    <|/ c |>\n<| c |>\nYes, thank you. I was looking for something like that and you\
    \ saved my life! And you are right, `str_repeat` is more elegant.\n<|/ c |>\n\
    <| a dscore=3 |>\n<code>\n<?php\n", "  $res = $x; // original value.\n  while\
    \ (true) {\n    $res = bcdiv($res, $base, 0);\n    if ($res == 0) {\n      break;\n\
    \    }\n    $res = \"0\" . $res;\n  }\n  return $res;\n}\n", "    if ($x < 0 ||\
    \ $base < 2) {\n        return \"Error: Base must be between 0 and 2\";\n    }\n\
    \n    if ($x < 10) {\n        return $x;\n    }\n\n    $baseStr = \"0123456789abcdefghijklmnopqrstuvwxyz\"\
    ;\n    $x = $x % $base;\n    $y = $baseStr[$x];\n\n    $xDivBase = (int)($x /\
    \ $base);\n    if ($xDivBase > 0) {\n        return change_base($xDivBase, $base)\
    \ . $y;\n    }\n\n    return $y;\n}\n", "    if ($base < 2) {\n        $base =\
    \ $base + 10;\n    }\n    $digits = array();\n    while ($x >= $base) {\n    \
    \    $digits[] = floor($x / $base);\n        $x = $x % $base;\n    }\n    $digits[]\
    \ = $x;\n    return $digits[count($digits) - 1];\n}\n", "  $result = $x;\n  while\
    \ ($base > 0) {\n    $result = 10 * $result + $x % $base;\n    $x = floor($x /\
    \ $base);\n    $base--;\n  }\n  return $result;\n}", "  $base_names = array_flip(str_split($base));\n\
    \  $x = $base_names[$x];\n  return str_pad($x, strlen($base), \"0\", STR_PAD_LEFT);\n\
    }\n", "    return base_convert($x, $base, 10);\n}\n</code>\n<|/ a dscore=5 |>\n\
    <| c |>\nGreat solution. Works for me on all types of numbers (integer, float,\
    \ strings, etc). Thanks!\n<|/ c |>\n<| c |>\nI used your function and changed\
    \ it to a function that accepts string and integers and floats, instead of an\
    \ arbitrary base that could be negative. Thanks a bunch!\n<|/ c |>\n<| c |>\n\
    : Nice! I added that function to the answer.\n<|/ c |>\n<| a dscore=3 |>\nPHP\
    \ has a decent set of math functions, including arbitrary-precision integer arithmetic.\
    \  Use it if you want a big number library that can handle arbitrarily large numbers.\n\
    <|/ a tags=php,math,bignum |>\n<| a |>\nTry this one:\n<code>\n<?php\n$num = $_POST[\"\
    num\"];\n$base = array('10', '8', '6', '5', '4', '3', '2', '1');\n$out = \"\"\
    ;\n$i = 0;\nwhile ($i < strlen($num)) {\n    if ($i < strlen($num) - strlen($num)\
    \ % $base[$i]) {\n        $out .= $num[$i];\n        $i++;\n    } else {\n   \
    \     $val = $base[$i];\n        while ($i < strlen($num) - strlen($num) % $val)\
    \ {\n            $out .= $num[$i++];\n        }\n    }\n}\necho($out);", "  $base\
    \ = intval($base);\n  $x = intval($x);\n  if ($base < 2) {\n    return $x;\n \
    \ }\n  if ($base > $x) {\n    throw new Exception\\InvalidArgumentException(sprintf('Base\
    \ number must be < %d', $x));\n  }\n  $r = $x;\n  $quotient = $x % $base;\n  while\
    \ ($quotient > 0) {\n    $r = $base * $r + $quotient;\n    $quotient = $quotient\
    \ / $base;\n  }\n  return $r;\n}\n", "  $y = $x;\n  while ($base > 10) {\n   \
    \ $y *= base;\n    $base -= 10;\n  }\n  return $y;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nWhile this code may answer the question, providing additional context\
    \ regarding how and/or why it solves the problem would improve the answer's long-term\
    \ value.\n<|/ c |>\n<| c |>\nThanks. I added an explanation.\n<|/ c |>\n<| a tags=arrays,string,php\
    \ dscore=0 |>\nI suppose this could be done with regular expressions but this\
    \ is way easier.  You just have to change the output in the right place.  \n<code>"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
