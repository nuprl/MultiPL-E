name: HumanEval_14_all_prefixes
language: php
prompt: "<?php\n// Return array of all prefixes from shortest to longest of the input\
  \ string\n// >>> all_prefixes(\"abc\")\n// array(\"a\", \"ab\", \"abc\")\nfunction\
  \ all_prefixes($string) {\n"
tests: "function candidate(...$args) {\n    return all_prefixes(...$args);\n}\n\n\
  function test(): void {\n    if (candidate(\"\") !== array()) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(\"asdfgh\") !== array(\"a\", \"as\", \"asd\"\
  , \"asdf\", \"asdfg\", \"asdfgh\")) { throw new Exception(\"Test failed!\"); }\n\
  \    if (candidate(\"WWW\") !== array(\"W\", \"WW\", \"WWW\")) { throw new Exception(\"\
  Test failed!\"); }\n}\n\ntest();"
completions: ["    return array_map(function($s) { return $s[0]; }, explode($string));\n\
    }\n", "    $result = array();\n    $stack = array();\n    $length = 0;\n    //\
    \ Process each character one by one\n    for ($i = 0; $i < strlen($string); $i++)\
    \ {\n        $char = substr($string, $i, 1);\n        $length = max($length, strlen($stack));\
    \ // Get the current length of the stack\n        // If we find a letter longer\
    \ than the current stack, we can drop it\n        if (strlen($stack) > 0 && isset($stack[strlen($stack)\
    \ - 1]) && isset($stack[strlen($stack) - 1][$char])) {\n            $stack = array_pop($stack);\n\
    \        }\n        // If we encounter a character at the bottom of the stack\
    \ (i.e. the string ended), then we can add it to the result\n        if ($length\
    \ === $i) {\n            $result = array_merge($result, $stack);\n        }\n\
    \        // Add prefix to the stack if there is one\n        if (!empty($stack))\
    \ {\n            $stack[] = $char;\n        }\n    }\n    return $result;\n}\n",
  "    $array = array();\n    foreach(str_split($string) as $character) {\n      \
    \  $array[] = preg_quote($character, \"/\");\n    }\n    return $array;\n}", " \
    \   $prefixes = array();\n    $current_length = 0;\n\n    foreach (explode($string)\
    \ as $character => $length) {\n        $current_length += $length;\n        $prefixes[$character]\
    \ = $prefix . ($current_length < $length ? \"{$prefix}\" : \"{$prefix}...\")\n\
    \    }\n\n    return $prefixes;\n}\n</code>\nThe same function can be written\
    \ for longest prefix and suffix as follows:\n<code>", "    $prefixes = array();\n\
    \    // Loop through each character in the string\n    for ($i = 0; $i < strlen($string);\
    \ $i++) {\n        // Loop through all previously found prefixes\n        foreach\
    \ ($prefixes as $prefix) {\n            // If the character at the current index\
    \ matches the previous prefix\n            // and the next character in the string\
    \ is a non-whitespace character\n            if ($string[$i] == $prefix and ctype_space($string[$i\
    \ + 1])) {\n                // Add the prefix to the list of prefixes and skip\
    \ the character at index $i\n                $prefixes[] = $prefix;\n        \
    \        unset($string[$i]);\n                break;\n            }\n        }\n\
    \    }\n    return $prefixes;\n}\n\n$string = \"abc\";", "\t$prefixes = array();\n\
    \tfor ($i = 0; $i < strlen($string); $i++) {\n\t\t$prefixes[] = substr($string,\
    \ 0, $i);\n\t}\n\treturn $prefixes;\n}\n", "\t$prefixes = array();\n\tfor ($i\
    \ = 0; $i < strlen($string); $i++) {\n\t\t$prefix = substr($string, 0, $i);\n\t\
    \tarray_push($prefixes, $prefix);\n\t}\n\treturn $prefixes;\n}\n", "    $return\
    \ = array();\n    $i = 0;\n    while (substr($string, $i, 1) !== false) {\n  \
    \      $return[] = substr($string, 0, $i);\n        $i++;\n    }\n    return $return;\n\
    }\n", "  $prefixes = array();\n  $len = strlen($string);\n\n  for ($i = 0; $i\
    \ < $len; ++$i) {\n    $prefix = substr($string, 0, $i);\n    $prefixes[$prefix]\
    \ = 1;\n\n    for ($j = $i + 1; $j < $len; ++$j) {\n      $prefixes[$prefix .\
    \ $j] = 1;\n    }\n  }\n\n  return $prefixes;\n}", "    $prefixes = array();\n\
    \    $length = strlen($string);\n    for ($i = 0; $i < $length; $i++) {\n    \
    \    $prefix = substr($string, 0, $i);\n        $prefixes[] = $prefix;\n    }\n\
    \    return $prefixes;\n}\n", "    $prefixes = array();\n    $strings = str_split($string);\n\
    \    foreach($strings as $string) {\n        $prefixes[] = substr($string, 0,\
    \ 1);\n    }\n    return $prefixes;\n}\n", "    $result = array();\n    foreach\
    \ (str_split($string, 1) as $char) {\n        $result[$char] = $char;\n    }\n\
    \    return $result;\n}\n", "    $prefixes = array();\n    for ($i = 0; $i < strlen($string);\
    \ ++$i) {\n        $prefix = substr($string, 0, $i);\n        if (in_array($prefix,\
    \ $prefixes)) $prefixes[] = $prefix;\n    }\n    return $prefixes;\n}\n</code>\n\
    <|/ a tags=php,arrays,regex |>\n<| c |>\nYes, that's the most concise and most\
    \ readable answer!\n<|/ c |>\n<| c |>\nGood answer, but it's not working as expected..\
    \ Try it with my example string. Also try the full code!\n<|/ c |>\n<| c |>\n\
    Thank you for the response! I used that same logic that you just gave me and it\
    \ works perfectly! You're a genius!\n<|/ c |>\n<| c |>\nThis answer fails on `all_prefixes(\"\
    a\")` which should return `array('a', 'aa')` but returns `array('a')`\n<|/ c |>\n\
    <| c |>\nIt also fails when passed an empty string.  It should be returning `array(\"\
    \")` rather than `array(\"\", \"a\")`\n<|/ c |>\n<| a dscore=3 |>\nYou could just\
    \ use substr() with strpos() to find the position of the first character in the\
    \ string that is not a vowel character, and then increment that position by one\
    \ until you hit another vowel character:\n<code>\n$str = 'abc';\n\n$arr = [];\n\
    while (($pos = strpos($str, 'a')) !== FALSE) {\n    $arr[] = substr($str, 0, $pos);\n\
    \    $str = substr($str, $pos + 1);\n}\n\n$arr[] = $str;\n</code>\nThis will end\
    \ up with $arr = ['', 'a', 'ab', 'abc']\n<|/ a tags=php,arrays,regex |>\n<| c\
    \ |>\nHi Aaron, thank you for the response! This works great! However, it leaves\
    \ the 'a' at the beginning of the string. Could you edit your answer to have the\
    \ output start with the empty string at the beginning.\n<|/ c |>\n<| c |>\nNo\
    \ problem, glad to help! :)\n<|/ c |>\n<| c |>\nIf you want the empty string to\
    \ be in the first position of the array, then change the while loop to this: `while\
    \ (($pos = strpos($str, 'a')) !== FALSE) {\n    $arr[] = substr($str, 0, $pos)\
    \ . $str[$pos];\n    $str = substr($str, $pos + 1);\n}`\n<|/ c |>\n<| c |>\nHi\
    \ Aaron, thank", "    return array_slice(preg_split('/(?=^.)/', $string), 0, count($string));\n\
    }", "    $prefix = array();\n    // Find the longest prefix with at least one\
    \ character and add it to the prefix array\n    $max_len = strlen($string);\n\
    \    for($i = 0; $i < $max_len; $i++) {\n        $prefix[] = $string[$i];\n  \
    \  }\n    return $prefix;\n}\n", "    $length       = strlen($string);\n    $prefixLength\
    \ = min(2, $length - 1);\n\n    $prefix = array();\n    for ($i = 0; $i < $length;\
    \ $i++) {\n        $prefix[] = substr($string, 0, $i);\n    }\n\n    return array_merge($prefix,\
    \ array_slice($prefix, 0, $prefixLength - 1), array_slice($prefix, $prefixLength));\n\
    }\n", "\t$length = 0;\n\tforeach (preg_split('//', $string, -1, PREG_SPLIT_NO_EMPTY)\
    \ as $str) {\n\t\t$length += strlen($str);\n\t}\n\t$prefixes = array();\n\tfor\
    \ ($i = 0; $i < $length; $i++) {\n\t\t$prefixes[] = substr($string, 0, $i);\n\t\
    }\n\treturn $prefixes;\n}\n", "    $len = strlen($string);\n    if ($len < 2)\
    \ return array();\n    $prefix_array = array();\n    for ($i = 0; $i < $len; $i++)\
    \ $prefix_array[] = substr($string, 0, $i);\n    return $prefix_array;\n}\n",
  "    $result = array();\n    $len = strlen($string);\n    for ($i = 0; $i < $len;\
    \ $i++) {\n        $result[$i] = $string[$i];\n    }\n    return $result;\n}\n",
  "    $prefixes = array();\n    for ($i = 0; $i < strlen($string); $i++) {\n    \
    \    $prefixes[] = substr($string, 0, $i);\n    }\n    return $prefixes;\n}",
  "    $chars = str_split($string);\n    $prefixes = array();\n    foreach ($chars\
    \ as $char) {\n        $prefixes[] = $char;\n    }\n    return array_reverse($prefixes);\n\
    }\n", "    $prefixes = array();\n    $length = strlen($string);\n    $firstChar\
    \ = substr($string, 0, 1);\n    $lastChar = substr($string, $length - 1, 1);\n\
    \    for ($i = 1; $i < $length; $i++) {\n        $prefixes[] = $firstChar.substr($string,\
    \ 0, $i);\n    }\n    $prefixes[] = $lastChar;\n    return array_reverse($prefixes);\n\
    }\n", "  $array = preg_split('/(?<=.)/g', $string, -1, PREG_SPLIT_NO_EMPTY);\n\
    \  $prefixes = array();\n  foreach ($array as $string) {\n    foreach ($array\
    \ as $prefix) {\n      $prefixes[] = $prefix . $string;\n    }\n  }\n  return\
    \ $prefixes;\n}\n", "    $prefixes = array();\n    $prefix = '';\n    for ($i\
    \ = 0; $i < strlen($string); $i++) {\n        $char = substr($string, $i, 1);\n\
    \        if ($char === $prefix) {\n            $prefixes[] = $prefix;\n      \
    \  }\n        $prefix .= $char;\n    }\n    return $prefixes;\n}\n", "    // Initialize\
    \ result array\n    $result = array();\n    \n    // Return string as-is if it\
    \ doesn't contain any characters\n    if(strlen($string) == 0) {\n        return\
    \ $result;\n    }\n    \n    // Initialize prefix count with 0\n    $prefixCount\
    \ = 0;\n    \n    // Loop through each character in input string\n    for($i =\
    \ 0; $i < strlen($string); ++$i) {\n        // Increment prefix count by 1 if\
    \ character at current index is in prefix set\n        if(in_array($string[$i],\
    \ $prefixSet)) {\n            $prefixCount++;\n        }\n        // Add character\
    \ at current index to result array if it isn't a prefix set\n        else {\n\
    \            $result[] = $string[$i];\n        }\n    }\n    \n    // Return the\
    \ result array\n    return $result;\n}\n</code>\nAll credit for this function\
    \ goes to RobertPitt on StackExchange: https://stackoverflow.com/a/3860559/75580\n\
    I used a variation of this in my original answer: https://stackoverflow.com/a/28661894/75580\n\
    <|/ a |>\n<| a |>\nA simple recursive solution:\n<code>\n<?php\n", "    $prefixes\
    \ = array();\n    foreach($string as $char) {\n        $prefixes = array_merge($prefixes,\
    \ str_split($char));\n    }\n    return $prefixes;\n}\n\n$prefixes = all_prefixes(\"\
    abc\");\necho \"</pre>\";\n", "    $prefixes = array();\n    // Split input string\
    \ on characters and add each prefix to the prefix array\n    foreach (str_split($string)\
    \ as $char) {\n        $prefixes[] = $char;\n        // Return array with remaining\
    \ characters\n        if ($char != \"\") {\n            $suffixes = array_slice($prefixes,\
    \ 0, count($prefixes)-1);\n            foreach ($suffixes as $prefix) {\n    \
    \            $prefixes[] = $prefix;\n            }\n        }\n    }\n    return\
    \ $prefixes;\n}", "    $result = array();\n    for ($i = 0; $i < strlen($string);\
    \ $i++) {\n        $prefix = substr($string, 0, $i);\n        $result[$prefix]\
    \ = $prefix;\n    }\n    return $result;\n}\n", "  $alphabet = array_merge(range(0,9),\
    \ range('A', 'Z'));\n  $prefixes = array();\n  foreach ($alphabet as $letter)\
    \ {\n    for ($i = strlen($string); $i >= 0; $i--) {\n      $prefixes[] = substr($string,\
    \ 0, $i);\n    }\n  }\n  return $prefixes;\n}\n", "    $array = array();\n   \
    \ $length = 0;\n    for ($i = 0; $i < strlen($string); $i++) {\n        $length++;\n\
    \        if ($string[$i] === \"$\") {\n            $array[$length - 1] .= \"\\\
    \\$\";\n        } else {\n            $array[$length] = $string[$i];\n       \
    \ }\n    }\n    return $array;\n}\n", "    $length  = strlen($string);\n    $prefixes\
    \ = array();\n    \n    // Find longest prefix of string\n    // Loop through\
    \ string from left to right and add all suffixes of prefix to a new array\n  \
    \  // Only add prefixes that have more than one character and have no duplicates\n\
    \    for ($i = 0; $i < $length; $i++) {\n        $character = substr($string,\
    \ $i, 1);\n        \n        // If length of character is 1 then add character\
    \ to prefix array\n        if ($character == 1) {\n            $prefixes[] = $character;\n\
    \        }\n        // If length of character is greater than 1 then check if\
    \ prefix has already been added\n        elseif (array_key_exists($character,\
    \ $prefixes)) {\n            if (count($prefixes) == 1) {\n                $prefixes[]\
    \ = $character;\n            }\n        } else {\n            $prefixes[] = $character;\n\
    \        }\n    }\n    \n    return $prefixes;\n}", "    $array = array();\n \
    \   for ($i = 0; $i < strlen($string); $i++) {\n        $array[] = $string[0];\n\
    \    }\n    return array_reverse($array);\n}\n</code>\nOutput:\n<code>\nArray\n\
    (\n    [0] => a\n    [1] => ab\n    [2] => abc\n    [3] => b\n    [4] => bc\n\
    \    [5] => c\n)\n</code>\n<|/ a dscore=4 tags=string,algorithm,sorting,php |>\n\
    <| c |>\nWow! Thank you, this is perfectly what I need. I've implemented it in\
    \ my code now. It works perfectly. Thank you so much!\n<|/ c |>\n<| c |>\nglad\
    \ to help :)\n<|/ c |>\n<| c |>\nThis is great! but is there a way I can do this\
    \ on multiple columns in same table?\n<|/ c |>\n<| c |>\nI mean if I have columns\
    \ a and b I want to be able to get output as ab and abc. Is there a way I could\
    \ do it?\n<|/ c |>\n<| c |>\nYes, you can do this by adding an extra condition\
    \ in `for` loop, see my updated answer.\n<|/ c |>\n<| a tags=string,algorithm,sorting,php\
    \ dscore=3 |>\nSince PHP 5.5, there is a built-in function called range(), which\
    \ can do this:\n<code>\n$alphabets = range(\"a\", \"z\");\nshuffle($alphabets);\n\
    $alphabets = array_slice($alphabets, 0, 1);\n$alphabets[] = \"\";\nshuffle($alphabets);\n\
    print_r($alphabets);\n</code>\nThis generates an array containing the 26 letters\
    \ A-Z and shuffles the array. You can then take the first and last element to\
    \ create the string.\nDemo: http://ideone.com/Z4EYpU\n<|/ a |>\n<| c |>\nThis\
    \ is perfect. Thank you\n<|/ c |>\n<| c |>\nThanks for the demo. Very nice\n<|/\
    \ c |>\n<| a |>\nJust one line :\n<code>\n$str='abcdefghijklmnopqrstuvwxyz';\n\
    echo implode(range(array_shift(str_split($str)),array_pop(str_split($str))))\n\
    </code>\nOutput :\n<code>\nabcde\nfghij\nklmno\npqrst\nuvwxy\n</code>\n<|/ a tags=string,algorithm,sorting,php\
    \ dscore=2 |>\n<| a tags=string,algorithm,sorting,php |>\nHere is a different\
    \ approach:\n<code>\n$arr = array", "    $prefixes = array();\n    $length = strlen($string);\n\
    \    for ($i = 0; $i < $length; $i++) {\n        $prefixes[] = substr($string,\
    \ 0, $i);\n    }\n    return $prefixes;\n}\n</code>\nThen you just have to call\
    \ it for each prefix.\n<|/ a dscore=0 |>\n<| c |>\nI do know that, but that would\
    \ require me to have a \"table\" like \"abc\" as rows and prefix as the columns.\
    \  This table would be pretty huge and would require to be updated every month,\
    \ so that's not a good solution.\n<|/ c |>\n<| c |>\nWell then what about just\
    \ having one table where you have the prefix and the length of the prefix, and\
    \ just insert the prefix of the string and the length of the prefix into the table?\
    \ This would be much easier than trying to do it in one query as far as I know.\
    \ Sorry if I'm just missing the point here.\n<|/ c |>\n<| c |>\nSorry, but I don't\
    \ understand.  You have the table, have you used the table or just used the prefixes?\n\
    <|/ c |>\n<| c |>\nI guess I should expand my answer, let me know if it works\
    \ for you\n<|/ c |>\n<| c |>\nI added some example code. Not sure if it's what\
    \ you need, but it's basically what I have in mind. You don't need multiple tables.\n\
    <|/ c |>\n<| a tags=php,sql,prefix |>\n<code>\n$prefixes = array();\n$prefixes[]\
    \ = 'aaa';\n$prefixes[] = 'bbb';\n$prefixes[] = 'ccc';\n$prefixes[] = 'ddd';\n\
    $prefixes[] = 'eee';\n$prefixes[] = 'fff';\n$prefixes[] = 'ggg';\n$prefixes[]\
    \ = 'hhh';\n$prefixes[] = 'iii';\n$prefixes[] = 'jjj';\n$prefixes[] = 'kkk';\n\
    $prefixes[] = 'lll';\n$prefixes[] = 'mmm';\n$prefixes[] = 'nnn';\n$prefixes[]\
    \ = 'ooo';\n$prefixes[] = 'ppp';\n$prefixes[] = 'qqq';\n$prefixes[] = 'rrr';\n\
    $prefixes[] = 'sss';\n$prefixes[] = 'ttt';\n$prefixes[] = 'uuu';\n$prefixes[]\
    \ = 'vvv';\n$prefixes[] = 'www';\n$prefixes[] = 'xxx';\n$prefixes[", "  $prefixes\
    \ = array();\n  $string = str_split($string);\n  $length = count($string);\n\n\
    \  for ($i = 0; $i < $length; $i++) {\n    $prefixes[] = $string[$i];\n  }\n \
    \ return $prefixes;\n}", "    $prefixes = array();\n    $current_length = strlen($string);\n\
    \    \n    $prefix = \"\";\n    for ($i = 0; $i < $current_length; $i++) {\n \
    \       $prefix = $prefix . $string[$i];\n        $prefixes[] = $prefix;\n   \
    \ }\n    return $prefixes;\n}\n", "  $prefixes = array();\n\n  for ($i = 0; $i\
    \ < strlen($string); $i++) {\n    $prefixes[] = $string[$i];\n\n    if (substr($string,\
    \ $i, 1) === $string[$i]) {\n      $prefixes[] = substr($string, 0, $i);\n   \
    \   break;\n    }\n  }\n\n  return $prefixes;\n}\n", "  $prefixes = array();\n\
    \  for ($len = strlen($string); $len > 0; $len--) {\n    $char = $string[$len];\n\
    \    for ($i = 0; $i < $len; $i++) {\n      if ($string[$i] == $char) {\n    \
    \    $prefixes[] = $char;\n        break;\n      }\n    }\n  }\n  return $prefixes;\n\
    }\n\n$prefixes = all_prefixes('abcde');\necho count($prefixes);\n</code>\n<|/\
    \ a dscore=0 tags=arrays,php |>\n<| c |>\nHm, this is basically the solution I\
    \ mentioned in my answer - I was thinking whether I should actually add another\
    \ answer - but I'll leave it as-is for now\n<|/ c |>\n<| c |>\nHaha, no problem,\
    \ thanks for the answer and your time!\n<|/ c |>\n<| c |>\n- no problem. Glad\
    \ I could help. I deleted my answer, as your answer is a good one (I just didn't\
    \ see it before), but I do think your approach is the best possible for what OP\
    \ is asking for.\n<|/ c |>\n<| a dscore=0 tags=arrays,php |>\n<code>", "\t$prefix\
    \ = array();\n\t$length = strlen($string);\n\tfor ($i = 0; $i < $length; ++$i)\
    \ {\n\t\t$prefix[] = $string[$i];\n\t\t$suffixes = array_reverse(all_suffixes($string));\n\
    \t\tforeach ($suffixes as $suffix) {\n\t\t\t$prefix[] = $suffix;\n\t\t}\n\t}\n\
    \treturn array_reverse($prefix);\n}", "    $prefixes = array();\n\n    foreach\
    \ (str_split($string) as $char) {\n        $prefixes[] = $char;\n    }\n\n   \
    \ while (count($prefixes) > 0) {\n        $new_prefixes = array();\n        foreach\
    \ ($prefixes as $prefix) {\n            for ($i = 0; $i < count($prefixes); $i++)\
    \ {\n                if (strlen($prefix . $prefixes[$i]) <= strlen($prefix)) {\n\
    \                    $new_prefixes[] = $prefixes[$i];\n                }\n   \
    \         }\n        }\n        $prefixes = $new_prefixes;\n    }\n\n    return\
    \ $prefixes;\n}\n", "    $min_length = min(strlen($string), strlen($string));\n\
    \    $all_prefixes = array();\n    for ($i = 0; $i < $min_length; $i++) {\n  \
    \      $all_prefixes[] = $string[$i];\n    }\n    $all_prefixes[] = '';\n    return\
    \ $all_prefixes;\n}\n</code>\nThis code assumes you're using PHP >= 5.3 -- if\
    \ you're using a previous version, the functions above can be modified for compatibility\
    \ by modifying the functions' names and altering their parameters.  Alternatively,\
    \ you can use anonymous functions to do the same thing, but that makes the code\
    \ less readable.\n<|/ a tags=algorithm,string,php |>\n<| c |>\nNice code. I was\
    \ just about to post a similar answer but you beat me to it. I'm glad you added\
    \ the explanation of why your code works. I love the use of `implode` - I never\
    \ thought about that before.\n<|/ c |>\n<| c |>\nYeah, `implode` is quite useful\
    \ when you want to join something with a string using some character (like `\"\
    \\n\"`, `\"\\n\"`, `\"\\r\\n\"`, or even a custom character of your choice), but\
    \ you don't want to worry about whether your string has whitespace or not, and\
    \ you know that the string will have at least one character of your choosing at\
    \ some point (otherwise, why use a string?).\n<|/ c |>\n<| c |>\nWhat about spaces\
    \ or multiple spaces between words? The above code doesn't include those cases.\n\
    <|/ c |>\n<| c |>\nWell, the OP didn't ask about that.  It's not like there's\
    \ a canonical solution for handling multiple spaces or multiple whitespaces, since\
    \ there's an infinite number of ways to interpret that.  As a result, we would\
    \ need to assume that multiple spaces or multiple whitespaces is the same as the\
    \ OP intended behavior, and handle that case separately.\n<|/ c |>\n<| c |>\n\
    I've updated the solution to handle spaces and multiple spaces correctly.  Also,\
    \ I've added a couple of extra cases to handle `''` vs `null`, `false`, and `'0'`\
    \ (which aren't in the OP's code but are actually valid input).\n<|/ c |>\n<|\
    \ a dscore=3 tags=algorithm,string,php |>\n<code>\n<?php", "    $prefixes = array();\n\
    \    $length = 1;\n    while (strlen($string) > $length) {\n        $prefixes[]\
    \ = substr($string, 0, $length);\n        $string = substr($string, $length);\n\
    \        $length++;\n    }\n    return $prefixes;\n}\n", "    foreach (explode('',\
    \ $string) as $i => $substr) {\n        $prefix = substr($string, 0, $i);\n  \
    \      yield $prefix;\n    }\n}\n", "    // Return empty array if there are no\
    \ prefixes\n    if (strlen($string) == 0) {\n        return array();\n    }\n\n\
    \    $prefixes = array();\n    for ($i = 0; $i < strlen($string); $i++) {\n  \
    \      $prefixes[] = substr($string, 0, $i);\n    }\n    return $prefixes;\n}\n\
    </code>\n<|/ a dscore=4 |>\n<| c |>\nHi Michael, Thanks for the answer but can\
    \ you please explain the code in detail. Thanks\n<|/ c |>\n<| c |>\nSure. This\
    \ code takes an array of prefixes and calculates the longest prefix for each string.\
    \ For each string it calculates the longest prefix which is its first character.\
    \ It then returns an array containing all prefixes in order of length and their\
    \ lengths as well. Do you understand why this works? The code doesn't do anything\
    \ complicated, it's just doing the same thing as your original code, but in less\
    \ lines of code. How did you get to this code?\n<|/ c |>\n<| c |>\nHi, I understand\
    \ your code but still cant understand why it works. I used your code but got output\
    \ like this `array(1) { [0]=> string(5) \"a\" }` which is wrong\n<|/ c |>\n<|\
    \ c |>\nIt seems like the code you had is still giving you an array of all the\
    \ prefixes in order of length and their lengths. If you want to output the longest\
    \ prefix just replace this line `$prefixes[] = substr($string, 0, $i);` with this\
    \ line `$prefixes[] = $string[0];` and remove the line that calculates the length.\
    \ Let me know if that works out for you. I'll add it to my answer above as well.\n\
    <|/ c |>\n<| c |>\nI understood your code but still cant understand why it works\
    \ when I used your code. As I told you, I use your code but my output is `array(1)\
    \ { [0]=> string(5) \"a\" }`. I just want output like this `array(1) { [0]=> string(4)\
    \ \"abc\" }`\n<|/ c |>\n<| a tags=arrays,algorithm,php,string dscore=1 |>\nOne\
    \ of the most useful answers here was made for PHP, but I will also provide some\
    \ Python3 code, which I believe is easier to understand for those unfamiliar with\
    \ Python.\n<code>\ndef all_prefixes(word):\n    prefixes = []\n    for letter\
    \ in word:\n        prefixes.append(word[:letter])\n    return prefixes\n\nprint(all_prefixes('abc'))\n\
    </code>\n<|/ a |>\n<| a |>\n<code>\n<?php\n", "  return array_slice(explode(',',\
    \ $string), 0, -1);\n}", "  $prefixes = array();\n  $prefix_length = strlen($string);\n\
    \  for ($i = 0; $i < $prefix_length; $i++) {\n    $prefix = substr($string, 0,\
    \ $i);\n    // Ignore empty prefix\n    if (empty($prefix)) {\n      continue;\n\
    \    }\n    // Ignore if prefix is shorter than the string length\n    if (strlen($prefix)\
    \ < $prefix_length) {\n      continue;\n    }\n    // Ignore if prefix length\
    \ greater than the string length\n    if ($prefix_length > strlen($prefix)) {\n\
    \      continue;\n    }\n    $prefixes[] = $prefix;\n  }\n  return $prefixes;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThanks, your answer is pretty good, but I find\
    \ it quite complicated. :D\n<|/ c |>\n<| c |>\nThank you. I thought it would be\
    \ a one-liner by someone else already. :D\n<|/ c |>\n<| c |>\nThe complexity is\
    \ O(N*logN) so it is slower than the accepted answer.\n<|/ c |>\n<| c |>\n, I\
    \ have added the source code to my answer.\n<|/ c |>\n<| c |>\nThank you for your\
    \ answer. I will test your function and tell you if it's fast enough.\n<|/ c |>\n\
    <| a |>\nThis is probably the fastest solution but it is O(N*logN), i.e. O(NlogN).\n\
    <code>\n$pattern = 'a*';\n$string = 'aabc';\npreg_match_all('/('.$pattern.')/',\
    \ $string, $matches);\n$prefixes = array_map(function ($match) {\n    return $match[0];\n\
    }, $matches[1]);\n</code>\n<|/ a dscore=3 tags=arrays,string,php,algorithm |>\n\
    <| c |>\n`preg_match_all` takes O(NlogN) too\n<|/ c |>\n<| c |>\nI tested the\
    \ function with some test cases and the result is that the accepted answer is\
    \ faster.\n<|/ c |>\n<| c |>\nI have added the source code to my answer.\n<|/\
    \ c |>\n<| c |>\n: Are you sure that the complexity is the same for both solutions?\n\
    <|/ c |>\n<| c |>\nI added a comparison between my solution and your solution.\n\
    <|/ c |>\n<| a tags=arrays,string,php,algorithm |>\nA simple one line solution\
    \ in PHP would be\n<code>\narray_unique(array_map(function($x){return substr($x,0,1);},explode(\"\
    *\", $", "    if (empty($string)) {\n        return array();\n    }\n\n    $prefixes\
    \ = array();\n    for ($len = strlen($string); $len > 0; $len--) {\n        $prefixes[]\
    \ = substr($string, 0, $len);\n    }\n\n    return $prefixes;\n}\n", "    $prefixes\
    \ = array();\n    $i = 0;\n    // While there are still characters in the string\n\
    \    while ($i < strlen($string)) {\n        // Increment the index by one\n \
    \       $i++;\n        // Get the prefix of the string and add it to the array\n\
    \        $prefixes[] = substr($string, 0, $i);\n    }\n    return $prefixes;\n\
    }", "    $prefixes = array();\n    $chars = str_split($string);\n    foreach ($chars\
    \ as $char) {\n        $chars = str_split($char);\n        foreach ($chars as\
    \ $c) {\n            $prefixes[] = $char;\n        }\n    }\n    return $prefixes;\n\
    }\n", "    $prefixes = array();\n    foreach (str_split($string) as $value) {\n\
    \        $prefixes[] = $value;\n        foreach ($prefixes as $prefix) {\n   \
    \         $prefixes[] = $prefix.$value;\n        }\n    }\n    return $prefixes;\n\
    }\n", "    $chars = preg_split('//', $string, -1, PREG_SPLIT_NO_EMPTY);\n    $prefixes\
    \ = array();\n    foreach ($chars as $char) {\n        $prefixes[] = $char;\n\
    \    }\n    $prefixes[] = '';\n    return array_reverse($prefixes);\n}\n", " \
    \ $prefixes = array();\n  $string = strtolower($string);\n  $prefix = $string;\n\
    \  for ($i = 0; $i < strlen($string); $i++) {\n    $prefix = substr($string, 0,\
    \ $i) . $prefix;\n    $prefixes[] = $prefix;\n  }\n  return $prefixes;\n}\n</code>\n\
    I feel it might be faster to use array_filter to remove any duplicates, rather\
    \ than looping through the array and comparing each element to the rest, but I'm\
    \ just not sure.\n<|/ a tags=php,string,algorithm |>\n<| a dscore=1 |>\nI guess\
    \ it would be something along the lines of this.\n<code>\n<?php\n$input = 'ab';\n\
    $result = '';\n$strings = str_split($input);\n$last = $strings[0];\nforeach ($strings\
    \ as $index => $string) {\n    $result .= $string;\n    if ($index === 0) {\n\
    \        $result = $result;\n    }\n    if ($index === count($strings) - 1) {\n\
    \        $result .= $last;\n    } else {\n        $result .= $last . $string;\n\
    \    }\n    $last = $string;\n}\nprint_r($result);\n</code>\n<|/ a tags=php,string,algorithm\
    \ |>\n<| c |>\nThis would only work if input was in order, i.e. a,b,ab,ac,abc\
    \ etc would give abca. As soon as you have a string of any characters as input\
    \ this would fail.\n<|/ c |>\n<| c |>\n- Yeah, that's true. This is an O(n) solution\
    \ that would only work with alphabetic inputs. I didn't realise the requirement\
    \ was alphabetic. Will think about it.\n<|/ c |>\n<| a tags=php,string,algorithm\
    \ dscore=0 |>\nYou could split the string into an array of single-character strings\
    \ and then use array_diff to find the duplicates:\n<code>\n$str = 'ab';\n$arr\
    \ = str_split($str);\n$duplicates = array_diff($arr, $arr[0]);\n</code>\n<|/ a\
    \ |>\n<| a dscore=0 |>\nI believe you can use the PHP function strtolower() to\
    \ convert your string to a lower case string.\nYou would then want to iterate\
    \ over each letter of the string comparing the lowercase version with the original.\
    \ Once the character does not match you know that the original string was a duplicate\
    \ and can remove it from the original string. The following pseudo code should\
    \ work:\n<code>\n$orig = \"abc\";\n$orig = strtolower($orig);\n$str = \"\";\n\n\
    foreach($orig as $char) {\n  if(strtolower($", "    $prefixes = array();\n   \
    \ $lenght = strlen($string);\n    for ($i = 0; $i < $lenght; $i++) {\n       \
    \ $prefixes[] = substr($string, 0, $i);\n    }\n    return $prefixes;\n}", " \
    \   return array_map(function($prefix) {\n        return substr($prefix, 0, 1);\n\
    \    }, $string);\n}\n", "    foreach (str_split($string) as $character) {\n \
    \       if ($character === '') {\n            continue;\n        }\n\n       \
    \ $prefixes = array_merge(\n            array_slice(str_split($string), 0, $character),\n\
    \            array($character)\n        );\n\n        if ($prefixes[0] === '')\
    \ {\n            continue;\n        }\n\n        return $prefixes;\n    }\n\n\
    \    return array('');\n}\n", "    $prefixes = array();\n    $len = strlen($string);\n\
    \    for ($i = 0; $i < $len; $i++) {\n        $prefixes[] = $string[$i];\n   \
    \ }\n    sort($prefixes);\n    return $prefixes;\n}\n", "    return array_filter(str_split($string),\
    \ 'strlen');\n}\n", "    $chars = str_split($string);\n    $prefixes = array();\n\
    \    foreach ($chars as $char) {\n        $prefixes = array_merge($prefixes, str_split($char));\n\
    \    }\n    sort($prefixes);\n    return array_slice($prefixes, 0, count($chars));\n\
    }\n", "    if (strlen($string) == 0) return array();\n    $prefixes = array();\n\
    \    $str = strtolower($string);\n    $pos = strlen($str) - 1;\n    while (0 !==\
    \ $pos) {\n        $prefix = substr($str, 0, $pos);\n        $prefixes[] = $prefix;\n\
    \        $str = substr($str, 0, --$pos);\n    }\n    return $prefixes;\n}\n",
  "    $prefixes = array();\n    $shortestLength = 0;\n    $longestLength = 0;\n \
    \   // Loop through all possible prefixes of $string\n    for ($i = 0; $i <= strlen($string);\
    \ $i++) {\n        // Check if prefix of $string exists in $prefixes array\n \
    \       if (in_array(substr($string, 0, $i), $prefixes)) {\n            // If\
    \ so, add it to $prefixes and remove it from $shortestLength\n            // and\
    \ $longestLength\n            $shortestLength = $i;\n            $longestLength\
    \ = $i;\n            $prefixes[] = substr($string, 0, $i);\n            unset($shortestLength,\
    \ $longestLength, $prefixes[$i]);\n            // Break out of loop if this prefix\
    \ is no longer needed, because all\n            // of its characters are in $string\n\
    \        } else if (substr($string, 0, $i) == substr($string, $i)) {\n       \
    \     $shortestLength = $shortestLength < $i ? $shortestLength : $i;\n       \
    \     $longestLength = $longestLength > $i ? $longestLength : $i;\n        }\n\
    \    }\n    return array($shortestLength, $longestLength, $prefixes);\n}\n", " \
    \   \n    $prefixes = array();\n    $stringLen = strlen($string);\n\n    for($i\
    \ = 0; $i < $stringLen; $i++) {\n        \n        $prefix = substr($string, 0,\
    \ $i);\n        $prefixes[] = $prefix;\n    }\n\n    return $prefixes;\n}\n",
  "    $prefixes = array();\n\n    for ($i = 1, $len = strlen($string); $i < $len;\
    \ $i++) {\n        $prefixes[] = substr($string, 0, $i);\n    }\n\n    return\
    \ $prefixes;\n}\n</code>\nThe PHP function strlen counts number of characters\
    \ in string. This function is defined in the PHP core. \n<code>\n/**\n* Returns\
    \ the length of the given string.\n*\n*    string\n*\n* int Length of the given\
    \ string\n*/", "    $array = [];\n    $prefix = \"\";\n    $length = 0;\n    for\
    \ ($i = 0; $i < strlen($string); $i++) {\n        $length++;\n        $prefix\
    \ = substr($string, 0, $i);\n        $array[] = $prefix;\n    }\n    return $array;\n\
    }\n", "  $prefixes = array();\n  for ($i = 0; $i < strlen($string); $i++) {\n\
    \    $prefix = substr($string, 0, $i);\n    if ($prefix !== '') {\n      $prefixes[]\
    \ = $prefix;\n    }\n  }\n  return $prefixes;\n}\n", "    $result = array();\n\
    \    // Use recursive function so we don't have to write lengthy code to do this\n\
    \    function allPrefixes($string, $start) {\n        if ($start >= strlen($string))\
    \ {\n            return $result;\n        }\n        // Recursive function calls\
    \ itself when current $start is larger than $string\n        $result = array();\n\
    \        // Loop through all characters in string from $start to end\n       \
    \ for ($i = $start; $i < strlen($string); $i++) {\n            // Add character\
    \ to our result array\n            $result[] = substr($string, 0, $i);\n     \
    \       // Append all character prefixes of string from $start up to current $i\n\
    \            $result = array_merge($result, allPrefixes(substr($string, $i), $i));\n\
    \        }\n        // Return our result array\n        return $result;\n    }\n\
    \    // Return our result array\n    return allPrefixes($string, 0);\n}\n", " \
    \ $prefixes = array();\n  $string  = strtolower($string);\n\n  do {\n    $prefixes[]\
    \ = substr($string, 0, 1);\n    $string = substr($string, 1);\n  } while ($string);\n\
    \n  return $prefixes;\n}\n", "    $prefix = array(\"\");\n    foreach (str_split($string)\
    \ as $s) {\n        $prefix[] = $s;\n    }\n    $prefix = array_reverse($prefix);\n\
    \    $result = [];\n    foreach ($prefix as $s) {\n        $result[] = $s.$s;\n\
    \    }\n    return $result;\n}\n", "    return array_map(function($s){return substr($s,0,1);},array_filter(explode($string,\"\
    $string\")));\n}", "    $array = [$string];\n    $length = strlen($string);\n\
    \    while ($length >= 0) {\n        $string = substr($string, 1, $length);\n\
    \        $array[] = $string;\n        $length--;\n    }\n    return $array;\n\
    }\n\n$array = all_prefixes(\"abc\");\n$array = array_reverse($array);\n\n$array\
    \ = array_merge(...$array);\nprint_r($array);\n</code>\n<|/ a |>\n<| c |>\nI did\
    \ not downvote, but I think this solution is more complicated than it needs to\
    \ be. You don't need to create a new array, just keep a pointer to the last element\
    \ of the array, and then append to it when needed.\n<|/ c |>\n<| a |>\nA simple\
    \ and elegant solution using array_reduce:\n<code>\n$string = \"abcaabcab\";\n\
    $array = array_reduce(array_slice(str_split($string), 1), function($carry, $item)\
    \ {\n    return array_merge($carry, array_slice($carry, 0, $item - 1));\n}, []);\n\
    </code>\nDemo: https://3v4l.org/WuM8Z\n<|/ a dscore=3 tags=arrays,php,string |>\n\
    <| a |>\nThis is my approach using array_reverse and array_slice\n<code>\n<?php\n\
    \    $string = \"abcaabcab\";\n    $array = array_reverse(str_split($string));\n\
    \    $array = array_slice($array, 0, $string.length);\n    var_dump($array);\n\
    </code>\nOutput\n<code>\narray(6) { [0]=> string(2) \"ab\" [1]=> string(2) \"\
    caa\" [2]=> string(2) \"ab\" [3]=> string(2) \"ca\" [4]=> string(2) \"a\" [5]=>\
    \ string(1) \"b\" }\n</code>\n<|/ a tags=arrays,php,string dscore=3 |>\n<| c |>\n\
    It's unclear to me why you call `array_reverse`?\n<|/ c |>\n<| c |>\nBecause the\
    \ OP said that the result should contain all the prefixes, not only the longest\
    \ one.\n<|/ c |>\n<| c |>\nThis doesn't give the correct result. For `abcaabcab`\
    \ the result is `array(\"a\", \"ab\", \"abc\", \"abca\", \"abcab\", \"abcca\"\
    , \"abcba\", \"abcaab\", \"abcaabc\", \"abcaabca\", \"abcaabcab\", \"abcaabcaba\"\
    )`. But the expected result given is `array(\"a\", \"ab\", \"abc\", \"abca\",\
    \ \"abcab\")`.\n<|/ c |>\n<| c |>\nGood catch, thank you. I fixed ", "    $prefixes\
    \ = array();\n    $length = strlen($string);\n\n    for ($i = 0; $i < $length;\
    \ $i++) {\n        if ($string[$i] == substr($string, $i - 1, 1))\n          \
    \  $prefixes[] = substr($string, 0, $i);\n    }\n\n    return $prefixes;\n}\n",
  "  $prefixes = array();\n  $length   = strlen($string);\n  for ($i = 0; $i < $length;\
    \ $i++) {\n    $prefix = substr($string, 0, $i);\n    if (substr($string, 0, $i)\
    \ === '0') {\n      $prefix = '';\n    }\n    $prefixes[] = $prefix;\n  }\n  return\
    \ $prefixes;\n}\n", "\t$prefixes = array();\n\tfor ($i = 0; $i < strlen($string);\
    \ $i++) {\n\t\t$prefixes[] = substr($string, 0, $i);\n\t}\n\treturn array_reverse($prefixes);\n\
    }\n", "  $prefixes = array();\n\n  // Return nothing if there are no characters\
    \ in string\n  if (strlen($string) === 0) {\n    return $prefixes;\n  }\n\n  //\
    \ Add prefix of first character to array\n  $prefixes[] = substr($string, 0, 1);\n\
    \n  // For all other characters, add to array the prefix of this character plus\
    \ any subsequent characters\n  for ($i = 1; $i < strlen($string); $i++) {\n  \
    \  $prefixes[] = substr($string, 0, $i);\n  }\n\n  // Return prefix array\n  return\
    \ $prefixes;\n}\n", "    $prefixes = array();\n    $shortestLength = min(strlen($string),\
    \ 3);\n    for ($i = 0; $i < $shortestLength; $i++) {\n        $prefixes[] = substr($string,\
    \ 0, $i);\n    }\n    return $prefixes;\n}\n", "    $prefixes = array();\n   \
    \ $s = strtolower($string);\n    for($i=1;$i<strlen($s);$i++) {\n        $prefixes[]\
    \ = $s[$i-1];\n    }\n    return $prefixes;\n}\n", "    $lengths = array_map('strlen',\
    \ str_split($string));\n    $prefixes = array_fill(0, count($lengths), 0);\n\n\
    \    // Get prefixes of the strings from shortest to longest\n    $prefix = 1;\n\
    \    for ($i = 1; $i < count($lengths); $i++) {\n        $prefixes[$i] = $prefix;\n\
    \        $prefix *= $lengths[$i];\n    }\n\n    return $prefixes;\n}\n", "   \
    \ $prefixes = array();\n    $length = 0;\n    foreach(explode($string) as $char)\
    \ {\n        $length++;\n        if($char !== '' && $char !== ' ' && $length >=\
    \ strlen($string)) {\n            $prefixes[] = substr($string, 0, $length);\n\
    \            break;\n        }\n    }\n    return $prefixes;\n}\n", "  $prefixes\
    \ = array();\n  for ($i = 0, $len = strlen($string); $i < $len; $i++) {\n    $prefixes[]\
    \ = substr($string, 0, $i);\n  }\n  return array_unique($prefixes);\n}\n", " \
    \   $prefixes = array();\n    $string = preg_replace(\"/[^a-z]/i\", \"\", $string);\n\
    \    $length = (strlen($string));\n    for ($i = 0; $i < $length; $i++) {\n  \
    \      $prefixes[] = $string[$i];\n    }\n    return array_reverse($prefixes);\n\
    }\n", "\t$prefix_lengths = array();\n\tfor ($i = 0; $i < strlen($string); $i++)\
    \ {\n\t\t$prefix = substr($string, 0, $i);\n\t\t$prefix_lengths[$prefix] = strlen($prefix);\n\
    \t}\n\tasort($prefix_lengths);\n\treset($prefix_lengths);\n\treturn array_keys($prefix_lengths);\n\
    }\n", "  $prefixes = array();\n  $string = strtolower($string);\n  $length = strlen($string);\n\
    \  for ($i = 0; $i < $length; $i++) {\n    $prefixes[] = substr($string, 0, $i);\n\
    \  }\n  return $prefixes;\n}\n", "    $prefix = array();\n    foreach (str_split($string)\
    \ as $part) {\n        $prefix[] = $part;\n    }\n    array_pop($prefix);\n  \
    \  return array_merge(array(\"\"), $prefix);\n}\n", "    return array_keys(\n\
    \        array_reverse(\n            preg_grep('/^(.{' . min(str_length($string),\
    \ 3) . '})/u', str_split($string))\n        )\n    );\n}\n</code>\n<|/ a |>\n\
    <| a |>\nYou can try this\n<code>\n$str = 'Hello world';\necho array_slice(explode(\"\
    \ \", $str), 0, 3);\n</code>\noutput\n<code>\nArray\n(\n    [0] => Hello\n   \
    \ [1] => world\n)\n</code>\n<|/ a tags=php,wordpress,string dscore=1 |>\n<| a\
    \ tags=php,wordpress,string dscore=1 |>\nThe simplest way is to explode the string\
    \ with space and get 3 first elements of that array and implode them with a comma:\n\
    <code>\n$string = \"Hello world\";\n$array = explode(\" \", $string);\n$result\
    \ = implode(\", \", array_slice($array, 0, 3));\n</code>\n<|/ a |>\n<| a |>\n\
    This works for me:\n<code>\necho implode(', ', array_slice(explode(\" \", $string),\
    \ 0, 3));\n</code>\nI hope this helps!\n<|/ a tags=php,wordpress,string dscore=1\
    \ |>\n<| a |>\nI would try something like this\n<code>\n<?php\n$string = \"Hello\
    \ World\";\n$array = explode(\" \", $string);\n$new_array = array();\nfor($i =\
    \ 0; $i < 3; $i++)\n{\n    if($i == 0)\n    {\n        $new_array[] = \"$array[0]\"\
    ;\n    }\n    else\n    {\n        $new_array[] = \"$array[$i]\";\n    }\n}\n\
    echo implode(\" \", $new_array);", "    $prefix = array();\n    $curlen = strlen($string);\n\
    \    for($i = 0; $i < $curlen; $i++) {\n        $prefix[] = substr($string, 0,\
    \ $i);\n    }\n    return $prefix;\n}\n", "  $return = array();\n  for ($i = 0;\
    \ $i < strlen($string); $i++) {\n    $return[] = substr($string, 0, $i);\n  }\n\
    \  return $return;\n}\n", "    $array = [];\n    foreach (array_reverse(str_split($string))\
    \ as $char) {\n        $array[] = $char;\n    }\n    return array_reverse($array);\n\
    }\n</code>\n<|/ a |>\n<| c |>\nVery neat function. Although it may seem a bit\
    \ inefficient for such a simple task, I love the fact that it works well. One\
    \ small thing, though: in line 5, the $array is supposed to have at least two\
    \ characters, so it could be \"return array_reverse($array);\". Just wanted to\
    \ let you know.\n<|/ c |>\n<| a dscore=2 tags=php |>\nHere is another solution\
    \ which uses array_reduce with array_reverse in its callback, not just to remove\
    \ the duplicates, but to reverse the whole array:\n<code>\n$array = array_reduce(\n\
    \    array_reverse(str_split($string)),\n    function ($carry, $item) {\n    \
    \    array_unshift($carry, $item);\n        return $carry;\n    }\n);\n</code>\n\
    The advantage is that it can handle arrays of any size.\n<|/ a |>\n<| c |>\nThis\
    \ is the solution I ended up using. It works well and is quite easy to understand\
    \ as well. Thanks!\n<|/ c |>\n<| a |>\nFor a shorter version than some of the\
    \ other answers, I'd go with this one:\n<code>", "  return array_reverse(array_map(fn($p)\
    \ use ($string) { return $string . $p; }, str_split($string)));\n}\n", "\t$result\
    \ = array();\n\tforeach (preg_split('//', $string, -1, PREG_SPLIT_NO_EMPTY) as\
    \ $item) {\n\t\t$item = trim($item);\n\t\tif (strlen($item) > 0) {\n\t\t\t$result[]\
    \ = $item;\n\t\t\t$result = array_merge($result, all_prefixes($item));\n\t\t}\n\
    \t}\n\treturn $result;\n}", "\t$prefixes = array();\n\t\n\t$len = strlen($string);\n\
    \t\n\tfor ($i = 0; $i < $len; ++$i) {\n\t\tif ($string[$i] == $string[$len - 1])\
    \ {\n\t\t\t$prefixes[] = substr($string, 0, $i);\n\t\t}\n\t}\n\t\n\treturn $prefixes;\n\
    }\n", "    $prefixes = array();\n    for ($len = strlen($string); $len > 0; $len--)\
    \ {\n        $prefix = substr($string, 0, $len);\n        if (in_array($prefix,\
    \ $prefixes)) $prefixes = array();\n        $prefixes[] = $prefix;\n    }\n  \
    \  return $prefixes;\n}", "  $prefixes = array();\n\n  // iterate over chars in\
    \ string\n  for ($i = 0; $i < strlen($string); $i++) {\n    // keep track of prefix\
    \ length\n    $prefix_length = 1;\n\n    // start iterating over the string again,\
    \ starting at position $i\n    for ($j = $i + 1; $j < strlen($string); $j++) {\n\
    \      // char at position $j is equal to char at position $i\n      if ($string[$j]\
    \ != $string[$i]) {\n        // if chars are not equal, increment prefix length\n\
    \        // and break the inner loop\n        $prefix_length++;\n        break;\n\
    \      }\n      // chars are equal and $j is not equal to $i, increase prefix\
    \ length\n      // and continue the outer loop\n      $prefix_length++;\n    }\n\
    \n    // if the prefix length is longer than the current shortest prefix,\n  \
    \  // remember this prefix and move on\n    if ($prefix_length > strlen($prefixes[0]))\
    \ {\n      $prefixes[0] = $string[$i];\n    }\n\n    // otherwise add prefix length\
    \ to the current shortest prefix\n    else {\n      $prefixes[1] += $prefix_length;\n\
    \    }\n  }\n\n  return $prefixes;\n}\n", "    $all_prefixes = array();\n    $prefix\
    \ = \"\";\n    $length = 0;\n    for ($i = 0; $i < strlen($string); $i++) {\n\
    \        if ($string[$i] == $string[$i + 1]) {\n            $all_prefixes[] =\
    \ $prefix . $string[$i];\n            $length++;\n        } else {\n         \
    \   $prefix = $string[$i];\n            $length = 1;\n        }\n    }\n    return\
    \ $all_prefixes;\n}\n", "    $prefixes = array();\n\n    // Create array of characters\
    \ from string to remove duplicates\n    $chars = preg_split('//u', $string, -1,\
    \ PREG_SPLIT_NO_EMPTY);\n\n    // Keep prefixes of longest length first\n    foreach\
    \ ($chars as $i => $char) {\n        if (strlen($char) > strlen($prefixes[$i]))\
    \ {\n            $prefixes[$i] = $char;\n        }\n    }\n\n    return $prefixes;\n\
    }\n</code>\n<|/ a tags=php,algorithm |>\n<| c |>\nYou might want to put this in\
    \ a function so that you can reuse it in other situations like this.\n<|/ c |>\n\
    <| a dscore=2 |>\nThis is an extension from Kevin Hoff's answer above, using recursion,\
    \ and returning the full string when it's done. It also doesn't use recursion:\n\
    <code>", "    $prefixes = array();\n\n    for ($i = 0; $i < strlen($string); $i++)\
    \ {\n        $prefixes[] = substr($string, 0, $i);\n    }\n\n    return $prefixes;\n\
    }\n</code>\n<|/ a dscore=5 tags=php,substring |>\n<| c |>\nThanks man, I was getting\
    \ frustrated. It was so easy. But you made my day\n<|/ c |>\n<| c |>\nHow can\
    \ you make this function more efficient?\n<|/ c |>\n<| c |>\nYou might also want\
    \ to consider using `substr` rather than `strlen`\n<|/ c |>\n<| a |>\nThis answer\
    \ builds on top of Danny's answer. Instead of using substr and strlen, I am now\
    \ using strrpos and strpos to determine if the first string is a prefix of the\
    \ second.\n<code>\n/**\n * Checks if a string is a prefix of another string. \n\
    \ * \n * string $firstString String to check if it is a prefix of.\n * string\
    \ $secondString String to check if it is a prefix of.\n * bool True if $firstString\
    \ is a prefix of $secondString.\n */", "    $prefix = array();\n    for ($i =\
    \ 0; $i < strlen($string); ++$i) {\n        $prefix[] = substr($string, 0, $i);\n\
    \    }\n    return $prefix;\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThanks for\
    \ this - this helped a lot.  I just needed to add the array keys to get this to\
    \ work.  I used this for my final working code: [link](http://stackoverflow.com/a/42755868/3688442)\n\
    <|/ c |>\n<| c |>\nThis code also works with UTF-8 chars. Just need to change\
    \ `substr($string, 0, $i)` to `mb_substr($string, 0, $i)`.\n<|/ c |>\n<| a dscore=4\
    \ |>\nThis solution is very similar to one above, but doesn't require a loop and\
    \ it is actually quite fast.\n<code>\n$length = '12345';\n$substring = '456';\n\
    $prefix_length = mb_strlen($substring);\n$prefix = substr($substring, 0, $prefix_length);\n\
    $suffix = '';\nif (mb_strlen($length) > $prefix_length) {\n  $suffix = substr($length,\
    \ $prefix_length);\n}\n</code>\n<|/ a tags=php,substr,string |>\n<| c |>\nThis\
    \ is actually the fastest solution I found too. Thank you.\n<|/ c |>\n<| c |>\n\
    Thanks for sharing your code. This helped me with a similar problem of getting\
    \ a part of a string. I used your solution because I needed a part of a string\
    \ and `mb_substr` doesn't exist for my version of PHP. Thank you.\n<|/ c |>\n\
    <| c |>\nThis helped me a lot with my problem. Thanks!\n<|/ c |>\n<| c |>\nWow,\
    \ I had no idea this function existed! Wow! And very fast!\n<|/ c |>\n<| c |>\n\
    I like this answer, as it is a single call to mb_substr. This should be the top\
    \ answer in my opinion.\n<|/ c |>\n<| a |>\nYou can use mb_substr() with the 3rd\
    \ parameter set to true.\n<code>\n$substr = mb_substr($str, 0, $position, 'UTF-8');\n\
    </code>\n<|/ a dscore=4 tags=php,substr,string |>\n<| c |>\nThe OP specifically\
    \ states they want to handle multi-byte charsets. `substr()` does not handle multi-byte\
    \ charsets. `mb_substr()` does (and it seems like it would be much slower, so\
    \ I'd avoid it).\n<|/ c |>\n<| c |>\nY", "  $prefixes = array();\n  $length =\
    \ strlen($string);\n  foreach (str_split($string) as $char) {\n    $prefix = substr($string,\
    \ 0, $length);\n    $prefixes[] = $prefix;\n    $length--;\n  }\n  return $prefixes;\n\
    }\n</code>\nThis works, but I wanted to know if there was a cleaner / more efficient\
    \ way of achieving the same results.  \nI realize this doesn't do exactly what\
    \ I'm looking for, but I'm looking for something that can take advantage of the\
    \ built-in functions of PHP.\n<|/ q dscore=2 |>\n<| c |>\nhttp://stackoverflow.com/questions/10266902/php-how-can-i-get-all-possible-combinations-of-the-characters-in-a-string\n\
    <|/ c |>\n<| c |>\n: Sorry, that question wasn't clearly phrased (perhaps I should\
    \ have researched more before asking the question?). I understand how to get all\
    \ combinations of a string, but I'm wondering if there is a way to accomplish\
    \ this using built in functions of PHP. Thanks for your suggestion though!\n<|/\
    \ c |>\n<| a dscore=3 |>\n<code>\n$string = 'abc';\n$maxLength = 3;\n$array =\
    \ str_split($string);\n$result = array();\n\nfor ($i = 0; $i < $maxLength; $i++)\
    \ {\n  array_unshift($array, array_shift($array));\n  for ($j = 0; $j < count($array);\
    \ $j++) {\n    $result[] = implode('', $array);\n  }\n}\n\nvar_dump($result);\n\
    </code>\nYou can change the $maxLength variable as you wish, in this example $maxLength\
    \ is set to 3.\n<|/ a tags=string,arrays,php |>\n<| c |>\nThis doesn't output\
    \ the actual combinations, just an indexed array of strings?\n<|/ c |>\n<| c |>\n\
    Yeah, it output the array that contains the combinations of `$string` as `abc`\
    \ with `$maxLength` number of elements, you can change the `$maxLength` variable\
    \ as you wish, in this example `$maxLength` is set to 3.\n<|/ c |>\n<| c |>\n\
    Thanks! I was thinking of using something like this for my problem, but didn't\
    \ know how to properly format the output.  This is perfect!  Thanks for the help!\n\
    <|/ c |>\n<| a dscore=1 |>\nHere's a solution using recursion.\n<code>", "   \
    \ $output = [];\n    $prefix = \"\";\n    for ($i = 0; $i < strlen($string); $i++)\
    \ {\n        $char = $string[$i];\n        $prefix = $char . $prefix;\n      \
    \  $output[] = $prefix;\n    }\n    return $output;\n}\n", "    $alphabetSize\
    \ = strlen($string);\n    $alphabet = array('');\n    $alphabet[\"\"] = '';\n\
    \    for ($i = 0; $i < $alphabetSize; $i++) {\n        for ($j = 0, $l = $alphabetSize;\
    \ $j < $l; $j++) {\n            $alphabet[$string[$j].$alphabet[$string[$j+1]]]\
    \ .= $string[$j];\n        }\n    }\n\n    return array_keys($alphabet);\n}",
  "    $result = [];\n    $prefixes = str_split($string);\n    foreach ($prefixes\
    \ as $prefix) {\n        foreach (str_split($prefix) as $char) {\n           \
    \ $result[] = $char;\n        }\n    }\n    return $result;\n}\n", "    $prefixes\
    \ = array();\n    $length   = strlen($string);\n    for ($i = 0; $i < $length;\
    \ ++$i) {\n        $prefixes[] = substr($string, 0, $i);\n    }\n    return $prefixes;\n\
    }\n", "    $prefixes = array();\n    $shortest = min($string, strlen($string));\n\
    \    for ($i = 0; $i < $shortest; $i++) {\n        $prefix = substr($string, 0,\
    \ $i);\n        if ($prefix === '') continue;\n        $prefixes[] = $prefix;\n\
    \    }\n    return $prefixes;\n}\n", "    $prefixes = array();\n\n    for ($i\
    \ = 0, $len = strlen($string); $i < $len; $i++) {\n        $prefix = substr($string,\
    \ 0, $i);\n        $prefixes[] = $prefix;\n\n        // Remove prefix from string\
    \ if all characters in prefix are in lowercase\n        if (preg_match('/^[a-z]/',\
    \ $prefix)) {\n            $string = substr($string, strlen($prefix));\n     \
    \   } else {\n            break;\n        }\n    }\n\n    return $prefixes;\n\
    }\n", "  return array_slice(explode(\" \", $string), 0, count($string));\n}\n",
  "    $prefixes = array();\n    $length = strlen($string);\n    for ($i = 0; $i <\
    \ $length; $i++) {\n        $prefix = substr($string, 0, $i);\n        $prefixes[]\
    \ = $prefix;\n    }\n    return $prefixes;\n}\n", "    $string = preg_replace('/[^a-z0-9]/i',\
    \ '', $string); // remove special chars\n    $input = preg_split('/[a-z0-9]/i',\
    \ $string);\n    $all_prefixes = array();\n    foreach ($input as $char) {\n \
    \       // if current char is not in all_prefixes, add it\n        if (! in_array($char,\
    \ $all_prefixes)) {\n            $all_prefixes[] = $char;\n        }\n    }\n\
    \    return $all_prefixes;\n}\n", "  $prefixes = array();\n  for ($i = 0; $i <\
    \ strlen($string); $i++) {\n    $prefix = substr($string, 0, $i);\n    $prefixes[]\
    \ = $prefix;\n  }\n  return $prefixes;\n}\n", "    // Convert input to lowercase\n\
    \    $string = (string)strtolower($string);\n\n    // Build output array\n   \
    \ $out = array();\n\n    // Iterate over input string\n    for ($i = 0; $i < strlen($string);\
    \ $i++) {\n        // Check if the current character is a lowercase character\n\
    \        if (ctype_lower($string[$i])) {\n            // If it is, store it as\
    \ the prefix for next iteration\n            $out[] = $string[$i];\n        }\
    \ else {\n            // If it is not, add it to the output array\n          \
    \  $out[] = \"\";\n        }\n    }\n\n    // Return array\n    return $out;\n\
    }\n", "    $prefixes = array();\n    $prefix = substr($string, 0, 1);\n    while\
    \ (strlen($string) > 0) {\n        $string = substr($string, 1);\n        $prefixes[]\
    \ = $prefix;\n    }\n    return $prefixes;\n}\n", "    $prefixes = array();\n\
    \    $str_len = mb_strlen($string, 'UTF-8');\n    $last_char_index = mb_strlen($string,\
    \ 'UTF-8') - 1;\n    for ($i = 0; $i < $str_len; $i++) {\n        // Use mb_strpos()\
    \ because preg_match() is not case sensitive\n        $pos = mb_strpos($string,\
    \ mb_substr($string, $i, 'UTF-8'), 0, 'UTF-8');\n        if ($pos === false) {\n\
    \            // No prefixes found\n            break;\n        } else {\n    \
    \        $prefix = mb_substr($string, 0, $pos, 'UTF-8');\n            $prefixes[]\
    \ = $prefix;\n            $string = $prefix . mb_substr($string, $pos + 1, 'UTF-8');\n\
    \            // Remove prefix from string\n            $last_char_index -= mb_strlen($prefix,\
    \ 'UTF-8');\n        }\n    }\n    return $prefixes;\n}\n\n/**\n * Validate a\
    \ string against the Luhn algorithm (mod 10).\n *\n * @param   string  $value\n\
    \ * @return  bool\n */", "    $prefixes = array();\n    $string_length = 0;\n\
    \    $last_prefix = '';\n    foreach (str_split($string) as $char) {\n       \
    \ $string_length++;\n        if ($char === $last_prefix) {\n            continue;\n\
    \        }\n        $last_prefix = $char;\n        $prefixes[] = $char;\n    }\n\
    \    return $prefixes;\n}\n", "  $prefixes = array();\n  $prefix_length = 0;\n\
    \  foreach (explode($string, '') AS $char) {\n    // Determine if current character\
    \ is a possible prefix, and if it is\n    // add it to the array of prefixes.\
    \  If not, then only add if it is the first\n    // character.\n    if (substr($char,\
    \ 0, $prefix_length) === $string) {\n      $prefixes[] = substr($char, 0, $prefix_length);\n\
    \    }\n    if ($prefix_length === 0) {\n      $prefix_length = strlen($char);\n\
    \    }\n  }\n  return $prefixes;\n}\n", "  $result = array();\n  foreach (str_split($string)\
    \ as $val) {\n    $result[] = str_pad($val, 2, \"0\");\n  }\n  return $result;\n\
    }\n", "    $prefixes = array();\n    // Create empty list of prefixes\n    foreach\
    \ (preg_split('//', $string, 0, PREG_SPLIT_NO_EMPTY) as $string) {\n        $prefixes[]\
    \ = '';\n    }\n    // Add the prefix of each character\n    for ($i = 1, $l =\
    \ mb_strlen($string); $i < $l; $i++) {\n        $prefixes[] = mb_substr($string,\
    \ 0, $i, '8bit');\n    }\n    return $prefixes;\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| a tags=string,php,regex,arrays |>\nHere's a way to do it without regular expressions:\n\
    <code>", "    $prefixes = array();\n    for ($i = 0; $i < strlen($string); $i++)\
    \ {\n        $prefixes[] = substr($string, 0, $i);\n    }\n    return $prefixes;\n\
    }\n", "    $array = array();\n\n    for ($i = 0; $i < strlen($string); $i++) {\n\
    \        $array[] = substr($string, 0, $i);\n    }\n    return $array;\n}\n",
  "  return array_slice(explode($string, \"\"), 0, count($string));\n}\n", "    //\
    \ Return empty array if $string is empty\n    if (!strlen($string)) {\n      \
    \  return array();\n    }\n\n    $prefixes = array();\n    // Add prefix to all\
    \ strings not starting with $string\n    foreach (str_split($string) as $char)\
    \ {\n        // Add prefix only if not already present\n        if (!in_array($char,\
    \ $prefixes)) {\n            $prefixes[] = $char;\n        }\n    }\n    return\
    \ $prefixes;\n}\n", "    return array_map(function($s) { return $s[0]; }, explode($string,\
    \ \"\"));\n}", "  $prefixes = array();\n  for ($i = strlen($string); $i > 0; $i--)\
    \ {\n    $prefixes[] = substr($string, 0, $i);\n  }\n  return $prefixes;\n}\n",
  "    $prefixes = array();\n    $length    = strlen($string);\n    for ($i = 0; $i\
    \ < $length; ++$i) {\n        $prefix = substr($string, 0, $i);\n        $prefixes[]\
    \ = $prefix;\n    }\n    return $prefixes;\n}\n</code>\n<|/ a dscore=3 |>\n<|\
    \ a dscore=3 |>\nYou can use a combination of the explode function and the array_unique\
    \ function:\n<code>\n$string = 'abc def cde ';\n$array = explode(' ',$string);\n\
    $array = array_unique($array);\n</code>\n<|/ a tags=php,string,unique |>\n<| a\
    \ tags=php,string,unique |>\nYou can use explode:\n<code>\n$string = 'abc def\
    \ cde ';\n$array = explode(' ',$string);\n$array = array_unique($array);\n</code>\n\
    <|/ a dscore=3 |>\n<| a tags=php,string,unique dscore=3 |>\nUsing preg_match and\
    \ preg_replace should do it:\n<code>\n<?php\n$string = 'abc def cde ';\n\n$pattern\
    \ = '/^([^\\s]+\\s+){2}([^\\s]+)/';\n$string = preg_replace($pattern, '$1$2',\
    \ $string);\n\nvar_dump($string);\n</code>\nOutput:\n<code>\nstring 'abc' (length=3)\n\
    </code>\n<|/ a |>\n<| a tags=php,string,unique |>\nI thought that I would throw\
    \ in my solution here. \nUsing array_unique on a string of space separated words\
    \ will not work if there are duplicates in the array of words e.g. \"a b c d a\"\
    \ would become \"a b c d\".\nTo fix this I used a regular expression to strip\
    \ out any duplicated words and then used array_unique to remove the duplicate\
    \ array elements.\n<code>\n$string = \"a b c d a\";\n$arr = explode(\" \", $string);\n\
    \n$arr2 = preg_replace('/\\s+/', \" \", $arr);\n$arr2 = array_unique(preg_replace('/\\\
    s+/', \" \", $arr2));\n\n$string = implode(\" \", $arr2);\necho $string;\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nYou should use $arr2 = preg_replace('/\\s+/', \" \"\
    , $arr); to avoid redundant spaces :)\n<|/ c |>\n<| a dscore=2 tags=php,string,unique\
    \ |>\nI came up with this solution. It's not as elegant as array_unique, but it's\
    \ still simple and doesn't use regular expressions.\n<code>\n", "  $prefixes =\
    \ array();\n  for ($i = 1; $i <= strlen($string); $i++) {\n    $prefix = substr($string,\
    \ 0, $i);\n    $prefixes[] = $prefix;\n  }\n  return $prefixes;\n}\n", "    return\
    \ preg_split('/(.+?)/', $string, null, PREG_SPLIT_NO_EMPTY);\n}\n", "    $allPrefixes\
    \ = array();\n    for ($i = 1; $i < strlen($string); $i++) {\n        $allPrefixes[]\
    \ = substr($string, 0, $i);\n    }\n    return $allPrefixes;\n}\n", "    if ($string\
    \ == \"\") return array(\"\");\n    $string = $string . \"\";\n    $prefix = array();\n\
    \    $prefix[0] = $string;\n    for ($i = 1; $i < strlen($string); $i++) {\n \
    \       $prefix[$i] = substr($string, 0, $i);\n    }\n    return $prefix;\n}\n\
    $shortestString = substr($string, 0, 1);\n$longestString = substr($string, 0,\
    \ -1);\n$shortestPrefixes = all_prefixes($shortestString);\n$longestPrefixes =\
    \ all_prefixes($longestString);\n$shortestPrefixLength = min($shortestPrefixes)\
    \ - 1;\n$longestPrefixLength = max($longestPrefixes) - 1;", "    $prefixes = array();\n\
    \    $length = 1;\n    $string = mb_strtoupper($string);\n    $original = $string;\n\
    \n    foreach (str_split($string) as $char) {\n        $string = $string.$char;\n\
    \        $length++;\n\n        if (mb_strtolower($string) == mb_strtolower($original))\
    \ {\n            $prefixes[] = $char;\n            $length++;\n        }\n   \
    \ }\n\n    return array_slice($prefixes, 0, count($prefixes)-1);\n}\n", "\t$array\
    \ = str_split($string);\n\t$result = array();\n\n\tforeach ($array as $value)\
    \ {\n\t\t$result[] = $value;\n\t\tif (isset($array[$value])) {\n\t\t\t$result[]\
    \ = $value . substr($array[$value], 1);\n\t\t}\n\t}\n\treturn $result;\n}\n",
  "    $prefixes = array();\n\n    foreach (str_split($string) as $i) {\n        $prefix\
    \ = implode('', array_slice($string, 0, $i));\n        if (!isset($prefixes[$prefix]))\
    \ $prefixes[$prefix] = 1;\n        else $prefixes[$prefix]++;\n    }\n\n    array_walk($prefixes,\
    \ function(&$value, $key) { $value = $key * $value; });\n    return array_reverse($prefixes);\n\
    }\n", "  $chars = preg_split('//', $string);\n  $prefixes = array();\n  foreach\
    \ ($chars as $char) {\n    $prefixes[] = $char;\n  }\n  return array_reverse($prefixes);\n\
    }\n", "    $i = 0;\n    $prefixes = array();\n    while ($i < strlen($string))\
    \ {\n        $prefixes[] = substr($string, $i, 1);\n        $i += 1;\n    }\n\
    \    return $prefixes;\n}\n", "    $prefixes = array();\n    $string_length =\
    \ strlen($string);\n    for ($i = 0; $i < $string_length; $i++) {\n        $char\
    \ = substr($string, $i, 1);\n        if (!isset($prefixes[$char])) {\n       \
    \     $prefixes[$char] = $char;\n            $prefixes[$char] .= $char;\n    \
    \    }\n    }\n    return $prefixes;\n}\n", "  $prefixes = array();\n  for ($i\
    \ = 0; $i < strlen($string); $i++) {\n    $prefixes[] = $string[$i];\n  }\n  return\
    \ array_reverse($prefixes);\n}", "  $prefixes = array();\n  $len = strlen($string);\n\
    \  for ($i = 0; $i < $len; $i++) {\n    $prefixes[] = $string[$i];\n  }\n  return\
    \ $prefixes;\n}", "    if (strlen($string) == 1) {\n        return array($string);\n\
    \    }\n    return array_map(function($s) { return array($s); }, preg_split('/[a-z]+/',\
    \ $string, -1, PREG_SPLIT_NO_EMPTY));\n}\n", "    $prefixes = array();\n    $i\
    \ = 0;\n    while($i < strlen($string)) {\n        $prefixes[] = substr($string,\
    \ $i, 1);\n        $i++;\n    }\n    return $prefixes;\n}\n", "\t$prefixes = array();\n\
    \tfor ($i = 0; $i < strlen($string); $i++) {\n\t\t$prefixes[] = $string[0];\n\t\
    }\n\twhile (count($prefixes) < count($string)) {\n\t\t$prefixes[] = $string[count($prefixes)\
    \ - 1];\n\t}\n\treturn $prefixes;\n}\n", "  $array = array_keys(preg_split('//',\
    \ $string, -1, PREG_SPLIT_NO_EMPTY));\n  $sorted = array_slice($array, 0, count($array)\
    \ - 1);\n  sort($sorted);\n  return array_reverse($sorted);\n}\n", "    $prefixes\
    \ = array();\n\n    for ($i = 0; $i < strlen($string); $i++) {\n        $prefixes[]\
    \ = substr($string, 0, $i);\n    }\n\n    return $prefixes;\n}\n</code>\n<|/ a\
    \ dscore=5 |>\n<| c |>\nI used this method, and I noticed that it was slower than\
    \ a regex, so I optimized it further, and here's my new code:\n`function getPrefixes($str)\
    \ {\n    $prefixes = array();\n    $len = strlen($str);\n    $i = 0;\n\n    while\
    \ ($i < $len) {\n        $prefixes[] = substr($str, 0, $i);\n        $i++;\n \
    \   }\n\n    return $prefixes;\n}`\n<|/ c |>\n<| a |>\n<code>\n$prefixes = array();\n\
    $string = preg_replace('/^.+?(?=.)/', '', $string);\n$length = strlen($string);\n\
    for ($i = 1; $i < $length; $i++) {\n    $prefixes[] = substr($string, 0, $i);\n\
    }\n</code>\n<|/ a tags=string,php,substring dscore=4 |>\n<| a tags=string,php,substring\
    \ |>\nYou can use array_slice() for this purpose.\n<code>\n$string = preg_replace('/^.+?(?=.)/',\
    \ '', $string);\n$substrings = array_slice($string, 1);\n</code>\n<|/ a dscore=3\
    \ |>\n<| c |>\nI think you mean `$substrings = array_slice($string, 0, 1);`\n\
    <|/ c |>\n<| a dscore=3 |>\nIf your strings are long, this will work:\n<code>\n\
    $string = \"abc123def456ghi789jkl\";\n$result = array_pop(preg_split(\"/[0-9]+/\"\
    , $string));\nvar_dump($result);\n</code>\n<|/ a tags=string,php,substring |>\n\
    <| a dscore=3 tags=string,php,substring |>\nTry this one:\n<code>\n$string = \"\
    abc123def456ghi789jkl\";\n$str = array();\n$length = strlen($string);\nfor ($i\
    \ = 1; $i < $length; $i++) {\n    $str[] = substr($string, 0, $i);\n}\nvar_dump($str);\n\
    </code>\n<|/ a |>\n<| a |>\nUsing preg_split:\n<code>\n$prefixes = preg_split(\"\
    /(?<=\\d)(?=\\D|$)/\", $string);\n</code>\nAnd if you need the result in array\
    \ format:\n<code>\n$prefixes = pre", "    if (strlen($string) <= 1) {\n      \
    \  return array($string);\n    }\n    $prefix_array = array();\n    $prefix_length\
    \ = 0;\n    foreach (str_split($string) as $char) {\n        $prefix_length =\
    \ max($prefix_length, strlen($char));\n        $prefix_array[] = $char;\n    }\n\
    \    array_unshift($prefix_array, $string[0]);\n    foreach ($prefix_array as\
    \ $prefix) {\n        $prefix_length++;\n        $prefix_array[$prefix_length]\
    \ = $prefix;\n    }\n    return $prefix_array;\n}", "    $result = array();\n\
    \    for ($i = 0; $i < strlen($string); $i++) {\n        $result[] = substr($string,\
    \ 0, $i);\n    }\n    return $result;\n}\n", "    $prefixes = array();\n    for\
    \ ($i = mb_strlen($string) - 1; $i >= 0; $i--) {\n        $prefixes[] = mb_substr($string,\
    \ 0, $i);\n    }\n    return $prefixes;\n}\n", "    $string = trim($string);\n\
    \    $string = preg_replace('/[^a-z0-9]/', '', $string);\n\n    $maxLength = 0;\n\
    \    $prefixes = array();\n\n    foreach (str_split($string) as $char) {\n   \
    \     $prefixes[] = $char;\n        $maxLength += mb_strlen($char, \"UTF-8\");\n\
    \    }\n\n    // The longest prefix\n    $maxLength = $maxLength > mb_strlen($string,\
    \ \"UTF-8\") ? mb_strlen($string, \"UTF-8\") : $maxLength;\n\n    $prefixes =\
    \ array_slice($prefixes, 0, $maxLength);\n\n    // Remove duplicate prefixes\n\
    \    $prefixes = array_unique($prefixes);\n\n    return $prefixes;\n}\n</code>\n\
    <|/ a dscore=3 |>\n<| a dscore=3 tags=php,mysql |>\nThis is a variation on Marks\
    \ answer but works with multi-byte characters and uses array_filter() to only\
    \ return unique values, as array_unique() seems to not return all occurrences\
    \ of the same value when dealing with multi-byte characters.\n<code>", "  $prefixes\
    \ = array();\n  foreach (str_split($string) as $char) {\n    $prefixes[] = $char;\n\
    \    if ($char === \"\") {\n      break;\n    }\n  }\n  return array_merge(array_slice($prefixes,\
    \ 0, -1), array(\"\"));\n}\n", "  $prefixes = array();\n  $str = preg_split('/(?<=\\\
    w)/', $string);\n  $strLength = count($str);\n  foreach ($str as $char) {\n  \
    \  $prefixes[] = $char;\n  }\n  $prefixes[] = '^';\n  for ($i = 1; $i < $strLength;\
    \ $i++) {\n    $prefixes[] = $str[$i].$prefixes[$i-1];\n  }\n  return $prefixes;\n\
    }\n", "    $prefixes = array();\n    $prefix = '';\n    for ($i = 0; $i < strlen($string);\
    \ ++$i) {\n        $prefix = $prefix . $string[$i];\n        if (isset($string[$i\
    \ + 1])) {\n            $prefixes[] = $prefix;\n        }\n    }\n    return $prefixes;\n\
    }\n", "  $prefixes = array();\n  $length = mb_strlen($string, '8bit');\n  if ($length\
    \ < 4) {\n    return $prefixes;\n  }\n  for ($i = 0; $i < $length; $i++) {\n \
    \   $prefixes[] = mb_substr($string, 0, $i, '8bit');\n  }\n  return $prefixes;\n\
    }", "    $prefixes = array();\n    $length = strlen($string);\n    for ($i = 0;\
    \ $i < $length; ++$i) {\n        $prefixes[] = substr($string, 0, $i);\n    }\n\
    \    return $prefixes;\n}\n</code>\n<|/ a tags=string,php,substring |>\n<| a dscore=2\
    \ |>\n<code>\n$string = \"abcdefg\";\n$char_count = strlen($string);\n$substring\
    \ = substr($string, $char_count/2, $char_count);\n\necho $substring;\n</code>\n\
    <|/ a tags=string,php,substring |>\n<| a |>\n<code>\n$string = \"abcdefg\";\n\
    $substring = substr($string, ceil(strlen($string) / 2));\necho $substring;\n</code>\n\
    <|/ a dscore=2 tags=string,php,substring |>\n<| a dscore=2 |>\n<code>\n$string\
    \ = \"abcdefg\";\n$len = strlen($string);\n$substring = substr($string, ($len\
    \ / 2), $len);\n</code>\n<|/ a tags=string,php,substring |>\n<| a tags=string,php,substring\
    \ dscore=2 |>\n<code>\n$string = \"abcdefg\";\n$pos = strlen($string) / 2;\n$substring\
    \ = substr($string, $pos);\n</code>\n<|/ a |>\n<| a |>\nUsing array_chunk():\n\
    <code>\n$string = \"abcdefg\";\n$substring = array_chunk(str_split($string), 2);\n",
  "    return array_filter(array_map('str_split', $string));\n}\n", "    if (strlen($string)\
    \ === 0)\n        return array();\n    $prefixes = array();\n    $lengths = array_map(function($x)\
    \ {\n        return strlen($x);\n    }, $string);\n    $max = max($lengths);\n\
    \    foreach ($lengths as $i => $length) {\n        if ($length === $max)\n  \
    \          $prefixes[] = $string[$i];\n        else\n            $prefixes[] =\
    \ $string[$i].$string[$length];\n    }\n    return $prefixes;\n}\n</code>\nAnd\
    \ here is an example of using it:\n<code>", "    return array_filter(array_map(\n\
    \        function($string) {\n            return str_split($string);\n       \
    \ },\n        preg_split('//', $string, -1, PREG_SPLIT_NO_EMPTY|PREG_SPLIT_DELIM_CAPTURE)\n\
    \    ));\n}\n", "\t$prefix = array();\n\tfor ($i = 0; $i < strlen($string); $i++)\
    \ {\n\t\t$prefix[$i] = substr($string, 0, $i);\n\t}\n\treturn $prefix;\n}\n",
  "  $prefixes = array();\n\n  $len = strlen($string);\n  for ($i = 1; $i < $len;\
    \ $i++) {\n    $prefixes[] = $string[$i - 1];\n  }\n\n  return $prefixes;\n}\n",
  "    $prefixes = array();\n    $length = strlen($string);\n    for($i = 0; $i <\
    \ $length; $i++) {\n        $prefix = substr($string, 0, $i);\n        $prefixes[]\
    \ = $prefix;\n    }\n    return $prefixes;\n}\n", "\t$output = array();\n\t$length\
    \ = strlen($string);\n\tfor ($i = 0; $i < $length; $i++) {\n\t\t$output[] = substr($string,\
    \ 0, $i);\n\t}\n\treturn $output;\n}\n", "\t$prefixes = array();\n\tfor ($i =\
    \ 0; $i < strlen($string); $i++) {\n\t\t$prefixes[] = substr($string, 0, $i);\n\
    \t}\n\treturn $prefixes;\n}\n", "  $prefixes = array();\n  $length = 0;\n  while\
    \ (isset($string[$length])) {\n    $prefixes[] = $string[$length];\n    $length++;\n\
    \  }\n  return $prefixes;\n}\n", "    $result = [];\n    for ($i = 1; $i <= strlen($string);\
    \ $i++) {\n        $result[] = substr($string, 0, $i);\n    }\n    return $result;\n\
    }\n", "    $result = array();\n    $prefixes = explode(\"_\", $string);\n    $length\
    \ = strlen($prefixes[0]);\n    for ($i = 0; $i < $length; $i++) {\n        $result[]\
    \ = array_shift($prefixes);\n    }\n    return $result;\n}\n", "    $prefixes\
    \ = array();\n    $shortest = $shortest = strlen($string);\n\n    while ($shortest)\
    \ {\n        $prefixes[] = substr($string, 0, $shortest);\n        $shortest--;\n\
    \    }\n\n    return $prefixes;\n}\n", "    $prefixes = array();\n    $last_char\
    \ = NULL;\n    for($i = 0; $i <= strlen($string); $i++) {\n        $char = substr($string,\
    \ $i, 1);\n        if($char === $last_char) {\n            $prefixes[] = $char;\n\
    \        } else {\n            $last_char = $char;\n        }\n    }\n    return\
    \ $prefixes;\n}\n", "    $prefixes = array();\n    $prefix = '';\n\n    for ($i\
    \ = 0; $i < strlen($string); $i++) {\n        if (substr($string, $i, 1) !== $prefix)\
    \ {\n            $prefixes[] = $prefix;\n            $prefix = substr($string,\
    \ $i, 1);\n        }\n    }\n\n    $prefixes[] = $prefix;\n\n    return $prefixes;\n\
    }\n", "    $prefixes = array();\n    for ($i = 0; $i < strlen($string); $i++)\
    \ {\n        $prefix = substr($string, 0, $i);\n        if ($prefix) {\n     \
    \       $prefixes[] = $prefix;\n        }\n    }\n    return $prefixes;\n}\n",
  "  $prefix = array();\n  for ($i = 0; $i < strlen($string); $i++) {\n    $prefix[$i]\
    \ = substr($string, 0, $i);\n  }\n  return $prefix;\n}\n", "    $prefixes = array();\n\
    \    for ($i = 0; $i < strlen($string); $i++) {\n        $prefix = substr($string,\
    \ 0, $i);\n        $prefixes[] = $prefix;\n    }\n    return $prefixes;\n}", " \
    \   // Make prefix array that sorts longest to shortest\n    $prefixes = array();\n\
    \    foreach (str_split($string) as $char) {\n        $prefixes[] = $char;\n \
    \   }\n    array_multisort($prefixes, SORT_DESC, $prefixes);\n    return $prefixes;\n\
    }\n", "    $all_prefixes = array();\n    for ($i = 0; $i < strlen($string); $i++)\
    \ {\n        $all_prefixes[] = substr($string, 0, $i);\n    }\n    return $all_prefixes;\n\
    }\n", "  $prefixes = array();\n  for ($i = 0; $i < strlen($string); $i++) {\n\
    \    $prefixes[] = substr($string, 0, $i);\n  }\n  return $prefixes;\n}\n</code>\n\
    <|/ a tags=string,php |>\n<| c |>\nWhile this link may answer the question, it\
    \ is better to include the essential parts of the answer here and provide the\
    \ link for reference.  Link-only answers can become invalid if the linked page\
    \ changes.\n<|/ c |>\n<| c |>\nthanks for noticing that. I added the essential\
    \ parts of the code. Hope that is ok\n<|/ c |>\n<| c |>\n+1 for the use of array_slice()\
    \ -- I hadn't used that before, much easier to read than the foreach loop that\
    \ was already in the accepted answer.\n<|/ c |>\n<| c |>\narray_slice is useful\
    \ in lots of cases. e.g. if you only need the n-th element of an array, or a slice\
    \ of the array. array_slice has nothing to do with iteration\n<|/ c |>\n<| c |>\n\
    Thanks for your comment. I am not sure how you got your comment to say `it was\
    \ not merely an exercise`. I am not even sure what an `exercise` is here. Your\
    \ comment just seems to say `this answer has helped me`. Anyway please re-read\
    \ my comment. `array_slice` is useful in lots of cases. e.g. if you only need\
    \ the n-th element of an array, or a slice of the array. `array_slice` has nothing\
    \ to do with iteration\n<|/ c |>\n<| a tags=string,php |>\n<code>\n$string = \"\
    abcdefghijklmnopqr\";\n\n$result = array();\n\nfor ($i = 1; $i < strlen($string);\
    \ $i++) {\n  $result[] = substr($string, 0, $i);\n}\n\nprint_r($result);\n\nArray\n\
    (\n    [0] => a\n    [1] => ab\n    [2] => abc\n    [3] => abcd\n    [4] => abcde\n\
    \    [5] => abcdef\n    [6] => abcdefg\n    [7] => abcdefgh\n    [8] => abcdefghi\n\
    \    [9] => abcdefghij\n    [10] => abcdefghijk\n    [11] => abcdefghijkl\n  \
    \  [12] => abcdefghijklm\n    [13] => abcdefghijklmn\n    [14] => abcdefghijklmno\n\
    \    [15] => abcdefghijklmnop\n    [16] => abcdefghijklmnopq\n)\n</code>\n<|/\
    \ a dscore=4 |>\n<|", "  $prefixes = array();\n  for ($i = 0; $i < strlen($string);\
    \ $i++) {\n    $prefixes[] = substr($string, 0, $i);\n  }\n  return $prefixes;\n\
    }\n</code>\nThen we have the longest prefix from the shortest input string:\n\
    <code>\n<?php", "    $lengths = array_map('strlen', str_split($string));\n   \
    \ array_pop($lengths);\n    $minLength = array_shift($lengths);\n    return array_merge(\n\
    \        array_map(\n            function ($length) use ($minLength) {\n     \
    \           return substr($string, 0, $length);\n            },\n            $lengths\n\
    \        ),\n        array($string)\n    );\n}\n", "    $prefixes = array();\n\
    \    $len = strlen($string);\n    for ($i = 0; $i < $len; $i++) {\n        $prefixes[]\
    \ = substr($string, 0, $i);\n    }\n    return $prefixes;\n}\n", "    $results\
    \ = array();\n    $length = strlen($string);\n    for ($i = 0; $i < $length; $i++)\
    \ {\n        $results[] = $string[$i];\n        $j = ($i + 1) % $length;\n   \
    \     if (!isset($string[$j]) || ($string[$j] !== $string[$i])) {\n          \
    \  $results[] = $string[$j];\n        }\n    }\n    return $results;\n}\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\nThis solution produces a correct result when used\
    \ with `preg_split`. For example: `all_prefixes('aaa')` returns `[\"aaa\", \"\
    a\", \"aa\"]`. Also note that using `++$i` instead of `++$j` produces a slightly\
    \ more efficient code. Also, I think it can be improved to return array of prefixes\
    \ without duplicates. Anyway, this is the answer which was first and helped me\
    \ a lot.\n<|/ c |>\n<| c |>\nThis does have the advantage of not creating an intermediate\
    \ array, and doesn't use any temporary variable. However it still does have quadratic\
    \ time complexity, for input length n. With an input of size 4 it's 25%, with\
    \ length 5 it's 16%, etc.\n<|/ c |>\n<| c |>\nHmmm i don't think it could be much\
    \ faster than my simple version with `preg_match`. I guess the regex version could\
    \ potentially be even faster by avoiding some `strlen` calls.\n<|/ c |>\n<| c\
    \ |>\nNice algorithm. But I think it will fail for strings like \"aaa\" and return\
    \ ['aa', 'a', 'a']. The result should return ['aa', 'aa']\n<|/ c |>\n<| c |>\n\
    Yes, it missed one case as said. Thank you for your feedback\n<|/ c |>\n<| a tags=string,php,arrays\
    \ |>\n<code>\n$array = explode(' ', 'aaa bbb ccc');\n</code>\nThen,\n<code>\n\
    $results = array();\nfor ($i = 0; $i < count($array); $i++) {\n    array_push($results,\
    \ $array[$i] . $array[$i+1]);\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nIt's better\
    \ not to post code only answers, but rather also give some explanation about your\
    \ code.\n<|/ c |>\n<| c |>\nThanks, I wanted to post my answer here but couldn't\
    \ without more code than a comment on another answer.\n<|/ c |>\n<| a dscore=1\
    \ |>\nOne more option:", "  if (empty($string)) {\n    return array();\n  }\n\n\
    \  $prefixes = array();\n  $len = strlen($string);\n\n  // Add every prefix of\
    \ the input string with a trailing 'a' if necessary\n  for ($i = 0; $i < $len;\
    \ $i++) {\n    $prefixes[] = substr($string, 0, $i);\n    $string = substr($string,\
    \ 1);\n\n    // If the input string contains no more prefixes, return the prefix\
    \ array\n    if (!$string) {\n      break;\n    }\n\n    // Add a trailing 'a'\
    \ after any prefix of the string that also has a prefix\n    $string = $prefixes[$i]\
    \ . $string;\n    $prefixes[] = substr($string, 0, $i);\n  }\n\n  return $prefixes;\n\
    }\n", "    $prefixes = array();\n    // If string is empty, return empty array\n\
    \    if ($string === \"\") {\n        return $prefixes;\n    }\n    // Iterate\
    \ over each character in the string\n    // If the current character is a space,\
    \ add to the prefix array and remove\n    // the character from the string\n \
    \   // If the character is not a space, remove it from the string\n    for ($i\
    \ = 0; $i < strlen($string); $i++) {\n        $char = strtolower($string[$i]);\n\
    \        if ($char === \" \" || $char !== \"'\" && $char !== \"-\") {\n      \
    \      $prefixes[] = $char;\n            unset($string[$i]);\n        }\n    }\n\
    \    // If string still has characters, append the last character to the prefix\
    \ array\n    // and remove the last character from the string\n    if ($string\
    \ !== \"\") {\n        $prefixes[] = strtolower($string[strlen($string) - 1]);\n\
    \        unset($string[strlen($string) - 1]);\n    }\n    return $prefixes;\n\
    }\n$prefixes = all_prefixes(\"a\");\nprint_r($prefixes);", "    sort(str_split($string));\n\
    \    $prefixes = array();\n    for ($i = 0, $len = count($string); $i < $len;\
    \ $i++) {\n        $prefix = $string[$i];\n        foreach ($prefixes as $prefix2)\
    \ {\n            if ($prefix === $prefix2) {\n                $prefixes[] = $prefix;\n\
    \            }\n        }\n    }\n    return $prefixes;\n}\n", "  $result = [];\n\
    \  // Split the string on every character, splitting the resulting string on each\
    \ char\n  // If the resulting string is empty, ignore it\n  // Also strip empty\
    \ strings\n  $array = str_split(preg_replace('![^a-zA-Z0-9]+!', ' ', $string));\n\
    \  // Looping over the splitted string, appending each prefix to the result\n\
    \  foreach ($array as $prefix) {\n    if (!empty($prefix)) {\n      $result[]\
    \ = $prefix;\n    }\n  }\n  return $result;\n}\n", "    $array = array();\n  \
    \  foreach (str_split($string) as $char) {\n        $array[] = $char;\n    }\n\
    \    foreach ($array as $key => $value) {\n        $array[$key] = $value . $array[$key];\n\
    \    }\n    return array_unique($array);\n}\n", "  $prefixes = array();\n  for\
    \ ($i = 0, $length = strlen($string); $i < $length; $i++) {\n    $prefixes[] =\
    \ $string[$i];\n  }\n  return $prefixes;\n}", "    $prefixes = array();\n    $len\
    \ = strlen($string);\n    for ($i = 0; $i < $len; $i++) {\n        $prefixes[]\
    \ = substr($string, 0, $i);\n    }\n    return $prefixes;\n}", "  $prefixes =\
    \ array();\n  for ($i = 0; $i < strlen($string); $i++) {\n    $prefix = substr($string,\
    \ 0, $i);\n    if (isset($prefixes[$prefix])) {\n      $prefixes[$prefix]++;\n\
    \    } else {\n      $prefixes[$prefix] = 1;\n    }\n  }\n  return $prefixes;\n\
    }", "    // Get length of input string\n    $str_len = strlen($string);\n\n  \
    \  // Initialize prefix array\n    $prefixes = array();\n\n    // Loop through\
    \ each character in the input string\n    for ($i = 0; $i < $str_len; $i++) {\n\
    \        // Get current character string\n        $current_char = $string[$i];\n\
    \n        // Loop through each prefix and if current prefix length is greater\
    \ than input string length\n        // then add current prefix to prefix array\n\
    \        for ($j = 0; $j < $i; $j++) {\n            if (substr($prefixes[$j],\
    \ 0, strlen($current_char)) == $current_char) {\n                $prefixes[$j]\
    \ .= $current_char;\n                break;\n            }\n        }\n    }\n\
    \n    // Return prefix array\n    return $prefixes;\n}\n", "    $prefix = \"\"\
    ;\n    $start = 0;\n    while(strlen($string) > 0) {\n        $end = strlen($string)\
    \ - 1;\n        $start = $end - 1;\n        $prefix .= substr($string, $start,\
    \ 1);\n        $string = substr($string, 0, $end);\n    }\n    return array($prefix);\n\
    }\n", "    // Return empty array if there are no prefixes\n    if(count($prefixes\
    \ = array_filter(explode($string, \"\"), function($char) {\n        return strlen($char);\n\
    \    })) === 0) {\n        return array();\n    }\n\n    // Return array of all\
    \ prefixes\n    return $prefixes;\n}\n</code>\n<|/ a |>\n<| a |>\nThis code works\
    \ for me \n<code>\n    $array=array('abcde','abcefg');\n    $i=0;\n    $final=array();\n\
    \n    while($i<count($array)){\n        $temp=array();\n        for($j=0;$j<count($array);$j++){\n\
    \            if(strlen($array[$j])==strlen($array[$i])){\n                $temp[]=$array[$j];\n\
    \            }\n        }\n\n        array_push($final,$temp);\n        $i++;\n\
    \    }\n\n    print_r($final);\n</code>\n<|/ a tags=arrays,php dscore=0 |>\n<|\
    \ a |>\n<code>", "    return array_map(function ($str) { return $str . $str; },\
    \ str_split($string));\n}\n", "\t$prefixes = array();\n\tforeach (str_split($string)\
    \ as $char) {\n\t\t$prefixes[] = $char;\n\t\t$prefixes = array_merge($prefixes,\
    \ array_keys($prefixes));\n\t}\n\tsort($prefixes);\n\treturn $prefixes;\n}", " \
    \   $prefixes = array();\n    for ($i = 0; $i < strlen($string); $i++) {\n   \
    \     $prefixes[] = substr($string, 0, $i);\n    }\n    return $prefixes;\n}\n",
  "\tpreg_match_all('/[A-z]/', $string, $matches);\n\treturn $matches[0];\n}\n", " \
    \   $prefix_array = array();\n    $prefix_counter = 1;\n    $prefix_length = strlen($string);\n\
    \    \n    foreach (str_split($string) as $char) {\n        if ($char === \"\"\
    ) continue;\n        if ($prefix_counter >= $prefix_length) {\n            $prefix_array[]\
    \ = \"\";\n            break;\n        }\n        $prefix_array[] = $char;\n \
    \       $prefix_counter++;\n    }\n    return $prefix_array;\n}\n", "  $prefixes\
    \ = array();\n  // For each character in the string ...\n  for ($i = 0; $i < strlen($string);\
    \ $i++) {\n    // ... get the length of the corresponding prefix\n    $prefixLen\
    \ = strlen(substr($string, 0, $i));\n    // ... and store it in $prefixes\n  \
    \  $prefixes[] = substr($string, 0, $i);\n  }\n  return $prefixes;\n}\n", "  \
    \  $prefixes = array();\n    $length = strlen($string);\n    for ($i = 0; $i <\
    \ $length; $i++) {\n        $prefix = substr($string, 0, $i);\n        $prefixes[$prefix]\
    \ = true;\n    }\n    $keys = array_keys($prefixes);\n    reset($keys);\n    return\
    \ array_map(function($v) use ($string) {return substr($string, 0, $v);}, $keys);\n\
    }", "    if (strlen($string) == 0) return array();\n    return explode(\" \",\
    \ ltrim(trim($string), \" \"));\n}\n</code>\n<|/ a dscore=4 tags=php,optimization,string\
    \ |>\n<| a tags=php,optimization,string |>\nThis is one way you could do it:\n\
    <code>\n$words = explode(' ', trim($string));\n$prefixes = array_map('trim', array_map(function($word)\
    \ {\n   return $word[0];\n}, $words));\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    I like the use of the anonymous function and trim.  One thing I would suggest\
    \ is using array_map($trim,$words) instead of array_map(function($word) {return\
    \ $word[0]; }, $words).\n<|/ c |>\n<| c |>\n: I like the use of trim() too. I\
    \ find that to be more consistent with other coding practices (i.e. `trim($string,\
    \ \" \\t\\n\\r\\0\\x0B\")` instead of `$string = trim($string, \"   \\t\\n\\r\\\
    0\\x0B\")`).\n<|/ c |>\n<| c |>\n: array_map can accept an array. So, there is\
    \ no need to create a new anonymous function every time.\n<|/ c |>\n<| c |>\n\
    : I see what you mean now. Wasn't aware. Thanks. :)\n<|/ c |>\n<| c |>\n: array_map\
    \ is probably faster than array_reduce in this case. But it's also much simpler\
    \ and clearer to read.\n<|/ c |>\n<| a dscore=2 |>\nThe simplest way to do this\
    \ is to use substr().\n<code>\n<?php", "    $array = array();\n    $array[] =\
    \ $string;\n    foreach ($array as $k => $v) {\n        $array[] = $v;\n     \
    \   $array[] = str_replace($v, \"\", $string);\n        $array[] = str_replace($v,\
    \ \"\", $string);\n        $array[] = str_replace($v, \"\", $string);\n      \
    \  $array[] = str_replace($v, \"\", $string);\n        $array[] = str_replace($v,\
    \ \"\", $string);\n        $array[] = str_replace($v, \"\", $string);\n      \
    \  $array[] = str_replace($v, \"\", $string);\n        $array[] = str_replace($v,\
    \ \"\", $string);\n        $array[] = str_replace($v, \"\", $string);\n      \
    \  $array[] = str_replace($v, \"\", $string);\n        $array[] = str_replace($v,\
    \ \"\", $string);\n    }\n    return $array;\n}\n", "    return array_flip(str_split($string));\n\
    }\n", "    $all_prefixes = array();\n    $prefix_length = strlen($string);\n \
    \   for ($i = 0; $i < $prefix_length; $i++) {\n        $all_prefixes[] = substr($string,\
    \ 0, $i);\n    }\n    return $all_prefixes;\n}", "    $prefixes = array();\n \
    \   $len       = strlen($string);\n    for ($i = 0; $i < $len; $i++) {\n     \
    \   $prefixes[] = substr($string, 0, $i);\n    }\n    return $prefixes;\n}\n",
  "    return array_map(function($s) {\n        return substr($s, 0, min(strlen($s),\
    \ strlen($string)));\n    }, $string);\n}\n", "    if (strlen($string) < 2) return\
    \ array();\n    $prefixes = array();\n    for ($i = 0, $len = strlen($string);\
    \ $i < $len; ++$i) {\n        $prefix = substr($string, $i, 1);\n        $prefixes[]\
    \ = $prefix;\n    }\n    return $prefixes;\n}", "    $prefixes = array();\n  \
    \  for ($i = 0, $s = strlen($string); $i < $s; $i++) {\n        for ($j = 0; $j\
    \ < strlen($string); $j++) {\n            $prefixes[] = substr($string, $i, 1);\n\
    \            $i += 1;\n        }\n    }\n    return $prefixes;\n}\n", "    $length\
    \ = mb_strlen($string, '8bit');\n    $prefixes = [];\n    for ($i = 0; $i < $length;\
    \ ++$i) {\n        $char = mb_substr($string, $i, 1, '8bit');\n        if ($char\
    \ !== '_') {\n            $prefixes[] = $char;\n        }\n    }\n    return $prefixes;\n\
    }\n", "    foreach (str_split($string) as $char) {\n        $prefix[] = substr($string,\
    \ 0, $char);\n    }\n    sort($prefix);\n    return $prefix;\n}\n</code>\n<|/\
    \ a tags=php,string,algorithm |>\n<| a dscore=2 |>\nFor a string, this seems to\
    \ be the best solution:\n<code>", "\t$prefixes = array();\n\t$prefix_length =\
    \ 1;\n\t$prefix = $string;\n\twhile ($prefix_length <= strlen($prefix)) {\n\t\t\
    $prefix = substr($prefix, 0, $prefix_length);\n\t\tif (! in_array($prefix, $prefixes))\
    \ $prefixes[] = $prefix;\n\t\t$prefix_length++;\n\t}\n\treturn $prefixes;\n}\n",
  "    $prefixes = array();\n    for ($i=0; $i < strlen($string); $i++) {\n      \
    \  $prefix = substr($string, 0, $i);\n        if (in_array($prefix, $prefixes))\n\
    \            continue;\n        $prefixes[] = $prefix;\n    }\n    return $prefixes;\n\
    }\n", "    $prefixes = array();\n\n    $s = strlen($string);\n    for ($i = 0;\
    \ $i < $s; $i++) {\n        for ($j = 0; $j < $s; $j++) {\n            if (\"\
    a\" < \"z\" <= \"z\" < \"a\" && \"A\" < \"Z\" <= \"Z\" < \"A\" && \"0\" < \"9\"\
    \ <= \"9\" < \"0\") {\n                $prefixes[] = $string[$i];\n          \
    \  }\n        }\n    }\n\n    return $prefixes;\n}\n</code>\n<|/ a tags=algorithm,php\
    \ dscore=2 |>\n<| c |>\nThat is *a lot* more complex than I thought it would be.\n\
    <|/ c |>\n<| c |>\nI added the other solution too. It was just a bit more complicated\
    \ than it should have been in the first place.\n<|/ c |>\n<| a |>\nYou can use\
    \ this code\n<code>\n$word = \"abc\";\n\n$arr = str_split($word);\n\n$output =\
    \ '';\nforeach ($arr as $char) {\n    $output .= ($char == $word[$i]) ? '+' :\
    \ $char;\n}\n</code>\n<|/ a dscore=0 tags=algorithm,php |>\n<| c |>\nIt seems\
    \ rather complicated to me. You are creating an array of letters from the input\
    \ and then rebuilding them one by one. Not really the simplest code.\n<|/ c |>\n\
    <| a tags=algorithm,php |>\nI have written this algorithm in python:\n<code>\n\
    >>> def all_prefixes(s):\n...     n = len(s)\n...     for i in xrange(n):\n...\
    \         prefixes = [s]\n...         for j in xrange(i):\n...             if\
    \ s[j] not in prefixes:\n...                 prefixes.append(s[j])\n...      \
    \   return prefixes\n... \n>>> all_prefixes('abc')\n['a', 'ab', 'abc']\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\n<?php"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
