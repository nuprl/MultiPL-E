name: HumanEval_2_truncate_number
language: php
prompt: "<?php\n// Given a positive floating point number, it can be decomposed into\n\
  // and integer part (largest integer smaller than given number) and decimals\n//\
  \ (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
  // >>> truncate_number(3.5)\n// 0.5\nfunction truncate_number($number) {\n"
tests: "function candidate(...$args) {\n    return truncate_number(...$args);\n}\n\
  \nfunction test(): void {\n    if (candidate(3.5) !== 0.5) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(1.25) !== 0.25) { throw new Exception(\"Test\
  \ failed!\"); }\n    if (candidate(123.0) !== 0.0) { throw new Exception(\"Test\
  \ failed!\"); }\n}\n\ntest();"
completions: ["  $decimals = strlen($number) - strrpos($number, '.');\n  if ($decimals\
    \ === -1) {\n    return $number;\n  }\n  $integer = '1';\n  $length = strlen($integer);\n\
    \  for ($i = 1; $i < $decimals; ++$i) {\n    $integer .= '0';\n  }\n  return $integer\
    \ . '.' . substr($number, $decimals + 1);\n}", "    if ($number < 1) {\n     \
    \   return 0;\n    }\n    return ceil($number);\n}\n", "\tif ($number < 1) {\n\
    \t\treturn 0;\n\t}\n\treturn ceil($number);\n}\n", "    $parts = explode('.',\
    \ $number);\n    if (count($parts) > 2) {\n        return $number;\n    }\n\n\
    \    return ($parts[1] == 0) ? round($number, 0) : $number;\n}\n", "    $num =\
    \ explode(\".\", $number);\n    return ($num[1] == 0) ? $num[0] : $num[0];\n}\n\
    \n/**\n * Formats the given number to a string.\n *\n * @param $number The number\
    \ to format.\n * @param $precision How many decimal places to round the number\
    \ to (default 0).\n * @return string Formatted number.\n */", "    $fraction =\
    \ $number-floor($number);\n    $integer = floor($number);\n    if ($fraction <\
    \ 0) {\n        $integer += floor($fraction);\n        $fraction = 0;\n    }\n\
    \    return $integer+$fraction;\n}", "    if (!is_numeric($number)) {\n      \
    \  return $number;\n    }\n\n    if ($number < 0) {\n        return $number;\n\
    \    }\n\n    $number_string = (string) $number;\n    $length = strlen($number_string);\n\
    \    if ($length < 1 || $length > 9) {\n        return $number;\n    }\n\n   \
    \ $result = substr($number_string, 0, $length - 1);\n    $result = rtrim($result,\
    \ '.');\n    if ($result > 1) {\n        $result *= 100;\n    }\n\n    return\
    \ $result;\n}\n\n/**\n * Format a byte size into a human readable size (e.g. 3\
    \ KB -> 3.5 MB)\n *\n * @param  string|int|float $size\n * @return string\n */",
  "  $round = pow(10, max(0, intval(log10($number))));\n  return $number < 1 ? 1 :\
    \ floor($number * $round) / $round;\n}\n", "    $decimal = $number - intval($number);\n\
    \    if ($decimal > 0.01) {\n        return round($number, 1);\n    }\n    return\
    \ $number;\n}\n", "  $sign = ($number < 0) ? '-' : '';\n  $string = number_format($number,\
    \ 0, '.', '');\n  $decimals = strlen($string) - strrpos($string, '.');\n  return\
    \ $sign . $number . '.' . substr($string, $decimals);\n}\n</code>\nNow you just\
    \ need to refactor your function to use the above function instead of your own.\
    \ Something like this:\n<code>\n/**\n * Formats phone number with specified format\
    \ and\n * adds extension if specified and does not already have one.\n *\n * string\
    \ $number\n * string $format E.g. '+49 (###) ###-##-##'\n * string $extension\
    \ E.g. '.ext' (defaults to '')\n * string\n */", "  return floor($number * 10)\
    \ / 10;\n}\n", "  $sign = $number < 0 ? -1 : 1;\n\n  return $sign * (int) ($number\
    \ - intval($number / abs($number)));\n}\n", "\treturn bcdiv($number, 1, 0, '',\
    \ STR_PAD_LEFT);\n}\n", "    return floor($number+.5);\n}\n", "  $integer = intval($number);\n\
    \  if ($integer == $number) {\n    return $integer;\n  }\n  $decimal = $number\
    \ - $integer;\n  if ($decimal < 0.0) {\n    return $decimal;\n  }\n  return $decimal\
    \ + 1;\n}", "  return $number > 0 ? floor($number - round($number)) : ceil($number);\n\
    }", "    $precision = strlen((string)$number) - strrpos((string)$number, '.');\n\
    \    return (float)number_format($number, $precision, '.', '');\n}\n", "  return\
    \ $number < 1 ? floor($number + 0.5) : $number;\n}\n", "  return intval($number\
    \ * 100) / 100;\n}\n</code>\n<|/ a tags=php,numbers,math |>\n<| a |>\nA quick\
    \ solution might be to check if there is a decimal point and if so remove it.\
    \ \n<code>\nif (strpos($yourNumber, '.') !== false)\n{\n    $yourNumber = str_replace('.',\
    \ '', $yourNumber);\n}\n</code>\n<|/ a tags=php,numbers,math dscore=2 |>\n<| c\
    \ |>\n`strpos` doesn't return a boolean, so your if statement will always evaluate.\n\
    <|/ c |>\n<| c |>\nYes, the double negation is unnecessary. Just check for false.\
    \ `if (strpos($yourNumber, '.') !== false) { ... }`\n<|/ c |>\n<| a tags=php,numbers,math\
    \ |>\nAnother idea to consider is to round the number and then truncate it to\
    \ only get the decimals.\n<code>\nround(3.4) == 3\nround(3.3) == 3\nround(3.2)\
    \ == 4\nround(3.0) == 3\nround(3.1) == 3\n</code>\nThen you can subtract the floor()\
    \ of the rounded number from your number to get the truncated decimals.\n<|/ a\
    \ dscore=2 |>\n<| a tags=php,numbers,math |>\nYou want to round up your number\
    \ to n decimal places.\nTo achieve this you can use the sprintf function:\n<code>\n\
    $roundedNumber = sprintf('%0.2f', $number);\n</code>\nOr if you only want to round\
    \ the number down to the given number of decimal places, you can use the round\
    \ function:\n<code>\n$roundedNumber = round($number, $decimalPlaces);\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nHi, thanks for your help, but my question is how do\
    \ I get the number with 2 decimal places rounding.\n<|/ c |>\n<| c |>\nHi, thanks\
    \ for your help, but my question is how do I get the number with 2 decimal places\
    \ rounding.\n<|/ c |>\n<| a |>\nAnother possibility is to check whether the number\
    \ contains decimals using strpos(), and if so, remove them:\n<code>\n$number =\
    \ preg_replace('/\\.[0-9]/', '', $number);\n</code>\n<|/ a tags=php,numbers,math\
    \ dscore=2 |>\n<| c |>\nI like this one. But i think the decimal is not necessary\n\
    <|/ c |>\n<| c |>\nI agree. Not sure why the OP wants decimals though.\n<|/ c\
    \ |>\n<| a tags=php,numbers,math ", "  $decimal = strpos($number, '.');\n  return\
    \ $decimal === false ? $number : substr($number, 0, $decimal);\n}\n", "    $parts\
    \ = explode('.', $number);\n    $decimal_part = $parts[1];\n    $decimal_part\
    \ = ltrim($decimal_part, '0');\n\n    $large_number = $parts[0];\n    $large_number\
    \ = substr($large_number, 0, -1);\n    $large_number = ltrim($large_number, '0');\n\
    \n    // If no decimal part is left, return $number as is\n    if ($decimal_part\
    \ == '0') {\n        return $number;\n    }\n\n    // If small number has no decimal\
    \ part, return the number\n    if (strlen($large_number) > strlen($decimal_part))\
    \ {\n        return $number;\n    }\n\n    // Truncate large number to nearest\
    \ integer\n    return intval($large_number) + $decimal_part;\n}\n</code>\n<|/\
    \ a dscore=5 |>\n<| c |>\nIt works like a charm and i think it is much easier\
    \ to read compared to the other answers\n<|/ c |>\n<| a tags=math,php |>\n<code>",
  "  return floor($number + 0) - 0;\n}\n", "  $int_part = floor(abs($number));\n \
    \ $decimal_part = abs($number - $int_part);\n  if ($decimal_part < 0.001) {\n\
    \    return $int_part;\n  }\n  return round($decimal_part * pow(10, floor(log10(abs($decimal_part)))),\
    \ 2);\n}\n", "    if (!is_numeric($number)) {\n        return false;\n    }\n\
    \    if ($number < 0) {\n        $number = -$number;\n    }\n    $length = strlen($number);\n\
    \    $decimal = substr($number, $length - 1);\n    if ($decimal != '0') {\n  \
    \      return $number;\n    }\n    if ($number == intval($number)) {\n       \
    \ return $number;\n    }\n    // Remove the decimal part\n    $number = substr($number,\
    \ 0, -1);\n    return $number;\n}\n", "  return floor($number * (PHP_INT_MAX +\
    \ 1) / PHP_INT_MAX);\n}\n", "  return floor($number);\n}\n", "    if ($number\
    \ < 1) {\n        return 0.0;\n    }\n\n    $remainder = fmod($number, 1);\n \
    \   if ($remainder == 0) {\n        return $number;\n    }\n\n    return $number\
    \ - $remainder;\n}", "  $remainder = $number;\n  $decimal = 0;\n\n  // If the\
    \ remainder is also negative\n  if ($number < 0) {\n    $remainder = -$number;\n\
    \  }\n\n  // Loop through every digit and check whether\n  // the remainder is\
    \ greater or smaller than the current digit.\n  for ($i = 0; $i < strlen($number);\
    \ $i++) {\n    $part = floor($remainder);\n    $remainder = $remainder - $part;\n\
    \n    // If remainder is smaller than the current digit\n    // and we are in\
    \ the first digit position,\n    // it means we have found the decimal.\n    if\
    \ ($remainder < pow(10, $i) and $i == 0) {\n      $decimal = $part;\n      break;\n\
    \    }\n  }\n\n  return $decimal;\n}\n</code>\n<|/ a dscore=2 |>\n<| a |>\n<code>\n\
    <?php\n$number = '5';\n$decimal = strlen($number) - strlen(strrchr($number, '.'))+1;\n\
    </code>\nThis code will count the number of dots in the string and then count\
    \ the number of characters before the dot. The reason is that if there is a dot\
    \ in front of the number, the whole number is already cut off and you won't be\
    \ able to get the correct decimal value.\n<|/ a dscore=1 tags=decimal,php |>\n\
    <| a tags=decimal,php |>\n<code>\n<?php \n$number=\"0.5\";\n$number= substr($number,\
    \ 0, strrpos($number, '.'));\n</code>\n<|/ a dscore=0 |>\n<| a tags=decimal,php\
    \ dscore=0 |>\nI think this works for you \n<code>\n$number = $val['price']; //where\
    \ $val is a array and price is key\n$decimals = intval(substr($number, 0, strrpos($number,\
    \ '.')));\n</code>\n<|/ a |>\n<| a |>\nYou could use the following functions:\n\
    <code>\n<?php\n", "  return floatval($number);\n}\n", "    // If number is already\
    \ integer or zero, return it.\n    if ($number == (int) $number) {\n        return\
    \ $number;\n    }\n    // If number is a float, convert it to integer and then\
    \ return.\n    if (is_float($number)) {\n        return (int) round($number);\n\
    \    }\n    // If number is a string, trim it, then convert it to an integer and\
    \ then return.\n    return (int) trim($number);\n}\n</code>\n<|/ a dscore=3 tags=php,math\
    \ |>\n<| c |>\nThis fails on `1.999998` and similar.\n<|/ c |>\n<| c |>\nThat's\
    \ probably a limitation of PHP's `bcdiv()` implementation.\n<|/ c |>\n<| a dscore=3\
    \ |>\n<code>", "  $decimals = preg_match('/\\.([0-9]+)/', $number, $decimals);\n\
    \  if ($decimals) {\n    $decimals = strlen($decimals[1]);\n  } else {\n    $decimals\
    \ = 0;\n  }\n\n  return intval($number) - intval($number) % $decimals;\n}\n",
  "  return round($number, 1);\n}\n", "    $decimals = floor(log10(abs($number)))\
    \ + 1;\n\n    return floor($number / 10**$decimals) * 10**$decimals;\n}\n</code>\n\
    <|/ a tags=php,mysql,sql,algorithm |>\n<| c |>\nThis code does not seem to work\
    \ for `ceil(1.5)`\n<|/ c |>\n<| c |>\nThis code does not seem to work for `ceil(1.5)`.\
    \ \n`ceil(1.5)` returns `2` whereas it should be `1.5`.\n<|/ c |>\n<| c |>\nI\
    \ think this is the best answer, it also works with ceil\n<|/ c |>\n<| c |>\n\
    This code does not work for `ceil(1.5)` it returns `2`, whereas it should be `1.5`.\n\
    <|/ c |>\n<| a dscore=4 |>\nI took it all together for myself (with help of other\
    \ answers) to make the function below which works with any type of numbers and\
    \ decimal places:\n<code>", "    if ($number == 0.0) {\n        return 0.0;\n\
    \    }\n    if ($number == 1.0) {\n        return 1.0;\n    }\n    if ($number\
    \ < 0.0) {\n        $number = -$number;\n    }\n    $whole = $number % 1;\n  \
    \  $number = $number - $whole;\n    $remainder = $number % 1;\n    if ($remainder\
    \ >= 0.5) {\n        return $whole;\n    }\n    return $whole + 1;\n}\n", "  $num_int\
    \ = (int) $number;\n  $num_decimal = (int) floor($number);\n  return round($number)\
    \ - $num_decimal;\n}\n", "  return $number < 0 ? ceil($number + 0.5) : floor($number\
    \ + 0.5);\n}\n", "    $exponent = floor(log10(abs($number)));\n    $number = floor($number\
    \ * pow(10, $exponent)) / pow(10, $exponent);\n    return $number;\n}\n</code>\n\
    <|/ a tags=php,math dscore=2 |>\n<| c |>\nGood point on not using division.  I\
    \ was worried that it would introduce a lot of overhead for what seems like a\
    \ simple operation.  I also didn't think of log10().\n<|/ c |>\n<| c |>\nIt seems\
    \ I misread your answer as using logarithms, but now that I think about it, it\
    \ just seems to add too much overhead.  I guess I'll stick to my current method\
    \ of truncating the decimals and using division instead.\n<|/ c |>\n<| c |>\n\
    I added an alternate solution without logarithms, it may be more efficient for\
    \ some cases, though I don't know.\n<|/ c |>\n<| a tags=php,math |>\nOne other\
    \ solution which may help you:\n<code>\n$number = 15.5678;\n\n$decimals = strrchr(strval($number),\
    \ '.');\n$decimals = str_replace('.', '', $decimals);\n\nif($decimals == '0')\
    \ {\n    echo 'No decimal found';\n} else {\n    echo $number / pow(10, strlen($decimals)-1);\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThe result of this is: `1.666`, but that\
    \ would be a problem if the number was `1.`\n<|/ c |>\n<| c |>\nI added a solution\
    \ to this to the original question.\n<|/ c |>\n<| a tags=php,math |>\nA simple\
    \ way is to cast the number to a string, remove the decimal point, then cast it\
    \ back to a number:\n<code>\n$number = 2.50;\necho $number / pow(10, strrpos((string)\
    \ $number, '.'));\n</code>\n<|/ a dscore=2 |>\n<| c |>\nthis answer is more accurate\
    \ than the accepted answer since it handles the cases where the decimal places\
    \ are zero\n<|/ c |>\n<| a tags=php,math dscore=2 |>\n<code>\n<?php\n\n$num =\
    \ 8.50;\n$dec = substr(strrchr((string)$num, '.'), 1);\n$dec = substr($dec, 0,\
    \ strlen($dec) - 1);\n\nif ($dec == 0)\n    echo '0';\nelse\n    echo $num / pow(10,\
    \ strlen($dec));\n", "    return $number <= 0 ? 0 : intval(($number + 0) * 100)\
    \ / 100;\n}\n", "  $decomposed = dechex(floor($number));\n  $decimals = strlen($decomposed)\
    \ - strrpos($decomposed, $decomposed[0]);\n  $decimals = strlen($decimals) ? '.'\
    \ . substr($decimals, 1) : '';\n  return substr($decomposed, 0, strlen($decomposed)\
    \ - strlen($decimals));\n}\n", "  if ($number < 0) {\n    return 0;\n  }\n  return\
    \ round($number);\n}\n", "    if ($number === 0) {\n        return 0;\n    }\n\
    \n    $number_parts = explode('.', $number);\n\n    return $number_parts[1];\n\
    }\n", "    $number = ($number + 0); // Avoid NaNs\n    $decPlaces = $number %\
    \ 1;\n    return $number - $decPlaces;\n}\n", "  // http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html\n\
    \  $dec = new BigDecimal($number);\n\n  // http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html\n\
    \  $integer = new BigDecimal('1');\n  $integer = $integer.divide($dec);\n  $integer\
    \ = $integer->multiply($dec);\n\n  return $integer;\n}\n", "    if ($number ==\
    \ 0) {\n        return 0.0;\n    }\n\n    return intval($number);\n}\n", "  $parts\
    \ = explode('.', $number);\n  if (count($parts) > 1) {\n    return $parts[1];\n\
    \  }\n  return $parts[0];\n}\n", "    if ($number > 0) {\n        return floor($number);\n\
    \    }\n\n    $x = $number - intval($number);\n    return ($x < 1) ? floor($number)\
    \ : $x;\n}\n</code>\n<|/ a |>\n<| a |>\nI implemented the function above but i\
    \ want to share the code with you:\n<code>", "    if ($number < 1.0) {\n     \
    \   return $number;\n    }\n    if ($number < 10) {\n        return floor($number);\n\
    \    }\n    $exponent = floor(log10($number));\n    $decimals = strlen($number)\
    \ - $exponent;\n    return floor($number / pow(10, $exponent)) + ($decimals ==\
    \ 0.5 ? 0.5 : 0);\n}\n</code>\n<|/ a |>\n<| a tags=php,math |>\nHow about this?\
    \ \n<code>\n<?php \n$a = 1.2;\n$a = round($a * pow(10,-3));\necho $a;", "    $result\
    \ = intval(abs($number));\n    if ($result <= 0) {\n        return 0;\n    }\n\
    \    return $result;\n}\n", "  if ($number == 0.0) {\n    return 0.0;\n  }\n\n\
    \  $result = $number - floor($number);\n  if ($result == 0.0) {\n    return $result;\n\
    \  }\n\n  return $result;\n}\n", "  if (!is_numeric($number)) {\n    throw new\
    \ \\InvalidArgumentException('The input is not a number.');\n  }\n\n  $decimals\
    \ = preg_replace('/([^0-9])\\.([0-9]+)/', '\\1', $number);\n  list($decimals,\
    \ $integer) = explode('.', $decimals);\n  return (float) $integer + $decimals;\n\
    }\n", "  if (abs($number) > 1.0) {\n    $number = floor(1.0 + $number);\n  }\n\
    \  return $number;\n}", "    return $number < 0 ? floor($number) : ceil($number);\n\
    }\n", "    $dec = $number % 1;\n    return ($dec == 0) ? intval($number) : round($number,\
    \ $dec);\n}\n\n/**\n * Get a timestamp of the current date in UTC\n *\n * Uses\
    \ http://php.net/manual/en/function.date.php\n */", "    $decimal_part = floor(abs($number));\n\
    \    return $number - $decimal_part * floor($number / $decimal_part);\n}\n", " \
    \   $fraction = number_format($number, 0, '', '');\n    $integerPart = (int) floor($number);\n\
    \    $decimalPart = $number - $integerPart;\n    if ($decimalPart >= 1) {\n  \
    \      return $decimalPart;\n    } else {\n        return $fraction;\n    }\n}",
  "    if (is_int($number)) {\n        return $number;\n    }\n\n    // the number\
    \ must be less than 1.\n    $number = max($number, 0);\n\n    // if the number\
    \ is greater than 1, it is equal 1.\n    // and if the number is smaller than\
    \ 1, it is the largest integer smaller than 1.\n    if ($number >= 1) {\n    \
    \    $number = ceil($number);\n    } else {\n        $number = floor($number);\n\
    \    }\n\n    return $number;\n}\n\n/**\n * Convert any number into its decimal\
    \ representation.\n * If the number is negative, return \"-\".\n * >>> convert_number(-3)\n\
    \ * '-3'\n * >>> convert_number(2.5)\n * '2'\n * >>> convert_number(5)\n * '5'\n\
    \ * >>> convert_number(0)\n * '0'\n * >>> convert_number(-0)\n * '0'\n * >>> convert_number(-0.5)\n\
    \ * '-0.5'\n * >>> convert_number(0.5)\n * '0.5'\n * >>> convert_number(0.33)\n\
    \ * '0.33'\n */", "  // Avoid errors due to rounding when casting to int.\n  $int_part\
    \ = intval($number);\n  return $int_part + ($number - $int_part) / \\PHP_INT_MAX;\n\
    }", "    if (is_float($number)) {\n        $decimal_places = preg_replace('/[^\\\
    .\\d]+/', '', $number);\n        return round($number, $decimal_places);\n   \
    \ }\n    return $number;\n}\n", "\tif ($number < 0.0) {\n\t\t$result = $number\
    \ / abs($number);\n\t\treturn $result - (float)strrpos($result, '.');\n\t}\n\t\
    $fraction = strrpos($number, '.');\n\treturn round($number / pow(10, $fraction),\
    \ 2);\n}\n", "  if (!is_numeric($number) || $number <= 0.0) {\n    throw new Exception($number\
    \ . \" is not a valid number\");\n  }\n  return $number - floor($number);\n}\n",
  "  $i = floor(log10($number)); // Leave as much as we can from the decimal part\n\
    \  return ($number <= $i ? floor($number / 10) : $i) * 0.1; // Multiply by 10\
    \ and subtract the decimal part\n}\n</code>\nThe benefit of this solution is that\
    \ it doesn't make any assumptions about rounding rules - it just truncates the\
    \ number at whatever precision is necessary.\n<|/ a tags=php |>\n<| c |>\nFor\
    \ some reason this answer got downvoted. Maybe because it's not PHP? I wrote a\
    \ PHP function that truncates a float or double, and it's also correct, so the\
    \ answer itself is not wrong.\n<|/ c |>\n<| c |>\nI didn't downvote, but it is\
    \ probably because it's not PHP, which I assumed from the tags of the question,\
    \ but that could be just my lack of PHP experience. My answer just happens to\
    \ work in PHP anyway.\n<|/ c |>\n<| c |>\nThat is indeed true. PHP has a lot of\
    \ good libraries available. I would not expect a PHP function to work everywhere,\
    \ though.\n<|/ c |>\n<| c |>\nThe answer is correct, however if your numbers are\
    \ already float then using round() is a much better option as it preserves precision.\
    \ Although it is not a built-in function but can be written as an extension in\
    \ PHP: http://stackoverflow.com/questions/10349237/how-to-truncate-float-to-two-decimals-in-php\n\
    <|/ c |>\n<| c |>\nAgreed. I updated the answer to show a PHP extension that can\
    \ truncate numbers to decimal places as well as integers.\n<|/ c |>\n<| a tags=php\
    \ |>\n<code>", "    $parts = explode('.', $number);\n    return $parts[1] ? $parts[1]\
    \ . '0' : 0;\n}\n", "  $fractionalPart = $number - floor($number);\n  $decimalPart\
    \ = number_format($fractionalPart, 0, '', '');\n  if ($decimalPart === '') {\n\
    \    $decimalPart = '0';\n  }\n  return $decimalPart;\n}\n", "    $decimal_precision\
    \ = strlen($number) - strpos($number, \".\");\n    if ($decimal_precision == 0)\
    \ {\n        return round($number, 0);\n    }\n    return round($number, $decimal_precision);\n\
    }\n", "    return ceil($number);\n}\n", "    $result = 0.0;\n    $remainder =\
    \ 0.0;\n\n    if ($number >= 0) {\n        $remainder = $number - floor($number);\n\
    \        if ($remainder > 0.0) {\n            $result = ($remainder > 0.0 ? floor($number)\
    \ : ceil($number));\n        }\n    }\n\n    return $result;\n}\n", "    $negative\
    \ = $number < 0;\n    $string = (string) $number;\n    // If the string begins\
    \ with \"-\" or a \"+\"\n    // we can safely remove it\n    if ($negative) {\n\
    \        if (substr($string, 0, 1) === '-') {\n            $string = substr($string,\
    \ 1);\n        } else {\n            $string = '+';\n        }\n    }\n    //\
    \ remove zeros\n    $string = preg_replace('/\\.0*$/', '', $string);\n    // Remove\
    \ thousand grouping separator\n    $string = preg_replace('/,0*$/', '', $string);\n\
    \    // Remove thousand separator\n    $string = preg_replace('/0,0*$/', '', $string);\n\
    \    $parts = explode('.', $string);\n    $decimals = count($parts) - 1;\n   \
    \ $decimals = $decimals % 1;\n    // If we have less than 1 decimal, we return\
    \ 0 anyway.\n    return $negative ? -$parts[0] * pow(10, -$decimals) : $parts[0]\
    \ * pow(10, $decimals);\n}\n", "    // the largest integer smaller than the given\
    \ number\n    $max_int = (int) $number;\n    // the leftover part (smaller than\
    \ 1)\n    $max_frac = (int) ($number - $max_int);\n    // the decimal part of\
    \ the number\n    return $max_frac;\n}\n</code>\n<|/ a dscore=1 tags=php,floating-point\
    \ |>\n<| a dscore=1 |>\nI used the PHP function bcmul to multiply two decimal\
    \ numbers and then truncate the result (using bcmath).\nThe code is as follows:\n\
    <code>\n$result = bcmul($x, $y); // $x is the float and $y is the integer\n$result\
    \ = bcmod($result,1); // truncate the result\n</code>\n<|/ a tags=php,floating-point\
    \ |>\n<| c |>\nThis worked for me in combination with round($result, 1); where\
    \ $result is decimal float and $result is integer in form of integers.\n<|/ c\
    \ |>\n<| a dscore=1 |>\nYou could round it and divide by 1 to get rid of any decimals\
    \ beyond the 6th decimal. For example:\n<code>\necho round(10.1234) / 1;\n</code>\n\
    <|/ a tags=php,floating-point |>\n<| c |>\nThis works, but it's not what I'd call\
    \ an answer to the question. If I understand correctly the OP wants to truncate\
    \ a floating-point number to an integer. By rounding it you loose the fractional\
    \ part.\n<|/ c |>\n<| a tags=php,floating-point dscore=0 |>\n<code>\n$num = (int)$num;\n\
    </code>\nThis works if you only want integer numbers, if you want float numbers\
    \ (which may have decimals) you could try this:\n<code>\n$num = floor($num);\n\
    </code>\n<|/ a |>\n<| a |>\nIf you don't mind using GMP library, you can do this\
    \ in one line:\n<code>\n$num = $num->copysign($num->integer($num));\n</code>\n\
    This way you will avoid the rounding/flooring issues mentioned in other answers,\
    \ and you will get integer result as well.\n<|/ a dscore=0 tags=php,floating-point\
    \ |>\n<| a |>\n<code>", "    $precision = strlen(ltrim($number, '0'));\n    return\
    \ round($number, $precision - strlen($number)) - $number < 0.01\n        ? floor($number)\n\
    \        : floatval($number);\n}\n", "  if ($number < 1) {\n    return 0;\n  }\n\
    \  $pow10 = 10;\n  $decPos = strrpos($number, '.');\n  $decLen = 0;\n  if ($decPos\
    \ !== false) {\n    $decLen = strlen($number) - $decPos;\n  }\n  $decLen = intval($decLen);\n\
    \  if ($decLen === 0) {\n    return round($number, $pow10);\n  }\n  if ($decLen\
    \ > $pow10) {\n    // Decimal part is too long to fit in $pow10\n    return round($number,\
    \ $pow10 - $decLen);\n  }\n  $decLen = $decLen - $pow10;\n  $intPart = floor($number);\n\
    \  $decPart = $number - $intPart;\n  if ($decPart > 0) {\n    return round($intPart\
    \ + ($decPart * $pow10), $pow10);\n  }\n  return round($intPart, $pow10);\n}\n",
  "    $result = intval($number);\n    $decimal = substr($number, strlen($number)\
    \ - 1);\n    if ($number > 0 && $decimal > 0) {\n        $result = $result / $decimal;\n\
    \    }\n    return $result;\n}", "    return intval((float) $number);\n}\n", " \
    \   $integer = floor($number);\n    $decimal = substr($number, $integer, strlen($number)\
    \ - $integer);\n\n    return $decimal;\n}\n", "  return $number < 1 ? $number\
    \ : $number - floor($number);\n}\n", "  return floor($number * 100) . '%';\n}\n",
  "  if ($number >= 1) {\n    return round($number);\n  }\n  $precision = strlen(ltrim($number,\
    \ '0'));\n  return round($number, $precision == 0 ? '0' : -1);\n}\n", "  // Round\
    \ down the number until it's small enough.\n  $decimal = $number - floor($number);\n\
    \  if ($decimal > 0.5) {\n    $number = floor($number);\n  } else {\n    $number\
    \ = ceil($number);\n  }\n\n  return $number;\n}\n</code>\n<|/ a tags=php |>\n\
    <| c |>\nI'm pretty sure this wont work when dealing with negative numbers.  You\
    \ can't really use floor() when dealing with negative numbers.\n<|/ c |>\n<| c\
    \ |>\nThat doesn't work either... it just rounds up to 0.\n<|/ c |>\n<| c |>\n\
    You're right :) I edited my answer\n<|/ c |>\n<| c |>\nYou didn't answer the question,\
    \ did you? What does your function do for negative numbers? Also, `0.5` and `0.5000`\
    \ will become `0.500` but your function will round up. `0.50` will become `0.51`\n\
    <|/ c |>\n<| c |>\nNope. OP asked for a function that truncates the number to\
    \ the nearest whole number. `0.50` becomes `0.51` and not `0.5`.\n<|/ c |>\n<|\
    \ a dscore=4 |>\nHow about this?\n<code>", "    if ($number < 1) {\n        return\
    \ $number;\n    }\n    $remainder = fmod($number, 1);\n    return floor($number)\
    \ - $remainder;\n}\n", "\t$number = abs($number);\n\n\tif ($number <= 1) {\n\t\
    \treturn 1;\n\t}\n\telse {\n\t\treturn round($number - $number % 1, 2);\n\t}\n\
    }\n", "  if ($number < 0) {\n    return -truncate_number(-$number);\n  }\n  //\
    \ Round half away from zero.\n  $decimals = floor((string)(intval($number) - 0.5));\n\
    \  $decimals = ($decimals > 0 ? $decimals : 0);\n  return $decimals;\n}\n", " \
    \   if ($number < 1) {\n        return 1;\n    }\n\n    $result = 0;\n    if ($number\
    \ >= 0) {\n        $result = 1;\n    }\n\n    return round($number - $result *\
    \ (int) $number, 6);\n}\n\n/**\n * Given a percentage number and maximum value,\
    \ returns the percentage rounded up to\n * the maximum value.\n * >>> set_percentage_width(0.7,\
    \ 100)\n * 100\n */", "  return floor($number*100)/100;\n}\n", "\t$n = floor($number);\n\
    \t$digits = strlen($number) - strlen($n);\n\treturn ($n < 1) ? 0 : ($digits >\
    \ 0) ? (substr($number, 0, $digits) . '.') : 0;\n}\n", "    $decimals = 1;\n \
    \   $integer = ceil($number);\n    if ($integer > 1) {\n        while ($integer\
    \ % 10 == 0) {\n            $integer++;\n        }\n    }\n    return $number\
    \ - $integer * pow(10, $decimals);\n}\n", "  $numberString = (string)$number;\n\
    \  if ($numberString{0} == '-') {\n    $negative = true;\n    $numberString =\
    \ substr($numberString, 1);\n  } else {\n    $negative = false;\n  }\n\n  // remove\
    \ commas\n  $numberString = str_replace(',', '', $numberString);\n\n  $decPart\
    \ = $numberString{0}; // start with the decimal part\n  $intPart = '';\n  $decimals\
    \ = '';\n  $lastPos = 0;\n  $length = strlen($numberString);\n  for ($i = 1; $i\
    \ <= $length; $i++) {\n    $char = substr($numberString, $i, 1);\n    if ($char\
    \ == '.') {\n      $decimals .= $char;\n    }\n    elseif ($char == '-') {\n \
    \     $negative = true;\n    }\n    elseif ($char == 'e' || $char == 'E') {\n\
    \      $decimals .= $char;\n    }\n    else {\n      $intPart = ($lastPos < $i)\
    \ ? $intPart . substr($numberString, $lastPos, $i - $lastPos) : $intPart;\n  \
    \    $decimals .= $char;\n    }\n    $lastPos = $i;\n  }\n\n  return ($negative)\
    \ ? -$decPart . $decimals : $decPart . $decimals;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a |>\nThe original code works in my situation when $numberString = '3.2';\n\
    <code>", "    $precision = $number->precision();\n    $fraction = $number->fpart();\n\
    \    if ($fraction === 0) {\n        return $number;\n    }\n    if ($precision\
    \ > 0) {\n        return $number;\n    }\n    if ($fraction < 0) {\n        $fraction\
    \ = 1;\n    }\n    // Round fraction if number is not an integer.\n    $fraction\
    \ = round($fraction, 0);\n    // Round fraction to $precision\n    $fraction =\
    \ $fraction->round($precision);\n    return $number->badd($fraction);\n}\n", " \
    \   $truncated = abs($number);\n    $remainder = $number - $truncated;\n    return\
    \ $truncated - ($remainder ? floor($remainder + 0.5) : 0);\n}\n\n/**\n * Convert\
    \ a hexadecimal number to an integer, without losing information.\n * Returns\
    \ the integer or FALSE when it's not a hexadecimal number.\n *\n * @param string\
    \ $hexadecimal The hexadecimal number\n * @return int Returns integer representation\
    \ of hexadecimal number when successful\n */", "    return (int)rtrim(sprintf('%.0f',\
    \ $number), '.');\n}\n", "    $remainder = $number % 1;\n    $decimals = '';\n\
    \    $decimals_needed = intval(floor(log10($number)) + 1);\n    if ($remainder)\
    \ {\n        $decimals_needed = $decimals_needed + 1;\n    }\n    for ($i = 0;\
    \ $i < $decimals_needed; $i++) {\n        $decimals .= ($i > 0) ? \".\" : \"\"\
    ;\n    }\n    return $number - $remainder . $decimals;\n}\n</code>\n<|/ a tags=php,math,floating-point\
    \ |>\n<| c |>\nYou don't need to do the whole number part, just do `floor(log10(abs($num)))\
    \ + 1` then `floor($num / pow(10, $decimals)) * pow(10, $decimals)`.\n<|/ c |>\n\
    <| c |>\nYeah, but you already have the number of decimals.\n<|/ c |>\n<| c |>\n\
    Yes, but you still need to go through all the digits. My suggestion avoids any\
    \ looping.\n<|/ c |>\n<| c |>\nThat would work also, but `log10(abs($num))` is\
    \ simpler, and is closer to the original code.\n<|/ c |>\n<| a dscore=3 |>\nJust\
    \ as a simple alternative:\n<code>\n$num = 1.58;\necho ceil($num * 100) / 100;\n\
    </code>\n<|/ a tags=php,math,floating-point |>\n<| c |>\nThanks for this alternative!\n\
    <|/ c |>\n<| a dscore=3 |>\n<code>\n<?php\n$num = '1.54';\necho ceil($num*100)/100;\n\
    </code>\n<|/ a tags=php,math,floating-point |>\n<| c |>\nThanks for this alternative!\n\
    <|/ c |>\n<| a tags=php,math,floating-point |>\n<code>\necho ceil($num*100)/100;\n\
    </code>\n<|/ a dscore=3 |>\n<| a tags=php,math,floating-point |>\n<code>\n$num\
    \ = 1.54;\necho number_format(($num * 100) + 0.5, 2, '.', '');\n</code>\nOutput:\
    \ 1.54\n<|/ a dscore=2 |>\n<| c |>\nThe question was how to truncate floating\
    \ point numbers to 2 decimal places. This converts them to integers and rounds\
    \ them up.\n<|/ c |>\n<| a |>\n<code>\necho round($number * 100) / 100;\n</code>\n\
    <|/ a tags=php,math,floating-point dscore=2 |>\n<| c |>\nThis rounds up numbers\
    \ below 1.0 and rounds down numbers above 1.0\n<|/", "    $int_part = (int) $number;\n\
    \    if ($int_part == 0) {\n        return 0.0;\n    }\n\n    // Truncate decimal\
    \ part at the decimal point only if there is one integer part.\n    $decimal_part\
    \ = $number - $int_part;\n    if ($decimal_part == 0.5) {\n        $decimal_part\
    \ = 0.0;\n        $int_part++;\n    }\n\n    // Convert to decimal string, then\
    \ remove trailing zeros\n    return number_format($decimal_part, 2);\n}\n</code>\n\
    <|/ a |>\n<| a tags=floating-point,php,javascript |>\nI needed a quick way to\
    \ round off a number to 2 decimals in PHP. I tried several options but none worked\
    \ as per my need. I had to do something similar to this:\n<code>\n<?php \n   \
    \ $price = '0.35';\n    $price = number_format((float)$price, 2, '.', ''); \n\
    \    $price = round($price, 2); ", "  $parts = explode('.', $number);\n  return\
    \ $parts[1] ?? 0;\n}", "\t$integer = intval($number);\n\t$decimal = ($integer\
    \ - $number) % 1;\n\t$number = $integer - $decimal;\n\treturn $number;\n}\n",
  "    return round($number, -floor($number) - 1);\n}\n", "  $decimal_pos = strrpos($number,\
    \ '.');\n  if ($decimal_pos !== false) {\n    $integer_part = substr($number,\
    \ 0, $decimal_pos);\n    $decimals = substr($number, $decimal_pos);\n    $decimals\
    \ = strlen($decimals) % 2 ? 0 : $decimals;\n    return $decimals ? substr($integer_part,\
    \ 0, strlen($integer_part) - $decimals) : $integer_part;\n  }\n  return $number;\n\
    }\n</code>\n<|/ a dscore=4 tags=php,rounding |>\n<| c |>\nVery elegant solution,\
    \ thanks. I extended it a little to also handle negative numbers (which I didn't\
    \ want to do myself):\n`function truncate_number($number) {\n  if ($number < 0)\
    \ {\n    return -truncate_number(-$number);\n  }\n  $decimal_pos = strrpos($number,\
    \ '.');\n  if ($decimal_pos !== false) {\n    $integer_part = substr($number,\
    \ 0, $decimal_pos);\n    $decimals = substr($number, $decimal_pos);\n    $decimals\
    \ = strlen($decimals) % 2 ? 0 : $decimals;\n    return $decimals ? substr($integer_part,\
    \ 0, strlen($integer_part) - $decimals) : $integer_part;\n  }\n  return $number;\n\
    }`\n<|/ c |>\n<| c |>\nJust out of interest, can you please share your thoughts\
    \ on [this related question here](https://stackoverflow.com/q/61511102/1372253)?\
    \ It seems to be a similar question, but the accepted answer is more elegant,\
    \ so I wanted to ask a separate question.\n<|/ c |>\n<| a tags=php,rounding |>\n\
    I created this function based on your answer:\n<code>", "    $precision = strlen($number)\
    \ - strpos($number, '.');\n    return round($number, $precision);\n}\n", "  if\
    \ (!is_float($number)) {\n    throw new InvalidArgumentException('$number must\
    \ be a float or integer');\n  }\n  if ($number === 0) {\n    return 0;\n  }\n\
    \  $negated = $number < 0;\n  $number = abs($number);\n  $decimals = strlen((string)\
    \ $number) - strrpos($number, '.');\n  if ($decimals === 0) {\n    return $number;\n\
    \  }\n  if ($number <= 1 / 10) {\n    return $negated ? floor($number) : ceil($number);\n\
    \  }\n  $factor = 10 ** $decimals;\n  if ($number >= $factor + 1 / 10) {\n   \
    \ return $negated ? floor($number) : ceil($number);\n  }\n  $rem = $number % $factor;\n\
    \  return $negated ? ceil($rem / $factor) : floor($rem / $factor);\n}\n", "  //\
    \ >>> truncate_number(2.5)\n  // 2\n  if ($number <= 1) {\n    return $number;\n\
    \  }\n  if ($number > 1000) {\n    return number_format(round($number, 2), 2);\
    \ // round up with 2 decimals\n  }\n  $truncated = floor($number);\n  return $number\
    \ - $truncated;\n}\n", "    if ($number == 0) {\n        return 0;\n    }\n  \
    \  $intpart = floor(abs($number));\n    $decimals = abs($number - $intpart);\n\
    \    return $decimals > 0 ? '.' . str_pad($decimals, 3, '0', STR_PAD_LEFT) : 0;\n\
    }\n\n/**\n * Generates a value with a specific length based on the total length\n\
    \ * of the number input with the current settings.\n *\n * ### Options:\n *\n\
    \ * - `precision` - Precision of the generated number.\n * - `thousands_separator`\
    \ - Thousands separator.\n * - `decimal_separator` - Decimal separator.\n * -\
    \ `force_decimals` - Whether to force decimals even if the decimal\n *   separator\
    \ is the comma (`,`).\n * - `add_leading_zeros` - Whether to add leading zeros\
    \ to the generated\n *   number.\n * - `add_trailing_zeros` - Whether to add trailing\
    \ zeros to the generated\n *   number.\n * - `strip_decimals` - Whether to strip\
    \ the decimals (`.`) and decimal\n *   separator (`,`) from the generated number.\n\
    \ * - `add_zeros` - Whether to add a `0` to the generated number if `0`\n *  \
    \ is inputted.\n * - `add_thousands_separator` - Whether to add a space to the\
    \ generated\n *   thousands separator.\n * - `add_spaces` - Whether to add a space\
    \ to the generated thousands\n *   separator.\n *\n * @param integer $length The\
    \ length of the generated number\n * @param array $options Options for the generated\
    \ number\n * @return string The generated number string\n */", "  return intval($number);\n\
    }\n</code>\nExample of use\n<code>\n$number = 4.5654;\n$truncatedNumber = truncate_number($number);\n\
    </code>\n<|/ a tags=php,numbers,truncate dscore=3 |>\n<| c |>\nThat should be\
    \ `intval($number)` instead of `floatval($number)`, right?\n<|/ c |>\n<| c |>\n\
    Thanks, I've corrected that.\n<|/ c |>\n<| c |>\n`floatval` is an alias of `intval`\n\
    <|/ c |>\n<| c |>\nAh, I see, but I thought it was more consistent with `intval`.\n\
    <|/ c |>\n<| c |>\nThe function is called truncate_number so I'm guessing it doesn't\
    \ really truncate, just discards the decimals? That's why you cast the argument\
    \ to a float before truncating it?\n<|/ c |>\n<| a dscore=3 |>\nYou could use\
    \ round() like so:\n<code>\n$num = round($num, 1);\n</code>\nor ceil():\n<code>\n\
    $num = ceil($num);\n</code>\n<|/ a tags=php,numbers,truncate |>\n<| c |>\nNo,\
    \ that's not what the OP wanted. He didn't say he wanted rounding. He wants truncation.\n\
    <|/ c |>\n<| c |>\nOkay fair enough. Didn't read it that way at all.\n<|/ c |>\n\
    <| a tags=php,numbers,truncate |>\nThe function you are looking for is called\
    \ floor() and ceil(). The difference between those functions is that ceil() will\
    \ always round up, and floor() will always round down.\n<|/ a dscore=3 |>\n<|\
    \ a tags=php,numbers,truncate |>\n<code>\n<?php\n\necho floor(0.99999); // 0\n\
    echo ceil(0.99999); // 1\n</code>\n<|/ a dscore=2 |>\n<| a |>\nIf you want to\
    \ truncate, you can use the floor() and ceil() functions:\n<code>\n<?php\n\necho\
    \ floor(0.99999); // 0\necho ceil(0.99999); // 1\n</code>\n<|/ a tags=php,numbers,truncate\
    \ dscore=2 |>\n<| a dscore=2 |>\nI assume you want to discard the decimal places.\n\
    <code>\necho floor(0.99999); // 0\necho ceil(0.99999); // 1\n</code>\n<|/ a tags=php,numbers,truncate\
    \ |>\n<| a tags=php,numbers,truncate |>\n<code>", "    $number = floor($number);\n\
    \    if ($number >= 1)\n        return $number;\n\n    $number = number_format($number,\
    \ 0, '', '');\n\n    if ($number[0] == '-') {\n        // Negative numbers take\
    \ the highest digit after the decimal point\n        $number = substr($number,\
    \ 1);\n    }\n\n    return $number;\n}\n", "  $decimal_part = floor($number);\n\
    \  $integer = floor($number - $decimal_part);\n  if ($integer < 0) {\n    return\
    \ $decimal_part + 1;\n  }\n  return $decimal_part;\n}\n", "    $number = intval($number);\n\
    \    return $number / pow(10, floor(log10($number)));\n}\n", "  // If the number\
    \ has a decimal, truncate it.\n  $parts = explode('.', $number);\n  if (count($parts)\
    \ > 1) {\n    return $parts[0];\n  }\n  // If the number has no decimals, return\
    \ it unchanged.\n  return $number;\n}\n", "  return ltrim($number, '0');\n}\n",
  "  // Return 0 if nothing to truncate.\n  if ($number == 0) {\n    return 0;\n \
    \ }\n  // Round down if it's too big.\n  if ($number > PHP_INT_MAX) {\n    return\
    \ PHP_INT_MAX;\n  }\n  // Do the math.\n  return (int) floor($number);\n}", "\t\
    $decimals = ($number - floor($number)) * 10;\n\treturn round($number, $decimals);\n\
    }\n", "    $decomp = explode('.', $number);\n    $decimals = $decomp[1];\n   \
    \ if ($decimals == null) {\n        return $decomp[0];\n    }\n    return $decomp[0];\n\
    }\n</code>\n<|/ a dscore=0 tags=php |>\n<| a tags=php |>\nHere is an example using\
    \ regex to truncate numbers with decimals to the nearest whole number with decimals.\n\
    <code>\n$string = '123,456,789';\n$string = '1,234,567.89';\n$string = '123,456,789.00';\n\
    \n$regex = '/([+-]?\\d+(?:[\\.,]\\d+)?)(\\.\\d+)?/';\n\nif(preg_match($regex,\
    \ $string, $matches)) {\n    $number = $matches[0];\n    \n    $intPart = (int)$number[0];\n\
    \    $decimals = $number[1];\n    \n    if($decimals) {\n        $decimalPart\
    \ = (int)$decimals[0];\n        $truncatedNumber = $intPart . '.' . ($decimalPart\
    \ - 1);\n    } else {\n        $truncatedNumber = $intPart;\n    }\n} else {\n\
    \    $truncatedNumber = $string;\n}\n\necho $truncatedNumber;\n</code>\n<|/ a\
    \ dscore=0 |>\n<| a tags=php |>\nHere is a function to truncate decimals.\n<code>",
  "  $dec = substr($number, strlen($number) - 1);\n  $int = strlen($dec) > 0 ? intval(substr($dec,\
    \ 0, strlen($dec) - 1)) : 0;\n  return $int + 0.5;\n}\n", "\t$n = log($number,\
    \ 10);\n\t$r = log($number, 10);\n\tif ($r > $n) {\n\t\t$f = floor($n / $r);\n\
    \t\treturn $f * pow(2, $r);\n\t}\n\treturn $number / pow(2, $n - $r);\n}\n", " \
    \ assert(is_numeric($number));\n\n  if ($number >= 1) {\n    $trunc_part = floor($number);\n\
    \  } else {\n    $trunc_part = ceil($number);\n  }\n\n  $dec = $number - $trunc_part;\n\
    \  if ($dec > 0) {\n    return $trunc_part;\n  } else {\n    return 0;\n  }\n\
    }\n", "    if ($number === 0) {\n        return 0;\n    }\n\n    return $number\
    \ < 0 ? ceil($number) : floor($number);\n}\n", "  $precision = (int) log10($number)\
    \ + 1;\n  $factor = 10 ** $precision;\n  return $number / $factor;\n}\n", "  \
    \  $parts = explode('.', $number);\n    return $parts[0] . '.' . ($parts[1] /\
    \ pow(10, strlen($parts[1]) - 1));\n}\n", "  $number = floatval($number);\n\n\
    \  if ($number < 0) {\n    $temp = -$number;\n    $number *= -1;\n    return $temp;\n\
    \  }\n\n  $remainder = fmod($number, 1);\n\n  if ($remainder == 0) {\n    return\
    \ $number;\n  }\n\n  return $number - $remainder;\n}\n", "  $precision = strlen(rtrim($number,\
    \ '0'));\n  $dec_part = rtrim($number, '.');\n\n  if ($dec_part !== '.') {\n \
    \   $dec_part = substr($dec_part, 0, $precision);\n  }\n\n  return $dec_part;\n\
    }\n", "    $parts = explode('.', $number);\n    $decimal_part = $parts[1];\n \
    \   $int_part = floor(array_shift($parts));\n    return $decimal_part . ($int_part\
    \ > 0 ? floor($int_part / 10) : '');\n}\n", "    if ($number < 1) {\n        return\
    \ 1;\n    }\n\n    $decimal_part = floor($number);\n    $int_part = (int) $number;\n\
    \n    if ($int_part > $decimal_part) {\n        return $decimal_part + 1;\n  \
    \  }\n\n    return $decimal_part;\n}\n", "  if ($number < 0) {\n    return 0.0;\n\
    \  }\n\n  $integer_part = (int) $number;\n  $decimal_part = $number - $integer_part;\n\
    \n  if ($decimal_part < 0) {\n    return 0.0;\n  }\n\n  return $decimal_part;\n\
    }\n\n/**\n * Return the current time with microseconds.\n *\n * @return string\n\
    \ */", "    $int_part = floor($number);\n    $decimal_part = substr($number, $int_part);\n\
    \    return $decimal_part;\n}\n", "  return floor($number * 10) / 10;\n}\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\nThis is correct. Also consider using [number_format](http://php.net/manual/en/function.number-format.php)\
    \ instead of sprintf to format your numbers.\n<|/ c |>\n<| a dscore=3 |>\nTry\
    \ this:\n<code>", "    if ($number < 0) {\n        $number = -$number;\n    }\n\
    \    return floor($number);\n}\n", "    if ($number >= 1) {\n        return intval(ceil($number));\n\
    \    }\n    $number = abs($number);\n    $decimals = intval(substr($number, strpos($number,\
    \ '.') + 1));\n    if ($decimals > 0) {\n        $number = substr($number, 0,\
    \ strpos($number, '.'));\n    }\n    return $number;\n}", "    // >>> truncate_number(3.5)\n\
    \    // 3.5\n    if ($number < 1.0) {\n        return $number;\n    }\n    if\
    \ ($number < 1.5) {\n        return floor($number);\n    }\n    if ($number <\
    \ 2.0) {\n        return ceil($number);\n    }\n    return round($number);\n}\n",
  "    if (is_null($number)) {\n        return null;\n    }\n\n    $precision = (int)\
    \ floor(log10($number));\n    $mantissa = bcdiv($number, pow(10, $precision),\
    \ 0);\n    if (bccomp($mantissa, 0) == 1) {\n        return $mantissa;\n    }\n\
    \    return null;\n}\n</code>\n<|/ a dscore=2 tags=php,rounding |>\n<| a dscore=1\
    \ |>\nIf all you want to do is rounding up and down, use the PHP function ceil()\
    \ and floor(). http://php.net/manual/en/function.floor.php\n<|/ a tags=php,rounding\
    \ |>\n<| c |>\nI need the decimal part too.\n<|/ c |>\n<| c |>\nThe decimal part\
    \ is always going to be greater than the integer part so they will be rounded\
    \ up or down no matter what. Are you trying to get it to round to the nearest\
    \ whole number? If so, I posted an answer.\n<|/ c |>\n<| a |>\nI needed to do\
    \ this, so I wrote this function that will round your number to the nearest whole\
    \ number.\n<code>\n/**\n * Round the number to the nearest whole number.\n *\n\
    \ * float $num\n * float\n */", "    $parts = explode(\".\", number_format($number));\n\
    \    return $parts[0];\n}\n", "\t$decimal_part = abs($number) % 1;\n\treturn floor($number)\
    \ > $decimal_part ? $decimal_part : ceil($number);\n}\n", "    if ($number >=\
    \ 1) {\n        return $number;\n    }\n\n    $sign = $number < 0 ? '-' : '';\n\
    \    $number = abs($number);\n\n    if ($number < 0.5) {\n        return $sign\
    \ * round($number, 1);\n    }\n\n    return $sign * round($number - 0.5, 2);\n\
    }\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis is an excellent contribution, but\
    \ unfortunately doesn't work correctly on negative numbers or floats that aren't\
    \ whole numbers.\n<|/ c |>\n<| c |>\nI guess it depends on what you are looking\
    \ for. If you want it to be able to handle negative numbers then you can just\
    \ remove the `if ($number < 0)` condition and replace it with `return $sign *\
    \ ($number > 0 ? round($number, 1) : round($number + 0.5, 2));`. That will give\
    \ `-0.1` to `0.000000000001` instead of `-0.1`\n<|/ c |>\n<| c |>\nJust found\
    \ that if you input 2.1, the result is 2.1, rather than 2.00. Which is correct,\
    \ as the last digit is being rounded. So perhaps do `round($number + 0.5, 2)`\
    \ rather than `round($number, 2)`\n<|/ c |>\n<| c |>\nAwesome! Works like a charm\n\
    <|/ c |>\n<| c |>\nHow can i use this for currency values?\n<|/ c |>\n<| a tags=php,rounding\
    \ |>\nThis should work:\n<code>\n$num = 1.246;\n$num .= str_repeat('0', -floor(log($num,\
    \ 10)));\n$num = sprintf('%f', $num);\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis\
    \ works, except for the case where $num is greater than or equal to 1, because\
    \ it will add `0` before the decimal point.\n<|/ c |>\n<| c |>\nWhy are you using\
    \ sprintf() when you don't need it?\n<|/ c |>\n<| c |>\nbecause `sprintf` returns\
    \ a string, so you can assign that string to a variable if you want\n<|/ c |>\n\
    <| c |>\n`sprintf` isn't just about formatting, it's also about returning a string\
    \ instead of a number.\n<|/ c |>\n<| c |>\nI don't think this works. The result\
    \ should be 2.00, but this returns 2.01\n<|/ c |>\n<| a tags=php,rounding |>\n\
    I found this question when searching for my own solution and I wanted to share\
    \ my solution, which is a modified version of Mark Baker's answer that allow",
  "  list($integer_part, $decimal_part) = explode('.', number_format($number, 2, 10));\n\
    \  return $decimal_part;\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis is a great\
    \ solution, but you might want to add an explanation of why you think it is better\
    \ than the original code\n<|/ c |>\n<| c |>\nThis answer is missing its educational\
    \ explanation.\n<|/ c |>\n<| c |>\nWhat happens if the number passed is `0`? The\
    \ function will just return `0`.\n<|/ c |>\n<| c |>\nThe original code will return\
    \ `0` for any input number that is `0`\n<|/ c |>\n<| c |>\nI see that, that's\
    \ why I mentioned it. :) But that's not why I posted the comment in my answer.\
    \ :)\n<|/ c |>\n<| a tags=rounding,php,math |>\nFor those who use PHP >= 5.3 you\
    \ can use round($value, 1) to round to 1 decimal place\n<|/ a dscore=5 |>\n<|\
    \ c |>\nThis answer should be marked as the correct one, it is the most correct\
    \ one so far (especially since it is mentioned in the comments by Craig Walker)\n\
    <|/ c |>\n<| c |>\nThis is actually a great answer. No need to write your own\
    \ code (although, it might be more efficient too!)\n<|/ c |>\n<| c |>\nI agree\
    \ with, this should be the accepted answer. Very clean and simple answer. No need\
    \ to write your own code.\n<|/ c |>\n<| c |>\nThis is great answer when your number\
    \ is in a variable\n<|/ c |>\n<| c |>\nThis is also very helpful if you are trying\
    \ to find what digit you are rounding to without actually having a number for\
    \ that digit.\n<|/ c |>\n<| a dscore=5 |>\nThe easiest way to round a number to\
    \ a number of decimal places is:\n<code>\n<?php\n$number = 15.5;\necho (float)\
    \ $number;\n</code>\n<|/ a tags=rounding,php,math |>\n<| c |>\nThis is best answer.\
    \ Simple and easy to use and doesn't require the round() function.\n<|/ c |>\n\
    <| c |>\nNice. Easy to remember and easy to understand. +1 from me\n<|/ c |>\n\
    <| c |>\nThis is the best solution\n<|/ c |>\n<| c |>\nThank you! This is exactly\
    \ what I was looking for.\n<|/ c |>\n<| c |>", "  $dec = floor($number);\n  return\
    \ ($dec == $number ? 0 : $dec);\n}\n", "  $parts = explode('.', (string) $number);\n\
    \  return array_pop($parts);\n}\n</code>\nAnd then, in the template:\n<code>\n\
    <?php\nif (isset($number)) {\n  $decimal = truncate_number($number);\n  echo 'Decimal\
    \ part: ' . $decimal;\n}", "  return round($number, -floor((strlen($number) -\
    \ strrpos($number, '.') + 1 + FP_EPSILON) / 2));\n}\n</code>\n<|/ a |>\n<| c |>\n\
    Just a minor suggestion: it might be useful to add that you can call `round()`\
    \ on the result of `truncate_number()` to return an integer (if that's what you\
    \ need).\n<|/ c |>\n<| c |>\n: Yes, that was what I meant by \"Return the decimal\
    \ part of the number.\" :)\n<|/ c |>\n<| a tags=php,math dscore=1 |>\nPHP has\
    \ a number_format function which does this:\n<code>\n$number = 12.34;\n$formatted\
    \ = number_format($number, 2, \",\", \".\");\necho $formatted;\n</code>\nWhich\
    \ would output\n<code>\n12.34\n</code>\nThe second argument is the number of decimal\
    \ places.  The third argument is a thousand seperator.  The fourth argument is\
    \ the decimal seperator.\n<|/ a |>\n<| c |>\nThanks for the tip! I like the 2nd\
    \ parameter :)\n<|/ c |>\n<| a dscore=1 |>\n<code>\n$number = 12.34;\n$formatted_number\
    \ = round($number * 100) / 100;\n$formatted_number = number_format($number, 2,\
    \ \",\", \".\");\necho $formatted_number;\n</code>\n<|/ a tags=php,math |>\n<|\
    \ a tags=php,math dscore=1 |>\n<code>", "  $integer = (int)$number;\n  $decimal\
    \ = (int)($number - $integer);\n  return $decimal < 1 ? $integer + $decimal :\
    \ $integer;\n}\n", "  $decPart = $number % 1;\n  $intPart = floor($number);\n\
    \  if ($decPart < 0) {\n    $decPart = 0;\n  }\n  return $decPart;\n}\n", "  \
    \  $parts = explode('.', $number);\n    $decimal_places = end($parts) - $number;\n\
    \n    // if there is no decimal, just round\n    if ($decimal_places <= 0) {\n\
    \        return round($number);\n    }\n\n    // truncate parts after the decimal\
    \ point\n    if ($decimal_places > 0) {\n        $parts = explode('.', substr($number,\
    \ 0, $decimal_places));\n        $new_parts = [];\n        foreach ($parts as\
    \ $part) {\n            $new_parts[] = round($part);\n        }\n        $new_number\
    \ = '.' . implode('.', $new_parts);\n    } else {\n        $new_number = round($number);\n\
    \    }\n\n    return $new_number;\n}\n", "    $decPart = floor($number);\n   \
    \ $intPart = $number - $decPart;\n    return $decPart + ($intPart > 0.05 ? round($intPart\
    \ * 100) : round($intPart * 10));\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis\
    \ should be the top answer! Thanks so much!\n<|/ c |>\n<| c |>\nA simple function\
    \ with no dependency is far superior to such a complex function with dependencies,\
    \ especially if you're dealing with lots of numbers.\n<|/ c |>\n<| c |>\nThe best\
    \ solution for any number, not just positive ones. Works with any number no matter\
    \ what. For instance, `truncate_number(1.1)` gives `1` while `truncate_number(2.5)`\
    \ gives `2`.\n<|/ c |>\n<| c |>\nNice solution. Just as a note: this won't work\
    \ for negative numbers; so be careful.\n<|/ c |>\n<| c |>\nI added an answer for\
    \ negative numbers, too.\n<|/ c |>\n<| a |>\nI wrote a simple function to truncate\
    \ floating point numbers. It has the following benefits:\n\nIt always rounds the\
    \ number to nearest integer.\nIt doesn't require any additional PHP extensions\
    \ or anything.\n\nIt looks like this:\n<code>", "    if ($number < 1.0)\n    \
    \    return 1.0;\n    if ($number >= 1000000.0)\n        return ceil($number);\n\
    \    $parts = explode('.', $number);\n    if (count($parts) == 1) {\n        //\
    \ no decimals\n        return $parts[0];\n    }\n    return ($parts[1] * 100 +\
    \ $parts[0]) / 1000000;\n}\n</code>\n<|/ a dscore=0 tags=php,mysql |>\n<| c |>\n\
    This solution is perfect for my needs.\n<|/ c |>\n<| a tags=php,mysql |>\n<code>\n\
    <?php", "  $result = $number;\n  if (!is_float($result) && $result !== '') {\n\
    \    $result = intval($result);\n  }\n  if ($result > 1) {\n    $result = $result\
    \ - 1;\n  }\n  return $result;\n}\n", "    $sign = $number < 0 ? -1 : 1;\n   \
    \ $number = abs($number);\n    $decimals = 1;\n    while (abs($number) > 1 &&\
    \ $number >= 0.1) {\n        $decimals++;\n        $number *= 10;\n    }\n   \
    \ return round($number, $decimals, PHP_ROUND_HALF_UP) * $sign;\n}\n", "  $factors\
    \ = array_map(function ($x) {\n    return intval($x / 1); // truncate decimals\n\
    \  }, preg_split('/(?=[0-9])/', (string) $number)); // get factors\n  return sprintf('%f',\
    \ array_sum($factors)); // return factors\n}\n", "  return round($number);\n}\n",
  "    return $number <= 0 ? 0 : $number >= 1 ?\n        $number : (integer)fmod($number\
    \ * 100, 1);\n}\n", "  // $number must be positive.\n  $decimals = preg_replace('/\\\
    ./', '', substr($number, -1));\n  return round($number, 0, $decimals);\n}\n</code>\n\
    <|/ a dscore=4 tags=php,rounding,precision,math |>\n<| c |>\nJust a side note\
    \ for future readers: this solution only works with integer numbers (i.e. any\
    \ number without decimals). For example with 2.5, it will give you 2, not 2.5.\
    \ You may add floor() or ceil() to make it work correctly.\n<|/ c |>\n<| a tags=php,rounding,precision,math\
    \ dscore=4 |>\nI found this solution to be quite straightforward and doesn't require\
    \ any conditionals:\n<code>", "  if (!isset($number) || $number == 0) {\n    return\
    \ 0;\n  }\n  if ($number < 0) {\n    return -truncate_number(abs($number));\n\
    \  }\n  // @codingStandardsIgnoreStart\n  $remainder = abs($number) - intval($number);\n\
    \  // @codingStandardsIgnoreEnd\n  return intval($number) - $remainder;\n}\n\n\
    /**\n * Returns true if the string is valid hex.\n *\n * @return bool\n */", " \
    \ return floor($number * 100000000) / 100000000;\n}\n", "\t$decimals = strlen(str_replace('.',\
    \ '', $number)) - strlen(rtrim($number, '0'));\n\t$integer = floor($number);\n\
    \treturn ($decimal === 0 || $decimal > $decimals) ? $integer : round($number,\
    \ $decimal);\n}", "    $digit = (int) $number;\n    $factor = 1; // initial factor\n\
    \    $truncated = 0; // initial truncated\n    do {\n        $truncated = $digit\
    \ - intval($digit/$factor);\n        $factor *= 10;\n    } while ($truncated >\
    \ 0);\n    return $truncated * $factor;\n}\n</code>\nAnd here's the complete PHP\
    \ code\n<code>\n<?php\ndefine('MAX_RECENT_RECORD_COUNT', 10); // max no. of recent\
    \ records to store in cache\ndefine('MAX_CACHE_TTL', 2592000); // cache TTL in\
    \ seconds\ndefine('CACHE_PREFIX', 'cache'); // cache prefix to identify records\
    \ in cache\ndefine('CACHE_SUFFIX', md5('records')); // cache suffix to identify\
    \ records in cache\ndefine('CACHE_TTL_KEY', 'ttl'); // cache key for TTL value\n",
  "\t$length = strlen($number);\n\t$decimals = $length - strrpos($number, '.');\n\t\
    if ($decimals > 0) {\n\t\t$number = substr($number, 0, $decimals);\n\t}\n\treturn\
    \ $number;\n}\n", "    if ($number < 0) {\n        return -truncate_number(-$number);\n\
    \    }\n    if ($number == 0) {\n        return 0;\n    }\n    return intval($number);\n\
    }\n\n/**\n * Get string length of an input.\n *\n * @param string $str\n * @return\
    \ integer\n */", "    $number = floor($number);\n    $decimal = (int) $number\
    \ - $number;\n    return $decimal > 0 ? $number : $number - 1;\n}\n</code>\n<|/\
    \ a dscore=0 |>\n<| c |>\nI used the code you provided to come up with this code\
    \ http://pastebin.com/8uZjW5XZ.  It doesn't quite work as intended though, it\
    \ returns \"0.\" when it should return \"0.5\" with the decimal.  I added the\
    \ decimal part to the code you provided, but that still doesn't work.  I think\
    \ it's because of the round() function, but I don't know how to fix it.  Can you\
    \ help?\n<|/ c |>\n<| c |>\n- You can't just add something to the code I provided,\
    \ because I'm already saying that I added that code to the code I posted.\n<|/\
    \ c |>\n<| c |>\nI see.  Sorry about that.  I appreciate the help though.\n<|/\
    \ c |>\n<| c |>\n- No problem, I'm glad it helped.\n<|/ c |>\n<| a dscore=0 |>\n\
    The code posted by Toulouse is correct, I just want to explain what's wrong with\
    \ your code.\nThe problem you are facing is that you are calculating a decimal\
    \ number and then round it. The result is the same for integers and floats because\
    \ both truncate it and round it. That's why you get the same output for both of\
    \ them.\nFor example :\n<code>\n$integer = 3.5;\n$decimal = truncate_number($integer);\n\
    echo $decimal;\n</code>\nWill output 0.5, because truncate and round give the\
    \ same result.\nThe solution is to truncate and round the integer part only:\n\
    <code>\n$integer = 3.5;\n$decimal = ceil(($integer - floor($integer)) / 1);\n\
    echo $decimal;\n</code>\nAnd you will get 3 as output. The $integer - floor($integer)\
    \ part will give 3 in this case, since 3.5 rounds to 3.\n<|/ a tags=decimal,php,floor,rounding\
    \ |>\n<| c |>\nThanks for your help everyone.  I posted my final code in the original\
    \ post.  Thanks again!\n<|/ c |>\n<| c |>\nYou're welcome, please don't forget\
    \ to mark the answer that helped you the most as accepted.\n<|/ c |>\n<| a dscore=0\
    \ tags=decimal,php,floor,rounding |>\nThe most correct way would be to convert\
    \ your decimal number into an integer and do your math on that:\n<code>\n$integer\
    \ = (int)$", "    return ($number < 0) ? ceil($number * 1000) / 1000 : floor($number\
    \ * 1000) / 1000;\n}", "  return ceil($number - (int)($number * 1e5)) / 1e5;\n\
    }\n</code>\nThis assumes you do not need to use floating point numbers for your\
    \ calculations and also that your numbers have the precision to hold the largest\
    \ integer (which can happen sometimes for very large numbers).\n<|/ a dscore=3\
    \ tags=truncate,php,precision,integer |>\n<| a |>\nTry this, it works:\n<code>\n\
    $number = floor(number_format(number_format($number, 6, '.', '')) / 1e6);\n</code>\n\
    <|/ a dscore=3 tags=truncate,php,precision,integer |>\n<| a dscore=3 |>\n<code>\n\
    $number = intval($number / 1e6);\n</code>\n<|/ a tags=truncate,php,precision,integer\
    \ |>\n<| c |>\nI think this is what he wants (truncate to 6 decimal places)\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>\n<?php", "    $decimals = preg_replace('/[^.0-9]/',\
    \ '', $number);\n    return round($number) - intval($decimals);\n}", "  $integer\
    \ = floor(abs($number));\n  $decimals = abs($number - $integer);\n\n  return $decimal\
    \ < 1 ? floor($integer) : ceil($integer);\n}\n", "  // Make sure we never round\
    \ up.\n  $number = max(floor($number), 0);\n\n  if ($number == 0.) {\n    return\
    \ 0.;\n  }\n\n  if ($number > 1) {\n    $result = $number - (floor($number));\n\
    \  } else {\n    $result = $number;\n  }\n\n  return $result;\n}\n", "    return\
    \ round($number, 0);\n}", "    // TODO: Improve this function\n    $int_part =\
    \ floor(abs($number));\n    $dec_part = abs($number - $int_part);\n    $dec_part_len\
    \ = strlen($dec_part);\n    $result = str_pad($dec_part_len, strlen($dec_part)\
    \ + 1, \"0\", STR_PAD_RIGHT);\n    return $result . $int_part;\n}\n", "    if\
    \ ($number < 1) {\n        return 0;\n    }\n\n    $parts = explode('.', (string)\
    \ $number);\n    $decimals = array_pop($parts);\n    $decomposed = array_pop($parts);\n\
    \n    return intval($decimals) . '.' . substr($decomposed, 0, 1);\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThanks for your answer. I would like to know how I\
    \ can use that method in my code and how i can check whether a float has decimal\
    \ part or not ?\n<|/ c |>\n<| c |>\nyou can simply do: `$num = truncate_number($num);`\
    \ then check the result with is_nan($num) or is_finite($num)\n<|/ c |>\n<| c |>\n\
    `is_nan($num)` will be false if `$num` is a string, so the above code won't work.\n\
    <|/ c |>\n<| a tags=floating-point,php,string |>\nFor those looking for a way\
    \ to check whether a float has a decimal part or not:\n<code>\n$num = floatval(\"\
    1.0\"); // 1\n\nif (strpos($num, '.') !== false) {\n    // has a decimal\n} else\
    \ {\n    // does not\n}\n</code>\nThis doesn't work for strings containing non-numeric\
    \ characters (such as letters) though.\n<|/ a dscore=2 |>\n<| c |>\nThis only\
    \ works as long as there's at least one decimal. If you're doing this in some\
    \ kind of loop or something and `$num` is something like `1.05`, then it will\
    \ return true. Also, this won't work for some floating point numbers in PHP like\
    \ `0.00000005`.\n<|/ c |>\n<| a tags=floating-point,php,string |>\nMy solution\
    \ is to check if the string doesn't start with a dot (.) and then check if a decimal\
    \ is found:\n<code>\nif (substr($value, 0, 1) != '.' && !strpos($value, '.'))\
    \ {\n    // doesn't contain a decimal number\n} else {\n    // contains a decimal\
    \ number\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis works for strings like\
    \ \"0.10\", but will fail for \"10.\"\n<|/ c |>\n<| a tags=floating-point,php,string\
    \ |>\nI haven't tested it, but you might want to use a regex:\n<code>\npreg_match('/(\\\
    d+\\.\\d+)/', $str, $match);\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nI\
    \ find it useful to convert a string to a float, then compare it to a float, rather\
    \ than the string directly. \n<code>\n$val = '10';\n$testVal", "  $decimals =\
    \ ($number - intval($number)) * pow(10, floor((strlen($number) - 1) - strpos($number,\
    \ '.')));\n  return intval($number) + $decimals;\n}\n", "    return floor($number);\n\
    }", "    $precision = strlen($number) - strpos($number, '.');\n    if ($precision\
    \ < 0)\n        $precision = 0;\n    return substr($number, strpos($number, '.')\
    \ + 1, $precision);\n}\n", "    $precision = pow(10, floor(log10($number)));\n\
    \    return round($number / $precision) * $precision;\n}\n", "    if ($number\
    \ > 1) {\n        $parts = explode('.', ltrim($number, '0'));\n        $decimal_part\
    \ = array_pop($parts);\n        if (count($parts) > 0) {\n            $decimal_part\
    \ = round($decimal_part, count($parts) - 1);\n        }\n        $number = $decimal_part;\n\
    \    }\n    return $number;\n}\n</code>\n<|/ a dscore=2 tags=php,number-formatting,currency\
    \ |>\n<| a |>\n<code>", "\tif ($number < 1.0) {\n\t\treturn 0.0;\n\t}\n\tif ($number\
    \ < 10) {\n\t\treturn $number;\n\t}\n\tif ($number % 10 == 0) {\n\t\treturn $number;\n\
    \t}\n\tif ($number % 10 == 1) {\n\t\treturn $number + 0.1;\n\t}\n\treturn $number\
    \ + 0.1;\n}\n", "  $rounded_number = round($number, 0);\n  return $number <= 0\
    \ ? floor($rounded_number) : ceil($rounded_number);\n}", "    $result = $number\
    \ - intval($number);\n    if ($result < 0) {\n        $result += 1;\n    }\n \
    \   return $result;\n}\n", "    $precision = strlen($number) - strrpos(strval($number),\
    \ '1');\n    return floor($number * pow(10, $precision)) / (pow(10, $precision));\n\
    }\n", "    $parts = explode('.', $number);\n    if ($parts[1] == 0) {\n      \
    \  $parts[1] = 1.0;\n    }\n    return $parts[0] . '.' . $parts[1];\n}\n", " \
    \   if ($number < 0) {\n        return floor($number);\n    }\n\n    if ($number\
    \ >= 1) {\n        return ceil($number);\n    }\n\n    return $number;\n}\n",
  "  $result = '';\n  if ($number > 1) {\n    $result = sprintf('%.0f', $number);\n\
    \  }\n  $index = strlen($result);\n  for ($i = 0; $i < strlen($number); $i++)\
    \ {\n    if ($number[$i] != '0') {\n      $result .= '.';\n    }\n    if ($i <\
    \ strlen($number) - 1) {\n      if ($number[$i] == ',') {\n        $result .=\
    \ '.';\n      }\n    }\n  }\n  return substr($result, 0, $index);\n}\n", "   \
    \ if ($number == 0.) {\n        return 0.;\n    }\n\n    $decimal_part = bcmod($number,\
    \ '1');\n    if ($decimal_part == 0.) {\n        $integer_part = 0.;\n    } else\
    \ {\n        $integer_part = floor($number);\n    }\n\n    if ($number < 1) {\n\
    \        $integer_part += 0.;\n    }\n\n    return $integer_part . '.' . str_repeat('0',\
    \ strlen($decimal_part - 1)) . $decimal_part;\n}\n</code>\nNote that this does\
    \ not give any rounding behavior. E.g. truncate_number(3.5) returns 3.5 instead\
    \ of 3.51.\n<|/ a dscore=2 |>\n<| c |>\nThe last line of the function should be:\
    \ `return $integer_part . '.' . str_pad('', strlen($decimal_part - 1), '0') .\
    \ $decimal_part;`\n<|/ c |>\n<| a tags=truncate,floating-point,php |>\nI got this\
    \ to work by first taking the integer part of the number and then appending zeros\
    \ to the decimal part using str_pad().\n<code>\n<?php\n$number = 3.5;\n$i = floor($number);\n\
    $iStr = (string) $i;\n$d = substr($number, strlen($iStr));\n$dStr = (string) $d;\n\
    $dStr = str_pad($dStr, strlen($dStr), '0', STR_PAD_LEFT);\necho $iStr . '.' .\
    \ $dStr;\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nHere is a one-liner solution\
    \ using substr and str_pad:\n<code>\n$i = floor($number);\n$d = substr($number,\
    \ strlen($i));\necho str_pad($d, strlen($d), '0', STR_PAD_LEFT);\n</code>\n<|/\
    \ a tags=truncate,floating-point,php |>\n<| a dscore=1 tags=truncate,floating-point,php\
    \ |>\nThis was asked and answered here.\nIt uses bcmath and is easily modifiable\
    \ to include negatives (negative numbers have a leading minus sign)\n<code>",
  "  $parts = explode('.', $number);\n  return array_shift($parts) > 0 ? array_shift($parts)\
    \ : 0;\n}\n", "    if (abs($number) <= 1) {\n        return 0.0;\n    }\n    return\
    \ ceil($number);\n}\n</code>\n<|/ a dscore=1 tags=php,php-5.5 |>\n<| a dscore=1\
    \ |>\nThe simplest way i found to do this was to explode the number and just subtract\
    \ the decimal part from the whole part and put them together as a string.\n<code>\n\
    $result = round($number*pow(10, strlen($number) - 1 - strpos($number, '.')));\n\
    </code>\n<|/ a tags=php,php-5.5 |>\n<| c |>\nYou don't need to `round()` $result,\
    \ because it already has fractional part - use only `$number*pow(10, strlen($number)\
    \ - 1 - strpos($number, '.'))`\n<|/ c |>\n<| c |>\nThe accepted answer has more\
    \ problems than this.  You should use the accepted answer when you have no idea\
    \ what the input number will be.  And use my answer when you need to convert anything.\n\
    <|/ c |>\n<| a tags=php,php-5.5 dscore=1 |>\nHere's an answer that does not use\
    \ strpos(). Works with floating point numbers as well.\n<code>", "    if ($number\
    \ == 0.0) {\n        return 0.0;\n    }\n    $sign = $number < 0.0 ? -1 : 1;\n\
    \    $absNumber = $sign * $number;\n    $result = floor($absNumber);\n    $decimals\
    \ = $absNumber - $result;\n    return $sign * ($result + ($decimals == 0.5 ? 0.0\
    \ : ceil(abs($decimals) / 2.0)));\n}\n</code>\n<|/ a tags=php,math |>\n<| c |>\n\
    Can you provide more information on the logic behind this?\n<|/ c |>\n<| a tags=php,math\
    \ |>\n<code>\n$a = '73.88';\n$b = '52.33';\n$c = '95.50';\n\n$a = str_replace(',',\
    \ '.', $a);\n$b = str_replace(',', '.', $b);\n$c = str_replace(',', '.', $c);\n\
    \n$total = $a * $b;\n$total = $total + $total * $c;\n$total = str_replace('.',\
    \ '', $total);\n\n$total = floatval($total);\n$total = ($total / 100);\n$total\
    \ = floor($total);\n$total = ceil($total);\n$total = str_pad($total, 2, '0', STR_PAD_LEFT);\n\
    \necho $total;\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\n<code>\n$a = '73.88';\n\
    $b = '52.33';\n$c = '95.50';\n\n$a = (float)str_replace(',','.',$a);\n$b = (float)str_replace(',','.',$b);\n\
    $c = (float)str_replace(',','.',$c);\n\n$total = $a * $b;\n$total = $total + $total\
    \ * $c;\n\n$total = ($total/100) * 100;\n$total = (int)$total;\n$total = ($total\
    \ > 100) ? 100 : $total;\n\necho 'Total:' . $total;\n</code>\n<|/ a tags=php,math\
    \ |>\n<| c |>\nHi please add some explanation\n<|/ c |>\n<| c |>\n$a = '73.88';\
    \ $b = str_replace(',','.','52.33'); $c = str_replace(',','.','95.50'); echo $total\
    \ = $a * $b; echo $total = $total + $total * $c; $total = ($total/100) * 100;\
    \ $total = (int)$total; $total = ($total > 100) ? 100 : $total; echo 'Total:'\
    \ . $total", "    $decimals = $number - intval($number);\n    return $decimals\
    \ <= 0 ? 0 : $decimals;\n}\n</code>\n<|/ a tags=php,decimal |>\n<| a |>\nTry this:\n\
    <code>", "  if (!isset($number)) {\n    return 0;\n  }\n\n  $decimals = pow(10,\
    \ floor(log10(abs($number))));\n  return $number < 0 ? ceil($number * $decimals)\
    \ : floor($number * $decimals);\n}\n\n/**\n * A helper function that parses a\
    \ version number as returned by a CDN.\n * Returns an associative array containing\
    \ any found components,\n * and the major version number found as a string of\
    \ the form 1.x.\n *\n * Given the version '1.5.1', the return value would be array('major'\
    \ => 1,\n * 'minor' => 5, 'patch' => 1)\n *\n * If there are no version components,\
    \ the return value will be empty.\n *\n * Given the version '1.0', the return\
    \ value would be array('major' => 1,\n * 'minor' => 0, 'patch' => 0)\n *\n * @param\
    \ string $version\n *   The version number to parse.\n *\n * @return array\n *\
    \   An associative array containing the parsed version number,\n *   and the major\
    \ version number as strings.\n *\n * @see normalize_version()\n */", "    if ($number\
    \ < 1.0)\n        return $number;\n    if ($number == floor($number))\n      \
    \  return truncate_number(floor($number));\n\n    $remainder = $number % 1;\n\
    \    return $remainder ? truncate_number($number) + $remainder : truncate_number($number);\n\
    }", "\t$factor = 1000;\n\t$decimals = -1;\n\t$int_part = 0.5;\n\n\t// Truncate\
    \ the number first to get the integer part.\n\tif ($number >= 1 && $number < $factor)\
    \ {\n\t\t$int_part = floor($number);\n\t}\n\t// Get the decimal part by finding\
    \ the nearest smaller value.\n\twhile ($number >= $factor) {\n\t\t$factor *= $factor;\n\
    \t\tif ($factor * 10 > $decimals) {\n\t\t\t$decimals = $factor * 10;\n\t\t}\n\t\
    }\n\n\t// Return the result.\n\treturn $decimals <= 0 ? $int_part : $int_part\
    \ . '.' . str_repeat('0', $decimals);\n}\n", "    $intPart = floor($number);\n\
    \    $decimals = abs($number - $intPart);\n    $decimals = max(1, $decimals);\n\
    \    return $intPart . $decimals;\n}\n</code>\n<|/ a tags=php,rounding |>\n<|\
    \ c |>\nThis assumes that floats are represented exactly; this probably isn't\
    \ the case. It's a very simple function, though, and probably sufficient.\n<|/\
    \ c |>\n<| c |>\nThat's true but this was the best I could find when searching\
    \ for a rounding function that worked with floats.\n<|/ c |>\n<| c |>\nThis also\
    \ fails for $number = 0.11. Should return 1 because 0.10 is closer to 1 than 0.11.\
    \ but returns 2 because 0.11 will round down to 1.\n<|/ c |>\n<| c |>\nThanks\
    \ for the heads up.  I've updated my answer to account for this possibility.\n\
    <|/ c |>\n<| c |>\nThis is awesome. No need to use any libraries just for this!\n\
    <|/ c |>\n<| a |>\nHow about a solution with intval() and decbin()?\n<code>",
  "    $decimal = substr($number, strrpos($number, '.') + 1);\n    return floor($number)\
    \ - $decimal;\n}\n\n/**\n * Formats a number with commas and rounds the result\
    \ to a given precision\n * and returns a float for PHP 5.2 and earlier\n *\n *\
    \ @param float $number\n * @param int $precision\n * @return float\n */", "\t\
    return round($number, 1);\n}\n\n/**\n * Convert a string to lowercase.\n * If\
    \ argument is an empty string, return an empty string.\n *\n * @param string $str\
    \ String to convert.\n * @return string\n */", "    $parts = explode('.', $number);\n\
    \    $decimals = isset($parts[1]) ? $parts[1] : 0;\n\n    return floor($number\
    \ * 10 / 10) + $decimals;\n}\n", "  $parts = get_integer_part($number);\n  return\
    \ $parts['integer'] + $parts['decimals'];\n}\n</code>\n<|/ a dscore=0 |>\n<| c\
    \ |>\nIt's a very good idea, but it's not working for negative numbers. Try it:\
    \ `truncate_number(-0.5)` it returns `0`.\n<|/ c |>\n<| a tags=php,rounding,floating-point,math\
    \ |>\nHere's a solution that works with the negatives too, although it does not\
    \ handle the edge cases where there aren't enough digits to hold the value as\
    \ a floating point number.\n<code>\n<?php\n\n$number = 1.2;\n\n$precision = 2;\n\
    \n$stringNumber = number_format($number, $precision, '.', '');\n\n$numberAsString\
    \ = str_replace('.', '', $stringNumber);\n\n$numberAsString = substr($numberAsString,\
    \ 0, strlen($numberAsString) - $precision);\n\n$stringNumberAsDecimal = substr($numberAsString,\
    \ 0, strlen($numberAsString) - $precision);\n\n$numberAsString = substr($numberAsString,\
    \ strlen($numberAsString) - $precision);\n\n$integerPart = $numberAsString;\n\n\
    $decimalPart = substr($stringNumberAsDecimal, 0, -1);\n\n$result = ($integerPart\
    \ + $decimalPart) / pow(10, $precision);\n\necho $result;\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\nHere is some simple math and string manipulation that\
    \ does what you need.  This is PHP 5.6 code.\n<code>\n<?php\n\n$num = 1.2;\n$precision\
    \ = 2;\n\n$num = sprintf('%0.'.$precision.'f', $num);\n$num = preg_replace('/0*$/',\
    \ '', $num); // strip trailing zeroes\n$num = sprintf('%0.'.$precision.'f', $num);\n\
    $num = str_pad($num, 8, '0', STR_PAD_LEFT);\n\n$parts = explode('.', $num);\n\n\
    $intPart = (string) $parts[0];\n$decimalPart = (string) $parts[1];\n\necho floor((float)\
    \ $intPart) * pow(10, $precision) + floatval($decimalPart);\n</code>\n<|/ a tags=php,rounding,floating-point,math\
    \ |>\n<| a tags=php,rounding,floating-point,math |>\n<code>\n$num1 = 1.2;\n$num2\
    \ = 1.23;\n$num3 = 1.2345;\n$num4 = 0.2;\n\nvar_dump(number_format($num1, 2) ==\
    \ '1.20'); // true\nvar_dump(number_format($num2, 2) == '1.23');", "  if ($number\
    \ < 1) {\n    return 0.0;\n  }\n\n  $exponent = floor(log10($number));\n  $significand_digits\
    \ = strlen($number) - $exponent;\n\n  // In case rounding causes a significant\
    \ digit, the number is not\n  // actually infinite, and we are rounding up.\n\
    \  if ($exponent == 0 &&\n      strpos($number, '.') !== false &&\n      ($significand_digits\
    \ + 1) < $significand_digits_max) {\n    $significand_digits_max -= 1;\n  }\n\n\
    \  return round($number, $significand_digits) /\n         pow(10, $exponent);\n\
    }\n", "  $n = floor($number);\n  $m = $number - $n;\n  return $m > 0 ? floor($m)\
    \ : 0.0;\n}", "  $negated = $number < 0;\n  if ($negated) {\n    $number = -$number;\n\
    \  }\n  $integerPart = floor($number);\n  $decimalPart = ($number - $integerPart)\
    \ * pow(10, $integerPart ? -$integerPart : 0);\n  return $negated ? -$decimalPart\
    \ : $decimalPart;\n}", "  return ceil($number);\n}\n", "  if (!is_numeric($number))\
    \ {\n    return $number;\n  }\n  $decimal_part = (float) substr($number, strlen($number)\
    \ - 1);\n  $number      = floatval($number);\n\n  $truncated_number = floor($number);\n\
    \  if ($number - $truncated_number > 0.9999999999999998) {\n    // Round down\n\
    \    return $truncated_number;\n  }\n\n  if ($number - $truncated_number < -0.9999999999999998)\
    \ {\n    // Round up\n    return $truncated_number + 1;\n  }\n\n  if ($number\
    \ - $truncated_number > -0.00000001 && $number - $truncated_number < -0.000000010000000005)\
    \ {\n    // Round down\n    return $truncated_number;\n  }\n\n  if ($number -\
    \ $truncated_number < 0.000000010000000005) {\n    // Round up\n    return $truncated_number\
    \ + 0.1;\n  }\n\n  return $truncated_number + 0.00000001;\n}\n", "    $result\
    \ = 0.0;\n    $integer = $number % 1;\n    if ($integer > 0) {\n        $result\
    \ += $integer;\n    }\n    if (abs($number) > 1) {\n        $integer++;\n    \
    \    $result += $integer / abs($integer);\n    }\n    return $result;\n}\n</code>\n\
    <|/ a dscore=1 tags=php,math,floating-point,ceil,truncate |>\n<| a |>\nOne solution\
    \ is to cast the number to a string then trim off any trailing decimals:\n<code>\n\
    $num = 5;\nvar_dump(strval($num));\nvar_dump(substr(strval($num),0,-1));\n</code>\n\
    <|/ a tags=php,math,floating-point,ceil,truncate dscore=1 |>\n<| a tags=php,math,floating-point,ceil,truncate\
    \ |>\nI've had the same question before, just as I needed to round the value to\
    \ 2 decimals. I ended up implementing my own ceil function as I didn't want to\
    \ be dependent on a library.\n<code>\n/**\n * ceil rounds up any float value to\
    \ the nearest whole number\n *\n * float $value the value you wish to ceil\n *\
    \ float $precision the number of decimal places you want the number to have\n\
    \ * float $precision the number of decimal places you want the number to have\n\
    \ */", "  // Strip trailing zeros\n  $number = rtrim($number, '0');\n  // Split\
    \ number into integer and decimal parts\n  $decimals = strlen($number) - strrpos($number,\
    \ '.');\n  $decimals = $decimals == 0 ? 0 : $decimals;\n  $integer = substr($number,\
    \ 0, strrpos($number, '.'));\n  return $decimals == 0 ? $integer : $integer .\
    \ '.' . str_repeat('0', $decimals);\n}\n", "  $result = floor($number);\n  $decimals\
    \ = abs($number - $result) * 10;\n\n  if ($number == $result) {\n    // We don't\
    \ have decimals.\n    return $result;\n  }\n\n  if ($decimals < 0) {\n    // We\
    \ have decimals.\n    return $result + 0.0;\n  }\n\n  return $result;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=php,regex dscore=1 |>\nA small addition to kumars\
    \ answer. \nWith kumars code I get the following result: \n<code>\n$text = 'I\
    \ love the new #1 #2 #3 #4 #5 #6 #7';\n</code>\nWith Kumars code you get this\
    \ result: \n<code>\n$text = 'I love the new #1 #2 #3 #4 #5 #6 #7';\n\n$pattern\
    \ = '#(#[0-9]+)#';\n\n$replacement = '';\n\necho preg_replace($pattern, $replacement,\
    \ $text);\n", "  return round($number, 2);\n}\n", "  $negative = $number < 0 ?\
    \ true : false;\n  $whole_part = floor($number);\n  $decimal_part = abs($number\
    \ - $whole_part);\n  if ($decimal_part == 0.0) {\n    return 0.0;\n  }\n  return\
    \ $negative ? -$decimal_part : $decimal_part;\n}\n", "    if ($number > 0) {\n\
    \        return floor($number);\n    } else {\n        return ceil($number);\n\
    \    }\n}\n", "    if ($number >= 1)\n        return $number;\n\n    $x = ltrim($number,\
    \ '0');\n    $decimals = strlen($x);\n    return ($decimals == 1) ? $number :\
    \ 0.$x;\n}\n", "  $fraction = intval(1 - ($number * pow(10, floor(log10($number)\
    \ + 1)));\n  return number_format($number, $fraction, '.', '');\n}", "  $negative\
    \ = $number < 0;\n  if ($negative) {\n    $number = -$number;\n  }\n\n  list($integer,\
    \ $decimal) = explode('.', strval($number), 2);\n\n  return $negative ? -$decimal\
    \ : $decimal;\n}\n", "  if ($number < 0.1) {\n    return round($number, 1);\n\
    \  }\n  return round($number, 0);\n}\n", "\tif ($number < 0) {\n\t\treturn 0;\n\
    \t}\n\t$fractional = (int) ($number % 1);\n\treturn $number - $fractional;\n}\n",
  "    $decimals = ($number - intval($number));\n    return intval($number) == $number\
    \ ? $decimals : $decimals - 1;\n}\n", "    return $number - intval($number);\n\
    }\n"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
