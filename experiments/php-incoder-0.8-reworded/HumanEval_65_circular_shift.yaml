name: HumanEval_65_circular_shift
language: php
prompt: "<?php\n// Circular shift the digits of the integer x, shift the digits right\
  \ by shift\n// and return the result as a string.\n// If shift > number of digits,\
  \ return digits reversed.\n// >>> circular_shift(12, 1)\n// \"21\"\n// >>> circular_shift(12,\
  \ 2)\n// \"12\"\nfunction circular_shift($x, $shift) {\n"
tests: "function candidate(...$args) {\n    return circular_shift(...$args);\n}\n\n\
  function test(): void {\n    if (candidate(100, 2) !== \"001\") { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(12, 2) !== \"12\") { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(97, 8) !== \"79\") { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(12, 1) !== \"21\") { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(11, 101) !== \"11\") { throw new Exception(\"\
  Test failed!\"); }\n}\n\ntest();"
completions: ["    if (!$shift) {\n        return $x;\n    }\n\n    $n = strlen($x);\n\
    \    if ($n < $shift) {\n        // $shift > $n\n        return substr($x, $n)\
    \ . circular_shift($x, $shift - $n);\n    }\n\n    return substr($x, 0, $shift)\
    \ . substr($x, $shift - $n, $n);\n}\n", "  $sign = ($x < 0) ? -1 : 1; // PHP 5.3\
    \ complains about an undefined constant\n  $digits = strlen(ltrim($x, \"0\"));\n\
    \  if((int)$shift > $digits) return $sign . $x;\n  else {\n    $ndigits = strlen(ltrim($x,\
    \ \"0\"));\n    $rdigits = strlen(ltrim(str_repeat('0', $shift - $ndigits), \"\
    0\"));\n    return $sign . $rdigits . $x;\n  }\n}", "    $digits = str_split($x,\
    \ strlen($x));\n    $digits_reversed = array_reverse($digits);\n    return implode('',\
    \ array_slice($digits_reversed, 0, $shift));\n}\n", "    $result = '';\n    $shift\
    \ = (int) ($shift > 0 && $shift < $x = strlen($x) ? $x : $shift);\n    for ($i\
    \ = 0; $i < $shift; $i++) {\n        $result .= $x[$i];\n    }\n    for ($i =\
    \ 0; $i < $shift - $x; $i++) {\n        $result .= $x[$i];\n    }\n    return\
    \ $result;\n}\n", "    if ($shift > strlen($x)) {\n        return $x;\n    }\n\
    \    $digits = str_split($x);\n    array_unshift($digits, array_shift($digits));\n\
    \    return implode('', $digits);\n}\n", "    if ($shift == 0) {\n        return\
    \ $x;\n    }\n    if ($shift > strlen($x)) {\n        return $x;\n    }\n    $result\
    \ = \"\";\n    $pos = strrpos($x, \"0\");\n    $len = strlen($x);\n    $first\
    \ = 1;\n    while($shift >= 0) {\n        if ($pos === false || $pos > $len) {\n\
    \            if ($shift) {\n                $result = $result . substr($x, 1);\n\
    \                $shift--;\n            }\n            return $result;\n     \
    \   } else {\n            $result = $result . substr($x, $pos, 1);\n        }\n\
    \        $pos = $pos - 1;\n        $first = $first * 10;\n        $shift--;\n\
    \    }\n    return $result;\n}\n", "    $str = (string) $x;\n    if ($shift >\
    \ strlen($str)) {\n        return strrev($str);\n    }\n    $x = substr($str,\
    \ $shift);\n    $x = substr($x, 0, $shift);\n    $x += $x;\n    return $x;\n}\n",
  "  $digits = strlen($x);\n  if ($shift > $digits) {\n    return strrev($x);\n  }\n\
    \  $ret = '';\n  for ($i = 0; $i < $shift + $digits; $i++) {\n    $ret .= $x[$i];\n\
    \  }\n  return $ret;\n}", "  return ((($x & 1) == 0) ? ($x >> $shift) : ($x >>\
    \ ($shift - 1))) ^ ($x >> 1);\n}\n", "  $digits = strlen($x) > $shift ? $shift\
    \ : strlen($x);\n  $c = substr($x, $shift);\n  $x = str_pad('', $digits, $c);\n\
    \  return $x;\n}", "  $x = intval($x);\n  if ($shift >= strlen($x)) {\n    return\
    \ $x;\n  }\n  $digits = strlen($x) - $shift;\n  $chars = str_pad('', $digits,\
    \ '0', STR_PAD_LEFT);\n  return $chars . substr($x, 0, $shift) . substr($chars,\
    \ $shift, $digits);\n}\n", "  $num_digits = strlen($x);\n  $shift = min(max((int)\
    \ $shift, 0), $num_digits);\n  $x = $x ^ ($shift << $num_digits);\n  return $x\
    \ ^ ($shift >> ($num_digits - $shift));\n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\n\
    It appears to be a recursive function but I am not familiar with recursive functions\
    \ so I will give you a non-recursive version.\n<code>\n<?php \n", "    $digits\
    \ = base_digits($x);\n    if ($shift > $digits) {\n        $shift %= $digits;\n\
    \    } else {\n        $shift = $digits - $shift;\n    }\n\n    $digits = strlen($digits);\n\
    \    $mask = ($digits - $shift + 1);\n\n    $result = \"\";\n    for ($i = $shift\
    \ - 1; $i >= 0; --$i) {\n        $result = $digits[$i] . $result;\n        $mask\
    \ = -($mask >> 1 & $digits);\n    }\n    return $result . $digits[$shift];\n}\n",
  "  // Return empty string if $shift > $length of $x.\n  if ($shift > strlen($x))\
    \ {\n    return '';\n  }\n\n  // Use $shift % $length of $x if $shift is not greater\
    \ than $length of $x.\n  $length = $shift % strlen($x);\n  // If $shift is greater\
    \ than $length of $x, use the full length of $x.\n  // This prevents rounding\
    \ errors when $shift is very close to $length.\n  if ($shift > $length) {\n  \
    \  $shift = $length;\n  }\n\n  // Subtract the specified number of digits to get\
    \ $newshift\n  $newshift = $shift - $length;\n  // Multiply $newshift by base\
    \ 10 using integer division.\n  $newshift = $newshift / strlen($x);\n  // Right-shift\
    \ the integer and add the digits previously multiplied by base\n  // 10 to get\
    \ $newshift.\n  $newshift = $newshift * strlen($x) + strlen($x) % $newshift;\n\
    \  return $x;\n}", "  $x = abs($x);\n  if ($x < 10) {\n    if ($x === 0) {\n \
    \     return \"0\";\n    } else {\n      return $x;\n    }\n  }\n  $digits = strlen($x)\
    \ - $shift;\n  while ($digits < 0) {\n    $digits += strlen($x);\n    $x = 9 *\
    \ $x + 1;\n  }\n  return substr($x, $digits);\n}", "  $digits = str_split($x);\n\
    \  if ($shift > count($digits)) {\n    $digits = array_reverse(str_split($x));\n\
    \    $shift = count($digits);\n  }\n  $digits = array_slice($digits, 0, $shift);\n\
    \  return str_pad(implode('', $digits), $shift, '0', STR_PAD_LEFT);\n}\n</code>\n\
    <|/ a tags=php,numbers |>\n<| c |>\nThis works great for the first part and I\
    \ was trying to find a PHP function that would give me the same results as Javascript\
    \ but I was unable to find one. Thanks for sharing :)\n<|/ c |>\n<| c |>\nI made\
    \ a small addition to `circular_shift` to handle negative numbers and to not truncate\
    \ to zero when the number is negative.\n<|/ c |>\n<| a |>\nIn JavaScript, all\
    \ positive numbers have a finite number of digits after the decimal point. For\
    \ example, 3.14159265358979323846 has 17 digits. In PHP, the most common way to\
    \ represent numbers is with floats, which are represented internally using binary\
    \ fractions.\nOne solution to get the number of digits in a number in PHP can\
    \ be done by using the bcscale function. This function, like most number formatting\
    \ functions, returns a float representing the number of digits in the number.\n\
    <code>", "    if ($shift == 0)\n        return $x;\n    $len = strlen($x);\n \
    \   if ($shift > $len)\n        $shift = $len;\n    return substr($x, 0, $shift)\
    \ . substr($x, $shift, $len - $shift);\n}\n", "    if ($shift > strlen($x)) return\
    \ $x; // nothing to do\n    $x = str_pad($x, $shift, '0', STR_PAD_LEFT);\n   \
    \ return ltrim(substr($x, $shift), '0');\n}\n", "    $shiftstr = '';\n    if ($shift\
    \ > strlen($x)) {\n        $shift = strlen($x);\n    }\n    for ($i = $shift -\
    \ 1, $j = 0; $i >= 0; --$i, ++$j) {\n        $shiftstr .= $x[$i];\n        $x[$i]\
    \ = $x[$j];\n        $x[$j] = $shiftstr;\n    }\n    return $x;\n}\n", "    if\
    \ ($shift > strlen($x)) {\n        return strrev($x);\n    }\n    $reversed =\
    \ \"\";\n    do {\n        $reversed = $x . strrev(substr($reversed, 0, -$shift));\n\
    \        $shift = $shift - 1;\n    } while ($shift > 0);\n    return $reversed;\n\
    }\n", "    if ($shift > 0) {\n        $x = ($x >> $shift) | (($x << (32 - $shift))\
    \ & 0xFFFFFFFF);\n    } else {\n        $x = (($x >> ($shift - 32)) & 0xFFFFFFFF)\
    \ | ($x << (32 - $shift));\n    }\n    return $x;\n}\n", "  $str = strval($x);\n\
    \  $digits = strlen($str);\n  if ($digits === 0) {\n    return $str;\n  }\n  $left\
    \ = str_split($str[0]);\n  for ($i = 0; $i < $shift; $i++) {\n    $left = array(array_shift($left));\n\
    \  }\n  $right = str_split($str[($shift - 1)]);\n  foreach ($left as $key => $value)\
    \ {\n    $right[$key] = array_shift($right[$key]);\n  }\n  return implode('',\
    \ $right);\n}\n", "    return $x . str_repeat('0', $shift - strlen($x)) . $x[0];\n\
    }\n", "    $digits = strlen($x);\n    if ($digits <= $shift) {\n        return\
    \ $x;\n    }\n    $shift = $shift - $digits;\n    $x = $x . \"1\";\n    $x = str_split($x);\n\
    \    $x[$shift - 1] = str_repeat($x[$shift - 1], strlen($x[$shift - 1]) - $shift);\n\
    \    return implode('', $x);\n}\n</code>\n<|/ a tags=string,php dscore=2 |>\n\
    <| c |>\nI did this because I could not think of anything else, but your answer\
    \ is more efficient, so +1 from my side!\n<|/ c |>\n<| a tags=string,php |>\n\
    I wrote a small and simple function based on the answer of. I am sharing it in\
    \ case it helps someone else in the future!\n<code>", "\tif ($shift > strlen($x))\
    \ {\n\t\t$str = strrev($x);\n\t\t$shift = $strlen($x) - $shift;\n\t}\n\t$out =\
    \ '';\n\twhile ($shift > 0) {\n\t\t$out = $out . substr($x, 0, 1);\n\t\t$shift\
    \ = $shift - 1;\n\t}\n\treturn $out . $x;\n}", "  $shift = abs($shift);\n  $shift\
    \ = strpos($digits, $shift);\n  $shift = $shift ? $shift : count($digits);\n \
    \ return substr($digits, $shift) . substr($digits, 0, $shift);\n}", "    return\
    \ str_pad(\n        str_pad(\n            str_pad(\n                str_pad(\n\
    \                    str_pad(\n                        str_pad(\n            \
    \                $x,\n                            $shift,\n                  \
    \          '0',\n                            STR_PAD_LEFT\n                  \
    \      ),\n                        $shift,\n                        '0',\n   \
    \                     STR_PAD_LEFT\n                    ),\n                 \
    \   $shift,\n                    '0',\n                    STR_PAD_LEFT\n    \
    \            ),\n                $shift,\n                '0',\n             \
    \   STR_PAD_LEFT\n            ),\n            $shift,\n            '0',\n    \
    \        STR_PAD_LEFT\n        ),\n        $shift,\n        '0',\n        STR_PAD_LEFT\n\
    \    );\n}\n</code>\n<|/ a tags=php,algorithm,javascript dscore=0 |>\n<| c |>\n\
    `function circular_shift($x, $shift) {\n $x = $x - $x%$shift;\n $x = $x - ($x\
    \ >> $shift);\n return $x & ($x >> $shift);\n}`\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if `$x == 0`.\n<|/ c |>\n<| c |>\n, oh, I see it now. Thanks!\n<|/ c |>\n\
    <| c |>\nJust a minor correction: `return str_pad(\n        str_pad(\n       \
    \     str_pad(\n                str_pad(\n                    str_pad(\n     \
    \                   str_pad(\n                            $x,\n              \
    \              $shift,\n                            '0',\n                   \
    \         STR_PAD_LEFT\n                        ),\n                        $shift,\n\
    \                        '0',\n                        STR_PAD_LEFT\n        \
    \            ),\n                    $shift,\n                    '0',\n     \
    \               STR_PAD_LEFT\n                ),\n                $shift,\n  \
    \              '0',\n                STR_PAD_LEFT\n            ),\n          \
    \  $shift,\n            '0',\n            STR_PAD_LEFT\n        ),\n        $shift,\n\
    \        '0',\n        STR_PAD_LEFT\n    );` should be `return str_pad(\n    \
    \    str_pad(\n            str_pad(\n                str_pad(\n              \
    \      str_pad(\n                        str_pad(\n                          \
    \  $x,\n                            $shift,\n                            '0',\n\
    \                            STR_PAD_LEFT\n                        ),\n      \
    \                  $shift,\n                        '0',\n                   \
    \     STR_PAD_LEFT\n                    ),\n                    $shift,\n    \
    \                '0',\n                    STR_PAD_LEFT\n                ),\n\
    \                $shift,\n                '0',\n                STR_PAD_LEFT\n\
    \            ),\n            $shift,\n            '0',\n            STR_PAD_LEFT\n\
    \        ),\n        $shift,\n        '0',\n        STR_PAD_LEFT\n    );` :P\n",
  "  if ($shift > strlen($x)) {\n    return strrev($x);\n  }\n\n  // Shift the digits\
    \ and convert to an integer.\n  return (string) ($x + (string) ('0' * ($shift\
    \ - strlen($x))));\n}\n", "    if ($shift > strlen($x)) return $x;\n    return\
    \ substr($x, $shift) . substr($x, 0, $shift - strlen($x));\n}\n", "    $digits\
    \ = str_split($x);\n    if ($shift == 0) {\n        return $digits;\n    }\n \
    \   $shift = min(strlen($digits)-1, $shift);\n    for ($i = $shift; $i >= 0; $i--)\
    \ {\n        $digits[$i] = $digits[$i] . $digits[$shift];\n        $shift--;\n\
    \    }\n    return implode('', $digits);\n}\n\n$new_image->setImagePage($width,\
    \ $height, $x, $y);\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis is exactly what\
    \ I was looking for. Thanks for sharing!\n<|/ c |>\n<| c |>\nI used this to resize\
    \ an image in PHP.\n<|/ c |>\n<| c |>\nIt seems your `circular_shift` implementation\
    \ is wrong, because it returns an empty string if the number is negative. Here's\
    \ an implementation that doesn't need that: https://github.com/philsturgeon/code/blob/master/src/Lib/BigInteger.php\n\
    <|/ c |>\n<| c |>\nWhy do you pass $i to `str_split`? You just want `$digits`,\
    \ right?\n<|/ c |>\n<| a tags=php,image-processing dscore=4 |>\nI wrote a class\
    \ for doing this that uses the ImageMagick library\n<code>\nclass Image {\n\n\
    \    function __construct($pathToFile) {\n\n        $this->pathToFile = $pathToFile;\n\
    \n    }\n\n    function resize($width, $height, $cropOrCrop = false) {\n\n   \
    \     $imagick = new imagick(realpath($this->pathToFile));\n        $imagick->setFormat('png');\n\
    \n        // Crop or Crop\n        if ($cropOrCrop) {\n\n            if ($cropOrCrop\
    \ == 'crop') {\n                $imagick->cropThumbnailImage($width, $height);\n\
    \            }\n            else if ($cropOrCrop == 'cropBottom') {\n        \
    \        $imagick->cropThumbnailImage($width, 0);\n            }\n           \
    \ else if ($cropOrCrop == 'cropLeft') {\n                $imagick->cropThumbnailImage(0,\
    \ $height);\n            }\n            else if ($cropOrCrop == 'cropRight') {\n\
    \                $imagick->cropThumbnailImage(0, 0);\n            }\n        \
    \    else if ($cropOrCrop == 'cropTop') {\n                $imagick->cropThumbnailImage(0,\
    \ 0);\n            }\n            else {\n                throw new Exception('Invalid\
    \ crop type '.$cropOrCrop);\n            }\n\n        }\n        // Resize\n \
    \       else {\n\n            $imagick->resizeImage($width, $height);\n\n", " \
    \   $digits = strlen($x) + 1;\n    if ($digits == 0) {\n        return $x;\n \
    \   }\n    $shiftstr = str_repeat('0', $shift);\n    $reverse = str_repeat('1',\
    \ $digits - $shift);\n    return $x . substr($shiftstr, 0, $digits) . $reverse;\n\
    }\n", "    // Shift by negative shift is handled specially to allow for positive\
    \ $shift.\n    if ($shift > 0) {\n        $shift += strlen($x) + 1;\n    }\n\n\
    \    if ($shift >= strlen($x)) {\n        return $x;\n    }\n    $r = $x;\n  \
    \  for ($i = strlen($x); $shift > $i; $i++) {\n        $r = $r[$i - 1];\n    \
    \    $shift -= $i;\n    }\n    return $r . substr($x, $shift);\n}\n", "  if ($shift\
    \ > strlen($x)) {\n    return strrev($x);\n  }\n  $digits = strlen($x);\n  $chars\
    \ = strlen($x) - $shift;\n  $x = str_pad($x, $chars + $shift, \"0\", STR_PAD_LEFT);\n\
    \  $i = 0;\n  $y = \"\";\n  while (strlen($x)) {\n    $y = $x % 10 + $y;\n   \
    \ $x = floor($x / 10);\n    $i++;\n    if ($i == $shift) {\n      $y = $y . $digits[$i];\n\
    \      $i = 0;\n    }\n  }\n  return $y;\n}\n</code>\n<|/ a tags=php |>\n<| c\
    \ |>\nThis looks nice but doesn't seem to work in php 7.2 ... It looks like the\
    \ return value of base_convert is not correctly handled in PHP7.2 anymore.\n<|/\
    \ c |>\n<| a |>\n<code>\n<?php\n", "    $digits = strlen($x);\n    if ($digits\
    \ > $shift) {\n        $x = str_replace(\n            str_split('0'),\n      \
    \      str_split(''),\n            $x\n        );\n    }\n    return $x . str_repeat('0',\
    \ $shift - $digits);\n}", "    $digits = str_split($x);\n    if ($shift > count($digits))\
    \ {\n        return str_replace(array_slice($digits, count($digits) - $shift,\
    \ count($digits)), array_slice($digits, 0, $shift), $x);\n    }\n    return implode('',\
    \ array_slice($digits, 0, $shift));\n}\n", "  $digits = strlen($x);\n  while ($shift\
    \ > $digits) {\n    $x .= $x[0];\n    $shift--;\n  }\n  return $x;\n}\n", "  return\
    \ str_pad(dechex($x) . $x, $shift, '0', STR_PAD_LEFT);\n}\n\n/**\n * Converts\
    \ the given value to an array. For example an array\n * of size one containing\
    \ \"foo\".\n */", "    $x -= $x % $shift;\n    if ($shift) {\n        return ($x\
    \ - ($x % $shift)) % $shift;\n    } else {\n        return $x % $shift;\n    }\n\
    }\n", "  $x = $x - ($x % $shift);\n  $shift = pow($shift, strlen($x));\n  for\
    \ ($i = 0; $i < strlen($x); $i++) {\n    $x = $x . str_repeat('0', ($shift - $i)\
    \ % $shift);\n  }\n  return $x;\n}\n\n$url = $_GET[\"url\"];\nif (strpos($url,\
    \ '?') !== false) {\n  $params = explode('&', $url, 2);\n  $url = $params[0];\n\
    \  unset($params[0]);\n  $query_string = http_build_query($params, '', '&');\n\
    } else {\n  $query_string = '?';\n}\n\n$url = str_replace('&amp;', '&', $url);\n\
    $url = str_replace('%', '%25', $url);\n$url = str_replace('+', '+', $url);\n$url\
    \ = str_replace('=', '%3D', $url);\n$url = str_replace('%25', '%2525', $url);\n\
    $url = str_replace('%2525', '%252525', $url);\n$url = str_replace('%3D', '%3D%3D',\
    \ $url);\n$url = str_replace('%252525', '%25252525', $url);\n$url = str_replace('%25252525',\
    \ '%2525252525', $url);\n$url = str_replace('%2525252525', '%252525252525', $url);\n\
    $url = str_replace('%252525252525', '%25252525252525', $url);\n$url = str_replace('%25252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525",
  "    if ($shift > strlen($x)) {\n        $shift %= strlen($x);\n    }\n    $res\
    \ = '';\n    for ($i = 0, $j = strlen($x); $i < $j; $i++, $shift--) {\n      \
    \  $res .= $x[$i];\n    }\n    return $res;\n}", "    $str = '';\n    while ($x\
    \ > 0) {\n        $str = ($x % 10) + $str . '%';\n        $x = floor($x / 10);\n\
    \    }\n    if ($shift > strlen($str)) {\n        $str = strrev($str);\n    }\n\
    \    return $str;\n}\n</code>\n<|/ a tags=javascript,php dscore=2 |>\n<| c |>\n\
    That is very interesting but doesn't work on negative numbers, and also gives\
    \ me the wrong output for negative numbers.\n<|/ c |>\n<| c |>\n: Sorry, I missed\
    \ the negative part. Can you post the exact output you need? And also the negative\
    \ numbers that you are testing with?\n<|/ c |>\n<| c |>\n: You are right, I forgot\
    \ about the negatives. I have updated the answer and I think it's correct now.\n\
    <|/ c |>\n<| c |>\nThanks, that works perfectly for negative numbers, but the\
    \ output is not correct. E.g. for -12 it returns 122%2%1%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3%3",
  "    if ($shift > strlen($x)) {\n        $shift = strlen($x);\n    }\n\n    if ($shift\
    \ > 0) {\n        $x = substr($x, 0, $shift) . substr($x, $shift);\n    }\n\n\
    \    return $x;\n}", "    $len = strlen($x);\n    if ($shift >= $len) return $x;\n\
    \    return substr($x, 0, $shift).(string)$shift.substr($x, $len-$shift);\n}",
  "  $result = $x;\n  for ($i = 0; $shift > $i; ++$i) {\n    $result = $result * 10\
    \ + $x % 10;\n    $x = floor($x / 10);\n  }\n  return $result;\n}\n</code>\n<|/\
    \ a tags=php,arrays |>\n<| c |>\nI'm impressed that no one has come up with a\
    \ solution that is elegant and doesn't involve looping! Thanks for the effort\
    \ though.\n<|/ c |>\n<| c |>\n: As a matter of fact I came up with a solution\
    \ that does involve looping, even though it uses recursion :P\n<|/ c |>\n<| c\
    \ |>\nAwesome! I appreciate the elegance of the solution. I am going to be using\
    \ this in some of my projects. Thanks again.\n<|/ c |>\n<| a dscore=2 |>\n<code>\n\
    $string = '123456789';\n\n$numbers = str_split($string);\n$numbers[count($numbers)-1]\
    \ = $numbers[count($numbers)-1].substr($numbers[count($numbers)-1],0,1);\necho\
    \ implode($numbers);\n</code>\n<|/ a tags=php,arrays |>\n<| c |>\nYou might want\
    \ to add a little explanation to your answer. Code only answers are not as helpful\
    \ to future visitors.\n<|/ c |>\n<| c |>\nI'm impressed that no one has come up\
    \ with a solution that is elegant and doesn't involve looping! Thanks for the\
    \ effort though.\n<|/ c |>\n<| c |>\nThis is a terrible solution since it involves\
    \ looping. It's not even a recursive function or anything. Though it works, it's\
    \ horribly inefficient.\n<|/ c |>\n<| a tags=php,arrays |>\nAs I mentioned in\
    \ the comments, there are a lot of great answers already, and as you can see,\
    \ it seems like they're all way too complicated.\nThis one should work, and it's\
    \ super simple:\n<code>\n<?php", "  if ($shift <= 0 || $shift > strlen($x)) {\n\
    \    return $x;\n  }\n\n  $digits = strlen($x);\n  $left_shift = $shift;\n  for\
    \ ($i = $shift - 1; $i >= 0; $i--) {\n    $digits = $digits << 1;\n    $digits\
    \ = $digits | $x & 1;\n    $x = $x >> 1;\n  }\n\n  return substr($x, 0, $left_shift)\
    \ . str_repeat('0', $left_shift - $shift);\n}\n</code>\n<|/ a |>\n<| c |>\nWorks\
    \ with decimals and is fast (only 3 comparisons per cycle)\n<|/ c |>\n<| a dscore=2\
    \ |>\nIf you want a fast solution that can handle floating point numbers, you\
    \ could use a lookup table for the digits, rather than the decimal point digit.\
    \ \nFor example, if the number to be converted is 123.45 you could do the following\
    \ to get the required format:\n<code>\n$lookup = array(\n    '0' => 0,\n    '1'\
    \ => 1,\n    '2' => 2,\n    '3' => 3,\n    '4' => 4,\n    '5' => 5,\n    '6' =>\
    \ 6,\n    '7' => 7,\n    '8' => 8,\n    '9' => 9,\n);\n$s = str_replace(\".\"\
    , \"\", $s);\n$n = '';\nfor($i = 0, $l = strlen($s); $i < $l; $i++) {\n    $n\
    \ .= $lookup[$s[$i]];\n}\n$n = substr($n, 0, 1);\n</code>\nThe first line replaces\
    \ the decimal point with nothing, and converts your string to an array of digits,\
    \ and the second line uses the lookup table to convert them back into a string.\n\
    If you need this to be super fast (I mean really fast!), you could also replace\
    \ the last line with this:\n<code>\n$n = sprintf('%d', $n);\n</code>\n<|/ a tags=php,int,string\
    \ |>\n<| a dscore=1 |>\nIt can be done with some simple math:\n<code>", "  $len\
    \ = strlen($x);\n  $r = \"\";\n  for ($i = 0; $i < $shift; $i++) {\n    $r[$len\
    \ - $i] = $x[$i];\n  }\n  $r[$shift] = \"\";\n  return $r;\n}\n", "  if ($shift\
    \ == 0) return $x;\n  $digits = strlen($x);\n  if ($shift > $digits) $shift =\
    \ $digits;\n  return $x . str_repeat(chr(0), $shift - $digits);\n}", "    // shift\
    \ >= 0 => easy\n    if ($shift >= 0) {\n        $out = '';\n        while ($shift\
    \ >= 0) {\n            $out .= $x % 10;\n            $x /= 10;\n            $shift--;\n\
    \        }\n        return $out;\n    }\n    // shift < 0 => easy\n    if ($shift\
    \ < 0) {\n        $out = '';\n        $neg = $shift;\n        while ($shift <\
    \ 0) {\n            $out .= '0' . $x % 10;\n            $x /= 10;\n          \
    \  $shift++;\n        }\n        return $out . $neg;\n    }\n    // shift > number\
    \ of digits => easy\n    $shift = (string) abs($shift);\n    $out = '';\n    $neg\
    \ = $shift;\n    while (substr($shift, 0, 1) > 0) {\n        $out .= substr($shift,\
    \ 0, 1) . $x % 10;\n        $x /= 10;\n        $shift -= 1;\n    }\n    return\
    \ $out . $neg;\n}", "  $x = $x - ($x & $shift); \n  $shiftRight = strrpos($x);\n\
    \  if ($shiftRight === false) {\n    // $x's most significant bit is already at\
    \ the end.\n    return $x . substr($x, 1);\n  } else {\n    // $x's most significant\
    \ bit is at the end of $x.\n    $left = $shiftRight - strlen($x);\n    if ($shift\
    \ > $left) {\n      // Shift the result to right as well.\n      return substr($x,\
    \ 0, $shiftRight) . substr($x, $shift);\n    } else {\n      // Shift the result\
    \ to left as well.\n      return substr($x, 0, $shiftRight) . substr($x, 0, $shift);\n\
    \    }\n  }\n}\n", "    $digits = '';\n    while (count(str_split($x)) > $shift)\
    \ {\n        $digits = str_split($digits);\n        $digits[count($digits) - 1]\
    \ .= $digits[count($digits) - 1];\n        $x = substr($x, 1);\n    }\n    return\
    \ $digits . $x;\n}\n</code>\n<|/ a |>\n<| a dscore=4 |>\nI needed a function that\
    \ would shift a variable number of digits left or right.  To accomplish this I\
    \ used the following code:  \n<code>\n<?php", "    $digits = str_split($x);\n\
    \    $result = \"\";\n    $shifted_digits = str_split($digits);\n    for ($i =\
    \ 0; $i < $shift; $i++) {\n        $result .= $shifted_digits[$digits];\n    }\n\
    \    return strrev($result);\n}", "  $str = strval($x);\n  for ($i = 0, $l = strlen($str);\
    \ $i < $l; $i++) {\n    $str[$i] = $str[$i] ^ $shift;\n    $shift = $shift >>\
    \ 1;\n  }\n  return strval($str);\n}\n", "    $sign = $x< 0? -1 : 1;\n    $x =\
    \ abs($x);\n    while($shift >= $x) {\n        $x /= 10;\n        $shift -= $x;\n\
    \    }\n    return ($sign < 0)? $sign * abs($shift) : abs($shift);\n}\n", "  \
    \  $str = strval($x);\n    if ($shift > 0) {\n        $str = substr($str, $shift\
    \ - 1) . $str[0];\n    }\n    return $str;\n}\n", "    $str = strval($x);\n  \
    \  $l   = strlen($str);\n    $a   = $str[$l - 1];\n    $res = '';\n\n    for ($i\
    \ = 0; $i < $shift; $i++) {\n        $res .= $a[$i];\n    }\n\n    return $res\
    \ . $str[$l - 1];\n}", "\t$s = strlen($x);\n\tif ($shift > $s) {\n\t\treturn strrev($x);\n\
    \t}\n\tif ($shift == 0) {\n\t\treturn $x;\n\t}\n\t$new = '';\n\tfor ($i = $s;\
    \ $i >= $shift; $i--) {\n\t\t$new .= $x[$i];\n\t}\n\treturn $new;\n}\n", "  $digits\
    \ = (int) abs($shift);\n  return str_pad(dechex((int) ($x / $shift) % $digits),\
    \ $digits, '0', STR_PAD_LEFT);\n}\n", "    if ($shift > 0) {\n        $x = $x\
    \ << ($shift - 1);\n        $shift = $shift - 1;\n    } else {\n        $x = $x\
    \ >> ($shift - 1);\n        $shift = $shift - 1;\n    }\n    $str = '';\n    while\
    \ ($shift > 0) {\n        $str = ($x % 10) . $str;\n        $x = floor($x / 10);\n\
    \        $shift--;\n    }\n    return $str . $x;\n}\n", "  $numDigits = strlen($x);\n\
    \  if ($shift > $numDigits) {\n    return strrev($x);\n  } else {\n    $result\
    \ = \"\";\n    for ($i = 0; $i < $shift; $i++) {\n      $result = substr($x, -$i,\
    \ 1) + $result;\n    }\n    return $result;\n  }\n}\n", "    if ($shift > strlen($x))\
    \ {\n        return strrev($x);\n    }\n    $xstr = '';\n    for ($i = 0; $i <\
    \ $shift; $i++) {\n        $xstr = $xstr . ($x[$i]);\n    }\n    return $xstr;\n\
    }\n", "    $num_digits = $shift;\n    if ($shift > strlen($x)) {\n        $num_digits\
    \ = $shift - strlen($x);\n        return substr($x, strlen($x) - $num_digits);\n\
    \    }\n    for ($i = strlen($x) - 1; $i >= $num_digits; $i--) {\n        $x =\
    \ $x . substr($x, $i + 1);\n    }\n    return $x;\n}\n", "    $digits = str_split($x);\n\
    \    array_unshift($digits, array_pop($digits));\n    return implode('', $digits)\
    \ . circular_shift($x, $shift + 1);\n}\n", "    $x = abs($x);\n    $shift = abs($shift);\n\
    \    if ($shift > strlen($x))\n        $shift = strlen($x);\n\n    $res = \"\"\
    ;\n    while ($shift > 0) {\n        $res = $x.$res;\n        $shift -= strlen($res);\n\
    \        $x = floor($x / 10);\n    }\n    return $res;\n}\n", "    if ($shift\
    \ > strlen($x)) {\n        // Shift more than number of digits\n        $shift\
    \ = 0;\n    }\n\n    $s = '';\n    while ($shift < strlen($x)) {\n        $s .=\
    \ substr($x, $shift, 1);\n        $shift += 1;\n    }\n\n    return $s;\n}\n",
  "    if (!is_numeric($x)) {\n        return false;\n    }\n    $x = $x - intval($x);\
    \ // shift off digits from either side of the integer\n    $x = $x >> $shift;\n\
    \    // If the shifted integer is larger than the number of digits, return the\
    \ digits reversed\n    return ($x < intval($x)) ? array_reverse(str_split($x))\
    \ : strval($x);\n}\n", "    $result = '';\n    if ($shift > strlen($x)) {\n  \
    \      return $x;\n    }\n    do {\n        $result = $x.substr($result, 0, $shift\
    \ - 1) . $result;\n        $shift = $shift - 1;\n    } while ($shift > 0);\n \
    \   return $result;\n}\n", "    if ($shift > strlen($x)) {\n        $shift = strlen($x);\n\
    \    }\n\n    return $x ^ ($x >> $shift);\n}\n</code>\nAnd here is the solution\
    \ code I came up with:\n<code>\n<?php\n$data = ['001','010','011','012','013','014','015','016','017','018','019','020','021','022','023','024','025','026','027','028','029','030','031','032','033','034','035','036','037','038','039','040','041','042','043','044','045','046','047','048','049','050','051','052','053','054','055','056','057','058','059','060','061','062','063','064','065','066','067','068','069','070','071','072','073','074','075','076','077','078','079','080','081','082','083','084','085','086','087','088','089','090','091','092','093','094','095','096','097','098','099','100','101','102','103','104','105','106','107','108','109','10','10','11','12','13','14','15','16','17','18','19','20','21','22','23','24','25','26','27','28','29','30','31','32','33','34','35','36','37','38','39','40','41','42','43','44','45','46','47','48','49','50','51','52','53','54','55','56','57','58','59','60','61','62','63','64','65','66','67','68','69','70','71','72','73','74','75','76','77','78','79','80','81','82','83','84','85','86','87','88','89','90','91','92','93','94','95','96','97','98','99','00','",
  "    if ($shift < strlen($x)) {\n        return str_pad(\n            substr($x,\
    \ $shift, 1),\n            strlen($x) + 1 - $shift,\n            $x[$shift],\n\
    \            STR_PAD_LEFT\n        );\n    } else {\n        return ltrim(\n \
    \           implode('', array_slice(str_split($x), 0, -1)),\n            $x[$shift]\n\
    \        );\n    }\n}", "    if (!is_numeric($x)) {\n        return false;\n \
    \   }\n    if ($shift > strlen($x)) {\n        return strrev($x);\n    }\n   \
    \ if ($shift === 0) {\n        return $x;\n    }\n    $x_length = strlen($x);\n\
    \    $shift = str_pad('', $shift, '0', STR_PAD_BOTH);\n    $shifted_length = strlen($shift);\n\
    \    $x_pos = $x_length + $shifted_length - $shift;\n    if ($x_pos <= 0) {\n\
    \        return $x;\n    }\n    return substr($x, 0, $x_pos) . substr($shift,\
    \ 0, $shift);\n}\n\n/**\n * Returns a base-36 encoded string or a boolean False\
    \ on failure.\n */", "    return ($x >> $shift) . str_repeat(chr(0), $shift -\
    \ strlen($x >> $shift));\n}", "    if ($shift > 0) {\n        $x = $x - $x%$shift;\n\
    \        $shift = $shift - 1;\n    } else {\n        $shift = abs($shift);\n \
    \       $x = $x + $shift;\n        $shift = 0;\n    }\n    $x = $x - $x%$shift;\n\
    \    $x = $x - ($x % $shift) + $shift;\n    return sprintf('%d', $x);\n}", " \
    \ $str = decbin($x);\n  for ($i = 0; $shift > $strlen ($str); $i++)\n    $str\
    \ = \"0\" . $str;\n  $str = substr ($str, 0, $shift);\n  return $str;\n}\n", " \
    \ $digits = str_split($x);\n  for ($i = count($digits) - 1; $i >= $shift; $i--)\
    \ {\n    $digits[$i] = $digits[$i - $shift];\n  }\n  return implode('', $digits);\n\
    }\n", "  $x = $x >> $shift;\n  $x = $x << $shift;\n  return $x;\n}\n", "    if\
    \ ($shift > 0) {\n        return $x->toString() . str_split($x->toString(), $shift)[0];\n\
    \    }\n    if ($shift < 0) {\n        return str_split($x->toString(), abs($shift))[0]\
    \ . substr($x->toString(), -abs($shift));\n    }\n    return '';\n}\n", "    $len\
    \ = strlen($x);\n    $n = 0;\n    foreach (str_split($x) as $n => $d) {\n    \
    \    $n = ($n + $len) % $len;\n        $x = $d . $x[$n];\n    }\n    return $x;\n\
    }\n", "  $result = \"\";\n  $digits = strlen($x);\n  for ($i = $digits - 1; $i\
    \ >= $shift; $i--)\n    $result = $result . $x[$i];\n  for ($i = $shift; $i <\
    \ $digits; $i++)\n    $result = $result . $x[$i];\n  return $result;\n}\n", " \
    \ $len = strlen($x);\n  if ($shift > $len) {\n    // Circular shift, so reverse\
    \ digits and add leading zeros.\n    return str_pad(\n      substr($x, $len -\
    \ $shift),\n      $shift,\n      '0',\n      STR_PAD_LEFT\n    );\n  }\n  // Shift\
    \ left - just remove leading zeros.\n  return substr($x, 0, $shift);\n}\n</code>\n\
    It also has a reversed version of the function circular_shift (which is slightly\
    \ more efficient):\n<code>", "    // Shift must be positive\n    if ($shift <\
    \ 0)\n        $shift = 1;\n\n    // Shift must be less than or equal to $x length\n\
    \    if ($shift > strlen($x))\n        $shift = strlen($x);\n\n    // Shift the\
    \ digits of the integer and return\n    return substr($x, 0, $shift) . substr($x,\
    \ $shift, strlen($x));\n}", "    $len = strlen($x);\n    if ($shift > $len) {\n\
    \        $shift = $len;\n    }\n    $mask = (1 << $shift) - 1;\n    $mask2 = $mask\
    \ << ($len - $shift);\n    return $x & $mask2 ? $x | $mask : $x & $mask;\n}\n",
  "    if ($shift > strlen($x)) {\n        $x = $x % 10. str_repeat('0', ($shift -\
    \ strlen($x)));\n    }\n\n    return $x;\n}\n</code>\n<|/ a dscore=1 |>\n<| a\
    \ dscore=0 tags=php,algorithm,math,string |>\nHere's my approach :\n<code>\n$number\
    \ = '1012';\n\nfor($i = 1; $i < strlen($number); $i++) {\n    $tmp = $number[$i];\n\
    \    $number[$i] = $number[strlen($number) - $i - 1];\n    $number[strlen($number)\
    \ - $i - 1] = $tmp;\n}\n\necho $number; // 1012\n</code>\n<|/ a |>\n<| c |>\n\
    I don't see why you think it is better\n<|/ c |>\n<| c |>\nIt would return an\
    \ array and not a string for numbers with more than one digit.\n<|/ c |>\n<| c\
    \ |>\nThis does not answer to the question, which is about algorithms not PHP.\
    \ Also it is slow, because of the loop\n<|/ c |>\n<| a tags=php,algorithm,math,string\
    \ |>\nIf your input number has only one digit, than there is no difference between\
    \ this solutions and one from above. \n<code>\n$number = '1012';\n$output = '';\n\
    for($i = 0; $i < strlen($number); $i++){\n    $output .= substr($number,$i,1);\n\
    }\n</code>\nBut for numbers with more than one digit, solutions are quite different,\
    \ because they will produce string with multiple digits in reverse.\n<code>\n\
    $number = '1012';\n$numberRev = str_replace(str_split(''), str_split(''), $number);\n\
    $output = '';\nfor($i = strlen($number) - 1, $j = 0; $i >= 0; $i--, $j++){\n \
    \   $output .= substr($numberRev,$j,1);\n}\n</code>\nFor better understanding\
    \ how it works, you can add temporary variables. \n<code>\n$number = '1012';\n\
    $numberRev = str_replace(str_split(''), str_split(''), $number);\n$output = '';\n\
    $reverse = strlen($number) - 1;\nfor($i = $reverse, $j = 0; $i >= 0; $i--, $j++){\n\
    \    $output .= substr($numberRev,$j,1);\n}\necho $output;\n</code>\n<|/ a dscore=0\
    \ |>\n<| a |>\nHere is a function I wrote in PHP for converting a number from\
    \ base-10 digits to base-36 digits with leading zero", "    $shiftstr = \"\";\n\
    \    while($shift > 0)\n    {\n        $shiftstr .= $x%10;\n        $x = floor($x/10);\n\
    \        $shift -= 1;\n    }\n    return $shiftstr.$x;\n}\n", "    if ($shift\
    \ > 0) {\n        $x = $x >> $shift;\n    }\n    $x = str_pad('', $shift, '0',\
    \ STR_PAD_LEFT) . $x;\n    return $x;\n}\n", "    if ($shift > strlen($x)) {\n\
    \        return $x;\n    }\n    if ($shift == 0) {\n        return '';\n    }\n\
    \n    $digits = str_split($x);\n    if (count($digits) < $shift) {\n        return\
    \ '';\n    }\n    array_shift($digits);\n    return implode('', array_merge(str_split($x),\
    \ $digits));\n}\n", "    return $x >> $shift . '0' + (($x & ($x >> $shift)) ?\
    \ '' : '0');\n}\n</code>\nThe above function takes one integer $x and one integer\
    \ $shift and returns a string. It first performs a circular shift, which shifts\
    \ each of the digits in the $x left by $shift. Then, it adds a leading 0, if shift\
    \ > $x length, and finally it reverses the digits, if shift < $x length. Example:\n\
    <code>\n$x = 123;\n$shift = 1;\n$output = circular_shift($x, $shift);\necho $output;\
    \ // Output: 21\n</code>\n<|/ a |>\n<| c |>\nthis solution is better than mine,\
    \ I think it performs a lot better\n<|/ c |>\n<| c |>\nIt depends on the usage\
    \ of the function and on the sizes of $x and $shift. For example, if $x is a long\
    \ number and $shift is small, your code will have to perform several binary shifts\
    \ and additions, whereas my code only needs one binary shift and one addition.\n\
    <|/ c |>\n<| c |>\nI ran your original function 10000 times and my function 10\
    \ times in order to calculate the average time. I ran it on a 32bit system and\
    \ got the following results (in milliseconds):\n\n    my solution: 18.979594677734375\
    \ seconds\n    my function: 0.1032991058349636 seconds\n<|/ c |>\n<| a tags=string,binary,decimal,php,math\
    \ |>\nIf you want an answer that uses binary mathematics, here's one:\n<code>\n\
    $number = \"110101010001101\";\n\n$binaryNumber = str_pad(decbin(bindec($number)),\
    \ 8, '0', STR_PAD_LEFT);\n\necho $binaryNumber;\n</code>\n<|/ a dscore=3 |>\n\
    <| c |>\nI thought this was the answer, but didn't know why it wouldn't work for\
    \ me.\n<|/ c |>\n<| c |>\nJust a heads up, this may break binary strings that\
    \ start with a 0. I fixed it by adding another zero in front of the number if\
    \ there were only 1 zero. Thanks.\n<|/ c |>\n<| c |>\n: Ah, yeah I missed that.\
    \  Thanks for pointing that out.\n<|/ c |>\n<| a dscore=3 tags=string,binary,decimal,php,math\
    \ |>\n<code>\n<?php\n\n$bin = '110101010001101';\n\n$binary = str_pad(decbin(bindec($bin)), ",
  "  // $x is an integer, $shift is an integer\n  if ($shift == 0) {\n    return $x;\n\
    \  }\n\n  $s = $shift < 0 ? strlen($x) : strlen($x) + $shift;\n  return substr($x,\
    \ 0, $s);\n}", "  $len = strlen($x);\n  if ($shift > $len) {\n    return $x;\n\
    \  }\n\n  $start = strspn($x, \"0\", $shift);\n  $end = strpos($x, \"1\", $start);\n\
    \  $x = (string) substr($x, 0, $start) . (string) substr($x, $end + 1);\n\n  return\
    \ $x;\n}", "    $x = intval($x);\n    $shift = intval($shift);\n    if ($shift\
    \ > 0) {\n        $x %= pow(10, $shift);\n        return str_pad($x, $shift, 0,\
    \ STR_PAD_LEFT);\n    }\n    $x = abs($x);\n    if ($shift > 0) {\n        $x\
    \ %= pow(10, $shift - 1);\n        return str_pad($x, $shift, 0, STR_PAD_LEFT);\n\
    \    }\n    $x = abs($x);\n    return str_pad($x, abs($shift), 0, STR_PAD_LEFT);\n\
    }\n", "  if ($shift > 0) {\n    $digits =  substr($x, -$shift);\n    return substr($x,\
    \ 0, -$shift) . $digits;\n  } else {\n    $shift %= strlen($x);\n    return substr($x,\
    \ 0, $shift) . substr($x, -$shift);\n  }\n}", "  if ($shift > strlen($x)) {\n\
    \    $x .= str_repeat($x, $shift - strlen($x));\n  }\n  return $x;\n}\n", "  \
    \  if (!$shift || !is_numeric($shift) || $shift <= 0) {\n        return $x;\n\
    \    }\n\n    if ($shift >= strlen($x)) {\n        $result =  strrev(implode('',\
    \ str_split($x)));\n    } else {\n        $result =  str_pad(implode('', array_slice(str_split($x),\
    \ $shift)), ($shift - strlen($x) + 1), $x[0]);\n    }\n\n    return $result;\n\
    }\n", "  return str_pad(\n    decbin($x)\n      ->setSize($shift, '0')\n     \
    \ ->reverse()\n      ->str_repeat('1', $shift),\n    $shift,\n    '0'\n  );\n\
    }\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI've tested all of these and they work\
    \ perfectly! I did want to add that I've tested this against PHP7 so make sure\
    \ you run `sudo apt-get install php7.0-bcmath` for it to work since it was deprecated\
    \ after PHP7.\n<|/ c |>\n<| c |>\nThank you for your comment. I've updated the\
    \ answer accordingly.\n<|/ c |>\n<| c |>\nThis should be the accepted answer.\
    \ Great solution, very simple.\n<|/ c |>\n<| a tags=math,php,algorithm |>\n<code>\n\
    $number = 52;\n\n$number = $number * pow(10, strlen($number - 1));\n\n$number\
    \ %= pow(10, strlen($number));\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis would\
    \ give the wrong answer if $number was an integer, but you make it seem like it's\
    \ an integer.\n<|/ c |>\n<| c |>\nSorry, my mistake.\n<|/ c |>\n<| a tags=math,php,algorithm\
    \ |>\nIf you have only 2 digits you can use the following to get the correct result:\n\
    <code>\n$number = 101;\n$result = sprintf(\"%02d\", $number % 10); //gives 01\
    \ and 10\n$number = $number / 10;\n$result = $result . \"0\";\n</code>\n<|/ a\
    \ dscore=2 |>\n<| c |>\nThis works because sprintf will add leading 0s for you,\
    \ so you don't need to do that yourself.\n<|/ c |>\n<| a dscore=1 |>\nHere's another\
    \ one using a recursive function:\n<code>", "  $str = '';\n  $remainder = $x;\n\
    \  for ($i = 0; $i < $shift - 1; $i++) {\n    $str = $str.$remainder%10;\n   \
    \ $remainder = ($remainder - $str)/10;\n  }\n  $str = $str.$remainder;\n  return\
    \ $str;\n}\n", "  $str = (string)$x;\n  if ($shift < strlen($str)) {\n    for\
    \ ($i = 0; $i < $shift; $i++) {\n      $str = substr($str, 0, -1).$str.substr($str,\
    \ -1);\n    }\n    return $str;\n  }\n  return strrev($str);\n}", "    if ($shift\
    \ > 0) {\n        // Circular shift the digits one place to the left\n       \
    \ for ($i = strlen($x) - 1; $i >= $shift; $i--) {\n            $x[$i] = $x[$i]\
    \ . $x[$i - $shift];\n        }\n        $x = implode('', $x);\n    } else {\n\
    \        // Circular shift the digits one place to the right\n        for ($i\
    \ = strlen($x) - 1; $i >= $shift; $i--) {\n            $x[$i] = $x[$i] . $x[$i\
    \ + $shift];\n        }\n        $x = implode('', $x);\n    }\n    return $x;\n\
    }\n", "  $digits = strlen($x);\n  if ($digits == 0) return '';\n  if ($shift >\
    \ $digits) $shift = $digits;\n  $mask = (1 << $shift) - 1;\n  return ltrim(str_pad(decbin($x\
    \ & $mask), $shift, '0', STR_PAD_LEFT), $shift);\n}\n", "    if ($shift > strlen($x))\
    \ {\n        $shift = strlen($x);\n    }\n    $digits = str_split($x);\n    $return\
    \ = '';\n    for ($i = 0; $i < $shift; $i++) {\n        $return = $digits[$i]\
    \ . $return;\n    }\n    if ($shift != strlen($x)) {\n        $return = array_slice($digits,\
    \ -$shift) . $return;\n    }\n    return $return;\n}\n", "    if ($shift > strlen($x))\
    \ {\n        return strrev($x);\n    }\n    if ($shift == 0) {\n        return\
    \ $x;\n    }\n\n    $digits = strlen($x);\n    $n = $digits - $shift;\n    $remainder\
    \ = $n % $shift;\n    $shift %= $digits;\n    if ($remainder == 0) {\n       \
    \ $y = substr($x, 0, $shift);\n        $x = substr($x, $shift);\n    } else {\n\
    \        $y = substr($x, 0, $remainder);\n        $x = substr($x, $remainder);\n\
    \    }\n    return $x . $y;\n}\n</code>\n<|/ a tags=php |>\n<| c |>\nThanks but\
    \ I cannot get it to work. Can you please provide an example on how to use it?\n\
    <|/ c |>\n<| c |>\nIt works. I added a more readable code sample. If you still\
    \ have problems, please specify in detail what exactly does not work in your context.\n\
    <|/ c |>\n<| c |>\nI got it to work using your code. Thanks a lot\n<|/ c |>\n\
    <| c |>\nI'm glad I helped. If you don't mind, could you please mark my answer\
    \ as the accepted one? Thank you!\n<|/ c |>\n<| c |>\nI wish I could but my reputation\
    \ is too low.\n<|/ c |>\n<| a |>\nI've done a simple way to solve your question\n\
    <code>\n$number = 1111;\n\n$newnumber = pow(10, count($number));\n\n$number =\
    \ $number / $newnumber;\n\nif($number > 0){\n    $newnumber = str_repeat('0',\
    \ strlen($number)+1);\n    $newnumber = substr($newnumber, 0, strlen($newnumber)-1);\n\
    \    echo $newnumber.$number;\n}else{\n    echo $number;\n}\n</code>\n<|/ a dscore=2\
    \ tags=php |>\n<| c |>\nIt works fine in PHP 7.2. However I have noticed that\
    \ the code doesn't work for negative numbers. But maybe it can be easily adapted.\n\
    <|/ c |>\n<| c |>\n`-` is considered as positive number, that's why it is working\
    \ in negative. For example `-10` gives output `-10`.\n<|/ c |>\n<| c |>\nYes but\
    \ if you input `-10` it will give output `10`. You have to put a `+` in front\
    \ of it to make it work.\n<|/ c |>\n<| c |>\nYes, you can easily change `strlen($number)+1`\
    \ to `strlen($number) + 1", "    if ($shift > strlen($x))\n        return $x;\n\
    \    return substr($x, 0, $shift).str_repeat('0', $shift - strlen($x)).substr($x,\
    \ $shift);\n}", "    $r = \"\";\n    do {\n        $d = $x % 10;\n        $x =\
    \ floor($x / 10);\n        $r = $r . $d;\n    } while (--$shift);\n    return\
    \ $r . $x;\n}", "    return $x . str_repeat(chr($shift % 256), strlen($x) - $shift);\n\
    }\n", "    $res = '';\n    while ($shift) {\n        if ($shift & 1) {\n     \
    \       $res = $res . substr($x, --$shift);\n        } else {\n            $res\
    \ = $res . substr($x, ++$shift);\n        }\n    }\n    return $res;\n}\n", " \
    \   if ($shift == 0) return \"\";\n    $digits = str_split($x);\n    return $shift\
    \ > count($digits) ? array_reverse($digits) : array_shift($digits) . array_shift($digits);\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nNot sure why you would want to reverse\
    \ the digits of the integer x to begin with. The reason I said that is because\
    \ you are converting the integer to a string and then back to an int again. It\
    \ seems redundant to convert it to a string before doing the above operation.\
    \ The solutions given here are far better though!\n<|/ c |>\n<| c |>\nThis doesn't\
    \ even work for negative numbers. You'd have to reverse the sign, convert to an\
    \ int, then reverse again. Or just use the modulus operator and avoid the string\
    \ conversion.\n<|/ c |>\n<| a |>\nA simple solution might be to use PHP's bitwise\
    \ operators to shift the binary number $x to the right.  Then, shift it back to\
    \ the left by 1 digit.\n<code>\n$x = 123;\n$right = (int)$x >> 1;\n$left = (int)$x\
    \ << 1;\n\n$r = $left | $right;\n</code>\nThat would result in $r being 123 instead\
    \ of 111.  To reverse:\n<code>\n$r = $left ^ ~$right;\n</code>\n<|/ a dscore=1\
    \ tags=bit-manipulation,algorithm,php |>\n<| a tags=bit-manipulation,algorithm,php\
    \ |>\nUsing a library like this, you can perform the manipulation in one line,\
    \ and it will also work with negative numbers.\n<code>\n$x = 123;\n$r = '';\n\
    $n = (int) ($x >> 1);\n$n = (int) ($n << 1);\n$n = bcadd($n, $n, 0, 1);\n$r =\
    \ bcadd($n, $r, 0, 1);\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\n<code>\n\
    $x = 123;\n$r = ($x >> 1) & 0x7F;\n$r = ($r << 1) & 0x7F;\n</code>\n<|/ a tags=bit-manipulation,algorithm,php\
    \ |>\n<| c |>\nYou don't need the `&`s around `$r` in the second line.\n<|/ c\
    \ |>\n<| a |>\n<code>\n$x = 123;\n$r = $x >> 1;\n$r = $r << 1;\n</code>\n<|/ a\
    \ tags=bit-manipulation,algorithm,php dscore=0 |>\n<| c |>\n$r will be 123 after\
    \ this\n<|/ c |>", "  $length = (int) strlen($x);\n  if ($shift > $length) {\n\
    \    $shift = $length;\n  }\n  $result = \"\";\n  for ($i = $length - $shift;\
    \ $i >= 0; $i -= $shift) {\n    $result = $x[$i] . $result;\n  }\n  return $result;\n\
    }\n", "    if ($shift > 0) {\n        $remainder = abs($x % $shift);\n       \
    \ $x = ($x % $shift) + $shift;\n        if ($remainder) {\n            $x = $x\
    \ - $remainder;\n        }\n    } else {\n        $x = $x + $shift - ($shift *\
    \ ($x / abs($x)));\n    }\n    return $x;\n}\n</code>\nNow the code which converts\
    \ it to binary is\n<code>", "    return str_pad(base_convert($x, 10, $shift),\
    \ strlen((string)$x) + $shift, \"0\", STR_PAD_LEFT);\n}", "  $remainder = $x %\
    \ $shift;\n  return ($remainder != 0)\n    ? $shift.'.'.circular_shift($remainder,\
    \ $shift)\n    : $shift;\n}", "    $x = abs($x);\n    $shift = abs($shift);\n\
    \    if ($shift > strlen($x)) {\n        $shift = strlen($x);\n    }\n\n    $digits\
    \ = '';\n    while ($shift > 0) {\n        $digits .= $x%10; $x = floor($x/10);\n\
    \        --$shift;\n    }\n    return $digits . $x;\n}\n", "    // Shift negative\
    \ values left as long as there are digits in the integer\n    // This handles\
    \ negative numbers properly.\n    if ($shift < 0 && $x >= 0) {\n        ++$shift;\n\
    \        --$x;\n    }\n\n    // Shift right if shift > number of digits\n    if\
    \ ($shift > strlen($x)) {\n        $x .= str_repeat('0', abs($shift) - strlen($x));\n\
    \    }\n\n    // Slice off the first $shift digits\n    return substr($x, $shift);\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a tags=php,math,modulo,bit-manipulation dscore=0\
    \ |>\n<code>\n<?php\n$input = \"12345\";\n", "    $x = $x >> $shift;\n    $x |=\
    \ $x << $shift;\n    return ($x >> $shift) . '' . $x & 1M;\n}", "  $digits = intval($x);\n\
    \  if ($digits === 0) {\n    return '0';\n  }\n  if ($shift > 0) {\n    return\
    \ $x % $shift ? circular_shift($x / $shift, $shift) . str_repeat('0', $shift)\
    \ : '0';\n  }\n  return str_repeat('9', $digits - 1) . str_pad($x % $shift, $shift,\
    \ '0');\n}\n</code>\n<|/ a dscore=0 tags=bit-shift,php,binary |>\n<| c |>\n`circular_shift(\
    \ 0x80000000, 0x100000000 )` is \"0\", which should be an error. I think you meant\
    \ `circular_shift( 0x80000000, 0x100000000 ) - 1`.\n<|/ c |>\n<| a dscore=0 |>\n\
    I've had a similar problem and found this solution:\n<code>\n<?php\n$bin = bindec('0b111111111111111111111111');\n\
    $twos = bindec('0b100000000000');\n$bin = $bin + (pow($twos, 8) - $bin) * 8;\n\
    echo \"$bin\\n\";\n</code>\n<|/ a tags=bit-shift,php,binary |>\n<| a |>\n<code>\n\
    $bin = bindec('0b111111111111111111111111');\n$twos = bindec('0b100000000000');\n\
    \n$bin = $bin + (pow($twos, 8) - $bin) * 8;\n\necho $bin;\n</code>\n<|/ a tags=bit-shift,php,binary\
    \ dscore=0 |>\n<| c |>\nPlease explain your answer\n<|/ c |>\n<| c |>\nPlease\
    \ don't post only code as answer, but also provide an explanation what your code\
    \ does and how it solves the problem of the question. Answers with an explanation\
    \ are usually more helpful and of better quality, and are more likely to attract\
    \ upvotes.\n<|/ c |>\n<| c |>\nWhy do you believe that this code is correct? What\
    \ is wrong with the OP's original code?\n<|/ c |>\n<| c |>\nThis code has two\
    \ issues: 1. it doesn't handle negative numbers. 2. It fails if the first bit\
    \ is 0. The second issue is easily solved by negating the result of the last line\
    \ `$bin + (pow($twos, 8) - $bin) * 8;`\n<|/ c |>\n<| a tags=bit-shift,php,binary\
    \ dscore=0 |>\n<code>\n<?php\n\n$bin = bindec('0b111111111111111111111111');\n\
    $twos = bindec('0b100000000000');\n\n$bin", "    $digits = str_split($x);\n  \
    \  array_shift($digits);\n    return implode('', array_slice($digits, 0, $shift));\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a |>\nThis is my solution:\n<code>", "  $shift\
    \ %= strlen($x);\n  return $x . str_repeat(substr($x, $shift), strlen($x) - $shift);\n\
    }\n", "    $result = \"\";\n    $remainder = $x % $shift;\n\n    while ($shift\
    \ > 0 && $remainder >= $shift) {\n        $result .= $shift . $x;\n        $x\
    \ = $x >> $shift;\n        $shift -= $shift;\n        $remainder = $x % $shift;\n\
    \    }\n    if ($remainder > 0) {\n        $result .= $shift . $x;\n    }\n  \
    \  return $result;\n}\n</code>\n<|/ a tags=php,math,bit-shift dscore=0 |>\n<|\
    \ a tags=php,math,bit-shift |>\n<code>", "\tif ($shift > strlen($x)) {\n\t\t$x\
    \ = strrev($x);\n\t\t$shift = strlen($x) + $shift;\n\t}\n\tfor ($i = strlen($x)\
    \ - 1; $i >= 0; $i--) $x[$i] = $x[$i] << $shift;\n\treturn implode('', $x);\n\
    }\n", "  $digits = str_split($x);\n  if (count($digits) > $shift) {\n    return\
    \ implode('', array_reverse(array_slice($digits, $shift)));\n  }\n  return implode('',\
    \ array_slice($digits, 0, $shift));\n}\n", "    $digits = strlen($x);\n    if\
    \ ($digits > $shift) {\n        $x = $x . str_repeat('0', $shift - $digits);\n\
    \    }\n    return $x;\n}\n", "\treturn (string) substr($x, ($shift = $shift %\
    \ strlen($x)) > 0 ? $shift : strlen($x));\n}", "    if ($shift > strlen($x)) {\n\
    \        return strrev($x);\n    }\n    else {\n        $r = $x;\n        $carry\
    \ = 0;\n        for ($i = 0; $i < $shift; $i++) {\n            $r = ($r * 10)\
    \ + (int)($carry);\n            $carry = $r % 10;\n            $r /= 10;\n   \
    \     }\n        if ($r != 0) {\n            $r .= $carry;\n        }\n      \
    \  return $r;\n    }\n}\n", "  if ($shift < 0) {\n    return strrev($x);\n  }\n\
    \  $string = '';\n  $shift = abs($shift);\n  while ($shift) {\n    $digit = $x\
    \ % 10;\n    $x = floor($x / 10);\n    if ($shift--) {\n      $string .= $digit;\n\
    \    }\n    else {\n      $string .= $digit . strrev($digit);\n    }\n  }\n  return\
    \ $string;\n}", "    $digits = strlen((string)$x);\n    if ($digits <= $shift)\
    \ {\n        return $x;\n    }\n    return str_pad(substr($x, 0, -$shift), $shift,\
    \ '0');\n}\n", "    if ($shift > strlen($x))\n        return strrev($x);\n   \
    \ $y = \"\";\n    for ($i = strlen($x); $i > $shift; $i--) {\n        $y .= substr($x,\
    \ $i - $shift, 1);\n    }\n    return $y;\n}", "    $digits = strlen($x);\n  \
    \  if ($shift == 0) return $x;\n    if ($shift >= $digits) return str_repeat(\"\
    0\", $digits);\n    $xlen = $digits - $shift;\n    $x = str_pad($x, $xlen, \"\
    0\", STR_PAD_LEFT);\n    $xlen = strlen($x);\n    return substr($x, $xlen + $shift);\n\
    }\n</code>\n<|/ a |>\n<| a tags=php,date dscore=0 |>\n<code>\n<?php\n\n    function\
    \ Circular_shiftLeft($number, $shift) {\n      $digits = strlen($number);\n  \
    \    if ($shift == 0) return $number;\n      if ($shift >= $digits) return str_repeat(\"\
    0\", $digits);\n      $xlen = $digits - $shift;\n      $x = str_pad($number, $xlen,\
    \ \"0\", STR_PAD_LEFT);\n      $xlen = strlen($x);\n      return substr($x, 0,\
    \ $shift).substr($x, $shift);\n    }\n\n    $test = \"20\";\n    echo Circular_shiftLeft($test,\
    \ 1);\n    echo Circular_shiftLeft($test, 2);\n    echo Circular_shiftLeft($test,\
    \ 3);\n    echo Circular_shiftLeft($test, 4);", "    if ($shift > strlen($x))\
    \ {\n        return $x;\n    }\n\n    $x = str_split($x);\n    $shift = $shift\
    \ % strlen($x[0]);\n    $newX = array();\n    foreach ($x as $xk => $xv) {\n \
    \       $newX[$xk] = $xv + $shift >= strlen($x[$xv]) ? $x[$xv] : $x[$xv] + $shift;\n\
    \    }\n    return implode('', $newX);\n}\n", "    $result = \"\";\n    if ($shift\
    \ > strlen($x)) {\n        $shift = strlen($x);\n    }\n    for ($i = 0; $i <\
    \ $shift; $i++) {\n        $result = $x[$i] . $result;\n    }\n    for ($i = $shift;\
    \ $i < strlen($x); $i++) {\n        $result = $result . $x[$i];\n    }\n    return\
    \ $result;\n}\n", "    if ($shift > strlen($x)) {\n        return $x;\n    }\n\
    \n    $digits = strlen($x);\n    $shift %= $digits;\n    return substr($x, 0,\
    \ $shift) . substr($x, $shift, $digits);\n}\n</code>\n<|/ a dscore=5 |>\n<| c\
    \ |>\nI suggest `substr` instead of `substr_replace` as it will save you some\
    \ cycles if your string contains lots of repeated characters.\n<|/ c |>\n<| c\
    \ |>\n`substr` is faster. `substr_replace` is slightly more versatile. `substr_replace`\
    \ is only faster because it's not a built-in function, but I wouldn't use that\
    \ either. You also probably need to do `$x = rtrim($x, '0');` after the loop if\
    \ you do this. See [this answer](http://stackoverflow.com/questions/4853211/how-to-replace-a-character-with-another-character-in-php/5899261#5899261)\
    \ for an explanation of why.\n<|/ c |>\n<| c |>\n`substr_replace` was introduced\
    \ in PHP 5.4.0.\n<|/ c |>\n<| c |>\nYes, you're right. I just realized and fixed\
    \ the code after your comment.\n<|/ c |>\n<| c |>\nNice! But what about performance\
    \ issues if you have a lot of strings to replace (lets say thousands of them)?\n\
    <|/ c |>\n<| a dscore=5 |>\nI always found this approach simple and effective:\n\
    <code>\n$x = str_repeat('0', $len) . str_pad($x, $len, \"0\", STR_PAD_LEFT);\n\
    </code>\nThis creates an array of zeroes, then adds your input string to the start\
    \ of those zeroes. Finally, it pads the beginning with zeroes again.\n<|/ a tags=string,replace,php\
    \ |>\n<| c |>\nThanks, but this doesn't work if `$len` is less than or equal to\
    \ `strlen($x)`.\n<|/ c |>\n<| a |>\nI wrote a function to generate all possible\
    \ combinations of string replacement with different replacements. This way you\
    \ can pass any number of replacements (even a lot of replacements) you need:\n\
    <code>", "    $digits = str_split(str_pad(decbin($x), $shift, '0', STR_PAD_LEFT));\n\
    \    return $shift > strlen($x) ? array_reverse($digits) : $digits;\n}\n", " \
    \   $num_digits = count(preg_split('//', strval($x)));\n    if ($shift >= $num_digits)\
    \ {\n        return strval(array_reverse($x));\n    }\n    return strval(array_slice($x,\
    \ $shift, $num_digits - $shift));\n}\n</code>\nThis implementation is tested and\
    \ works just fine (though it will break for non-positive integers, which is undesirable\
    \ behavior).\n<|/ a tags=php,math |>\n<| a dscore=3 |>\nHere's another alternative\
    \ to Ben Jones's answer that works for negative numbers also:\n<code>", "    $shifted\
    \ = $x >> $shift;\n\n    if ($shift == 0) return $x;\n\n    if ($shift == -1)\
    \ return strrev($shifted);\n\n    return $shifted . str_repeat(chr($shifted >>\
    \ 8), $shift % 8);\n}\n</code>\nAnd this is the output:\n\n<code>\n<?php\n\necho\
    \ circular_shift(12, 1) . \"\\n\";\necho circular_shift(12, 2) . \"\\n\";\necho\
    \ circular_shift(12, 3) . \"\\n\";\necho circular_shift(12, 4) . \"\\n\";\necho\
    \ circular_shift(12, 5) . \"\\n\";\necho circular_shift(12, 6) . \"\\n\";\necho\
    \ circular_shift(12, 7) . \"\\n\";\necho circular_shift(12, 8) . \"\\n\";\necho\
    \ circular_shift(12, 9) . \"\\n\";\necho circular_shift(12, 10) . \"\\n\";\necho\
    \ circular_shift(12, 11) . \"\\n\";\necho circular_shift(12, 12) . \"\\n\";\n\
    echo circular_shift(12, 13) . \"\\n\";\necho circular_shift(12, 14) . \"\\n\"\
    ;\necho circular_shift(12, 15) . \"\\n\";\necho circular_shift(12, 16) . \"\\\
    n\";\necho circular_shift(12, 17) . \"\\n\";\necho circular_shift(12, 18) . \"\
    \\n\";\necho circular_shift(12, 19) . \"\\n\";\necho circular_shift(12, 20) .\
    \ \"\\n\";\necho circular_shift(12, 21) . \"\\n\";\necho circular_shift(12, 22)\
    \ . \"\\n\";\necho circular_shift(12, 23) . \"\\n\";\necho circular_shift(12,\
    \ 24) . \"\\n\";\necho circular_shift(12, 25) . \"\\n\";\necho circular_shift(12,\
    \ 26) . \"\\n\";\necho circular_shift(12, 27) . \"\\n\";\necho circular_shift(12,\
    \ 28) . \"\\n\";\necho circular_shift(12, 29) . \"\\n\";\necho circular_shift(12,\
    \ 30) . \"\\n\";\necho circular_shift(12, 31) . \"\\n\";\necho circular_shift(12,\
    \ 32) . \"\\n\";\necho circular_shift(12, 33) . \"\\n\";\necho circular_shift(12,\
    \ 34) . \"\\n\";\necho circular_shift(12, 35) . \"\\n\";\necho circular_shift(12,\
    \ 36) . \"\\n\";\necho circular_shift(12, 37) . \"\\n\";\necho circular_shift(12,\
    \ 38) . \"\\n\";\necho circular_shift(12, 39) . \"\\n\";\necho circular_shift(12,\
    \ 40) . \"\\n\";\necho circular_shift(12, 41) . \"\\n\";\necho circular_shift(12,\
    \ 42) . \"\\n\";\necho circular_shift(12, 43) . \"\\n\";\necho circular_shift(12,\
    \ 44) . \"\\n\";\necho circular_shift(12, 45) . \"\\n\";\necho circular_shift(12,\
    \ 46) . \"", "    if ($shift > strlen($x)) {\n        return strrev($x);\n   \
    \ }\n    if ($shift == 0) {\n        return $x;\n    }\n    $remainder = strlen($x)\
    \ % $shift;\n    $return = '';\n    if ($remainder) {\n        $return = substr($x,\
    \ $shift, $remainder);\n    }\n    return $return.substr($x, 0, -$shift).$return;\n\
    }\n", "  $str = intval($x);\n  $shift %= strlen($str);\n  return $str[strlen($str)-$shift]\
    \ . $str;\n}\n", "    $digits = '';\n    while (count(str_split($x)) > $shift)\
    \ {\n        $x = str_split($x);\n        $digits = array_shift($x).$digits;\n\
    \    }\n    return implode('', $x).$digits;\n}\n</code>\nThis works by repeatedly\
    \ splitting the string into digits (str_split($x)).  It stops splitting when it\
    \ reaches $shift-count(str_split($x)) and then joins all the digits together.\
    \  It uses array_shift to pull off the last digit (array_shift($x)) and then implode\
    \ to put it back together into one string.\nDemo\n<|/ a |>\n<| c |>\nWhile I like\
    \ this algorithm, it actually has many problems. It does not handle negative numbers,\
    \ infinite numbers, decimal numbers, etc. I would not use it in a real life situation,\
    \ but it's good to see it working. However, I'm a little confused. I thought that\
    \ `array_shift` would shift from its first argument, but then it returns an array\
    \ with the shifted value, which would overwrite the original array. Why the `array_shift`?\
    \ What does it do?\n<|/ c |>\n<| c |>\nOops, you're correct.  I forgot the `array_shift`\
    \ when writing the answer.  Thanks for catching that.\n<|/ c |>\n<| c |>\nNice.\
    \ Can you explain why `array_shift` returns an array instead of just shifting\
    \ off the value? I'm pretty confused at this point.\n<|/ c |>\n<| c |>\n`str_split`\
    \ returns an array of characters, so we need to `array_shift` to get the last\
    \ character.  It would be a bit cleaner if array_shift returned a single character\
    \ instead of an array.\n<|/ c |>\n<| c |>\nThe `array_shift` actually returns\
    \ just a single character from the array. It's not designed to remove the last\
    \ element from the array. So the return type is not actually an array, but rather\
    \ a string. `array_shift` is also quite a bit faster than `array_pop` because\
    \ it avoids needing to move anything around in memory.\n<|/ c |>\n<| a tags=php,string,number-formatting\
    \ dscore=3 |>\nHere's a fairly simple method that should work well enough for\
    \ you:\n<code>", "    return $x ^ ($x >> ($shift = $shift < 0 ? 0 : $shift));\
    \ \n}\n", "    if ($shift > strlen($x)) {\n        return strrev($x);\n    }\n\
    \n    $r = substr($x, 0, $shift);\n    $x = substr($x, $shift);\n\n    $i = 0;\n\
    \    while ($i < strlen($r)) {\n        $r = $r . substr($x, $i++, 1);\n    }\n\
    \n    return $r;\n}\n\n/**\n * Given a binary string (0 to 1) convert it to decimal\
    \ string\n * using radix 16\n *\n * Examples of binary to decimal conversion:\n\
    \ *\n * \"0\" => 0\n * \"1\" => 1\n * \"10\" => 16\n * \"11\" => 17\n * \"100\"\
    \ => 256\n * \"101\" => 257\n * \"110\" => 6552\n * \"111\" => 6553\n */", " \
    \   if ($shift > 0) {\n        $x = $x - ($x % $shift);\n        $x = $x + ($shift\
    \ - 1);\n    } else {\n        $x = $x + ($shift - 1);\n        $x = $x - ($x\
    \ % $shift);\n    }\n    return $x;\n}", "    $len = strlen($x);\n    if ($shift\
    \ > $len) {\n        $shift = $len;\n    }\n    $x = ''.$x;\n    $n = strlen($x);\n\
    \    for ($i = 0; $i < $shift; $i++) {\n        $x = substr($x, 1);\n        $n\
    \ = strlen($x);\n    }\n    $x = substr($x, 0, $n);\n    return $x;\n}\n</code>\n\
    And here is a test script:\n<code>\n<?php\n$tests = array(\n    array(12, 1),\n\
    \    array(12, 2),\n);\n\nforeach ($tests as $test) {\n    echo sprintf(\"%s =>\
    \ %s\\n\", $test[0], circular_shift($test[0], $test[1]));\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nAwesome! This is really helpful.\n<|/ c |>\n<| c |>\nNo problem,\
    \ glad I could help.\n<|/ c |>\n<| c |>\nI did a quick test and I seem to be getting\
    \ wrong results for most of the results from this script. I think my test script\
    \ was too simple and missed some cases. I added a test case to my question above.\
    \ Can you try it again?\n<|/ c |>\n<| c |>\nYes, I had a typo. My test case had\
    \ the result \"12\" instead of \"21\". I fixed it and it works now. Thank you\
    \ so much for your help.\n<|/ c |>\n<| a dscore=2 |>\n<code>\n$val  = 12;\n$shift\
    \ = 2;\n$length = strlen($val);\n\nif ($shift >= $length) {\n   return $val;\n\
    }\n\n$new = '';\nfor ($i = 0; $i < $shift; $i++) {\n   $new .= substr($val, $i\
    \ + 1);\n}\nreturn $new;\n</code>\n<|/ a tags=php,algorithm |>\n<| a tags=php,algorithm\
    \ |>\n<code>\n$x = 12;\n$shift = 3;\n$r = \"\";\n$m = pow($x, $shift);\nfor($i=1;$i<$shift;$i++)\
    \ {\n    $r = $r.($m%10);\n    $m = ($m/10);\n}\nprint $r;\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=php,algorithm |>\nThis is an alternative to Tim's answer. Although\
    \ it only uses PHP functions:\n<code>\n<?php\n", "  $x = abs($x); // Make sure\
    \ we handle negative numbers\n  $shift = abs($shift); // Make sure we handle negative\
    \ shift amounts\n\n  // Shift negative amount left first\n  if ($shift < 0) {\n\
    \    $shift += $x->bitLength();\n    $x = $x->changeSign();\n  }\n  $len = $x->bitLength();\n\
    \  $shift = $len - $shift;\n  $mask = (1<<$shift) - 1;\n  $x->mask($mask); //\
    \ Apply mask\n  $x = $x->changeSign(); // Shift right to align shifted digits\
    \ left\n\n  // Shift digits by shift\n  $result = $x->toDec();\n  for ($i = $shift;\
    \ $i > 0; $i--) {\n    $result = ($result * 10) + ($result & 1);\n  }\n\n  //\
    \ Shift right to align digits right\n  $result = $x->toDec();\n  for ($i = 0;\
    \ $i < $shift; $i++) {\n    $result = ($result * 10) + ($result & 1);\n  }\n\n\
    \  return $result;\n}\n", "  $str = \"\";\n  $n = strlen($x);\n  for($i = 0; $i\
    \ < $shift && $i < $n; $i++) {\n    $str .= $x[$i];\n  }\n  $c = $n - $shift;\n\
    \  for ($i = 0; $i < $c; $i++) {\n    $str .= $x[$i + $shift];\n  }\n  return\
    \ $str;\n}", "  $digits = strlen($x);\n  $reversed_digits = $digits < $shift ?\
    \ $digits : $shift;\n  if ($digits > $shift) {\n    $result = substr($x, 0, $shift);\n\
    \    $result .= substr($x, $reversed_digits);\n    return $result;\n  } else {\n\
    \    $result = substr($x, 0, $digits);\n    $result .= substr($x, $reversed_digits,\
    \ $shift);\n    return $result;\n  }\n}\n", "    $str = '';\n    if ($shift >\
    \ strlen($x)) {\n        for ($i = strlen($x); $i < $shift; $i++) {\n        \
    \    $str .= $x[$i];\n        }\n        return $str;\n    }\n\n    for ($i =\
    \ 0; $i < $shift; $i++) {\n        $str .= $x[$i + $shift];\n    }\n    return\
    \ $str;\n}\n", "    // $x is an integer\n    // $shift is an integer, positive\
    \ or negative\n    $xstr = strval($x);\n    if ($shift >= 0) {\n        $shiftstr\
    \ = strval($shift);\n        $x_parts = str_split($xstr);\n        $shiftstr_parts\
    \ = str_split($shiftstr);\n        $x_parts[] = array_shift($shiftstr_parts);\n\
    \        $x = implode('', $x_parts);\n    }\n    $xstr = strrev($xstr);\n    $xstr\
    \ = $xstr . $shiftstr;\n    $xstr = strrev($xstr);\n    return $xstr;\n}\n", " \
    \   $digits = str_split($x);\n    $n = 0;\n    foreach ($digits as $digit) {\n\
    \        $n = ($n * 10 + $digit) % 10 - $shift;\n    }\n    return $n === 0 ?\
    \ $digits[0] : $digits[$n];\n}\n", "    $num = $x;\n    for ($i = 0; $i < $shift;\
    \ $i++) {\n        $num = 11 * $num + $i << 1;\n    }\n    return $num % 11;\n\
    }\n", "\tif ($shift == 0) return $x;\n\t$s = $shift < 0 ? -$shift : $shift;\n\t\
    $shift = strlen($x) - $s;\n\t$result = \"\";\n\t$remainder = 0;\n\tfor ($i = 0;\
    \ $i <= $shift; $i++) {\n\t\t$remainder = $remainder + $x[$i];\n\t\t$result =\
    \ $result . chr($remainder);\n\t}\n\treturn $result . str_repeat(\"0\", $shift);\n\
    }", "    $digits = str_split($x);\n    $shift = abs($shift);\n    if ($shift >\
    \ count($digits)) {\n        $digits = array_slice($digits, 0, $shift);\n    }\
    \ else {\n        $digits = array_slice($digits, 0, $shift);\n        $digits\
    \ = array_slice($digits, 0, $shift - 1);\n    }\n    return implode('', $digits);\n\
    }", "    $x = intval($x);\n    if ($shift > strlen($x)) {\n        $x = strrev($x);\n\
    \        return $x;\n    }\n    $sign = ($x<0) ? '-' : '';\n    $shift = abs($shift);\n\
    \    $digits =  $shift - ($shift % strlen($x)); // shift % number of digits, for\
    \ last shift\n    return $sign . $digits = str_pad(substr($x, strlen($x) - $digits,\
    \ $digits), $shift, \"0\", STR_PAD_LEFT);\n}\n</code>\nAnd now you can simply\
    \ do:\n<code>\necho circular_shift($x, 4);\n</code>\n<|/ a tags=php,bit-manipulation\
    \ |>\n<| c |>\nThis code does work, but `circular_shift()` only works on positive\
    \ numbers, and `strrev()` reverses a string, and so only works on strings of length\
    \ 1 or greater.  I believe this answer has a bug in it.  For example, `echo circular_shift(12,\
    \ 2);` returns `10` when it should be `12`.  To fix this, simply change `$sign\
    \ = ($x<0) ? '-' : '';` to `$sign = ($x<0) ? '' : '';` and then `$digits = $shift\
    \ - ($shift % strlen($x));` to `$digits = $shift - ($shift % strlen($x) + 1);`.\n\
    <|/ c |>\n<| c |>\nOops looks like I did not read this code thoroughly enough,\
    \ you are correct. I've updated the answer to fix this.\n<|/ c |>\n<| a |>\nYou\
    \ can use bit shift operations in PHP to achieve the result.\n<code>\n<?php\n\n\
    $x = 511;\necho (1 << $x) ^ $x;\n</code>\nOutput:\n<code>\n1000\n</code>\nThe\
    \ above code shifts the number by $x places to the left. Then, XORs the number\
    \ with the original number.\n<|/ a tags=php,bit-manipulation dscore=5 |>\n<| c\
    \ |>\nThis is great! But how would you do this for a multidimensional array?\n\
    <|/ c |>\n<| c |>\n: You could write a recursive function to do that, or you could\
    \ do it with a `foreach` loop, or you could do it with a `for` loop, or you could\
    \ do it with a `while` loop, or you could do it with an array-walk function. Which\
    \ approach is best will depend on what you're trying to accomplish. Are you trying\
    \ to shift all of the numbers in the array, or just some of them? Or do you want\
    \ to shift them \"in place\"?\n<|/ c |>\n<| c |>\nThe reason I ", "    $r = $x;\n\
    \    for($i = 0; $i < $shift; $i++)\n        $r = (10 * $r) % MOD;\n    return\
    \ $r;\n}\n", "  $xstr = strval($x);\n  $xlen = strlen($xstr);\n  $shift = intval($shift);\n\
    \  $shift = $shift % $xlen;\n  if ($shift == 0)\n    return $xstr;\n  $xstr =\
    \ $xstr[$shift];\n  $shift = $xlen - $shift;\n  if ($shift > 0)\n    return $xstr\
    \ . str_repeat($xstr[0], $shift);\n  return strrev($xstr) . str_repeat($xstr[0],\
    \ $shift);\n}\n", "    $reversed = \"\";\n    $remainder = 0;\n    while ($shift\
    \ > 0 && $x) {\n        $reversed = $x % 10 + $reversed;\n        $x = floor($x\
    \ / 10);\n        $remainder = $remainder + ($x % 10);\n        $shift = $shift\
    \ - 1;\n    }\n\n    if ($shift > 0 && $x) {\n        $reversed = $x % 10 + $reversed;\n\
    \    }\n    return strrev($reversed) + strrev($remainder);\n}\n", "    if ($shift\
    \ > strlen($x)) {\n        return strrev($x);\n    }\n    $digits = str_split($x);\n\
    \    return implode('', array_slice($digits, $shift - strlen($digits)));\n}\n",
  "    $ret = $x;\n    $shift = strlen($shift);\n    while ($shift > strlen($x)) {\n\
    \        $ret .= $shift!==strlen($x) ? substr($x, strlen($x)-$shift) : '';\n \
    \       $shift -= strlen($x);\n    }\n    return $ret.$x;\n}\n", "    if ($shift\
    \ == 0) {\n        return 0;\n    }\n    if ($shift > strlen($x)) {\n        return\
    \ $x;\n    }\n    $result = '';\n    while ($shift > 0) {\n        $result = $x[$shift\
    \ - 1] . ($result ? str_repeat('0', 7 - $shift) : '');\n        $shift--;\n  \
    \  }\n    return $result;\n}\n", "  $digits = str_split($x);\n  $digits_length\
    \ = strlen($digits);\n\n  if ($digits_length <= $shift) {\n    return $digits;\n\
    \  }\n\n  $result = $x;\n  $carry = 0;\n  for ($i = 0; $i < $digits_length; $i++)\
    \ {\n    $result = $result * 10 + $digits[$i] + $carry;\n    $carry = $result\
    \ / 10;\n    $result = $result % 10;\n  }\n  if ($carry) {\n    $result = $result\
    \ + $carry;\n  }\n  return str_pad(substr($result, 0, $shift), $shift, '0', STR_PAD_LEFT);\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThanks, your response is very helpful and I learned\
    \ something new about `bcmath` so I learned a lot.  However, when I try to run\
    \ your code I get the following error:  `Parse error: syntax error, unexpected\
    \ ';', expecting '(' in C:\\wamp\\www\\test\\test.php on line 3`  I am unsure\
    \ of what to do from here.  I have updated my original post with the code that\
    \ I am using.\n<|/ c |>\n<| c |>\n: You put a semicolon after `echo $result;`,\
    \ remove it.\n<|/ c |>\n<| c |>\nYes, I do that in my real code and the semicolon\
    \ didn't exist in the example.  I removed it and the error still persists.\n<|/\
    \ c |>\n<| a tags=php,rounding,math dscore=0 |>\nI modified the code so that it\
    \ returns a float instead of a string which I believe is what you want. \n<code>\n\
    <?php", "    $result = '';\n    $shiftLength = strlen($shift);\n    $shiftRemainder\
    \ = $shiftLength % 2 == 1;\n    $x = abs($x);\n    if ($x < 10) {\n        return\
    \ str_pad($x, $shiftLength, $shift);\n    } elseif ($x < 100) {\n        return\
    \ str_pad(floor($x / 10) * 10, $shiftLength, $shift);\n    } elseif ($x < 1000)\
    \ {\n        return str_pad(floor($x / 100) * 100, $shiftLength, $shift);\n  \
    \  } elseif ($x < 10000) {\n        return str_pad(floor($x / 1000) * 1000, $shiftLength,\
    \ $shift);\n    } elseif ($x < 100000) {\n        return str_pad(floor($x / 10000)\
    \ * 10000, $shiftLength, $shift);\n    } elseif ($x < 1000000) {\n        return\
    \ str_pad(floor($x / 100000) * 100000, $shiftLength, $shift);\n    } elseif ($x\
    \ < 10000000) {\n        return str_pad(floor($x / 1000000) * 1000000, $shiftLength,\
    \ $shift);\n    } elseif ($x < 100000000) {\n        return str_pad(floor($x /\
    \ 10000000) * 10000000, $shiftLength, $shift);\n    } else {\n        return str_pad(floor($x\
    \ / 100000000) * 100000000, $shiftLength, $shift);\n    }\n}", "    $digits =\
    \ base_digits($x);\n    if ($shift < 0 || $shift >= $digits) {\n        return\
    \ $x;\n    }\n    $digits = base_digits($x);\n    if ($shift > 0) {\n        $digits\
    \ = array_reverse($digits);\n    }\n    return implode('', array_slice($digits,\
    \ 0, $shift)) . array_slice($digits, $shift);\n}\n\n/**\n * Format a number as\
    \ a percentage.\n *\n * @param float $value A floating point number\n * @param\
    \ int $precision The precision of the calculation\n *\n * @return string The percentage\
    \ formatted as a string\n */", "    $xstr = (string)$x;\n    $xlen = strlen($xstr);\n\
    \    $result = '';\n    if ($shift > $xlen) {\n        $shift = $xlen;\n    }\n\
    \    for ($i = 0; $i < $shift; $i++) {\n        $result .= substr($xstr, $xlen\
    \ - $i, 1);\n    }\n    for ($i = 0; $i < $xlen; $i++) {\n        $result .= substr($xstr,\
    \ $i, 1);\n    }\n    return $result;\n}", "    if ($shift > strlen($x)) {\n \
    \       return $x;\n    }\n    return substr($x, $shift, strlen($x)) . substr($x,\
    \ 0, $shift);\n}\n", "  $digits = base_convert($x, 10, 2);\n  return str_pad(base_convert($digits,\
    \ 10, 2), $shift, '0', STR_PAD_LEFT);\n}\n</code>\nIf you need to use this a lot,\
    \ you can wrap it in a function.\n<|/ a |>\n<| c |>\nYeah, that's what I figured.\
    \ Just wanted to make sure there wasn't an easier way first.\n<|/ c |>\n<| c |>\n\
    The best way would be to implement a circular shift in the language you already\
    \ use to implement the code. PHP has [bitwise operators](https://secure.php.net/manual/en/language.operators.bitwise.php)\
    \ which would make this easy.\n<|/ c |>\n<| c |>\nI wouldn't implement this in\
    \ PHP, as PHP would not be able to use these bitwise operators.\n<|/ c |>\n<|\
    \ c |>\nIf you were writing an embedded system you might be able to use something\
    \ from the STM32 family. Otherwise you would need to implement the algorithm in\
    \ assembly language or a language with a similar instruction set as the one the\
    \ CPU is running on. I'm guessing you would need to write a lot of code.\n<|/\
    \ c |>\n<| c |>\nYeah that was my first thought. Since it would be a small embedded\
    \ system, I was going to try and write a program in C. I was just hoping someone\
    \ else had already done it.\n<|/ c |>\n<| a |>\nPHP does not have bitwise operators.\
    \ That would require a library which isn't available on most platforms. You could\
    \ use the GMP library to deal with big numbers. \nHere's a solution that uses\
    \ recursion:\n<code>", "  $result = $x;\n  while ($shift > strlen($result)) {\n\
    \    $result .= $x;\n  }\n  $result = '';\n  while (strlen($result) < $shift)\
    \ {\n    $result .= $x;\n  }\n  return $result;\n}", "\t$xstr = \"\";\n\twhile\
    \ ($shift >= 0) {\n\t\t$xstr = ($xstr + ($x % 10)) % 10;\n\t\t$x = floor($x /\
    \ 10);\n\t\t$shift -= strlen($xstr);\n\t}\n\tif ($shift > 0) {\n\t\t$xstr = ($xstr\
    \ + ($x % 10)) % 10;\n\t\t$x = floor($x / 10);\n\t}\n\treturn $xstr;\n}\n", " \
    \   if ($shift > strlen($x)) {\n        return strrev($x);\n    }\n    return\
    \ substr($x, 0, $shift).(string)((int)($x) % pow(10, $shift)).substr($x, $shift);\n\
    }\n", "\tif ($shift == 0)\n\t\treturn $x;\n\tif ($shift > strlen($x))\n\t\treturn\
    \ $x . array_reverse(str_split($x, $shift, 1));\n\treturn str_split($x, $shift,\
    \ 1);\n}\n", "  $shift = (int) $shift;\n  $result = \"\";\n  $len = strlen($x);\n\
    \  for ($i = $shift; $i < $len; $i++) {\n    $result .= $x[$len - ($i + 1)];\n\
    \  }\n  return $result;\n}", "  $len = (string)($x >> $shift);\n  $digits = strlen((string)($x\
    \ >> $shift));\n  while ($shift < $len) {\n    $x = $x >> 1;\n    $shift++;\n\
    \  }\n  return str_pad((string)($x >> $shift), $len, '0', STR_PAD_LEFT);\n}\n",
  "    if ($shift > strlen($x))\n        return strrev($x);\n    if ($shift == strlen($x))\n\
    \        return $x;\n    $result = \"\";\n    while ($shift > 0) {\n        $result\
    \ = $x{$shift} . $result;\n        $shift--;\n    }\n    return $result;\n}\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't work for numbers bigger than\
    \ 128, and I'm sure it could be optimized (like maybe looping backwards instead\
    \ of forwards).\n<|/ c |>\n<| c |>\nThis code was originally written by myself,\
    \ so I don't have the time to optimize it. Maybe someone else will optimize it.\n\
    <|/ c |>\n<| a dscore=0 |>\nTry this:\n<code>", "    $digits = str_split($x);\n\
    \    $n_digits = count($digits);\n    if ($shift == 0)\n        return $x;\n \
    \   elseif ($shift > $n_digits)\n        return array_reverse(str_split($x));\n\
    \    else\n        return str_pad('', $shift, '0') . array_shift($digits);\n}\n",
  "  $digits = str_split($x);\n  array_walk(\n    $digits,\n    function (&$digit,\
    \ $i) use ($digits, $shift) {\n      if ($i > $shift) {\n        $digit = array_shift($digits);\n\
    \      }\n    },\n    array_fill(0, $shift, array_shift($digits))\n  );\n\n  return\
    \ implode('', $digits);\n}\n", "    return ($x & ($x >> $shift)) >> ($shift &\
    \ 0x1F);\n}\n", "  // shift the digits of $x right by $shift amount, and return\
    \ the result.\n  // shift the digits right by $shift amount and return the result.\n\
    \  // shift the digits right by $shift amount and return the result.\n  $x = $x\
    \ ^ ($x >> $shift);\n  $x = $x ^ ($x >> (32 - $shift));\n  return $x ^ ($x >>\
    \ $shift);\n}\n</code>\n<|/ a tags=php,bitwise-operators,bit-manipulation,bit-shift\
    \ dscore=2 |>\n<| c |>\nI did a test and it seems that this method is not very\
    \ efficient. It takes about 4 seconds to execute a test with $num = 7878787878787878\
    \ , $shift = 1000000000\n<|/ c |>\n<| c |>\nYou're right. I've edited the function\
    \ to implement the method from [this answer](https://stackoverflow.com/a/53762431/13476199).\
    \ It's faster now. :-)\n<|/ c |>\n<| a tags=php,bitwise-operators,bit-manipulation,bit-shift\
    \ |>\nThis worked for me.\n<code>", "    return str_pad(\n        decbin($x)\n\
    \            ->binToDec()\n            ->shift($shift)\n            ->decbin()\n\
    \            ->unshift()\n            ->reverse()\n            ->str_pad('', $shift,\
    \ '0'),\n        32,\n        '0'\n    );\n}\n", "\tif ($shift >= strlen($x))\
    \ {\n\t\treturn $x;\n\t}\n\treturn substr($x, 0, $shift).(string)circular_shift(substr($x,\
    \ $shift), 1);\n}\n", "  if ($shift > strlen($x)) {\n    $x = array_reverse($x);\n\
    \    $shift = strlen($x) - $shift;\n  }\n  $digits = str_split($x);\n  $result\
    \ = array_shift($digits);\n  for ($i = 0; $i < $shift; ++$i) {\n    $result =\
    \ $result . array_shift($digits);\n  }\n  return implode('', $digits) . $result;\n\
    }\n</code>\n<|/ a tags=php |>\n<| c |>\nThis answer should be downvoted because:\
    \ 1) it is not code, but a description of a technique in general; 2) it doesn't\
    \ work if `$x === 0`, which is impossible for unsigned integers in PHP.\n<|/ c\
    \ |>\n<| a tags=php |>\n<code>", "    $result = '';\n    $shift = abs($shift);\n\
    \    if ($shift > 0) {\n        $shift %= strlen($x);\n    }\n    for($i = 0;\
    \ $i < $shift; $i++) {\n        $result .= $x[$i];\n    }\n    for ($i = strlen($x);\
    \ $i < $shift; $i++) {\n        $result .= $x[0];\n    }\n    return $result;\n\
    }\n", "    if ($shift == 0)\n        return 0;\n    if ($shift > strlen($x)) {\n\
    \        $x = strrev($x);\n        $shift = strlen($x) - $shift;\n    }\n    $digits\
    \ = array();\n    do {\n        $digits[] = substr($x, $shift, 1);\n        $shift\
    \ = $shift - 1;\n    } while ($shift > 0);\n    return join('', $digits);\n}\n",
  "  $digits = str_split($x);\n  array_walk($digits, 'circular_shift', $shift);\n\
    \  return implode('', $digits);\n}\n", "  $digits = strlen($x);\n  if ($shift\
    \ > $digits) {\n    return strrev($x);\n  }\n  $digits = $digits - $shift;\n \
    \ $result = \"\";\n  for ($i = 0; $i < $digits; ++$i) {\n    $result .= substr($x,\
    \ $i + $shift, 1);\n  }\n  return $result;\n}", "  $digits = strlen((string)$x)\
    \ < $shift ? strlen((string)$x) : $shift;\n  $reversed = strlen((string)$x) <\
    \ $shift ? strrev((string)$x) : '';\n  $reversed = str_pad($reversed, $digits,\
    \ 0, STR_PAD_LEFT);\n  return $reversed . $x->toString();\n}\n", "    $x = (string)\
    \ $x;\n    $shift = abs($shift);\n    $len = strlen($x);\n    if ($shift > $len)\
    \ {\n        return substr($x, $len - $shift);\n    }\n    if ($shift < -$len)\
    \ {\n        return substr($x, 0, -$shift);\n    }\n    $result = '';\n    $start\
    \ = 0;\n    for ($i = 0; $i < $len; $i++) {\n        $result = $result . substr($x,\
    \ $start, $shift - $start) . $x[$i];\n        if ($shift > $len - $i) {\n    \
    \        $start = $i + 1;\n        }\n    }\n    return $result;\n}\n", "    if\
    \ ($shift > strlen($x)) {\n        $shift = strlen($x);\n    }\n    $string =\
    \ '';\n    while ($shift-- > 0) {\n        $string = chr(ord($string) . $x[$shift]);\n\
    \    }\n    return $string;\n}", "  $digits = strlen($x) > strlen($shift) ? strlen($x)\
    \ : strlen($shift);\n  $result = \"\";\n  for ($i = 0; $i < $digits; $i++) {\n\
    \    $result = $x[(strlen($x) - $i - 1)] . $result . $x[(strlen($x) - $i - 2)];\n\
    \  }\n  return $result;\n}", "    $digits = strval($x);\n    $shift = strval($shift);\n\
    \    $result = '';\n    while (1) {\n        $result = $result . substr($digits,\
    \ ($shift > strlen($digits)) ? 0 : ($shift - 1), 1) . substr($digits, 0, $shift\
    \ - 1);\n        $shift--;\n        if ($shift < strlen($digits)) {\n        \
    \    $digits = substr($digits, 0, $shift);\n        } else {\n            break;\n\
    \        }\n    }\n    return $result;\n}\n</code>\n<|/ a tags=php,python,algorithm,math\
    \ |>\n<| a tags=php,python,algorithm,math dscore=4 |>\nFor a number n with two\
    \ digits, you can make a number m = (n-1)+m (mod 10) and shift m by one digit.\
    \ With this number you can calculate what m is and what n-m is. Using this method\
    \ you can calculate what m is. \nThe result is m = (n-1)+m (mod 10)\nThe shift\
    \ is n-m.\n<|/ a |>\n<| a |>\nThis is my solution:\n<code>", "    if ($shift >\
    \ strlen($x)) {\n        return $x;\n    }\n    $result = '';\n    while (--$shift\
    \ >= 0) {\n        $result = $x . $result;\n        $x = $x >> 1;\n    }\n   \
    \ return $result;\n}\n", "\t$shift = abs($shift);\n\t$digits = str_split($x);\n\
    \tif ($shift > count($digits)) {\n\t\treturn implode('', array_reverse($digits));\n\
    \t}\n\treturn implode('', array_slice($digits, $shift, $shift));\n}\n</code>\n\
    <|/ a |>\n<| a tags=php,math |>\nHere's a solution I came up with...\n<code>\n\
    <?php\n\n$input = 36;\n\nfor($x = 10; $x <= $input; $x += 10) {\n\n    $firstDigit\
    \ = floor($x / $x);\n    $secondDigit = floor($x % $x);\n\n    echo \"$firstDigit$secondDigit\"\
    ;\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis doesn't work for negative numbers.\
    \ Try `$input = -36;` to see what I mean.\n<|/ c |>\n<| c |>\nGood catch, didn't\
    \ think of that. I've updated my answer.\n<|/ c |>\n<| c |>\nI did it in a much\
    \ simpler way: `for ($i = 10; $i <= $input; $i += 10) { $firstDigit = floor($i\
    \ / $i); $secondDigit = floor($i % $i); echo \"$firstDigit$secondDigit\"; }`\n\
    <|/ c |>\n<| a tags=php,math |>\nIf you have a number you simply do this:\n<code>\n\
    $i = 96;\n$digits = explode(\"\", decbin($i));\n$res = $digits[count($digits)-1];\n\
    </code>\n<|/ a dscore=2 |>\n<| a tags=php,math |>\nI came up with a solution based\
    \ on a few answers here. \n<code>", "    $digits = strlen($x);\n    if ($digits\
    \ <= $shift) {\n        return $x;\n    }\n\n    $reversed_digits = ($shift -\
    \ $digits) + ($shift % $digits);\n    return str_pad(substr($x, $reversed_digits),\
    \ $shift, \"0\", STR_PAD_LEFT);\n}", "  $digits = base_digits($x);\n  $n = strlen($digits);\n\
    \  if ($n < $shift) {\n    $shift %= $n;\n    $digits = str_repeat('0', $n) .\
    \ $digits;\n  }\n  $digits = str_pad($digits, $shift, '0', STR_PAD_LEFT);\n  return\
    \ $digits . $digits;\n}\n\n/**\n * Returns a string with digits rotated to the\
    \ left by a given amount.\n *\n * @param string $num The integer to rotate.\n\
    \ * @param int $shift The number of digits to rotate by.\n *\n * @return string\n\
    \ */", "  if ($shift > strlen($x)) {\n    // Too many shifts, just return the\
    \ digits reversed.\n    $r = strrev($x);\n  } else {\n    // Shift to the right\
    \ by one digit.\n    $r = substr($x, $shift, 1);\n    $r = substr($r, 0, strlen($x)\
    \ - $shift);\n  }\n  return $r;\n}\n", "    if ($shift > strlen($x))\n       \
    \ return $x; // return digits reversed\n    if ($shift == 0)\n        return '';\
    \ // return empty string if shift is 0\n    $digits = str_split($x);\n    $shifted\
    \ = array_shift($digits);\n    $result = '';\n    foreach ($digits as $digit)\n\
    \        $result .= ($digit . $shifted);\n    return $result;\n}\n</code>\nA better\
    \ way that gives you more control:\n<code>\n/**\n * Returns digits in a cyclic\
    \ shifted string, starting at the beginning\n * and proceeding to the end. If\
    \ shift is negative, digits in the cycle are\n * rotated right.\n *\n * string\
    \ $x\n * int $shift Number of digits to shift\n * string Shifted digits\n */",
  "    $digits = strlen($x);\n    if ($shift == 0) return $x;\n    $digits = $digits\
    \ >> $shift;\n    $shift = $shift % $digits;\n    $x = '';\n    if ($shift < 0)\
    \ $x = str_pad($x, $digits, chr($shift));\n    else $x = str_pad($x, $digits,\
    \ chr($digits + $shift));\n    return $x;\n}\n</code>\n<|/ a |>\n<| a dscore=1\
    \ |>\nThe function will get two arguments \nthe number you want to shift and the\
    \ shift number\n<code>", "  $x = abs($x);\n  $shift = abs($shift);\n  if ($x <\
    \ 5) {\n    return ($x != 0) ? str_pad(decbin($x), 8, '0', STR_PAD_LEFT) : '0';\n\
    \  }\n  if ($shift > strlen(decbin($x))) {\n    return ($shift != 0) ? str_pad(decbin($x),\
    \ $shift, '0', STR_PAD_LEFT) : '0';\n  }\n  $digits = decbin($x);\n  $shifts =\
    \ decbin($shift);\n  while (($shift = substr($shifts, $shift - 1, 1)) === '0')\
    \ {\n    $shift = substr($shifts, 0, $shift - 1);\n  }\n  return bindec($shift\
    \ . $digits);\n}\n</code>\n<|/ a tags=javascript,php |>\n<| c |>\nNice! But why\
    \ not just `function circular_shift($x,$shift){ return decbin($x>>$shift)*pow(2,$shift);}`\
    \ ?\n<|/ c |>\n<| c |>\n: It's not possible to do that in PHP.\n<|/ c |>\n<| a\
    \ tags=javascript,php |>\nTo get shifted bits from an integer in php, use bitwise\
    \ shift operator:\n<code>\n$x = 5; // 0x5\n$shift = 2; // 0x10\n\n$result =  ($x\
    \ >> $shift); // 0xf\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThank you for your\
    \ answer but that's not what I was asking. I'm not trying to shift bits from an\
    \ integer in php, I need to shift bits from a string of hex digits into an integer.\
    \ I'm also trying to do this as efficiently as possible, no loops.\n<|/ c |>\n\
    <| c |>\nWhat you mean by \"shift bits from a string of hex digits into an integer\"\
    ? Are you trying to convert a binary string to a decimal number?\n<|/ c |>\n<|\
    \ c |>\nNo I'm not. I'm trying to convert a string of hex digits into its integer\
    \ equivalent. For example, convert \"1234\" to decimal (the number represented\
    \ by hex \"3412\"). I'm basically trying to do what the javascript function `parseInt(string,\
    \ radix)` does.\n<|/ c |>\n<| a dscore=0 tags=javascript,php |>\nThis doesn't\
    \ answer your question but maybe it helps you. \n<code>\n$hex = '1234';\nvar_dump(hexdec(bin2hex($hex)));\
    \ // 5678\n</code>\n<|/ a |>\n<| c |>\nThat works, but I need something a bit\
    \ more efficient, as it's looping through an array of hex digits. ", "    if ($shift\
    \ > strlen($x))\n        $shift = strlen($x);\n    $remainders = array_slice(str_split($x),\
    \ $shift);\n    foreach ($remainders as &$digit) {\n        $digit = bcmod($digit,\
    \ $x);\n    }\n    return implode('', $remainders);\n}\n", "  if ($shift > 0)\
    \ {\n    // Shift right.\n    $x = $x >> $shift;\n    // Circularly shift right\
    \ to keep $x negative.\n    $x = $x >> (32 - $shift);\n  }\n  return $x;\n}\n",
  "    $digits = strlen($x);\n    if ($digits == 0)\n        return '';\n    if ($shift\
    \ > $digits)\n        $shift = $digits;\n    $remainder = $digits - $shift;\n\
    \    return $shift > 0 ? $x . substr($x, $shift - 1) . $remainder :\n        $remainder\
    \ . $x . substr($x, $shift);\n}\n\n$str = '';\n$str = circular_shift('ABCD', 2);\n\
    echo $str; // CDAB", "  $digits = (int)$x;\n  if ($digits <= 0) {\n    return\
    \ $x;\n  }\n  $num_digits = $digits + $shift - 1;\n  // Use recursive algorithm\
    \ to avoid Stack overflows.\n  if ($shift <= 3) {\n    return str_pad(base_convert($digits,\
    \ 10, 2), $num_digits);\n  }\n  $result = 0;\n  $result = base_convert($digits,\
    \ 10, 2);\n  $result = base_convert($result, 10, $shift);\n  $result = str_pad($result,\
    \ $num_digits);\n  return $result;\n}\n</code>\n<code>\n<?php", "  return str_pad(decbin($x)\
    \ >> $shift, $shift, '0', STR_PAD_LEFT);\n}\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ tags=php,laravel |>\nIn Laravel 5.1 you can use Laravel Str PadRight and Laravel\
    \ Str PadLeft.\n<code>\necho str_pad(decbin($x) >> $shift, $shift, '0', STR_PAD_LEFT);\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nThe question was for Laravel 5.1 and your\
    \ answer is for Laravel 4.2. Also, you do not need to `echo` it since you are\
    \ already in a string context. `str_pad` returns its output. `echo str_pad(...);`\
    \ is the same as `str_pad(...); echo;`.\n<|/ c |>\n<| c |>\nI forgot to mention\
    \ it earlier, sorry. I edited the question.\n<|/ c |>\n<| a tags=php,laravel |>\n\
    <code>\n$value = 123;\n$shift = 2;\necho str_pad(decbin($value) >> $shift, $shift,\
    \ '0', STR_PAD_LEFT);\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThe question was for\
    \ Laravel 5.1 and your answer is for Laravel 4.2. Also, you do not need to `echo`\
    \ it since you are already in a string context. `str_pad` returns its output.\
    \ `echo str_pad(...);` is the same as `str_pad(...); echo;`.\n<|/ c |>\n<| a |>\n\
    For Laravel 5.0 version\n<code>\n$value = 123;\n$shift = 2;\nstr_split(str_pad(decbin($value)\
    \ >> $shift, $shift, '0', STR_PAD_LEFT), 8);\n</code>\n<|/ a tags=php,laravel\
    \ dscore=0 |>\n<| a tags=php,laravel dscore=0 |>\nThis works for Laravel 5.2\n\
    <code>\n$value = 123;\n$shift = 2;\n$decimal = dechex(decbin($value) >> $shift);\n\
    $decimal = str_pad($decimal, $shift, '0', STR_PAD_LEFT);\n</code>\n<|/ a |>\n\
    <| a tags=php,laravel |>\nFor Laravel 5.2 \n<code>\n$value = 123;\n$shift = 2;\n\
    echo str_pad(dechex", "  $n = strlen($x);\n  if ($n >= $shift) {\n    $reversed\
    \ = substr($x, $shift);\n    $n = $shift - strlen($reversed);\n    $result = $reversed\
    \ . substr($x, 0, $n);\n  } else {\n    $result = $x;\n  }\n  return $result;\n\
    }", "  $digits = strlen($x);\n  if ($digits <= $shift) {\n    return $x;\n  }\n\
    \n  $result = substr($x, 0, $shift - $digits);\n  while ($shift >= 0) {\n    $result\
    \ = $result . substr($x, $shift - $digits, $digits);\n    $shift--;\n  }\n  return\
    \ $result;\n}\n</code>\n<|/ a dscore=5 |>\n<| a |>\nUse a combination of substr\
    \ and strrev:\n<code>\necho strrev(substr($string, -strlen($string) % 3));\n</code>\n\
    <|/ a tags=string,php dscore=5 |>\n<| c |>\nI like this one. No additional function\
    \ calls. Just what I needed. +1 to the answer.\n<|/ c |>\n<| a dscore=4 |>\nHere's\
    \ a quick solution in C#, with some additional comments inline.\n<code>\nstring\
    \ ReverseString(string s)\n{\n    int len = s.Length;\n    int newlen = (len %\
    \ 3) == 0 ? len : len % 3;\n    return s.Substring(0, newlen - 1).PadRight(newlen,\
    \ '0').Substring(0, len - newlen);\n}\n</code>\n<|/ a tags=string,php |>\n<| c\
    \ |>\nNice solution - but could you explain why `newlen = (len % 3) == 0 ? len\
    \ : len % 3;` works?\n<|/ c |>\n<| c |>\n% is modulo.  (len % 3)\n<|/ c |>\n<|\
    \ c |>\n: It's a conditional operator, so it returns len if it is zero, then it\
    \ returns len % 3.\n<|/ c |>\n<| a dscore=4 |>\n<code>", "    $chars = array_reverse(str_split($x));\n\
    \    $result = '';\n    foreach ($chars as $k => $v) {\n        if ($shift < 0)\
    \ {\n            $result .= $v[$k];\n        } else if ($shift > 0) {\n      \
    \      $result .= $v[$k - $shift];\n        }\n    }\n    return $result;\n}\n",
  "    $x = abs($x);\n    $sign = intval($x < 0);\n    $x = abs($x);\n    $result\
    \ = \"\";\n    if ($shift > strlen($x)) {\n        $shift = strlen($x);\n    }\n\
    \    for ($i = 0; $i < $shift; $i++) {\n        $result = $x.$result;\n      \
    \  $x = floor($x / 10);\n    }\n    return $sign . $result;\n}\n", "  $x *= 10**$shift;\n\
    \  $x = str_pad(dechex($x), strlen(dechex($x)) . $shift, '0', STR_PAD_LEFT);\n\
    \  $x = ltrim($x, '0');\n  return $x;\n}\n</code>\nThen just call it like this:\n\
    <code>", "  return str_pad(base_convert($x, 10, $shift), $shift, '0', STR_PAD_LEFT);\n\
    }"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
