name: HumanEval_130_tri
language: php
prompt: "<?php\n// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
  \ in \n// the last couple centuries. However, what people don't know is Tribonacci\
  \ sequence.\n// Tribonacci sequence is defined by the recurrence:\n// tri(1) = 3\n\
  // tri(n) = 1 + n / 2, if n is even.\n// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n\
  \ + 1), if n is odd.\n// For example:\n// tri(2) = 1 + (2 / 2) = 2\n// tri(4) =\
  \ 3\n// tri(3) = tri(2) + tri(1) + tri(4)\n// = 2 + 3 + 3 = 8 \n// You are given\
  \ a non-negative integer number n, you have to a return an array of the \n// first\
  \ n + 1 numbers of the Tribonacci sequence.\n// Examples:\n// >>> tri(3)\n// array(1,\
  \ 3, 2, 8)\nfunction tri($n) {\n"
tests: "function candidate(...$args) {\n    return tri(...$args);\n}\n\nfunction test():\
  \ void {\n    if (candidate(3) !== array(1, 3, 2, 8)) { throw new Exception(\"Test\
  \ failed!\"); }\n    if (candidate(4) !== array(1, 3, 2, 8, 3)) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(5) !== array(1, 3, 2, 8, 3, 15)) { throw new\
  \ Exception(\"Test failed!\"); }\n    if (candidate(6) !== array(1, 3, 2, 8, 3,\
  \ 15, 4)) { throw new Exception(\"Test failed!\"); }\n    if (candidate(7) !== array(1,\
  \ 3, 2, 8, 3, 15, 4, 24)) { throw new Exception(\"Test failed!\"); }\n    if (candidate(8)\
  \ !== array(1, 3, 2, 8, 3, 15, 4, 24, 5)) { throw new Exception(\"Test failed!\"\
  ); }\n    if (candidate(9) !== array(1, 3, 2, 8, 3, 15, 4, 24, 5, 35)) { throw new\
  \ Exception(\"Test failed!\"); }\n    if (candidate(20) !== array(1, 3, 2, 8, 3,\
  \ 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11)) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(0) !== array(1)) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(1) !== array(1, 3)) { throw new Exception(\"\
  Test failed!\"); }\n}\n\ntest();"
completions: ["    if($n == 1) {\n        return array(3);\n    }\n    if($n == 2)\
    \ {\n        return array(1,3);\n    }\n    if($n % 2 == 0) {\n        $left =\
    \ tri($n - 1);\n        $right = tri($n - 2) + tri($n + 1);\n        return $left\
    \ + $right;\n    }\n    $left = $n = tri($n - 1) + tri($n - 2);\n    return $left\
    \ + $n + 1;\n}\n\n$n = $_GET['n'];\n$result = tri($n);\nprint_r($result);\n",
  "\t$seq = [];\n\tif ($n < 3 || !is_numeric($n) || $n < 1 || ($n % 2) === 0)\n\t\t\
    return $seq;\n\t$seq[] = 3;\n\tif ($n >= 2) {\n\t\t$seq[] = 1;\n\t\tif ($n % 2\
    \ === 1)\n\t\t\t$seq[] = 2;\n\t\t$seq[] = 2;\n\t\t$seq[] = 2;\n\t}\n\treturn $seq;\n\
    }\n", "    $results = [\n        3 => 1,\n        2 => [3, 1],\n        1 => [3,\
    \ 4, 3],\n        0 => [3, 3, 4, 3, 1]\n    ];\n    return $results[$n] ?? null;\n\
    }\n", "    if ($n < 3) return $n;\n    $tri = [1];\n    for ($i = 2; $i < $n;\
    \ $i += 2) {\n        $tri[] = $tri[$i - 1] + $tri[$i - 2];\n    }\n    return\
    \ $tri;\n}", "\tif ($n < 2) {\n\t\treturn [];\n\t}\n\t\n\t$result = [];\n\t\n\t\
    for ($i = 0; $i < $n; $i++) {\n\t\tif ($i % 2 == 0) {\n\t\t\t$result[] = 1;\n\t\
    \t} else {\n\t\t\t$result[] = $result[$i - 1] + $result[$i - 2];\n\t\t}\n\t}\n\
    \t\n\treturn $result;\n}\n", "    if ($n == 0) {\n        return [];\n    }\n\n\
    \    if ($n >= 2) {\n        return [$n, $n - 1, $n + 1 ];\n    }\n\n    return\
    \ tri($n - 1) + tri($n - 2);\n}", "    if ($n <= 2) {\n        return array($n);\n\
    \    }\n\n    if ($n == 1) {\n        return array(3);\n    }\n\n    $a = tri($n\
    \ - 1) + tri($n - 2);\n    if ($n % 2 == 0) {\n        $a[] = tri($n + 1);\n \
    \   }\n    return $a;\n}\n</code>\n<|/ a tags=php,recursion dscore=3 |>\n<| c\
    \ |>\n`tri(17)` returns `array(17, 19, 11, 7, 5, 3, 17, 19, 11, 7, 5, 3, 15, 13,\
    \ 5, 3, 5, 3, 13, 9, 11, 7, 5, 3)` whereas `tri(8)` returns `array(8, 8, 8, 8,\
    \ 8, 8, 8, 8, 8)`\n<|/ c |>\n<| c |>\nIt gives array `array(8, 8, 8, 8, 8, 8,\
    \ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8)` because you have used this code: `if ($n % 2\
    \ == 0) {\n        $a[] = tri($n + 1);\n    }` which always adds 1 to the last\
    \ element of the array and will never reach 8.\n<|/ c |>\n<| a tags=php,recursion\
    \ |>\n<code>\n<?php", "    $a = array(3);\n    $a[2] = $a[0] + $a[1]; // 1\n \
    \   $a[0] = $a[1] + $a[0]; // 3\n    $a[1] = $a[2] + $a[1]; // 1\n    $a[3] =\
    \ $a[$n] + $a[$n - 1]; // 8\n    return $a;\n}\n</code>\n<|/ a tags=fibonacci,php\
    \ |>\n<| a |>\n<code>\n<?php", "  if ($n === 0 || $n === 1) {\n    return array($n);\n\
    \  }\n\n  return tri($n - 1) + tri($n - 2) + tri($n + 1);\n}\n</code>\n<|/ a tags=php,recursion\
    \ dscore=0 |>\n<| a dscore=0 |>\n<code>", "    return array_merge(\n        array(1),\n\
    \        range(1, $n + 1),\n        range($n, 0, -1) // The range operator does\
    \ not allow negative start, only end\n    );\n}\n</code>\n<|/ a |>\n<| c |>\n\
    `range(1, $n + 1)` will also work\n<|/ c |>\n<| c |>\nWhat is the time complexity\
    \ of this function?\n<|/ c |>\n<| c |>\n.Desai Nothing in particular, it's a very\
    \ simple recursive function\n<|/ c |>\n<| c |>\n.Desai It has time complexity\
    \ `O(n)`. Which is better depends on what you're doing with the result.\n<|/ c\
    \ |>\n<| c |>\nThanks for the answer!\n<|/ c |>\n<| a |>\nIn python you can do:\n\
    <code>\ndef tri(n):\n    return tri(n-1) + tri(n-2) + tri(n-3)\n\ndef sumTri(n):\n\
    \    return tri(n) + tri(n-2) + tri(n-3)\n</code>\n<|/ a tags=php,fibonacci,python,algorithm\
    \ dscore=5 |>\n<| c |>\nThis is quite a nice one-liner. Python is amazing once\
    \ you get used to it.\n<|/ c |>\n<| c |>\n: And it also works with the standard\
    \ library: https://docs.python.org/2/library/functools.html#functools.partial\n\
    <|/ c |>\n<| a dscore=5 tags=php,fibonacci,python,algorithm |>\nIn Ruby:\n<code>\n\
    def fib(n)\n  if n == 0 || n == 1 then return n\n  else return fib(n-2) + fib(n-1)\n\
    end\n\nputs fib(3) # => 8\n</code>\n<|/ a |>\n<| c |>\nHow does this answer differ\
    \ from that of Damien Ritz? What is the advantage?\n<|/ c |>\n<| c |>\nThey are\
    \ different in terms of complexity. I don't see an advantage to either of them.\
    \ I personally prefer Damien's answer because it's clearer and shorter.\n<|/ c\
    \ |>\n<| c |>\nRuby doesn't have an explicit `return` statement, so the last line\
    \ is implicitly a `return`.  So you might as well write `return fib(n-2) + fib(n-1)`\n\
    <|/ c |>\n<| c |>\n, you're right of course. I've edited the answer.\n<|/ c |>\n\
    <| a |>\n<code>\ndef fibonacci(n):\n  if n == 0 or n == 1:\n    return ", "  \
    \  $result = [];\n    for ($i = 0; $i < $n; $i++) {\n        $result[$i] = $i\
    \ + 1;\n        $result[$i] = $result[$i] + ($i & 1 ? 2 : 1);\n    }\n    return\
    \ $result;\n}", "    $a = 1;\n    $b = 1;\n    $c = 1;\n\n    while ($n--) {\n\
    \        $a++;\n        $b++;\n        $c++;\n\n        if ($n%2 == 0) {\n   \
    \         $c = $a + $c + $b;\n            $a = 0;\n            $b = 0;\n     \
    \   }\n    }\n    \n    return array($a, $b, $c, $c);\n}\n</code>\n<|/ a tags=php,math,function,sequence,recursion\
    \ dscore=4 |>\n<| c |>\nThank you for providing this solution. I was actually\
    \ wondering what could be the most efficient way to code this function in PHP.\
    \ How did you come up with such an awesome solution :)\n<|/ c |>\n<| c |>\nI did\
    \ it the same way and was wondering if there is a more efficient way to do it,\
    \ like using the built-in PHP functions or something. Not sure though.\n<|/ c\
    \ |>\n<| c |>\nThis answer is way better than the accepted one. My only suggestion\
    \ is to add a `return tri($n - 1)` in the last line so it returns the last number\
    \ as well.\n<|/ c |>\n<| c |>\nYou can remove the extra variables, `$a` and `$b`,\
    \ by replacing `$a` with `return $a + tri($n - 1)`. Same for `$c` with `return\
    \ $c + tri($n - 1)`.\n<|/ c |>\n<| c |>\nIf you do that, you can't call `tri()`\
    \ with zero as parameter, since it will throw an error because it requires an\
    \ argument\n<|/ c |>\n<| a dscore=4 |>\nThe simple and efficient solution using\
    \ O(1) space and O(n) time complexity (thanks to Robert's comment):\n<code>",
  "  $tri = array();\n  for ($i = 1; ($i * 2) <= $n; $i++) {\n    $tri[] = $i;\n \
    \ }\n  return $tri;\n}\n", "    $a = 1;\n    $b = 1;\n    $c = 1;\n    $sequence\
    \ = [];\n    for($i = 0; $i <= $n; $i++) {\n        $sequence[] = $a;\n      \
    \  $a = $b;\n        $b = $c;\n        $c = $a + $b;\n    }\n    return $sequence;\n\
    }\n", "    $fib = array(\n        1 => 3,\n        3 => 5,\n        7 => 13\n\
    \    );\n    $return = array();\n\n    for ($i = 1; $i < $n; $i++) {\n       \
    \ if ($n % 2 == 0) {\n            $return[] = $fib[$i];\n        } else {\n  \
    \          $return[] = $fib[$i - 1] + $fib[$i - 2];\n        }\n    }\n\n    return\
    \ $return;\n}\n</code>\n<|/ a dscore=5 tags=php,fibonacci,algorithm |>\n<| a |>\n\
    <code>", "    $sum = $a1 = $a2 = $a3 = 1;\n    $odd = $n % 2;\n    for ($i = 2;\
    \ $i <= $n; $i++) {\n        $sum = array_merge($a2, [$a3]);\n        $a1 = $a2;\n\
    \        $a2 = $a3;\n        $a3 = $sum[$odd = !$odd];\n    }\n    return $a1;\n\
    }\n</code>\nThis returns every number from 0 to n+1 inclusive. It uses array_merge\
    \ and ternary operations to shorten the code. \n<code>", "    $arr = [];\n   \
    \ for($i = 1; $i <= $n; $i++) {\n        $arr[] = $i;\n        $arr[] = array_sum(array_slice($arr,\
    \ -1) / 2);\n    }\n    return $arr;\n}", "\tglobal $n;\n\t$a = 0;\n\t$b = 3;\n\
    \t$c = 1;\n\t$d = 1;\n\t\n\tfor ($i = 1; $i < $n; $i++) {\n\t\tif ($i % 2 == 0)\
    \ {\n\t\t\t$a = $a + $c;\n\t\t} else {\n\t\t\t$b = $b + $d;\n\t\t}\n\t\t$c = $c\
    \ - $d;\n\t\t$d = $d + $c;\n\t}\n\t\n\treturn $a + $b;\n}\n", "    \n    $ar =\
    \ [];\n    if ($n > 0) {\n        if ($n % 2 == 0) {\n            $ar[] = 3;\n\
    \        }\n        $ar[] = ($n + 1) + ($n + 1) / 2;\n        if ($n % 2 == 1)\
    \ {\n            $ar[] = ($n + 1) + ($n - 1) + ($n + 2) / 2;\n        }\n    }\n\
    \    return $ar;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=php,codeigniter,math,fibonacci,array-algorithms\
    \ dscore=0 |>\nA faster method to get first 20 elements of the fibonacci series\
    \ is to create a function which returns the nth fibonacci number, then you can\
    \ get the first 20 elements by calling the function\n<code>\n<?php", "    return\
    \ $n <= 1 ? array(1) : (array(\n        tri($n - 1),\n        tri($n - 2),\n \
    \       tri($n + 1)\n    ));\n}\n", "    if ($n == 0) {\n        return array(0,\
    \ 1, 1, 1);\n    } else if ($n == 1) {\n        return array(1, 2, 1);\n    }\
    \ else {\n        $result = [];\n        $last = 0;\n        $last1 = 0;\n   \
    \     $last2 = 0;\n        for ($i = 0; $i <= $n; $i++) {\n            $last =\
    \ 1 + $last + $last1 + $last2;\n            $last1 = $last2;\n            $last2\
    \ = $last;\n            $result[] = $last;\n        }\n        return $result;\n\
    \    }\n}\n</code>\n<|/ a |>\n<| a dscore=2 |>\nTry this:\n<code>\n$numOfDigits\
    \ = 6;\n$number = 30;\n$numbers = '';\n\nfor ($i = 1; $i <= $numOfDigits; $i++)\
    \ {\n    $numbers = $numbers + str_pad(trim(str_repeat('0', $i).$number), $numOfDigits,\
    \ '0', STR_PAD_RIGHT);\n}\n\nvar_dump($numbers);\n</code>\nThe output is:\n<code>\n\
    string(17) \"00030\" string(17) \"00303\" string(17) \"03033\" string(17) \"30333\"\
    \n</code>\nThis doesn't use any looping or recursion, but it builds the sequence\
    \ in one shot. \nThe trim function will get rid of any leading 0's and just add\
    \ the number to the result string.\n<|/ a tags=php,algorithm,math |>\n<| a tags=php,algorithm,math\
    \ |>\n<code>\n<?php\n    function getTribonacciSequence($n)\n    {\n        $total\
    \ = 0;\n\n        for($x = 1; $x < $n; $x++)\n        {\n            $total +=\
    \ pow($x,3);\n        }\n\n        return $total;\n    }\n\n    echo getTribonacciSequence(5);",
  "    if ($n <= 0) {\n        return [];\n    }\n    $result = [3];\n    if ($n &\
    \ 1) {\n        $result.push(1);\n    }\n    $result.push(3);\n    $result.push(tri($n\
    \ - 1) - tri($n - 2) + tri($n + 1));\n    return $result;\n}\n", "    // base\
    \ case \n    if ($n === 1) {\n        return array(1);\n    }\n    $ret = array();\n\
    \    for ($i = 0; $i < $n; $i++) {\n        $ret[] = $ret[count($ret) - 1] + $ret[count($ret)\
    \ - 2] + $ret[count($ret) - 3];\n    }\n    return $ret;\n}\n", "    if($n ==\
    \ 1) {\n        return array(3);\n    }\n    if($n == 0) {\n        return array(1);\n\
    \    }\n    if($n%2 == 0) {\n        return array(tri($n-1), tri($n-2), tri($n+1));\n\
    \    }\n    return array(tri($n-1), tri($n+2), tri($n+3));\n}\n", "\t$a1 = array(1,\
    \ 3);\n\t$a2 = array(2, 2);\n\t$a3 = array(3, 1);\n\t$a4 = array(8, 8);\n\t$a5\
    \ = array(5, 5);\n\t$a6 = array(9, 9);\n\t$a7 = array(6, 6);\n\t$a8 = array(7,\
    \ 7);\n\t$a9 = array(10, 10);\n\t$a10 = array(8, 8);\n\t$a11 = array(6, 6);\n\t\
    $a12 = array(7, 7);\n\t$a13 = array(10, 10);\n\t\n\tif ($n <= 0)\n\t{\n\t\treturn\
    \ false;\n\t}\n\t\n\tif ($n == 1)\n\t{\n\t\treturn array(3);\n\t}\n\t\n\telse\
    \ if ($n % 2 == 0)\n\t{\n\t\t$tri_res = array();\n\t\t$tri_res = array_merge($tri_res,\
    \ tri($n / 2));\n\t\t$tri_res = array_merge($tri_res, tri($n / 2 - 1));\n\t\t\
    $tri_res = array_merge($tri_res, tri($n / 2 + 1));\n\t\t\n\t\treturn $tri_res;\n\
    \t}\n\t\n\telse if ($n % 2 == 1)\n\t{\n\t\t$tri_res = array();\n\t\t$tri_res =\
    \ array_merge($tri_res, tri($n / 2));\n\t\t$tri_res = array_merge($tri_res, tri($n\
    \ / 2 + 1));\n\t\t\n\t\treturn $tri_res;\n\t}\n\t\n\telse\n\t{\n\t\t$tri_res =\
    \ array();\n\t\t$tri_res = array_merge($tri_res, tri($n / 2));\n\t\t$tri_res =\
    \ array_merge($tri_res, tri($n / 2 + 1));\n\t\t$tri_res = array_merge($tri_res,\
    \ tri($n / 2 - 1));\n\t\t\n\t\treturn $tri_res;\n\t}\n}\n", "\t$result = [3];\n\
    \tfor ($i = 0; $i <= $n; $i++) {\n\t\tif ($i%2 === 0) {\n\t\t\t$result[] = 1 +\
    \ $i/2;\n\t\t} else {\n\t\t\t$result[] = tri($i-1) + tri($i-2) + tri($i+1);\n\t\
    \t}\n\t}\n\treturn $result;\n}\n", "\t$result = array();\n\tfor ($i = 0; $i <=\
    \ $n; $i++) {\n\t\t$result[] = $i == 1 ? 3 : (1 + $i) / 2;\n\t}\n\treturn $result;\n\
    }\n", "  if ($n === 0) return array();\n  if ($n === 1) return array(1, 3, 2);\n\
    \  if ($n % 2 == 0) return array(tri($n/2)[0], tri($n/2)[1] + tri($n/2)[2]);\n\
    \  else return array(tri($n/2)[0], tri($n/2)[1] + tri($n/2)[1] + tri($n/2)[2]);\n\
    }", "    $first = 0;\n    $second = 1;\n    $third = 1;\n    $return = array($first);\n\
    \    for ($i = 1; $i <= $n; $i++) {\n        $return[] = $third;\n        $first\
    \ = $second;\n        $second = $third;\n        $third = $first + $second;\n\
    \    }\n    return $return;\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=php,algorithm,recursion\
    \ |>\n<code>\n<?php\n$n = 4;\n$numbers = array(3,8,15,21);\nprint_r (array_map\
    \ (function($x) use ($n) {return ($x%2 == 1)?$n*$x:$x;},array_slice($numbers,\
    \ 0, $n)));", "  $seq = [];\n  \n  // Base case\n  if ($n < 3) {\n    $seq[] =\
    \ $n;\n  } else {\n    $seq[] = tri($n - 1) + tri($n - 2) + tri($n + 1);\n  }\n\
    \  \n  return $seq;\n}\n", "    $fib = [1, 1, 1];\n    $n = array_push($fib, $fib[0]);\n\
    \    foreach (range(1, $n) as $i) {\n        $tmp = array_pop($fib);\n       \
    \ $fib[] = $tmp + $fib[$tmp];\n    }\n    return $fib;\n}", "    $arr = array();\n\
    \    if ($n < 2) {\n        return $arr;\n    }\n    $fib1 = 1;\n    $fib2 = 1;\n\
    \    $fib3 = 1;\n    $count = 0;\n    $n = ceil($n / 2);\n    for($i = 0; $i <\
    \ $n; $i++) {\n        $fib3 = $fib1 + $fib2 + $fib3;\n        $arr[] = $fib3;\n\
    \        $fib2 = $fib1;\n        $fib1 = $fib3;\n        $count++;\n    }\n  \
    \  $fib3 = $fib1 + $fib2 + $fib3;\n    $arr[] = $fib3;\n    return $arr;\n}",
  "\t$nums = array(1);\n\tfor ($i = 0; $i < $n; $i++) {\n\t\t$nums[] = $nums[$i -\
    \ 1] + $nums[$i - 1] + $nums[$i - 1];\n\t}\n\treturn $nums;\n}\n", "    $sequence\
    \ = new Array(); \n    // if ($n < 3){\n    //     return $sequence;\n    // }\n\
    \    $sequence[] = 3; \n    $even = $n%2;\n    if($even === 1){\n        $sequence[]\
    \ = $sequence[count($sequence)-1] + $sequence[count($sequence)-2];\n    }\n  \
    \  else{\n        $sequence[] = $sequence[count($sequence)-1] + $sequence[count($sequence)-2]\
    \ + $sequence[count($sequence)-3];\n    }\n    return $sequence;\n}\n$n = 2;\n\
    $result = tri($n);\nvar_dump($result);\n</code>\n<|/ a tags=php,fibonacci,algorithm,recursion\
    \ |>\n<| c |>\nThe question explicitly states the input should be non-negative,\
    \ just like the OP has done in the code sample - so your solution will fail for\
    \ negative inputs.\n<|/ c |>\n<| a tags=php,fibonacci,algorithm,recursion |>\n\
    You can do this by using the Fibonacci formula, by defining the recursive relation\
    \ Fn = Fn-1 + Fn-2. \nThe recursive relation works in two steps: the first step\
    \ can be done with recursion. \nThe second step can be done by iterating over\
    \ F(n), and appending the result to a result array.\n<code>\n$result = [];\n$result[0]\
    \ = 0;\n\nfor($i = 1; $i <= $n; $i++) {\n    $result[] = $result[$i - 1] + $result[$i];\n\
    }\n", "    $arr = [1, 3];\n    if ($n % 2 === 0) {\n        for ($i = 3; $i <=\
    \ $n; $i = $i + 2) {\n            $arr[] = $arr[$i - 1] + $arr[$i - 2];\n    \
    \    }\n    } else {\n        for ($i = 2; $i <= $n; $i = $i + 2) {\n        \
    \    $arr[] = $arr[$i - 1] + $arr[$i - 2];\n        }\n    }\n    return $arr;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nFor a general solution, use the formula\
    \ `tri(n) = tri(n-1) + tri(n-2) + tri(n+2)` instead of the loop. Your solution\
    \ does not work when n is odd, since the loop will skip the last element\n<|/\
    \ c |>\n<| c |>\nThanks man! you save my time :)\n<|/ c |>\n<| a tags=php,number-theory,fibonacci\
    \ |>\n<code>", "\t$first = [1 => 3];\n\tif ($n & 1) {\n\t\t$first[tri($n - 1)]\
    \ = 1 + tri($n - 2);\n\t}\n\tif ($n & 2) {\n\t\t$first[$first[tri($n - 2)]] =\
    \ tri($n - 1) + tri($n - 2) + tri($n + 1);\n\t}\n\treturn $first;\n}", "    $n\
    \ = abs($n);\n    $numbers = array();\n    if ($n < 3) {\n        $numbers[] =\
    \ 1;\n        $numbers[] = 1;\n        return $numbers;\n    }\n    $prev = $prev2\
    \ = 0;\n    $n--;\n    $numbers[] = 1;\n    $numbers[] = 1;\n    for ($i = 0;\
    \ $i < $n; $i++) {\n        $prev2 = $prev;\n        $prev = $prev2 + $prev;\n\
    \        $numbers[] = $prev;\n    }\n    return $numbers;\n}", "    if($n<2) return\
    \ array(1);\n    $ret = tri($n-2);\n    return $ret+$ret+$ret+1;\n}\n", "    $nums\
    \ = array();\n    $nums[] = 1;\n    if($n%2 == 0) {\n        for($i = 3; $i <=\
    \ $n; $i++) {\n            $nums[] = $nums[$i-1] + $nums[$i-2];\n        }\n \
    \   } else {\n        for($i = 3; $i <= $n; $i++) {\n            $nums[] = $nums[$i-1]\
    \ + $nums[$i-2] + $nums[$i];\n        }\n    }\n    return $nums;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nI haven't thought of that, thanks!\n<|/ c |>\n<| c |>\nWhat\
    \ if the array is already built? I don't see how your answer solves that. Also\
    \ the complexity is `O(n ^ 2)` which is not ideal and shouldn't be used.\n<|/\
    \ c |>\n<| c |>\nHmm I'm not sure what you mean, are you saying it takes too long\
    \ to generate the array? I took care of building the array by hand, so it should\
    \ be fast.\n<|/ c |>\n<| c |>\nIf i understood correctly he wants to build a tribonacci\
    \ sequence in an array as his question suggests.\n<|/ c |>\n<| c |>\nYes, but\
    \ he doesn't want to calculate the entire array. So this solution doesn't help.\n\
    <|/ c |>\n<| a dscore=0 |>\nHere's a quick way to calculate the sequence. Given\
    \ the fact that n >= 4, n^2 + n^2 = n^3.\n<code>\n$n = <whatever the user enters>;\n\
    $c = 1;\nfor ($i = 1; $i <= $n; $i++)\n{\n    $c = $c * (($n + $i) / $n) - ($i\
    \ * $i / $n);\n}\necho \"$c \\n\" . str_pad('', $n, '-');\n</code>\n<|/ a tags=php,math\
    \ |>\n<| c |>\nThis gives different results for `n=0`, `n=3`, `n=5`, `n=7`, etc.\n\
    <|/ c |>\n<| c |>\nI didn't test them, but I'm pretty sure that they all do. Also,\
    \ I didn't say it didn't, I said it gives the same result for me.\n<|/ c |>\n\
    <| a tags=php,math dscore=0 |>\n<code>\n<?php ", "    if($n == 0) return array();\n\
    \    if($n == 1) return array(3);\n    if($n % 2 == 0) return array(tri($n - 1)\
    \ + tri($n - 2) + tri($n + 1));\n    return array(tri($n - 1) + tri($n - 2));\n\
    }", "    $a = $b = 1;\n    $result = array($n);\n    for($i = 1;$i < $n+1;$i++)\
    \ {\n        $result[] = $a++;\n        $b += $a/2;\n        $a += $b;\n    }\n\
    \    return $result;\n}\n</code>\n<|/ a tags=php,recursion |>\n<| a dscore=4 |>\n\
    <code>", "    if ($n <= 1)\n        return array(1);\n    $a = $b = 1;\n    for($i\
    \ = 2; $i <= $n; $i++) {\n        $a = $b;\n        $b = $a + $b;\n    }\n   \
    \ return array($a, $b, $a, $b);\n}", "    $a = [1, 1, 1];\n    for ($i = 2; $i\
    \ <= $n; ++$i) {\n        $a[] = $a[$i - 1] + $a[$i - 2] + $a[$i + 1];\n    }\n\
    \    return $a;\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nPlease add comments to\
    \ your answer about the code you provide.\n<|/ c |>\n<| c |>\nJust to add an important\
    \ point: This solution does not work for large numbers.\n<|/ c |>\n<| c |>\nYou\
    \ don't need to use recursion to get the triangle of fibonacci numbers. You only\
    \ need `O(n^2)` space, and you can calculate them using a simple loop\n<|/ c |>\n\
    <| a dscore=2 |>\nThis is my solution for fibonacci series:\n<code>\n$fib = array();\n\
    $fib[0]=1;\n$fib[1]=2;\n$i = 1;\nwhile($i<= 1000){\n    array_push($fib,$fib[$i-1]+$fib[$i]);\n\
    \    echo $fib[$i-1] .\"<br>\";\n    $i++;\n}\n</code>\n<|/ a tags=php,arrays,fibonacci\
    \ |>\n<| a |>\n<code>\n$fibonnacci = array();\n$fibonnacci[0] = 1;\n$fibonnacci[1]\
    \ = 2;\n$fibonnacci[2] = 1;\n$fibonnacci[3] = 2;\n$index = 4;\n\n$number = \"\
    1234567\";\n$nr = strlen($number);\nfor($i = 0; $i < $nr; $i++) {\n    $fibonnacci[$index]\
    \ = $fibonnacci[$index-1] + $fibonnacci[$index-2];\n    $index++;\n}\n\necho $fibonnacci[0];\n\
    </code>\n<|/ a tags=php,arrays,fibonacci dscore=2 |>\n<| a |>\n<code>", "    $a\
    \ = array(3);\n    if (is_int($n)) {\n        $a[] = $n;\n    }\n    $n = $n %\
    \ 2;\n    if ($n == 0) {\n        return array($a[0] + $a[1] + $a[2], $a[0] +\
    \ $a[2] + $a[3] + $a[1], $a[0] + $a[1] + $a[3] + $a[2]);\n    }\n    $c = array(1);\n\
    \    for ($i = 2; $i <= $n; $i++) {\n        $c[] = $c[($i - 1)] + $c[($i - 2)]\
    \ + $c[($i + 1)] + $c[($i + 2)];\n    }\n    return $c;\n}", "    $triarray =\
    \ array();\n    $triarray[] = 3;\n    $triarray[] = 1;\n    for ($i = 1; $i <\
    \ $n; $i++) {\n        if ($i % 2 == 0) {\n            $triarray[] = $triarray[$i\
    \ - 1] + $triarray[$i - 2];\n        } else {\n            $triarray[] = $triarray[$i\
    \ - 1] + $triarray[$i - 2] + $triarray[$i];\n        }\n    }\n    return $triarray;\n\
    }", "    return array_merge(\n      [1, (2 / 2)],\n      array_slice(\n      \
    \  array_merge(\n          tri($n - 1) + tri($n - 2) + tri($n + 1),\n        \
    \  array_slice(\n            tri($n),\n            0,\n            ($n % 2) ?\
    \ 1 : 2\n          )\n        ), 0, ($n % 2) ? 1 : 2\n      )\n    );\n  }\n \
    \ \n  // TESTS\n\n  public function testTri() {\n    $this->assertSame(\n    \
    \  array_slice(tri(3), 0, 3),\n      [1, 3, 2]\n    );\n    $this->assertSame(\n\
    \      tri(3),\n      [1, 3, 2]\n    );\n    $this->assertSame(\n      tri(4),\n\
    \      [1, 3, 2]\n    );\n    $this->assertSame(\n      tri(5),\n      [1, 3,\
    \ 2, 8]\n    );\n    $this->assertSame(\n      tri(6),\n      [1, 3, 2, 8, 13]\n\
    \    );\n  }\n\n  public function testTri2() {\n    $this->assertSame(\n     \
    \ tri(2),\n      [1, 2]\n    );\n    $this->assertSame(\n      tri(3),\n     \
    \ [1, 3]\n    );\n    $this->assertSame(\n      tri(4),\n      [1, 3]\n    );\n\
    \    $this->assertSame(\n      tri(5),\n      [1, 3, 2]\n    );\n    $this->assertSame(\n\
    \      tri(6),\n      [1, 3, 2]\n    );\n    $this->assertSame(\n      tri(7),\n\
    \      [1, 3, 2, 8]\n    );\n  }\n\n  public function testTri3() {\n    $this->assertSame(\n\
    \      tri(1),\n      [1]\n    );\n    $this->assertSame(\n      tri(2),\n   \
    \   [1, 2]\n    );\n    $this->assertSame(\n      tri(3),\n      [1, 3]\n    );\n\
    \    $this->assertSame(\n      tri(4),\n      [1, 3]\n    );\n    $this->assertSame(\n\
    \      tri(5),\n      [1, 3, 2]\n    );\n    $this->assertSame(\n      tri(6),\n\
    \      [1, 3, 2]\n    );\n    $this->assertSame(\n      tri(7),\n      [1, 3,\
    \ 2, 8]\n    );\n    $this->assertSame(\n      tri(8),\n      [1, 3, 2, 8, 13]\n\
    \    );\n  }\n\n  public function testTri4() {\n    $this->assertSame(\n     \
    \ tri(8),\n      [1, 3, 2, 8, 13]\n    );\n  }\n\n  public function testTri5()\
    \ {\n    $this->assertSame(\n      tri(2),\n      [1, 2]\n    );\n    $this->assertSame(\n\
    \      ", "    $array = [];\n    if ($n % 2 === 0) {\n        $array[0] = 3;\n\
    \        $array[1] = ($n / 2) + 1;\n    } else {\n        $array[0] = ($n / 2)\
    \ + 1;\n        $array[1] = tri($n - 1) + tri($n - 2) + tri($n + 1);\n    }\n\
    \    return $array;\n}\n", "    $result = [];\n    for($i = 1; $i < $n; $i++)\
    \ {\n        $result[] = ($i % 2 === 1) ? $i + 1 : $i;\n    }\n    return $result;\n\
    }\n</code>\n<|/ a tags=php,loops,arrays dscore=2 |>\n<| c |>\nThis is really interesting.\
    \  It appears that this is what I was trying to accomplish. Thank you for your\
    \ explanation!\n<|/ c |>\n<| c |>\nThis is really great and very fast! But I wonder\
    \ how this compares to all the other methods I have seen so far... the speed is\
    \ really impressive! Thank you!\n<|/ c |>\n<| a dscore=1 |>\nI've tested and this\
    \ is my take on it\n<code>", "    \n    if (!is_numeric($n)) {\n        throw\
    \ new \\InvalidArgumentException('Tribonacci sequence only accept integer as parameter');\n\
    \    }\n    $array = [];\n    \n    if ($n == 1) {\n        $array[] = 1;\n  \
    \  }\n    if ($n == 2) {\n        $array[] = 2;\n        $array[] = 3;\n    }\n\
    \    if ($n == 3) {\n        $array[] = 3;\n        $array[] = 4;\n        $array[]\
    \ = 5;\n    }\n    if ($n == 4) {\n        $array[] = 5;\n        $array[] = 6;\n\
    \        $array[] = 7;\n        $array[] = 8;\n    }\n    if ($n == 5) {\n   \
    \     $array[] = 8;\n        $array[] = 9;\n        $array[] = 10;\n        $array[]\
    \ = 11;\n        $array[] = 12;\n    }\n    if ($n == 6) {\n        $array[] =\
    \ 12;\n        $array[] = 13;\n        $array[] = 14;\n        $array[] = 15;\n\
    \        $array[] = 16;\n    }\n    if ($n == 7) {\n        $array[] = 16;\n \
    \       $array[] = 17;\n        $array[] = 18;\n        $array[] = 19;\n     \
    \   $array[] = 20;\n    }\n    if ($n == 8) {\n        $array[] = 20;\n      \
    \  $array[] = 21;\n        $array[] = 22;\n        $array[] = 23;\n        $array[]\
    \ = 24;\n    }\n    if ($n == 9) {\n        $array[] = 24;\n        $array[] =\
    \ 25;\n        $array[] = 26;\n        $array[] = 27;\n        $array[] = 28;\n\
    \        $array[] = 29;\n    }\n    if ($n == 10) {\n        $array[] = 30;\n\
    \        $array[] = 31;\n        $array[] = 32;\n        $array[] = 33;\n    \
    \    $array[] = 34;\n        $array[] = 35;\n    }\n    if ($n == 11) {\n    \
    \    $array[] = 35;\n        $array[] = 36;\n        $array[] = 37;\n        $array[]\
    \ = 38;\n        $array[] = 39;\n        $array[] = 40;\n    }\n    if ($n ==\
    \ 12) {\n        $array[] = 40;\n        $array[] = 41;\n        $array[] = 42;\n\
    \        $array[] = 43;\n        $array[] = 44;\n        $array[] = 45;\n    \
    \    $array[] = 46;\n    }\n    if ($n == 13) {\n        $array[] = 46;\n    \
    \    $array[] = 47;\n        $array[] = 48;\n        $array[] = 49;\n        $array[]\
    \ = 50;\n        $array[] = 51;\n        $array[] = 52;\n    }\n    if ($n ==\
    \ 14) {\n", "    $arr = array();\n    $arr[0] = 1;\n    $arr[1] = 2;\n    if ($n%2\
    \ != 1) {\n        $arr[2] = $arr[0]+$arr[1];\n        $arr[3] = $arr[0]+$arr[1]+$arr[2];\n\
    \        $arr[4] = $arr[3]+$arr[2];\n        $arr[5] = $arr[3]+$arr[1]+$arr[4];\n\
    \    } else {\n        $arr[2] = $arr[0]+$arr[1];\n        $arr[3] = $arr[0]+$arr[1];\n\
    \        $arr[4] = $arr[1]+$arr[3];\n        $arr[5] = $arr[2]+$arr[4];\n    }\n\
    \    return $arr;\n}\n", "\t$a = array(3,1);\n\tfor ($i=2;$i<=$n;$i++) {\n\t\t\
    $a[] = array_shift($a);\n\t}\n\treturn $a;\n}", "    if ($n < 0) return [];\n\
    \    if ($n == 3) return [2, 1];\n    $array1 = [];\n    $array2 = [];\n    for\
    \ ($i = 1; $i <= $n; $i++) {\n        $array1[$i - 1] = $i;\n        $array2[$i\
    \ - 1] = $i + ($i / 2);\n    }\n    $array3 = $array1 + $array2;\n    sort($array3);\n\
    \    return $array3;\n}\n", "\t$array = array(1);\n\tfor ($i = 1; $i <= $n; $i++)\
    \ {\n\t\t$array[] = array_sum($array);\n\t\t$array[] = $array[count($array) -\
    \ 1];\n\t\t$array = array_merge(array($array[count($array) - 1]), $array);\n\t\
    }\n\treturn $array;\n}", "    if ($n < 1) return [];\n    $a = $b = 1;\n    $c\
    \ = 0;\n    for ($i = 1; $i <= $n; $i++) {\n        $c++;\n        if ($i % 2\
    \ == 0) {\n            $a += $b;\n        }\n        $b = $a;\n        $a = $c;\n\
    \    }\n    return array_merge([1], [$a + $b, $a + 2 * $b, $a + 3 * $b]);\n}\n",
  "    $result = array(1);\n    for($i = 2; $i <= $n; $i++) {\n        $result[] =\
    \ $result[($i-1)+($i-2) + ($i+1)];\n    }\n    return $result;\n}", "    if ($n\
    \ < 2) {\n        return array();\n    }\n    return array(\n        1 + $n /\
    \ 2, $n / 2, $n + $n / 2, \n        1 + $n + $n / 2, $n - 1, $n, \n        $n\
    \ - 2, $n - 1, $n + $n, $n, \n        $n + 2, $n - 2, $n + $n - 1, $n + $n + 1\n\
    \    );\n}\n\n$result = tri($n);\nprint_r($result);\n", "    $arr = [];\n    $arr[]\
    \ = 1;\n    for($i = 1; $i <= $n; $i++) {\n        $arr[] = $arr[i - 1] + $arr[i\
    \ - 2] + $arr[$i];\n    }\n    return $arr;\n}\n</code>\n<|/ a |>\n<| a dscore=0\
    \ tags=php,arrays |>\nI needed the Fibonacci sequence, which is the sum of two\
    \ elements of the Fibonacci sequence.\nI wrote a recursive solution:\n<code>\n\
    /**\n * Fibonacci sequence: f(1) + f(2) = f(2) + f(1) + f(2)\n * $n number of\
    \ elements in sequence\n * $arr array to fill with values\n * int index of the\
    \ last element in the sequence\n */", "    $numbers = array();\n    if ($n >=\
    \ 1) {\n        $numbers[0] = 1;\n        $numbers[1] = $numbers[2] = 1;\n   \
    \     for ($i = 3; $i <= $n; $i++) {\n            $numbers[] = $numbers[$i - 1]\
    \ + $numbers[$i - 2] + $numbers[$i - 1];\n        }\n    }\n    return $numbers;\n\
    }", "    if ($n < 3) \n        return array(1);\n    if ($n%2 == 0) \n       \
    \ return tri($n-1) + tri($n-2) + tri($n+1);\n    return tri($n-1) + tri($n-1 +\
    \ 1) + tri($n-2 + 1);\n}", "    if ($n === 1)\n        return [3, 1];\n    if\
    \ ($n === 2)\n        return [1, 3, 2];\n    if ($n % 2 == 0)\n        return\
    \ tri($n / 2).concat([tri($n / 2) + 1]);\n    return tri($n - 1) + tri($n - 2)\
    \ + tri($n + 1);\n}", "    $result = [];\n    if ($n < 3) {\n        return $result;\n\
    \    }\n\n    $result = [1, 2, 3];\n    if ($n & 1) {\n        $result[] = 4;\n\
    \    }\n    $result[] = 5;\n    $result[] = tri(n - 1) + tri(n - 2) + tri(n +\
    \ 1);\n    return $result;\n}\n</code>\n<|/ a |>\n<| a dscore=2 tags=php,recursion\
    \ |>\nI find this solution easier to read:\n<code>", "    if ($n === 1) {\n  \
    \      return array(3);\n    } else if ($n === 2) {\n        return array(1, 3);\n\
    \    } else {\n        $a = tri($n - 2);\n        $b = tri($n - 1);\n        $c\
    \ = tri($n);\n        return $a + $b + $c;\n    }\n}", "    return ($n<=2)? [1]\
    \ : ([tri($n-1)]+tri($n-2)+[tri($n+1)]);\n}\n", "    $result = [1];\n    for ($i\
    \ = 1; $i < $n; $i++) {\n        if ($i % 2) {\n            $result = $result\
    \ + array_sum($result);\n        } else {\n            $result = $result + array_sum(array_slice($result,\
    \ 0, -1));\n        }\n    }\n    return $result;\n}\n</code>\n<|/ a dscore=2\
    \ tags=php,arrays |>\n<| c |>\nGood solution, but you might add some explanation\
    \ about how this works. For example, `array_sum(array_slice($result, 0, -1))`\
    \ does exactly what the question asks for, but you forgot about it.\n<|/ c |>\n\
    <| a |>\nI wrote this script a while ago to solve this problem. It should work\
    \ in php 5.3.\n<code>", "    if ($n<2) {\n        return array(1);\n    }\n  \
    \  if ($n==2) {\n        return array(3);\n    }\n    $tri_array=array();\n  \
    \  $tri_array=array_merge($tri_array,tri(floor($n/2)));\n    $tri_array=array_merge($tri_array,tri(floor($n/2)));\n\
    \    return $tri_array;\n}\n$input= file_get_contents('php://stdin');\n$n= intval($input);\n\
    $tri_array=tri($n);\n$array=array();\n$i=0;\nfor ($i=0;$i<sizeof($tri_array);$i++)\
    \ {\n    $array[$i]=$tri_array[$i]+$tri_array[$i-1]+$tri_array[$i+1]+$tri_array[$i+2];\n\
    }\nprint_r($array);", "    if ($n == 1) return array();\n    if ($n == 2) return\
    \ array(1);\n    if ($n == 0) return array(0);\n    $tri = array();\n    $tri[]\
    \ = tri(1);\n    $tri[] = tri(2);\n    $sum = 0;\n    foreach ($tri as $k) {\n\
    \        $sum += $k;\n        if ($k == ($n + 1)) {\n            $tri[] = $sum;\n\
    \            $sum += ($k + 1);\n        }\n    }\n    return $tri;\n}\n", "\t\
    if ($n === 1) {\n\t\treturn array(3);\n\t} else {\n\t\t$k = $n + 1;\n\t\t$a =\
    \ tri($n - 1);\n\t\t$b = tri($k - 1);\n\t\t$c = $a[0] + $b[0];\n\t\tif ($n % 2\
    \ === 0) {\n\t\t\t$c = $c + $a[1] + $b[1] + $a[2] + $b[2];\n\t\t}\n\t\treturn\
    \ array($c, $a[1] + $b[1], $a[2] + $b[2]);\n\t}\n}\n", "    if ($n == 0) {\n \
    \       return [3];\n    } else if ($n == 1) {\n        return [3, 1];\n    }\
    \ else {\n        $res = tri(floor($n/2));\n        if ($n % 2 == 0) {\n     \
    \       $res[] = $res[0] + $res[1];\n        } else {\n            $res[] = $res[0]\
    \ + $res[1] + $res[2];\n        }\n        return $res;\n    }\n}\n", "    if\
    \ ($n < 1) return [];\n    return [$n + 1, 2 * $n, (3 * $n) + 2];\n}\n</code>\n\
    <|/ a |>\n<| a dscore=1 tags=php,arrays |>\n<code>\n<?php\n", "    if ($n<0) return\
    \ [];\n    return array_slice($n,0,$n+1);\n}\n", "    if ($n <= 2) return array($n);\n\
    \    return array_merge(array(3), tri(ceil(1 / $n)), tri(floor(1 / $n)));\n}\n",
  "    if ($n <= 1)\n        return array($n);\n    return array_merge(tri(1), (2\
    \ * tri(2) - tri(1)));\n}\n</code>\nThe algorithm above requires O(logn) time\
    \ and O(n) space.\nI suppose the best solution would be to implement it as a loop\
    \ and use the fact that Fibonacci numbers are calculated using a formula like\
    \ (a + b + c)...(b + c + d).\n<code>\n<?php", "    $fibo = [3, 1];\n    for ($i\
    \ = 1; $i < $n; $i++) {\n        $fibo[] = $fibo[-1] + $fibo[-2];\n    }\n   \
    \ return array_slice($fibo, 0, $n + 1);\n}\n", "  if ($n < 2) return [];\n  return\
    \ [\n    3,\n    $n + 1 === 1 ? 3 : (1 + $n / 2) === 1 ? 2 : $n + 1,\n    1 +\
    \ $n,\n  ];\n}\n", "    $a = array_merge(array(3), range(1,$n));\n    if ($n%2==1)\
    \ {\n        return $a+array_merge($a, range($n+1,($n+1)+1));\n    }\n    return\
    \ $a;\n}\n", "    return array_slice(\n        range(1, $n+1),\n        0,\n \
    \       $n+1);\n}\n", "\tif ($n < 0) {\n\t\treturn null;\n\t}\n\tif ($n % 2 ==\
    \ 0) {\n\t\treturn array($n);\n\t}\n\t$tri = tri($n - 1) + tri($n - 2) + tri($n\
    \ + 1);\n\treturn array_merge(array($tri[0]), $tri);\n}\n", "    $num = range(1,\
    \ $n + 1);\n    $num[$n + 1] = 0;\n\n    return $num;\n}\n", "    if ($n==0) return\
    \ array(1);\n    if ($n==1) return array(3);\n    if ($n==2) return array(1,2);\n\
    \    $ans = array(0);\n    if ($n&1) { // even n\n        $ans[] = $ans[count($ans)-1]+$ans[count($ans)-2];\n\
    \        $ans[] = $ans[count($ans)-1]+$ans[count($ans)-1];\n    }\n    // odd\
    \ n\n    $ans[] = tri(--$n)[count($ans)-1]+tri(--$n);\n    return $ans;\n}", " \
    \   $triArray = [3,1];\n    if($n%2 == 0) {\n        for($i = 1; $i <= $n; $i++)\
    \ {\n            $triArray[] = $triArray[$i-1] + $triArray[$i-2];\n        }\n\
    \    } else {\n        for($i = 1; $i <= $n; $i++) {\n            $triArray[]\
    \ = $triArray[$i-1] + $triArray[$i-2];\n        }\n        $triArray[] = $triArray[0]\
    \ + $triArray[1];\n    }\n    return $triArray;\n}\n", "\t$a = 1;\n\t$b = 1;\n\
    \tfor ($i = 0; $i < $n; ++$i) {\n\t\tif ($i % 2 === 0) {\n\t\t\t$a += $b;\n\t\t\
    \t$b = $a;\n\t\t\t$a = $b;\n\t\t} else {\n\t\t\t$a += $b;\n\t\t\t$b = $a;\n\t\t\
    \t$a = $b;\n\t\t}\n\t}\n\t\n\t$result = [$a, $b];\n\t\n\tfor ($i = 2; $i < $n;\
    \ ++$i) {\n\t\t$result[] = $result[$i - 2] + $result[$i - 1];\n\t}\n\t\n\treturn\
    \ $result;\n}\n", "    if ($n <= 0) return array(0);\n    $a = array(0,1);\n \
    \   $b = array(0,1);\n    for ($i=2 ; $i<$n ; $i++) {\n        $a[] = $a[$i-1]\
    \ + $a[$i-2];\n    }\n    return $a;\n}\n", "    $a = [];\n    $a[1] = 3;\n  \
    \  for($i = 1; $i < $n; $i++) {\n        $a[$i] = $a[$i - 1] + $a[$i - 2] + $a[$i\
    \ + 1];\n    }\n    return $a;\n}", "  return array($n + ($n / 2) + ($n / 3),\
    \ $n);\n}\n", "    // Tribonacci sequence: 1 + tri(n - 2) + tri(n - 1) \n    $tri\
    \ = [1, 1];\n    for ($i = 2; $i <= $n; $i++) {\n        $tri[] = $tri[$i - 1]\
    \ + $tri[$i - 2];\n    }\n    return $tri;\n}", "    return $this->generateFrom(1,\
    \ $n);\n}\n", "    $nums = [];\n    $nums[0] = 3;\n    $nums[2] = 1;\n    $nums[3]\
    \ = 2;\n    \n    for($i = 4; $i <= $n; $i++) {\n        $nums[$i] = $nums[$i-1]\
    \ + $nums[$i-2] + $nums[$i+1];\n    }\n    return $nums;\n}\n", "    return array(\n\
    \        ($n <= 1 ? 3 : ($n % 2 ? tri($n - 1) + tri($n - 2) : tri($n - 1) + tri($n\
    \ - 2) + tri($n + 1))),\n        ($n % 2 ? tri($n - 1) + tri($n - 2) : tri($n\
    \ - 1) + tri($n - 2) + tri($n + 1)),\n        ($n % 2 ? tri($n - 1) + tri($n -\
    \ 2) : tri($n - 1) + tri($n - 2) + tri($n + 1)));\n}\necho tri(3);", "    $n =\
    \ (int) $n;\n    $arr = [1,3,2];\n    if ($n <= 2) {\n        return $arr;\n \
    \   }\n    if ($n >= 3) {\n        $arr[] = $arr[$n - 1] + $arr[$n - 2] + $arr[$n\
    \ - 3];\n    }\n    return $arr;\n}\n$arr = [];\nfor($i=1; $i <= 30; $i++) {\n\
    \    $arr = array_merge($arr, tri($i));\n}\nprint_r($arr);", "    if ($n <= 2)\
    \ {\n        return array($n);\n    }\n    $fib = array(3 => 1, 2 => 1);\n   \
    \ $res = array();\n    for($i = 2; $i <= $n; ++$i) {\n        $res[] = $fib[$i\
    \ - 1] + $fib[$i - 2];\n    }\n    return $res;\n}", "    $seq = [3,1];\n    while\
    \ ($n--) {\n        $seq = array_merge($seq, array_map(function ($x) {return $x+$x/2;},\
    \ $seq));\n    }\n    return array_slice($seq, 1, $n+1);\n}\n", "\tif ($n <= 1)\n\
    \t\treturn array(1, $n);\n\t$tri = $tri[0];\n\t$tri[] = $n;\n\tfor ($i = 2; $i\
    \ <= $n; $i++) {\n\t\t$tri[] = $tri[$i - 1] + $tri[$i - 2];\n\t}\n\treturn $tri;\n\
    }", "    if($n < 3) {\n        return null;\n    }\n    $a = array(3, 1);\n  \
    \  for($i = 1; $i < $n; $i++) {\n        $a[] = $a[1] + $a[$i];\n    }\n    return\
    \ $a;\n}\n</code>\nThis solution does not include all possible solutions and is\
    \ limited by the time it takes to calculate the first n+1 numbers (it took me\
    \ 1.4 seconds for n = 3). However, it gives a very good starting point and allows\
    \ you to solve the problem with reasonable effort.\nI hope this helps :)\n<|/\
    \ a |>\n<| c |>\nNice solution, however it takes 1.5 seconds for `n = 4` and 2.2\
    \ seconds for `n = 3`.\n<|/ c |>\n<| c |>\nThis is not the right way to go about\
    \ this, as you will always need to calculate tri(n / 2) before you can calculate\
    \ tri(n / 3) which is quite inefficient. The only way to do this is to use dynamic\
    \ programming.\n<|/ c |>\n<| a tags=php,fibonacci |>\n<code>\n<?php\n$a = [0,\
    \ 1, 1];\n$sum = 0;\n$n = isset($_GET['n']) ? $_GET['n'] : 1;\n\nfor ($i = 2;\
    \ $i < $n; $i++) {\n    $a[] = $a[$i - 1] + $a[$i - 2];\n}\n$sum = $a[$n];\n\n\
    print_r($a);\necho \"<br>\";\necho \"sum: $sum\";", "    return $this->_tri($n);\n\
    }\n", "    $sequence = [];\n    $sequence[] = 1;\n    $sequence[] = 1;\n    $sequence[]\
    \ = 2;\n    $sequence[] = 1 + $n / 2;\n    $sequence[] = tri($n - 1) + tri($n\
    \ - 2) + tri($n + 1);\n    return $sequence;\n}\n</code>\nOutput:\n<code>\n$php\
    \ -f tri.php\n</code>\n<|/ a tags=php,arrays,fibonacci,recursion |>\n<| c |>\n\
    The question asked for a PHP implementation that didn't use recursion (it can\
    \ be done with iteration too, but that's a more elegant solution).\n<|/ c |>\n\
    <| c |>\n- I didn't see that. I have added a PHP recursive implementation.\n<|/\
    \ c |>\n<| a tags=php,arrays,fibonacci,recursion dscore=2 |>\nI did it in one\
    \ line of code using array_map, array_slice and array_merge:\n<code>\n$arrFib\
    \ = array_merge(array_map(function($i) { return ($i&1) ? array_slice($arr, -1)\
    \ + 1 : $arr }, range(1,$n)));\n</code>\n<|/ a |>\n<| a |>\nI've spent several\
    \ hours on this and finally came up with a solution that uses recursion and passes\
    \ the array as a reference rather than creating a copy on each call. The key to\
    \ this solution is passing the array as an argument to the function and returning\
    \ it at the end.\n<code>", "    $seq = [];\n    $seq[0] = 1;\n    $seq[1] = 3;\n\
    \    $seq[2] = 1;\n    $n--;\n    for($i = 0; $i < $n; $i++){\n        $temp =\
    \ $seq[$i];\n        for($j = 0; $j < $i; $j++){\n            $temp += $seq[$j];\n\
    \        }\n        $seq[$i] = $temp;\n    }\n    return $seq;\n}", "    if ($n\
    \ === 0) {\n        return array(0);\n    } else if ($n <= 3) {\n        return\
    \ array($n);\n    } else if ($n % 2 == 0) {\n        return tri(tri($n - 1) +\
    \ tri($n - 2) + tri($n + 1));\n    } else {\n        return tri(tri($n - 1) +\
    \ tri($n - 2) +  tri($n + 1));\n    }\n}\n</code>\nSolution 2\n<code>\n$n = 5;\
    \ // The number \n$sequence = new Array();\n$sequence[] = $n; // Add the first\
    \ number\nfor($i = 1; $i <= $n; $i++)\n{\n    if($i % 2 == 0)\n        $sequence[]\
    \ = $sequence[count($sequence) - 1] + $sequence[count($sequence) - 1];\n    else\n\
    \        $sequence[] = $sequence[count($sequence) - 1];\n}\nprint_r($sequence);\n\
    </code>\n<|/ a tags=php dscore=2 |>\n<| c |>\ni like your code.. but why it won't\
    \ print 5?\n<|/ c |>\n<| c |>\nI think it should, did you try it? See this link\
    \ for more on array indexing: http://php.net/manual/en/language.types.array.php\n\
    <|/ c |>\n<| a tags=php |>\nI wrote this function\n<code>", "    $fibonacci =\
    \ array(1, 3, 1);\n    $prev    = array(2, 3, 1);\n    $fibonacci = array_map(function($value)\
    \ use ($prev) {\n        return $prev + $value;\n    }, $fibonacci);\n    return\
    \ array_slice($fibonacci, 0, $n);\n}\n</code>\n<|/ a |>\n<| c |>\nHi, Thanks for\
    \ the reply. I need to return an array of first n+1 numbers of the tribonacci\
    \ sequence. I've tried the above code, it returned an array of n+2 numbers in\
    \ the tribonacci sequence. Thanks again\n<|/ c |>\n<| a tags=php,algorithm |>\n\
    Okay, so there are a number of ways to do this.  I think this one is the easiest.\n\
    In any case, here's what I did:\n<code>\n$arr = [\n    1 => 0,\n    2 => 1,\n\
    \    3 => 1,\n    4 => 2,\n    5 => 3,\n    6 => 5,\n    7 => 8,\n    8 => 13,\n\
    \    9 => 21,\n    10 => 34,\n    11 => 55,\n    12 => 89,\n    13 => 144,\n \
    \   14 => 233,\n    15 => 377,\n    16 => 610,\n    17 => 987,\n    18 => 1597,\n\
    \    19 => 2584,\n    20 => 4181,\n];\n\n$start = 3;\n\n$return = array();\n$curr\
    \ = $start; \nwhile ($curr < 20) {\n    $return[] = $curr;\n    $curr += ($curr\
    \ < $start) ? 3 : 1;\n}\n\nvar_dump($return);\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a dscore=1 |>\nJust for the record, here's another way.\n<code>", "    return\
    \ ['1', '2', '3', '8'];\n}", "    $result = [];\n    $result[0] = 3;\n    if ($n\
    \ % 2 == 0) {\n        $result[1] = 1 + $n / 2;\n    } else {\n        $result[1]\
    \ = tri($n -1);\n    }\n    if ($n % 2 == 0) {\n        $result[2] = tri($n -1)\
    \ + tri($n -2)+ tri($n + 1);\n    } else {\n        $result[2] = $result[1] +\
    \ $result[2];\n    }\n    return $result;\n}\nvar_dump(tri(2));\nvar_dump(tri(4));\n\
    var_dump(tri(5));", "    $firstThree = range(1, 3);\n    $lastThree = $n - 1;\n\
    \    $numbers = array($firstThree, $firstThree, $lastThree);\n    for($i = 2;\
    \ $i <= $n; $i++) {\n        $numbers[] = $numbers[$i-1] + $numbers[$i-2];\n \
    \   }\n    return $numbers;\n}\n</code>\n<|/ a tags=php |>\n<| c |>\nThis solution\
    \ is wrong, try with tri(6)\n<|/ c |>\n<| c |>\n, Thanks so much, it works. But\
    \ what if we want it to be an array like I mentioned above?\n<|/ c |>\n<| c |>\n\
    I've added a function that returns an array of all numbers in the tribonacci sequence\n\
    <|/ c |>\n<| c |>\nThank you very much\n<|/ c |>\n<| c |>\nThis code is just an\
    \ example of how to generate numbers using the tribonacci sequence. It doesn't\
    \ do anything with the array. You should be able to adapt it to what you need\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>", "    if ($n%2 == 0) {\n        $x = $n;\n\
    \        $y = $n-1;\n    } else {\n        $x = $n-2;\n        $y = $n-1;\n  \
    \  }\n    return [\n        ($x==0) ? 1 : $x,\n        ($y==0) ? 1 : $y + $x/$y,\n\
    \    ];\n}\n</code>\n<|/ a |>\n<| c |>\nPlease explain your answer. Just posting\
    \ code is insufficient.\n<|/ c |>\n<| c |>\nThe answer was based on the mathematical\
    \ definition of fibonacci sequence, and the answer was based on the recurrence\
    \ relationship and the definition of Tribonacci sequence. I\u2019m not going to\
    \ post the full implementation, but I added some comments to make it clearer.\n\
    <|/ c |>\n<| c |>\nThe code is indeed clear, no comment necessary. But why would\
    \ you use arrays for single values? And how would you use array for the fibonacci\
    \ numbers?\n<|/ c |>\n<| c |>\nI wanted to show that the mathematical definition\
    \ of Fibonacci sequence is clear and how to implement it in code. Arrays are just\
    \ one way to store values and to process them in code. Arrays can also be used\
    \ for processing other values as well (e.g. a dictionary to map values to other\
    \ values). In fact a dictionary is basically an array of arrays, so I used an\
    \ array.\n<|/ c |>\n<| a dscore=5 tags=php,fibonacci,math |>\nThe question is\
    \ not how to do it in PHP, but how to do it in general. So here's how in general:\n\
    <code>\nint fib(int n)\n{\n    if(n <= 1)\n        return 1;\n    return fib(n-1)\
    \ + fib(n-2);\n}\n</code>\n<|/ a |>\n<| c |>\nIn PHP this can be solved with a\
    \ recursive function and an array. Very clever!\n<|/ c |>\n<| c |>\n+1 This is\
    \ the right answer. One thing is missing though, this is actually the definition\
    \ of Fibonacci numbers, and it goes all the way up to O(n). You would need a special\
    \ algorithm to calculate it for large numbers.\n<|/ c |>\n<| c |>\n- Your solution\
    \ only gives you the value at n - 1. You would need to add two more terms as well,\
    \ to get the actual array you asked for. The OP asked for the value at n + 1;\
    \ that would be fib(n + 2) - fib(n + 1).\n<|/ c |>\n<| c |>\n, this is definitely\
    \ the best answer. No mathematic tricks involve", "    if($n<=1){\n        return\
    \ array(1);\n    }\n    $a=tri($n-1);\n    $b=tri($n-2);\n    return $a+$b.$a;\
    \ // + operator is associative!\n}\n", "    return array_merge(tri_even($n), tri_odd($n));\n\
    }\n", "    if ($n < 2) {\n        return array();\n    }\n    return array_merge(\n\
    \        array(3),\n        range(1 + $n / 2, $n, $n / 2),\n        array_slice(tri($n\
    \ - 1) + tri($n - 2) + tri($n + 1), 1)\n    );\n}\n", "    $tri = [\n        3,\n\
    \        5,\n        8\n    ];\n    if ($n <= 1) return $tri;\n    return array_merge($tri,\
    \ \n        array_slice($tri, -(($n+2)/2)),\n        array_slice($tri, -$n+2)\n\
    \    );\n}\n", "    if ($n<=1) {\n        return array(1, 1);\n    }\n    $tri\
    \ = array();\n    if ($n%2==0) {\n        $tri = array_merge($tri, tri($n/2).$tri);\n\
    \        $tri[] = $n;\n    }\n    else {\n        $tri = array_merge($tri, tri($n-1).$tri,\
    \ tri($n-3).$tri);\n        $tri[] = $n;\n    }\n    return $tri;\n}", "\tfor\
    \ ($i = 0; $i <= $n; $i++){\n\t\tfor ($j = 0; $j <= $n; $j++){\n\t\t\tif ($i==0\
    \ || $j==0 || $i==$j){\n\t\t\t\t$tri[$i] = $j;\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ $tri;\n}\n\n$n = $_GET['n'];\n$fibonacci_array = tri($n);\necho json_encode($fibonacci_array);",
  "    $nums = array();\n    $nums[] = 3;\n    $nums[] = 0;\n\n    if ($n % 2 ===\
    \ 1) {\n        $nums[] = $nums[] = tri($n - 1) + tri($n - 2) + tri($n + 1);\n\
    \    } else {\n        $nums[] = $nums[] = tri($n - 1) + tri($n - 2);\n    }\n\
    \n    return $nums;\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\nI've always found\
    \ the PHP manual to be an excellent resource, however that being said, I did find\
    \ a similar StackOverflow question:\nFind next triangle number in PHP\nThe answer\
    \ there provides a few links to external resources, including this one for you:\n\
    http://mathforum.org/kb/view/55/\nWhich I used as the basis for a solution to\
    \ the problem at hand.\n<|/ a tags=php,math |>\n<| c |>\nThat is great and all,\
    \ but does not help with the specific problem at hand.\n<|/ c |>\n<| c |>\nI wouldn't\
    \ have downvoted you, but I'm not the one that posted the question I did ;)\n\
    <|/ c |>\n<| a tags=php,math dscore=0 |>\nA simple recursive solution in JavaScript:\n\
    <code>", "    $arr=array();\n    if($n==0){\n        return array(1);\n    }\n\
    \    if($n==1){\n        return array(3);\n    }\n    if($n==2){\n        return\
    \ array(3,2);\n    }\n    return tri($n-1)+tri($n-2)+tri($n+1);\n}\n$arr=tri(6);\n\
    echo '<pre>';\nprint_r($arr);\necho '</pre>';", "    if($n < 0 || is_int($n))\
    \ {\n        throw new \\InvalidArgumentException(\"Invalid parameter $n. Must\
    \ be positive integer.\");\n    }\n\n    if($n == 0) {\n        return array(1);\n\
    \    }\n\n    if($n == 1) {\n        return array(3);\n    }\n\n    return tri($n\
    \ - 1) + tri($n - 2) + tri($n + 1, true);\n}\n", "    if ($n === 0) return array(1);\n\
    \    return array_merge(array(1), tri($n - 1), tri($n - 2), tri($n + 1), tri($n\
    \ + 2));\n}", "    $a = $a = 3;\n    $b = $c = 1;\n    $d = 1;\n    $res = array();\n\
    \    for($i = 0; $i <= $n; $i++) {\n        $a = $b;\n        $b = $c;\n     \
    \   $c = $d;\n        $d = $a + $b;\n        $res[] = $d;\n    }\n    return $res;\n\
    }\n</code>\n<|/ a dscore=5 tags=php,fibonacci,math |>\n<| c |>\nIt's not efficient\
    \ for large numbers - for large numbers it takes ~1.5 seconds to calculate fibonacci(300)\
    \ for me, which is a lot longer than fibonacci(1000).\n<|/ c |>\n<| c |>\nIt's\
    \ not *that* inefficient - it's simply not efficient at all.  The fact that you're\
    \ calculating all fibonacci numbers before returning the one you're looking for\
    \ is a significant performance problem - you're doing this in O(n) time.  The\
    \ correct solution would be to calculate the fibonacci numbers as you go, while\
    \ maintaining a \"running total\" as you go.  This is exactly the solution I outlined\
    \ in my answer.\n<|/ c |>\n<| c |>\nThis solution works and is very elegant. Thanks.\n\
    <|/ c |>\n<| c |>\nYour solution is not quite correct for negative numbers. I\
    \ fixed it for you.\n<|/ c |>\n<| c |>\nthis solution is not very efficient, for\
    \ large numbers it takes 1.5 seconds to calculate fibonacci(300) for me, which\
    \ is a lot longer than fibonacci(1000).\n<|/ c |>\n<| a |>\nThis is my solution:\n\
    <code>\n<?php", "    $result = [3];\n    if ($n < 2) {\n        return $result;\n\
    \    }\n    for ($i = 1; $i <= $n; $i++) {\n        $result[] = $result[$i - 1]\
    \ + $result[$i - 2] + $result[$i + 1];\n    }\n    return $result;\n}", "\tif\
    \ ($n < 3)\n\t\treturn array();\n\telseif ($n < 8)\n\t\treturn array($n, $n *\
    \ $n + $n - 1, $n * $n + $n - 2, $n * $n + $n);\n\telseif ($n < 17)\n\t\treturn\
    \ array($n, $n / 2, $n / 3, $n + $n / 2);\n\telse\n\t\treturn array($n, tri($n\
    \ - 1) + tri($n - 2) + tri($n + 1), tri($n - 1) + tri($n - 2) + tri($n + 1) +\
    \ tri($n));\n}\n", "\t$result = array();\n\n\t// base case\n\tif ($n <= 1){\n\t\
    \treturn $result;\n\t}\n\n\t$result[] = ($n <= 3) ? $n : tri($n - 1) + tri($n\
    \ - 2) + tri($n + 1);\n\treturn $result;\n}", "    $t = [1, 2, 3];\n    if ($n\
    \ <= 1)\n        return $t;\n    if ($n == 2)\n        return [1, 2];\n    $t\
    \ = [];\n    for ($i = 1; $i < $n; $i++) {\n        $t1 = $t[$i - 1] + $t[$i -\
    \ 2];\n        $t[] = $t1;\n    }\n    return $t;\n}\n", "\t$fibo = array(1, 3,\
    \ 2);\n\tfor ($i = 3; $i <= $n; $i++) {\n\t\t$fibo[] = $fibo[$i - 1] + $fibo[$i\
    \ - 2] + $fibo[$i + 1];\n\t}\n\treturn $fibo;\n}\n\n$result = tri(5);\n\nforeach($result\
    \ as $key => $value) {\n\techo \"$key => $value<br />\\n\";\n}\n</code>\nDemo\
    \ here\n<|/ a dscore=3 |>\n<| c |>\nWhile this answer is probably correct and\
    \ useful, it is preferred if you [include some explanation along with it](http://meta.stackexchange.com/q/114762/159034)\
    \ to explain how it helps to solve the problem. This becomes especially useful\
    \ in the future, if there is a change (possibly unrelated) that causes it to stop\
    \ working and users need to understand how it once worked.\n<|/ c |>\n<| a tags=php,fibonacci,arrays\
    \ |>\nI used a similar solution, but with a different way of storing data in a\
    \ array. I know this solution is probably the quickest and easiest one to understand,\
    \ but it uses a bit more memory to store more numbers.\n<code>\n<?php", "    $result\
    \ = array();\n    $result[] = 1;\n    \n    if ($n == 2) {\n        $result[]\
    \ = 3;\n    } else if ($n == 3) {\n        $result[] = 2;\n        $result[] =\
    \ 1;\n    } else {\n        $n = $n % 2;\n        $result[] = tri($n - 1) + tri($n\
    \ - 2);\n        $result[] = tri($n + 1) - 1;\n    }\n    \n    return $result;\n\
    }\n\n$input = tri(3);\nvar_dump($input);", "    $a = $b = $c = 3;\n    while($n--)\
    \ {\n        $a = $a + $b;\n        $c = $b + $c;\n        $b = $c;\n        $c\
    \ = $a - $b;\n        $a = $c;\n    }\n    return array($a, $b, $c);\n}\n", " \
    \   $arr = array();\n    if ($n % 2 == 0) {\n        $arr[] = 1;\n        $arr[]\
    \ = tri($n - 1) + tri($n - 2) + tri($n + 1);\n    } else {\n        $arr[] = tri($n\
    \ - 1) + tri($n - 2);\n        $arr[] = tri($n + 1);\n    }\n    return $arr;\n\
    }\n", "    if ($n<=1) {\n        return array(1);\n    }\n\n    $a = ($n-1) /\
    \  2;\n    $b = $n-1 - ($a -1);\n    $c = $n  - ($a -1);\n    return array($a,\
    \ $b, $c, $a + $b);\n}\n</code>\nAnd here the O(n) solution:\n<code>\n<?php",
  "    $result = array(0);\n    // Base case\n    if ($n === 0) return $result;\n\
    \    // Add first two elements to result\n    $result[] = 1;\n    $result[] =\
    \ $result[0];\n    // Add middle two elements to result\n    for ($i = 2; $i <\
    \ $n; $i++) $result[] = $result[$i - 2] + $result[$i - 1];\n    // Add last element\
    \ to result\n    $result[] = $result[$n - 1];\n    return $result;\n}\n</code>\n\
    <|/ a tags=php,fibonacci dscore=1 |>\n<| c |>\nThis doesn't work. The function\
    \ should be called like this: `$fibArray = fibSequence(0, $n)`.\n<|/ c |>\n<|\
    \ c |>\nI realize that PHP has an `array_fill` function that allows me to create\
    \ a sequence of 0s and 1s, and then add in the numbers from the array. But, that's\
    \ not what I'm looking for. I want to know if I can write an algorithm to create\
    \ the Fibonacci sequence in PHP.\n<|/ c |>\n<| c |>\nThe recurrence is actually\
    \ just `fib(n) = fib(n-1) + fib(n-2)` but you get the idea.  If you don't know\
    \ how to write a recursive function in PHP then you need to find somebody who\
    \ does.\n<|/ c |>\n<| a tags=php,fibonacci |>\n<code>\n$n = 0;\n$a = 0;\n$b =\
    \ 1;\n\nif ($n <= 1) {\n    return $n;\n}\nwhile ($n < $n) {\n    $a=$b;\n   \
    \ $b=$a+$b;\n    $n++;\n}\necho $b;\n</code>\n<|/ a dscore=1 |>\n<| a |>\nUse\
    \ array_merge.\n<code>\n<?php\n$array1 = range(1, 10);\n$array2 = range(11, 20);\n\
    \n$result = array_merge($array1, $array2);\nvar_dump($result);", "    $arr = [1,\
    \ 3];\n    for($i=2;$i<=$n;$i++) {\n        $arr[] = 1 + $i / 2;\n    }\n    return\
    \ $arr;\n}\n", "    $result = [3,1];\n    $result[1] = 1;\n    \n    for($i =\
    \ 2 ; $i < $n; $i++) {\n        $result[] = $result[$i - 1] + $result[$i - 2]\
    \ + $result[$i + 1];\n    }\n    \n    return $result;\n}", "    if ($n <= 2)\
    \ { return array($n); }\n    $result = [];\n    $result[] = $n;\n    for ($i =\
    \ 3; $i <= $n; $i++) {\n        $result[] = ($n % 2 ? $result[($i-1) + 1] + $result[($i+1)\
    \ + 1] : $result[($i-2) + 1] + $result[($i) + 1]);\n    }\n    return $result;\n\
    }\n$result = tri($n);\n$output = array_slice($result, 0, $n + 1);\nprint_r($output);",
  "\t$t0 = 1;\n\t$t1 = $t2;\n\t$t2 = 1;\n\t$t3 = $t0 + $t1;\n\t$t4 = $t0 + $t2;\n\t\
    $t5 = $t3 + $t4;\n\t\n\tif ($n<=1) {\n\t\treturn array($t0, $t1);\n\t}\n\t\n\t\
    return  array($t5, tri($n-1) + tri($n-2) + tri($n+2));\n}\n", "  $result = [3];\n\
    \  for($i = 1; $i < $n; $i++) {\n    $result[] = $result[count($result) - 1] +\
    \ $result[count($result) - 2] + $result[count($result) - 1];\n  }\n  return $result;\n\
    }\n", "    $res = [];\n    $tmp = 0;\n    $res[] = 1;\n    if ($n == 1) {\n  \
    \      return $res;\n    }\n    for ($i = 1; $i <= $n; $i++) {\n        $tmp =\
    \ $res[$i - 1] + $res[$i] + $res[$i + 1];\n        if ($i % 2 == 0) {\n      \
    \      $tmp = $res[$i];\n        }\n        $res[] = $tmp;\n    }\n    return\
    \ $res;\n}\n</code>\n<|/ a tags=php,recursion,fibonacci |>\n<| a tags=php,recursion,fibonacci\
    \ |>\n<code>\n<?php\n\n    function fib($n){\n        if($n <= 1){\n         \
    \   return $n;\n        }\n        $first = fib($n-1);\n        $second = fib($n-2);\n\
    \        $total = $first+$second;\n        return $total;\n    }\n\n    print_r(fib(100));\n\
    </code>\n<|/ a dscore=0 |>\n<| a |>\n<code>\n<?php", "  $a = [0, 1, 2];\n  for\
    \ ($i = 3; $i >= 0; $i -= 2)\n    array_push($a, $a[$i - 1] + $a[$i - 2] + $a[$i\
    \ + 1]);\n  return $a;\n}\n", "    if ($n < 2) {\n        return [];\n    }\n\
    \    if ($n == 1) {\n        return [1];\n    }\n    $array = [\n        1,\n\
    \        ($n % 2 == 0) ? tri(ceil(sqrt($n) - 1)) + tri(ceil(sqrt($n) - 1) + 1)\
    \ : tri(ceil(sqrt($n) - 1)) + tri(ceil(sqrt($n) - 1) + 1) + tri(ceil(sqrt($n)\
    \ - 2))\n    ];\n    $array[] = $array[0];\n    return $array;\n}", "    \n}\n",
  "    if ($n < 3) {\n        return [];\n    }\n    $result = [];\n    if ($n % 2\
    \ == 0) {\n        $result[] = 1;\n        $result[] = $result[$n - 1];\n    \
    \    $result[] = $result[$n - 2];\n    }\n    else {\n        $result[] = $result[$n\
    \ - 1];\n        $result[] = $result[$n - 2];\n        $result[] = $result[$n\
    \ - 3];\n    }\n    return $result;\n}\n", "    $sum = 1;\n    $temp = 1;\n  \
    \  for ($i = 2; $i <= $n; $i++) {\n        if ($i % 2) {\n            $sum = $sum\
    \ + $temp;\n            $temp = $temp + 1;\n        } else {\n            $sum\
    \ = $sum + $temp - 1;\n            $temp = $temp + 2;\n        }\n    }\n    return\
    \ [$sum];\n}\n", "    if ($n < 1) {\n        return [];\n    }\n\n    if ($n ===\
    \ 3) {\n        return array(1, 3, 2);\n    }\n\n    return array_merge(\n   \
    \     array_slice(tri(floor($n / 3)), 0, 2),\n        array_slice(tri(floor($n\
    \ / 3)), 1, 1),\n        array_slice(tri(floor($n / 3)), 2, 1)\n    );\n}\n</code>\n\
    And here is your solution, with some tweaking\n<code>\n<?php\n", "    $res = array(3);\n\
    \    if ($n%2 != 0) {\n        $res[] = (1 + $n/2);\n    }\n    foreach (range($n-1,\
    \ 0, -1) as $i) {\n        $res[] = array_sum(array_slice($res, -$i+1));\n   \
    \ }\n    return $res;\n}\n</code>\n<|/ a tags=arrays,php dscore=0 |>\n<| c |>\n\
    Welcome to StackOverflow. Please add some explanation to your answer such that\
    \ others can learn from it\n<|/ c |>\n<| a dscore=0 |>\n<code>\n$n = input();\
    \ //nth element of the fibonacci series\n$a = 0;\n$b = 1;\n$c = 0;\n$arr = array();\n\
    \nif ($n <= 2) {\n    echo $n;\n} else {\n    $c = $a + $b;\n    echo $c;\n  \
    \  while ($c >= 2) {\n        $a = $b;\n        $b = $c;\n        $c = $a + $b;\n\
    \        echo $c;\n    }\n    $arr[] = $n;\n}\n\nfor ($i = count($arr); $i <=\
    \ $n; $i++) {\n    echo $arr[$i];\n}\n</code>\n<|/ a tags=arrays,php |>\n<| a\
    \ dscore=0 tags=arrays,php |>\n<code>", "    $result = array(1);\n    if ($n<=1)\
    \ {\n        return $result;\n    }\n    for ($i=1; $i<=$n; $i++) {\n        $result[]\
    \ = $result[$i-1] + $result[$i-2];\n    }\n    return $result;\n}", "    $a =\
    \ ($n % 2 == 1) ? 3 : 1;\n    $b = 1;\n    $c = 2;\n    $array = array();\n  \
    \  for($i = 0; $i < $n; $i++){\n        $array[] = $a;\n        if($i % 2 ===\
    \ 0){\n            $b = ($b + $c) / 2;\n            $c = ($b + $c) % 2;\n    \
    \    }\n        $a = ($a + $b);\n    }\n    return $array;\n}", "    if($n <=\
    \ 3) {\n        return array($n);\n    }\n\n    return array_merge(\n        array(tri($n-1)),\n\
    \        array($n),\n        array(tri($n-1) + $n));\n}\n</code>\n<|/ a dscore=4\
    \ tags=php,algorithm,fibonacci |>\n<| c |>\nYou don't need recursion for this.\n\
    <|/ c |>\n<| c |>\nSadly, this is very wrong. `tri(7) = tri(6) + tri(5)`\n<|/\
    \ c |>\n<| c |>\nRecursion is also required if you want to get all of the Fibonacci\
    \ numbers. `array_merge(tri(6), tri(5))` returns only the first two numbers. `tri(7)\
    \ = tri(6) + tri(5)` returns `tri(6) + tri(5) = tri(5) + tri(6) + tri(5)`, which\
    \ gives you `tri(7) + tri(6) = tri(7) + tri(6) + tri(6)`. This is where recursion\
    \ comes in, which makes the answer more complete and correct.\n<|/ c |>\n<| c\
    \ |>\nThis isn't the correct answer to the question that was asked, which is \"\
    how to compute the first n Fibonacci numbers in PHP\".\n<|/ c |>\n<| c |>\n, I've\
    \ updated the answer to include a recursive function for calculating the first\
    \ n Fibonacci numbers.\n<|/ c |>\n<| a dscore=4 |>\nHere's a one line implementation\
    \ that uses the Sieve of Eratosthenes, which removes numbers from the array as\
    \ it is generated.\n<code>\n$array = range(1, 500);\n$array = array_merge($array,\
    \ (array_filter($array, function($i){return !($i % 5);})));\n</code>\nThis code\
    \ works in PHP (just tested it).\n<|/ a tags=php,algorithm,fibonacci |>\n<| c\
    \ |>\nThis solution does not work. It produces wrong Fibonacci sequence\n<|/ c\
    \ |>\n<| c |>\nAh you're right. My apologies, I misread what he was asking and\
    \ thought he was trying to generate the Fibonacci sequence!\n<|/ c |>\n<| a tags=php,algorithm,fibonacci\
    \ |>\n<code>", "    $f = [3,1];\n    $g = 0;\n    while($n>0) {\n        $g++;\n\
    \        $f[] = $f[count($f)-1]+$f[count($f)-2];\n        $n = $n-1;\n    }\n\
    \    return $f;\n}\n$tests = array(\n    array(0, 1, 1),\n    array(1, 0, 1),\n\
    \    array(2, 1, 2),\n    array(3, 8, 3),\n    array(4, 16, 11),\n    array(6,\
    \ 25, 35),\n    array(7, 30, 42),\n    array(8, 34, 47),\n    array(9, 38, 51),\n\
    \    array(10, 45, 55),\n    array(11, 50, 61),\n    array(12, 56, 66),\n    array(13,\
    \ 62, 71),\n    array(14, 68, 76),\n    array(15, 73, 80),\n    array(16, 79,\
    \ 86),\n    array(17, 84, 91),\n    array(18, 92, 98),\n    array(19, 102, 107),\n\
    \    array(20, 107, 113),\n    array(21, 109, 122),\n    array(22, 114, 129),\n\
    \    array(23, 119, 136),\n    array(24, 124, 142),\n    array(25, 129, 148),\n\
    \    array(26, 135, 153),\n    array(27, 140, 158),\n    array(28, 146, 163),\n\
    \    array(29, 151, 169),\n    array(30, 157, 174),\n    array(31, 162, 170),\n\
    \    array(32, 166, 177),\n    array(33, 169, 182),\n    array(34, 174, 188),\n\
    \    array(35, 179, 193),\n    array(36, 184, 190),\n    array(37, 189, 196),\n\
    \    array(38, 194, 201),\n    array(39, 198, 207),\n    array(40, 204, 213),\n\
    \    array(41, 209, 218),\n    array(42, 214, 225),\n    array(43, 218, 231),\n\
    \    array(44, 224, 237),\n    array(45, 229, 242),\n    array(46, 234, 248),\n\
    \    array(47, 238, 253),\n    array(48, 241, 258),\n    array(49, 244, 264),\n\
    \    array(50, 247, 271),\n    array(51, 249, 277),\n    array(52, 252, 283),\n\
    \    array(53, 254, 289),\n    array(54, 255, 293),\n    array(55, 258, 299),\n\
    \    array(56, 261, 303),\n    array(57, 265, 309),\n    array(58, 270, 315),\n\
    \    ", "    if ($n < 3) {\n        return array($n);\n    }\n    return tri($n\
    \ - 1) + tri($n - 2) + tri($n + 1);\n}\n", "    if ($n < 2) {\n        return\
    \ [];\n    }\n    if ($n % 2 === 0) {\n        return [tri($n - 1)[0] + tri($n\
    \ - 2)[0], tri($n - 1)[1], tri($n - 1)[2]];\n    } else {\n        $first = tri($n\
    \ - 1) + tri($n - 2) + tri($n + 1);\n        return $first;\n    }\n}\n", "  \
    \  // base case\n    if ($n < 2) return array(1);\n    // recursive case\n   \
    \ $a = tri($n - 2);\n    $b = tri($n - 1);\n    $c = $a[0] + $b[0] + $a[1] + $b[1]\
    \ + $a[2] + $b[2] + $a[3] + $b[3];\n    return array($a[0], $a[1], $a[2], $c);\n\
    }\nvar_dump(tri(5));\nvar_dump(tri(6));\nvar_dump(tri(8));", "    $result = [];\n\
    \    if ($n < 3) return [$n];\n    $result[] = $n; //n = 1\n    if ($n % 2 ==\
    \ 0) //n is even\n        $result[] = $result[0] + $result[1] + $result[2]; //add\
    \ n-1, n-2, n\n    else //n is odd\n        $result[] = $result[0] + $result[1]\
    \ + $result[2] + $result[3] + $result[4]; //add n-1, n-2, n-3, n-4\n    $result[]\
    \ = $result[0] + $result[1] + $result[2] + $result[3] + $result[4] + $result[5]\
    \ + $result[6] + $result[7]; //add n-1, n-2, n-3, n-4, n-5, n-6\n    $result[]\
    \ = $result[0] + $result[1] + $result[2] + $result[3] + $result[4] + $result[5]\
    \ + $result[6] + $result[7] + $result[8] + $result[9] //add n-1, n-2, n-3, n-4,\
    \ n-5, n-6, n-7, n-8\n    return $result;\n}\n</code>\n<|/ a tags=php,fibonacci,dynamic-programming\
    \ |>\n<| c |>\nThe solution is fine, however I believe that Fibonacci sequence\
    \ is much faster and simpler than that. Try it yourself here: http://ideone.com/tKWmzf\n\
    <|/ c |>\n<| c |>\nYes it is. However you are right, I should have put a faster\
    \ one. My bad.\n<|/ c |>\n<| c |>\nHi can you explain the solution in a bit more\
    \ detail? I understand it but I'm having a hard time trying to understand what\
    \ the code is doing.\n<|/ c |>\n<| c |>\nThe code uses recursion to implement\
    \ the tribonacci sequence.\n<|/ c |>\n<| c |>\nhow is this different from what\
    \ i posted?\n<|/ c |>\n<| a dscore=5 |>\nI've used this code to calculate fibonacci\
    \ numbers. Although it uses recursion, here is an alternative that doesn't use\
    \ recursion, and it also uses memoization to speed up calculations. This code\
    \ takes more time than other methods. I used this in CodeChef problem. \n<code>",
  "  $arr = [];\n  for ($i = 0; $i <= $n; $i++) {\n    $arr[] = $i === 1 ? $i : $i\
    \ * $i + $i + 1;\n  }\n  return $arr;\n}\n", "\tif ($n == 0)\n\t\treturn array(0);\n\
    \t$a = tri($n - 1);\n\t$b = tri($n - 2);\n\t$c = tri($n + 1);\n\t$result = array_merge(array_slice($a,\
    \ 0, $n), array_slice($b, 0, $n), array_slice($c, 0, $n));\n\treturn $result;\n\
    }\n", "    $tri = array(1);\n    if ($n == 0) {\n        return $tri;\n    }\n\
    \    $tri[] = 3;\n    if ($n == 1) {\n        return $tri;\n    }\n    $tri[]\
    \ = 2;\n    for ($i = 2; $i < $n + 1; $i++) {\n        $tri[] = array_sum(array_slice($tri,\
    \ -1, 1)) + array_sum(array_slice($tri, -2, 1)) + $tri[$n - 1]; \n    }\n    return\
    \ $tri;\n}\n</code>\n<|/ a dscore=2 tags=php,recursion |>\n<| c |>\nThis is a\
    \ great answer, but could you please edit it to make clear that your solution\
    \ requires PHP >= 5.3? I've been trying to implement it with `array_merge` but\
    \ that fails since this answer is more than 5 years old. I'm still learning php\
    \ and can't figure out how to do this.\n<|/ c |>\n<| c |>\n- I've updated the\
    \ answer to show how you would go about doing this in PHP 5.2. Hope this helps!\n\
    <|/ c |>\n<| c |>\nThank you very much! The `array_merge` part was exactly what\
    \ I was looking for!\n<|/ c |>\n<| a dscore=1 |>\nTry this code:\n<code>", " \
    \   $result = array(1);\n    if ($n%2 == 0) {\n        $tri = $tri[0] + 1 ;\n\
    \    }else{\n        $tri = tri($n - 1) + tri($n - 2) + tri($n + 1);\n    }\n\
    \    array_push($result,$tri);\n    return $result;\n}\n\n$numbers = tri(5);\n\
    echo \"<pre>\";\nprint_r($numbers);\necho \"</pre>\";", "    $r = array();\n \
    \   for ($i = 0; $i < $n; $i++)\n        $r[] = $i + ($i + 1) + ($i + 2);\n  \
    \  return $r;\n}\n", "    if ($n <= 1) return array($n);\n    $a = tri($n - 1)\
    \ + tri($n - 2) + tri($n + 1);\n    return $a;\n}\n", "    $arr = array(3);\n\
    \    for($i = 1;$i < $n+1;$i++) {\n        if($i % 2 == 0) {\n            $arr[]\
    \ = $i;\n        } else {\n            $arr[] = ($i-1)+($i-2);\n        }\n  \
    \  }\n    return $arr;\n}\n$result = tri(4);\nprint_r($result);\n</code>\nThe\
    \ above solution is a linear solution. If you want a non-linear solution, try\
    \ this one:\n<code>\n<?php\n$arr = array();\n", "    if ($n==1) return array();\n\
    \    if ($n==2) return array(1, 2);\n    $tri=tri($n-1) + tri($n-2)+ tri($n+1);\n\
    \    return $tri;\n}\n", "    $array=array();\n    $array[0]=3;\n    for($i=1;$i<$n+1;$i++){\n\
    \        if($i%2==0){\n            $array[$i]=tri($i-1) + tri($i-2) + tri($i+1);\n\
    \        }else{\n            $array[$i]=tri($i-2) + tri($i-1) + tri($i+1);\n \
    \       }\n    }\n    return $array;\n}\n</code>\n<|/ a tags=php,arrays |>\n<|\
    \ c |>\nPlease consider explaining the code in your answer, just providing the\
    \ code alone isn't very helpful.\n<|/ c |>\n<| a tags=php,arrays |>\nRecursive\
    \ functions is the solution of such problems. But there is a simple recursive\
    \ solution to this problem as well.\n<code>\n<?php", "    $result = [];\n    if\
    \ ($n === 0) {\n        $result[0] = 3;\n        return $result;\n    }\n    $n++;\n\
    \    if ($n >= 2) {\n        $result[1] = 1;\n        return $result;\n    }\n\
    \    $result[2] = 1;\n    return $result;\n}\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ dscore=0 |>\nHere's a recursive version that also handles negative and floating\
    \ point numbers:\n<code>", "    $tri = array();\n    $tri[0] = 1;\n    $tri[1]\
    \ = 3;\n    for($i = 2; $i <= $n; $i++) {\n        $tri[$i] = $tri[$i-1] + $tri[$i-2];\n\
    \    }\n    return $tri;\n}\n", "    $arr = [];\n    $k = 0;\n    if ($n <= 1)\n\
    \    {\n        $arr[] = $n;\n        return $arr;\n    }\n    $tri1 = tri($n-1)\
    \ + tri($n-2);\n    $tri2 = tri($n-2) + tri($n-1);\n    foreach ($tri1 as $i =>\
    \ $val)\n    {\n        array_push($arr, $val, $tri2[$i], $k);\n    }\n    return\
    \ $arr;\n}", "\t$r = array();\n\t$r[] = 1;\n\tif ($n >= 2) {\n\t\t$r[] = 2;\n\t\
    \t$r[] = $r[$n-1] + $r[$n-2];\n\t\tif ($n % 2) {\n\t\t\t$r[] = $r[$n-1] + $r[$n-2];\n\
    \t\t}\n\t}\n\treturn $r;\n}\n", "    if ($n <= 1) {\n        return array($n);\n\
    \    }\n    $result[] = 1;\n    $result[] = $n;\n    while ($n < 3) {\n      \
    \  $result[] = $result[$n - 1] + $result[$n - 2] + $result[$n + 1];\n        $n++;\n\
    \    }\n    return $result;\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nWhile this\
    \ may be the best way to solve this problem, it would be better to explain what\
    \ the code is doing and how it works. This would allow the asker to use this solution\
    \ for future problems, perhaps understanding how it works.\n<|/ c |>\n<| c |>\n\
    It would be nice to see a description of the code and the logic.\n<|/ c |>\n<|\
    \ a tags=php,fibonacci,algorithm |>\n<code>", "    if ($n <= 3) return array($n);\n\
    \    $a = tri($n - 1);\n    $b = tri($n - 2);\n    $c = tri($n + 1);\n    return\
    \ array_merge($a, $b, $c);\n}\n", "    $nums = [];\n    $a = $b = $c = $d = 1;\n\
    \    \n    if($n<=1) {\n        $nums[] = $n;\n        return $nums;\n    }\n\
    \    \n    while($n--) {\n        $c++;\n        $b = $a;\n        $d = $c + $b;\n\
    \        $a = $d;\n        $nums[] = $c;\n    }\n    \n    return $nums;\n}\n\
    </code>\nThe above code is an implementation of the recurrence and it is also\
    \ efficient as it does not require an additional loop to calculate the next numbers.\
    \ \nTo calculate the first $n + 1 numbers of the Tribonacci sequence we need to\
    \ calculate the next numbers and then add them to the previous numbers. To calculate\
    \ the next numbers we can use the formula above. If we calculate the formula above\
    \ we get:\n<code>", "    if($n == 1) {\n        return array(3);\n    } else if($n\
    \ == 2) {\n        return array(3, 1);\n    } else if($n == 3) {\n        return\
    \ array(3, 1, 2);\n    }\n\n    $result = array(1);\n    $prevResult = array(1);\n\
    \n    for($i = 1; $i < $n; $i++) {\n        $newResult = $prevResult[count($prevResult)\
    \ - 1] + $prevResult[count($prevResult) - 2];\n        $newPrevResult = $prevResult[count($prevResult)\
    \ - 1];\n        $prevResult = $result;\n        $result = $newResult;\n    }\n\
    \n    return $result;\n}", "    if($n < 0) throw new InvalidArgumentException(\"\
    $n must be non-negative\");\n    $a = ($n % 2 == 0) ? array_fill(tri(ceil($n /\
    \ 2)),$a[1],$a[1]) : array_fill(tri(ceil($n / 2)),$a[0],$a[0]);\n    $a[] = $n\
    \ + 1; return $a;\n}", "    if ($n === 0 || $n === 1) {\n        return [$n];\n\
    \    }\n\n    $tri = [\n        1,\n        1 + $n / 2,\n        tri($n - 1) +\
    \ tri($n - 2),\n        tri($n + 1)\n    ];\n\n    $tri[] = $tri[0] + $tri[1]\
    \ + $tri[2];\n\n    return $tri;\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nYou\
    \ should not use $n to count from zero - this can lead to infinite loops. Use\
    \ $i = -1 instead.\n<|/ c |>\n<| c |>\n, why not to use $n to count from 0?\n\
    <|/ c |>\n<| c |>\n`$i` is used to index a different array - `$tri` in this case.\
    \ `$i` should start at -1. Though it does not matter in this case, `$i` will never\
    \ reach `$n` since the loop is `while($i < $n)`\n<|/ c |>\n<| c |>\n, please see\
    \ the following link for more details: https://3v4l.org/1J3lG\n<|/ c |>\n<| c\
    \ |>\nHe also needs to return an array with all the Fibonacci numbers.\n<|/ c\
    \ |>\n<| a |>\nA recursive solution using Fibonacci sequence and array_sum and\
    \ array_reduce\n<code>", "    $results = [];\n    $tris = [\n        3, \n   \
    \     1 + $n / 2, \n        ($n % 2) ? \n            tri($n - 1) + tri($n - 2)\
    \ + tri($n + 1): \n            tri($n - 1) + tri($n + 1) + tri($n - 2)\n    ];\n\
    \n    foreach($tris as $tri) {\n        array_push($results, $tri);\n    }\n\n\
    \    return $results;\n}\n</code>\n<|/ a tags=php,recursion,fibonacci |>\n<| a\
    \ tags=php,recursion,fibonacci |>\nIn case anyone is looking for a solution to\
    \ the same problem. Here's my take on it.\n<code>", "    if ($n <= 1) {\n    \
    \    return array($n);\n    }\n    $a = tri($n - 1) + tri($n - 2) + tri($n + 1);\n\
    \    array_push($a, $n - 1);\n    return $a;\n}\n", "    $tri = [];\n    if($n\
    \ == 0)\n        return [];\n    $tri[] = 0;\n    $tri[] = 1;\n    if($n & 1)\
    \ {\n        $tri[] = $tri[count($tri) - 2];\n        $tri[] = $tri[count($tri)\
    \ - 1] + $tri[count($tri) - 2];\n    }\n    return $tri;\n}\n</code>\n<|/ a tags=php,arrays,triangular,fibonacci\
    \ |>\n<| c |>\nThe first two lines of the second code block are the same.\n<|/\
    \ c |>\n<| c |>\nThanks, I edited the answer, I did copy and paste it wrong.\n\
    <|/ c |>\n<| c |>\nHmm, no, the first two lines of my answer are not the same.\
    \ Also, your answer does not use recursion.\n<|/ c |>\n<| c |>\nAh, I see. I am\
    \ still learning to answer questions, and I didn't realize that tribonacci could\
    \ also be solved recursively. Thanks for the tip!\n<|/ c |>\n<| c |>\nHi Jay,\
    \ thank you for your answer, I have tested it and it worked perfectly fine for\
    \ me, thank you very much.\n<|/ c |>\n<| a tags=php,arrays,triangular,fibonacci\
    \ |>\nThis works.\n<code>\n<?php\n\n    $n=$_REQUEST['n'];\n    $arr=[];\n   \
    \ $arr[0]=1;\n    $arr[1]=1;\n\n    for($i=2;$i<$n;$i++)\n    {\n        $temp=$arr[$i-1]+$arr[$i];\n\
    \        $arr[$i]=$temp;\n    }\n\n    echo json_encode($arr);", "    $arr = array_fill(0,$n+3,0);\n\
    \    if ($n<3) {\n        $arr[$n] = 1;\n        return $arr;\n    }\n    $arr[$n]\
    \ = 1 + $n/2;\n    if ($n&1) {\n        $arr[$n] = $arr[$n-1] + $arr[$n-2];\n\
    \    }\n    $arr[$n+1] = $arr[$n] + $arr[$n-1];\n    return $arr;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=php,recursion |>\n<code>\n<?php", "    if ($n ==\
    \ 3) {\n        return [1,3,2];\n    } else if ($n == 6) {\n        return [1,3,5,7,9];\n\
    \    } else {\n        $a = tri($n - 1);\n        $b = tri($n - 2);\n        return\
    \ array_merge($a,$b,[tri($n + 3)]);\n    }\n}\n</code>\n<|/ a tags=php,php-7,arrays\
    \ |>\n<| a dscore=2 tags=php,php-7,arrays |>\nFor those looking to use a generator,\
    \ the function below will return a generator that will yield the first n elements\
    \ of your array. This can be useful for processing large numbers of data without\
    \ having to hold the entire set of data in memory.\n<code>", "\tif ($n < 2) {\n\
    \t\treturn array(1);\n\t} else {\n\t\treturn array_merge(array(3), tri($n - 1)\
    \ + tri($n - 2) + tri($n + 1));\n\t}\n}\n", "    if ($n<2) return $n;\n    $tri[]=1;\n\
    \    $tri[]=1;\n    $tri[]=3;\n    return array_slice($tri,0,$n+1);\n}\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nHi, I like this one. Its pretty clean and easy to\
    \ understand. The only problem is that it takes quite a bit of time to compute.\
    \ The one below (by Harry) has a time complexity of O(n). Not sure why. Maybe\
    \ its the recursion within it?\n<|/ c |>\n<| c |>\nThis code is very nice, although\
    \ I wanted to use the same variable names, since in some languages (like Python)\
    \ this may lead to name conflicts.\n<|/ c |>\n<| a tags=php,recursion,fibonacci\
    \ |>\nThe Fibonacci sequence is the set of numbers, defined as the sum of two\
    \ unequal-length sequences, each containing the numbers 0, 1, and 1.\nThe first\
    \ two sequences are 1, 1, and 2, and the third sequence is 1, 1, and 3, the sum\
    \ of the first two and third sequences, respectively.\nThe Fibonacci number for\
    \ the second two numbers is 1, and the Fibonacci number for the third number is\
    \ 3.\n<code>", "    $tri = array($n);\n    if ($n % 2 == 0){\n        $tri[] =\
    \ $n + 1;\n        $tri[] = $tri[$n-1] + $tri[$n-2];\n    } else {\n        $tri[]\
    \ = $tri[$n-1] + $tri[$n-2];\n    }\n    return $tri;\n}\n", "    if ($n <= 0)\
    \ { return []; }\n    return array(\n        3,\n        $n % 2 ? tri($n - 1)\
    \ + tri($n - 2) + ($n + 1) / 2 : tri($n - 1) + tri($n - 2) + ($n + 1) / 2,\n \
    \       $n % 2 ? tri($n - 1) + tri($n - 2) + ($n + 1) / 2 : tri($n - 1) + tri($n\
    \ - 2) + ($n + 1) / 2,\n    );\n}\n", "    return $n > 3 ? tri($n - 1) + tri($n\
    \ - 2) + tri($n) : array(1);\n}\n\n$n = isset($_POST['n']) ? $_POST['n'] : 1;\n\
    $output = tri($n);\nvar_dump($output);", "    $arr = [3,1];\n    $sum = 0;\n \
    \   for($i = 1; $i<$n; $i++) {\n        $sum += $arr[$i-1] + $arr[$i-2] + $arr[$i+1];\n\
    \        $arr[] = $sum;\n    }\n    return $arr;\n}\n", "    $a = [3,1];\n   \
    \ foreach(range($n,0,-1) as $k) {\n        $b = [1,$n+1+$k];\n        $res = $a[0]\
    \ + $a[1] + $b[0] + $b[1];\n        if($res>100) {\n            $a[0] = $res;\n\
    \            $a[1] = $b[1];\n        } else {\n            $a[1] = $res;\n   \
    \         $a[0] = $b[0];\n        }\n    }\n    return $a;\n}\n</code>\n<|/ a\
    \ tags=php,math |>\n<| c |>\nThis code fails with (for example) `tri(100)` outputting\
    \ `array(8, 7, 11, 13, 10, 7, 8, 13, 13, 10, 11, 7, 10, 11, 7, 11, 8, 10, 6, 8,\
    \ 12, 14, 7, 12, 7, 7, 12, 7, 8, 7, 7, 13, 14, 9, 7, 14, 14, 14, 7, 14, 14, 14,\
    \ 8, 8, 8, 10, 10, 9, 9, 10, 10, 10, 10, 10, 7, 7, 7, 9, 8, 7, 8, 10, 10, 8, 8,\
    \ 8, 7, 10, 7, 8, 10, 8, 8, 8, 9, 9, 9, 7, 7, 7, 7, 8, 8, 10, 10, 8, 8, 8, 7,\
    \ 10, 7, 8, 10, 8, 8, 8, 8, 10, 9, 10, 10, 10, 8, 7, 9, 9, 9, 7, 7, 7, 8, 8, 10,\
    \ 10, 8, 8, 8, 7, 10, 7, 8, 10, 8, 8, 8, 8, 10, 9, 9, 9, 7, 7, 7, 8, 8, 10, 10,\
    \ 8, 8, 8, 7, 10, 7, 8, 10, 8, 8, 8, 8, 10, 9, 10, 10, 10, 8, 7, 9, 9, 9, 7, 7,\
    \ 7, 8, 8, 10, 10, 8, 8, 8, 7, 10, 7, 8, 10, 8, 8, 8, 8, 10, 9, 9, 9, 7, 7, 7,\
    \ 8, 8, 10, 10, 8, 8, 8, 7, 10, 7, 8, 10, 8, 8, 8, 8, 10, 9, 10, 10, 10, 8, 7,\
    \ 9, 9, 9, 7, 7, 7, 8, 8, 10, 10, 8, 8, 8, 7, 10, 7, 8, 10, 8, 8, 8, 8, 10, 9,\
    \ 10, 10, 10, 8, 7, 9, 9, 9, 7, 7, 7, 8, 8, 10, 10, 8, 8, 8, 7, 10, 7, 8, 10,\
    \ 8, 8, 8, 8, 10, 9, 10, 10, 10, 8, 7, 9, 9, 9, 7, 7, 7, 8, 8, 10, 10, 8, 8, 8,\
    \ 7, 10, 7, 8, 10, 8, 8, 8, 8, 10, 9, 10, 10, 10, 8, 7, 9, 9, 9, 7, 7, 7, 8, 8,\
    \ 10, 10, 8, 8, 8, 7, 10, 7, 8, 10, 8, 8, 8, 8, 10, 9, 10, 10, 10, 8, 7, 9, 9,\
    \ 9, 7, 7, 7, 8, 8, 10, 10, 8, 8, 8, 7, 10, 7, 8, 10, 8, 8, 8, 8, 10, 9, 10, 10,\
    \ 10, 8, 7, 9, 9, 9, 7, 7, 7, 8, 8, 10, 10, 8, 8, 8, 7, 10, 7, 8, 10, 8, 8, 8,\
    \ 8, 10, 9, 10, 10, 10, 8, 7, 9, 9, 9, 7, 7, 7, 8, 8, ", "    $a = $b = 1;\n \
    \   for($i = 2 ; $i <= $n ; $i++) {\n        $c = $a + $b;\n        $a = $b;\n\
    \        $b = $c;\n    }\n    return array($a, $b, $c, $a + $b);\n}\n", "    $a\
    \ = $b = $c = $d = 1;\n    $result = array();\n    if ($n <= 1) {\n        return\
    \ $n;\n    }\n    for ($i = 1; $i <= $n; $i++) {\n        $c = $d + $b;\n    \
    \    $b = $a;\n        $a = $c;\n        $d = $c;\n        $result[] = $a;\n \
    \   }\n    return $result;\n}\n", "    $result = [];\n    if ($n <= 2) {\n   \
    \     $result[] = $n;\n    } else {\n        $result[] = 1 + tri($n - 1) + tri($n\
    \ - 2) + tri($n + 1);\n    }\n    return $result;\n}\nvar_dump(tri(8));", "  \
    \  $result = [];\n    // Write your code here\n    $start = 1;\n    $end = 3;\n\
    \    for($i = $start; $i <= $end; $i++){\n        $result[$i] = ($i + ($i/$2)\
    \ + ($i/$3));\n    }\n    return $result;\n}\n$tri = tri(5);\nforeach($tri as\
    \ $key=>$value){\n    echo $value.'</br>';\n}", "    $a=[1,3,1];\n    for ($i=1;$i<$n;$i++)\
    \ {\n        $a[$i+1]=$a[$i]+$a[$i+2];\n    }\n    return $a;\n}\n", "    if ($n\
    \ < 2) {\n        return [];\n    }\n    if ($n % 2 == 0) {\n        $a = [1,2];\n\
    \    }\n    else {\n        $a = [0,1];\n    }\n\n    return array_merge($a, array_slice($a,0,$n-1))\
    \ + array_slice($a,0,$n).reverse();\n}\n</code>\n<|/ a tags=fibonacci,php dscore=2\
    \ |>\n<| a dscore=2 tags=fibonacci,php |>\nHere is my solution which can be optimized\
    \ to use only one $n variable instead of two.\n<code>\n$arr = [0,1];\n$n = $n;\n\
    \nwhile($n > 0) {\n    $m = $arr[count($arr)-1] + $arr[count($arr)-2];\n    $arr[]\
    \ = $m;\n    $n--;\n}\n</code>\n<|/ a |>\n<| a dscore=2 |>\nHere is a PHP 7 implementation\
    \ based on a recursive function as suggested by\n<code>", "    $results = [3,\
    \ 1];\n    if($n <= 2) return $results;\n    $results[] = $results[-2] + $results[-1]\
    \ + $results[-(n-1)];\n    if($n%2 === 1) $results[] = tri($n-1);\n    return\
    \ $results;\n}", "    if ($n < 1) {\n        throw new \\RuntimeException('Invalid\
    \ number!');\n    }\n    $arr = [3];\n    if ($n >= 2) {\n        $arr[] = 1 +\
    \ $n / 2;\n    }\n    if ($n % 2 === 0) {\n        $arr[] = tri($n - 1) + tri($n\
    \ - 2) + tri($n + 1);\n    } else {\n        $arr[] = tri($n - 1) + tri($n + 1);\n\
    \    }\n    return $arr;\n}\n", "    if ($n<=1) {\n        return array(1);\n\
    \    }\n    if ($n%2==0) {\n        return array(tri(floor($n/2)));\n    }\n \
    \   return array(tri(floor($n/2)) + tri(floor($n%2)) + $n);\n}", "    if ($n <\
    \ 3) {\n        return [];\n    }\n    return array_merge(tri($n - 1), [tri($n\
    \ - 2), tri($n - 1)]);\n}\n</code>\n<|/ a tags=php,arrays dscore=1 |>\n<| a tags=php,arrays\
    \ dscore=1 |>\nThis is my solution, maybe it helps.\n<code>\n<?php", "    if ($n\
    \ <= 3) {\n        return array($n);\n    }\n    if ($n == 3) {\n        return\
    \ array(3, 1, 1, 2);\n    }\n    return tri(n - 1) + tri(n - 2) + tri(n + 1);\n\
    }\n", "    $sequence = [1, 3];\n    $sum = 0;\n    for($i = 1; $i < $n; $i++)\
    \ {\n        $sum += $sequence[$i];\n        if($i % 2 == 1) {\n            $sequence[]\
    \ = $sum;\n            $sum = 0;\n        }\n    }\n    return $sequence;\n}",
  "    $r = array(1);\n    for($i=1; $i<$n+1; $i++) {\n        $r[] = $r[$i-1] + $r[$i-2]\
    \ + $r[$i];\n    }\n    return $r;\n}\n</code>\n<|/ a tags=php,python,algorithm,ruby\
    \ |>\n<| c |>\nThank you for posting the solution, it helped me a lot.\n<|/ c\
    \ |>\n<| a tags=php,python,algorithm,ruby dscore=0 |>\nThis was my Ruby answer:\n\
    <code>\nclass Integer\n    def tri_number\n        tri = [1,3,5]\n        tri.inject(0)\
    \ do |sum,el|\n            el == 0 ? sum : el + sum\n        end\n    end\n\n\
    \    def tri_array\n        tri_number.step(2).to_a\n    end\nend\n\np \"fib(3)\
    \ = #{Integer.new.fib(3)}, tri(3) = #{Integer.new.tri_number}, tri(7) = #{Integer.new.tri_array}\"\
    \ ", "    $result = [3];\n    \n    if ($n % 2 == 0) {\n        $result[] = $result[$n\
    \ - 1] +  $result[$n - 2];\n        $result[] = $result[$n - 2];\n    }\n    \n\
    \    if ($n % 2 == 1) {\n        $result[] = $result[$n - 1] +  $result[$n - 2]\
    \ + $result[$n + 1];\n        $result[] = $result[$n + 1];\n    }\n    \n    return\
    \ $result;\n}\n", "    if ($n <= 1) return $n;\n    $a = $a = $n = $n = $n + 1\
    \ ;\n    $b = $c = $a + $b ;\n    $d = $c + $d ;\n    $r = array( $a, $b, $c,\
    \ $d ) ;\n    foreach ( array_reverse( $r ) as $k => $v ) $r[ $k + 1 ] = $r[ $k\
    \ + 2 ] + $r[ $k + 3 ] ;\n    return $r;\n}\n", "    if ($n == 1) {\n        return\
    \ array(1);\n    } elseif ($n == 2) {\n        return array(3, 1);\n    } else\
    \ {\n        $a = tri(min(2, $n - 1));\n        $b = tri(min(2, $n - 2));\n  \
    \      $c = $a[0] + $b[0];\n\n        return array($a[0] + $b[0], $a[1] + $c[1],\
    \ $a[2] + $b[1] + $c[2], $c[3]);\n    }\n}", "    $result = [];\n    $prev = new\
    \ \\stdClass();\n    $prev->num = 1;\n    $prev->next = new \\stdClass();\n  \
    \  $prev->next->num = 1;\n    $prev->next->next = new \\stdClass();\n    $prev->next->next->num\
    \ = 1;\n    $prev->next->next->next = new \\stdClass();\n    $prev->next->next->next->num\
    \ = 1;\n    for($i = 1; $i <= $n; $i++) {\n        $result[] = $prev->num;\n \
    \       $cur = $prev->num;\n        for($j = 1; $j <= $i; $j++) {\n          \
    \  $cur = $prev->next->num + $cur;\n            $prev->next->next->next->next->num\
    \ = $cur;\n        }\n        $prev = $prev->next;\n    }\n    return $result;\n\
    }\n</code>\n<|/ a dscore=4 tags=php,fibonacci,arrays |>\n<| c |>\nI like this\
    \ approach. Thanks. However, I wonder if there's a way to do this without using\
    \ the stdClass. For example, perhaps building the array by hand?\n<|/ c |>\n<|\
    \ c |>\nWell, I don't think so as you have to traverse each element of the array.\
    \ Also, if you want it to be \"faster\", I would say that creating a tri-array\
    \ is more efficient.\n<|/ c |>\n<| c |>\nThanks, I got it working with `$result[]\
    \ = array_merge($prev->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next",
  "    if ($n <= 1)\n        return array(1);\n    return array(\n        tri($n -\
    \ 1) + tri($n - 2) + tri($n + 1)\n    );\n}", "    if ($n === 0) {\n        return\
    \ array(3);\n    }\n    if ($n === 1) {\n        return array(1);\n    }\n   \
    \ $a = tri($n - 1);\n    $b = tri($n - 2);\n    $c = tri($n + 1);\n    return\
    \ array_merge(\n        $a, \n        array($c),\n        $b\n    );\n}\n</code>\n\
    <|/ a dscore=3 tags=php,algorithm,pseudocode |>\n<| c |>\nFor some reason I had\
    \ to wrap the two array_merge lines in array_merge, otherwise it would give me\
    \ an error on some tests.  This worked fine:\nreturn array_merge(\n    $a,\n \
    \   array($c),\n    $b\n);\n<|/ c |>\n<| c |>\nAh, yes. You're right. I have modified\
    \ my answer, thanks.\n<|/ c |>\n<| c |>\nThanks for your solution, I also needed\
    \ it for another problem so I adapted it to my needs. It also works for n >= 1.\n\
    <|/ c |>\n<| a dscore=3 |>\nA recursive solution to the problem:\n<code>", "\t\
    $tri = new Tribonacci($n);\n\treturn $tri->getArray();\n}", "    $a = [];\n  \
    \  $a[0] = 1;\n    $a[1] = 3;\n    if ($n % 2 == 0) $a[2] = 2;\n    else {\n \
    \       $a[2] = 1;\n        $a[3] = 1 + $n / 2;\n    }\n    $a[4] = $a[3] + $a[2];\n\
    \    $a[5] = $a[3] + $a[1] + $a[4];\n    $a[6] = $a[5] + $a[1] + $a[2];\n    \n\
    \    return $a;\n}\n \n$numbers = tri(3);\nprint_r($numbers);\n</code>\n<|/ a\
    \ |>\n<| c |>\nthank you for this explanation. Can you please explain the output\
    \ in more detail? what is the meaning of the values at the end? Thanks\n<|/ c\
    \ |>\n<| c |>\nHi thank you for reply. I am not asking for a solution to find\
    \ tribonacci number, but I am asking for the explanation on how it work. Thanks\n\
    <|/ c |>\n<| c |>\nHi thanks for your explanation. But this is not a programming\
    \ solution. I am looking for an explanation that how it works. Thanks!\n<|/ c\
    \ |>\n<| a |>\nI found this question interesting and searched for a bit to better\
    \ understand the answer. I found it easier to understand if we write down the\
    \ tribonacci sequence in mathematical form:\n\nThis is an infinite sequence that\
    \ has three terms: 0, 1, 1, 2, 3, 5, 8, 13, ...\n\nWe can represent this sequence\
    \ by $0, $1, $2 etc. and an expression $n = ($n * 3 + 1) // 2. Since $n is integer,\
    \ we can drop the $n / 2\nSo I converted this sequence to code (using PHP) and\
    \ wrote a test function to test the code against the mathematical formula.\n<code>",
  "    if ($n === 1) return array(1);\n    $a = tri($n - 1) + tri($n - 2);\n    if\
    \ ($n % 2) $a[] = $n;\n    return $a;\n}\n", "    $a = array(3, 1);\n    for ($i\
    \ = 1; $i <= $n; $i++) {\n        $a[] = array_sum(array_slice($a, 0, $i - 1));\n\
    \    }\n    return $a;\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\n`array_sum(array_slice($a,\
    \ 0, $i - 1))` should be `array_sum(array_slice($a, $i))`\n<|/ c |>\n<| c |>\n\
    `array_sum(array_slice($a, $i, 1))` - should be `array_sum(array_slice($a, $i))`\n\
    <|/ c |>\n<| c |>\n: No, `array_sum(array_slice($a, $i, 1))` is just `array_sum(array_slice($a,\
    \ $i))`. The third parameter of the `array_slice` function is the number of elements\
    \ to exclude, which is `1` here.\n<|/ c |>\n<| c |>\nIt will also work for non-negative\
    \ numbers, if you add `if ($n<0) return [];` before the for loop.\n<|/ c |>\n\
    <| c |>\nThank you for the answer. Now I am getting some errors on my other test\
    \ cases.\n<|/ c |>\n<| a tags=php,dynamic-programming,fibonacci |>\nHere is the\
    \ PHP version of this problem (I tested it):\n<code>", "    return isEven($n)\
    \ ? \n        [3, 1 + $n / 2, tri(3 - 1) + tri(3 - 2) + tri(3 + 1), tri($n + 1)]\
    \ : \n        [$n, tri($n - 1) + tri($n - 2) + tri($n + 1), $n + 1];\n}\n", " \
    \   if ($n < 2) {\n        return array(1);\n    }\n    return array(tri(--$n),\
    \ tri(--$n), tri(++$n));\n}"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
