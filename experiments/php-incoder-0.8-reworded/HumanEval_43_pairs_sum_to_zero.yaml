name: HumanEval_43_pairs_sum_to_zero
language: php
prompt: "<?php\n// pairs_sum_to_zero takes an array of integers as an input.\n// it\
  \ returns true if there are two distinct elements in the array that\n// sum to zero,\
  \ and false otherwise.\n// >>> pairs_sum_to_zero(array(1, 3, 5, 0))\n// false\n\
  // >>> pairs_sum_to_zero(array(1, 3, -2, 1))\n// false\n// >>> pairs_sum_to_zero(array(1,\
  \ 2, 3, 7))\n// false\n// >>> pairs_sum_to_zero(array(2, 4, -5, 3, 5, 7))\n// true\n\
  // >>> pairs_sum_to_zero(array(1))\n// false\nfunction pairs_sum_to_zero($l) {\n"
tests: "function candidate(...$args) {\n    return pairs_sum_to_zero(...$args);\n\
  }\n\nfunction test(): void {\n    if (candidate(array(1, 3, 5, 0)) !== false) {\
  \ throw new Exception(\"Test failed!\"); }\n    if (candidate(array(1, 3, -2, 1))\
  \ !== false) { throw new Exception(\"Test failed!\"); }\n    if (candidate(array(1,\
  \ 2, 3, 7)) !== false) { throw new Exception(\"Test failed!\"); }\n    if (candidate(array(2,\
  \ 4, -5, 3, 5, 7)) !== true) { throw new Exception(\"Test failed!\"); }\n    if\
  \ (candidate(array(1)) !== false) { throw new Exception(\"Test failed!\"); }\n \
  \   if (candidate(array(-3, 9, -1, 3, 2, 30)) !== true) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(array(-3, 9, -1, 3, 2, 31)) !== true) { throw\
  \ new Exception(\"Test failed!\"); }\n    if (candidate(array(-3, 9, -1, 4, 2, 30))\
  \ !== false) { throw new Exception(\"Test failed!\"); }\n    if (candidate(array(-3,\
  \ 9, -1, 4, 2, 31)) !== false) { throw new Exception(\"Test failed!\"); }\n}\n\n\
  test();"
completions: ["  sort($l);\n  $prev = -INF;\n  foreach($l as $n) {\n    if ($prev\
    \ + $n < 0) {\n      $prev += $n;\n    } else {\n      return TRUE;\n    }\n \
    \ }\n  return FALSE;\n}\n", "    $n = count($l);\n    for ($i = 0; $i < $n-1;\
    \ $i++) {\n        for ($j = $i+1; $j < $n; $j++) {\n            if ($l[$i] +\
    \ $l[$j] == 0) {\n                return false;\n            }\n        }\n  \
    \  }\n    return true;\n}", "   $res = true;\n   $s = array_sum($l);\n   foreach\
    \ ($l as $k => $v) {\n      $res && $v == 0 || $res = (abs($v - $s) == 0);\n \
    \     $res = $res && abs($s - $v) == 0;\n   }\n   return $res;\n}\n", "    $a\
    \ = array_unique($l);\n    sort($a);\n    $sum = 0;\n    for ($i=0; $i<count($a);\
    \ $i++) {\n        $sum += $a[$i];\n        if ($sum == 0) {\n            return\
    \ true;\n        }\n    }\n    return false;\n}\n", "  $s = array_count_values($l);\n\
    \  return ($s[1] > 1 && $s[0] > 1) ? false : true;\n}\n", "  for ($n = count($l)\
    \ - 1; $n >= 0; $n--) {\n    list($x, $y) = $l[$n];\n    if ($x != $y) $l[$n]\
    \ = ($x + $y) == 0;\n  }\n  return true;\n}\n", "    if (count($l) <= 1) return\
    \ true;\n    $sum = array_sum($l);\n    foreach ($l as $i => $e) {\n        if\
    \ ($sum > 0) return false;\n        $sum -= $l[$i];\n    }\n    return true;\n\
    }\n", "  if ($l == array()) return true;\n  $r = array();\n  foreach ($l as $e)\
    \ {\n    $t = $e;\n    foreach ($r as $e) {\n      if ($e + $t <= 0) {\n     \
    \   $t = 0;\n        break;\n      }\n    }\n    $r[] = $t;\n  }\n  return count($r)\
    \ == 2;\n}\n", "    $s = 0;\n    $t = 0;\n    foreach ($l as $k => $v) {\n   \
    \     if ($v < 0) $v *= -1;\n        $s += $v;\n        $t += $v;\n    }\n   \
    \ return ($s == 0 && $t == 0) || ($s == $t);\n}\n", "\tforeach ($l as $k => $v)\
    \ {\n\t\t$pair[$k] = $k;\n\t\t$sum[$k] = 0;\n\t\tforeach ($l as $kk => $vv) {\n\
    \t\t\tif ($v + $vv == $kk)\n\t\t\t\t$sum[$k] += $kk;\n\t\t}\n\t\tif ($sum[$k]\
    \ > 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "    sort($l);\n\
    \    $s = array_sum($l);\n    $l = array_flip($l);\n    foreach ($l as $t => $v)\
    \ {\n        if ($s >= $t) {\n            if ($s != $t) {\n                return\
    \ false;\n            }\n        }\n    }\n    return true;\n}\n", "  $pairs =\
    \ array_count_values($l);\n  foreach ($pairs as $pair) {\n    if ($pair > 1) {\n\
    \      return false;\n    }\n  }\n  return true;\n}\n", "  $s = array_sum($l);\n\
    \  $c = array_count_values($l);\n  return count(array_keys($c, $s)) == 2;\n}\n",
  "    $pairs = array();\n    $len = count($l);\n    for ($i = 0; $i < $len; $i++)\
    \ {\n        for ($j = $i + 1; $j < $len; $j++) {\n            if ($l[$i] + $l[$j]\
    \ == 0) {\n                $pairs[] = array($l[$i], $l[$j]);\n            }\n\
    \        }\n    }\n    return $pairs;\n}\n", "    // make pairs array and sort\
    \ it\n    $pairs = array_map(function ($x, $y) { return [$x, $y]; }, $l, $l);\n\
    \    sort($pairs);\n\n    // two elements with same value or negative difference\n\
    \    // make two indexes and set them to null to ignore pairs with same value\n\
    \    $a = reset($pairs);\n    $b = current($pairs);\n\n    // if two elements\
    \ have same value or positive difference set them to zero\n    return ($a[0] ==\
    \ $b[0]) || abs($a[0] - $b[0]) < 2;\n}\n", "    $len = count($l);\n    for ($i\
    \ = 0; $i < $len; $i++) {\n        $sum = 0;\n        for ($j = $i + 1; $j < $len;\
    \ $j++) {\n            $sum = $sum + $l[$i] * $l[$j];\n        }\n        if ($sum\
    \ == 0)\n            return false;\n    }\n    return true;\n}\n", "  $sum = 0;\n\
    \  foreach ($l as $v) {\n    $sum += $v;\n  }\n  if ($sum == 0 || $sum == -$sum)\
    \ {\n    return false;\n  }\n  sort($l);\n  $sum = 0;\n  $first = $l[0];\n  foreach\
    \ ($l as $v) {\n    if ($v == $first) {\n      ++$sum;\n    } else {\n      if\
    \ ($sum == 0) {\n        return false;\n      }\n      $sum = 0;\n    }\n  }\n\
    \  return true;\n}", "    $n = count($l);\n    $sum = 0;\n    $pairs = array();\n\
    \    for ($i = 0; $i < $n; $i++) {\n        for ($j = $i + 1; $j < $n; $j++) {\n\
    \            if ($l[$i] + $l[$j] == 0) {\n                array_push($pairs, [$i,\
    \ $j]);\n                array_push($pairs, [$j, $i]);\n            }\n      \
    \      $sum += $l[$i] + $l[$j];\n        }\n    }\n    if (count($pairs) == 2)\
    \ {\n        for ($i = 0; $i < count($pairs[0]); $i++) {\n            for ($j\
    \ = $i + 1; $j < count($pairs[0]); $j++) {\n                if ($pairs[0][$i]\
    \ != $pairs[0][$j]) {\n                    return false;\n                }\n\
    \            }\n        }\n        return true;\n    } else {\n        return\
    \ false;\n    }\n}", "    $n = count($l);\n    for ($i=0; $i<$n-1; $i++) {\n \
    \       for ($j=$i+1; $j<$n; $j++) {\n            if ($l[$i] + $l[$j] == 0) {\n\
    \                return true;\n            }\n        }\n    }\n    return false;\n\
    }\n", "  foreach ($l as $key => $val) {\n    // if element exists, add it to the\
    \ sum\n    if (array_key_exists($key, $l)) {\n      $s = $l[$key] + $val;\n  \
    \    if ($s == 0) {\n        // if the sum of the array is zero, return true\n\
    \        return true;\n      }\n    }\n  }\n  // otherwise, return false\n  return\
    \ false;\n}\n", "  $num_elements = count($l);\n  foreach($l as $index => $element)\
    \ {\n    $sum = 0;\n    for($i = 0; $i < $num_elements; $i++) {\n      if ($i\
    \ != $index) {\n        $sum += $l[$i];\n      }\n    }\n    if ($sum == 0) {\n\
    \      return true;\n    }\n  }\n  return false;\n}\n", "  return count($l) >\
    \ 1 &&\n    array_diff_key($l, $l[0])\n      === array_fill_keys(array_keys($l),\
    \ 0);\n}\n</code>\n<|/ a |>\n<| c |>\nI feel like this is close to what I need,\
    \ but I need something that will run on every array of any size, not just pairs.\n\
    <|/ c |>\n<| c |>\nYes, I see now. I modified my answer to do what you want now.\n\
    <|/ c |>\n<| a dscore=0 |>\nJust use the php function array_diff_key() with array_fill_keys().\
    \ \n<code>\n<?php\n$pairs = array(1, 3, -2, 1);\n$diff1 = array_fill_keys(array_keys($pairs),\
    \ 0);\nprint_r($diff1);", "    if (empty($l)) {\n        return false;\n    }\n\
    \    $n = count($l);\n    for ($i = 0; $i < $n; $i++) {\n        for ($j = $i\
    \ + 1; $j < $n; $j++) {\n            $a = $l[$i];\n            $b = $l[$j];\n\
    \            if ($b < 0 || $a < 0) {\n                return false;\n        \
    \    }\n            $x = $a + $b;\n            if ($x == 0) {\n              \
    \  return false;\n            }\n            if ($x != $a) {\n               \
    \ return false;\n            }\n        }\n    }\n    return true;\n}", "    foreach($l\
    \ as $e => $x) {\n        $r = array_shift($l);\n        if ( $e + $r == 0 ) return\
    \ false;\n    }\n    return true;\n}\n", "    $sum = 0;\n    $result = array();\n\
    \    foreach ($l as $e) {\n        $sum += $e;\n        if ($sum == 0)\n     \
    \       $result[] = array($e);\n        elseif ($sum < 0) {\n            $sum\
    \ = $sum * -1;\n            $result[] = array($e);\n        }\n    }\n    return\
    \ $result == array();\n}", "  if (!$l)\n    return false;\n  for ($i = 0, $l =\
    \ count($l); $i < $l; $i++)\n    if ($l[$i] === 0)\n      return false;\n  return\
    \ true;\n}\n", "  $n = 0;\n  foreach ($l as $i => $e) {\n    if ($e < 0) {\n \
    \     return FALSE;\n    }\n    if ($e == 0) {\n      return TRUE;\n    }\n  \
    \  if ($e) {\n      $n++;\n    }\n  }\n  return $n == 2;\n}\n", "    // first\
    \ sort the array so we can do a binary search\n    sort($l);\n    $size = count($l);\n\
    \    $sum = 0;\n    $k = 0;\n    $found = false;\n    for($i = 0; $i < $size;\
    \ $i++) {\n        $sum += $l[$i];\n        if($sum == 0) {\n            $found\
    \ = true;\n            break;\n        }\n    }\n    if(!$found) return false;\n\
    \    for($j = 0; $j < $size; $j++) {\n        if($k == $j) continue;\n       \
    \ $val = $l[$j];\n        $l[$j] = $l[$k];\n        $l[$k] = $val;\n        $k++;\n\
    \    }\n    return $k;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nOh my god...\n\
    <|/ c |>\n<| c |>\nThis takes O(n\xB2) time, instead of O(n). See my answer for\
    \ a O(n) solution.\n<|/ c |>\n<| c |>\nThis takes O(n) time, instead of O(n\xB2\
    ) when there are duplicates in the array. See my answer for a O(n) solution.\n\
    <|/ c |>\n<| a dscore=2 tags=arrays,php,algorithm |>\nThis would be a O(n) solution\
    \ by modifying the original solution provided by Sam (thanks Sam):\n<code>", " \
    \   $sum = array_sum($l);\n    return $sum == 0;\n}\n", "  $sum = 0;\n  foreach\
    \ ($l as $e) {\n    if ($e < 0) {\n      return false; // this array has two negative\
    \ elements\n    }\n    $sum += $e;\n  }\n  return ($sum % 2 == 0);\n}\n", "  \
    \  $result = (count($l) % 2 == 0 && count($l) > 1);\n    if ($result) {\n    \
    \    sort($l);\n        $last = $l[count($l) - 1];\n        $pairs = array_chunk($l,\
    \ 2);\n        foreach ($pairs as $pair) {\n            $last = $pair[0] + $last;\n\
    \            $result = $result && ($pair[0] == $last);\n        }\n    }\n   \
    \ return $result;\n}\n", "    $sum = 0;\n    foreach ($l as $e) {\n        $sum\
    \ += $e;\n    }\n    return $sum == 0;\n}\n", "  $total = 0;\n  $result = '';\n\
    \  foreach ($l as $item) {\n    if ($total > 0) {\n      if ($item == 0) {\n \
    \       $result .= '0';\n        $total = 0;\n      } else if ($item == $total)\
    \ {\n        $result .= '0';\n        $total = 0;\n      } else {\n        $result\
    \ .= $item;\n        $total += $item;\n      }\n    }\n  }\n  // This may include\
    \ additional 0s.\n  return !$result;\n}", "    sort($l);\n    $t = 0;\n    for\
    \ ($i = 0; $i < count($l); $i++) {\n        $t += $l[$i];\n        for ($j = $i\
    \ + 1; $j < count($l); $j++) {\n            if ($t += $l[$j] === 0) {\n      \
    \          return false;\n            }\n        }\n    }\n    return true;\n\
    }\n</code>\nIt uses a sorting algorithm, which should be fast, but is O(n\xB2\
    ).\n<|/ a |>\n<| c |>\nI like it, though it could be improved to use an ordered\
    \ set for the pairs to keep O(n) complexity\n<|/ c |>\n<| c |>\nI think your `pairs_sum_to_zero`\
    \ function doesn't work. It returns `true` for an input like `array(1, 3, -2,\
    \ 1)`\n<|/ c |>\n<| c |>\n, You're right, it's wrong.  I thought it worked with\
    \ sorted arrays.  I've fixed it, but I think it works now.\n<|/ c |>\n<| c |>\n\
    Nice solution, but please let me just clarify that `pairs_sum_to_zero` doesn't\
    \ work with an array like `[2,3]`. As far as I can tell, `pairs_sum_to_zero` requires\
    \ that every array element be at least as large as all other array elements, not\
    \ just one element larger than the other. I'm thinking that the solution is to\
    \ do a quick test before doing the `sort` function.\n<|/ c |>\n<| a |>\nI think\
    \ this should work, although I haven't tested it:\n<code>", "    // loop through\
    \ all pairs and see if they sum to zero.\n    // return the result of the test\n\
    \    foreach ($l as $key => $value) {\n        for ($i = $key+1; $i < count($l);\
    \ $i++) {\n            // add +1 to the keys and values to avoid double-counting\n\
    \            if ($l[$key] + $l[$i] === 0) {\n                return false;\n \
    \           }\n        }\n    }\n    return true;\n}\n", "  $sum = 0;\n  foreach\
    \ ($l as $i => $x) {\n    if ($x != 0) {\n      $sum += $x;\n      if ($sum <\
    \ 0) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n", "  //\
    \ Write your code here\n  $sum = 0; $counter = 0;\n  foreach($l as $key => $value){\n\
    \    if($value == 0) $counter++;\n    $sum += $value;\n    if($sum == 0) return\
    \ true;\n  }\n  return false;\n}\n", "  $sum = 0;\n  $l = array_map('intval',\
    \ $l);\n  $n = count($l);\n  for ($i = 0; $i < $n; $i++) {\n    for ($j = $i+1;\
    \ $j < $n; $j++) {\n      $sum += $l[$i] + $l[$j];\n    }\n    if ($sum == 0)\n\
    \      return true;\n  }\n  return false;\n}\n", "    $a = $l[0];\n    $b = $l[1];\n\
    \    return ($a + $b == 0);\n}\n", "  // If there is only one element in the list,\
    \ then\n  // it cannot be sum to zero!\n  if (count($l) == 1) {\n    return false;\n\
    \  }\n\n  // If the list has only one unique value, then\n  // the list cannot\
    \ be sum to zero.\n  if (array_count_values($l)[1] == 1) {\n    return false;\n\
    \  }\n\n  // Now we must find two distinct elements in the list\n  // that sum\
    \ to zero.\n  $a = $l[0];\n  $b = $l[0];\n\n  foreach ($l as $i => $val) {\n \
    \   if ($val > 0) {\n      $b += $val;\n      if ($b == 0) {\n        $a = $b;\n\
    \        $b = $val;\n      } else if ($b < 0) {\n        $a = $b;\n        $b\
    \ = $val;\n      }\n    }\n  }\n\n  // If only two distinct elements in the list\
    \ sum to zero,\n  // then the list cannot be sum to zero.\n  if ($a == 0 && $b\
    \ == 0) {\n    return false;\n  }\n\n  return true;\n}\n", "\tfor ($i = 1, $j\
    \ = count($l); $j < count($l); $i++) {\n\t\tif ($l[$i] + $l[$j] != 0) {\n\t\t\t\
    return false;\n\t\t}\n\t}\n\treturn true;\n}\n", "    if (count($l) < 3) return\
    \ false;\n    $result = array_shift($l);\n    foreach ($l as $e) {\n        $result\
    \ -= $e;\n        if ($result <= 0) return true;\n    }\n    return false;\n}\n",
  "    $sum = 0;\n    $flag = false;\n    $len = $l[0];\n    foreach($l as $number)\
    \ {\n        $sum += $number;\n    }\n    if($sum == 0) {\n        $flag = true;\n\
    \    }\n    else {\n        $j = 0;\n        for($i = 1; $i < $len; $i++) {\n\
    \            if($l[$i] < 0) {\n                while($l[$i] < 0 && $j < $len)\
    \ {\n                    $l[$j] += $l[$i];\n                    $j++;\n      \
    \          }\n            }\n            else {\n                while($l[$i]\
    \ > 0 && $j < $len) {\n                    $l[$j] += $l[$i];\n               \
    \     $j++;\n                }\n            }\n        }\n    }\n    return $flag;\n\
    }\n", "    $l1 = [];\n    $l2 = [];\n    foreach ($l as $item) {\n        $l1[$item]\
    \ = 1;\n    }\n    foreach ($l as $item) {\n        if ($item > 0) {\n       \
    \     $l2[$item] += 1;\n        } else {\n            unset($l2[$item]);\n   \
    \     }\n    }\n    return $l2[0] === $l1[count($l1)-1];\n}\n", "  if (!is_array($l))\
    \ {\n    return false;\n  }\n  $results = [];\n  $n = count($l);\n  for ($i =\
    \ 0; $i < $n; $i++) {\n    $l2 = $l;\n    sort($l2);\n    $j = array_shift($l2);\n\
    \    $results[] = [$i, $j];\n    while (count($l2) > 0) {\n      $j2 = array_shift($l2);\n\
    \      if ($j != $j2) {\n        $results[] = [$i, $j];\n        $j = $j2;\n \
    \     } else {\n        $results[] = [$i, $j2];\n      }\n    }\n  }\n  return\
    \ array_count_values($results);\n}\n", "  return !array_diff($l, array_unique($l));\n\
    }\n", "  $sum = 0;\n  foreach ($l as $item) {\n    if ($item == 0) return false;\n\
    \    $sum += $item;\n  }\n  if ($sum == 0) return false;\n  sort($l);\n  $first\
    \ = array_shift($l);\n  foreach ($l as $item) {\n    if ($item != $first) return\
    \ false;\n  }\n  return true;\n}\n", "    $sum = 0;\n    foreach ($l as $v) {\n\
    \        $sum += $v;\n    }\n    if ($sum == 0) {\n        return false;\n   \
    \ }\n    if ($sum < 0) {\n        return true;\n    }\n    $keys = array();\n\
    \    foreach ($l as $v) {\n        if ($v == 0) {\n            return false;\n\
    \        }\n        if (in_array($v, $keys)) {\n            return false;\n  \
    \      }\n        $keys[] = $v;\n    }\n    return true;\n}", "    $nums = array_count_values($l);\n\
    \    foreach ($nums as $k => $v) {\n        if ($v === 1) {\n            return\
    \ false;\n        }\n    }\n    return true;\n}\n", "    return count($l) == count(array_filter(array_count_values($l),\
    \ 'is_int')) && array_sum($l) == 0;\n}", "    $n = count($l);\n    for ($i = 0;\
    \ $i < $n; $i++) {\n        for ($j = $i + 1; $j < $n; $j++) {\n            if\
    \ ($l[$i] + $l[$j] == 0) {\n                return true;\n            }\n    \
    \    }\n    }\n    return false;\n}\n", "    $sum = 0;\n    $l = array_count_values($l);\n\
    \    foreach($l as $k => $v) {\n        if ($v > 1) {\n            $sum += $v;\n\
    \        } else {\n            $sum += $k;\n        }\n    }\n    return ($sum\
    \ == 0);\n}", "  $a1 = $l[0];\n  $a2 = $l[1];\n  if ($a1 + $a2 == 0) {\n    return\
    \ true;\n  }\n  return false;\n}\n", "    if (is_array($l)) {\n        if (count($l)\
    \ <= 1) {\n            return false;\n        }\n        $results = [];\n    \
    \    foreach ($l as $item) {\n            $results[$item] = $item;\n        }\n\
    \        $sum = 0;\n        foreach ($results as $item) {\n            $sum +=\
    \ $item;\n        }\n        if ($sum == 0) {\n            return true;\n    \
    \    } else {\n            return false;\n        }\n    }\n    return false;\n\
    }", "  $sum = 0;\n  $num = 0;\n  $first = null;\n  foreach ($l as $k => $v) {\n\
    \    $num++;\n    $sum += $v;\n    if ($sum === 0) {\n      $first = $k;\n   \
    \   $sum = $v;\n    } else {\n      if ($first === null) {\n        return true;\n\
    \      }\n      $sum -= $l[$first];\n    }\n  }\n  if ($num !== count($l)) {\n\
    \    return null;\n  }\n  return false;\n}\n", "    $pairs = array();\n    foreach\
    \ ($l as $a) {\n        foreach ($l as $b) {\n            if (($b - $a) == 0)\
    \ {\n                if ($a < $b) $pairs[] = $b;\n                else $pairs[]\
    \ = $a;\n            }\n        }\n    }\n    return count($pairs) == 2;\n}",
  "  $sums = array();\n  for ($i = 0; $i < count($l); $i++) {\n    $sums[] = array_sum(array_slice($l,\
    \ $i, 1));\n  }\n  $result = array_count_values($sums);\n  foreach ($result as\
    \ $sum => $count) {\n    if ($count == 2) {\n      return false;\n    }\n  }\n\
    \  return true;\n}", "    if (empty($l)) {\n        return false;\n    }\n   \
    \ $n = array_shift($l);\n    foreach ($l as $v) {\n        if ($v > 0) {\n   \
    \         return false;\n        }\n    }\n    if ($n === 0 && count($l) === 1)\
    \ {\n        return true;\n    }\n    return array_reduce($l, function ($acc,\
    \ $v) {\n        if ($v === 0) {\n            return $acc;\n        }\n      \
    \  return $acc || ($v !== 0 && $v != $n);\n    });\n}\n</code>\n<|/ a dscore=2\
    \ tags=arrays,php |>\n<| a dscore=2 |>\nHere is my solution. \nFirst we check\
    \ if there are two distinct elements that are both greater than 0. \nThen we start\
    \ looping through each element and check if it sums to zero and if it is we check\
    \ whether that element is in the array that we are currently checking. \nIf it\
    \ is not in the array then we add the new element to the array and move on to\
    \ the next element. \nI hope this helps.\n<code>", "  if (empty($l)) return false;\n\
    \  $n = count($l);\n  $sum = 0;\n  $j = 1;\n  for ($i = 0; $i < $n; $i++) {\n\
    \    do {\n      $sum = $sum + $l[$i];\n      if ($sum >= 0) $j++;\n    } while\
    \ ($j < $n && $sum != 0);\n    if ($sum != 0) return false;\n  }\n  return true;\n\
    }\n", "    $first = array_shift($l);\n    $last = array_shift($l);\n    $ans =\
    \ false;\n    foreach ($l as $item) {\n        if ($item == $last + 1) {\n   \
    \         $ans = !$ans;\n        } else if ($item == $first - 1) {\n         \
    \   $ans = !$ans;\n        }\n    }\n    return $ans;\n}\n", "  // write your\
    \ code here\n  foreach ($l as $key => $value) {\n    if ($key > 0) {\n      $count\
    \ = 0;\n      $first = false;\n      $last = array_slice($l, $key - 1, 1);\n \
    \     $first = array_slice($l, $key, 1);\n      foreach ($first as $k => $item)\
    \ {\n        if ($item == 0) {\n          $count++;\n        } else {\n      \
    \    break;\n        }\n      }\n      foreach ($last as $k => $item) {\n    \
    \    if ($item == 0) {\n          $count++;\n        } else {\n          break;\n\
    \        }\n      }\n      if ($count == 2) {\n        return true;\n      }\n\
    \    }\n  }\n  return false;\n}", "    $c = array_count_values($l);\n    foreach($c\
    \ as $k => $v) {\n        if($v < 2) return false;\n    }\n    return true;\n\
    }\n", "    $pairs = array_count_values($l);\n    // iterate over pairs -- if there\
    \ are 2 or more distinct elements,\n    // return false\n    foreach ($pairs as\
    \ $a => $b){\n        if ($b < 2) return false;\n    }\n    // return true only\
    \ if all pairs sum to 0\n    foreach ($pairs as $a => $b){\n        if ($b ==\
    \ 0) return true;\n    }\n    // if here, return false\n    return false;\n}\n",
  "    $s = array_sum($l);\n    $n = count($l);\n    for($i = 0; $i < $n; $i++) {\n\
    \        for($j = 0; $j < $n; $j++) {\n            if($i != $j && $l[$i] + $l[$j]\
    \ == 0) {\n                return false;\n            }\n        }\n    }\n  \
    \  return true;\n}\n</code>\n<|/ a tags=python,algorithm,php |>\n<| c |>\nThank\
    \ you. Do you think it is possible to have this working in PHP? The function is\
    \ working as expected on Python but it is not working on PHP\n<|/ c |>\n<| a dscore=1\
    \ tags=python,algorithm,php |>\nThis algorithm works for me:\n<code>\n<?php\n\n\
    $arr = [1,3,-3,5,5,7,0];\n$sum = 0;\n$result = [];\n$n = 0;\nforeach($arr as $number){\n\
    \    if($number > 0){\n        $sum += $number;\n        if($sum == 0){\n    \
    \        $result[$n] = $number;\n            $n++;\n        }\n    }\n}\n\nvar_dump($result);\n",
  "    foreach ($l as $k => $v) {\n        foreach ($l as $i => $val) {\n        \
    \    if ($val == $v && $k != $i) {\n                return false;\n          \
    \  }\n        }\n    }\n    return true;\n}\n", "    if (sizeof($l) === 0) return\
    \ false;\n    $x = array_shift($l);\n    $y = array_shift($l);\n    if ($x ==\
    \ 0 || $y == 0) return false;\n    return ((array_sum($l) == $x) && (array_sum($l)\
    \ == $y));\n}\n", "    sort($l);\n    $sum = 0;\n    for ($i = count($l)-1; $i\
    \ >= 0; $i--) {\n        if ($l[$i] + $l[$i+1] == $sum) {\n            unset($l[$i],\
    \ $l[$i+1]);\n        } else {\n            $sum = $l[$i] + $sum;\n        }\n\
    \    }\n    return empty($l) ? false : true;\n}", "    $pairs = array();\n   \
    \ $zeroes = 0;\n    foreach($l as $i => $num) {\n        $pairs[$num] = $i;\n\
    \        for($j = ($i + 1) ; $j < count($l) ; $j++) {\n            $pairs[$l[$j]]\
    \ -= 1;\n            $zeroes += $l[$j];\n        }\n    }\n    return $zeroes\
    \ > 0 && count($pairs) == 2;\n}\n", "    // We will use an array to keep track\
    \ of the pairs that sum to zero.\n    // A pair is a pair of values from the input\
    \ array that sums to zero.\n    $pairs = array();\n\n    // Iterate through the\
    \ array.\n    foreach ($l as $i => $e) {\n        // Get the value of this pair.\n\
    \        $e0 = $l[$i];\n\n        // Check if the value of this pair is already\
    \ in our array of pairs.\n        $found = false;\n\n        // If there is no\
    \ current pair, just add this pair to the array of pairs.\n        if (count($pairs)\
    \ == 0) {\n            $pairs[] = array();\n            $pairs[][] = $e0;\n  \
    \      }\n        // Iterate through the current pairs.\n        else {\n    \
    \        // Iterate through the pairs we've already found.\n            foreach\
    \ ($pairs as $pair) {\n                // If this is the pair that sums to zero,\
    \ add it to the array of pairs.\n                if ($e == $pair[0] + $pair[1])\
    \ {\n                    $pairs[$i][] = $e0;\n                    $found = true;\n\
    \                    break;\n                }\n            }\n            //\
    \ If there is no pair sums to zero, add the new pair to the array of pairs.\n\
    \            if (!$found) {\n                $pairs[] = array();\n           \
    \     $pairs[][] = $e0;\n            }\n        }\n    }\n\n    // Check whether\
    \ we found any pairs that sum to zero.\n    if (count($pairs) == 0) {\n      \
    \  return false;\n    }\n    else {\n        return true;\n    }\n}\n", "    sort($l);\n\
    \    $j = 1;\n    $result = ($l[0] + $l[1] === 0);\n    for ($i = 2; $i < count($l);\
    \ $i++) {\n        if ($l[$i] + $l[$j] === 0) {\n            $result = false;\n\
    \        } else {\n            $result = true;\n        }\n        $j++;\n   \
    \ }\n    return $result;\n}", "    sort($l);\n    $sum = 0;\n    $n = sizeof($l)\
    \ - 1;\n    for($i = 0; $i < $n; $i++) {\n        $sum += $l[$i];\n        $l[$i]\
    \ = $sum;\n        $sum -= $l[$i + 1];\n        $l[$i + 1] = $sum;\n    }\n  \
    \  return array_count_values($l) == 1;\n}\n", "  $sum = 0;\n  $result = [];\n\
    \  foreach ($l as $item) {\n    if ($item > 0) {\n      $sum = $sum + $item;\n\
    \      $result[] = $sum;\n    }\n  }\n  sort($result);\n  $diff = 0;\n  foreach\
    \ ($result as $val) {\n    if ($val != 0) {\n      $diff = $diff + $val;\n   \
    \   if ($diff != 0) {\n        return true;\n      }\n    }\n  }\n  return false;\n\
    }", "    $n = count($l);\n    $s = array();\n    for ($i = 0; $i < $n; $i++) {\n\
    \        $sum = 0;\n        for ($j = 0; $j < $n; $j++) {\n            if ($i\
    \ == $j) {\n                continue;\n            }\n            $sum += $l[$i];\n\
    \            $sum *= -1;\n            if ($sum > 0) {\n                $s[$sum]\
    \ = $i;\n            }\n        }\n    }\n    if ($s[0] == 0) {\n        return\
    \ true;\n    }\n    $found = 0;\n    $i = 0;\n    $j = 0;\n    while ($found <\
    \ 2) {\n        if ($i == $j) {\n            $j += 1;\n            $found++;\n\
    \        }\n        if ($s[$j] != 0) {\n            $j += 1;\n            $found++;\n\
    \        }\n        if ($s[$j] != 0) {\n            $i += 1;\n            $found++;\n\
    \        }\n        if ($s[$i] != 0) {\n            $i += 1;\n            $found++;\n\
    \        }\n    }\n    return false;\n}", "    $sum = 0;\n    foreach ($l as $i\
    \ => $s) {\n        if ($s === 0) return false;\n        $sum += $s;\n    }\n\
    \    foreach ($l as $i => $s) {\n        if ($s !== 0) return false;\n    }\n\
    \    $sum -= $l[0];\n    return $sum === 0;\n}\n</code>\n<|/ a dscore=1 |>\n<|\
    \ c |>\nI don't think this is the right way to do it - it doesn't use pairs, it\
    \ just checks if all elements are 0\n<|/ c |>\n<| c |>\nAh, you're right. I got\
    \ too focused on getting this to work with pairs and thought it could be solved\
    \ with pairs only.\n<|/ c |>\n<| c |>\nI suppose the easiest way to find out if\
    \ there are any pairs is to compare the length of the array to its length?\n<|/\
    \ c |>\n<| c |>\nThis doesn't work if there are two numbers that sum to zero but\
    \ in different positions.\n<|/ c |>\n<| c |>\nIt was an interesting problem to\
    \ solve - it took me quite a while to figure it out.\n<|/ c |>\n<| a dscore=1\
    \ |>\n<code>\n<?php\n\n$numbers = [1,3,-5,0,3,7,-5,5,1,7,9,-3,9,6,0,7,-6,-9,2,4,8,4,-2,1,4,2,-3,-6,7,7,8,-3,2];\n\
    \n$numbers_arr = $numbers;\n\nsort($numbers_arr);\n\n$sum = 0;\n\nfor($i=0; $i<count($numbers_arr);\
    \ $i++){\n\n    $sum += $numbers_arr[$i];\n\n    if($sum == 0){\n        echo\
    \ \"there are 2 pairs of zeros<br>\";\n        break;\n    }\n\n}\n", "    $result=array();\n\
    \    foreach($l as $k=>$v){\n        foreach($l as $k1=>$v1){\n            if($k\
    \ == $k1) continue;\n            if($v+$v1==0){\n                $result[$k][]=array($k,$v1);\n\
    \            }\n        }\n    }\n    return !empty($result);\n}\n", "    // This\
    \ code assumes that all the array elements are integers.\n    // It will fail\
    \ if the array contains floating point elements.\n    // The algorithm makes no\
    \ assumptions about how many duplicates\n    // there might be in the array.\n\
    \    $a = array_count_values($l);\n    \n    // This code assumes that there are\
    \ no repeated elements in the array.\n    $b = 0;\n    \n    foreach ($a as $key\
    \ => $value) {\n        if ($b == 0) {\n            return false;\n        } else\
    \ {\n            if ($value == 0) {\n                return false;\n         \
    \   } else {\n                $b = $b - $value;\n            }\n        }\n  \
    \  }\n    \n    return true;\n}\n", "  $cs = array_count_values($l);\n  return\
    \ count($cs) == 1 && abs(min($cs)) == abs(max($cs));\n}\n", "    foreach ($l as\
    \ $pair) {\n        sort($pair);\n    }\n    if (count($l) == 0) {\n        return\
    \ true;\n    }\n\n    $l[0][0] = -$l[0][0];\n    foreach ($l as $pair) {\n   \
    \     sort($pair);\n        if ($pair[0] > 0) {\n            return false;\n \
    \       }\n    }\n    return true;\n}\n", "  $sum=0;\n  foreach ($l as $k => $v)\
    \ {\n    $sum += $v;\n    if ($sum == 0)\n      return $k+1;\n  }\n  return false;\n\
    }\n", "  // return array_count_values($l);\n  $count = array_count_values($l);\n\
    \  \n  return $count[0]==$count[1];\n}\n", "  foreach($l as $e) {\n    $total\
    \ = 0;\n    foreach($l as $s) {\n      $total += $s;\n      if ($e == $total)\
    \ return false;\n    }\n  }\n  return true;\n}\n", "  $sum = 0;\n  $n = count($l);\n\
    \  for ($i = 0; $i < $n; $i++) {\n    $sum += $l[$i];\n    if ($sum < 0) {\n \
    \     $sum = 0;\n    }\n  }\n  return ($sum == 0);\n}", "  return pairs_sum_to_zero_all($l,\
    \ 0);\n}\n", "    foreach ($l as $pair) {\n        $sum = 0;\n        $size =\
    \ count($pair);\n        for ($i = 0; $i < $size; $i++) {\n            $sum +=\
    \ $pair[$i];\n        }\n        if ($sum > 0) {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n", "    foreach($l as $element) {\n  \
    \      for($i=0;$i<count($l);$i++) {\n            $sum = $element+$l[$i];\n  \
    \          if($sum == 0) {\n                return true;\n            }\n    \
    \        if($sum < 0) {\n                $element-=$l[$i];\n                if($element\
    \ < 0) {\n                    return true;\n                }\n            }\n\
    \            else if($sum > 0) {\n                $l[$i]-=$element;\n        \
    \        if($l[$i] < 0) {\n                    return true;\n                }\n\
    \            }\n        }\n    }\n    return false;\n}", "    $pairs = array();\n\
    \    $n = count($l);\n\n    // initialize pairs array\n    for ($i = 0; $i < $n;\
    \ $i++) {\n        $pairs[] = array($l[$i], 0);\n    }\n\n    // iterate through\
    \ pairs array\n    for ($i = 0; $i < $n - 1; $i++) {\n        $j = $i + 1;\n\n\
    \        // handle first iteration only\n        if ($i == 0) {\n            $pairs[$i][0]\
    \ += $l[$i];\n            $pairs[$j][1] += $l[$i];\n            continue;\n  \
    \      }\n\n        // handle all remaining iterations\n        if ($j == $n)\
    \ {\n            $pairs[$i][1] += $l[$i];\n            break;\n        }\n\n \
    \       // handle all but last iteration\n        $pairs[$i][1] += $l[$i];\n \
    \       $pairs[$j][1] += $l[$i];\n    }\n\n    // return true if there are two\
    \ distinct elements in the array that\n    // sum to zero, and false otherwise.\n\
    \    // for example:\n    //      l = {1, 2, -3, 5}\n    //      pairs = {\n \
    \   //          1 => [-3, 0],\n    //          2 => [1, 0],\n    //          3\
    \ => [0, 1],\n    //          4 => [0, 1]\n    //      }\n    //      returns\
    \ true\n    if ($pairs[0][1] != 0 || $pairs[1][1] != 0 || $pairs[2][1] != 0 ||\
    \ $pairs[3][1] != 0) {\n        return true;\n    }\n\n    return false;\n}\n",
  "  $pairs = array();\n  foreach($l as $i => $value) {\n    foreach($l as $j => $value2)\
    \ {\n      if ($i != $j && $value == $value2) {\n        $pairs[] = array($i,\
    \ $j);\n      }\n    }\n  }\n  return count($pairs) > 0 && twoDie($pairs, 0);\n\
    }\n", "  $a = array_count_values($l);\n  $b = array_count_values(array_reverse($l));\n\
    \  return array_intersect_key($b, $a) === array();\n}\n", "    foreach ($l as\
    \ $key => $item) {\n        for ($i = 0; $i < count($l) - $key - 1; $i++) {\n\
    \            if ($l[$i] + $l[$i + 1] != 0) {\n                return false;\n\
    \            }\n        }\n    }\n    return true;\n}\n</code>\n<|/ a tags=php,arrays\
    \ |>\n<| a tags=php,arrays |>\nYou might want to use the array_diff() function\
    \ to determine if there are two elements that are the same. \n<code>\n<?php\n\
    $array1 = array(2, 3, 3, 5);\n$array2 = array(2, 3, 3);\n\n$array1 = array_unique($array1);\n\
    $array2 = array_unique($array2);\n\nif (array_diff($array2, $array1)) {\n    echo\
    \ \"There are two unique values.\";\n} else {\n    echo \"There are no unique\
    \ values.\";\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like the idea of using\
    \ `array_diff`, but this doesn't work as expected if there are duplicate values\
    \ in both arrays, e.g. `$array2 = array(2, 3, 3, 3, 3);` would return `\"There\
    \ are two unique values.\"` rather than `\"There are no unique values.\"`.\n<|/\
    \ c |>\n<| a tags=php,arrays |>\nFor a one liner:\n<code>\nif ( !count(array_intersect($array1,\
    \ $array2)) )\n</code>\n<|/ a dscore=2 |>\n<| a tags=php,arrays |>\nThe array_diff\
    \ and array_intersect functions are what are needed here.\n<code>", "    $sum\
    \ = 0;\n    $found = false;\n\n    // loop through our list and check each pair\n\
    \    foreach ($l as $i => $val) {\n        // check if we have found the sum already\n\
    \        if ($found && $sum == $val) {\n            return true;\n        }\n\
    \        // sum the current value with anything in the list and check it again\n\
    \        $sum = $sum + $l[$i];\n        // keep track of whether we found a pair\n\
    \        $found = true;\n    }\n\n    // if we have found a pair, there are two\
    \ values that sum to zero\n    return false;\n}\n", "    $sum = 0;\n    $lSize\
    \ = count($l);\n    for ($i = 0; $i < $lSize; $i++) {\n        if ($l[$i] > 0)\
    \ {\n            $sum += $l[$i];\n        }\n    }\n    return ($sum < 0);\n}\n",
  "  $sum = 0;\n  foreach ($l as $key => $value) {\n    if ($value == 0) {\n     \
    \ return false;\n    }\n    $sum += $value;\n  }\n  $sum -= array_sum($l);\n \
    \ return ($sum == 0);\n}", "    $count = count($l);\n    if ($count == 0) return\
    \ false;\n    $sum = $l[0];\n    for ($i = 1; $i < $count; ++$i) {\n        if\
    \ ($l[$i] + $sum != 0) {\n            return false;\n        }\n        $sum +=\
    \ $l[$i];\n    }\n    return true;\n}\n", "  $result = '';\n  $l2 = $l;\n  \n\
    \  foreach ($l2 as $i => $val) {\n    if ($val == 0 && $i != 0) {\n      if ($result\
    \ != '') {\n        return true;\n      }\n      $result = $i;\n    } else if\
    \ ($val == 0 && $i == 0) {\n      return false;\n    }\n  }\n  \n  return $result\
    \ != '';\n}\n", "    return count($l) === 2 && is_int($l[0]) && is_int($l[1])\
    \ &&\n           $l[0] === $l[1] + 0;\n}", "  foreach($l as $index => $value)\
    \ {\n    foreach($l as $second_index => $second_value) {\n      if ($value ==\
    \ $second_value) {\n        if ($value != 0) {\n          return false;\n    \
    \    }\n        if ($index != $second_index) {\n          return false;\n    \
    \    }\n      }\n    }\n  }\n  return true;\n}", "  if (!is_array($l)) {\n   \
    \ die('pairs_sum_to_zero() requires an array');\n  }\n  foreach($l as $i => $el)\
    \ {\n    if ($el < 0) {\n      unset($l[$i]);\n    }\n  }\n  return !count($l);\n\
    }", "    $pairs = array();\n    $sum = 0;\n    $n = count($l);\n    $m = array_count_values($l);\n\
    \    foreach ($m as $k => $n) {\n        $sum += $k;\n        if (isset($pairs[$sum]))\
    \ {\n            foreach ($pairs[$sum] as $k2) {\n                if ($k2 == $k)\
    \ {\n                    return false;\n                }\n            }\n   \
    \     }\n        $pairs[$sum] = array($k);\n    }\n    return true;\n}\n</code>\n\
    <|/ a dscore=2 tags=algorithm,php,arrays |>\n<| a |>\nA different approach is\
    \ to keep track of the unique sums that you've seen.  For example:\n<code>\n$arr\
    \ = [1, 3, 5, 0];\n$uniques = array();\n\nforeach ($arr as $value) {\n    if (!array_key_exists($value,\
    \ $uniques)) {\n        $uniques[$value] = array();\n    }\n    $uniques[$value][]\
    \ = $value;\n}\n\n$uniques = array_unique($uniques);\n\necho 'Unique sums: ' .\
    \ implode(', ', $uniques);\n</code>\nOutput:\n\nUnique sums: 3, 5\n\nDemo\n<|/\
    \ a dscore=1 tags=algorithm,php,arrays |>\n<| c |>\nI think I like this. This\
    \ way you have a new array to keep track of unique sums.\n<|/ c |>\n<| c |>\n\
    Yeah, that's what I meant to do, but didn't have time for it.  I've updated my\
    \ answer with the code I used.\n<|/ c |>\n<| a tags=algorithm,php,arrays |>\n\
    This isn't really an answer to the question, but it's an alternative solution,\
    \ if you don't mind modifying the inputs.  Since you mentioned array_count_values,\
    \ I thought I'd give that a try.\nThis function will let you count how many times\
    \ each unique value occurs in a given array.  Then you can decide which unique\
    \ values you want to remove from the output (probably the keys from the array\
    \ of pairs).\n<code>", "    $pairs = array();\n    foreach($l as $item) {\n  \
    \      foreach($l as $i => $item) {\n            if ($item == $i) {\n        \
    \        continue;\n            }\n            $sum = ($item < 0) ? $item + max($l)\
    \ - $i : $item + $i;\n            if ($sum == 0) {\n                $pairs[] =\
    \ array($i, $item);\n            }\n        }\n    }\n    return count($pairs)\
    \ == 2;\n}\n</code>\n<|/ a tags=php,arrays,sorting,algorithm |>\n<| c |>\nThanks\
    \ for the answer. I'm very new to PHP, so I may have missed something - could\
    \ you elaborate on the \"if ($sum == 0) return false;\" line? Also, would this\
    \ work for an array of non-negative integers? I've edited my question to clarify\
    \ what kind of input I'm dealing with.\n<|/ c |>\n<| c |>\n- I edited my answer\
    \ to include some explanation for the `if ($sum == 0) return false;` line. Also,\
    \ I see you added an example of `array(2, 4, -5, 3, 5, 7)` as one of your inputs.\
    \ If you run the above code with that array as an input, the function will return\
    \ `false`, because there are no two non-negative integers that sum to zero. Is\
    \ that what you wanted?\n<|/ c |>\n<| c |>\nYes, that looks correct. I actually\
    \ was testing this on a larger array, so I forgot that my test array didn't have\
    \ pairs that sum to zero.\n<|/ c |>\n<| c |>\n- No problem. Glad I could help.\n\
    <|/ c |>\n<| a dscore=1 |>\nAn untested idea:\n<code>", "    $sum = 0;\n    foreach($l\
    \ as $k=>$v) {\n        if ($sum > 0 && $sum == $v) {\n            return false;\n\
    \        }\n        $sum += $v;\n    }\n    return true;\n}", "    sort($l);\n\
    \    $lsum = 0;\n    foreach ($l as $k => $v) {\n        $lsum += $v;\n      \
    \  if ($v > 0 && $lsum == 0) {\n            return false;\n        }\n    }\n\
    \    return true;\n}\n", "    $n = count($l);\n    if ($n == 0) {\n        return\
    \ false;\n    }\n\n    $sum = 0;\n    for ($i = 0; $i < $n; $i++) {\n        $sum\
    \ += $l[$i];\n    }\n\n    for ($i = 0; $i < $n; $i++) {\n        if ($sum ==\
    \ $l[$i]) {\n            return false;\n        }\n    }\n\n    return true;\n\
    }\n", "    sort($l);\n    foreach ($l as $pair) {\n        $b = array_fill(0,\
    \ 2, 0);\n        foreach ($l as $k => $v) $b[$v]++;\n        if ($b == array_fill(0,\
    \ 2, 0)) {\n            return false;\n        }\n    }\n    return true;\n}\n\
    </code>\n<|/ a tags=combinations,php,arrays dscore=1 |>\n<| a dscore=1 |>\n<code>\n\
    $arr = array(1, 3, -2, 1);\n$count = count($arr);\nforeach ($arr as $i => $v)\
    \ {\n    for ($j = $i; $j < $count; ++$j) {\n        $arr[$i] -= $arr[$j];\n \
    \       $arr[$j] += $arr[$i];\n        if ($arr[$i] == 0) {\n            return\
    \ $arr;\n        }\n    }\n}\n</code>\n<|/ a tags=combinations,php,arrays |>\n\
    <| a tags=combinations,php,arrays dscore=1 |>\nThis works also in PHP:\n<code>\n\
    <?php", "  if (count($l) <= 1) return false;\n\n  // a helper function to test\
    \ whether two numbers are equal\n  function isEqual($x, $y) {\n    return $x ==\
    \ $y;\n  }\n\n  $sum = 0;\n  $first = 0;\n  foreach ($l as $item) {\n    $first\
    \ = $item;\n    $sum += $first;\n  }\n  if ($sum != 0) {\n    foreach ($l as $item)\
    \ {\n      if (isEqual($item, $sum)) return false;\n    }\n    return true;\n\
    \  }\n  else {\n    return false;\n  }\n}\n", "  $pairs = array();\n  $sum = 0;\n\
    \  foreach ($l as $v) {\n    $pairs[$v][] = $sum;\n    $sum += $v;\n  }\n  foreach\
    \ ($pairs as $v => $a) {\n    sort($a);\n    $pairs[$v] = array_merge($a, $pairs[$v]);\n\
    \  }\n  $n = count($pairs[max($pairs)]);\n  for ($i = 0; $i < $n; ++$i) {\n  \
    \  if (count($pairs[$i]) != 2) {\n      return false;\n    }\n  }\n  return true;\n\
    }\n", "    $a = array_count_values($l);\n    return $a[array_sum($a)] == 0;\n\
    }\n</code>\n<|/ a tags=arrays,php,math |>\n<| c |>\nThe algorithm is fine for\
    \ small arrays, but the efficiency can be improved by using a binary search to\
    \ find the indexes of items with non-zero sum before iterating through the array.\
    \ Also, it should be noted that an input array of size 1 will always return false.\n\
    <|/ c |>\n<| c |>\nThis does not work for me for the following array: array(-1.2,\
    \ -0.4, -0.1, 0.0, 0.2, -1.4, -1.2)\n<|/ c |>\n<| c |>\n: That's not a valid input\
    \ array. The algorithm works fine on my test case.\n<|/ c |>\n<| c |>\n: It also\
    \ fails if all the numbers are zero.\n<|/ c |>\n<| a tags=arrays,php,math |>\n\
    Try this:\n<code>\n<?php\n", "    $a = array_count_values($l);\n    $b = array_count_values(array_flip($l));\n\
    \    return ($a['0'] + $b['0']) == 0 ? false : true;\n}", "  $sum = 0;\n  foreach($l\
    \ as $e) {\n    $sum += $e;\n    if ($sum > 0) {\n      return true;\n    }\n\
    \  }\n  return false;\n}\n", "    $sum = 0;\n    foreach ($l as $item) {\n   \
    \     $sum += $item;\n    }\n    return ($sum == 0);\n}\n", "    $s = array();\n\
    \    $m = array_sum($l);\n    foreach ($l as $n => $x) {\n        $s[$n][] = $x;\n\
    \        if ($x == $m) {\n            return false;\n        }\n    }\n    return\
    \ true;\n}\n", "    $retVal = false;\n\n    for ($i = 0; $i < sizeof($l); $i++)\
    \ {\n        for ($j = $i+1; $j < sizeof($l); $j++) {\n            if ($l[$i]\
    \ + $l[$j] == 0) {\n                $retVal = true;\n                break;\n\
    \            }\n        }\n    }\n\n    return $retVal;\n}", "    foreach ($l\
    \ as $key => $value) {\n        foreach ($l as $key2 => $value2) {\n         \
    \   if ($key != $key2 && $value != $value2 && $value + $value2 == 0) {\n     \
    \           return false;\n            }\n        }\n    }\n    return true;\n\
    }\n</code>\n<|/ a dscore=2 tags=arrays,php |>\n<| c |>\nNice solution too, thanks.\
    \ But I think `array_reduce` should be more efficient.\n<|/ c |>\n<| c |>\nI disagree,\
    \ array_reduce is about as efficient as it gets, I doubt you'll see an improvement.\n\
    <|/ c |>\n<| c |>\nI haven't thought about performance. But I still think this\
    \ way is more readable and maintainable. I'm a newbie in programming, maybe I\
    \ should switch to Java and learn Python instead.\n<|/ c |>\n<| c |>\nI agree,\
    \ it's not really readable. Although it works very well for arrays of length 8,\
    \ it quickly gets out of hand. Also it has a lot of redundant code. For example,\
    \ `$key != $key2` can be replaced with `$key != $key2 || $value == $value2`. Same\
    \ goes for `$value + $value2 == 0`. Although I'm not sure it matters much for\
    \ short arrays. But even with a longer array it doesn't help a lot.\n<|/ c |>\n\
    <| a dscore=2 tags=arrays,php |>\nThis is a more elegant way in my opinion:\n\
    <code>\n<?php", "  if (empty($l))\n    return false;\n  $sum = 0;\n  $i = 1;\n\
    \  foreach ($l as $item) {\n    $sum += $item;\n    if ($sum === 0)\n      return\
    \ true;\n    if ($sum > 0) {\n      $i++;\n      $sum -= $item;\n      if ($i\
    \ === 2) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n",
  "  foreach ($l as $i => $num) {\n    foreach ($l as $j => $num) {\n      if ($num\
    \ - $l[$j] == 0) {\n        array_splice($l, $i, 1);\n      }\n    }\n  }\n  return\
    \ empty($l);\n}", "    $num_elements = count($l);\n    $num_pairs = $num_elements\
    \ - 1;\n    for ($i = 0; $i < $num_elements; $i++) {\n        $j = $i + 1;\n \
    \       $sum = $l[$i] + $l[$j];\n        if ($sum < 0) {\n            $sum +=\
    \ $num_elements;\n        }\n        if ($sum == 0) {\n            return true;\n\
    \        }\n    }\n    return false;\n}", "  $sum = 0;\n  $count1 = 0;\n  $count2\
    \ = 0;\n  foreach($l as $k=>$v){\n    $sum += $v;\n    if ($sum == 0) {\n    \
    \  $count1++;\n    } else {\n      if ($sum > 0) {\n        $count2++;\n     \
    \ }\n    }\n  }\n  if ($count1 == $count2) {\n    return true;\n  } else {\n \
    \   return false;\n  }\n}\n", "  sort($l);\n  $n = sizeof($l);\n  for($i = 0;\
    \ $i < $n - 1; $i++) {\n    if($l[$i] + $l[$i + 1] == 0) return false;\n  }\n\
    \  return true;\n}\n", "    $sum = 0;\n    $first = true;\n    $result = array();\n\
    \    foreach($l as $item) {\n        if ($first) {\n            $first = false;\n\
    \            $sum = $item;\n            $result[$sum] = 1;\n        } else {\n\
    \            $sum = $sum + $item;\n            if ($sum == 0) {\n            \
    \    $result[$sum] = 1;\n            } else {\n                unset($result[$sum]);\n\
    \            }\n        }\n    }\n    if (count($result) == 0) {\n        return\
    \ true;\n    } else {\n        return false;\n    }\n}\n", "    $first = array_shift($l);\n\
    \    foreach ($l as $a) {\n        $b = array_shift($l);\n        if ($a === 0\
    \ && $b === 0) {\n            return false;\n        }\n        if ($a !== $b)\
    \ {\n            return true;\n        }\n    }\n    return true;\n}\n", "  $sum\
    \ = 0;\n  $counter = 0;\n  $first = 1;\n  foreach ($l as $item) {\n    if ($item\
    \ == 0) {\n      $first = 0;\n    } else {\n      if ($first == 1) {\n       \
    \ $sum += $item;\n        $counter++;\n      } else {\n        if ($counter ==\
    \ 2) {\n          return true;\n        }\n        $sum -= $item;\n        $counter\
    \ = 1;\n      }\n    }\n  }\n  return false;\n}\n", "    foreach ($l as $index\
    \ => $value) {\n        $sum = 0;\n        foreach ($l as $subindex => $subvalue)\
    \ {\n            $sum += $value;\n            if ($sum == $subvalue) {\n     \
    \           $l[$index] = $subindex;\n                break;\n            }\n \
    \       }\n    }\n    return count($l) == 1;\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\n`count(array_unique($l)) == 1` is very close to `pairs_sum_to_zero($l)`.\
    \  I would expect `count(array_unique($l)) == 1` to return `true` in your example,\
    \ while `pairs_sum_to_zero($l)` should return `false`.  Am I missing something?\n\
    <|/ c |>\n<| c |>\nI did notice that the OP didn't care about duplicate elements\
    \ in the array and just wanted true if the pairs sum to zero.\n<|/ c |>\n<| c\
    \ |>\nI'm sorry, I should've been more clear: I do care about duplicate elements.\
    \ I just don't care about duplicates in the middle of the array. In the example\
    \ I gave, all pairs of elements in the array sum to zero. In the general case,\
    \ I don't care about the middle of the array\n<|/ c |>\n<| c |>\nI made an edit\
    \ to my answer. Try it out.\n<|/ c |>\n<| c |>\nThat's a good idea, but this only\
    \ works if the entire array is already zero. For example, if the array is `[2,4,8,6,6,7]`,\
    \ then `pairs_sum_to_zero($array)` returns `false` while `pairs_sum_to_zero([2,4,6,6,7])`\
    \ returns `true`. I need it to be true if the entire array is zero\n<|/ c |>\n\
    <| a dscore=0 tags=algorithm,php |>\nA simple iterative method would be to iterate\
    \ through your array, setting a flag on every pair that sums to zero. If the flag\
    \ is set, you found a pair of numbers that sum to zero. Here is an example:\n\
    <code>\n<?php\n", "  // Write your code here\n  $n = sizeof($l);\n  for($i=0;\
    \ $i<$n; $i++) {\n    for($j=$i+1; $j<$n; $j++) {\n      if ($l[$i]+$l[$j]==0)\
    \ {\n        return true;\n      }\n    }\n  }\n  return false;\n}", "    $pairs\
    \ = array_count_values($l);\n    if (sizeof($pairs) < 2) {\n        return false;\n\
    \    }\n    $max_val = max($l);\n    foreach ($pairs as $key => $value) {\n  \
    \      if ($max_val - $value < 2) {\n            return false;\n        }\n  \
    \  }\n    return true;\n}\n", "    sort($l);\n    $lSum = 0;\n    $rSum = 0;\n\
    \    foreach ($l as $item) {\n        $lSum += $item;\n        if ($item < 0)\
    \ {\n            $rSum -= $item;\n        }\n    }\n    if ($lSum > 0) {\n   \
    \     return false;\n    }\n    foreach ($l as $item) {\n        if ($item ==\
    \ 0) {\n            return true;\n        }\n        $rSum += $item;\n    }\n\
    \    return $rSum == 0;\n}\n", "    foreach ($l as $key => $value) {\n       \
    \ $other_value = array_sum($l) - $value;\n        if ($value + $other_value ==\
    \ 0) {\n            return true;\n        }\n    }\n    return false;\n}\n", " \
    \ return sizeof($l) === sizeof(array_unique($l)) == sizeof($l);\n}", "    $pairs\
    \ = array_count_values($l);\n    $sum = 0;\n    foreach ($pairs as $p => $n) {\n\
    \        if ($n != 0) {\n            if ($sum != 0) {\n                return\
    \ false;\n            }\n            $sum = $p;\n        }\n    }\n    if ($sum\
    \ != 0) {\n        return false;\n    }\n    return true;\n}\n</code>\n<|/ a tags=combinations,php\
    \ dscore=1 |>\n<| a tags=combinations,php dscore=1 |>\nI believe there is a simpler\
    \ solution using array_filter. Although it may not work well for large arrays\
    \ and is quite inefficient, it still does the job and seems more efficient than\
    \ using the foreach loop which would be far worse if you have a large array.\n\
    <code>\n<?php\n\n    $array = array(1, 3, 5, 0);\n    $newArray = array_filter($array,\
    \ function($val){\n        return $val != 0;\n    }, ARRAY_FILTER_USE_BOTH);\n\
    \n    var_dump($newArray);\n", "  foreach ($l as $key => $value) {\n    foreach\
    \ ($l as $key2 => $value2) {\n      if ($key == $key2 && ($value + $value2) ===\
    \ 0) {\n        return false;\n      }\n    }\n  }\n  return true;\n}", "    $zero\
    \ = array_filter($l, function($num) {\n        return $num === 0;\n    });\n \
    \   return count($zero) !== count($l) ? false : true;\n}\n</code>\nI didn't want\
    \ to use array_diff() here because it doesn't support multi-dimensional arrays.\n\
    I did some reading of the code you wrote and found that the array_diff() function\
    \ is used to compare two arrays. It is very useful because we can pass an array\
    \ and get a difference array back with the elements of the first array that aren't\
    \ in the second array.\nThe array_filter() function is used to filter out certain\
    \ elements. In this case, it filters out all the zeros because I passed array_filter($l,\
    \ function($num) { return $num === 0; });. It then compares the filtered array\
    \ with all the elements in $l.\nI decided to use array_filter() to filter out\
    \ the zeros and then compare the results with array_diff(). It seemed a little\
    \ simpler.\nI then decided to write my own solution to solve this problem because\
    \ I didn't want to use array_diff() or the array_filter() function.\nI decided\
    \ to use my own function to solve this problem because it was less code than array_filter()\
    \ and array_diff().\nI wrote my own function to solve this problem. My solution\
    \ doesn't use array_diff() or array_filter().\nHere is the code:\n<code>\n<?php",
  "    sort($l);\n    $last = null;\n    $sum = $l[0][0];\n    for ($i = 0; $i < count($l);\
    \ $i++) {\n        if ($last !== null && $l[$i][$last] == $l[$i][0] - $l[$last][0])\
    \ {\n            $sum -= $l[$last][0];\n        } else {\n            $sum +=\
    \ $l[$i][0]; // += means sum\n            $last = $i;\n        }\n    }\n    return\
    \ $sum == 0;\n}\n", "    $sum = array_sum($l);\n    foreach($l as $i => $e) {\n\
    \        $l[$i] = abs($e);\n    }\n    $s = array_count_values($l);\n    $result\
    \ = true;\n    foreach($s as $i => $e) {\n        if($e != $sum) {\n         \
    \   $result = false;\n        }\n    }\n    return $result;\n}\n", "  return count(array_count_values($l))\
    \ == 1;\n}\n", "    return array_count_values($l)[0] == count($l);\n}\n", "  $sum\
    \ = 0;\n  foreach ($l as $n) {\n    $sum += $n;\n  }\n  return ($sum < 0);\n}",
  "    $sum = 0;\n    $twos = 0;\n    $two = 0;\n    $even = 0;\n    foreach ($l as\
    \ $item) {\n        if ($item > 0) $sum += $item;\n        if ($item == 2) $twos++;\n\
    \        if ($item % 2 == 0) $even++;\n    }\n    return ($sum == 0 && $twos ==\
    \ 0 && $even == 0);\n}", "    sort($l);\n    $n = 0;\n    $k = 0;\n    $m = count($l)\
    \ - 1;\n    for ($i = $m; $i >= 0; $i--) {\n        $n++;\n        if ($l[$i]\
    \ == 0) {\n            $k++;\n        }\n    }\n    return $k == $n;\n}\n", " \
    \   $result=true;\n    foreach ($l as $key => $value) {\n        if (is_numeric($value))\
    \ {\n            if ($value < 0) {\n                if (is_numeric($l[$key-1]))\
    \ {\n                    $result=$result && ($l[$key-1]<0);\n                }\
    \ else {\n                    $result=$result && ($value<0);\n               \
    \ }\n            } else {\n                if (is_numeric($l[$key-1])) {\n   \
    \                 $result=$result && ($l[$key-1]==0);\n                } else\
    \ {\n                    $result=$result && ($value==0);\n                }\n\
    \            }\n        } else {\n            if (is_numeric($l[$key-1])) {\n\
    \                $result=$result && ($l[$key-1]==0);\n            } else {\n \
    \               $result=$result && ($value==0);\n            }\n        }\n  \
    \  }\n    return $result;\n}", "    $r = array_reverse($l);\n    return array_diff_assoc($r,\
    \ $l);\n}\n", "\t$pairs = array(\n\t\tarray(1,2),\n\t\tarray(3,4),\n\t\tarray(5,6),\n\
    \t\tarray(7,8),\n\t\tarray(9,10),\n\t\tarray(11,12),\n\t\tarray(13,14),\n\t\t\
    array(15,16)\n\t);\n\tforeach ($pairs as $pair) {\n\t\t$first = array_shift($l);\n\
    \t\t$second = array_shift($l);\n\t\tif ($first + $second == 0) {\n\t\t\t$pairs[]\
    \ = $pair;\n\t\t\tcontinue;\n\t\t}\n\t\treturn false;\n\t}\n\treturn true;\n}",
  "    if (sizeof($l) !== 1) {\n        throw new Exception('pairs_sum_to_zero only\
    \ works on one-dimensional arrays');\n    }\n    $pairs = array();\n    foreach\
    \ ($l as $key => $val) {\n        if ($val < 0) {\n            $pairs[$key] =\
    \ -$val;\n        } else {\n            $pairs[$key] = $val;\n        }\n    }\n\
    \    return count(array_intersect($pairs, array_flip($pairs))) === 1;\n}", " \
    \   $r = array();\n    foreach($l as $v) {\n        if ($v < 0) {\n          \
    \  return false;\n        }\n        if (array_key_exists($v, $r) && $r[$v] ==\
    \ 0) {\n            return false;\n        } else {\n            $r[$v] = 1;\n\
    \        }\n    }\n    if (empty($r)) {\n        return false;\n    }\n    foreach\
    \ ($r as $k => $v) {\n        if ($v != 2) {\n            return false;\n    \
    \    }\n    }\n    return true;\n}\n", "    $count = count($l);\n    if ($count\
    \ < 2)\n        return false;\n    $pairs = array_count_values($l);\n    foreach\
    \ ($pairs as $k => $v) {\n        if ($v > 1)\n            return false;\n   \
    \ }\n    return true;\n}\n", "    $arr = array_count_values($l);\n    foreach\
    \ ($arr as $key => $val) {\n        if ($val == 1) {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n", "    // iterate over pairs such that\
    \ a[i] + b[j] = 0 for all i, j where 0 <= i < j\n    foreach($l as $a => $b) {\
    \ \n        for ($i = $a; $i <= $a-$b;$i++) \n            for ($j = $a + 1; $j\
    \ <= $a-$b; $j++) \n                if ($l[$i] + $l[$j] == 0) return true;\n \
    \   }\n    return false;\n}", "    sort($l);\n    for($i = 1; $i < count($l);\
    \ $i++) {\n        for($j = $i+1; $j < count($l); $j++) {\n            if ($l[$i]\
    \ + $l[$j] == 0) {\n                return false;\n            }\n        }\n\
    \    }\n    return true;\n}\n", "    sort($l);\n    $s = 0;\n    $t = array_pop($l);\n\
    \    for ($i = 0; $i < count($l); $i++) {\n        $s += $l[$i];\n        if ($s\
    \ == 0) {\n            return $s == $t;\n        }\n        if ($s < 0) {\n  \
    \          return false;\n        }\n    }\n}\n", "    $l = array_values($l);\n\
    \    if (count($l) < 2) return false;\n    if ($l[0] != 0 && $l[1] != 0) return\
    \ false;\n    $sum = $l[0] + $l[1];\n    foreach (array_slice($l, 2) as $n) {\n\
    \        if ($sum - $n == 0) return true;\n        $sum -= $n;\n    }\n    return\
    \ false;\n}", "  // Write your code here\n}\n</cell>\n<cell>", "  $n = count($l);\n\
    \  if($n == 0) return false;\n  $ret = false;\n  $d = array_count_values($l);\n\
    \  $keys = array_keys($d);\n  for($i = 0; $i < $n - 1; $i++){\n    $sum += $keys[$i];\n\
    \    if($sum < 0) $sum = 0;\n    if($sum == 0) $ret = true;\n  }\n  return $ret;\n\
    }\n", "  sort($l);\n  $sum = 0;\n  foreach ($l as $v) {\n    $sum += $v;\n   \
    \ if ($sum < 0) return false;\n  }\n  return $sum == 0;\n}\n", "  if(empty($l))\
    \ return false;\n  $s = array_count_values($l);\n  foreach($s as $i => $v) if($v\
    \ > 1) return true;\n  foreach($s as $i => $v) if($v === 1) return false;\n  return\
    \ false;\n}\n", "    $sum = 0;\n    $len = count($l);\n    $i = 0;\n    for($j=0;\
    \ $j < $len; ++$j) {\n        if($l[$j] != 0) {\n            $sum -= $l[$j];\n\
    \        } else {\n            $i++;\n        }\n    }\n    if($i != $len) {\n\
    \        return false;\n    }\n    return $sum == 0;\n}\n", "    // Write your\
    \ code here.\n    $pairs = array_count_values($l);\n    foreach($pairs as $k =>\
    \ $v){\n        if($v > 1){\n            return false;\n        }\n    }\n   \
    \ return true;\n}\n", "  sort($l);\n  sort($l);\n  $a = array_slice($l, 0, -2);\n\
    \  return ($a[0]+$a[1]+$a[2]) == 0;\n}\n", "    $sum = 0;\n    foreach ($l as\
    \ $item) {\n        if ($sum == 0) {\n            $sum = $item;\n        } else\
    \ {\n            $sum -= $item;\n            if ($sum == 0) return false;\n  \
    \      }\n    }\n    return true;\n}\n", "  $n = count($l);\n  $sum = 0;\n  for\
    \ ($i=0; $i<$n; $i++) {\n    $sum += $l[$i];\n  }\n  for ($i=0; $i<$n; $i++) {\n\
    \    $j = $i+1;\n    while (isset($l[$j]) && $l[$j] == $l[$i]) {\n      $j++;\n\
    \    }\n    if ($j == $i+1) {\n      return false;\n    }\n    $l[$i] = $l[$j];\n\
    \    $l[$j] = $sum;\n  }\n  return true;\n}\n", "  $n = count($l);\n  if ($n <\
    \ 2) {\n    return false;\n  }\n  $d = 0;\n  for ($i = 0; $i < $n; ++$i) {\n \
    \   $d += $l[$i];\n  }\n  return $d == 0;\n}", "    $l = sort($l);\n    $sum =\
    \ 0;\n    foreach ($l as $num) {\n        if ($sum == 0) return false;\n     \
    \   if ($sum == $num) return false;\n        $sum += $num;\n    }\n    return\
    \ true;\n}", "    $sum = 0;\n    foreach($l as $i) {\n        if($i == 0) {\n\
    \            continue;\n        }\n        if($sum + $i != 0) {\n            return\
    \ false;\n        }\n        $sum += $i;\n    }\n    return true;\n}\n", "   \
    \ $sum = 0;\n    foreach($l as $k => $v) {\n        if(!$sum) $sum += $v;\n  \
    \      elseif($sum >= 0) $sum -= $v;\n        else return false;\n    }\n    return\
    \ $sum == 0;\n}\n", "    if (!is_array($l)) return false;\n    $n = count($l);\n\
    \    $zeros = array_fill(0, $n, 0);\n    foreach ($l as $n => $value) {\n    \
    \    $zeros[$n] += $value;\n    }\n    foreach ($zeros as $n => $value) {\n  \
    \      if ($value !== 0) return false;\n    }\n    return true;\n}\n", "  $n =\
    \ count($l);\n  for ($i = 0; $i < $n; $i++) {\n    $total = 0;\n    for ($j =\
    \ $i; $j < $n; $j++) {\n      if ($l[$i] - $l[$j] != 0) {\n        $total++;\n\
    \      }\n    }\n    if ($total == 2) {\n      return true;\n    }\n  }\n  return\
    \ false;\n}", "    $count = 0;\n    $n = count($l);\n    foreach ($l as $i =>\
    \ $val) {\n        if ($val > 0) {\n            $count++;\n            if ($val\
    \ != $l[$i+1]) {\n                return false;\n            }\n        }\n  \
    \  }\n    return $count <= 2;\n}\n", "  global $sum_of_pairs;\n  $num_pairs =\
    \ count($l);\n  $sum_of_pairs = 0;\n  $result = true;\n  for ($i = 0; $i < $num_pairs;\
    \ $i++) {\n    $j = $i + 1;\n    if ($j < $num_pairs && $l[$i] + $l[$j] == 0)\
    \ {\n      $sum_of_pairs += $i + $j;\n      $result = false;\n    }\n  }\n  if\
    \ ($sum_of_pairs == $num_pairs) {\n    $result = true;\n  }\n  return $result;\n\
    }\n", "    $sum = $l[0];\n    foreach ($l as $n) {\n        $sum += $n;\n    }\n\
    \    return $sum == 0;\n}", "    $sum = 0;\n    foreach ($l as $e) {\n       \
    \ $sum += $e;\n    }\n    return $sum == 0;\n}\n", "    if (count($l) < 2) {\n\
    \        return FALSE;\n    }\n\n    $first = $l[0];\n    $rest = $l;\n\n    for\
    \ ($i = 1; $i < count($rest); $i++) {\n        $current += $rest[$i];\n      \
    \  if ($current === 0 && !isset($pairs[$first]) && !isset($pairs[$current])) {\n\
    \            return TRUE;\n        }\n    }\n    return FALSE;\n}\n", "    $sum\
    \ = 0;\n    $n = sizeof($l);\n    for ($i = 0; $i < $n; $i++) {\n        $sum\
    \ += $l[$i];\n    }\n    for ($j = $n-1; $j >= 0; $j--) {\n        for ($i = $j;\
    \ $i >= 0; $i--) {\n            if ($l[$i] + $l[$j] == 0) {\n                return\
    \ true;\n            }\n        }\n    }\n    return false;\n}", "  $sum = 0;\n\
    \  $n = count($l);\n  for ($i = 0; $i < $n; $i++) {\n    $sum += $l[$i];\n   \
    \ if ($sum < 0) {\n      return false;\n    }\n  }\n  return true;\n}\n", "  $i\
    \ = 1;\n  $n = 0;\n  $sum = 0;\n  while ($i < count($l)) {\n    if ($sum == 0)\
    \ {\n      $sum = $l[$i];\n    }\n    if ($sum < 0) {\n      return false;\n \
    \   }\n    if ($l[$i] == 0) {\n      $sum = 0;\n    } else {\n      $sum += $l[$i];\n\
    \      $n++;\n    }\n    $i++;\n  }\n  return ($n == 2 && $sum == 0) ? true :\
    \ false;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 tags=php,functional-programming,algorithm\
    \ |>\nIn fact, we can do it with O(n) time complexity with the help of the following\
    \ observation:\n\nThe array is sorted in ascending order\n\nThe first element\
    \ of the array is the smallest one and if we delete it from the array then we\
    \ will end up with an empty array. So in order to see if we have more than one\
    \ element we need to see if we are at the end of the array. If we do then we have\
    \ more than one element and the last one is 0.\nHere is how it looks:\n<code>\n\
    <?php", "    if (sizeof($l) == 0) {\n        return false;\n    }\n    $sum =\
    \ 0;\n    for ($i = 0, $j = sizeof($l) - 1; $i < sizeof($l); $j = $i++) {\n  \
    \      $sum += $l[$i];\n        if ($sum < 0) {\n            $sum = 0;\n     \
    \   }\n    }\n    return $sum == 0;\n}\n", "    $result = true;\n    foreach ($l\
    \ as $n => $val) {\n        if ($n == 0) {\n            continue;\n        }\n\
    \        $result = $result && ($val == 0);\n    }\n    return $result;\n}\n",
  "  $n = count($l);\n  for($i = 0; $i < $n; $i++) {\n    for($j = 0; $j < $n; $j++)\
    \ {\n      $sum = $l[$i] + $l[$j];\n      if ($sum == 0) return false;\n     \
    \ if ($j >= $i) break;\n    }\n  }\n  return true;\n}\n", "    return !array_diff(array_keys($l),\
    \ array_unique(array_map('abs', $l)));\n}\n", "    $s = array_sum($l);\n    foreach($l\
    \ as $k => $v) {\n        if ($v > 0) continue;\n        if ($k == 0) return true;\n\
    \        return ($s == $v);\n    }\n    return false;\n}\n", "  $n = count($l);\n\
    \  for($i = 0; $i < $n-1; ++$i) {\n    $j = $i+1;\n    if($l[$i] + $l[$j] == 0)\
    \ {\n      $l[$i] = 0;\n      $l[$j] = $l[$j];\n      unset($l[$j+1]);\n     \
    \ $i--; $j--;\n      continue;\n    }\n    else if($l[$i] + $l[$j] > 0)\n    \
    \  return false;\n  }\n  return true;\n}\n", "    sort($l);\n    $sum = 0;\n \
    \   for ($i = 0; $i < count($l); $i++) {\n        $sum += $l[$i];\n        if\
    \ ($sum < 0) {\n            return false;\n        }\n    }\n    return true;\n\
    }\n\n$a = [1,2,1,3,4,2];\nvar_dump(pairs_sum_to_zero($a));", "  $a1 = $l[0];\n\
    \  $a2 = $l[1];\n  $b1 = $l[2];\n  $b2 = $l[3];\n\n  $result = 0;\n  for($i =\
    \ $a1; $i <= $a2; $i++) {\n    $result += $i;\n  }\n  if($result == $b1 && $result\
    \ != $b2) {\n    return true;\n  }\n  elseif($result == $b2 && $result != $b1)\
    \ {\n    return true;\n  }\n  elseif($result < $b1 && $result != $b2) {\n    return\
    \ true;\n  }\n  elseif($result > $b2 && $result != $b1) {\n    return true;\n\
    \  }\n  elseif($result > $b1 && $result < $b2) {\n    return false;\n  }\n  elseif($result\
    \ == $b1 && $result == $b2) {\n    return false;\n  }\n}", "    $t = array();\n\
    \    for($i = 0; $i < count($l); $i++) {\n        $t[$l[$i]] = $i;\n    }\n  \
    \  $ret = true;\n    for($i = 0; $i < count($t); $i++) {\n        for($j = count($t);\
    \ $j < count($t); $j++) {\n            if($t[$i] + $t[$j] == 0) {\n          \
    \      $ret = false;\n                break;\n            }\n        }\n    }\n\
    \    return $ret;\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\nI do not think\
    \ there is an algorithm that does this in O(n) but there is a O(n log n) solution:\n\
    <code>\ndef contains_pairs(l):\n  seen = set()\n  return any([seen.add((x,y))\
    \ for x,y in zip(l[:-1], l[1:])]) and seen.add((l[-1], l[0]))\n</code>\nThis sets\
    \ seen.add((l[-1], l[0])) to false when they don't match. Then it adds ((l[-1],\
    \ l[0])) to the set seen (because we already checked for it) and returns True\
    \ if it finds one and False if it doesn't.\n<|/ a tags=language-agnostic,arrays,algorithm\
    \ |>\n<| a tags=language-agnostic,arrays,algorithm |>\nA simple O(n) solution:\
    \ sort your array (O(nlogn)) and then simply check if any two adjacent elements\
    \ differ by more than 1.\n<|/ a dscore=0 |>\n<| c |>\nThis would fail to detect\
    \ array `[1, -1, 1, -1, 3]` (a 3-element array consisting of a pair).\n<|/ c |>\n\
    <| c |>\nThanks for your quick response. Yes, this will not detect pairs because\
    \ this array has 3 elements. But in the question he stated that he needs to find\
    \ pairs only.\n<|/ c |>\n<| c |>\nHmm, I just realized that your solution won't\
    \ work either because your array is sorted. I would have made it a 2-dimensional\
    \ array and used pairs of elements as the index, so I wouldn't have to sort.\n\
    <|/ c |>\n<| c |>\nIt would still be O(nlogn), since you still have to traverse\
    \ the array once to create the indexes.\n<|/ c |>\n<| c |>\nOh, I did not realize\
    \ you were using pairs as indexes. I thought you were using numbers as indexes.\
    \ You probably should have added that to the question then.\n<|/ c |>\n<| a |>\n\
    A simple O(n) solution is to just go through the list ", "    $total = 0; $pairs\
    \ = array();\n    foreach($l as $i => $x) {\n        $total += $x;\n        $pairs[]\
    \ = array('index' => $i, 'value' => $x, 'total' => $total);\n    }\n    $n = count($pairs);\n\
    \    for($i = 0; $i < $n; $i++) {\n        for($j = $i; $j < $n; $j++) {\n   \
    \         if($pairs[$i]['value'] > 0) {\n                if($pairs[$j]['value']\
    \ == 0) {\n                    return false;\n                }\n            \
    \    if($pairs[$i]['value'] + $pairs[$j]['value'] == $pairs[$i]['total']) {\n\
    \                    unset($pairs[$j]);\n                    $n--;\n         \
    \       }\n            }\n        }\n    }\n    return $n == 0;\n}\n", "    $sum\
    \ = 0;\n    foreach ($l as $value) {\n        $sum += $value;\n    }\n    return\
    \ $sum < 0;\n}\n</code>\n<|/ a tags=php dscore=0 |>\n<| c |>\nThis is really unnecessarily\
    \ complicated. Why not just `array_reduce()`?\n<|/ c |>\n<| c |>\nYeah, I don't\
    \ believe there is an elegant way to do this in one fell swoop.\n<|/ c |>\n<|\
    \ c |>\nThe thing is, it's pretty easy to write this as a single `for` loop. Unless\
    \ you've got a better solution, I'm going to stick with this one.\n<|/ c |>\n\
    <| a |>\nA slight variant on answer:\n<code>", "    $count = 0;\n    $pairs =\
    \ array();\n    foreach ($l as $key => $value)\n    {\n        $pairs[] = array($key,\
    \ $value);\n        if ($value == 0) {\n            $count++;\n        }\n   \
    \ }\n\n    if ($count == count($l)) {\n        return true;\n    } else {\n  \
    \      return false;\n    }\n}\n", "  return count($l) === count(array_unique($l))\
    \ &&\n      array_sum($l) === 0;\n}\n", "  return count(array_unique(array_map('abs',\
    \ $l))) == 2;\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis would work only if\
    \ the array values are all positive. If there are negative values this will cause\
    \ false positives.\n<|/ c |>\n<| c |>\nIf this is true, and I need a solution\
    \ that works in all cases, I'd have to create a separate function and loop through\
    \ the array twice, adding each value to the sum, then subtract each value from\
    \ the sum. As far as I can tell, this would work but would be a lot slower than\
    \ the function I provided.\n<|/ c |>\n<| c |>\n, if the array values are all positive,\
    \ `array_sum()` will work as well. If the values are all negative, `array_diff()`\
    \ will do the job.\n<|/ c |>\n<| c |>\n, good point - you're absolutely right\
    \ that `array_diff()` will do the job here. I've updated my answer to reflect\
    \ this and also added another `array_reduce()` solution to my answer, which I\
    \ think may be the fastest way to implement this solution.\n<|/ c |>\n<| c |>\n\
    , just curious, what is the time complexity of `array_diff()` in this case?\n\
    <|/ c |>\n<| a tags=php,algorithm |>\nHere is my solution which avoids recursion\
    \ and uses array_reduce():\n<code>", "  $sum = 0;\n  $len = count($l);\n  for($i\
    \ = 0; $i < $len; $i++)\n  {\n    $sum += $l[$i];\n  }\n  return ($sum == 0);\n\
    }\n</code>\n<|/ a tags=php,algorithm |>\n<| c |>\nThis is not what OP asked, he\
    \ just wanted to check how many times any element is in the array.\n<|/ c |>\n\
    <| c |>\nIt's not really an O(n) solution. I don't think you can do it with an\
    \ O(1) space.\n<|/ c |>\n<| c |>\nHow about O(n) space - see my solution?\n<|/\
    \ c |>\n<| c |>\nYes, I posted an O(n) solution in the same time.\n<|/ c |>\n\
    <| c |>\nHow about O(1) space? O(1), O(1), O(1), O(1)... O(1)... O(1)\n<|/ c |>\n\
    <| a tags=php,algorithm |>\nO(n) time and O(1) space\nThis solution has O(n) time\
    \ and O(1) space. It uses a hash table to keep track of each unique element and\
    \ how many times it occurs in the list.\nThe algorithm works by counting the number\
    \ of elements in the list that sum to zero and then storing each unique element\
    \ that sums to zero in a hash table. Each time the hash table has a key that sums\
    \ to zero it increases the counter in the hash table by 1. As soon as this happens,\
    \ it means that any key that has a value less than or equal to one means all the\
    \ other elements already sum to zero.\nThis algorithm is O(n) time because the\
    \ hash table is resized each time it has a unique element that sums to zero.\n\
    <code>\n<?php\n\n$input = array(1,3,5,7,1,9,-5,3,5,-3,-5,2,4,3,7,-6,1,9,5,0,-9,-3,5,-7,2,1,9,4,2,7,-7,5,5,-6,1,3,5,7,-1,1,8,9,-7,1,4,-4,1,8,1,5,3,0,6,5,5,6,3,9,2,4,-6,4,8,8,7,2,-9,-3,-7,-1,6,8,8,4,6,-5,2,7,-3,-9,6,7,-3,-7,8,7,8,7,-7,6,8,-9,3,6,-9,-7,8,-9,3,6,8,4,-6,5,3,9,-4,9,-6,7,4,-7,8,7,5,-7,2,8,-7,6,7,-9,8,-9,-6,-4,-7,4,-9,-7,3,-9,6,-",
  "    $sum = 0;\n    $n = 0;\n    $pairs = array();\n    foreach ($l as $item) {\n\
    \        $sum -= $item;\n        if ($sum < 0) {\n            $pairs[] = [$n,\
    \ $item];\n            $sum = 0;\n            $n++;\n        } else {\n      \
    \      $sum += $item;\n        }\n    }\n    return $n != 1;\n}\n</code>\n<|/\
    \ a dscore=0 |>\n<| c |>\nI thought I did this before, but now I see that this\
    \ is only valid for `$l <= 0`. So I edited it but I think this is not the best\
    \ solution...\n<|/ c |>\n<| c |>\nThis approach is not correct in all cases: pairs\
    \ can have negative values inside: it happens that `(2, 3)` sums to zero but `(1,\
    \ 3)` does not.\n<|/ c |>\n<| a dscore=0 |>\n<code>\n<?php", "  foreach ($l as\
    \ $i => $value) {\n    foreach ($l as $j => $value) {\n      if ($i != $j && $j\
    \ - $value == $value - $l[$i]) {\n        return false;\n      }\n    }\n  }\n\
    \  return true;\n}\n$input = array(1, 3, 5, 0);\nif (pairs_sum_to_zero($input))\
    \ {\n  echo \"true\\n\";\n} else {\n  echo \"false\\n\";\n}", "  $pairs = array();\n\
    \  $sum = 0;\n  foreach ($l as $value) {\n    if ($value < 0) {\n      $pairs[]\
    \ = array($value, -$value);\n      $sum += $value;\n    }\n    else {\n      $pairs[]\
    \ = array($value, $value);\n      $sum += $value;\n    }\n  }\n  for ($i = 0;\
    \ $i < count($pairs); $i += 2) {\n    if ($pairs[$i][0] + $pairs[$i][1] != $sum)\
    \ {\n      return false;\n    }\n  }\n  return true;\n}\n\n", "    $sum = 0;\n\
    \    foreach ($l as $i) {\n        $sum += $i;\n        if ($sum == 0) return\
    \ true;\n    }\n    return false;\n}\n", "  // This can be done in one line, as\
    \ shown below\n  //return (array_keys($l) == array_keys(array_filter(array_count_values($l))));\n\
    \n  // Let's rewrite this a bit. First, we will get all the keys of $l\n  // that\
    \ have a nonzero count in the array $l. We will then compare\n  // these keys\
    \ with all the keys in $l that have nonzero counts in\n  // $l. Finally, we will\
    \ check if these two sets are identical.\n  // We return the result of the above\
    \ check as our output.\n  $keys = array_keys(array_filter(array_count_values($l)));\n\
    \  return array_intersect($keys, $keys) == $keys;\n}\n", "    $c = count($l);\n\
    \    $n = array_sum($l);\n    return $c == $n && $n == 0;\n}", "    $n = 0;\n\
    \    $x = 0;\n    $y = 1;\n    foreach ($l as $k => $v) {\n        if ($v < 0)\
    \ {\n            $n = $v;\n            $x = $k;\n        } elseif ($v > 0) {\n\
    \            $y = $v;\n            $n = $y;\n            $x = $k;\n        }\n\
    \        $n++;\n        if ($n == 2) {\n            if ($x == $y) {\n        \
    \        return true;\n            }\n        }\n    }\n    return false;\n}\n",
  "    // your code here\n    return array_intersect_key($l, array_flip(array_diff_key(array_flip($l),\
    \ array_flip($l)))) == $l;\n}\n", "    if (count($l) === 1) {\n        return\
    \ false;\n    }\n    $n = 0;\n    $nn = count($l);\n    $pairs = array();\n  \
    \  $j = 0;\n    $z = 0;\n    for ($i = 0; $i < $nn; $i++) {\n        for ($k =\
    \ $i; $k < $nn; $k++) {\n            $n += $l[$i];\n            if ($n >= 0) {\n\
    \                $z += $l[$k];\n                if ($z >= 0) {\n             \
    \       $pairs[$j] = array($i, $k);\n                    $j++;\n             \
    \   }\n            }\n        }\n    }\n    return count(array_unique($pairs))\
    \ === $j;\n}", "    $sum = 0;\n    foreach ($l as $elem) {\n        $sum += $elem;\n\
    \    }\n    return $sum == 0;\n}\n</code>\n<|/ a |>\n<| a dscore=4 tags=arrays,php\
    \ |>\nHere's a nice one-liner solution using a simple for loop:\n<code>", "  $a\
    \ = $l[0];\n  foreach ($l as $k => $v) {\n    if ($v < 0)\n      break;\n    if\
    \ ($v != 0) {\n      if ($v != $a)\n        return false;\n    }\n    $a -= $v;\n\
    \  }\n  return true;\n}\n", "  // your code goes here\n  if (is_array($l)) {\n\
    \    // if the array is empty, return false\n    if (count($l) == 0) return false;\n\
    \n    // sort the array in reverse order since we're going backwards\n    sort($l);\n\
    \n    // find the first pair of consecutive elements that sum to zero\n    for\
    \ ($i = 0; $i < count($l); $i++) {\n      for ($j = $i; $j < count($l); $j++)\
    \ {\n        // if the elements of the array don't sum to zero\n        if ($l[$i]\
    \ + $l[$j] != 0) break;\n\n        // if we've found the elements that sum to\
    \ zero, return true\n        if ($i == $j) break;\n      }\n    }\n  }\n  // if\
    \ it gets to here then the array contains one or more pair of elements that sum\
    \ to zero\n  return true;\n}", "    sort($l);\n    $last = $l[0];\n    for ($i\
    \ = 1; $i < count($l); $i++) {\n        $current = $l[$i];\n        if ($current\
    \ - $last != 0) {\n            return false;\n        }\n        $last = $current;\n\
    \    }\n    return true;\n}\n", "  return count($l) === count(array_unique(array_map('array_sum',\
    \ $l)));\n}\n\n/**\n * @task helpers Helpers\n * @brief Perform operations on\
    \ multiple arrays.\n */", "    $len = count($l);\n    $count = 0;\n    for ($i\
    \ = 0; $i < $len; $i++) {\n        $count += $l[$i];\n        $otherCount = 0;\n\
    \        for ($j = $i; $j < $len; $j++) {\n            $otherCount += $l[$j];\n\
    \            if ($count - $otherCount === 0)\n                return true;\n \
    \       }\n    }\n    return false;\n}\n"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
