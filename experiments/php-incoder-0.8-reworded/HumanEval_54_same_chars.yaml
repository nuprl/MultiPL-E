name: HumanEval_54_same_chars
language: php
prompt: "<?php\n// Check if two words have the same characters.\n// >>> same_chars(\"\
  eabcdzzzz\", \"dddzzzzzzzddeddabc\")\n// true\n// >>> same_chars(\"abcd\", \"dddddddabc\"\
  )\n// true\n// >>> same_chars(\"dddddddabc\", \"abcd\")\n// true\n// >>> same_chars(\"\
  eabcd\", \"dddddddabc\")\n// false\n// >>> same_chars(\"abcd\", \"dddddddabce\"\
  )\n// false\n// >>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")\n// false\n\
  function same_chars($s0, $s1) {\n"
tests: "function candidate(...$args) {\n    return same_chars(...$args);\n}\n\nfunction\
  \ test(): void {\n    if (candidate(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\") !== true)\
  \ { throw new Exception(\"Test failed!\"); }\n    if (candidate(\"abcd\", \"dddddddabc\"\
  ) !== true) { throw new Exception(\"Test failed!\"); }\n    if (candidate(\"dddddddabc\"\
  , \"abcd\") !== true) { throw new Exception(\"Test failed!\"); }\n    if (candidate(\"\
  eabcd\", \"dddddddabc\") !== false) { throw new Exception(\"Test failed!\"); }\n\
  \    if (candidate(\"abcd\", \"dddddddabcf\") !== false) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(\"eabcdzzzz\", \"dddzzzzzzzddddabc\") !==\
  \ false) { throw new Exception(\"Test failed!\"); }\n    if (candidate(\"aabb\"\
  , \"aaccc\") !== false) { throw new Exception(\"Test failed!\"); }\n}\n\ntest();"
completions: ["  \n  // If one of the strings is empty return false\n  if (empty($s0)\
    \ || empty($s1)) {\n    return false;\n  }\n  // If the strings are the same return\
    \ true\n  if ($s0 == $s1) {\n    return true;\n  }\n\n  // Count the number of\
    \ characters in the strings\n  $s0_count = strlen($s0);\n  $s1_count = strlen($s1);\n\
    \n  // Loop through each character\n  for ($i = 0; $i < $s0_count && $i < $s1_count;\
    \ $i++) {\n    // If characters don't match return false\n    if ($s0[$i] != $s1[$i])\
    \ {\n      return false;\n    }\n  }\n\n  // If all the characters are the same\
    \ return true\n  return $s0_count == $s1_count;\n}", "  if (strlen($s0) == 0 ||\
    \ strlen($s1) == 0) {\n    return false;\n  }\n  if (strlen($s0) != strlen($s1))\
    \ {\n    return false;\n  }\n  for ($i = 0; $i < strlen($s0); ++$i) {\n    $char\
    \ = mb_substr($s0, $i, 1, UTF_8);\n    if ($char != mb_substr($s1, $i, 1, UTF_8))\
    \ {\n      return false;\n    }\n  }\n  return true;\n}\n", "\t$i0 = 0; // Current\
    \ position of $s0 in $s1\n\t$i1 = 0; // Current position of $s1 in $s0\n\t$j0\
    \ = 0; // Current position of current character in $s0\n\t$j1 = 0; // Current\
    \ position of current character in $s1\n\t$ret  = true;\n\twhile ($i1 < strlen($s1))\
    \ {\n\t\tif ($s0[$i0] != $s1[$i1]) {\n\t\t\t$i1 = $i0;\n\t\t\t$j1 = $j0;\n\t\t\
    \t$ret = false;\n\t\t\tbreak;\n\t\t}\n\t\t$i0++;\n\t\t$j0++;\n\t\t$i1++;\n\t}\n\
    \treturn $ret;\n}\n", "    $s1_length = strlen($s1);\n    $s0_length = strlen($s0);\n\
    \    if ($s1_length < $s0_length) {\n        return true;\n    }\n    for ($i\
    \ = 0; $i < $s0_length; $i++) {\n        if ($s1[$i] != $s0[$i]) {\n         \
    \   return false;\n        }\n    }\n    return true;\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThis algorithm is not 100% correct. An example would be \"abcccdddaaa\"\
    , \"dddddddabccc\". This method returns true, even though the strings aren't the\
    \ same length. It can be fixed by adding another loop to iterate over the shorter\
    \ string and count the characters. I also added a method which returns a Boolean\
    \ and an explanation of the algorithm. Also, in the second loop of the above code,\
    \ the code checks that there are no more letters after a letter from the longer\
    \ string has been found.\n<|/ c |>\n<| a |>\nFor people looking for a Python solution,\
    \ this one works with Python 3.9\n<code>\ndef same_length(s0, s1):\n    # First\
    \ check that the strings have the same number of characters.\n    if int(len(s0))\
    \ < int(len(s1)):\n        return False\n    # Loop through both strings until\
    \ they run out of letters.\n    for i, j in zip(s0, s1):\n        # Check if current\
    \ letter matches with the next letter of the first string.\n        if not i ==\
    \ j:\n            return False\n        # Stop checking letters once the shorter\
    \ string has run out of letters.\n        if int(len(s0)) == i:\n            break\n\
    \    return True\n</code>\n<|/ a tags=string,php,algorithm dscore=4 |>\n<| a |>\n\
    You can try this code:\n<code>\n<?php\n", "    return substr($s0, 0, strlen($s0))\
    \ == substr($s1, 0, strlen($s1));\n}\n", "    if ($s0 === $s1) return true;\n\
    \    if (strlen($s0) != strlen($s1)) return false;\n    $s0 = strtolower($s0);\n\
    \    $s1 = strtolower($s1);\n    for ($i = 0; $i < strlen($s0); $i++) if ($s1[$i]\
    \ != $s0[$i]) return false;\n    return true;\n}\n", "    $len = min(strlen($s0),\
    \ strlen($s1));\n    for ($i = 0; $i < $len; $i++) {\n        if ($s1[$i] != $s0[$i])\
    \ return false;\n    }\n    return true;\n}\n", "    $len = strlen($s0);\n   \
    \ $max_len = max(strlen($s0), strlen($s1));\n    for($i = 0; $i < $len; $i++){\n\
    \        $char = ord(substr($s0, $i, 1)) - ord(substr($s1, 0, 1));\n        $len0\
    \ = strlen($s0);\n        $len1 = strlen($s1);\n        if($len0 >= $len1 && $char\
    \ == 0){\n            continue;\n        }\n        if($len0 == $len1){\n    \
    \        return true;\n        }\n        $char1 = ord(substr($s1, $i, 1)) - ord(substr($s0,\
    \ 1, 1));\n        if($char1 != 0){\n            return false;\n        }\n  \
    \  }\n    return true;\n}\n\n/**\n * \u5224\u65AD\u4E24\u4E2A\u5B57\u7B26\u4E32\
    \u662F\u5426\u76F8\u7B49\uFF0C\u4E00\u5B9A\u957F\u5EA6\n * \n * @param  string\
    \ $s1 \u8981\u6BD4\u8F83\u7684\u5B57\u7B26\u4E321\n * @param  string $s2 \u8981\
    \u6BD4\u8F83\u7684\u5B57\u7B26\u4E322\n * @param  int $len \u957F\u5EA6\n * @return\
    \ bool\n */", "    $count1 = 0;\n    $count2 = 0;\n    for ($i = 0; $i < strlen($s0);\
    \ $i++) {\n        if ($s0[$i] === $s1[$i]) {\n            $count1++;\n      \
    \      $count2++;\n        }\n    }\n    return $count1 === $count2;\n}\n", " \
    \ $s0 = str_replace(array(\"\\r\\n\", \"\\r\"), \"\\n\", $s0);\n  $s1 = str_replace(array(\"\
    \\r\\n\", \"\\r\"), \"\\n\", $s1);\n  for ($i = 0; $i < max(strlen($s0), strlen($s1));\
    \ $i++) {\n    if (ord($s0[$i]) == ord($s1[$i])) {\n      continue;\n    }\n \
    \   if (ord($s0[$i]) < ord($s1[$i])) {\n      return false;\n    }\n    if (ord($s0[$i])\
    \ > ord($s1[$i])) {\n      return true;\n    }\n  }\n  return (strlen($s0) ==\
    \ strlen($s1));\n}", "    $len = max(strlen($s0), strlen($s1));\n    if ($len\
    \ == 0) return true;\n    $diff = strlen($s0) - strlen($s1);\n    if ($diff <\
    \ 0) return false;\n    return ($diff == 0);\n}\n", "    $s0_length = strlen($s0);\n\
    \    $s1_length = strlen($s1);\n\n    if ($s0_length != $s1_length) {\n      \
    \  return false;\n    }\n\n    $j = 0;\n\n    for ($i = 0; $i < $s0_length; $i++)\
    \ {\n        if ($s0[$i] != $s1[$i]) {\n            return false;\n        }\n\
    \        $j++;\n        if ($j >= $s1_length) {\n            return true;\n  \
    \      }\n    }\n\n    return false;\n}\n", "  for($i = 0, $max = min(count($s0),\
    \ count($s1)); $i < $max; ++$i) {\n    if(ord($s0[$i]) !== ord($s1[$i])) return\
    \ false;\n  }\n  return true;\n}\n", "    if (strlen($s0) != strlen($s1)) {\n\
    \        return false;\n    }\n    // Find the same characters in both strings.\n\
    \    $same = [];\n    for ($i = 0; $i < strlen($s0); $i++) {\n        if ($s0[$i]\
    \ == $s1[$i]) {\n            $same[] = $s0[$i];\n        }\n    }\n    return\
    \ empty($same);\n}", "  $i0 = 0; $i1 = 0;\n  while ($i0 < strlen($s0)) {\n   \
    \ if ($s1[$i0] == $s0[$i0]) {\n      $i1++;\n      $i0++;\n    } elseif ($i1 ==\
    \ strlen($s0)) {\n      return true;\n    }\n  }\n  return false;\n}\n", "  //\
    \ Split $s0 into characters $s0_chars starting at $s0_pos.\n  $s0_chars = str_split($s0,\
    \ 1);\n  $s0_pos = 0;\n  $s0_len = strlen($s0);\n\n  // Split $s1 into characters\
    \ $s1_chars starting at $s1_pos.\n  $s1_chars = str_split($s1, 1);\n  $s1_pos\
    \ = 0;\n  $s1_len = strlen($s1);\n\n  // Loop through $s0_chars until we find\
    \ a character in $s1_chars.\n  $same = false;\n  while ($s0_len > 0 && $s1_len\
    \ > 0) {\n    if ($s0_chars[$s0_pos] == $s1_chars[$s1_pos]) {\n      $s0_pos++;\n\
    \      $s1_pos++;\n      $s0_len--;\n      $s1_len--;\n      $same = true;\n \
    \   } else {\n      $s0_pos++;\n      $s1_len--;\n    }\n  }\n\n  return $same;\n\
    }\n", "    // If one of the two strings is empty, or if the characters are not\
    \ the same\n    if (empty($s0) || empty($s1) || !isset($s0[0]) || !isset($s1[0]))\
    \ {\n        return false;\n    }\n\n    // Iterate over the characters of the\
    \ strings\n    for ($i = 0; $i < min(strlen($s0), strlen($s1)); $i++) {\n    \
    \    // If the characters are not equal\n        if ($s1[$i] != $s0[$i]) {\n \
    \           // If there is a difference in length\n            if (strlen($s0)\
    \ < strlen($s1)) {\n                // If it's shorter\n                return\
    \ false;\n            }\n\n            // If it's longer\n            return true;\n\
    \        }\n    }\n\n    // All characters are equal\n    return true;\n}\n",
  "\t$str1 = str_split($s1);\n\t$str2 = str_split($s0);\n\tfor ($i=0; $i < count($str1);\
    \ $i++) {\n\t\tif ($str1[$i] !== $str2[$i]) return false;\n\t}\n\treturn true;\n\
    }\n", "\t$s0  = str_replace(array(\"[\", \"]\"), \"\", preg_replace(\"/[^a-zA-Z]/\"\
    , \"\", $s0));\n\t$s1 = str_replace(array(\"[\", \"]\"), \"\", preg_replace(\"\
    /[^a-zA-Z]/\", \"\", $s1));\n\treturn (ctype_alnum($s0) && ctype_alnum($s1)) &&\
    \ (strlen($s0) == strlen($s1));\n}", "  return is_string($s0) && is_string($s1)\
    \ &&\n         strlen($s0) == strlen($s1) &&\n         strpos($s0, $s1) !== false\
    \ &&\n         strpos($s1, $s0) !== false;\n}\n", "    $c0 = preg_split('//',\
    \ $s0, -1, PREG_SPLIT_NO_EMPTY);\n    $c1 = preg_split('//', $s1, -1, PREG_SPLIT_NO_EMPTY);\n\
    \    if (count($c0) !== count($c1)) {\n        return false;\n    }\n\n    foreach\
    \ ($c1 as $i => $c){\n        if (!array_search($c, $c0)) {\n            return\
    \ false;\n        }\n    }\n\n    return true;\n}\n", "  return preg_match('/(.)\\\
    \\1{' . ($s0 != '' ? strlen($s0) : 0) . ',}/', $s1) === 1;\n}", "  foreach ($s0\
    \ as $c) {\n    if (strpos($s1, $c) !== FALSE) {\n      $s1lenght = strlen($s1);\n\
    \      $s0lenght = strlen($s0);\n      if ($s0lenght > $s1lenght) {\n        if\
    \ (substr($s1, $s0lenght - $s1lenght, 1) === $c) {\n          return TRUE;\n \
    \       }\n      } else {\n        if (substr($s0, $s1lenght - $s0lenght, 1) ===\
    \ $c) {\n          return TRUE;\n        }\n      }\n    }\n  }\n  return FALSE;\n\
    }", "    $a0 = str_split($s0);\n    $a1 = str_split($s1);\n    foreach ($a0 as\
    \ &$a) {\n        $a = $a != $a1[count($a) - 1];\n    }\n    return implode('',\
    \ $a0);\n}\n", "  if (strlen($s0) == 0)\n    return strlen($s1) == 0;\n  if (strlen($s1)\
    \ == 0)\n    return false;\n  return ($s0[0] == $s1[0]);\n}", "  $len0 = strlen($s0);\n\
    \  $len1 = strlen($s1);\n  if ($len0 !== $len1) return false;\n  foreach (str_split($s0)\
    \ as $c0 => $v0) {\n    if (!isset($s1[$c0])) return false;\n  }\n  return true;\n\
    }", "    $s1Len = strlen($s1);\n    $s0Len = strlen($s0);\n    $max = $s0Len >\
    \ $s1Len ? $s0Len : $s1Len;\n    $sameChars = $s0Len > $s1Len;\n    for($i = 0;\
    \ $i < $max; ++$i) {\n        if($sameChars) {\n            $ch0 = $s0[$i];\n\
    \            $ch1 = $s1[$i];\n        } else {\n            $ch0 = $s1[$i];\n\
    \            $ch1 = $s0[$i];\n        }\n        if($ch0 != $ch1) return $sameChars;\n\
    \    }\n    return $sameChars;\n}\n", "    return strlen($s0) == strlen($s1) &&\
    \ strlen($s0) == strlen($s0) &&\n        strpos($s0, $s1) !== false && strpos($s1,\
    \ $s0) !== false;\n}\n", "  $s0 = explode(\" \", $s0);\n  $s1 = explode(\" \"\
    , $s1);\n  $max = max(count($s0), count($s1));\n  for($i = 0; $i < $max; $i++)\
    \ {\n    if($s0[$i] === $s1[$i]) return false;\n  }\n  return true;\n}\n\n$s0\
    \ = \"\";\n$s1 = \"This is a long string with different lengths, not longer than\
    \ 80 characters. Don't worry, the longest string is longer than 80 characters.\
    \ Don't worry, the longest string is longer than 80 characters.\";\n$s2 = \"This\
    \ is a long string with different lengths, not longer than 80 characters. Don't\
    \ worry, the longest string is longer than 80 characters. Don't worry, the longest\
    \ string is longer than 80 characters.\";\n\n$s0 = explode(\" \", $s0);\n$s1 =\
    \ explode(\" \", $s1);\n$s2 = explode(\" \", $s2);\n$max = max(count($s0), count($s1),\
    \ count($s2));\nfor($i = 0; $i < $max; $i++) {\n  if($s0[$i] === $s1[$i] && $s1[$i]\
    \ === $s2[$i]) continue;\n  if($s0[$i] !== $s1[$i] && $s1[$i] !== $s2[$i]) return\
    \ false;\n}\nreturn true;", "    foreach (str_split($s0) as $c) {\n        if\
    \ (array_search($c, $s1) !== false) {\n            return true;\n        }\n \
    \   }\n    return false;\n}", "\t$len0 = strlen($s0);\n\t$len1 = strlen($s1);\n\
    \t// Are they the same length?\n\tif ($len0 != $len1) {\n\t\treturn false;\n\t\
    }\n\t$count = 0;\n\tfor ($i = 0; $i < $len0; $i++) {\n\t\t$c0 = $s0[$i];\n\t\t\
    $c1 = $s1[$i];\n\t\tif ($c0 != $c1) {\n\t\t\t$count++;\n\t\t}\n\t}\n\treturn $count\
    \ == 0;\n}", "  if (strlen($s0) != strlen($s1)) {\n    return false;\n  }\n  for\
    \ ($i = 0; $i < strlen($s0); $i++) {\n    if ($s0[$i] != $s1[$i]) {\n      return\
    \ false;\n    }\n  }\n  return true;\n}\n", "    // O(n^2) but n is expected to\
    \ be small\n    // O(n^2) but n is expected to be small\n    if ($s0 === $s1)\
    \ {\n        return true;\n    }\n    $s0 = str_split($s0);\n    $s1 = str_split($s1);\n\
    \    $chars = array_count_values($s0);\n    $chars = array_diff($chars, array_count_values($s1));\n\
    \    foreach ($chars as $char) {\n        if (($s1[$char] > 1) || ($s0[$char]\
    \ > 1)) {\n            return false;\n        }\n    }\n    return true;\n}\n",
  "    // Check if there are any common chars.\n    if (strlen($s0) > strlen($s1))\
    \ {\n        return false;\n    }\n    $c0 = str_split($s0);\n    $c1 = str_split($s1);\n\
    \    $i = 0;\n    while ($i < count($c0) && $i < count($c1)) {\n        if ($c0[$i]\
    \ == $c1[$i]) {\n            $i++;\n        } else {\n            return false;\n\
    \        }\n    }\n    // If they are the same letters.\n    if ($i < count($c0))\
    \ {\n        return true;\n    }\n    // At least one character in common is different.\n\
    \    return false;\n}\n", "    $len_0 = strlen($s0);\n    $len_1 = strlen($s1);\n\
    \    $same = 0;\n    if ($len_0 == $len_1)\n    {\n        for ($i = 0; $i < $len_0;\
    \ ++$i) {\n            if ($s0[$i] != $s1[$i]) {\n                $same++;\n \
    \               break;\n            }\n        }\n        return $same == $len_0;\n\
    \    }\n    return $len_0 == $len_1;\n}\n", "    $s0 = strtolower($s0);\n    $s1\
    \ = strtolower($s1);\n    \n    if (strlen($s0) > strlen($s1)) {\n        $s1\
    \ = $s0 . $s1;\n        $s0 = $s1;\n    }\n\n    // check letter occurrences\n\
    \    for ($i = 0, $len1 = strlen($s0); $i < $len1; $i++) {\n        $o1 = array_search($s0[$i],\
    \ $s1);\n        if ($o1 === false) {\n            return false;\n        }\n\
    \        for ($j = 0, $len2 = strlen($s1); $j < $len2; $j++) {\n            $o2\
    \ = array_search($s1[$j], $s0);\n            if ($o2 === false) {\n          \
    \      return false;\n            }\n            if ($o1 === $o2) {\n        \
    \        continue;\n            }\n            return $s1[$j] . ' ' . $s0[$i]\
    \ . ' ' . substr($s1, $o1, 1);\n        }\n    }\n\n    return true;\n}\n", " \
    \ if (!is_string($s0) || !is_string($s1) || $s0 === $s1) {\n    return true;\n\
    \  }\n  $s0 = strtolower($s0);\n  $s1 = strtolower($s1);\n  $len0 = strlen($s0);\n\
    \  $len1 = strlen($s1);\n  for ($i = 0; $i < $len0; ++$i) {\n    if ($s1[$i] !=\
    \ $s0[$i]) {\n      return false;\n    }\n  }\n  for ($i = 0; $i < $len1; ++$i)\
    \ {\n    if ($s0[$i] != $s1[$i]) {\n      return false;\n    }\n  }\n  return\
    \ true;\n}\n", "    $s0 = preg_replace('/[^a-z]/', '', $s0);\n    $s1 = preg_replace('/[^a-z]/',\
    \ '', $s1);\n    return count($s0) === strlen($s0) && count($s1) === strlen($s1);\n\
    }\n</code>\n<|/ a dscore=1 tags=php,javascript |>\n<| c |>\n`function same_chars($s0,\
    \ $s1) {\n    $s0 = preg_replace('/[^a-z]/', '', $s0);\n    $s1 = preg_replace('/[^a-z]/',\
    \ '', $s1);\n    return count($s0) === strlen($s0) && count($s1) === strlen($s1);\n\
    }`\n<|/ c |>\n<| c |>\n, that's a little different... it compares the characters\
    \ *in words*. But it doesn't compare the *lengths* of the strings.\n<|/ c |>\n\
    <| a tags=php,javascript |>\n<code>", "    $s0 = $s0 . \"\"; // convert null to\
    \ empty string so we can use strlen()\n    $s1 = $s1 . \"\"; // convert null to\
    \ empty string so we can use strlen()\n    $len = min(strlen($s0), strlen($s1));\n\
    \n    for ($i = 0; $i < $len; $i++) {\n        if ($s1[$i] <> $s0[$i]) return\
    \ false;\n    }\n    return true;\n}\n", "    $n = min(strlen($s0), strlen($s1));\n\
    \    for ($i = 0; $i < $n; ++$i) {\n        if ($s0[$i] != $s1[$i])\n        \
    \    return false;\n    }\n    return true;\n}", "  // Initialize $output with\
    \ $s0.\n  $output = $s0;\n  $len = strlen($s0);\n  // Find the common prefix.\n\
    \  // This is done by iterating through the $s0 string and comparing $s1's characters\n\
    \  // to each character in $s0 until one is a mismatch.\n  $common = 0;\n  for\
    \ ($i = 0; $i < $len; $i++) {\n    if ($s1[$i] != substr($s0, $i, 1)) {\n    \
    \  $common = $i;\n      break;\n    }\n  }\n  // If $common is zero there is nothing\
    \ in common.\n  if ($common === 0) return false;\n  // If there is common prefix\
    \ and $common + 1 is equal to $len that means $s1 is\n  // at least as long as\
    \ the common prefix $s0.\n  if ($common + 1 == $len) return true;\n  // If there\
    \ is common prefix and $common + 2 is greater than $len that means $s1 is\n  //\
    \ longer than the common prefix $s0.\n  if ($common + 2 == $len) return false;\n\
    \  // At this point $common + 3 is greater than $len and the two strings have\
    \ at\n  // least one common prefix and one character in common.\n  // $common\
    \ + 3 > $len && $common + 3 == $len\n  // $common + 3 < $len && $common + 3 ==\
    \ $len\n  // $common + 3 > $len || $common + 3 > $len\n  if ($common + 3 >= $len)\
    \ return false;\n  // If the strings share no characters, they are equal.\n  if\
    \ ($s1[$common] == substr($s0, $common, $len - $common)) return true;\n  // If\
    \ $s1 has a character not in $s0, they are different.\n  if ($s1[$common] != substr($s0,\
    \ $common, $len - $common)) return false;\n  // If the strings share one character,\
    \ they are equal.\n  if ($s1[$common] == substr($s0, $common, 1)) return true;\n\
    \  // If $s1 has a character not in $s0, they are different.\n  if ($s1[$common]\
    \ != substr($s0, $common, 1)) return false;\n  // If all else fails, return false.\n\
    \  return false;\n}", "\t$s0 = strtolower($s0);\n\t$s1 = strtolower($s1);\n\t\
    for ($i = 0; $i < min(strlen($s0), strlen($s1)); $i++)\n\t\tif ($s1[$i] != $s0[$i])\n\
    \t\t\treturn false;\n\treturn true;\n}\n", "  // If s0 and s1 are not of the same\
    \ length, return false\n  if (strlen($s0) > strlen($s1)) {\n    return false;\n\
    \  }\n\n  // Loop through s1 and check to see if the characters are the same\n\
    \  $i = 0;\n  while ($i < strlen($s1)) {\n    // If one character does not match,\
    \ return false\n    if ($s0[$i] != $s1[$i]) {\n      return false;\n    }\n  \
    \  $i++;\n  }\n\n  return true;\n}\n", "  list($a, $b, $c, $d, $e, $f, $g, $h)\
    \ = $s0;\n  list($a, $b, $c, $d, $e, $f, $g, $h) = $s1;\n  $a_length = strlen($a);\n\
    \  $b_length = strlen($b);\n  $c = array_map('ord', array_merge(range(ord('a'),\
    \ ord('z') + 1), range(ord('A'), ord('Z') + 1), range(ord('0'), ord('9') + 1),\
    \ array(chr(0xE0), chr(0x00), chr(0x1F))));\n  $d = array_map('ord', array_merge(range(ord('a'),\
    \ ord('z') + 1), range(ord('A'), ord('Z') + 1), range(ord('0'), ord('9') + 1),\
    \ array(chr(0xE0), chr(0x00), chr(0x1F))));\n  $e_length = strlen($e);\n  $f_length\
    \ = strlen($f);\n  $g_length = strlen($g);\n  $h_length = strlen($h);\n  $a_count\
    \ = count($a);\n  $b_count = count($b);\n  $c_count = count($c);\n  $d_count =\
    \ count($d);\n  $e_count = count($e);\n  $f_count = count($f);\n  $g_count = count($g);\n\
    \  $h_count = count($h);\n  if (($a_length == $b_length) && ($a_length == $c_length)\
    \ && ($a_length == $d_length) && ($a_length == $e_length) && ($a_length == $f_length)\
    \ && ($a_length == $g_length) && ($a_length == $h_length)) {\n    if (($a_count\
    \ == $b_count) && ($a_count == $c_count) && ($a_count == $d_count) && ($a_count\
    \ == $e_count) && ($a_count == $f_count) && ($a_count == $g_count) && ($a_count\
    \ == $h_count)) {\n      return $a == $b;\n    }\n    else {\n      return false;\n\
    \    }\n  }\n  else {\n    return false;\n  }\n}\n</code>\n<|/ a tags=string,comparison,php\
    \ |>\n<| c |>\nHe doesn't actually need the hashes, he just wants to see if two\
    \ strings have the same characters.  So the only thing he needs to do is count\
    \ the number of each character in each string.\n<|/ c |>\n<| c |>\nThis fails\
    \ for `'hello'` and `'hello'`.\n<|/ c |>\n<| c |>\nIf that is what he wants, he\
    \ should probably add some sort of handling to handle that case.  It is not clear\
    \ from the question as to whether the case that he is concerned about is possible\
    \ or not.\n<|/ c |>\n<| c |>", "  // Checks for same characters.\n  $s0 = preg_replace(\"\
    /[^a-zA-Z0-9]/\", \"\", $s0);\n  $s1 = preg_replace(\"/[^a-zA-Z0-9]/\", \"\",\
    \ $s1);\n  return ($s0 === $s1);\n}\n", "    $s0len = strlen($s0);\n    $s1len\
    \ = strlen($s1);\n    $count = 0;\n    for($i = 0; $i < $s0len; $i++) {\n    \
    \    $count = max($count, ord($s0[$i]) - ord($s1[$i]));\n    }\n    return ($s0len\
    \ == $s1len) && ($count <= 0);\n}\n", "\t$s0 = $s0 ? utf8_encode($s0) : '';\n\t\
    $s1 = $s1 ? utf8_encode($s1) : '';\n\t$n0 = mb_strlen($s0);\n\t$n1 = mb_strlen($s1);\n\
    \tif ($n0 != $n1)\n\t\treturn false;\n\tfor ($i = 0; $i < $n0; ++$i) {\n\t\t$c0\
    \ = mb_substr($s0, $i, 1, 'UTF-8');\n\t\t$c1 = mb_substr($s1, $i, 1, 'UTF-8');\n\
    \t\tif ($c0 != $c1)\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "    $len =\
    \ strlen($s0);\n    $len1 = strlen($s1);\n    for($i = 0; $i < $len; $i++)\n \
    \       $s0[$i] = $s0[$i];\n    for($i = 0; $i < $len1; $i++)\n        $s1[$i]\
    \ = $s1[$i];\n    for($i = 0; $i < $len; $i++)\n        for($j = 0; $j < $len1;\
    \ $j++)\n            if ($s0[$i] == $s1[$j])\n                return true;\n \
    \   return false;\n}\n", "    $chars0 = mb_strlen($s0, 'UTF-8');\n    $chars1\
    \ = mb_strlen($s1, 'UTF-8');\n    if ($chars0 > $chars1) return false;\n    if\
    \ ($chars0 == $chars1) return true;\n    for ($i = 0; $i < $chars0; ++$i) {\n\
    \        if (mb_substr($s0, $i, 1, 'UTF-8') != mb_substr($s1, $i, 1, 'UTF-8'))\
    \ return false;\n    }\n    return true;\n}", "    $s0 = preg_replace('/[\\xC0-\\\
    xC6]/u', '', $s0);\n    $s1 = preg_replace('/[\\xC0-\\xC6]/u', '', $s1);\n\n \
    \   return $s0 === $s1;\n}", "    if ($s0 == $s1) return true;\n    if (strlen($s0)\
    \ != strlen($s1)) return false;\n    $n = strlen($s0);\n    for ($i = 0; $i <\
    \ $n; $i++) {\n        if ($s0[$i] != $s1[$i]) return false;\n    }\n    return\
    \ true;\n}\n", "    global $sameChars;\n    $sameChars = false;\n    $len = max(strlen($s0),\
    \ strlen($s1));\n    for ($i = 0; $i < $len; $i++) {\n        if ($s0[$i] != $s1[$i])\
    \ return false;\n    }\n    return true;\n}\n", "  global $word_chars_map, $word_chars_map_rev;\n\
    \  $word_chars_map = $word_chars_map_rev = array();\n  $len = strlen($s0);\n \
    \ for ($i = 0; $i < $len; ++$i) {\n    $s0 = str_pad($s0, $i, chr(0), STR_PAD_RIGHT);\n\
    \    $s1 = str_pad($s1, $i, chr(0), STR_PAD_RIGHT);\n    $word_chars_map[ord($s0[$i])]\
    \ = ord($s1[$i]);\n  }\n  $len = strlen($s0);\n  for ($i = 0; $i < $len; ++$i)\
    \ {\n    if (isset($word_chars_map[ord($s0[$i])])) {\n      unset($word_chars_map[ord($s0[$i])]);\n\
    \      $word_chars_map_rev[ord($s1[$i])] = chr($i);\n      return 1;\n    }\n\
    \  }\n  return 0;\n}\n</code>\n<|/ a |>\n<| c |>\nThis works perfectly for two\
    \ words that don't share characters. However, it seems to fail for strings where\
    \ all the characters are the same except for one or two characters, e.g. \"eeeeeeeeeee\"\
    . Any idea on how to fix this?\n<|/ c |>\n<| a dscore=0 tags=php,algorithm |>\n\
    Here's a solution using array_filter and strtr without recursion:\n<code>\n<?php",
  "    foreach (str_split($s0) as $i => $c) {\n        if (!isset($s1[$i]) || $c !=\
    \ $s1[$i]) {\n            return false;\n        }\n    }\n    return true;\n}",
  "  $l0 = strlen($s0);\n  $l1 = strlen($s1);\n  $len = 0;\n  for ($i = 0; $i < $l0;\
    \ $i++) {\n    if (ord($s0[$i]) != ord($s1[$i])) {\n      $len += 1;\n      if\
    \ ($len == 2) {\n        return true;\n      }\n    }\n  }\n  return $len == 2;\n\
    }\n", "  global $l; // $l is length\n  $d0 = strlen($s0);\n  $d1 = strlen($s1);\n\
    \  $m = min(abs($d0), abs($d1));\n  $i = 0;\n  while ($i < $m) {\n    if ($s1[$i]\
    \ != $s0[$i]) {\n      return false;\n    }\n    $i++;\n  }\n  return $i == $d0;\n\
    }\n", "  if (strlen($s0) != strlen($s1)) {\n    return false;\n  }\n\n  $i = 0;\n\
    \  while ($i < strlen($s0)) {\n    if ($s0[$i] != $s1[$i]) {\n      return false;\n\
    \    }\n    $i++;\n  }\n\n  return true;\n}\n", "  return strlen($s0) == strlen($s1)\n\
    \    && strpos($s0, $s1) === false;\n}\n", "    $s0 = str_replace(\" \", \"\"\
    , $s0);\n    $s1 = str_replace(\" \", \"\", $s1);\n    if (strlen($s0) == strlen($s1))\
    \ {\n        $result = 0;\n        for ($i = 0; $i < strlen($s0); $i++) {\n  \
    \          $result |= ord($s0[$i]) ^ ord($s1[$i]);\n        }\n        return\
    \ ($result === 0);\n    }\n    return false;\n}\n", "  // Count the number of\
    \ characters.\n  $c0 = count($s0);\n  $c1 = count($s1);\n  // Check if both words\
    \ share the same number of characters.\n  if ($c0 == $c1) {\n    return $s0 ==\
    \ $s1;\n  }\n  // Check if at least one of the two words is shorter than the other.\n\
    \  if ($c1 < $c0) {\n    return false;\n  }\n  // Check if all the letters share\
    \ the same number of characters.\n  for ($i = 0; $i < $c0; $i++) {\n    if ($s1[$i]\
    \ != $s0[$i]) {\n      return false;\n    }\n  }\n  // Check if any letter has\
    \ different number of characters.\n  for ($i = 0; $i < $c0; $i++) {\n    if ($s0[$i]\
    \ != $s1[$i]) {\n      return true;\n    }\n  }\n}\n", "\t$a0 = str_split($s0);\n\
    \t$a1 = str_split($s1);\n\tfor ($i = 0; $i < min(count($a0), count($a1)); $i++)\
    \ {\n\t\tif ($a0[$i] != $a1[$i]) return false;\n\t}\n\treturn true;\n}\n", " \
    \   $s0_len = strlen($s0);\n    $s1_len = strlen($s1);\n    if ($s0_len != $s1_len)\n\
    \        return false;\n    $c = $s0;\n    for($i = 0; $i < $s0_len; $i++) {\n\
    \        $c = strchr($c, $s1[$i]);\n        if (!$c)\n            return false;\n\
    \    }\n    return true;\n}\n", "    if ($s0 == '')\n        $s0 = '&nbsp;';\n\
    \    else\n        $s0 = '<nobr style=\"white-space: nowrap\">' . html_entity_decode($s0,\
    \ ENT_QUOTES, 'UTF-8') . '</nobr>';\n\n    if ($s1 == '')\n        $s1 = '&nbsp;';\n\
    \    else\n        $s1 = '<nobr style=\"white-space: nowrap\">' . html_entity_decode($s1,\
    \ ENT_QUOTES, 'UTF-8') . '</nobr>';\n\n    if (strlen($s0) == strlen($s1))\n \
    \       $s0 = str_replace(\"\\n\", '<nobr></nobr>', $s0);\n    else\n        $s0\
    \ = str_replace(\"\\n\", '<nobr style=\"white-space: nowrap\">' . $s0 . '</nobr>',\
    \ $s0);\n        \n    if (strlen($s1) == strlen($s0))\n        $s1 = str_replace(\"\
    \\n\", '<nobr></nobr>', $s1);\n    else\n        $s1 = str_replace(\"\\n\", '<nobr\
    \ style=\"white-space: nowrap\">' . $s1 . '</nobr>', $s1);\n        \n    $s0\
    \ = str_replace(\"\\n\", ' ', $s0);\n    $s1 = str_replace(\"\\n\", ' ', $s1);\n\
    \    \n    return preg_match('/^(.*) (.*)$/', $s0, $m) && preg_match('/^(.*) (.*)$/',\
    \ $s1, $m) && $m[1] === $m[2];\n}\n</code>\n<|/ a tags=html,regex,php |>\n<| a\
    \ tags=html,regex,php dscore=0 |>\nFor anyone who would like to use the answer\
    \ of Pawel. I had to modify it a little bit so that it would work with special\
    \ characters ( \u2116 \xE9 \xE0 \xE8 \xF9 \xEC \xF2 \xF9 \xF2 \xF9 \xF2 \xF9 \xF9\
    \ \xF9 \xF9 \xF2 \xF9 \xF9 \xF9 \xF9 \xF9 \xF9 \xF9 \xF2 \xF9 \xF9 \xF9 \xF9 \xF9\
    \ \xF9 \xF9 \xF9 \xF9 \xF9 \xF9 \xF2 \xF9 \xF9 \xF9 \xF9 \xF9 \xF9 \xF9 \xF9 \xF9\
    \ \xF9 \xF9 \xF9 \xF9 \xF9 \xF9 \xF9 \xF9 \xF9 \xF9 \xF9 \xF9 \xF9 \xF9 \xF9 \xF9",
  "    $s0len = strlen($s0);\n    $s1len = strlen($s1);\n\n    $samechars = $s0len\
    \ == $s1len;\n\n    $s0chars = 0;\n    $s1chars = 0;\n\n    for ($i = 0; $i <\
    \ $s0len; $i++)\n        if ($s1[$i] == $s0[$i])\n            $s0chars++;\n  \
    \      else\n            $samechars = false;\n\n    for ($i = 0; $i < $s1len;\
    \ $i++)\n        if ($s0[$i] == $s1[$i])\n            $s1chars++;\n        else\n\
    \            $samechars = false;\n\n    return $samechars && $s0chars == $s1chars;\n\
    }\n</code>\n<|/ a tags=php,algorithm,sorting,arrays |>\n<| c |>\nNice, but I suspect\
    \ the OP wants to compare strings with each other, not arrays.\n<|/ c |>\n<| c\
    \ |>\nWhat if these two strings contain non-ASCII characters? Your solution would\
    \ not work with them.\n<|/ c |>\n<| c |>\n: Good point. It wouldn't be difficult\
    \ to modify it to handle non-ASCII characters, though.\n<|/ c |>\n<| c |>\nI'm\
    \ guessing the OP would still have to worry about character encodings though,\
    \ right?\n<|/ c |>\n<| c |>\n: I don't know. I don't use PHP, so I wouldn't know.\
    \ In C or C++, I would just use the `strcmp()` function, but I haven't used PHP\
    \ for too long...\n<|/ c |>\n<| a tags=php,algorithm,sorting,arrays dscore=5 |>\n\
    For completeness sake: this is an interesting problem and I've found a lot of\
    \ interesting solutions so far.\nThere are several solutions proposed here which\
    \ are basically the same but are much better explained.\nHowever I've found a\
    \ small niggle in some of them. One of these solutions was given above by Chris\
    \ Martin. However this solution has the drawback that you cannot use any other\
    \ function except for strcmp on the array elements. So instead of comparing two\
    \ strings using strcmp you can use any algorithm you want.\nSo instead of:\n<code>\n\
    <?php\nif ( strcmp($a, $b) < 0 ) {\n    //\n}", "  return preg_match('/'.preg_quote($s0,\
    \ '/').'/',\n                    preg_replace('/'.preg_quote($s1, '/').'/', '',\
    \ 1));\n}\n</code>\n<|/ a tags=php,string |>\n<| a tags=php,string |>\nFor checking\
    \ whether two strings are the same or not, you should use strcmp function. It's\
    \ return 0 if two strings are same, else return 1. \n<code>\n<?php\nif (strcmp($s1,\
    \ $s2) == 0) {\n echo \"same\";\n} else {\n echo \"different\";\n}", "    $s1_len\
    \ = strlen($s1);\n    $s0_len = strlen($s0);\n    $maxlen = 0;\n\n    for($i =\
    \ 0; $i < $s1_len; $i++) {\n        $s1[$i] = str_pad($s1[$i], $s0_len, \"\\0\"\
    );\n    }\n\n    for($i = 0; $i < $s0_len; $i++) {\n        $maxlen = max($maxlen,\
    \ strlen($s1[$i]));\n    }\n\n    for($i = 0; $i < $s0_len; $i++) {\n        if($s1[$i]\
    \ !== $s0[$i]) {\n            return false;\n        }\n    }\n\n    return true;\n\
    }\n", "  return preg_match(\"/(.)\\1/\", $s0) == preg_match(\"/(.)\\1/\", $s1);\n\
    }\n", "    $chars = str_split($s0);\n    $chars2 = str_split($s1);\n    $n = min(count($chars),\
    \ count($chars2));\n    for ($i = 0; $i < $n; $i++) {\n        if ( $chars[$i]\
    \ != $chars2[$i] ) return false;\n    }\n    return true;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=php,arrays,sorting |>\nThe function str_split() can be used to\
    \ split a string into an array by one character into an array of strings. \nIn\
    \ your case you can then simply use the sort() function on the array to sort the\
    \ strings in ascending order.\n<code>\n<?php\n$s = \"abcde\";\n$arr = str_split($s);\n\
    \nsort($arr);\nprint_r($arr);\n</code>\n<|/ a dscore=1 |>\n<| a tags=php,arrays,sorting\
    \ |>\nI suggest the following function which first checks that the two arrays\
    \ are of equal size, then compares them character by character. If they don't\
    \ match, false is returned and the script exits. If they do match, the array is\
    \ re-indexed and sorted so that all the letters are in alphabetical order.\n<code>",
  "    if ($s0 === $s1) return true;\n    $s1_length = strlen($s1);\n    $s0_length\
    \ = strlen($s0);\n    for ($i = 0; $i < $s1_length; ++$i) {\n        if ($s1[$i]\
    \ !== $s0[$i]) return false;\n    }\n    return true;\n}\n", "    if (strlen($s0)\
    \ == 0 || strlen($s1) == 0) {\n        return false;\n    }\n\n    // Convert\
    \ the strings to lowercase so we don't have to worry about case differences\n\
    \    $s0 = strtolower($s0);\n    $s1 = strtolower($s1);\n\n    // Check if each\
    \ character of the first string is the same as the first\n    // character of\
    \ the second string\n    for ($i = 0; $i < strlen($s0); $i++) {\n        if ($s1[$i]\
    \ != $s0[$i]) {\n            return false;\n        }\n    }\n\n    // Check if\
    \ the strings match up to the length of the shortest one\n    $len = (strlen($s0)\
    \ < strlen($s1)) ? strlen($s0) : strlen($s1);\n    if (strlen($s0) == $len) {\n\
    \        return true;\n    } else {\n        return false;\n    }\n}", "\t$c0\
    \ = array_count_values(str_split($s0));\n\t$c1 = array_count_values(str_split($s1));\n\
    \treturn array_diff_key($c0, $c1) == array_diff_key($c1, $c0);\n}\n", "  // If\
    \ one of the two word is empty, then return false.\n  if (strlen($s0) == 0 ||\
    \ strlen($s1) == 0) return false;\n  // Initialize $s0_length as the number of\
    \ characters in s0.\n  $s0_length = strlen($s0);\n  // Initialize $s1_length as\
    \ the number of characters in s1.\n  $s1_length = strlen($s1);\n  // Compare s0\
    \ and s1 character by character.\n  for ($i = 0; $i < $s0_length; $i++) {\n  \
    \  if ($s0[$i] != $s1[$i]) return false;\n  }\n  // If s0 and s1 length are same,\
    \ then return true.\n  return $s0_length == $s1_length;\n}\n", "    return substr_count($s0,\
    \ $s1) === substr_count($s1, $s0);\n}\n", "  if ($s0 === $s1) {\n    return true;\n\
    \  }\n  $len0 = strlen($s0);\n  $len1 = strlen($s1);\n  if ($len0 !== $len1) {\n\
    \    return false;\n  }\n  $count1 = 0; $count2 = 0;\n  for ($i = 0; $i < $len0;\
    \ $i++) {\n    $char0 = $s0[$i];\n    $char1 = $s1[$i];\n    if ($char0 === $char1)\
    \ {\n      $count1++;\n    } else {\n      if ($count1 > 0) {\n        return\
    \ false;\n      }\n      $count1 = $count2 = 0;\n    }\n  }\n  return true;\n\
    }\n", "    if (strlen($s0) == 0 || strlen($s1) == 0) return false;\n    $s0 =\
    \ strtolower($s0);\n    $s1 = strtolower($s1);\n    $n = strlen($s0);\n    $m\
    \ = strlen($s1);\n    if ($n == $m && ($n == 1 || $m == 1)) return true;\n   \
    \ if ($n == $m) return false;\n    $i = 0;\n    $j = 0;\n    $k = 0;\n    while\
    \ ($i < $n && $j < $m) {\n        if ($s1[$j] == $s0[$i]) $i++;\n        elseif\
    \ ($s0[$i] == '-' && $j == $n - 1) return false;\n        elseif ($s1[$j] == $s0[$i])\
    \ $j++;\n        else return false;\n        $k++;\n    }\n    return $i == $n;\n\
    }\n</code>\n<|/ a tags=php,string,compare |>\n<| c |>\nI think this fails when\
    \ the string has two words with different numbers of characters. \"The quick brown\
    \ fox jumps over the lazy dog\" will return a false, but \"The quick brown fox\
    \ jumps over the lazy dog lazy\" will return a true.\n<|/ c |>\n<| c |>\nYou are\
    \ right. I just added the code for the case when two words have different number\
    \ of characters and edited the original code to handle words with different number\
    \ of characters. I also added the case when two strings are equal\n<|/ c |>\n\
    <| c |>\nThe code you added doesn't work if the strings are equal, because you\
    \ do something like if ($s1[$i] == $s0[$i]) {\n    $i++;\n    $j++;\n  } else\
    \ {\n    return false;\n  }.\n<|/ c |>\n<| a dscore=1 |>\nI haven't tested this,\
    \ but I believe this should work fine:\n<code>", "    if (strlen($s0) > strlen($s1))\
    \ {\n        return false;\n    }\n    // Same length\n    if (strlen($s0) ==\
    \ strlen($s1)) {\n        $result = true;\n        for ($i = 0; $i < strlen($s0);\
    \ $i++) {\n            // Not equal\n            if ($s0[$i] != $s1[$i]) {\n \
    \               $result = false;\n            }\n        }\n        return $result;\n\
    \    }\n    return false;\n}", "    return preg_match('/^(.)\\1{2,}$/', $s0) &&\
    \ preg_match('/^(.)\\1{2,}$/', $s1) && preg_match('/^(.)\\1{2,}$/', $s0);\n}\n",
  "    // Check for equality using strcmp().\n    return strcmp($s0, $s1) === 0;\n\
    }\n", "    $n0 = count($s0);\n    $n1 = count($s1);\n    if ($n0 != $n1)\n   \
    \     return false;\n    for ($i = 0; $i < $n0; ++$i) {\n        if ($s0[$i] !=\
    \ $s1[$i])\n            return false;\n    }\n    return true;\n}\n", "    $s0\
    \ = (string) $s0;\n    $s1 = (string) $s1;\n\n    $l = min(strlen($s0), strlen($s1));\n\
    \n    for ($i = 0; $i < $l; $i++) {\n        if ($s1[$i] != $s0[$i]) return false;\n\
    \    }\n\n    return true;\n}\n", "  // Check if the characters are the same.\n\
    \  // >>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")\n  // True\n  // >>>\
    \ same_chars(\"abcd\", \"dddddddabc\")\n  // True\n  // >>> same_chars(\"dddddddabc\"\
    , \"abcd\")\n  // True\n  // >>> same_chars(\"eabcd\", \"dddddddabc\")\n  // False\n\
    \  // >>> same_chars(\"abcd\", \"dddddddabce\")\n  // False\n  // >>> same_chars(\"\
    eabcdzzzz\", \"dddzzzzzzzddddabc\")\n  // False\n\n  // Create a table of characters\
    \ to compare against.\n  // >>> table = dict([(\"e\",0),(\"abcd\",1),(\"z\",2),(\"\
    zzzz\",3)])\n  // >>> table[\"e\"]\n  // 0\n  // >>> table[\"z\"]\n  // 2\n  //\
    \ >>> table[\"d\"]\n  // 1\n  // >>> table[\"abcd\"]\n  // 0\n  // >>> table[\"\
    zz\"]\n  // 3\n  // >>> table[\"zzz\"]\n  // 2\n  // >>> table.keys()\n  // ['eabcdzzzz',\
    \ 'abcd', 'zzzz', 'zzz']\n\n  // Create tables of chars to compare against.\n\
    \  $table0 = dict([($s0, 0),($s1 ,1)]);\n  $table1 = dict([($s0, 0),($s1 ,1)]);\n\
    \n  // Compare each char in the first string.\n  // >>> table0[\"e\"]\n  // 0\n\
    \  // >>> table0[\"z\"]\n  // 1\n  // >>> table0[\"d\"]\n  // 1\n  // >>> table0[\"\
    abcd\"]\n  // 0\n  // >>> table0[\"zz\"]\n  // 1\n  // >>> table0[\"zzz\"]\n \
    \ // 1\n  // >>> table0.keys()\n  // ['eabcdzzzz', 'abcd', 'zzzz', 'zzz']\n\n\
    \  // Compare each char in the second string.\n  // >>> table1[\"e\"]\n  // 0\n\
    \  // >>> table1[\"z\"]\n  // 1\n  // >>> table1[\"d\"]\n  // 1\n  // >>> table1[\"\
    abcd\"]\n  // 0\n  // >>> table1[\"zz\"]\n  // 1\n  // >>> table1[\"zzz\"]\n \
    \ // 1\n  // >>> table1.keys()\n  // ['eabcdzzzz', 'abcd', 'zzzz', 'zzz']\n\n\
    \  // For each character in both strings.\n  foreach($table0 as $k => $v) {\n\
    \    $table1[$k] = 0;\n    foreach($table1 as $k2 => $v2) {\n      if ($v == $",
  "    if ($s0 == $s1) {\n        return true;\n    }\n    $len = strlen($s0);\n \
    \   $len1 = strlen($s1);\n    if ($len == $len1) {\n        for ($i = 0; $i <\
    \ $len; $i++) {\n            if ($s1[$i] != $s0[$i]) {\n                return\
    \ false;\n            }\n        }\n        return true;\n    }\n    return false;\n\
    }\n\n$a = \"eabcdzzzzz\";\n$b = \"dddddddabce\";\n$c = $a;\nif (same_chars($a,\
    \ $b)) {\n    print(\"$a is the same as $b\");\n} else {\n    print(\"$a is not\
    \ the same as $b\");\n}\n\n$a = \"abcd\";\n$b = \"dddddddabc\";\n$c = $a;\nif\
    \ (same_chars($a, $b)) {\n    print(\"$a is the same as $b\");\n} else {\n   \
    \ print(\"$a is not the same as $b\");\n}\n\n$a = \"eabcd\";\n$b = \"dddddddabc\"\
    ;\n$c = $a;\nif (same_chars($a, $b)) {\n    print(\"$a is the same as $b\");\n\
    } else {\n    print(\"$a is not the same as $b\");\n}\n\n$a = \"abcd\";\n$b =\
    \ \"dddddddabce\";\n$c = $a;\nif (same_chars($a, $b)) {\n    print(\"$a is the\
    \ same as $b\");\n} else {\n    print(\"$a is not the same as $b\");\n}\n\n$a\
    \ = \"eabcdzzzzz\";\n$b = \"dddzzzzzzzddeddabc\";\n$c = $a;\nif (same_chars($a,\
    \ $b)) {\n    print(\"$a is the same as $b\");\n} else {\n    print(\"$a is not\
    \ the same as $b\");\n}\n\n$a = \"abcd\";\n$b = \"dddddddabce\";\n$c = $a;\nif\
    \ (same_chars($a, $b)) {\n    print(\"$a is the same as $b\");\n} else {\n   \
    \ print(\"$a is not the same as $b\");\n}\n\n$a = \"eabcdzzzzz\";\n$b = \"dddzzzzzzzddeddabc\"\
    ;\n$c = $a;\nif (same_chars($a, $b)) {\n    print(\"$a is the same as $b\");\n\
    } else {\n    print(\"$a is not the same as $b\");\n}\n\n$a = \"abcd\";\n$b =\
    \ \"dddddddabce\";\n$c = $a;\nif (same_chars($a, $b)) {\n    print(\"$a is the\
    \ same as $b\");\n} else {\n    print(\"$a is not the same as $b\");\n}\n\n$a\
    \ = \"eabcd\";\n$b = \"dddddddabce\";\n$c = $a;\nif (same_chars($a, $b)) {\n \
    \   print(\"$a is the same as $b\");\n} else {\n", "    return !strlen($s0) &&\
    \ !strlen($s1) || !strlen($s0) && strlen($s1)\n    ||\n    strlen($s0) && strlen($s1)\n\
    \    && strpos($s0, $s1) === false;\n}", "  if (strlen($s0) != strlen($s1)) {\n\
    \    return false;\n  }\n\n  for ($i = 0; $i < strlen($s0); $i++) {\n    if ($s0[$i]\
    \ != $s1[$i]) {\n      return false;\n    }\n  }\n  return true;\n}\n", "    $s1\
    \ = strtolower($s1);\n    $s0 = strtolower($s0);\n    $m = str_word_count($s0);\n\
    \    $n = str_word_count($s1);\n    $same = str_word_count($s0, 1) === $m;\n \
    \   if ($same && $m === $n) {\n        return true;\n    }\n    for ($i = 0; $i\
    \ < $m; $i++) {\n        $j = $i + 1;\n        $same2 = $s1[$i] === $s0[$j];\n\
    \        if ($same2) {\n            if ($i < $n - 1) {\n                $same2\
    \ = $s0[$j] === $s1[$i + 1];\n            }\n        }\n        $same = $same\
    \ && $same2;\n    }\n    return $same;\n}", "    for($i = 0; $i < min(strlen($s0),\
    \ strlen($s1)); $i++) {\n        if($s1[$i] != $s0[$i]) return false;\n    }\n\
    \    return true;\n}\n", "    return preg_match('/[^'.preg_quote($s0).'\\s]/',\
    \ $s1) === preg_match('/[^'.preg_quote($s0).'\\s]/', $s0);\n}", "\tif (strlen($s0)\
    \ > strlen($s1)) {\n\t\t$s0 = substr($s0, 1, strlen($s0));\n\t} else {\n\t\t$s1\
    \ = substr($s1, 0, strlen($s1));\n\t}\n\t$len = strlen($s0);\n\tfor ($i = 0; $i\
    \ < $len; $i++) {\n\t\tif ($s1[$i] != $s0[$i]) {\n\t\t\treturn false;\n\t\t}\n\
    \t}\n\treturn true;\n}\n", "    return (strlen($s0) == strlen($s1) &&\n      \
    \  implode('', array_map('ord', str_split($s0)) == implode('', array_map('ord',\
    \ str_split($s1)))));\n}", "    if ($s0 == $s1)\n        return true;\n    if\
    \ (strlen($s0) != strlen($s1))\n        return false;\n    $s1_len = strlen($s1);\n\
    \    $j = 0;\n    for ($i = 0; $i < $s1_len; ++$i) {\n        if (ord($s1[$i])\
    \ != ord($s0[$i]))\n            return false;\n        if (++$j >= 2)\n      \
    \      return true;\n    }\n    return false;\n}", "    $len = min(strlen($s0),\
    \ strlen($s1));\n    for ($i = 0; $i < $len; $i++) {\n        $char0 = ord($s0{$i});\n\
    \        $char1 = ord($s1{$i});\n        if ($char0 !== $char1) {\n          \
    \  return false;\n        }\n    }\n    return true;\n}\n", "    $s0 = preg_replace('/[^a-z]/',\
    \ '', $s0);\n    $s1 = preg_replace('/[^a-z]/', '', $s1);\n    if (strlen($s0)\
    \ == strlen($s1)) {\n        return strlen($s0) == strlen(preg_replace('/[^a-z]/i',\
    \ '', $s1 . substr($s0, 1)));\n    }\n    return false;\n}\n", "  if (!is_string($s0)\
    \ || !is_string($s1) || strlen($s0) != strlen($s1)) return false;\n\n  $s0 = strtolower($s0);\n\
    \  $s1 = strtolower($s1);\n\n  for ($i = 0; $i < strlen($s0); $i++) if ($s1[$i]\
    \ != $s0[$i]) return false;\n\n  return true;\n}\n</code>\n<|/ a dscore=4 |>\n\
    <| c |>\nThis is a great solution, and I love the explanation of why it works.\
    \  I tested it on PHP 5.5.9, 7.2.8 and 7.3.7 and it worked flawlessly in all of\
    \ them.  It even works when one of the strings has zeros in it.\n<|/ c |>\n<|\
    \ c |>\nThis is great and solved my problem also. However I don't understand why\
    \ this works: `$s0 = strtolower($s0);` I guess it works because it is casting\
    \ the string to lower case first before the `is_same` function is evaluated. I\
    \ thought it would have to be done before the `is_same` function.\n<|/ c |>\n\
    <| c |>\nHi, welcome to Stack Overflow. Your question was answered here: https://stackoverflow.com/questions/4866059/str-to-lower-string-without-converting-all-characters-in-string/4870477#4870477\n\
    <|/ c |>\n<| a |>\n<code>\n$search = strtolower($search);\n$search = preg_replace('/[^a-zA-Z0-9-]/',\
    \ '', $search);\n$search = preg_replace('/[^a-z0-9]/', '', $search);\n\nreturn\
    \ $search;\n</code>\n<|/ a dscore=4 tags=php,string |>\n<| c |>\nThis is exactly\
    \ what I needed, but with a few small changes. I needed to use '-' instead of\
    \ '_' to allow dashes in the search string, and to allow the search to be more\
    \ general by using 'a-z' instead of just '0-9'. Also, it should be `preg_replace('/[^a-z0-9-]+/',\
    \ '', $search);` because dashes aren't in the range of alphanumerics. Other than\
    \ that, I was able to use this and successfully do my search on any combination\
    \ of words in the search string.\n<|/ c |>\n<| c |>\nWhat is the `+` doing there?\n\
    <|/ c |>\n<| c |>\nIt makes the previous pattern match one or more occurrences\
    \ of the previous pattern. From the documentation: `+ (one or more times)`.\n\
    <|/ c |>\n<| c |>\nThis answer is missing its educational explanation.\n<|/ c\
    \ |>\n", "    $s01 = strlen($s0) === strlen($s1);\n    if ($s01) {\n        for\
    \ ($i = 0; $i < strlen($s0); ++$i) {\n            if ($s0[$i] !== $s1[$i]) return\
    \ false;\n        }\n        return true;\n    }\n    return false;\n}\n", " \
    \   if (!is_string($s0) || $s0 === \"\" || !is_string($s1) || $s1 === \"\")\n\
    \        return false;\n    $s0 = strtolower($s0);\n    $s1 = strtolower($s1);\n\
    \    if (preg_match('/(.)\\1{2,}/', $s1) || preg_match('/(.)\\1{2,}/', $s0))\n\
    \        return false;\n    return preg_match('/(.)\\1{2,}/', $s0);\n}\n", " \
    \ if (strlen($s0) == 0)\n    return true;\n  if (strlen($s1) != strlen($s0))\n\
    \    return false;\n  $len = 0;\n  $s0 = strtolower($s0);\n  do {\n    $s1 .=\
    \ $s0;\n    $len++;\n  } while ($s1 == strtolower($s1));\n  return $len == strlen($s0);\n\
    }\n\n/**\n * Find a common set of characters between two strings.\n *\n * We assume\
    \ that there are at least two strings to compare.\n */", "    $n = min(strlen($s0),\
    \ strlen($s1));\n    for($i=0; $i<$n; ++$i) {\n        if($s0 [$i] != $s1 [$i])\n\
    \            return false;\n    }\n    return true;\n}", "  if (strlen($s0) ==\
    \ 0) return strlen($s1) == 0;\n  if (strlen($s1) != strlen($s0)) return false;\n\
    \  for ($i = 0; $i < strlen($s0); $i++) {\n    if ($s0[$i] != $s1[$i]) return\
    \ false;\n  }\n  return true;\n}", "  $s0 = preg_replace('/\\s+/', '', $s0);\n\
    \  $s1 = preg_replace('/\\s+/', '', $s1);\n  return strlen($s0) == strlen($s1)\
    \ && strlen($s0) == count(preg_split('//', $s0)) && count(preg_split('//', $s1))\
    \ == strlen($s0);\n}", "    if (strlen($s0) > strlen($s1)) {\n        return false;\n\
    \    }\n    for ($i = 0, $max = strlen($s0); $i < $max; ++$i) {\n        if ($s1[$i]\
    \ != $s0[$i]) {\n            return false;\n        }\n    }\n    return true;\n\
    }\n", "    $s0 = preg_replace('/[^a-z]/', '', $s0);\n    $s1 = preg_replace('/[^a-z]/',\
    \ '', $s1);\n    if (strlen($s0) == strlen($s1)) {\n        $chars = array(strlen($s0));\n\
    \        for ($i = 0; $i < strlen($s0); ++$i) {\n            $chars[$i] = ord($s0[$i]);\n\
    \        }\n        for ($i = 0; $i < strlen($s1); ++$i) {\n            $chars[$i]\
    \ = ord($s1[$i]);\n        }\n        $chars = array_merge($chars, array_fill(0,\
    \ strlen($s1), 1));\n        sort($chars);\n        $chars = array_flip($chars);\n\
    \        return count($chars) == 1;\n    }\n    return false;\n}\n", "    $t0\
    \ = array_map('ord', str_split($s0));\n    $t1 = array_map('ord', str_split($s1));\n\
    \    $len0 = count($t0);\n    $len1 = count($t1);\n    for($i = 0; $i < $len0;\
    \ $i++) {\n        $c0 = ($t0[$i] == $t1[$i]);\n        for($j = $i + 1; $j <\
    \ $len1; $j++) {\n            $c1 = ($t0[$i] == $t1[$j]);\n            $c2 = ($c0\
    \ == $c1);\n        }\n        $c = $c2;\n    }\n    return $c;\n}\n", "\t$s1\
    \ = str_replace(' ', '', $s1);\n\t$s1 = str_replace('  ', '', $s1);\n\t$s0 = str_replace('\
    \ ', '', $s0);\n\t$s0 = str_replace('  ', '', $s0);\n\treturn (strlen($s0) ==\
    \ strlen($s1) &&\n\t\t  strpos($s0, $s1) !== false &&\n\t\t  strpos($s1, $s0)\
    \ !== false);\n}\n", "    $len = min(strlen($s0), strlen($s1));\n    for($i=0;\
    \ $i<$len; $i++) {\n        if($s1[$i] != $s0[$i]) return false;\n    }\n    return\
    \ true;\n}", "    $s0 = $s0.toLowerCase();\n    $s1 = $s1.toLowerCase();\n   \
    \ $len = strlen($s0);\n    $count = 0;\n    $pos0 = 0;\n    $pos1 = 0;\n\n   \
    \ while ($pos0 < $len && $pos1 < $len) {\n        if ($s1[$pos1] == $s0[$pos0])\
    \ {\n            $count++;\n        }\n        $pos0++;\n        $pos1++;\n  \
    \  }\n    return $count == $len;\n}", "  $s0 = preg_replace(\"/[^a-z]/\", \"\"\
    , $s0);\n  $s1 = preg_replace(\"/[^a-z]/\", \"\", $s1);\n  if ($s0 == $s1) {\n\
    \    return true;\n  }\n  $s0 = strlen($s0);\n  $s1 = strlen($s1);\n  if ($s0\
    \ > $s1) {\n    return false;\n  }\n  else {\n    for ($i = 0; $i < $s0; $i++)\
    \ {\n      if ($s1 != substr_count($s0, $i)) {\n        return false;\n      }\n\
    \    }\n    return true;\n  }\n}", "  if (strlen($s0) == 0)\n    return true;\n\
    \  else if (strlen($s1) == 0)\n    return false;\n\n  $count = ord($s0[0]) - ord($s1[0]);\n\
    \  for ($i = 0; $i < strlen($s0); $i++)\n    if ($count != 0)\n      $count =\
    \ (ord($s0[$i]) - ord($s1[0])) | $count;\n    else\n      $count = (ord($s0[$i])\
    \ - ord($s1[$i])) | 0;\n  return $count == 0;\n}\n", "    $s0 = preg_replace('/(.)\\\
    1/', '', $s0);\n    $s1 = preg_replace('/(.)\\1/', '', $s1);\n    return preg_match_all('/(.)\\\
    1/', $s0, $matches) &&\n        preg_match_all('/(.)\\1/', $s1, $matches) &&\n\
    \        $matches[0][0] == $matches[1][0];\n}\n", "    $s0_size = strlen($s0);\n\
    \    $s1_size = strlen($s1);\n    if ($s0_size != $s1_size || strcasecmp($s0,\
    \ $s1) !== 0)\n        return false;\n    $c0 = $s0;\n    $c1 = $s1;\n    $count\
    \ = 0;\n    while ($c0 && $c1) {\n        $c0 = strtoupper($c0);\n        $c1\
    \ = strtoupper($c1);\n        if ($c0 !== $c1)\n            return false;\n  \
    \      $count++;\n        $c0++;\n        $c1++;\n    }\n    return $count ==\
    \ $s0_size;\n}", "\treturn preg_replace('/(.)\\1{2,}/', '', $s0) == preg_replace('/(.)\\\
    1{2,}/', '', $s1);\n}\n", "    if (!preg_match('~^[abcd]+$~', $s0) || !preg_match('~^[abcd]+$~',\
    \ $s1))\n        return false;\n    return preg_match_all('~^[abcd]+$~', $s0,\
    \ $s0) == preg_match_all('~^[abcd]+$~', $s1, $s1);\n}\n", "    return preg_match_all('/[A-z]+/',\
    \ $s0) && preg_match_all('/[A-z]+/', $s1);\n}", "    if (!is_string($s0) || !is_string($s1)\
    \ || strlen($s0) != strlen($s1)) {\n        return false;\n    }\n    $len = strlen($s0);\n\
    \    for ($i = 0; $i < $len; $i++) {\n        if (ord($s0[$i]) != ord($s1[$i]))\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\n", "  \
    \  $s0 = str_replace(\"\\n\", \" \", $s0);\n    $s1 = str_replace(\"\\n\", \"\
    \ \", $s1);\n\n    // Remove duplicate spaces.\n    $s0 = preg_replace('/[\\n\\\
    r]/', ' ', $s0);\n    $s1 = preg_replace('/[\\n\\r]/', ' ', $s1);\n\n    // Split\
    \ the input on spaces.\n    $s0 = preg_split('/ +/', $s0);\n    $s1 = preg_split('/\
    \ +/', $s1);\n\n    // Check if the set of characters in s1 are the same as the\
    \ set of characters\n    // in s0.\n    return count(array_intersect($s0, $s1))\
    \ == count($s0);\n}\n", "  if (!$s0 || !$s1) return false;\n  for ($i = 0; $i\
    \ < strlen($s0); $i++) for ($j = 0; $j < strlen($s1); $j++) {\n    if ($s0[$i]\
    \ != $s1[$j]) {\n      return false;\n    }\n  }\n  return true;\n}\n", "    $s0len\
    \   = strlen($s0);\n    $s1len   = strlen($s1);\n    $same    = 0;\n    for ($i\
    \ = 0; $i < $s0len; $i++)\n        if ($s0[$i] !== $s1[$i])\n            $same++;\n\
    \    return ($s0len === $s1len && $same === $s0len);\n}\n", "    $s1_length =\
    \ strlen($s1);\n    if ($s0_length != $s1_length) {\n        return false;\n \
    \   }\n\n    for ($i = 0; $i < $s0_length; $i++) {\n        if ($s1[$i] != $s0[$i])\
    \ {\n            return false;\n        }\n    }\n\n    return true;\n}\n", " \
    \   $s1 = preg_replace('/(.)$/', \"$1$1\", $s1);\n    return preg_match_all('/(.)\\\
    \\1/', $s0, $s0_count) && preg_match_all('/(.)\\\\1/', $s1, $s1_count);\n}", " \
    \   $s0 = str_replace(\"\\r\\n\", \"\\n\", $s0);\n    $s1 = str_replace(\"\\r\\\
    n\", \"\\n\", $s1);\n    $s0 = str_replace(\"\\r\", \"\\n\", $s0);\n    $s1 =\
    \ str_replace(\"\\r\", \"\\n\", $s1);\n\n    // Check if each character is in\
    \ both strings.\n    foreach (str_split($s0) as $c) {\n        if (!strpos($s1,\
    \ $c)) {\n            return false;\n        }\n    }\n    return true;\n}\n</code>\n\
    <|/ a tags=php,replace,string |>\n<| c |>\nThis won't catch `AaBbCc`, but thanks\
    \ for giving me something to look at! :)\n<|/ c |>\n<| c |>\nThis is great! I\
    \ added another answer that combines both answers into one that does a case insensitive\
    \ and case sensitive check.\n<|/ c |>\n<| a |>\nHere is a case insensitive and\
    \ case sensitive answer combined with Mike Cox's answer and this answer:\n<code>",
  "  if ($s0 == $s1)\n    return true;\n  if (strlen($s0) != strlen($s1))\n    return\
    \ false;\n  foreach (str_split($s0) as $c0\n      => $c1) {\n    if ($c0 != $c1)\n\
    \      return false;\n  }\n  return true;\n}\n", "    return $s0 === $s1 || preg_match('/'\
    \ . $s0 . '|' . $s1 . '/', $s0) || preg_match('/' . $s1 . '|' . $s0 . '/', $s1);\n\
    }\n", "    global $CASE_MAPPING_ORIGIN;\n\n    if ($s0 === $s1)\n        return\
    \ true;\n\n    $s0 = $CASE_MAPPING_ORIGIN;\n    $s1 = $CASE_MAPPING_ORIGIN;\n\n\
    \    $i0 = 0;\n    $i1 = 0;\n\n    $len0 = strlen($s0);\n    $len1 = strlen($s1);\n\
    \n    for ($i = 0; $i < $len0; $i++) {\n        if ($s1[$i0] != $s0[$i0])\n  \
    \          return false;\n\n        $i0++;\n    }\n\n    for ($i = 0; $i < $len1;\
    \ $i++) {\n        if ($s1[$i1] != $s0[$i1])\n            return false;\n\n  \
    \      $i1++;\n    }\n\n    if ($i0 != $len0 || $i1 != $len1)\n        return\
    \ false;\n\n    return true;\n}", "\t$len0 = strlen($s0);\n\t$len1 = strlen($s1);\n\
    \tfor ($i = 0; $i < $len0; $i++) {\n\t\tfor ($j = 0; $j < $len1; $j++) {\n\t\t\
    \tif ($s1[$j] != $s0[$i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ true;\n}\n\n", "    $s0 = $s0;\n    $s1 = $s1;\n    $s0 = mb_convert_case($s0,\
    \ MB_CASE_TITLE, \"UTF-8\");\n    $s1 = mb_convert_case($s1, MB_CASE_TITLE, \"\
    UTF-8\");\n\n    if (mb_strlen($s0) > mb_strlen($s1)) {\n        $s1 = $s1 . str_repeat(mb_substr($s0,\
    \ 1, mb_strlen($s0), \"UTF-8\"), mb_strlen($s0));\n    } elseif (mb_strlen($s0)\
    \ < mb_strlen($s1)) {\n        $s0 = $s0 . str_repeat(mb_substr($s1, 0, mb_strlen($s1),\
    \ \"UTF-8\"), mb_strlen($s1));\n    }\n\n    $s0 = preg_replace(\"(.*)(.)(?!$)\"\
    , $s0 . $s0, $s0);\n    $s1 = preg_replace(\"(.*)(.)(?!$)\", $s1 . $s1, $s1);\n\
    \n    $l0 = mb_strlen($s0);\n    $l1 = mb_strlen($s1);\n    $i = 0;\n\n    while\
    \ ($i < $l0 && $i < $l1) {\n        if ($s0[$i] == $s1[$i]) {\n            $i++;\n\
    \        } else {\n            if ($s0[$i] === $s1[$i]) {\n                return\
    \ false;\n            }\n            if (mb_strlen($s0) >= $l1 - $i || mb_strlen($s1)\
    \ >= $l0 - $i) {\n                return false;\n            }\n        }\n  \
    \  }\n    return true;\n}\n\n/**\n * @param string $s\n * @param string $p\n *\
    \ @return string\n */", "  $s0 = preg_split('//', $s0);\n  $s1 = preg_split('//',\
    \ $s1);\n  $l0 = count($s0);\n  $l1 = count($s1);\n  for ($i = 0; $i < $l0; $i++)\
    \ {\n    for ($j = 0; $j < $l1; $j++) {\n      if ($s0[$i] == $s1[$j]) {\n   \
    \     $i += 1;\n        $j += 1;\n        continue;\n      }\n      break;\n \
    \   }\n  }\n  return $l0 == $i;\n}", "    $s0 = strtolower($s0);\n    $s1 = strtolower($s1);\n\
    \    $n = max(strlen($s0), strlen($s1));\n    for ($i = 0; $i < $n; $i++) {\n\
    \        $c = $s1[$i];\n        if ($s1[$i] != $s0[$i]) {\n            return\
    \ false;\n        }\n    }\n    return true;\n}\n", "    if ($s0 === $s1) {\n\
    \        return true;\n    }\n    $s0 = preg_replace(\"/[^a-zA-Z0-9-_]/\", \"\"\
    , $s0);\n    $s1 = preg_replace(\"/[^a-zA-Z0-9-_]/\", \"\", $s1);\n    if (strlen($s0)\
    \ > strlen($s1)) {\n        return false; // longer\n    }\n    if (strlen($s0)\
    \ < strlen($s1)) {\n        return false; // shorter\n    }\n    $m = [];\n  \
    \  for ($i = 0; $i < strlen($s0); $i++) {\n        $m[$i] = 0;\n    }\n    for\
    \ ($i = 0; $i < strlen($s1); $i++) {\n        $m[$i] = isset($m[$i + 1]) ? $m[$i\
    \ + 1] + 1 : 1;\n    }\n    for ($i = 0; $i < strlen($s0); $i++) {\n        if\
    \ ($m[$i] <= 1) {\n            return false;\n        }\n    }\n    return true;\n\
    }\n", "    // Check if words are same length\n    if (strlen($s0) > strlen($s1))\
    \ {\n        return false;\n    }\n\n    // Check if two words have same letters\
    \ one by one\n    $len1 = strlen($s0);\n    $len2 = strlen($s1);\n    $same =\
    \ 0;\n    for ($i = 0; $i < $len1; $i++) {\n        if ($s1[$i] == $s0[$i]) {\n\
    \            $same += 1;\n        }\n    }\n\n    return $same == $len2;\n}\n",
  "    return count($s0) === count($s1) &&\n        array_reduce(array_map('strlen',\
    \ $s0), function ($c, $i) { return ($c <= $i) ? $c : $i; }) === count($s0);\n}",
  "    if (strlen($s0) != strlen($s1)) {\n        return false;\n    }\n    $c0 =\
    \ preg_split('//', $s0, -1, PREG_SPLIT_NO_EMPTY);\n    $c1 = preg_split('//',\
    \ $s1, -1, PREG_SPLIT_NO_EMPTY);\n    sort($c0);\n    sort($c1);\n    if ($c0\
    \ === $c1) {\n        return true;\n    }\n    return preg_replace('/(.)\\1/',\
    \ '', implode('', array_diff($c0, $c1))) == '';\n}", "    $s0 = preg_replace('/[^a-z]+/i',\
    \ '', $s0);\n    $s1 = preg_replace('/[^a-z]+/i', '', $s1);\n    $a0 = str_split($s0);\n\
    \    $a1 = str_split($s1);\n    return count($a0) == count($a1) && count(array_diff($a0,\
    \ $a1)) == 0;\n}", "\t$len0 = strlen($s0);\n\t$len1 = strlen($s1);\n\t$len = $len0\
    \ - $len1;\n\t$len = max($len, 0);\n\t$len = $len > 0 ? $len : 1;\n\t$t0 = str_split($s0);\n\
    \t$t1 = str_split($s1);\n\tfor ($i = 0; $i < $len; ++$i) {\n\t\tif ($t0[$i] !==\
    \ $t1[$i]) return false;\n\t}\n\treturn true;\n}\n", "  $s0 = mb_substr($s0, 1,\
    \ mb_strlen($s0, \"8bit\"), \"8bit\");\n  $s1 = mb_substr($s1, 1, mb_strlen($s1,\
    \ \"8bit\"), \"8bit\");\n\n  return mb_substr($s0, -1, mb_strlen($s1, \"8bit\"\
    ), \"8bit\") == $s1;\n}", "    if ($s0 === $s1) {\n        return true;\n    }\n\
    \n    $len = min(strlen($s0), strlen($s1));\n    for ($i = 0; $i < $len; ++$i)\
    \ {\n        if ($s0 [$i] != $s1 [$i]) {\n            return false;\n        }\n\
    \    }\n\n    return true;\n}\n", "  if ($s0 == $s1) {\n    return true;\n  }\n\
    \n  foreach (str_split($s0, 1) as $c) {\n    if ($s1 === $c) { // empty strings\
    \ are equal\n      return true;\n    }\n\n    if ($c !== $s1[0]) {\n      return\
    \ false;\n    }\n\n    $s1 = substr($s1, 1);\n  }\n\n  return false;\n}", "  \
    \  $s0 = str_replace(array(\"e\", \"z\", \"z\", \"z\", \"z\", \"d\", \"d\", \"\
    a\", \"c\"), \"\", $s0);\n    $s1 = str_replace(array(\"e\", \"z\", \"z\", \"\
    z\", \"z\", \"d\", \"d\", \"a\", \"c\"), \"\", $s1);\n    return $s0 === $s1;\n\
    }\n", "    // Check lengths\n    if (strlen($s0) == strlen($s1)) {\n        for\
    \ ($i = 0; $i < strlen($s0); $i++) {\n            if ($s0[$i] != $s1[$i]) {\n\
    \                return false;\n            }\n        }\n        return true;\n\
    \    }\n\n    return false;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nYour solution\
    \ seems to be the simplest, but I'm having difficulty understanding it. The other\
    \ posts seem to have difficulty understanding it as well.\n<|/ c |>\n<| c |>\n\
    It's basically the same algorithm as Jason's one, but his is more extensible,\
    \ so you can add more rules to it (like case insensitive, etc)\n<|/ c |>\n<| c\
    \ |>\nIt also doesn't return the number of matching characters. I modified it\
    \ so it returns the number of matching characters. I believe this should be the\
    \ accepted answer\n<|/ c |>\n<| c |>\nYes it does, thank you! For some reason\
    \ when I checked it on my data set it gave the wrong number of matching characters,\
    \ but it gave the correct number of matching characters when I tested it on a\
    \ different set of data. I'm guessing it's something to do with the way my data\
    \ is structured that's causing it to behave differently. Your algorithm seems\
    \ to be perfect. Thanks again for all of your help!\n<|/ c |>\n<| a tags=arrays,php\
    \ |>\nYou can use a simple loop and an array_search to get the index of the character\
    \ and remove it from the array. \n<code>\n$array = array(\"e\", \"g\", \"d\",\
    \ \"d\", \"a\");\nfor ($i = 0; $i < count($array); $i++) {\n    if(in_array($array[$i],\
    \ $array)) {\n        unset($array[$i]);\n    }\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nYes that would work, but the problem is I only want to remove characters\
    \ that are in the array. This only removes the ones that match in the same index\
    \ as the letter in question\n<|/ c |>\n<| c |>\nSorry I misunderstood your question.\
    \ Fixed the code so that it will remove all characters that are in the array\n\
    <|/ c |>\n<| c |>\nThank you. I've fixed my code so it doesn't remove any characters,\
    \ just returns how many matching characters there are.\n<|/ c |>\n<| a |>\nYou\
    \ could use a regex in combination with array_map(), but this would mean that\
    \ you would have to write a separate regex for each of the letters.\n<|/ a dscore=0\
    \ tags=arrays,php |>\n<| a |>\nThis regex should do it", "    if (strlen($s0)\
    \ != strlen($s1)) {\n        return false;\n    }\n    $c0 = array();\n    $c1\
    \ = array();\n    for ($i = 0; $i < strlen($s0); $i++) {\n        $c0[] = ord($s0[$i]);\n\
    \        $c1[] = ord($s1[$i]);\n    }\n    $c0 = array_unique($c0);\n    $c1 =\
    \ array_unique($c1);\n    if (count($c0) != count($c1)) {\n        return false;\n\
    \    }\n    foreach ($c0 as $c) {\n        if (! in_array($c, $c1)) {\n      \
    \      return false;\n        }\n    }\n    return true;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=string,php,string-length |>\nYou could make use of str_repeat()\
    \ and in_array() :\n<code>\n<?php", "    $c0 = array_count_values(str_split($s0));\n\
    \    $c1 = array_count_values(str_split($s1));\n    foreach ($c1 as $s2 => $count)\
    \ {\n        if ($c1[$s2] == $count && isset($c0[$s2]) && $c0[$s2] == $c1[$s2])\
    \ {\n            continue;\n        }\n        return false;\n    }\n    return\
    \ true;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nThe most efficient way\
    \ is to use array_diff_assoc(), because you have the characters to compare (the\
    \ words), so to compare them without having to check all the characters in one\
    \ word:\n<code>", "    if ($s0 == $s1) {\n        return true;\n    }\n    if\
    \ (count($s0) != count($s1)) {\n        return false;\n    }\n    $len = count($s0);\n\
    \    for ($i = 0; $i < $len; $i++) {\n        if ($s0[$i] != $s1[$i]) {\n    \
    \        return false;\n        }\n    }\n    return true;\n}", "    if (strlen($s0)\
    \ > strlen($s1)) {\n        return false;\n    }\n    $i0 = 0;\n    $i1 = 0;\n\
    \    while ($i0 < strlen($s0)) {\n        $ch0 = substr($s0, $i0, 1);\n      \
    \  $ch1 = substr($s1, $i1, 1);\n        if ($ch0 != $ch1) {\n            break;\n\
    \        }\n        $i0++;\n        $i1++;\n    }\n    if ($i0 == strlen($s0))\
    \ {\n        return true;\n    }\n    if ($i1 == strlen($s1)) {\n        return\
    \ true;\n    }\n    if ($i0 < strlen($s0)) {\n        return same_chars($s0, substr($s1,\
    \ $i1));\n    }\n    return false;\n}\n", "  $len = strlen($s0);\n  for ($i =\
    \ 0; $i < $len; $i++) {\n    if ($s1[$i] != $s0[$i]) return false;\n  }\n  return\
    \ true;\n}\n", "    $s1 = str_replace(\" \", \"\", $s1);\n    $s0 = str_replace(\"\
    \ \", \"\", $s0);\n    if ($s0 === $s1) {\n        return true;\n    }\n    $samechars\
    \ = false;\n    $len = min(strlen($s0), strlen($s1));\n    for ($i = 0; $i < $len;\
    \ $i++) {\n        $samechars |= ord($s0[$i]) === ord($s1[$i]);\n    }\n    return\
    \ $samechars;\n}\n", "    // If $s0 and $s1 are both empty strings, return true.\n\
    \    // This allows us to treat the empty string as equal\n    // to any string.\n\
    \    if (strlen($s0) == 0 && strlen($s1) == 0) {\n        return true;\n    }\n\
    \n    // If $s0 and $s1 have different lengths, return false.\n    if (strlen($s0)\
    \ > strlen($s1)) {\n        return false;\n    }\n\n    $result = true;\n    $len\
    \ = strlen($s0);\n\n    // Check that $s0 and $s1 have the same number of characters.\n\
    \    for ($i = 0; $i < $len; $i++) {\n        if ($s0[$i] != $s1[$i]) {\n    \
    \        $result = false;\n            break;\n        }\n    }\n    return $result;\n\
    }\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI got this error when trying: \n\nNotice:\
    \ Undefined offset: 0 in C:\\xampp\\htdocs\\word\\index.php on line 16\n\nWarning:\
    \ Invalid argument supplied for foreach() in C:\\xampp\\htdocs\\word\\index.php\
    \ on line 16\n\nNotice: Undefined offset: 0 in C:\\xampp\\htdocs\\word\\index.php\
    \ on line 17\n\nWarning: Invalid argument supplied for foreach() in C:\\xampp\\\
    htdocs\\word\\index.php on line 17\n<|/ c |>\n<| a tags=php |>\n<code>\n<?php\
    \ \n$string1=\"Hello World\";\n$string2=\"Hello World\";\nif($string1==$string2)\n\
    {\n    echo \"They are equal\";\n}\nelse\n{\n    echo \"They are not equal\";\n\
    }", "    // TODO: Make this more efficient.\n    // If the characters match, return\
    \ true.\n    // Otherwise, return false.\n    // TODO: Use a better data structure\
    \ to store the characters.\n    for ($i = 0; $i < strlen($s0); $i++) {\n     \
    \   $c = $s0[$i];\n        for ($j = 0; $j < strlen($s1); $j++) {\n          \
    \  $c2 = $s1[$j];\n            if ($c == $c2) {\n                return true;\n\
    \            }\n        }\n    }\n    return false;\n}", "  $s0 = preg_replace(\"\
    /[^a-z ]/i\", \"\", $s0);\n  $s1 = preg_replace(\"/[^a-z ]/i\", \"\", $s1);\n\
    \  return $s0 === $s1;\n}", "    if (count($s0) != count($s1)) {\n        return\
    \ false;\n    }\n\n    sort($s0);\n    sort($s1);\n\n    foreach ($s0 as $i =>\
    \ $char) {\n        if ($s1[$i] != $char) {\n            return false;\n     \
    \   }\n    }\n\n    return true;\n}\n", "    if (strlen($s0) != strlen($s1)) {\n\
    \        return false;\n    }\n    $same = 0;\n    for ($i = 0; $i < strlen($s0);\
    \ $i++) {\n        if ($s1[$i] != $s0[$i]) {\n            $same++;\n        }\n\
    \    }\n    return $same == strlen($s0);\n}\n", "    $len = min(strlen($s0), strlen($s1));\n\
    \    for ($i = 0; $i < $len; $i++) {\n        if ($s1[$i] != $s0[$i]) return false;\n\
    \    }\n    return true;\n}\n", "    $i = min(strlen($s0), strlen($s1));\n   \
    \ $j = 0;\n    while ($i < $j) {\n        if ($s1[$i] == $s0[$j]) $i++;\n    \
    \    else break;\n        $j++;\n    }\n    return $i == $j;\n}", "    if (strlen($s0)\
    \ > strlen($s1)) {\n        $s0 = substr($s0, 1, strlen($s0));\n    } else {\n\
    \        $s1 = substr($s1, 1, strlen($s1));\n    }\n    \n    $s = array();\n\
    \    \n    for ($i = 0; $i < strlen($s0); $i++) {\n        $s[$i] = 0;\n    }\n\
    \    \n    for ($i = 0; $i < strlen($s1); $i++) {\n        if ($s1[$i] == $s0[$i])\
    \ {\n            $s[$i] = 1;\n        }\n    }\n    \n    return array_sum($s)\
    \ == strlen($s0);\n}\n", "    $len = max(strlen($s0), strlen($s1));\n    for ($i\
    \ = 0; $i < $len; $i++) {\n        if ($s0[$i] !== $s1[$i]) return false;\n  \
    \  }\n    return true;\n}\n</code>\n<|/ a |>\n<| c |>\nWow, thanks. I realize\
    \ I should have mentioned my constraints, but this seems to work well. I'll accept\
    \ it in 5 minutes when it allows me to.\n<|/ c |>\n<| c |>\nI appreciate this.\
    \ I ran some tests and it works perfectly. I'm going to do some more tests on\
    \ larger files just in case it breaks but I believe this will be a solid solution\
    \ for me. Thanks again!\n<|/ c |>\n<| a |>\nAssuming that the strings have the\
    \ same length, you can do it in a single iteration over the characters, checking\
    \ if the character at the current position is different from the current character\
    \ from the previous position, and breaking out of the loop:\n<code>\nint sameChars(string\
    \ a, string b) {\n    int same = 0;\n    for (char c : a + b) {\n        if (c\
    \ != a[same] || c != b[same]) {\n            same += 1;\n            break;\n\
    \        }\n    }\n    return same;\n}\n</code>\n<|/ a dscore=1 tags=php |>\n\
    <| a dscore=1 tags=php |>\nI wrote the following function for my use. I don't\
    \ know if it's the best way to do this, but it's my best and it works for me.\
    \ I hope it helps you, too.\n<code>\npublic static function isSame($var1, $var2,\
    \ $var3 = null) {\n    // If first value is not defined, set the first to itself\n\
    \    if(!is_null($var3)) $var3 = $var3;\n    // If second value is not defined,\
    \ set the second to itself\n    if(!is_null($var2)) $var2 = $var2;\n    // If\
    \ both values are the same, return true\n    if($var1 == $var2) return true;\n\
    \n    // If second value is shorter than first value, return false\n    if($var2\
    \ == \"\") return $var1 == \"\";\n\n    // If first value is shorter than second\
    \ value, return false\n    if($var1 == \"\") return $var2 == \"\";\n\n    // If\
    \ both values are equal, count characters in first and second values\n    $valueLength\
    \ = min(strlen($var1), strlen($var2));\n    // If both values are the same, return\
    \ true\n    if($valueLength == strlen($var2)) return true;\n\n    // If the characters\
    \ are the same, return false\n    if($valueLength == strlen($var1)) return false;\n\
    \n    // If the characters are different, compare them\n    for($i = 0; $i < $",
  "  if (!is_string($s0) || !is_string($s1) || strlen($s0) != strlen($s1)) {\n   \
    \ return false;\n  }\n  $c0 = preg_split('//', $s0);\n  $c1 = preg_split('//',\
    \ $s1);\n  foreach ($c1 as $i => $c1_char) {\n    foreach ($c0 as $j => $c0_char)\
    \ {\n      if ($c0_char == $c1_char) {\n        unset($c0[$j], $c1[$i]);\n   \
    \     break;\n      }\n    }\n  }\n  return empty($c0) ? false : count($c0) ==\
    \ count($c1);\n}\n", "  return strlen($s0) == strlen($s1) &&\n    count(array_intersect(str_split($s0),\
    \ str_split($s1))) == strlen($s0);\n}\n", "  // If the string lengths are the\
    \ same, nothing to compare.\n  if (strlen($s0) == strlen($s1)) {\n    return true;\n\
    \  }\n  // If the strings are the same length, we'll use the same algorithm.\n\
    \  // Use case-insensitivity to test for different upper and lowercase\n  // characters.\
    \ Otherwise, use strpos to find the position of each character.\n  $s1_len = strlen($s1);\n\
    \  for ($i = 0; $i < strlen($s0); $i++) {\n    if (ctype_upper($s1[$i]) === ctype_upper($s0[$i]))\
    \ {\n      if (ctype_lower($s1[$i]) === ctype_lower($s0[$i])) {\n        if ($s1_len\
    \ - $i <= $i || $s1[$i] != $s0[$i]) {\n          return false;\n        }\n  \
    \    } else {\n        if ($s1_len - $i > $i || $s1[$i] != $s0[$i]) {\n      \
    \    return false;\n        }\n      }\n    } else {\n      if ($s1_len - $i >\
    \ $i || ctype_lower($s1[$i]) !== ctype_lower($s0[$i])) {\n        return false;\n\
    \      }\n    }\n  }\n  return true;\n}\n", "    return preg_replace('/(.)\\1/',\
    \ $s0, $s1) == $s1;\n}\n", "\t$s0len = strlen($s0);\n\t$s1len = strlen($s1);\n\
    \n\tif ($s0len != $s1len) return false;\n\n\tfor ($i = 0; $i < $s0len; $i++) {\n\
    \t\tif ($s0[$i] != $s1[$i]) return false;\n\t}\n\n\treturn true;\n}\n\n", "  if\
    \ (strlen($s0) == 0)\n    return (strlen($s1) == 0);\n\n  if (strlen($s1) == 0)\n\
    \    return false;\n\n  $i = $j = 0;\n  while ($i < strlen($s0) && $j < strlen($s1))\
    \ {\n    if ($s1[$j] != $s0[$i]) {\n      break;\n    }\n    $i++;\n    $j++;\n\
    \  }\n  return ($i == strlen($s0));\n}\n", "\treturn (strlen($s0) === strlen($s1)\
    \ && count(array_unique($s0)) === count(array_unique($s1)));\n}\n", "    // Make\
    \ sure s0 and s1 are strings.\n    $s0 = strval($s0);\n    $s1 = strval($s1);\n\
    \n    // Go through the letters in s0 and s1 and count how often they occur.\n\
    \    $count = array();\n    for ($i = 0; $i < strlen($s0); $i++) {\n        $count[strtolower($s0[$i])]++;\n\
    \        $count[strtolower($s1[$i])]++;\n    }\n\n    // If count is bigger than\
    \ zero, they are not the same character.\n    return count($count) > 0;\n}\n",
  "  if (!$s0 || $s1 === '') return true;\n  $s0 = preg_replace('/(^|\\s)([a-zA-Z])/',\
    \ \"\\$1\\$2\", $s0);\n  $s1 = preg_replace('/(^|\\s)([a-zA-Z])/', \"\\$1\\$2\"\
    , $s1);\n  $s0 = str_replace('$', '', $s0);\n  $s1 = str_replace('$', '', $s1);\n\
    \  return $s0 == $s1;\n}\n", "    $chars = str_split($s0);\n    sort($chars);\n\
    \    sort($chars);\n    sort($chars);\n    sort($s1);\n    sort($s1);\n    sort($s1);\n\
    \    return array_slice($chars, 0, count($chars)) === array_slice($s1, 0, count($s1));\n\
    }\n", "  if (strlen($s0) > strlen($s1)) {\n    return false;\n  }\n\n  for ($i\
    \ = 0; $i < strlen($s0); $i++) {\n    if (strpos($s1, $s0[$i]) === false) {\n\
    \      return false;\n    }\n  }\n\n  return true;\n}\n</code>\n<|/ a tags=algorithm,php,language-agnostic,string\
    \ dscore=3 |>\n<| a dscore=2 |>\n<code>", "    if (strlen($s0) == strlen($s1)\
    \ &&\n        strlen($s0) == 0) {\n        return true;\n    }\n    if (strlen($s0)\
    \ > strlen($s1) ||\n        strlen($s0) < strlen($s1)) {\n        return false;\n\
    \    }\n    $a = str_split($s0);\n    $b = str_split($s1);\n    $c = array_count_values($a)\
    \ + array_count_values($b);\n    foreach ($c as $i => $c) {\n        if ($c !=\
    \ 1) {\n            return false;\n        }\n    }\n    return true;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nI agree, but you didn't mention the complexity of OP's solution,\
    \ and it seems to me that your solution will be much slower than the one he posted\
    \ (which uses `array_count_values()`).\n<|/ c |>\n<| c |>\nYeah I didn't think\
    \ of that, array_count_values does a lot of extra work.\n<|/ c |>\n<| c |>\nI\
    \ updated my solution to include a function to get an exact match, and added a\
    \ short demo for you to try it out!\n<|/ c |>\n<| c |>\nThat would be nice to\
    \ know!\n<|/ c |>\n<| c |>\nYeah I tested it out, and it's definitely faster.\
    \  I'm still waiting for the answer from the OP to see if this approach is faster,\
    \ though.\n<|/ c |>\n<| a dscore=4 |>\nHere is a solution using regex:\n<code>",
  "    $i = 0;\n    $j = 0;\n    $same = 0;\n    $len = min(strlen($s0), strlen($s1));\n\
    \    while($i < $len && $j < $len) {\n        if ($s1[$i] == $s0[$j]) {\n    \
    \        $same += 1;\n            $i++;\n            $j++;\n        }\n      \
    \  else if ($s1[$i] > $s0[$j]) {\n            $i++;\n        }\n        else {\n\
    \            $j++;\n        }\n    }\n    return $same == strlen($s0); // return\
    \ true if equal\n}\n", "\treturn preg_match('/[A-z]{2}/', $s0) && preg_match('/[A-z]{2}/',\
    \ $s1);\n}\n", "    $a = array();\n    $b = array();\n    for ($i = 0; $i < strlen($s0);\
    \ $i++) {\n        $a[$i] = substr($s0, $i, 1);\n        for ($j = 0; $j < strlen($s1);\
    \ $j++) {\n            if ($a[$i] == substr($s1, $j, 1)) {\n                $b[$i]\
    \ = true;\n                break;\n            }\n        }\n    }\n    return\
    \ !in_array(false, $b, true);\n}\n", "    $s1 = strtolower($s1);\n    $s0 = strtolower($s0);\n\
    \    $len0 = strlen($s0);\n    $len1 = strlen($s1);\n    $i = 0;\n    $k = 0;\n\
    \    for ($i = 0; $i < $len0; $i++) {\n        if ($s1[$i] == $s0[$i]) {\n   \
    \         $k++;\n            continue;\n        }\n        if ($k != 0) {\n  \
    \          return false;\n        }\n    }\n    return $k == $len1;\n}\n", " \
    \ if (strlen($s0) == 0) {\n    return strlen($s1) == 0;\n  }\n  else if (strlen($s1)\
    \ == 0) {\n    return false;\n  }\n  else {\n    $j = 0;\n    $i = 0;\n    while\
    \ ($i < strlen($s0)) {\n      if ($s0[$i] != $s1[$j]) {\n        return false;\n\
    \      }\n      $i++;\n      $j++;\n    }\n    return true;\n  }\n}", "    if\
    \ (strlen($s0) > strlen($s1)) {\n        $s0 = $s1 . $s0;\n        $s1 = $s0 .\
    \ $s1;\n        $s0 = $s0 . $s0;\n    }\n\n    $l0 = strlen($s0);\n    $l1 = strlen($s1);\n\
    \    $c0 = count($s0);\n    $c1 = count($s1);\n\n    $same = 0;\n\n    for ($i\
    \ = 0; $i < $l0; $i++) {\n        if ($s1[$i] != $s0[$i]) {\n            return\
    \ false;\n        }\n    }\n\n    for ($i = 0; $i < $l1; $i++) {\n        if ($s0[$i]\
    \ != $s1[$i]) {\n            return false;\n        }\n    }\n\n    for ($i =\
    \ 0; $i < $c1; $i++) {\n        $c0 = count($s0);\n        $c1 = count($s1);\n\
    \n        if ($s0[$i] != $s1[$i]) {\n            $same += ($c1 - $c0) / 2;\n \
    \       }\n    }\n\n    return ($same == $c0);\n}\n", "  $len0 = strlen($s0);\n\
    \  $len1 = strlen($s1);\n  if ($len0 !== $len1) return false;\n  for ($i = 0;\
    \ $i < $len0; ++$i) {\n    if ($s0[$i] !== $s1[$i]) return false;\n  }\n  return\
    \ true;\n}\n", "\t$a0 = preg_split('//u', $s0, -1, PREG_SPLIT_NO_EMPTY);\n\t$a1\
    \ = preg_split('//u', $s1, -1, PREG_SPLIT_NO_EMPTY);\n\tif (count($a0) == 1 &&\
    \ count($a1) == 1)\n\t\treturn true;\n\tforeach ($a0 as $i => $char)\n\t\tif (!isset($a1[$i]))\
    \ return false;\n\treturn true;\n}\n", "    if (empty($s0) || empty($s1)) {\n\
    \        return false;\n    }\n\n    $s_chars = array_count_values(str_split($s0));\n\
    \    $l_chars = array_count_values(str_split($s1));\n\n    return $s_chars ==\
    \ $l_chars;\n}\n", "    if (empty($s0) || empty($s1)) {\n        return false;\n\
    \    }\n    if (strlen($s0) != strlen($s1)) {\n        return false;\n    }\n\
    \    $s = $s0;\n    for ($i = 0; $i < strlen($s0); $i++) {\n        $s1 = substr($s1,\
    \ $i, 1);\n        if ($s != $s1) {\n            return false;\n        }\n  \
    \  }\n    return true;\n}", "    $len0 = count($s0);\n    $len1 = count($s1);\n\
    \    if ($len0 != $len1) {\n        return false;\n    }\n    for ($i = 0; $i\
    \ < $len0; $i++) {\n        if ($s1[$i] != $s0[$i]) {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n", "    // Remove common characters.\n\
    \    $s0 = preg_replace('/[^a-z]/',' ',$s0);\n    $s1 = preg_replace('/[^a-z]/','\
    \ ',$s1);\n    // Count how many of each type of letter we have.\n    $c = array_count_values(str_split($s0));\n\
    \    $d = array_count_values(str_split($s1));\n    // Check the longest word first.\n\
    \    if (strlen($s0) > strlen($s1))\n        list($s0,$s1) = array($s1,$s0);\n\
    \    // Check each word from left to right.\n    for ($i = 0; $i < min(strlen($s0),strlen($s1));\
    \ $i++) {\n        // If one word has more of the same letter then we know it\
    \ doesn't\n        // match.\n        if ($c[$i] < $d[$i]) return false;\n   \
    \     // If they both have more of this letter then they match.\n        if ($c[$i]\
    \ > $d[$i]) return true;\n    }\n    // Check each word from right to left.\n\
    \    for ($i = strlen($s0)-1; $i >= 0; $i--) {\n        if ($c[$i] < $d[$i]) return\
    \ false;\n        if ($c[$i] > $d[$i]) return true;\n    }\n    // If every word\
    \ has the same count of letters then they match.\n    return count($c) == count($d);\n\
    }", "    $s0 = preg_replace('/(\\w)\\1+/', \"\\\\1\", $s0);\n    $s1 = preg_replace('/(\\\
    w)\\1+/', \"\\\\1\", $s1);\n    if ($s0 === $s1) {\n        return true;\n   \
    \ } else {\n        return false;\n    }\n}\n", "\t$i0 = strlen($s0);\n\t$i1 =\
    \ strlen($s1);\n\tif ($i0 != $i1) return false;\n\t$i = 0;\n\twhile ($i < $i0)\
    \ {\n\t\tif ($s1[$i] != $s0[$i]) return false;\n\t\t$i++;\n\t}\n\treturn true;\n\
    }\n\n", "  // Check if the lengths match.\n  if (strlen($s0) != strlen($s1)) {\n\
    \    return false;\n  }\n\n  // Check if the characters match.\n  for ($i = 0;\
    \ $i < strlen($s0); $i++) {\n    if ($s0[$i] != $s1[$i]) {\n      return false;\n\
    \    }\n  }\n\n  return true;\n}\n", "    $n0 = strlen($s0);\n    $n1 = strlen($s1);\n\
    \    if ($n0 !== $n1)\n        return false;\n    $k0 = $n0 >> 1;\n    $k1 = $n1\
    \ >> 1;\n    for ($k = 0; $k < $k0; $k++)\n        $c = $s1[$k];\n    for ($k\
    \ = 0; $k < $k1; $k++)\n        $c = $s0[$k] . $c;\n    return ($s1[$k] === $s0[$k]);\n\
    }\n", "    if (strlen($s0) != strlen($s1)) {\n        return false;\n    }\n\n\
    \    $a = str_split($s0);\n    $b = str_split($s1);\n\n    foreach ($a as $k =>\
    \ $v) {\n        if ($a[$k] != $b[$k]) {\n            return false;\n        }\n\
    \    }\n\n    return true;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nJust a small\
    \ suggestion, maybe you can use a foreach instead of a for loop in order to increase\
    \ readability. Something like: `$a = str_split($s0); $b = str_split($s1); foreach($a\
    \ as $k => $v) {if($a[$k] != $b[$k]) {return false;} }`\n<|/ c |>\n<| c |>\nGood\
    \ call, I modified it to use a `foreach`, also added a check that the strings\
    \ are the same length. Thanks!\n<|/ c |>\n<| c |>\nThanks again! I was actually\
    \ thinking of using the same approach as this question you linked to, because\
    \ I needed to compare the characters and compare the indexes of the character\
    \ positions in each string. Your solution is definitely a lot cleaner!\n<|/ c\
    \ |>\n<| a tags=performance,php |>\nIf you're only comparing two strings for equality,\
    \ you can use array_diff() to achieve the same result.\n<code>", "    if (strlen($s0)\
    \ != strlen($s1)) {\n        return false;\n    }\n    $same = true;\n    for\
    \ ($i = 0; $i < strlen($s0); $i++) {\n        if ($s0[$i] != $s1[$i]) {\n    \
    \        $same = false;\n        }\n    }\n    return $same;\n}", "  $diff = 0;\n\
    \  for ($i = 0; $i < strlen($s0); $i++) {\n    if ($s1[$i] != $s0[$i]) {\n   \
    \   $diff++;\n    }\n  }\n  return $diff <= strlen($s0) && $diff <= strlen($s1);\n\
    }\n", "    if (strlen($s0) != strlen($s1)) {\n        return false;\n    }\n \
    \   $len = strlen($s0);\n    for ($i = 0; $i < $len; ++$i) {\n        if ($s0[$i]\
    \ != $s1[$i]) {\n            return false;\n        }\n    }\n    return true;\n\
    }\n</code>\n<|/ a |>\n<| a tags=php,string dscore=2 |>\nThis solution was very\
    \ helpful to me.  I needed to compare the length of a string to the length of\
    \ the same string broken into chunks of 3 characters, in order to see if it were\
    \ a Palindrome.  I used the above function and modified it slightly to take into\
    \ account that the length of each string will vary.\n<code>", "    $i0 = 0;\n\
    \    $i1 = 0;\n    $same = 0;\n    while ($i0 < strlen($s0)) {\n        if ($s1[$i0]\
    \ != $s0[$i0]) {\n            $same++;\n        } else {\n            $i1++;\n\
    \        }\n        $i0++;\n    }\n    return $same == strlen($s0);\n}", "  $s0\
    \ = \"$s0\" . \"\"; // to make it string\n  $s1 = \"$s1\" . \"\"; // to make it\
    \ string\n  for ($i = 0; $i < min(strlen($s0), strlen($s1)); $i++) {\n    if ($s1[$i]\
    \ != $s0[$i]) {\n      return 0;\n    }\n  }\n  return (strlen($s0) == strlen($s1));\n\
    }", "    $n0 = strlen($s0);\n    $n1 = strlen($s1);\n\n    for($i = 0; $i < $n0;\
    \ $i++) {\n        for($j = $i; $j < $n1; $j++) {\n            if ($s1[$j] !=\
    \ $s0[$i]) {\n                return false;\n            }\n        }\n    }\n\
    \n    return true;\n}\n", "    $s0 = preg_replace('/[^a-zA-Z0-9\\s]/', '', $s0);\n\
    \    $s1 = preg_replace('/[^a-zA-Z0-9\\s]/', '', $s1);\n    return $s0 == $s1;\n\
    }\n", "    $s1 = strtolower($s1);\n    $s0 = strtolower($s0);\n    $length = min(strlen($s0),\
    \ strlen($s1));\n    for ($i = 0; $i < $length; $i++) {\n        if ($s1[$i] !=\
    \ $s0[$i]) {\n            return false;\n        }\n    }\n    return true;\n\
    }\n", "  if (!strlen($s0) || strlen($s1) != strlen($s0)) {\n    return false;\n\
    \  }\n  $a = $s0;\n  $b = $s1;\n  $c = $a;\n  $i = 0;\n  while ($i < strlen($b))\
    \ {\n    if ($a[$i] != $b[$i]) {\n      break;\n    }\n    $i++;\n  }\n  return\
    \ $i == strlen($b);\n}", "  // Check for same chars\n  $n1 = strlen($s1);\n  $n2\
    \ = strlen($s2);\n  $c = 0;\n  for($i=0; $i < $n1; $i++) {\n    if($s1[$i] ==\
    \ $s2[$i]) {\n      $c++;\n    }\n  }\n  return $c == $n1;\n}\n", "    $s0_len\
    \ = strlen($s0);\n    $s1_len = strlen($s1);\n    \n    for ($i = 0; $i < $s0_len;\
    \ $i++) {\n        if ($s1[$i] != $s0[$i]) {\n            return false;\n    \
    \    }\n    }\n    \n    return true;\n}", "    if ($s0 === $s1) return true;\n\
    \    $s0 = str_replace(\" \", \"\", $s0);\n    $s1 = str_replace(\" \", \"\",\
    \ $s1);\n    for ($i = 0; $i < max(strlen($s0), strlen($s1)); $i++) {\n      \
    \  if ($s1[$i] != $s0[$i]) return false;\n    }\n    return true;\n}\n", "   \
    \ $s0 = strtolower($s0);\n    $s1 = strtolower($s1);\n    if (strlen($s0) == strlen($s1))\
    \ {\n        return $s0 == $s1;\n    }\n    $s0 = str_replace('z', '', $s0);\n\
    \    $s1 = str_replace('z', '', $s1);\n    if (strlen($s0) == strlen($s1)) {\n\
    \        return $s0 == $s1;\n    }\n    if (strlen($s0) > strlen($s1)) {\n   \
    \     return false;\n    }\n    $s0 = str_replace(array(\"a\", \"b\"), array(1,\
    \ 2), $s0);\n    $s1 = str_replace(array(\"a\", \"b\"), array(1, 2), $s1);\n \
    \   if (strlen($s0) == strlen($s1)) {\n        return $s0 == $s1;\n    }\n   \
    \ return $s0 == $s1;\n}\n", "    $s_len = strlen($s0);\n    $t_len = strlen($s1);\n\
    \n    if ($s_len == $t_len) {\n        $count = 0;\n        for ($i=0; $i<$s_len;\
    \ $i++) {\n            if ($s1[$i] != $s0[$i]) {\n                return false;\n\
    \            }\n            $count++;\n        }\n        return $count == $s_len;\n\
    \    } else {\n        return false;\n    }\n}\n\n$fp = fopen(\"input.txt\", \"\
    r\");\nif ($fp) {\n    do {\n        $str = fgets($fp, 1024);\n        if ($str\
    \ !== false) {\n            $str = trim($str);\n            if (!is_numeric($str))\
    \ {\n                $strs = explode(\":\", $str);\n                $nm = $strs[0];\n\
    \                $ln = $strs[1];\n                $ln = trim($ln);\n         \
    \       $ln = substr($ln, 0, strlen($ln)-1);\n                $ln = ltrim($ln);\n\
    \                $num = 0;\n                $ln_length = strlen($ln);\n      \
    \          for ($i=0; $i<$ln_length; $i++) {\n                    $num += ord($ln[$i]);\n\
    \                }\n                $num = $num * (int) $nm;\n               \
    \ $num = $num / $nm;\n                echo $num;\n            }\n        }\n \
    \   } while ($str != false);\n}\nfclose($fp);\n</code>\n<|/ a tags=php,php-7.2,palindrome\
    \ dscore=0 |>\n<| c |>\nWhat about when you have 2 or more words?\n<|/ c |>\n\
    <| c |>\nI added a code to handle 2 or more words. Check it out and tell me if\
    \ it works.\n<|/ c |>\n<| c |>\nIt doesn't work: if the input is \"abc def\",\
    \ the output is \"abc\" not \"abc def\"\n<|/ c |>\n<| c |>\nI have updated my\
    \ code, now the output is abc def. Check it out and tell me if that's what you\
    \ wanted.\n<|/ c |>\n<| a tags=php,php-7.2,palindrome |>\n<code>", "  $s0 = strtr($s0,\
    \ \"aeiou\", \"AEIOU\");\n  $s1 = strtr($s1, \"aeiou\", \"AEIOU\");\n  return\
    \ strlen($s0) == strlen($s1) &&\n         strpos($s0, $s1) !== FALSE;\n}", " \
    \   $s0 = \"$s0\";\n    $s1 = \"$s1\";\n    $len = strlen($s0);\n    $len1 = strlen($s1);\n\
    \    if ($len != $len1) {\n        return false;\n    }\n    for ($i = 0; $i <\
    \ $len; $i++) {\n        if ($s1[$i] != $s0[$i]) {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n</code>\n<|/ a dscore=1 tags=javascript,php,algorithm\
    \ |>\n<| a dscore=1 |>\nIn case you don't need to validate each word (only characters)\
    \ in each of sentences, I suggest to split the strings and compare each of them\
    \ using Array.every.\n<code>\nconst strings = ['eabcdzzzz', 'dddzzzzzzzddeddabc'];\n\
    strings.every(\n  (str1, str2) => {\n    const len1 = str1.length;\n    const\
    \ len2 = str2.length;\n    return Array.from({length: len1}).every((_, i) => str1.charAt(i)\
    \ === str2.charAt(i));\n  }\n);\n</code>\n<|/ a tags=javascript,php,algorithm\
    \ |>\n<| a |>\nFor those who prefer the readable version\n<code>", "    $i0 =\
    \ array();\n    $i1 = array();\n    $k0 = array();\n    $k1 = array();\n\n   \
    \ // Scan through s0 word by word.\n    for ($i = 0; $i < strlen($s0); $i++) {\n\
    \        $k0[ord($s0[$i])]++;\n    }\n    // Scan through s1 word by word.\n \
    \   for ($i = 0; $i < strlen($s1); $i++) {\n        $k1[ord($s1[$i])]++;\n   \
    \ }\n    // Compare the two character counts.\n    if ($k0 != $k1) {\n       \
    \ return false;\n    }\n    // If two characters are the same, compare the corresponding\
    \ letters.\n    for ($i = 0; $i < strlen($s0); $i++) {\n        $i0[$k0[ord($s0[$i])]]++;\n\
    \        $i1[$k1[ord($s1[$i])]]++;\n    }\n    foreach ($i0 as $k => $v) {\n \
    \       if ($v != $i1[$k]) {\n            return false;\n        }\n    }\n  \
    \  return true;\n}\n", "  return preg_match('/[^'.$s0.']*'.$s0.'[^'.$s1.']*'.$s1.'/i',\
    \ $s1) === 0;\n}\n", "  $c0 = count_chars($s0);\n  $c1 = count_chars($s1);\n \
    \ return $c0 == $c1;\n}\n"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
