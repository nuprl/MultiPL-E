name: HumanEval_10_make_palindrome
language: php
prompt: "<?php\n// Find the shortest palindrome that begins with a supplied string.\n\
  // Algorithm idea is simple:\n// - Find the longest postfix of supplied string that\
  \ is a palindrome.\n// - Append to the end of the string reverse of a string prefix\
  \ that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\
  \"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\"\
  )\n// \"catac\"\nfunction make_palindrome($string) {\n"
tests: "function candidate(...$args) {\n    return make_palindrome(...$args);\n}\n\
  \nfunction test(): void {\n    if (candidate(\"\") !== \"\") { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(\"x\") !== \"x\") { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(\"xyz\") !== \"xyzyx\") { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(\"xyx\") !== \"xyx\") { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(\"jerry\") !== \"jerryrrej\") { throw new\
  \ Exception(\"Test failed!\"); }\n}\n\ntest();"
completions: ["    // No palindrome?\n    $str = trim($string);\n    if ($str == \"\
    \") return $string;\n    $strlen = strlen($str);\n    if ($strlen == 1) return\
    \ $str;\n    // The longest postfix of $str being a palindrome is itself.\n  \
    \  // So add $str to the beginning of $str, reverse the string, and return it.\n\
    \    $reversed_str = strrev($str);\n    return $str . $reversed_str;\n}\n", " \
    \ $palindrome = $string;\n  while (strlen($palindrome) < strlen($string)) {\n\
    \    $palindrome = strrev($palindrome) . $string;\n  }\n  return $palindrome;\n\
    }", "  $suffixes = get_longest_postfix_suffix($string);\n  $prefix = substr($string,\
    \ 0, strlen($string) - 1);\n  return $prefix . str_replace(array_reverse($suffixes),\
    \ $prefix);\n}", "  // find the longest postfix of string that is a palindrome\n\
    \  $string_palindrome = $string;\n  $str_length = strlen($string_palindrome);\n\
    \  while ($str_length > 0) {\n    $last_char = substr($string_palindrome, $str_length\
    \ - 1);\n    $string_palindrome = substr($string_palindrome, 0, $str_length -\
    \ 1);\n    if ($last_char == substr($string_palindrome, 0, $str_length / 2)) {\n\
    \      break;\n    }\n    $str_length = strlen($string_palindrome);\n  }\n\n \
    \ // append the reverse of the string prefix before the palindromic suffix\n \
    \ $string_palindrome .= strrev(substr($string_palindrome, 0, $str_length / 2));\n\
    \  $string_palindrome = trim($string_palindrome);\n  if ($string_palindrome ==\
    \ $string) {\n    return $string_palindrome;\n  }\n  return false;\n}\n", "  $longest\
    \ = find_longest($string);\n  return substr($string, 0, strrpos($string, $longest));\n\
    }\n", "  if ($string === '') {\n    return '';\n  }\n  $postfix = substr($string,\
    \ -1);\n  $postfix = strrev($postfix);\n  $prefix = substr($string, 0, -1);\n\
    \  $prefix = strrev($prefix);\n  return $prefix . $postfix;\n}\n", "  // 1. Find\
    \ the longest postfix of supplied string that is a palindrome\n  $length = strlen($string);\n\
    \  $suffix = '';\n  for ($i = $length - 1; $i >= 0; $i--) {\n    $suffix = $string[$i]\
    \ . $suffix;\n    if ($suffix == substr($string, $i)) {\n      break;\n    }\n\
    \  }\n\n  // 2. Append to the end of the string reverse of a string prefix that\
    \ comes before the palindromic suffix\n  $result = $string;\n  for ($i = 0; $i\
    \ < $length; $i++) {\n    $result = $string[$i] . $result;\n  }\n  return $result\
    \ . $suffix;\n}\n", "    // The longest postfix that is a palindrome\n    $pal_postfix\
    \ = substr($string, -1);\n    // Reverse of postfix of supplied string\n    $pal_reverse\
    \ = strrev($pal_postfix);\n    // Append the reverse of the postfix to the supplied\
    \ string\n    return $string.$pal_reverse;\n}\n", "    if (strlen($string) ==\
    \ 0) {\n        return $string;\n    }\n\n    $max_length = strlen($string) -\
    \ 1;\n    $max_length_palindrome = strlen(substr($string, 0, $max_length));\n\
    \    $substring = substr($string, 0, $max_length);\n\n    if ($max_length_palindrome\
    \ == 0) {\n        return $substring;\n    }\n\n    $string_to_reverse = substr($string,\
    \ $max_length);\n    $string_to_reverse_palindrome = substr($string_to_reverse,\
    \ 0, $max_length_palindrome);\n    $result = substr($substring, 0, -1 * $max_length_palindrome).$string_to_reverse_palindrome;\n\
    \n    return $result;\n}\n", "    $postfix = substr($string, -1);\n    $reverse\
    \ = strrev($postfix);\n    $prefix = substr($string, 0, -1);\n    return $prefix\
    \ . $reverse;\n}\n</code>\n<|/ a tags=palindrome,algorithm,php dscore=5 |>\n<|\
    \ c |>\nIt is a very nice implementation. However there is a problem in the PHP\
    \ version due to the `strrev()` function, which returns reversed string with a\
    \ fixed size. Here is a small bug that can lead to undefined behavior in case\
    \ when the `$string` is longer than the size of the reversed string.\n<|/ c |>\n\
    <| c |>\n: That's true. The strrev function does have one parameter: string $string,\
    \ int $length which is not always enough. Though we can fix the issue by increasing\
    \ the length parameter to twice of the string's length. The same can happen in\
    \ the PHP version: `strrev` can return incorrect result if the string passed as\
    \ a parameter is too long to reverse (for example in the case of `$string = 'a'\
    \ * 20000;` - reversing `'a' * 20120;` gives correct result, while reversing `$string\
    \ = 'a' * 20100;` gives incorrect result). So we can fix this bug easily just\
    \ by adding this two lines: `if ($length > strlen($reverse)) $length = strlen($reverse);`\
    \ and `$length = ceil($length / 2);` before calling `strrev`.\n<|/ c |>\n<| a\
    \ tags=palindrome,algorithm,php |>\nHere is my palindrome code in JavaScript for\
    \ reference:\n<code>", "    if ($string === \"\") {\n        return $string;\n\
    \    }\n\n    $prefix = substr($string, 0, strlen($string) - 1);\n    if (substr($string,\
    \ -1) !== $prefix) {\n        $string .= $prefix;\n    }\n\n    return $string;\n\
    }\n", "  // Step 1: Find the longest postfix string that is a palindrome.\n  //\
    \ This is done by scanning backwards from end for occurrences of character\n \
    \ // that is not a palindrome.\n  $max_postfix_length = strlen($string) - 1;\n\
    \  for ($i = strlen($string) - 1; $i >= 0; $i--) {\n    if (!is_palindrome($string\
    \ . $string[$i])) {\n      $max_postfix_length = $i;\n      break;\n    }\n  }\n\
    \  $postfix = substr($string, 0, $max_postfix_length);\n  // Step 2: Append the\
    \ reverse of the postfix string to the end of the string.\n  $reverse = strrev($postfix);\n\
    \  return $string . $reverse;\n}", "    $longer_prefix = substr($string, 0, -1);\n\
    \    $longer_prefix = substr($longer_prefix, 0, strrpos($longer_prefix, \"\"));\n\
    \n    $longer_suffix = substr($string, -1);\n    $longer_suffix = substr($longer_suffix,\
    \ 0, strrpos($longer_suffix, \"\"));\n\n    $reversal = str_reverse($longer_prefix)\
    \ . $longer_suffix;\n\n    return $reversal;\n}", "    $is_palindrome = TRUE;\n\
    \    $length      = strlen($string);\n    $max_postfix = $length - 1;\n    $max_suffix\
    \  = 0;\n\n    for($i = 0; $i <= $max_postfix; $i++) {\n        $postfix = substr($string,\
    \ $i, 1);\n\n        if($postfix != $string[$length - $i]) {\n            $is_palindrome\
    \ = FALSE;\n            break;\n        }\n    }\n\n    if($is_palindrome) {\n\
    \        $max_suffix = $length - strlen(substr($string, $max_postfix, 1));\n\n\
    \        if($max_suffix < $max_postfix) {\n            $is_palindrome = FALSE;\n\
    \        }\n    }\n\n    if(!$is_palindrome) {\n        return FALSE;\n    }\n\
    \n    return $string . str_repeat(substr($string, 0, $max_suffix), $max_postfix)\
    \ . str_repeat(substr($string, $max_postfix, $length), $max_suffix);\n}\n", " \
    \ $prefix_length = strlen($string);\n  for ($i = 0; $i < $prefix_length; $i++)\
    \ {\n    $reverse_string = strrev($string);\n    if ($string[$i] != $reverse_string[$i])\
    \ {\n      return $string.$reverse_string;\n    }\n  }\n  return $string;\n}\n",
  "  if (empty($string)) return \"\";\n  $length = strlen($string);\n  if ($length\
    \ == 1) return $string;\n\n  // Find longest (longest = longest * 2 + 1) prefix\n\
    \  $prefixes = array();\n  for ($i = 0; $i < $length; $i++) {\n    $prefixes[]\
    \ = $string[$i];\n  }\n  $longest = array_reduce($prefixes, function($previous,\
    \ $current) {\n    return max($previous * 2, $current);\n  });\n\n  // Find the\
    \ palindromic suffix\n  $suffixes = array();\n  for ($i = $length - 1; $i >= 0;\
    \ $i--) {\n    $suffixes[] = $string[$i];\n  }\n  $longest = array_reduce($suffixes,\
    \ function($previous, $current) {\n    return max($previous * 2, $current);\n\
    \  });\n\n  // Append to the end of the string reverse\n  return $prefix . strrev($suffix);\n\
    }", "  $palindrome = \"\";\n  $max_len = 0;\n  $min_len = strlen($string);\n\n\
    \  // Find longest palindrome suffix\n  for ($i = 0; $i < $min_len; $i++) {\n\
    \    $suffix = substr($string, $i, $min_len - $i);\n    if (strlen($suffix) >\
    \ $max_len) {\n      $max_len = strlen($suffix);\n      $palindrome = $suffix;\n\
    \    }\n  }\n  // Append reverse of string prefix that is before palindromic suffix.\n\
    \  $palindrome .= substr($string, 0, $max_len);\n  return $palindrome;\n}\n",
  "    $palindrome = array();\n    foreach(str_split($string) as $letter) {\n    \
    \    // Find the suffix that is a palindrome.\n        $palindrome_suffix = find_palindrome_suffix($letter,\
    \ $string);\n        if ($palindrome_suffix != FALSE) {\n            $palindrome[]\
    \ = $palindrome_suffix;\n        }\n        // Find the prefix that comes before\
    \ the suffix.\n        $palindrome_prefix = find_palindrome_prefix($letter, $string);\n\
    \        if ($palindrome_prefix != FALSE) {\n            $palindrome[] = reverse_string($palindrome_prefix);\n\
    \        }\n    }\n    $palindrome = array_unique($palindrome);\n    return implode($palindrome);\n\
    }\n", "  $length = strlen($string);\n  if ($length < 2) {\n    return $string;\n\
    \  }\n  $longest_postfix_length = find_longest_palindrome_postfix($string);\n\
    \  assert($longest_postfix_length >= 0);\n  $reversed_string_prefix = substr($string,\
    \ 0, $longest_postfix_length);\n  return substr($string, 0, $longest_postfix_length)\
    \ . str_rev($reversed_string_prefix);\n}\n", "  $len   = strlen($string);\n  $max\
    \   = 0;\n  $palindrome = \"\";\n  for ($i = 0; $i < $len; $i++) {\n    $palindrome\
    \ .= $string[$i];\n    $reversed = strrev($string);\n    $max = max(strlen($reversed),\
    \ $max);\n    if ($reversed[$i] == $string[$i]) {\n      $reversed = substr($reversed,\
    \ 0, $i) . $palindrome . substr($reversed, $i);\n      $palindrome = substr($reversed,\
    \ 0, $max);\n    } else {\n      $palindrome .= $string[$i];\n    }\n  }\n  return\
    \ $palindrome;\n}\n", "    if (empty($string)) {\n        return $string;\n  \
    \  }\n\n    $postfix = substr($string, -1);\n    $reverse = str_replace(substr($string,\
    \ 0, -1), \"\", $string);\n\n    return $string . $postfix . $reverse;\n}", " \
    \   $string = str_replace(',', '', $string);\n\n    $length_of_string = $string[strlen($string)-1];\n\
    \n    $suffix = '';\n    for ($i = strlen($string)-2; $i >= 0; $i--) {\n     \
    \   $suffix .= $string[$i];\n    }\n    $prefix = substr($string, 0, $i);\n  \
    \  $palindrome_length = (strlen($prefix) + strlen($suffix)) -1;\n\n    while (strlen($string)\
    \ < $palindrome_length) {\n        $string = $string+str_repeat($string[0], strlen($string)/$palindrome_length);\n\
    \    }\n\n    $string = str_replace(\" \", \"\", $string);\n    $string = str_replace(',',\
    \ '', $string);\n\n    return $prefix.$string.$suffix;\n}\n", "    // Create a\
    \ palindromic string\n    $pal = $string;\n    $pal_len = 0;\n    // Find the\
    \ longest prefix of $pal that is palindromic\n    for ($i = 0; $i < strlen($pal);\
    \ $i++) {\n        $pal_len++;\n        for ($j = $pal_len - 1; $j > 0; $j--)\
    \ {\n            if ($pal[$i] != $pal[$j]) {\n                break;\n       \
    \     }\n        }\n        // Add the reversed prefix to the palindromic string\n\
    \        $pal .= $pal[$j];\n    }\n    return $pal;\n}\n", "  $postfix = $string;\n\
    \  while (strlen($postfix) > 1) {\n    $postfix = substr($postfix, 0, -1); //\
    \ -1 because we don't want to get rid of its last char.\n    if (palindrome($postfix))\
    \ {\n      return $postfix . $reverse($postfix);\n    }\n  }\n  return $postfix;\n\
    }\n</code>\n<|/ a tags=php,algorithm,string |>\n<| a dscore=2 |>\nI created two\
    \ functions, one for checking palindrome and another for reversing a string given\
    \ two strings.\n<code>", "  if(strlen($string) == 0) return \"\";\n  $reversed\
    \ = \"\";\n  $postfix = \"\";\n  $length = strlen($string);\n\n  // Find the longest\
    \ postfix of supplied string that is a palindrome.\n  for($i = 0; $i < $length;\
    \ $i++) {\n    $postfix .= $string[$i];\n  }\n\n  // Append to the end of the\
    \ string reverse of a string prefix that comes before the palindromic suffix.\n\
    \  for($i = 0; $i < $length; $i++) {\n    $reversed .= substr($string, 0, $length\
    \ - $i + 1);\n  }\n\n  // Reverse the palindrome by appending it to reversed.\n\
    \  $reversed .= $postfix;\n\n  // Return post reversed string.\n  return $reversed;\n\
    }", "    $palindrome = $string;\n\n    // Find the longest postfix that is a palindrome.\n\
    \    $postfix = substr($palindrome, 0, strrpos($palindrome, $string[0]));\n  \
    \  if ($string !== $postfix) {\n        $palindrome .= make_palindrome(substr($string,\
    \ strlen($postfix, 1)));\n    }\n\n    // Append the reverse of the postfix to\
    \ the end of the palindrome.\n    $palindrome .= strrev(substr($postfix, 1));\n\
    \n    return $palindrome;\n}\n</code>\nThe PHP code above is a direct translation\
    \ of the pseudo-code in the Wikipedia article on Longest palindromic substring.\
    \ Here are some tests for its correctness:\n<code>\nassert(make_palindrome(\"\
    a\") == \"a\");\nassert(make_palindrome(\"ab\") == \"ab\");\nassert(make_palindrome(\"\
    abc\") == \"abc\");\nassert(make_palindrome(\"abcd\") == \"abcd\");\nassert(make_palindrome(\"\
    abba\") == \"abba\");\nassert(make_palindrome(\"abbaa\") == \"abba\");\nassert(make_palindrome(\"\
    abbab\") == \"abba\");\nassert(make_palindrome(\"abbaba\") == \"abba\");\nassert(make_palindrome(\"\
    abbabab\") == \"abbab\");\nassert(make_palindrome(\"abbababa\") == \"abbab\");\n\
    assert(make_palindrome(\"abbababba\") == \"abbab\");\nassert(make_palindrome(\"\
    abbababbaa\") == \"abbab\");\nassert(make_palindrome(\"abbababbaab\") == \"abbab\"\
    );\nassert(make_palindrome(\"abbababbaaba\") == \"abbab\");\nassert(make_palindrome(\"\
    abbababbaabaa\") == \"abbab\");\nassert(make_palindrome(\"abbababbaabaaa\") ==\
    \ \"abbab\");\nassert(make_palindrome(\"abbababbaabaaab\") == \"abbab\");\nassert(make_palindrome(\"\
    abbababbaabaaaab\") == \"abbab\");\nassert(make_palindrome(\"abbababbaabaaaabb\"\
    ) == \"abbab\");\nassert(make_palindrome(\"abbababbaabaaaabbba\") == \"abbab\"\
    );\nassert(make_palindrome(\"abbababbaabaaaabbbaa\") == \"", "    $string = strtolower($string);\n\
    \    $palindrome = \"\";\n    $postfix = \"\";\n    foreach (str_split($string)\
    \ as $character) {\n        $postfix = $postfix . $character;\n        if ($character\
    \ != $postfix) {\n            $palindrome = $palindrome . $character;\n      \
    \  }\n    }\n    return $palindrome . $reverse($postfix);\n}\n", "  $palindrome\
    \ = $string;\n  for ($i = 0; $i < strlen($string); $i++) {\n    $reversed_string\
    \ = strrev($palindrome);\n    if (strstr($palindrome, $reversed_string) !== FALSE)\
    \ {\n      $palindrome = substr_replace(\n        $string,\n        $reversed_string,\n\
    \        $i,\n        strlen($palindrome) - $i\n      );\n    }\n  }\n  return\
    \ $palindrome;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis won't work for `hello`,\
    \ for example, since the longest palindrome would be `hallo` and you remove `e`\n\
    <|/ c |>\n<| c |>\nI appreciate the response. While the answer may be the only\
    \ way to solve this problem, the fact that my initial question was to find a palindrome\
    \ of a string and to find the palindromes themselves, this answer has proven to\
    \ be most useful for me. I tested the code and it appears to do just what I need\
    \ it to.\n<|/ c |>\n<| c |>\nGlad this was useful. Sorry it took so long to respond.\
    \ I was working with some time constraints and I didn't have a chance to try the\
    \ code on `hello`.\n<|/ c |>\n<| a tags=palindrome,php |>\nI ran the below code\
    \ on my local server (WAMP Server) and I got the desired result\n<code>\n$string\
    \ = \"cat\";\nif (preg_match(\"/^([a-z])+$/\",$string))\n{\n$reversed_string =\
    \ strrev($string);\nif (preg_match(\"/$reversed_string/\",$string))\n{\n$palindrome\
    \ = substr($string, strlen($string) - strlen($reversed_string), strlen($string));\n\
    }\n}\necho $palindrome;\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nI see that\
    \ there are already many posts with palindrome-questions here but I also want\
    \ to share my way of checking palindromes. I've tried to make it as simple as\
    \ possible:\n<code>", "    // Get prefix of string that is a palindrome.\n   \
    \ $postfix_length = get_longest_palindrome_postfix($string);\n    $postfix_string\
    \ = $string;\n    if ($postfix_length != strlen($string)) {\n        $postfix_string\
    \ = substr($postfix_string, 0, $postfix_length);\n    }\n    $postfix_string =\
    \ strrev($postfix_string);\n\n    // Append to end of string reverse of string\
    \ prefix that comes before the palindromic suffix.\n    $final_string = strrev($postfix_string)\
    \ . $string;\n\n    return $final_string;\n}", "    $ls = strlen($string);\n \
    \   if ($ls > 1) {\n        $prefix_length = 0;\n        while ($ls > $prefix_length\
    \ && !($string[$prefix_length] == $string[$prefix_length / 2])) {\n          \
    \  $prefix_length++;\n        }\n        if ($prefix_length) {\n            $prefix_length\
    \ /= 2;\n            $suffix = substr($string, -$prefix_length);\n           \
    \ $string = substr($string, 0, -$prefix_length) . strrev($suffix);\n        }\n\
    \    }\n    return $string;\n}\n</code>\n<|/ a tags=php,algorithm |>\n<| a |>\n\
    My answer is based on this answer:\nThe solution to this problem will consist\
    \ of using dynamic programming.\nHere's a breakdown of how to solve it:\n\nCreate\
    \ 2 arrays, one for storing the palindrome and one for storing the suffix of the\
    \ given string\nGo through the given string and check if it's palindromic by appending\
    \ the suffix of the string to the palindrome array\nDo the same process again\
    \ and append the suffix of the string to the palindrome array\nRepeat this process\
    \ until there is no more suffix\n\nYou now have the palindrome array and suffix\
    \ array. Iterate through both arrays, check if the strings in the palindrome array\
    \ are palindromic, if not then print an error message saying that the string is\
    \ not a palindromic string. Repeat from step 2\n\nThis approach uses O(n) space\
    \ and O(1) time.\nCode:\n<code>\n<?php", "    $longest = find_longest_palindrome_prefix($string);\n\
    \    $result = $string . $reverse($string, $longest);\n    return $result;\n}\n",
  "    $max_len = max(strlen($string), strlen(implode($string, str_split($string,\
    \ -1))));\n    for ($i = 0; $i < $max_len; $i++) {\n        if (strrev($string)\
    \ == implode($string, str_split(strrev($string), -1))) {\n            return substr($string,\
    \ 0, $i).strrev(substr($string, $i));\n        }\n    }\n    return $string;\n\
    }\n", "    $len = strlen($string);\n    if ($len < 2) {\n        return $string;\n\
    \    }\n    $prefix_suffix = substr($string, 0, -1);\n    $postfix_suffix = substr($string,\
    \ -1);\n    $reversed_postfix_suffix = strrev($postfix_suffix);\n\n    $possible_postfix_palindrome\
    \ = $prefix_suffix . $reversed_postfix_suffix;\n    return $possible_postfix_palindrome;\n\
    }\n", "  // Find the longest postfix of supplied string that is a palindrome.\n\
    \  // Assume that strings with non-alphanumeric chars are palindromes.\n  $l =\
    \ 0;\n  while ($string[$l] === ' ')\n    $l++;\n  $l = strlen($string) - $l;\n\
    \  $l = max(1, $l);\n  $r = $l;\n  $found = false;\n  $s = \"\";\n  while ($r\
    \ > 0) {\n    $s = substr($string, 0, $r + 1) + substr($string, $r + 1, $l) +\
    \ $s;\n    if (substr($string, $r, 1) === substr($string, $r - 1, 1))\n      $found\
    \ = true;\n    $r--;\n  }\n  // Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n  $string = $string;\n  while\
    \ ($found) {\n    if (substr($string, 0, $r) === substr($string, 0, $r - 1))\n\
    \      $string = substr($string, 0, $r - 1) + $s . substr($string, $r - 1, 1);\n\
    \    else\n      $string = substr($string, 0, $r) + $s . substr($string, $r, 1);\n\
    \    $found = false;\n    $r--;\n  }\n  return $string;\n}\n", "    $length  =\
    \   strlen($string);\n    $postfix =   \"\";\n    $reverse  =   \"\";\n    $postfix\
    \ =   strrev($string);\n    $start    =   strpos($postfix, $string);\n    $length\
    \   =   strlen($postfix);\n    while($start >= 0){\n        $reverse   .=   substr($postfix,\
    \ 0, $start);\n        $postfix =   substr($postfix, $start);\n        $start\
    \    =   strpos($postfix, $string);\n        $length   =   strlen($postfix);\n\
    \    }\n    $reverse   .=   $postfix;\n    return $reverse;\n}\n", "  $l = 0;\n\
    \  $r = strlen($string) - 1;\n  $longest = 0;\n  $palindrome = \"\";\n  while\
    \ (isPalindromic($string[$l], $string[$r])) {\n    $palindrome .= $string[$l];\n\
    \    $longest = max($longest, strlen($palindrome));\n    $l++;\n    $r--;\n  }\n\
    \  return $palindrome . $string[$l] . str_repeat($string[$r], $longest);\n}\n",
  "    $string = preg_replace('/[[:^alpha:]]/', '', strtolower($string));\n    if\
    \ (strlen($string) === 1) {\n        return $string;\n    }\n\n    $postfix_lengths\
    \ = count_postfix_lengths($string);\n    foreach ($postfix_lengths as $postfix_length\
    \ => $count) {\n        $palindrome = substr($string, 0, $postfix_length);\n \
    \       $palindrome_length = strlen($palindrome);\n        if ($palindrome_length\
    \ <= 1) {\n            continue;\n        }\n\n        $reverse_string = substr($palindrome,\
    \ 1, $palindrome_length);\n        $reverse_string = strrev($reverse_string);\n\
    \n        $reversed_string = $reverse_string . $palindrome;\n\n        if ($string\
    \ === $reversed_string) {\n            return $string;\n        }\n    }\n\n \
    \   return $string;\n}\n", "    $palindrome = '';\n    $suffix = '';\n    for\
    \ ($i = 0, $strLen = strlen($string); $i < $strLen; $i++) {\n        $suffix =\
    \ $suffix . $string[$i];\n        $reversed_suffix = strrev($suffix);\n      \
    \  if ($suffix === $reversed_suffix) {\n            $palindrome = $palindrome\
    \ . $reversed_suffix;\n            $suffix = $reversed_suffix;\n        } else\
    \ {\n            $suffix = $reversed_suffix;\n        }\n    }\n    return $palindrome;\n\
    }\n", "    $reverse_string = \"\";\n    $is_first = true;\n\n    while (strlen($string)\
    \ > 0) {\n        $reverse_string .= substr($string, -1);\n        $string = substr($string,\
    \ 0, -1);\n        if ($is_first) {\n            $is_first = false;\n        \
    \    $string .= $reverse_string;\n        } else {\n            $string .= $reverse_string\
    \ . $string;\n        }\n    }\n    return $string;\n}\n\n$reverse_substring =\
    \ make_palindrome($string);\necho $reverse_substring;\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nIt does not work:\n\nmake_palindrome(\"racecar\") gives rcarracec\n\
    <|/ c |>\n<| a tags=algorithm,palindrome,php |>\n<code>", "    $length = strlen($string);\n\
    \    if ($length <= 1) return $string;\n\n    // Find the longest postfix string\
    \ which is a palindrome\n    $prefix   = $string;\n    $suffix   = $string;\n\
    \    $suffixLen = $length;\n    while (--$suffix)\n        $suffixLen--;\n   \
    \ $suffixLen = $length - $suffixLen;\n    $longestPalindrome = $prefix . str_repeat(\n\
    \        '*',\n        $suffixLen + 1\n    ) . substr($string, 0, $suffixLen);\n\
    \n    // Append the reverse of the suffix string to the end of the supplied string\n\
    \    return $string . $suffix . str_repeat(\n        '*',\n        $length - ($suffixLen\
    \ + 1)\n    ) . $longestPalindrome;\n}\n", "    $reverse = strrev($string);\n\
    \    $string = $string;\n    return $string.$reverse;\n}\n", "  $reversed_string\
    \ = $string;\n  $reverse_length = strlen($string);\n  for ($i = 0; $i < $reverse_length;\
    \ $i++) {\n    $reversed_string = strrev($reversed_string);\n  }\n  return $string\
    \ . $reversed_string;\n}", "    // Palindrome check\n    $longest_postfix_length\
    \ = 0;\n    for ($i = strlen($string); $i >= 0; $i--) {\n        // Find longest\
    \ palindrome suffix beginning with $string[$i]\n        $longest_postfix_length\
    \ = $i >= $longest_postfix_length ? $i : $longest_postfix_length;\n    }\n\n \
    \   $result = substr($string, 0, $longest_postfix_length) . str_rev(substr($string,\
    \ 0, $longest_postfix_length));\n    if (strcasecmp($string, $result) != 0) {\n\
    \        throw new Exception(\"The supplied string is not a palindrome\");\n \
    \   }\n\n    return $result;\n}", "  $strings = array($string);\n  while (true)\
    \ {\n    $palindromes = array();\n    $length = strlen($string);\n    for ($i\
    \ = 0; $i < $length; $i++) {\n      $candidate = substr($string, 0, $length -\
    \ $i);\n      if (preg_match('/^(.)\\1$/', $candidate, $palindromes) === 1) {\n\
    \        $palindromes[$i] = $palindromes[$i];\n      }\n    }\n    if (count($palindromes)\
    \ === 1) {\n      return $palindromes[0];\n    }\n    $strings[] = implode('',\
    \ array_reverse($palindromes));\n  }\n}", "  if (!is_string($string)) return;\n\
    \n  // Create a map of characters we've seen so we know how far to go with them\n\
    \  // and how many times to look at them to get the answer\n  $characters = array_fill_keys(str_split($string),\
    \ 1);\n\n  // Build the string backwards and look it up\n  $string_reversed =\
    \ strrev($string);\n  $palindrome_index = strrpos($string_reversed, $string) +\
    \ strlen($string);\n\n  // Do the first part of the string backwards\n  for ($i\
    \ = 0; $i <= $palindrome_index; $i++) {\n    $characters[$string[$i]] += $i;\n\
    \  }\n\n  // Now start checking the rest of the string forwards\n  for ($i = $palindrome_index;\
    \ $i >= 0; $i--) {\n    $characters[$string[$i]] += $i;\n  }\n\n  // Look for\
    \ the longest palindrome that starts with the first character\n  $palindrome =\
    \ '';\n  $max_length = 0;\n  foreach ($characters as $character => $occurrence)\
    \ {\n    if ($occurrence > $max_length) {\n      $palindrome = $character;\n \
    \     $max_length = $occurrence;\n    }\n  }\n\n  // Add this character to the\
    \ end of the string and reverse the string\n  return $string . $palindrome . strrev($string);\n\
    }", "  return str_replace($string, strrev($string).$string, $string);\n}\n</code>\n\
    <|/ a tags=php dscore=0 |>\n<| c |>\nThanks so much for this. I will definitely\
    \ keep this in mind when I am coding my next challenge. Much appreciated and really\
    \ appreciate the code you posted.\n<|/ c |>\n<| c |>\nI wanted to let you know\
    \ that your solution didn't quite work for my needs. The solution by is what I\
    \ was looking for but I think it might work better for my needs. I am sure your\
    \ solution is very helpful though. Again, thanks so much!\n<|/ c |>\n<| a |>\n\
    <code>\n<?php\n$palindrome=array();\n$palindrome['h','e','l','l','o'];\n$palindrome['e','l','o'];\n\
    $palindrome['l','o'];\n$palindrome['o'];\n$palindrome['l','o','h'];\n$palindrome['e','l','o','h'];\n\
    $palindrome['l','o','h'];\n$palindrome['o','h'];\n$palindrome['h'];\n$palindrome['e','l','o','h'];\n\
    $palindrome['l','o','h'];\n$palindrome['o','h'];\n$palindrome['h'];\n$palindrome['e','l','o','h'];\n\
    $palindrome['l','o','h'];\n$palindrome['o','h'];\n$palindrome['h'];\n$palindrome['e','l','o','h'];\n\
    $palindrome['l','o','h'];\n$palindrome['o','h'];\n$palindrome['h'];\n$palindrome['e','l','o','h'];\n\
    $palindrome['l','o','h'];\n$palindrome['o','h'];\n$palindrome['h'];\n$palindrome['e','l','o','h'];\n\
    $palindrome['l','o','h'];\n$palindrome['o','h'];\n$palindrome['h'];\n$palindrome['e','",
  "    $string = strrev($string);\n    $i = 1;\n    while (strlen($string) > strlen($string.$string.$string))\
    \ {\n        $string = substr($string, 0, -1) . $string;\n        $i++;\n    }\n\
    \    return $string;\n}\n\n$a = \"\";\nif (isset($_POST[\"submit\"])) {\n    $a\
    \ = make_palindrome($_POST[\"string\"]);\n}\necho \"<form action='index.php' method='post'>\"\
    ;\necho \"<input type='text' name='string' value='$a' />\";\necho \"<input type='submit'\
    \ name='submit' value='Make Palindrome' />\";\necho \"</form>\";", "    $string\
    \ = (string)$string;\n    if (empty($string)) {\n        return '';\n    }\n\n\
    \    // Find longest palindrome of a string.\n    // We can use brute-force approach\
    \ to find it. We will use it to compare prefix and suffix to find the largest\
    \ suffix.\n    // For example we suppose we found palindrome \"cata\" with suffix\
    \ \"tac\". We will use it to find \"cata\".\n    // We have two such palindromes:\
    \ \"cata\" and \"tac\".\n    // We need to find longest palindrome with prefix\
    \ \"cat\". Let's use cata to find longest palindrome with prefix \"cata\".\n \
    \   $palindrome = strrev($string);\n    $length = strlen($string);\n    $longestPalindrome\
    \ = substr($string, 0, $length-1);\n\n    // Let's compare prefix and suffix to\
    \ find the largest suffix.\n    while (strlen($string) > 0 && strlen($palindrome)\
    \ > 0 && $palindrome !== $longestPalindrome) {\n        $palindrome = substr($string,\
    \ 0, $length-1);\n        $length = strlen($string);\n        $longestPalindrome\
    \ = substr($string, 0, $length-1);\n    }\n\n    $palindrome = (string)$palindrome;\n\
    \n    // Concatenate longest palindrome with longest prefix of the supplied string\n\
    \    return $string . $longestPalindrome;\n}\n</code>\n<|/ a tags=php,palindrome\
    \ |>\n<| c |>\nThis is just amazing! I've never seen this type of approach before\
    \ and I like how it works. Thank you so much! I was banging my head against the\
    \ wall trying to find a solution like this one. This solved my problem.\n<|/ c\
    \ |>\n<| c |>\n, I've added some comments in the code (look for comments above\
    \ \"// Find longest palindrome of a string\"). Also I've added some comments in\
    \ the description of algorithm itself. Now it should be easier to understand how\
    \ it works.\n<|/ c |>\n<| c |>\nAwesome explanation. Thank you again! I wish there\
    \ was more like this.\n<|/ c |>\n<| c |>\nThis solution will fail if the string\
    \ has special characters like '!' and '.', because the special character will\
    \ affect the string length.\n<|/ c |>\n<| c |>\nThis can be done by changing the\
    \ string encoding like so: `$string = (string)mb_convert_encoding($string, 'ASCII',\
    \ 'UTF-8", "    $prefix = substr($string, 0, -1);\n    $suffix = substr($string,\
    \ -1, 1);\n\n    if ($prefix === $suffix) {\n        return $string;\n    }\n\n\
    \    $palindrome = substr($string, 0, -1);\n    $palindrome_reverse = strrev($palindrome);\n\
    \n    return $palindrome . $palindrome_reverse;\n}", "  $postfix = substr($string,\
    \ -1);\n  $palindrome = substr($string, 0, -1);\n  while (substr($palindrome,\
    \ 0, -1) == $postfix) {\n    $palindrome .= str_repeat(substr($postfix, 0, -1),\
    \ strlen($postfix));\n    $postfix = substr($postfix, -1);\n  }\n  return $palindrome\
    \ . $postfix;\n}\n", "    if (empty($string)) {\n        return \"\";\n    }\n\
    \    // Find the longest palindrome of $string that is a palindrome.\n    $postfix\
    \ = $string;\n    for ($i = strlen($string) - 1; $i >= 0; $i--) {\n        if\
    \ (substr($postfix, 0, $i) === substr($string, 0, $i)) {\n            $postfix\
    \ = substr($postfix, 0, $i) . $string[$i];\n        }\n    }\n    return $postfix;\n\
    }", "    $len = strlen($string);\n    $revstring = \"\";\n    $postfix = \"\"\
    ;\n    $postfix_len = 0;\n    \n    for ($i = 0; $i < $len; $i++) {\n        $postfix[$i]\
    \ = $string[$i];\n        if ($postfix_len > 0) {\n            $revstring .= $postfix[$postfix_len];\n\
    \            $postfix_len = 0;\n        }\n        if ($i < $len - 1) {\n    \
    \        if ($string[$i] == $string[$i + 1]) {\n                $postfix_len++;\n\
    \            } else {\n                $postfix_len = 0;\n            }\n    \
    \    }\n    }\n    \n    $postfix[$postfix_len] = $string[$len-1];\n    \n   \
    \ for ($i = 0; $i < $len - 2; $i++) {\n        $revstring .= $postfix[$i];\n \
    \   }\n    \n    return $revstring;\n}\n\n$test = \"test\";\necho \"test is a\
    \ palindrome: \" . isPalindrome($test) . \"\\n\";\necho \"Test is a palindrome:\
    \ \" . isPalindrome($test) . \"\\n\";\necho \"Test is NOT a palindrome: \" . (!isPalindrome($test))\
    \ . \"\\n\";\n", "    $length = get_palindrome_length($string);\n\n    if ($length\
    \ == 0) {\n        return $string;\n    }\n\n    $str1 = substr($string, 0, $length\
    \ - 1);\n    $str2 = substr($string, $length - 1);\n\n    return $str1 . $str2\
    \ . $string;\n}\n", "    if ($string == \"\") return \"\";\n    $palindrome =\
    \ strrev($string);\n    $palindrome = strrev($palindrome);\n    $palindrome .=\
    \ substr($string, 0, strlen($string) - 1);\n    return $palindrome;\n}\n", " \
    \   if (strlen($string) < 2) return $string;\n    if (strlen($string) == 1) return\
    \ $string;\n    $palindrome = $string;\n    $reverse = '';\n    $len = strlen($string);\n\
    \    for ($i = 0; $i < $len; $i++) {\n        $reverse = $string.$reverse;\n \
    \       $palindrome = $string.$palindrome;\n    }\n    $reverse = strrev($reverse);\n\
    \    $palindrome = $palindrome.$reverse;\n    return $palindrome;\n}\n", "  $prefix_length\
    \ = strlen($string);\n  $suffix = str_reverse($string);\n  $palindrome_length\
    \ = strlen($string) - $prefix_length;\n  for ($p = 1; $p < $palindrome_length;\
    \ $p++) {\n    $string = $string.$suffix.substr($string, $prefix_length);\n  }\n\
    \  return $string;\n}", "  $longest_postfix = find_longest_postfix_substr($string);\n\
    \  return $longest_postfix . $string . reverse_substr($longest_postfix);\n}\n",
  "    $length       = strlen($string);\n    $longest_post = find_longest_postfix_palindrome($string);\n\
    \    if ($length > $longest_post) {\n        $suffix         = substr($string,\
    \ $longest_post, $length);\n        $reverse_suffix = '' . strrev($suffix);\n\
    \        $palindrome     = $string . $reverse_suffix;\n        $reverse_prefix\
    \ = substr($string, 0, $longest_post);\n        $prefix         = $reverse_prefix\
    \ . $reverse_suffix;\n        return $prefix . $palindrome;\n    }\n    return\
    \ $string;\n}\n", "    // Create a reversed version of the string that does not\
    \ contain any palindrome prefix.\n    // Then find the palindrome suffix of the\
    \ reversed string.\n    // If the palindrome suffix is shorter than the reversed\
    \ string then it is impossible to create one.\n    // >>> make_palindrome(\"cata\"\
    )\n    // \"cata\"\n    $reversed = strrev($string);\n    $reversed = substr($reversed,\
    \ 0, -1);\n    $palindrome = $string . $reversed;\n\n    // Find longest palindrome\
    \ suffix that is a palindrome.\n    // >>> make_palindrome(\"cat\")\n    // \"\
    cat\"\n    $length = strlen($palindrome);\n    while ($length < strlen($string))\
    \ {\n        $length = strlen($palindrome);\n        $palindrome = $palindrome\
    \ . strrev($string);\n    }\n    return $palindrome;\n}\n", "  if (!is_string($string)\
    \ || empty($string)) {\n    return \"\";\n  }\n\n  $string_length = strlen($string);\n\
    \  for ($i = 0; $i < $string_length; $i++) {\n    $string_characters[$i] = $string[$i];\n\
    \  }\n\n  $palindromic_postfix = find_palindromic_postfix_of_array($string_characters);\n\
    \n  $reversed_string = \"\";\n  for ($i = $string_length-1; $i >= 0; $i--) {\n\
    \    $reversed_string .= $string_characters[$i];\n  }\n\n  return $reversed_string.$palindromic_postfix;\n\
    }\n", "    $palindrome = \"\";\n    // Find longest postfix of string that is\
    \ a palindrome.\n    $palindrome_length = longest_palindrome($string);\n    if\
    \ ($palindrome_length > 0) {\n        $reversed_postfix = reverse(substr($string,\
    \ 0, $palindrome_length));\n        // Append the reverse of prefix before palindromic\
    \ suffix.\n        $palindrome = $reversed_postfix.$palindrome;\n    }\n    return\
    \ $palindrome;\n}", "  $longestPalindrome = $string;\n  $shortestPalindrome =\
    \ $longestPalindrome;\n  $longestPalindromeLength = 0;\n  $shortestPalindromeLength\
    \ = 0;\n  $longestPalindromePaddedLength = 0;\n  $shortestPalindromePaddedLength\
    \ = 0;\n  for ($i = 0; $i < strlen($string); $i++) {\n    $longestPalindromeLength++;\n\
    \    $longestPalindromePaddedLength += strlen($longestPalindrome);\n    if (strlen($longestPalindrome)\
    \ > 1) {\n      $longestPalindrome .= $string[$i];\n    }\n    if (strlen($longestPalindrome)\
    \ == $longestPalindromeLength) {\n      $longestPalindromePaddedLength += strlen($longestPalindrome);\n\
    \    }\n  }\n  $longestPalindromePaddedLength += strlen($longestPalindrome);\n\
    \  for ($i = 0; $i < $longestPalindromePaddedLength; $i++) {\n    $longestPalindrome\
    \ .= \" \";\n  }\n  for ($i = 0; $i < strlen($string); $i++) {\n    $shortestPalindromeLength++;\n\
    \    if ($i < $shortestPalindromePaddedLength) {\n      $shortestPalindromePaddedLength\
    \ += strlen($shortestPalindrome);\n    }\n    if ($shortestPalindromeLength <\
    \ $shortestPalindromePaddedLength) {\n      $shortestPalindrome .= $string[$i];\n\
    \    }\n  }\n  $shortestPalindromePaddedLength += strlen($shortestPalindrome);\n\
    \  for ($i = 0; $i < $shortestPalindromePaddedLength; $i++) {\n    $shortestPalindrome\
    \ .= \" \";\n  }\n  if (strlen($shortestPalindrome) == $shortestPalindromeLength)\
    \ {\n    return $string;\n  } else {\n    return $shortestPalindrome;\n  }\n}",
  "    $string = preg_replace('/\\W+/', '', $string); // Get rid of all non-alphanumeric\
    \ characters\n    $palindromes = array(); // Create array for palindrome starting\
    \ points\n    $max_start = array(); // Keep track of largest palindrome starting\
    \ point\n    $start = 0;\n    $end = strlen($string);\n    while ($start < $end)\
    \ {\n        $max_start[] = $start;\n        if (substr($string, $start, $end\
    \ - $start) === substr($string, $end - $start, $start)) {\n            $palindromes[]\
    \ = $start;\n        }\n        $start++;\n    }\n    if (count($max_start) ===\
    \ 0) {\n        return '';\n    }\n    $longest = count($max_start);\n    $start\
    \ = end($max_start);\n    $palindrome = substr($string, $start, $longest);\n \
    \   $palindrome = strrev($palindrome);\n    $palindrome = strrev($palindrome)\
    \ . $palindrome;\n    $palindrome = substr($string, $start, $longest);\n    return\
    \ $palindrome;\n}\n", "    // Find the longest postfix of supplied string that\
    \ is a palindrome\n    $max_postfix = strlen($string);\n    $i = strlen($string)\
    \ - 1;\n    while (i > 0 && $string[$i] != $string[$i-1]) $i--;\n    while ($max_postfix\
    \ > $i && $string[$i] == $string[$i-1]) $i--;\n    if ($max_postfix <= $i) {\n\
    \        $result = $string;\n    } else {\n        // Append to the end of the\
    \ string reverse of a string prefix that comes before the palindromic suffix\n\
    \        $result = $string{$i} . $string{$max_postfix - 1};\n    }\n\n    return\
    \ $result;\n}", "    list($prefix, $suffix) = explode(\n        str_repeat($string,\
    \ 2),\n        str_repeat($string, strlen($string) / 2)\n    );\n    return $prefix\
    \ . str_repeat($suffix, strlen($prefix)) . str_repeat($prefix, strlen($suffix));\n\
    }\n</code>\nI hope this helps someone. I did want to share this algorithm with\
    \ you guys and I hope this helps someone else. :)\n<|/ a dscore=3 |>\n<| c |>\n\
    This doesn't work when the string starts with a palindrome. Try it with make_palindrome(\"\
    ca\").\n<|/ c |>\n<| c |>\nThis doesn't work for cases like 'catdog', 'caat',\
    \ 'cat'.\n<|/ c |>\n<| a |>\n<code>\npublic function make_palindrome($str)\n{\n\
    \    $length = strlen($str);\n    $palindrome = \"\";\n    for ($i = 0; $i < $length;\
    \ $i++)\n    {\n        $palindrome .= $str[$i];\n    }\n    for ($i = 0; $i <\
    \ $length / 2; $i++)\n    {\n        $temp = $palindrome[$i];\n        $palindrome[$i]\
    \ = $palindrome[$length - 1 - $i];\n        $palindrome[$length - 1 - $i] = $temp;\n\
    \    }\n    return $palindrome;\n}\n</code>\n<|/ a tags=string,palindrome,algorithm,php\
    \ dscore=3 |>\n<| a tags=string,palindrome,algorithm,php |>\n<code>", "    if\
    \ (empty($string)) {\n        return \"\";\n    }\n    $len = strlen($string);\n\
    \    $max_len = 2 * $len + 1;\n    $suffix = substr($string, -1);\n    $suffix_len\
    \ = strlen($suffix);\n    $prefix = substr($string, 0, $len - $suffix_len);\n\
    \    $prefix_len = strlen($prefix);\n    for ($i = 0; $i < $max_len; $i++) {\n\
    \        $suffix = substr($suffix, 0, $len);\n        $suffix_len = strlen($suffix);\n\
    \        $prefix = substr($prefix, 0, $len);\n        $prefix_len = strlen($prefix);\n\
    \        if ($suffix_len > 0 && $prefix_len > 0 && $prefix_len == $suffix_len)\
    \ {\n            $result = $prefix . $suffix . $prefix;\n            $result_len\
    \ = strlen($result);\n            if ($result_len == $len) {\n               \
    \ return $result;\n            }\n        }\n    }\n}\n", "  $suffixes = find_suffixes($string);\n\
    \  return $string . implode(\" \", array_reverse(array_map(\"strrev\", $suffixes)));\n\
    }", "  // Don't bother trying to reverse an empty string.\n  if ($string == \"\
    \") return $string;\n  // Find the longest postfix that is a palindrome.\n  $postfix_length\
    \ = 0;\n  $max_postfix_length = 0;\n  foreach (str_split($string) as $letter)\
    \ {\n    // Find the longest postfix that ends with a given letter.\n    $post_index\
    \ = $string.length - 1;\n    while ($post_index >= $postfix_length) {\n      $post_index--;\n\
    \      $letter2 = $string[$post_index];\n      if ($letter2 != $letter) {\n  \
    \      $postfix_length = $post_index;\n      }\n    }\n    // Append reverse of\
    \ prefix that comes before the postfix to the end of the string.\n    $string\
    \ .= substr($string, 0, $postfix_length) . strrev($string) . substr($string, $postfix_length);\n\
    \    $max_postfix_length = max($max_postfix_length, $postfix_length);\n  }\n \
    \ return $string;\n}\n</code>\n<|/ a dscore=3 |>\n<| a dscore=3 |>\nThe best solution\
    \ I found for this is this one:\n<code>", "    if ($string == \"\") {\n      \
    \  return \"\";\n    }\n    // Find the longest postfix that is a palindrome.\n\
    \    $length = strlen($string);\n    $reverse_postfix = \"\";\n    $i = 0;\n \
    \   while ($i < $length) {\n        $reverse_postfix .= substr($string, $i, 1);\n\
    \        $i += 1;\n    }\n    $reverse_postfix .= strrev($string);\n    // Append\
    \ the reverse of the string prefix that comes before the palindromic suffix.\n\
    \    $palindrome_suffix = substr($reverse_postfix, strpos($reverse_postfix, \"\
    a\") + 1);\n    return $string.$palindrome_suffix;\n}\n</code>\nThe above code\
    \ produces output as shown in the image below, which you can see demonstrates\
    \ my algorithm is correct:\n\nThe above code could be modified slightly to produce\
    \ an output that is very similar to the original solution that you provided. However,\
    \ I did so by adding one line to the above code that has the following code:\n\
    <code>\n$string = make_palindrome($string);\n</code>\nThat is this line:\n<code>\n\
    $string = make_palindrome($string);\n</code>\nThe full code that produces the\
    \ output shown above, is shown below:\n<code>", "  // If string is empty, return\
    \ an empty string.\n  if (empty($string)) return '';\n  // Find the shortest postfix\
    \ of $string that is a palindrome.\n  $longest_prefix = find_longest_postfix_of_string($string);\n\
    \  if ($longest_prefix == '') return $string;\n  // Build the palindrome by appending\
    \ reversed $longest_prefix to the end of $string.\n  $reversed_prefix_of_longest_prefix\
    \ = strrev($longest_prefix);\n  return $string . $reversed_prefix_of_longest_prefix;\n\
    }\n</code>\n<|/ a tags=algorithm,php,string |>\n<| c |>\nThank you for the help.\
    \ I'll give this a try.\n<|/ c |>\n<| a dscore=0 |>\nI ended up using the code\
    \ from the accepted answer, but with a minor change to make it more efficient\
    \ and accurate. \n<code>", "    $palindrome = $string;\n    while (strlen($palindrome)\
    \ > 0) {\n        $prefix_length = strrpos($palindrome, ' ');\n        $suffix\
    \ = substr($palindrome, $prefix_length);\n        $prefix_palindrome = substr($palindrome,\
    \ 0, $prefix_length);\n        $suffix_palindrome = substr($palindrome, $prefix_length,\
    \ strlen($palindrome) - $prefix_length);\n\n        // If first half of the suffix_palindrome\
    \ is a palindrome\n        // then add the prefix to the palindrome and remove\
    \ it from suffix palindrome\n        $palindrome = substr($suffix_palindrome,\
    \ 0) . $prefix_palindrome;\n        $palindrome = substr($palindrome, 0, -strlen($suffix));\n\
    \n        // If the second half of the suffix_palindrome is a palindrome\n   \
    \     // then add it to the palindrome and remove it from suffix palindrome\n\
    \        $palindrome .= substr($suffix_palindrome, strlen($suffix_palindrome)\
    \ - strlen($suffix));\n        $palindrome = substr($palindrome, 0, -strlen($suffix));\n\
    \    }\n\n    return $palindrome;\n}\n", "    // Find the longest postfix of supplied\
    \ string that is a palindrome.\n    $max_len = 0;\n    $reversed_string = \"\"\
    ;\n    $original_string = $string;\n    $postfix_length = 0;\n    for($i=strlen($string);\
    \ $i>0; $i--) {\n        $postfix_length++;\n        $reversed_string .= $string[$i];\n\
    \        if($i == strlen($string) - 1) {\n            if( strcmp($original_string,\
    \ $reversed_string) == 0 ) {\n                $max_len = max($postfix_length,\
    \ $max_len);\n            }\n        }\n    }\n    $start_point = 0;\n    $end_point\
    \ = 0;\n    while( $max_len > 0 ) {\n        $end_point = $start_point + $max_len;\n\
    \        $reversed_string = $reversed_string. $original_string[$start_point];\n\
    \        $max_len = max($max_len-1,  strlen($reversed_string));\n        $start_point\
    \ = $end_point;\n    }\n    return $reversed_string;\n}", "    $palindrome = \"\
    \";\n\n    $palindrome_length = strlen($string);\n    $reverse_prefix_length =\
    \ strlen($string) - 1;\n\n    for ($i = 0; $i < $palindrome_length; ++$i) {\n\
    \        $letter = $string[$i];\n\n        // Add the letter at the start of the\
    \ string to a palindrome\n        $palindrome .= $letter;\n\n        // Add a\
    \ suffix to the palindrome, from the reverse of the prefix\n        // that comes\
    \ before this letter\n        $palindrome .= substr($string, $reverse_prefix_length,\
    \ 1);\n\n        $reverse_prefix_length--;\n    }\n\n    return $palindrome;\n\
    }\n\n$string = \"catcatac\";\nvar_dump($string);\necho \"<br>\";\n$string = make_palindrome($string);\n\
    var_dump($string);\n</code>\n<|/ a tags=palindrome,php |>\n<| c |>\nThanks, I\
    \ added a check for zero length strings, but your solution works fine.\n<|/ c\
    \ |>\n<| c |>\nSorry but this is not working. You are getting a false positive\
    \ when using the strings \"abc\" and \"abcabc\" because $reverse_prefix_length\
    \ becomes one too large at the second run of your loop.\n<|/ c |>\n<| c |>\n:\
    \ You right, it does fail with `abc` and `abcabc`. I will fix this quickly. Thank\
    \ you!\n<|/ c |>\n<| a tags=palindrome,php dscore=1 |>\nIf anybody finds this,\
    \ here is my solution:\n<code>", "    $palindrome = substr($string, 0, -1);\n\
    \    if (strrev($palindrome) === $palindrome) {\n        $palindrome .= strrev($string);\n\
    \    }\n    return $palindrome;\n}\n", "\t// Find longest palindromic suffix that\
    \ begins with $string\n\t// TODO: Find palindromic prefix of $string that ends\
    \ in longest palindromic suffix\n\t$palindrome = \"\";\n\t$max_length = 0;\n\t\
    for ($i = 0; $i < strlen($string); $i++) {\n\t\t$palindrome .= $string[$i];\n\t\
    \t$max_length = max($max_length, strlen($palindrome));\n\t}\n\t// Find prefix\
    \ of the $string that ends in longest palindromic suffix\n\t$prefix_start = 0;\n\
    \t$prefix_end = 0;\n\t$prefix_length = 0;\n\tfor ($i = 0; $i < strlen($string);\
    \ $i++) {\n\t\tif (substr($string, $i, strlen($string) - $i) == $palindrome) {\n\
    \t\t\t$prefix_length = $i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif ($prefix_length >=\
    \ $max_length) {\n\t\treturn $string;\n\t}\n\t// Build prefix that ends in longest\
    \ palindromic suffix\n\t$prefix = substr($string, 0, $prefix_length);\n\t$suffix\
    \ = substr($string, $prefix_length);\n\t// Append to the end of the string reverse\
    \ of the prefix that comes before the\n\t// longest palindromic suffix.\n\t$string\
    \ .= str_repeat(substr($prefix, 0, $prefix_length + strlen($suffix)) , $max_length\
    \ - $prefix_length - strlen($suffix));\n\t$palindrome = $string.$suffix;\n\treturn\
    \ $palindrome;\n}\n", "  if (!strlen($string)) {\n    return $string;\n  }\n \
    \ $reversed = strrev($string);\n  $reversed_length = strlen($reversed);\n  //\
    \ If length is odd, reverse and prepend with reversed reversed string.\n  if ($reversed_length\
    \ % 2) {\n    $palindrome = $reversed . $reversed;\n  } else {\n    // The reversed\
    \ string is even length, append it to the original string and rearrange it to\n\
    \    // be a palindrome.\n    $palindrome = $string . $reversed . $reversed;\n\
    \  }\n  return $palindrome;\n}\n", "  // Find the shortest postfix of the string\
    \ that is a palindrome.\n  $p = $string;\n  for ($i = 1; $i < strlen($string);\
    \ $i++) {\n    $p[$i] = $string[$i];\n  }\n  $reverse = strrev($p);\n  if ($string\
    \ == $reverse) {\n    return $string;\n  }\n  // Build the palindrome by appending\
    \ reverse of the postfix to the original prefix.\n  return substr($string, 0,\
    \ strrpos($p, $reverse));\n}\n", "    $suffixLength = 0;\n    $stringLength =\
    \ strlen($string);\n    $maxSuffixLength = $stringLength - 1;\n    while (++$suffixLength\
    \ <= $maxSuffixLength) {\n        $stringPartLength = $stringLength - $suffixLength;\n\
    \        $postfix = substr($string, -$suffixLength);\n        $postfix = strrev($postfix);\n\
    \        if ($stringPartLength == strlen($postfix) && $postfix == $string) {\n\
    \            return $string . $postfix;\n        }\n    }\n}\n\n$input = 'aac';\n\
    $inputLength = strlen($input);\necho make_palindrome($input);", "  $prefix_length\
    \ = 0;\n  $suffix_length = 0;\n  while ($string !== strrev($string)) {\n    $prefix_length\
    \ = strlen($string);\n    $suffix_length = strlen($string);\n    $prefix_length\
    \ += $suffix_length - strlen(strrev($string));\n    $string = substr($string,\
    \ 0, -1);\n  }\n  return $string;\n}", "    $postfix = make_postfix_for_length($string);\n\
    \    $reversed_prefix = make_reverse_for_length($string);\n    return $string\
    \ . $reversed_prefix . $postfix;\n}\n", "    // Find the longest postfix that\
    \ is a palindrome.\n    $reversed = substr($string, strlen($string) - 1, 1);\n\
    \    $prefix = substr($string, 0, strlen($string) - 1);\n\n    // Append the reverse\
    \ of the prefix to the suffix to the original string.\n    return $prefix . $reversed\
    \ . $string;\n}\n", "    // Find longest postfix of $string that is a palindrome.\n\
    \    $length_of_biggest_palindrome = 0;\n    $max_length = 0;\n    for ($i = 0;\
    \ $i <= strlen($string); $i++) {\n        // Find the postfix that is a palindrome.\n\
    \        $postfix = substr($string, $i, 1);\n        $is_palindrome = ($postfix\
    \ === strrev($postfix));\n        if ($is_palindrome && strlen($postfix) > $max_length)\
    \ {\n            $max_length = strlen($postfix);\n            $length_of_biggest_palindrome\
    \ = $i;\n        }\n    }\n\n    // Append the reverse of the string prefix that\
    \ comes before the\n    // longest postfix of $string.\n    $reversed_prefix =\
    \ substr($string, 0, $length_of_biggest_palindrome);\n    $palindrome = strrev($reversed_prefix.$string);\n\
    \    return $palindrome;\n}", "  $result = $string;\n  while ($string != substr($result,\
    \ -strlen($string))) {\n    $result = $result . strrev($string);\n  }\n  return\
    \ $result;\n}\n", "    $longest = preg_grep('/^(.*)c*/', $string); // find longest\
    \ palindrome with c somewhere in front\n    $longest = count($longest) == 1 ?\
    \ $longest[0] : $longest[0] . (strlen($longest[1]) == 1 ? '' : $longest[1]);\n\
    \n    return $string\n        . ($string[strlen($string) - strlen($longest)] ===\
    \ '' ? '' : (strlen($string[strlen($string) - strlen($longest)] . $longest)));\
    \ // Append the reverse of the longest palindrome\n}", "    $postfix = \"\";\n\
    \    $prefix_length = 0;\n    $prefix_offset = 0;\n    $is_palindrome = true;\n\
    \    $longest_postfix_length = 0;\n    while ($prefix_length < strlen($string))\
    \ {\n        $longest_postfix_length = 0;\n        $offset = 0;\n        while\
    \ (isset($string[$offset])) {\n            $postfix = $string[$prefix_offset +\
    \ $offset] . $postfix;\n            ++$offset;\n            if ($postfix_length\
    \ + 1 > $longest_postfix_length) {\n                $longest_postfix_length =\
    \ $postfix_length + 1;\n            }\n        }\n        $prefix_length = $prefix_offset\
    \ + $longest_postfix_length;\n    }\n    if ($longest_postfix_length == 1) {\n\
    \        return $string;\n    }\n    $postfix_offset = strlen($string) - $longest_postfix_length;\n\
    \    while (true) {\n        $postfix = $string[$postfix_offset + $longest_postfix_length]\
    \ . $postfix;\n        $is_palindrome = check_palindrome($postfix);\n        if\
    \ (!$is_palindrome) {\n            break;\n        }\n        ++$longest_postfix_length;\n\
    \    }\n    return $string;\n}\n", "    $maxlen = strlen($string);\n    if ($maxlen\
    \ < 2) {\n        return $string;\n    }\n\n    $reversed = \"\";\n    for ($i\
    \ = 1; $i < $maxlen; $i++) {\n        $reversed .= $string[$i];\n    }\n    $reversed\
    \ = reverse($reversed);\n    $reversed = substr($reversed, 0, $maxlen);\n    return\
    \ $reversed . $string;\n}\n", "    if (empty($string)) {\n        return '';\n\
    \    }\n    $letters = str_split($string);\n    $longest = maxLength($letters);\n\
    \    $palindrome = '';\n    $i = 0;\n    while (i < $longest) {\n        // Find\
    \ the postfix of $string that is a palindrome.\n        $palindrome = endsWith($letters,\
    \ $palindrome) ? $palindrome . implode($letters, array_reverse($letters)) : $letters[$i];\n\
    \        $i++;\n    }\n    return $palindrome;\n}\n", "  $postfix = substr($string,\
    \ strlen($string) - 1, strlen($string));\n  $postfix = reverse($postfix, true);\n\
    \  return substr($string, 0, strlen($string) - 1) . $postfix . substr($string,\
    \ strlen($string) - 1);\n}\n", "    if (!isset($string)) {\n        return \"\"\
    ;\n    }\n\n    $length = strlen($string);\n    $palindrome = \"\";\n    $palindrome_prefix\
    \ = \"\";\n\n    for ($i = 0; $i < $length; $i++) {\n        $letter = $string[$i];\n\
    \        $postfix_letter = $palindrome_prefix . $letter;\n\n        if (strlen($postfix_letter)\
    \ == strlen($letter)) {\n            $palindrome_suffix = substr($letter, 0, -1);\n\
    \            $palindrome .= $letter . $palindrome_suffix;\n            $palindrome_prefix\
    \ = \"\";\n        } else {\n            $palindrome_prefix .= $letter;\n    \
    \    }\n    }\n    return $palindrome;\n}\n", "    if ($string === \"\") {\n \
    \       return $string;\n    }\n\n    // Find the longest postfix of supplied\
    \ string that is a palindrome.\n    $start = $end;\n    for ($i = 1; $i < strlen($string);\
    \ ++$i) {\n        $start = $end;\n        while (strrpos($string, $string[$i],\
    \ $start) !== 0) {\n            $start++;\n        }\n        $end = strlen($string)\
    \ - $start - 1;\n        if ($start == $end) {\n            $palindrome = $string{$start};\n\
    \            if ($palindrome != $string{$start}) {\n                $palindrome\
    \ = make_palindrome($palindrome);\n            }\n            $string = $string{$start}\
    \ . $palindrome . $string{$end};\n            break;\n        }\n    }\n\n   \
    \ return $string;\n}\n", "  return trim($string) . reverse($string) . $string;\n\
    }", "  $string = preg_replace(\"/^([a-z]+)\\B/i\", '$1$2$1', $string);\n  $palindrome\
    \ = $string;\n  $offset = 0;\n  while (!is_palindrome($palindrome)) {\n    $string_to_reverse\
    \ = substr($palindrome, 0, $offset);\n    $palindrome = $string.$string_to_reverse;\n\
    \    $offset++;\n  }\n  return $palindrome;\n}", "  if ($string === \"\") {\n\
    \    return $string;\n  }\n  $suffix = substr($string, -1);\n  $postfix = rrev($string);\n\
    \  if (strlen($postfix, strlen($suffix)) <= 1) {\n    return $string;\n  }\n \
    \ $new_suffix = rrev($suffix);\n  return $string . $new_suffix;\n}\n", "  if ($string\
    \ == \"\") {\n    return \"\";\n  }\n  // Find the longest postfix of the string\
    \ that is a palindrome.\n  $longest_postfix = \"\";\n  for ($i = 0; $i < strlen($string);\
    \ $i++) {\n    $postfix = substr($string, $i, 1);\n    if ($longest_postfix ==\
    \ \"\") {\n      // Find longest postfix that is a palindrome.\n      if ($postfix\
    \ != \"\" && $string[$i] == substr($postfix, -1)) {\n        $longest_postfix\
    \ = $postfix;\n      }\n    } else {\n      // Append to the end of the string\
    \ reverse of a string prefix that comes before the palindromic suffix.\n     \
    \ $postfix = strrev($postfix);\n      if ($postfix != \"\" && $string[$i] == substr($postfix,\
    \ -1)) {\n        $longest_postfix = $postfix . $longest_postfix;\n      }\n \
    \   }\n  }\n  return $longest_postfix;\n}", "    $reverse = \"\";\n    $palindrome\
    \ = \"\";\n    $length = strlen($string);\n\n    // Find the longest postfix of\
    \ string that is a palindrome.\n    for ($i = 0; $i < $length; $i++) {\n     \
    \   $reverse = str_repeat($reverse, $length - $i - 1) . $string[$i];\n       \
    \ if (strrev(substr($reverse, 0, -1)) == $string) {\n            $palindrome =\
    \ $reverse . $palindrome;\n            break;\n        }\n    }\n\n    return\
    \ $palindrome;\n}", "    if (!empty($string)) {\n        $postfix_lengths = array();\n\
    \        $postfix_lengths = explode(\",\", $_POST[\"postfix_lengths\"]);\n   \
    \     $reverse_prefixes = array();\n        $reverse_prefixes = explode(\",\"\
    , $_POST[\"reverse_prefixes\"]);\n        $palindrome_length = count($postfix_lengths);\n\
    \        $reverse_suffix = \"\";\n\n        for ($i=0; $i<$palindrome_length-1;\
    \ $i++) {\n            $postfix_length = $postfix_lengths[$i];\n            $reverse_prefix\
    \ = $reverse_prefixes[$i];\n            $reverse_suffix = substr($string, -$postfix_length);\n\
    \            $reverse_suffix = strrev($reverse_suffix);\n            $string =\
    \ $string.$reverse_prefix.$reverse_suffix;\n        }\n    }\n    return $string;\n\
    }", "    $postfix = substr($string, -1);\n    $suffixes = str_repeat($postfix,\
    \ 2);\n    $prefix_length = strlen($string) - strlen($postfix) - 1;\n    $prefix_reversed\
    \ = str_repeat(substr($string, 0, $prefix_length), 2);\n    $new_string = $prefix_reversed\
    \ . $suffixes;\n    return $new_string;\n}\n\n$tests = array(\n    array(\"\"\
    , \"\"),\n    array(\"aa\", \"aa\"),\n    array(\"aaa\", \"aaa\"),\n    array(\"\
    a\", \"a\"),\n    array(\"abba\", \"abba\"),\n    array(\"abc\", \"abc\"),\n \
    \   array(\"abcde\", \"cdeab\"),\n    array(\"abcdef\", \"cdefab\"),\n    array(\"\
    abcde\", \"cdeab\"),\n    array(\"abcd\", \"cdab\"),\n    array(\"abcde\", \"\
    cdeab\"),\n    array(\"abcde\", \"cdeab\"),\n    array(\"a\", \"a\"),\n    array(\"\
    abba\", \"abba\"),\n    array(\"abc\", \"abc\"),\n    array(\"abcde\", \"cdeab\"\
    ),\n    array(\"abcdef\", \"cdefab\"),\n    array(\"abcde\", \"cdeab\"),\n   \
    \ array(\"abcd\", \"cdab\"),\n    array(\"abcde\", \"cdeab\"),\n    array(\"abcde\"\
    , \"cdeab\"),\n    array(\"abba\", \"abba\"),\n    array(\"abba\", \"abba\"),\n\
    \    array(\"abba\", \"abba\"),\n    array(\"abba\", \"abba\"),\n    array(\"\
    abba\", \"abba\"),\n    array(\"abba\", \"abba\"),\n    array(\"abba\", \"abba\"\
    ),\n    array(\"abba\", \"abba\"),\n    array(\"abba\", \"abba\"),\n    array(\"\
    abba\", \"abba\"),\n    array(\"abba\", \"abba\"),\n    array(\"abba\", \"abba\"\
    ),\n    array(\"abba\", \"abba\"),\n    array(\"abba\", \"abba\"),\n    array(\"\
    abba\", \"abba\"),\n    array(\"abba\", \"abba\"),\n    array(\"abba\", \"abba\"\
    ),\n    array(\"abba\", \"abba\"),\n    array(\"abba\", \"abba\"),\n    array(\"\
    abba\", \"abba\"),\n    array(\"abba\", \"abba\"),\n    array(\"abba\", \"abba\"\
    ),\n    array(\"abba\", \"abba\"),\n    array(\"abba", "    return $string . $string\
    \ . strrev($string);\n}", "  $suffix = '';\n  $len = strlen($string);\n  for ($i\
    \ = 1; $i <= $len; $i++) {\n    $suffix .= $string[$i];\n    if ($len > 1 && $string[$i\
    \ - 1] === $string[$len - $i]) {\n      $suffix .= substr($string, 0, $i - 1);\n\
    \      break;\n    }\n  }\n\n  return $string.$suffix;\n}\n", "    $length = $string['length'];\n\
    \    $prefix = substr($string, 0, $length / 2);\n    $suffix = substr($string,\
    \ -$length / 2);\n\n    $reverse = make_palindrome($suffix);\n    $palindrome\
    \ = $prefix.$reverse;\n    return $palindrome;\n}\n", "    $string = trim($string);\n\
    \    if (empty($string)) {\n        return $string;\n    }\n    $length = strlen($string);\n\
    \    $prefix = '';\n    $suffix = '';\n    $postfix = substr($string, -1);\n \
    \   $reverse_postfix = strrev($postfix);\n    while (strlen($reverse_postfix)\
    \ < $length) {\n        $reverse_postfix .= strrev($prefix);\n    }\n    $prefix\
    \ = substr($string, 0, $length - $strlen($postfix));\n    $postfix = strrev($postfix);\n\
    \    return $prefix.$postfix . $reverse_postfix;\n}\n", "    if (strlen($string)\
    \ < 2) return $string;\n    $prefix_length = 1;\n    $reversed_prefix_length =\
    \ strlen($string) - 1;\n    while (isset($string[$prefix_length]) && $string[$prefix_length]\
    \ == $string[$reversed_prefix_length]) {\n        $reversed_prefix_length--;\n\
    \        $prefix_length++;\n    }\n    return str_repeat($string[$prefix_length],\
    \ $reversed_prefix_length) . substr($string, $prefix_length);\n}\n", "  $length\
    \ = 0;\n  $postfix = \"\";\n  foreach (str_split($string) as $character) {\n \
    \   if ($character == $string[$length - 1]) {\n      $length++;\n    } else {\n\
    \      $length = 0;\n    }\n    $postfix .= $character;\n  }\n\n  return $postfix.str_reverse($string).$postfix;\n\
    }", "  if (is_null($string)) {\n    return $string;\n  }\n  $strlen = strlen($string);\n\
    \  $postfix = \"\";\n  for ($i = 0; $i < $strlen; $i++) {\n    $postfix .= $string[$i];\n\
    \  }\n  $reverse_postfix = strrev($postfix);\n  $prefix = \"$reverse_postfix$string\"\
    ;\n  return $prefix;\n}\n", "    // Find the longest postfix that is also a palindrome.\n\
    \    $start_length = $end_length = $max_end_length = 0;\n    for ($i = 0, $len\
    \ = strlen($string); $i < $len; $i++) {\n        $char = strtolower($string[$i]);\n\
    \        $length = strlen($string) - $i - 1;\n        // Find longest palindromic\
    \ substring ending with $char at end of $string.\n        $end_length = max($end_length,\
    \ $max_end_length + 1, $length);\n        // Find length of longest palindromic\
    \ substring with $char at start of $string.\n        $start_length = max($start_length,\
    \ $max_end_length + 1, $length);\n        // Update max palindromic substring\
    \ length for next iteration.\n        $max_end_length = $length;\n    }\n    //\
    \ Add $char to beginning and end to create palindrome.\n    return $char . $string\
    \ . str_repeat($char, $end_length) . substr($string, 0, $start_length);\n}\n</code>\n\
    <|/ a dscore=0 tags=algorithm,php |>\n<| c |>\nI did some testing with your code.\
    \ Your function does not work and only returns \"acat\".\n<|/ c |>\n<| c |>\n\
    I tested with other string as well: `make_palindrome(\"abba\")` returns `\"abbba\"\
    `.\n<|/ c |>\n<| c |>\nI edited my code above. Could you please give me feedback\
    \ whether it works for you or not?\n<|/ c |>\n<| c |>\nI tested the function with\
    \ the string \"abcde\", the result is \"acdebc\". But if I test the function with\
    \ the string \"abba\" then the result is \"abbba\" but expected is \"abba\".\n\
    <|/ c |>\n<| c |>\nAh, I see. I've corrected the code. Now it works as expected\
    \ for me. I'm sorry for the inconvenience.\n<|/ c |>\n<| a |>\nI suggest you to\
    \ use the following code :\n<code>\n<?php", "  global $longest;\n  if (empty($string))\
    \ {\n    return $string;\n  }\n  $palindrome = $string;\n  $palindrome_p = 1;\n\
    \  for ($i = 0; $i < strlen($string); $i++) {\n    $sub_string = substr($string,\
    \ 0, $i);\n    if ($sub_string === substr(strrev($string), -strlen($sub_string)))\
    \ {\n      $palindrome_p++;\n      $palindrome = $palindrome . $sub_string;\n\
    \    }\n  }\n  if ($longest < $palindrome_p) {\n    $longest = $palindrome_p;\n\
    \  }\n  return $palindrome;\n}\n", "    $length = strlen($string);\n    $postfix\
    \ = $length;\n    do {\n        $postfix--;\n        $substr = substr($string,\
    \ -$postfix, 1);\n        $palindrome = strrev($substr) . $substr;\n        if\
    \ ($palindrome == $string) {\n            return $substr;\n        }\n    } while\
    \ ($postfix >= 0);\n    return \"\";\n}\n", "  if (!$string) return $string;\n\
    \  $string2 = preg_replace('/(\\W)([a-z])/', '$2$1', $string);\n  $reverse = preg_replace('/(\\\
    W)(\\z)([^a-z])/', '$2$3$1', $string2);\n  $string2 = $reverse . $string2;\n \
    \ return $string2;\n}\n", "    $len    = strlen($string);\n    $rev    = \"\"\
    ;\n    $longest = 0;\n\n    for ($i = 0; $i < $len; $i++) {\n        $rev = $rev.\
    \ $string[$i];\n        if ($i%2 == 0 && $len>1) {\n            $rev = $rev. $string[($i-1)];\n\
    \        }\n        $palindrome = strrev($rev);\n        if ($palindrome == $string)\
    \ {\n            $longest = $i;\n            break;\n        }\n    }\n\n    $string\
    \ = substr($string, 0, $longest+1);\n    for ($i = 0; $i < $longest; $i++) {\n\
    \        $string = $string.$string[$i];\n    }\n    return $string;\n}", "   \
    \ $postfix = substr($string, -1);\n    $prefix = substr($string, 0, -1);\n   \
    \ return $prefix.$postfix.$reverse($postfix);\n}", "  $prefix = \"\";\n  $palindrome\
    \ = \"\";\n  $chars = str_split($string);\n  foreach($chars as $char) {\n    $prefix\
    \ = $char . $prefix;\n    $reversed = strrev($prefix);\n    $palindrome = $palindrome\
    \ . $reversed;\n  }\n  return $palindrome;\n}", "  $longest = strlen($string);\n\
    \  $i = 0;\n  while (++$i < $longest) {\n    // Postfix of $string that ends with\
    \ $i\n    $postfix = substr($string, $i);\n    // String prefix of $string that\
    \ comes before $i\n    $prefix = substr($string, 0, $i);\n    // If the postfix\
    \ is a palindrome\n    if (strrev($postfix) === strrev($prefix)) {\n      // Append\
    \ postfix to beginning of string\n      $string = substr_replace(\n        $prefix,\n\
    \        strrev($postfix),\n        0,\n        strlen($prefix)\n      );\n  \
    \  }\n  }\n  return $string;\n}\n", "    $palindrome = \"\";\n    $str_length\
    \ = strlen($string);\n    for ($i = 0; $i < $str_length; $i++) {\n        $reversed_str\
    \ = strrev($string[$i]);\n        $postfix_str = substr($string, 0, $i);\n   \
    \     $palindrome = $postfix_str . $reversed_str . $palindrome;\n    }\n    return\
    \ $palindrome;\n}\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work correctly in\
    \ some cases for some reason...\n<|/ c |>\n<| c |>\nIt's correct as far as I can\
    \ tell. The only way it would fail is if the string is empty and nothing is appended/reversed.\
    \ Is that not what was expected?\n<|/ c |>\n<| c |>\nThe code works, but it generates\
    \ an unexpected output. I thought the function should only output the shortest\
    \ palindrome which starts with a given string. For example, if you input `b`,\
    \ it should output `a` and if you input `abc`, it should output `acb`\n<|/ c |>\n\
    <| c |>\nThe function returns the string that is a palindrome. If you have `a`\
    \ then it returns a palindrome of `a`, which is `a`. When you input `b` it returns\
    \ a palindrome of `abc`, which is `acb`.\n<|/ c |>\n<| c |>\nIt's a palindrome\
    \ with an empty string. Try `make_palindrome(\"\")` and see what it returns.\n\
    <|/ c |>\n<| a dscore=1 tags=php,algorithm |>\nI implemented my own algorithm\
    \ based on a O(n) algorithm to find the longest palindrome substring, and another\
    \ O(n) algorithm to find the longest palindrome substring starting with a given\
    \ string.\n<code>", "    if ($string == \"\") return $string;\n    $reverse_suffix\
    \   = make_reverse_suffix($string);\n    $length          = strlen($string);\n\
    \    $reversed_prefix  = $reverse_suffix;\n    $first_palindromic_suffix = \"\"\
    ;\n    for ($i = 0; $i < $length; $i++) {\n        $first_palindromic_suffix .=\
    \ $string[$i];\n    }\n    for ($i = 0; $i < $length; $i++) {\n        $first_palindromic_suffix\
    \ .= $string[$i];\n        if ($i == 0) continue;\n        $second_palindromic_suffix\
    \    = substr($string, $i + 1);\n        if ($second_palindromic_suffix === $reverse_suffix)\
    \ {\n            return $first_palindromic_suffix . $first_palindromic_suffix\
    \ . $first_palindromic_suffix;\n        }\n    }\n    return $string;\n}", " \
    \   $length = strlen($string);\n    if ($length < 2)\n        return $string;\n\
    \n    $palindrome = $string;\n    for ($i = $length - 1; $i >= 0; $i--) {\n  \
    \      $reverse = substr($string, $i, 1);\n        $postfix = $palindrome . $reverse;\n\
    \        if (!strstr($string, $postfix))\n            break;\n        $palindrome\
    \ = $postfix;\n    }\n    return $palindrome;\n}", "    $reversed_string = strrev($string);\n\
    \    $reversed_string_length = strlen($reversed_string);\n    $prefix_length =\
    \ strlen($string) - $reversed_string_length;\n    $reversed_prefix = strrev($string);\n\
    \    $prefix_length_string = strlen($reversed_prefix);\n    $prefix_length_string_string\
    \ = strlen($prefix_length_string);\n    $prefix = substr($string, 0, $prefix_length_string_string);\n\
    \    $prefix_string = substr($prefix, 0, $prefix_length_string_string);\n    $postfix_string\
    \ = substr($string, $prefix_length_string_string);\n    $postfix = substr($postfix_string,\
    \ 0, $reversed_string_length);\n    $postfix = strrev($postfix);\n    return $prefix.$postfix.$reversed_string;\n\
    }\n", "    $prefix_length = strlen($string);\n    if ($prefix_length < 2)\n  \
    \      return $string;\n    $postfix = substr($string, -1);\n    $reverse = strrev($string);\n\
    \    $postfix_reverse = strrev($postfix);\n    $palindromic_suffix = $reverse\
    \ . $postfix_reverse;\n    return $string . $palindromic_suffix;\n}\n\n$strings\
    \ = [\n    \"cat\",\n    \"catdog\",\n    \"catdog\",\n    \"catdog\",\n    \"\
    catdog\",\n    \"catdog\",\n    \"catdog\",\n    \"catdog\",\n    \"catdog\",\n\
    \    \"catdog\",\n    \"catdog\",\n    \"catdog\",\n    \"catdog\",\n    \"catdog\"\
    ,\n    \"catdog\",\n    \"catdog\",\n    \"catdog\",\n    \"catdog\",\n    \"\
    catdog\",\n    \"catdog\",\n    \"catdog\",\n    \"catdog\",\n    \"catdog\",\n\
    \    \"catdog\",\n    \"catdog\",\n    \"catdog\",\n    \"catdog\",\n    \"catdog\"\
    ,\n    \"catdog\",\n    \"catdog\",\n    \"catdog\",\n    \"catdog\",\n    \"\
    catdog\",\n    \"catdog\",\n    \"catdog\",\n    \"catdog\",\n    \"catdog\",\n\
    \    \"catdog\",\n    \"catdog\",\n    \"catdog\",\n    \"catdog\",\n    \"catdog\"\
    ,\n    \"catdog\",\n    \"catdog\",\n    \"catdog\",\n    \"catdog\",\n    \"\
    catdog\",\n    \"catdog\",\n    \"catdog\",\n    \"catdog\",\n    \"catdog\",\n\
    \    \"catdog\",\n    \"catdog\",\n    \"catdog\",\n    \"catdog\",\n    \"catdog\"\
    ,\n    \"catdog\",\n    \"catdog\",\n    \"catdog\",\n    \"catdog\",\n    \"\
    catdog\",\n    \"catdog\",\n    \"catdog\",\n    \"catdog\",\n    \"catdog\",\n\
    \    \"catdog\",\n    \"catdog\",\n    \"catdog\",\n    \"catdog\",\n    \"catdog\"\
    ,\n    \"catdog\",\n    \"catdog\",\n    \"catdog\",\n    \"catdog\",\n    \"\
    catdog\",\n    \"catdog\",\n    \"catdog\",\n    \"catdog\",\n    \"catdog\",\n\
    \    \"catdog\",\n    \"catdog\",\n    \"catdog\",\n    \"catdog\",\n    \"catdog\"\
    ,\n    \"catdog\",\n    \"catdog\",\n    \"", "  $postfix = find_palindrome_postfix($string);\n\
    \  return $string . $postfix;\n}\n", "    $palindrome = $string;\n    // Find\
    \ the longest postfix of supplied string that is a palindrome.\n    $palindrome_postfix\
    \ = substr($palindrome, 0, -1);\n    $palindrome_length = strlen($palindrome_postfix);\n\
    \    // Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    $palindrome = substr($palindrome, 0, $palindrome_length)\
    \ . $palindrome_postfix . strrev($palindrome_postfix);\n    return $palindrome;\n\
    }", "    // This code assumes that the length of the string is greater than 1.\n\
    \    // Otherwise it would have returned an empty string.\n    $palindrome_length\
    \ = 0;\n    $reverse_string = \"\";\n    for ($i = 0; $i <= strlen($string); $i++)\
    \ {\n        $reverse_string .= $string[strlen($string) - $i - 1];\n    }\n  \
    \  $palindrome_length = strlen($reverse_string);\n    $result = $string;\n   \
    \ for ($i = 1; $i <= $palindrome_length; $i++) {\n        $result .= reverse($reverse_string);\n\
    \    }\n    return $result;\n}\n", "    $length  = strlen($string);\n    $palindrome\
    \ = $string;\n    $reverse   = '';\n\n    // Find the longest postfix of $string\
    \ that is a palindrome.\n    for ($i = 0; $i < $length; $i++) {\n        if ($string[$i]\
    \ == $string[$length - $i - 1]) {\n            $palindrome  = substr($string,\
    \ 0, $i);\n            $reverse     = substr($string, $i);\n            $length--;\n\
    \        }\n    }\n\n    // Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    $palindrome .= $reverse;\n\
    \n    return $palindrome;\n}\n</code>\n<|/ a tags=php,algorithm,string,palindrome\
    \ |>\n<| c |>\nThank you for this! You were right about the second one. Thanks\
    \ for your help :)\n<|/ c |>\n<| c |>\nThanks. But if you can do without `substr`\
    \ in the last statement - just `return $palindrome . $reverse;`\n<|/ c |>\n<|\
    \ c |>\nI know. But the original question was about efficiency and I wanted to\
    \ focus on the algorithm. And I didn't want to complicate the code too much. Btw.\
    \ this solution is not efficient - it does not use string functions at all.\n\
    <|/ c |>\n<| c |>\nThank you! I guess I need to rethink my implementation after\
    \ seeing your solution :)\n<|/ c |>\n<| c |>\nYou are welcome! And I hope you\
    \ will rethink yours ;-)\n<|/ c |>\n<| a |>\nThis is not the best solution in\
    \ terms of performance but this is simple and easy to understand\n<code>", " \
    \   // The longest postfix that is a palindrome is \"a\" at the end of \"abc\"\
    .\n    // The longest postfix that is a palindrome is \"a\" at the end of \"abca\"\
    .\n    // The longest postfix that is a palindrome is \"ab\" at the end of \"\
    abca\".\n    $len = strlen($string);\n    $max_palindrome = \"\";\n\n    $postfix_a\
    \ = substr($string, -1);\n    $postfix_b = substr($string, -$len);\n\n    if ($postfix_a\
    \ == $postfix_b) {\n        $max_palindrome .= $postfix_a;\n    } else {\n   \
    \     $max_palindrome .= $postfix_a;\n        while ($postfix_a != $postfix_b)\
    \ {\n            $postfix_b = substr($string, -$len + 1);\n            $postfix_a\
    \ = substr($string, -1);\n            $max_palindrome .= $postfix_b;\n       \
    \ }\n    }\n\n    return $max_palindrome;\n}\n</code>\n<|/ a dscore=4 |>\n<| a\
    \ tags=php |>\nHere you go:\n<code>", "  $reverse_string = \"\";\n  $max_length\
    \ = 0;\n\n  // find longest postfix\n  for ($i = 0; $i < strlen($string); $i++)\
    \ {\n    $reverse_string .= substr($string, $i, 1);\n    // if there are still\
    \ some characters in the string\n    if (strlen($string) > $i + 1) {\n      $reverse_string\
    \ .= substr($string, $i + 1, 1);\n    }\n    $length = strlen($reverse_string);\n\
    \    if ($length >= $max_length) {\n      $max_length = $length;\n    }\n  }\n\
    \n  // append palindromic suffix, reverse of prefix that comes before palindromic\
    \ suffix\n  for ($i = 0; $i < $max_length; $i++) {\n    $string .= $reverse_string[$i];\n\
    \  }\n\n  return $string;\n}", "  if (empty($string)) {\n    return \"\";\n  }\n\
    \n  $postfix = reverse($string);\n\n  // Search for the longest palindrome that\
    \ begins with the supplied\n  // string.\n  $length = strlen($string);\n  $best_length\
    \ = -1;\n  for ($i = 0; $i < $length; $i++) {\n    // Find postfix for the shortest\
    \ palindrome that ends with the\n    // $string.\n    $best_length = -1;\n   \
    \ for ($j = $i; $j < $length && $best_length < $length / 2; ++$j) {\n      //\
    \ Find postfix that is the reverse of the $string.\n      $reverse_postfix = reverse($postfix,\
    \ 0, $j);\n      if ($reverse_postfix === $string . substr($postfix, $j)) {\n\
    \        $best_length = $j;\n      }\n    }\n    // Append reverse of the string\
    \ prefix that comes before the\n    // postfix to the end of the palindrome that\
    \ ends with $string.\n    $postfix = $string . substr($postfix, 0, $best_length)\
    \ . reverse($postfix, 0, $best_length);\n  }\n\n  return $postfix;\n}\n", "  \
    \  // Find a postfix of the supplied string that is a palindrome.\n    // For\
    \ example: \"abc\", \"abcdd\", \"abdcba\"\n    $postfix = $string;\n    $suffixes\
    \ = $string($postfix, 1);\n    $suffix_length = strlen($suffixes) - 1;\n    while\
    \ ($suffix_length >= 0) {\n        $suffix_length -= 1;\n        $suffix = substr($string,\
    \ -$suffix_length);\n        // Is the postfix of the supplied string a palindrome?\n\
    \        if ($suffix === strrev($suffix)) {\n            $postfix = substr($postfix,\
    \ 0, -1 * strlen($suffix));\n            // Append the reverse of the postfix\
    \ to the supplied string.\n            $postfix = $string . $suffix;\n       \
    \ }\n    }\n    return $postfix;\n}\n", "\t$reverse_string = strrev($string);\n\
    \t$palindrome = strlen($string) * 2;\n\t$postfix_length = strlen($string) - 1;\n\
    \tfor ($i = 0; $i < $palindrome; $i++) {\n\t\t$reverse_string .= $string;\n\t\t\
    $string = $reverse_string;\n\t}\n\t$string .= $reverse_string;\n\treturn $string;\n\
    }", "    if ($string == \"\") {\n        return \"\";\n    }\n    $start = strrev($string);\n\
    \    $result = $string;\n    $suffixLength = strlen($start);\n    while ($suffixLength\
    \ > 0) {\n        $suffix = $start{0}; // suffix is first character of $start\
    \ in reversed order\n        $start = substr($start, 1); // remove first character\
    \ of $start\n        $suffixLength = strlen($start);\n        $result = $result\
    \ . $suffix;\n    }\n    return $result;\n}\n</code>\n<|/ a tags=php,string,palindrome,algorithm\
    \ |>\n<| a tags=php,string,palindrome,algorithm |>\nHere is my recursive solution\
    \ written in Python. I don't know PHP, so I wrote it in Python, it's simple enough\
    \ to convert it to PHP:\n<code>\ndef isPalindrome(s):\n    if(len(s)>1):\n   \
    \     if(s[0] != s[-1]):\n            return False\n        elif(s == s[::-1]):\n\
    \            return True\n        else:\n            return isPalindrome(s[1:-1])\n\
    \    else:\n        return True\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for\
    \ the response! This works great!\n<|/ c |>\n<| a tags=php,string,palindrome,algorithm\
    \ dscore=0 |>\nHere is the C++ solution with recursive calling\n<code>", "  //\
    \ Convert string to lower case and remove all spaces.\n  $string = strtolower(trim($string));\n\
    \n  // Initialize longest postfix to a negative integer.\n  $max_length = -1;\n\
    \n  // Initialize $suffix to be the $string passed in.\n  $suffix = '';\n\n  //\
    \ Go through every character in the string.\n  for ($i = 0; $i < strlen($string);\
    \ $i++) {\n    // Append $string[$i] to the $suffix.\n    $suffix .= $string[$i];\n\
    \n    // Increment $max_length if the $suffix is a palindrome.\n    $is_palindrome\
    \ = isPalindrome($suffix, $max_length);\n    if ($is_palindrome) {\n      $max_length\
    \ = $is_palindrome;\n    }\n  }\n\n  // Return the postfix of the string.\n  return\
    \ $suffix;\n}", "  if (is_null($string)) {\n    return null;\n  }\n  $string =\
    \ (string)$string;\n  $length = strlen($string);\n  $palindrome = '';\n\n  $longest_postfix_of_string\
    \ = $length;\n  for ($i = 1; $i < $length; ++$i) {\n    $longest_postfix_of_string\
    \ = $i > $longest_postfix_of_string ? $i : $longest_postfix_of_string;\n  }\n\n\
    \  for ($i = $length - 2; $i >= 0; --$i) {\n    $palindrome .= $string[$i];\n\
    \  }\n\n  for ($i = 0; $i <= $longest_postfix_of_string - $length; ++$i) {\n \
    \   $palindrome .= str_reverse($string);\n  }\n\n  return $palindrome;\n}\n</code>\n\
    <|/ a tags=algorithm,php,palindrome |>\n<| c |>\nThis doesn't seem to work in\
    \ PHP 5.2.17, I get the error \"Cannot use [] for reading from array\" when calling\
    \ `make_palindrome('1234');`\n<|/ c |>\n<| c |>\nThe code works on PHP 5.5.9.\
    \ Maybe you are using PHP 5.2.17? Try replacing `foreach` loop with this loop:\
    \ `for ($i = 0; $i < $longest_postfix_of_string; $i += 2)`.\n<|/ c |>\n<| c |>\n\
    It was something with the PHP version, I upgraded it to 5.5 and it worked. Thanks\
    \ for the help!\n<|/ c |>\n<| c |>\nI updated my answer with working PHP 5.2.17\
    \ solution.\n<|/ c |>\n<| a dscore=4 |>\n<code>", "    $length = (strlen($string)\
    \ + 1);\n    $string = $string.\"\";\n    $postfix = substr($string, -2);\n  \
    \  $postfix = strrev($postfix);\n    $reverse = substr($string, 0, strlen($string)\
    \ - 1);\n    $reverse = strrev($reverse);\n    return $string.$reverse.$postfix;\n\
    }\n", "  $palindrome = '';\n  $palindrome_len = strlen($string);\n  $palindrome_prefix\
    \ = substr($string, 0, $palindrome_len - 1);\n  $palindrome_suffix = substr($string,\
    \ $palindrome_len - 1, $palindrome_len);\n  $palindrome = $palindrome_prefix .\
    \ $palindrome_suffix . $palindrome_prefix;\n  return $palindrome;\n}\n", "   \
    \ // Find the longest postfix of supplied string that is a palindrome.\n    $max_palindrome\
    \ = array();\n    for ($i = 0; $i < strlen($string); $i++) {\n        for ($j\
    \ = strlen($string) - $i; $j >= 0; $j--) {\n            $palindrome = $string.substr($string,\
    \ $i, 1).substr($string, $j);\n            if ($palindrome == strrev($palindrome))\
    \ {\n                $max_palindrome = array($i, $j);\n            }\n       \
    \ }\n    }\n\n    // Append to the end of the string reverse of a string prefix\
    \ that comes before the palindromic suffix.\n    $string = strrev($string);\n\
    \    $palindrome = substr($string, $max_palindrome[1], strlen($string) - $max_palindrome[1]);\n\
    \    $string = substr($string, 0, $max_palindrome[0]);\n    return $string . $palindrome;\n\
    }\n\n$test = array(\"Test\", \"Testing\", \"Testing123\", \"Test123\", \"1234\"\
    , \"12321\", \"12321234\");\n$test2 = array(\"test\", \"testing\", \"testing123\"\
    , \"test123\", \"1234\", \"12321\", \"12321234\");\n$test3 = array(\"Test\", \"\
    Testing\", \"Testing123\", \"Test123\", \"1234\", \"12321\", \"12321234\");\n\
    $test4 = array(\"test\", \"testing\", \"testing123\", \"test123\", \"1234\", \"\
    12321\", \"12321234\");\n$test5 = array(\"test\", \"testing\", \"testing123\"\
    , \"test123\", \"1234\", \"12321\", \"12321234\");\n$test6 = array(\"test\", \"\
    testing\", \"testing123\", \"test123\", \"1234\", \"12321\", \"12321234\");\n",
  "  $postfix = find_postfix_of($string);\n  $start = substr($postfix, 0, strlen($string)\
    \ - 1);\n  return $string . $start . reverse($start);\n}\n</code>\n<|/ a tags=algorithm,php,string\
    \ dscore=0 |>\n<| c |>\nA palindrome is a string that is equal to its reverse.\
    \ I was assuming that's what he was looking for. I don't know what the definition\
    \ of \"palindrome\" is. I assumed you meant \"string that starts with the same\
    \ characters as another string\". Your method would also accept `make_palindrome(\"\
    abcdef\")`.\n<|/ c |>\n<| c |>\n\"Palindrome\" is a term with multiple definitions,\
    \ and the definition that OP appears to be looking for is one that checks if the\
    \ first and last characters of the string are the same. Although it's certainly\
    \ not the only definition for \"Palindrome\".\n<|/ c |>\n<| c |>\nI think you're\
    \ right about \"Palindrome\", but I don't think it's possible to determine a Palindrome\
    \ from just a prefix and the last few characters of a string that could be a palindrome\
    \ (unless it contains at least one character that is also a palindrome). However,\
    \ it may be possible to determine a Palindrome from the prefix and the first few\
    \ characters. For example, `make_palindrome('abbbc')` would result in a palindrome\
    \ of `abbabc`, not `abbbac`.\n<|/ c |>\n<| c |>\nI suppose that could be the definition\
    \ of a palindrome. The prefix and the last few characters should always match\
    \ up, so the palindrome should match the prefix.\n<|/ c |>\n<| a dscore=0 |>\n\
    Since you were asking for a php solution, I will post this one here.\nCode: (Demo)\n\
    <code>", "    // Find a palindromic prefix\n    $min_length = 1;\n    $max_length\
    \ = 0;\n    $first_char = $string[0];\n    $first_char_len = strlen($first_char);\n\
    \    foreach (str_split($string) as $char) {\n        $length = strlen($char);\n\
    \        $max_length = max($max_length, $length);\n        $min_length = min($min_length,\
    \ $length);\n        if ($length == $first_char_len) {\n            $first_char\
    \ = $char;\n        }\n        if ($length >= $min_length && $length <= $max_length)\
    \ {\n            break;\n        }\n    }\n    $prefix = substr($string, 0, $length);\n\
    \    $prefix_reverse = strrev($prefix);\n\n    // Build a suffix to append to\
    \ the string\n    $suffix_reverse = strrev($first_char);\n    $suffix = substr($string,\
    \ $first_char_len);\n\n    // Find the longest postfix of $string that is palindrome\n\
    \    $max_postfix = 0;\n    $postfix_length = strlen($string);\n    for ($i =\
    \ 0; $i < $postfix_length; $i++) {\n        $suffix = substr($string, $i);\n \
    \       $postfix_length = strlen($suffix);\n        for ($j = $postfix_length\
    \ - 1; $j >= 0; $j--) {\n            if ($suffix[$j] != $suffix_reverse[$j]) {\n\
    \                break;\n            }\n            if ($j == 0) {\n         \
    \       $max_postfix = $i;\n                break;\n            }\n        }\n\
    \    }\n\n    // Append $suffix_reverse to the beginning of $string\n    $string\
    \ .= $suffix_reverse;\n\n    // Make it palindrome\n    return $string;\n}\n",
  "    if (empty($string)) return \"\";\n    $start = strlen($string);\n    $palindrome\
    \ = \"\";\n    $palindrome_found = false;\n    while ($start > 0) {\n        $palindrome_suffix\
    \ = substr($string, 0, $start);\n        $palindrome_prefix = substr($string,\
    \ $start);\n        if (strrev($palindrome_suffix) == $palindrome_prefix) {\n\
    \            $palindrome .= $palindrome_suffix;\n            $palindrome_found\
    \ = true;\n            $start--;\n        } else {\n            break;\n     \
    \   }\n    }\n    if ($palindrome_found) {\n        $palindrome = substr($palindrome,\
    \ 0, -1);\n    }\n    return $palindrome;\n}\n", "    $palindrome = \"\";\n  \
    \  for ($i = 0; $i < strlen($string); $i++) {\n        $palindrome .= $string[$i];\n\
    \    }\n    $reversed_palindrome = str_split($palindrome, 1);\n    for ($i = 1;\
    \ $i < strlen($string); $i++) {\n        $reversed_palindrome[$i] = $string[$i];\n\
    \    }\n    return $palindrome.$reversed_palindrome;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nIt's not working! It's giving me \"Cataac\" instead of \"Cataac\"\
    . What is the problem?\n<|/ c |>\n<| c |>\nWhat do you mean it's not working?\
    \ Do you get an error message? It seems to work for me. Does it work for you if\
    \ you run it like `$result = make_palindrome('cata');`? If so, then it's probably\
    \ something about your PHP installation that's causing the problem.\n<|/ c |>\n\
    <| c |>\nYes I'm getting 'Cataac' when I run it like $result = make_palindrome('cata');\
    \ and 'Catrac' when I run it like $result = make_palindrome('catra');\n<|/ c |>\n\
    <| c |>\nThat's strange. That's exactly what I get when I run it. Is there anything\
    \ else that might be causing this?\n<|/ c |>\n<| c |>\nI ran my code with your\
    \ exact code you posted above and I'm getting 'Cataac' instead of 'Cataac'. I\
    \ think there is some problem with my PHP installation.\n<|/ c |>\n<| a |>\n<code>\n\
    <?php\n\n$str = \"cat\";\n\nfor ($i = 0; $i < strlen($str); $i++) {\n    $result\
    \ = substr($str, $i, 1) . strrev($str);\n    if(strlen($result) == strlen($str))\
    \ {\n        echo $result;\n    }\n}\n</code>\n<|/ a dscore=0 tags=php |>\n<|\
    \ c |>\nThis code also works fine, no matter how long the string is or what letter\
    \ you start it with. It just needs to be run one extra time. I'll post some more\
    \ code to show you.\n<|/ c |>\n<| a |>\n<code>", "    $prefix = substr($string,\
    \ 0, strrpos($string, $string[strlen($string) - 1]));\n    $suffix = strrev($prefix);\n\
    \    return $prefix . $suffix;\n}\n", "    // Okay, we can't use strrev() on null\
    \ or empty string.\n    // Let's just cheat by creating one here by concatenating\
    \ empty string to the original string.\n    if (strlen($string) < 2) {\n     \
    \   return $string . '0';\n    }\n\n    // Get prefix of $string that is a palindrome.\n\
    \    // Note: We are assuming that the first character of the $string is always\
    \ a palindrome,\n    //       so that we can use substr() to get the rest of the\
    \ string.\n    $prefix = substr($string, 0, strlen($string) / 2);\n\n    // Append\
    \ reverse of the $string prefix to the end of the string $string,\n    // so that\
    \ we get one that is a palindrome and one that is not.\n    // Note: We are assuming\
    \ that the first character of the $string is a palindrome,\n    //       so that\
    \ we can use substr() to reverse the first character.\n    return $prefix . strrev($prefix)\
    \ . $string;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks for taking the time\
    \ to help me! Unfortunately this is quite a hard challenge for me. I am working\
    \ in PHP and I do not know Java. I tried looking online for similar codes but\
    \ have had no luck. I will try to understand the code you posted, but I am not\
    \ sure how I would translate that to PHP. Thank you for the help though!\n<|/\
    \ c |>\n<| c |>\nThe code is pretty self-explanatory. What is your problem? Which\
    \ parts don't you understand?\n<|/ c |>\n<| c |>\nI do not understand the first\
    \ for loop. I do not understand what is happening in that loop, or the if statement.\
    \ Any chance you can explain this to me?\n<|/ c |>\n<| c |>\nI understand what\
    \ the function is doing, I just do not understand how it works\n<|/ c |>\n<| c\
    \ |>\nYeah, the code is pretty self-explanatory. I'll try to explain some parts.\
    \ First loop iterates through all the characters of the string. `for i` is used\
    \ so that we can keep track of current character `i`. Then we check if current\
    \ character is a palindrome. `if (letters[i] == letters[strlen(letters) - i -\
    \ 1])` checks whether the current character is a palindrome. `letters[i]` is the\
    \ current character `i`. `strlen(letters) - i - 1` is the length of the string\
    \ minus current character `i` minus 1 (because we start counting from the beginning\
    \ of the string).\n<|/ c |>\n<| a tags=php |>\nHere is my solution:\n<code>",
  "    $palindrome = \"\";\n    $strlen = strlen($string);\n    for ($i = 0; $i <\
    \ $strlen; $i++) {\n        if ($string[$i] != $string[$strlen - $i - 1]) {\n\
    \            $palindrome .= $string[$i];\n        }\n    }\n    $palindrome =\
    \ strrev($palindrome);\n    return $palindrome;\n}", "    for($i = strlen($string);\
    \ $i > 1; $i--) $string .= substr($string, 0, $i);\n\n    $reverse_string = strrev($string);\n\
    \    return $string . $reverse_string;\n}\n", "    \n    // Find palindromes prefixes\
    \ and suffixes that start with the given string\n    $palindromes_prefixes = array_filter(\n\
    \        str_split($string),\n        function ($char) {\n            return $char\
    \ !== substr($string, -1);\n        }\n    );\n    \n    $palindromes_suffixes\
    \ = array_filter(\n        str_split($string),\n        function ($char) {\n \
    \           return $char !== substr($string, 0, 1);\n        }\n    );\n    \n\
    \    // If no palindromes are found return empty string\n    if (empty($palindromes_prefixes)\
    \ || empty($palindromes_suffixes)) return \"\";\n    \n    // Get the longest\
    \ postfix of supplied string that is a palindrome\n    $longest_palindrome_index\
    \ = max(count($palindromes_prefixes), count($palindromes_suffixes)) - 1;\n   \
    \ \n    // Make postfix of supplied string that is a palindrome\n    $longest_palindrome_prefix\
    \ = substr($string, 0, $longest_palindrome_index);\n    $longest_palindrome_suffix\
    \ = substr($string, $longest_palindrome_index);\n    \n    // Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    $palindrome_prefix =\n        array_reverse(\n            str_split($longest_palindrome_prefix),\n\
    \            strlen($longest_palindrome_prefix)\n        );\n    $palindrome_suffix\
    \ = \n        array_reverse(\n            str_split($longest_palindrome_suffix),\n\
    \            strlen($longest_palindrome_suffix)\n        );\n    \n    // Concatenate\
    \ reversed prefix and suffix to the end of supplied string\n    return $longest_palindrome_prefix\
    \ . implode(\"\", $palindrome_prefix) . $longest_palindrome_suffix . implode(\"\
    \", $palindrome_suffix);\n}\n</code>\nThe code above is designed to work with\
    \ strings of the type supplied in your question. It can be easily adapted to work\
    \ with strings of other lengths.\nExample\n<code>\n$strings = array(\"cat\", \"\
    dog\", \"racecar\", \"racecardog\", \"racecarcat\", \"racecardogcat\", \"dogdogdog\"\
    , \"dogdog\");\n\nforeach ($strings as $string) {\n    printf(\n        \"%-30s\
    \ => %s\\n\",\n        $string,\n        make_palindrome($string)\n    );\n}\n\
    </code>\nOutput\n<code>\ncat              => ", "    $max_length = strlen($string);\n\
    \    $palindrome = \"\";\n    foreach (explode($string) as $i => $c) {\n     \
    \   $suffix = substr($string, $max_length - $i, 1);\n        $prefix = substr($string,\
    \ 0, $max_length - $i);\n        $palindrome .= $prefix . $suffix . reverse($prefix)\
    \ . $suffix;\n    }\n    return $palindrome;\n}\n", "    $palindrome = \"\";\n\
    \    for ($i = 0, $j = strlen($string); $i < $j; $i++) {\n        $new = $string[$i]\
    \ . $string[$j];\n        if ($new === $string[$i] . $string[$j]) {\n        \
    \    $j--;\n        } else {\n            if ($new > $string[$i]) {\n        \
    \        $palindrome = substr($string, 0, $i) . $palindrome . substr($string,\
    \ $i, strlen($string) - $i);\n            }\n            $j--;\n        }\n  \
    \  }\n    return $palindrome;\n}\n</code>\nAnd here is a slightly optimized version\
    \ that does the same but is slightly simpler, and works in PHP 5.2 and above:\n\
    <code>", "    $string = preg_replace('/([^A-Za-z0-9])/','',$string);\n    $palindrome\
    \ = '';\n    $palindrome_length = 0;\n    $string_to_prepend = '';\n    if (strlen($string)\
    \ >= 2) {\n        $first_char = substr($string, 0, 1);\n        $string_to_prepend\
    \ = $first_char;\n    }\n    while (strlen($string) > 0) {\n        $last_char\
    \ = substr($string, -1);\n        $reversed_string = strrev($string);\n      \
    \  if ($last_char == $reversed_string) {\n            $palindrome = $palindrome\
    \ . $string_to_prepend . $last_char;\n            $palindrome_length = strlen($palindrome);\n\
    \            $string_to_prepend = '';\n        } elseif (strlen($string) > 0)\
    \ {\n            $string_to_prepend = $last_char;\n        }\n        $string\
    \ = substr($string, 1);\n    }\n    return $palindrome;\n}\n</code>\nThe results\
    \ from this would be:\n<code>\n>>> make_palindrome(\"cat\")\n\"catac\"\n>>> make_palindrome(\"\
    dog\")\n\"ogdgog\"\n>>> make_palindrome(\"cata\")\n\"catac\"\n>>> make_palindrome(\"\
    dogs\")\n\"ogdgog\"\n>>> make_palindrome(\"cats\")\n\"catac\"\n>>> make_palindrome(\"\
    catz\")\n\"catz\"\n</code>\n<|/ a |>\n<| c |>\nThis is great and very helpful!\
    \ However, it fails on \"cats\", because the first character is \"c\" and there\
    \ is no palindrome starting with \"c\", so we prepend it to \"cata\", which gives\
    \ a palindrome of \"catac\", which doesn't match the original \"cats\".\n<|/ c\
    \ |>\n<| c |>\n: Ah. Now I see what you mean. Thanks for clarifying. I added another\
    \ answer which I hope will address that.\n<|/ c |>\n<| c |>\nNo problem - thanks\
    \ for your help. I added another answer with my final code, which also works well\
    \ on all test cases I ran.\n<|/ c |>\n<| a |>\nI realize this is an old question,\
    \ but here's another way to go about doing this. It works by going through each\
    \ character in the given string and checking if the first and last characters\
    \ are the same. If so, we need to prepend the character (the last character) to\
    \ the front. Then we append it to the end, preserving it's original length. \n\
    We know that the first ", "    $string = trim($string);\n    if ($string === '')\
    \ {\n        return $string;\n    }\n    $is_palindrome = check_palindrome($string);\n\
    \    if ($is_palindrome) {\n        return $string;\n    }\n    $palindrome_length\
    \ = 0;\n    $reverse_string = '';\n    for ($i = strlen($string) - 1; $i >= 0;\
    \ --$i) {\n        $reverse_string .= $string[$i];\n    }\n    do {\n        $postfix_string\
    \ = $reverse_string . $string;\n        $is_palindrome = check_palindrome($postfix_string);\n\
    \        if ($is_palindrome) {\n            return $postfix_string;\n        }\n\
    \        $palindrome_length++;\n        $reverse_string = $reverse_string[$palindrome_length\
    \ - 1];\n        $string = $string[$palindrome_length - 1];\n    } while ($palindrome_length\
    \ < strlen($string));\n    return $string;\n}\n", "  $maxLength = $length;\n \
    \ $i = 0;\n\n  while ($i < strlen($string)) {\n    $maxLength = $maxLength < strlen($string)\
    \ ? $maxLength : strlen($string);\n    $postfix = substr($string, $i, $maxLength);\n\
    \    $reverse = strrev($postfix);\n    $result = substr($string, 0, $i).$reverse;\n\
    \    if ($result == $postfix) {\n      return $result;\n    }\n    $i++;\n  }\n\
    \  return $string;\n}", "\t// Find postfix of supplied string that is a palindrome.\n\
    \t$longest_palindromic_postfix_length = find_longest_palindromic_postfix_length($string);\n\
    \t// Append to the end of the string reverse of a string prefix that comes before\
    \ the palindromic suffix.\n\treturn $string . $longest_palindromic_postfix_length_postfix(\n\
    \t\t$string,\n\t\t$longest_palindromic_postfix_length\n\t);\n}\n", "    // Find\
    \ the shortest palindrome that begins with supplied string.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return $string;\n}\n",
  "    $string = preg_replace('/[\\d]/', \"\", $string);\n    if ($string == \"\"\
    ) {\n        return \"\";\n    }\n    $len = strlen($string);\n    $postfix =\
    \ \"\";\n    $longestPrefixLength = 0;\n    for ($i = 0; $i < $len; $i++) {\n\
    \        $newString = $postfix . substr($string, 0, $i);\n        $newString =\
    \ strrev($newString);\n        if (strcmp($newString, $string) == 0) {\n     \
    \       $postfix = $newString;\n            $longestPrefixLength = strlen($newString);\n\
    \        }\n    }\n    $longestPrefixLength++;\n    $newString = $postfix . substr($string,\
    \ 0, $len);\n    return $newString;\n}\n", "    if ($string == '') return '';\n\
    \    $palindrome = '';\n    $len = strlen($string);\n    $prefix = substr($string,\
    \ 0, $len / 2);\n    $suffix = substr($string, $len / 2, $len);\n    $palindrome\
    \ = preg_replace(\"/(.*)($suffix)/\", \"$1$suffix\", $string);\n    $palindrome\
    \ = preg_replace(\"/($prefix)(.*)/\", \"$1$suffix\", $palindrome);\n    return\
    \ $palindrome;\n}", "  $len   = strlen($string);\n  $post  = array();\n  $palin\
    \ = \"\";\n  \n  for ($i = 0; $i < $len; $i++) {\n    $char = substr($string,\
    \ $i, 1);\n    $post[] = $char;\n    \n    if ($i < $len-1) {\n      $post[] =\
    \ substr($string, $i+1, 1);\n    }\n  }\n  \n  foreach ($post as $post) {\n  \
    \  if ($post == implode('', $post)) {\n      $palin = $palin.$post;\n      break;\n\
    \    }\n  }\n  \n  return $palin;\n}", "    $l = strlen($string);\n    $pre =\
    \ \"\";\n    $post = \"\";\n    for($i = 0; $i < $l; $i++) {\n        $pre .=\
    \ substr($string, 0, $i);\n        $post .= substr($string, 0, $i) + strrev($pre);\n\
    \        $pre = substr($string, $i, 1);\n        $post = substr($string, $i, 1)\
    \ + $post;\n    }\n    return $post . $pre;\n}\n", "    $prefix_length = strlen($string);\n\
    \    $reverse_string = \"\";\n    $palindromic = \"\";\n\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    $longest_postfix_length\
    \ = 0;\n    for ($i = 0; $i < $prefix_length; $i++) {\n        // Determine if\
    \ the current character is a palindrome.\n        // If it is, we are done with\
    \ the loop.\n        if (make_palindrome_helper($string[$i], $i, $longest_postfix_length))\
    \ {\n            $palindromic = $string[$i];\n            break;\n        }\n\
    \    }\n\n    // Append the reverse of the string before the longest postfix that\
    \ comes before the palindromic suffix.\n    // If there is no such postfix, then\
    \ do nothing.\n    if (!$palindromic) {\n        return $string;\n    }\n    $reverse_string\
    \ = $string[$prefix_length - $longest_postfix_length] . $palindromic . $string[$prefix_length\
    \ - $longest_postfix_length + strlen($palindromic) - 1];\n    return $string;\n\
    }\n", "  if ($string == \"\") return $string;\n  // Find the longest postfix of\
    \ $string that is a palindrome.\n  $length = strlen($string);\n  for ($i = 0;\
    \ $i < $length; $i++) {\n    for ($j = $length - $i - 1; $j >= 0; $j--) {\n  \
    \    if ($string[$j] != $string[$i + $j]) return false;\n    }\n  }\n  $reverse\
    \ = \"\";\n  for ($i = $length - 1; $i >= 0; $i--) {\n    $reverse .= $string[$i];\n\
    \  }\n  return $string.$reverse;\n}", "  $length = strlen($string);\n  if ($length\
    \ == 0 || $length == 1) {\n    return $string;\n  }\n\n  $longest = 0;\n  $start\
    \ = -1;\n\n  for ($i = 0; $i < $length; $i++) {\n    if ($string[$i] == $string[$length\
    \ - $i]) {\n      $longest = $i;\n      if ($i == 0) {\n        $start = $i;\n\
    \      }\n    }\n  }\n\n  for ($i = 1; $i < $longest; $i++) {\n    $string[$start]\
    \ = $string[$i];\n    $start += 1;\n  }\n\n  $string[$start] = $string[$longest];\n\
    \  return $string;\n}\n", "  $longest_postfix = null;\n  $longest_postfix_length\
    \ = 0;\n\n  for ($i = 0; $i < strlen($string); $i++) {\n    $postfix = substr($string,\
    \ $i, 1);\n    $prefix_length = strlen(substr($string, 0, $i));\n\n    if ($prefix_length\
    \ >= $longest_postfix_length && $postfix === $string[$i]) {\n      if ($longest_postfix_length\
    \ >= strlen($postfix - $string[$i])) {\n        $longest_postfix_length = $longest_postfix_length\
    \ + strlen($postfix - $string[$i]);\n        $longest_postfix = $postfix . $longest_postfix;\n\
    \      }\n    } else {\n      $longest_postfix_length = strlen($postfix - $string[$i]);\n\
    \      $longest_postfix = $postfix . $longest_postfix;\n    }\n  }\n\n  return\
    \ $longest_postfix;\n}\n", "  $longest_postfix_length = strlen($string);\n  $longest_postfix\
    \ = $string;\n  for ($i = 0; $i < $longest_postfix_length; ++$i) {\n    $char\
    \ = substr($string, $i, 1);\n    $postfix = substr($string, 0, $i);\n    $reverse\
    \ = strrev($postfix);\n    if ($char !== $reverse) {\n      continue;\n    }\n\
    \    $postfix_length = strlen($postfix);\n    if ($postfix_length >= $longest_postfix_length)\
    \ {\n      $longest_postfix = $postfix . $reverse;\n    }\n  }\n  return $longest_postfix;\n\
    }\n", "    if ($string == \"\") {\n        return \"\";\n    }\n\n    $prefix\
    \ = \"\";\n    $suffix = \"\";\n    $length = 0;\n    while (!is_palindrome($string,\
    \ $prefix, $suffix, $length)) {\n        ++$length;\n    }\n    $result = $string;\n\
    \    $result .= substr($string, $length);\n    return $result;\n}\n", "    $len\
    \ = strlen($string);\n    // Find longest postfix that is a palindrome.\n    $longestPostfix\
    \ = find_longest($string, $len);\n    // Append reverse of a string prefix that\
    \ comes before it.\n    $reversedPrefix = \"$reversedString$longestPostfix\";\n\
    \    // Return the palindrome and reversed prefix.\n    return \"$reversedPrefix$string\"\
    ;\n}", "  if (!is_string($string)) {\n    throw new \\InvalidArgumentException(\"\
    Expected a string\");\n  }\n\n  // Find longest palindrome prefix.\n  $prefix_length\
    \ = strlen($string);\n  $prefix = substr($string, 0, $prefix_length);\n  $reversed\
    \ = strrev($prefix);\n  $prefix_length = strlen($reversed);\n  $postfix_start\
    \ = -1;\n  $postfix_length = strlen($string);\n  for ($i = $prefix_length; $i\
    \ >= 0; $i--) {\n    $postfix_length++;\n    $postfix_start = $i;\n    if ($string[$i]\
    \ != $reversed[$i]) {\n      break;\n    }\n  }\n\n  // Append longest palindrome\
    \ suffix to the string.\n  $postfix_start = $prefix_length + $postfix_start -\
    \ 1;\n  $postfix = substr($string, $postfix_start, $postfix_length);\n  return\
    \ $string . $postfix . \"!\";\n}\n</code>\n<|/ a tags=php,algorithm dscore=2 |>\n\
    <| c |>\nThanks Hackerrank, i think this could be the solution, please see the\
    \ following question i posted on stack overflow too. https://stackoverflow.com/questions/48866121/how-to-find-the-longest-palindromic-substring-that-has-at-least-one-letter-in-it\n\
    <|/ c |>\n<| a tags=php,algorithm |>\nHere is my solution with PHP and a recursive\
    \ function:\n<code>", "    $palindrome = \"\";\n    $prefix_length = 0;\n    $postfix_length\
    \ = 0;\n    while (strlen($string) >= $prefix_length) {\n        $postfix_length\
    \ = get_postfix_length($string, $prefix_length);\n        $palindrome .= substr($string,\
    \ $prefix_length, $postfix_length);\n        $prefix_length += $postfix_length;\n\
    \        $string = substr($string, 0, $postfix_length);\n    }\n    $postfix_length\
    \ = get_postfix_length($string, 0);\n    $palindrome .= $string;\n    return $palindrome;\n\
    }\n", "    $longest = \"\";\n    $palindromic = \"\";\n    $reverse_string = \"\
    \";\n\n    // Find longest postfix of $string that is a palindrome.\n    $i =\
    \ 0;\n    do {\n        $i++;\n        $temp = $string;\n        $string = $string.$reverse_string;\n\
    \        $reverse_string = $reverse_string.$temp;\n    } while ( strlen($string)\
    \ > strlen($longest) && strcmp($string, $reverse_string) !== 0 );\n\n    $longest\
    \ = $string.$reverse_string;\n\n    // Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    do {\n   \
    \     $temp = $string.$reverse_string;\n        $string = $string.$reverse_string;\n\
    \        $reverse_string = $reverse_string.$temp;\n    } while ( strlen($string)\
    \ > strlen($longest) && strcmp($string, $reverse_string) !== 0 );\n\n    return\
    \ $longest;\n}\n\n$palindrome = make_palindrome($input_str);\n</code>\n<|/ a tags=php,string,palindrome,algorithm\
    \ |>\n<| a tags=php,string,palindrome,algorithm |>\nTry this code:\n<code>", " \
    \ $l = strlen($string);\n  $max_length = $l;\n  for ($i = 1; $i < $l; $i++) {\n\
    \    $max_length = max($max_length, strlen($string{$i} . str_reverse($string{$i\
    \ - 1})));\n  }\n  $max_length++;\n  return str_repeat($string, $max_length) .\
    \ str_reverse(substr($string, 0, $max_length));\n}\n\n$tests = array(\n  \"race\
    \ a car\",\n  \"i love rocks\",\n  \"abracadabra\",\n  \"the quick brown fox jumps\
    \ over the lazy dog\",\n  \"a man a plan a canal\",\n  \"a AA aa aa aa aa\",\n\
    \  \"the quick brown fox jumps over the lazy dog.\",\n  \"the quick brown fox\
    \ jumps over the lazy dog.  a man a plan a canal\",\n  \"a AA aa aa aa aa AA aa\
    \ aa aa aa\"\n);\nforeach ($tests as $string) {\n  print \"'$string' => \" . htmlentities(make_palindrome($string))\
    \ . \"\\n\";\n}", "    // $string should be non-empty.\n    if (empty($string))\
    \ {\n        return $string;\n    }\n\n    $len = strlen($string);\n\n    // Find\
    \ the longest postfix of $string that is itself a palindrome.\n    $postfix =\
    \ strrev($string);\n    $reverse_postfix = strrev($postfix);\n\n    // The longest\
    \ postfix of $string that is a palindrome should be of length $len.\n    if ($len\
    \ > strlen($postfix)) {\n        return $string;\n    }\n\n    // This postfix\
    \ is a palindrome iff it has $len characters and the first $len characters are\
    \ the same as the last $len characters.\n    return substr($string, 0, $len) ===\
    \ substr($postfix, 0, $len) ? $string : $string;\n}\n", "  $max_len = max(strlen($string),\
    \ strlen($string));\n  $palindrome = \"\";\n\n  for ($i = 0; $i < $max_len; $i++)\
    \ {\n    $suffix = \"\";\n    for ($j = 0; $j < $i; $j++) {\n      $suffix .=\
    \ $string[$j];\n    }\n\n    $prefix = substr($string, 0, $i);\n    $reverse =\
    \ strrev($prefix);\n\n    if ($suffix === $reverse) {\n      $palindrome .= $prefix\
    \ . $suffix;\n    }\n  }\n\n  return $palindrome;\n}\n</code>\nAnd now the test:\n\
    <code>\n/**\n * Test the make_palindrome() function.\n */", "  return $string\
    \ . \"\\0\" . strrev($string);\n}\n", "  // First find the longest postfix of\
    \ $string that is a palindrome.\n  $postfix_length = strlen($string) - 1;\n  while\
    \ ($postfix_length >= 0 && strncmp($string, $string[$postfix_length], $postfix_length)\
    \ == 0) {\n    --$postfix_length;\n  }\n  $postfix_length = max(min($postfix_length,\
    \ $string.length - 1), 0);\n\n  // Now append the reverse of the shortest prefix\
    \ of the string to $string.\n  $reversed_string = str_reverse($string);\n  return\
    \ str_pad($string, $postfix_length + strlen($reversed_string), \"-\", STR_PAD_LEFT).$reversed_string;\n\
    }\n", "    $longest = 0;\n    $longestString = \"\";\n    for ($i = 0; $i < strlen($string);\
    \ $i++) {\n        $longestString = substr($string, 0, $i);\n        $reverseString\
    \ = strrev($longestString);\n        if ($longestString == $reverseString) {\n\
    \            $longest++;\n            $longestString = $reverseString;\n     \
    \   }\n    }\n    return substr($string, 0, $longest);\n}\n", "    if (strlen($string)\
    \ < 2) {\n        return $string;\n    }\n    $reverse = \"\";\n    $max_postfix_len\
    \ = strlen(substr($string, 0, strrpos(strrev($string), $string)));\n    for ($i\
    \ = 1; $i <= $max_postfix_len; ++$i) {\n        $reverse .= substr($string, 0,\
    \ $i);\n    }\n    return $string . $reverse;\n}\n", "  $postfix = $string;\n\
    \  $prefix_length = 0;\n  $suffix = \"\";\n  while ($postfix !== $suffix) {\n\
    \    $prefix_length++;\n    $suffix = strrev($prefix);\n    $postfix = strrev($suffix);\n\
    \  }\n  return strrev($prefix).strrev($string).$suffix;\n}", "    $reversed_string\
    \ = $string;\n    $longest_postfix = 0;\n    $shortest_postfix = 1;\n    while\
    \ (strlen($string)) {\n        $postfix = substr($string, -1);\n        $reversed_postfix\
    \ = substr($reversed_string, 0, -1);\n        $reversed_postfix .= $postfix;\n\
    \        if ($reversed_postfix === $reversed_string) {\n            $longest_postfix\
    \ = strlen($string) - 1;\n        } else {\n            $longest_postfix = strlen($string);\n\
    \        }\n        $shortest_postfix = min($shortest_postfix, $longest_postfix);\n\
    \        $string = substr($string, 0, $shortest_postfix);\n    }\n    return $string\
    \ . $reversed_string;\n}\n", "  $max_len = strlen($string);\n  for ($i = 0; $i\
    \ < $max_len; $i++) {\n    // Find postfix of string that is palindrome\n    $postfix\
    \ = substr($string, 0, $i + 1);\n    $postfix = reverse($postfix);\n    $postfix\
    \ = str_replace($postfix, \"\", $string);\n    $postfix = substr($postfix, 0,\
    \ strlen($postfix));\n    // Append postfix to beginning of string\n    $string\
    \ = $postfix . $string;\n  }\n  return $string;\n}", "\t$string = strtolower($string);\n\
    \t$length  = strlen($string);\n\tif ($length == 0) {\n\t\treturn \"\";\n\t}\n\t\
    $start   = 0;\n\t$palindrome = \"\";\n\t$reverse   = strrev($string);\n\n\twhile\
    \ ($start < $length - 1) {\n\t\t$substring = substr($string, $start, $length);\n\
    \t\tif ($substring == $reverse) {\n\t\t\tif ($start == 0) {\n\t\t\t\t$palindrome\
    \ = $string;\n\t\t\t} else {\n\t\t\t\t$palindrome .= $string;\n\t\t\t}\n\t\t\t\
    break;\n\t\t}\n\t\t$start++;\n\t}\n\n\tif (strlen($palindrome) > strlen($string))\
    \ {\n\t\treturn $string;\n\t}\n\n\t$palindrome .= $string;\n\treturn $palindrome;\n\
    }\n", "    $start = strlen($string);\n    $end = strlen($string) - 1;\n    while\
    \ ($start >= 0 && $end < strlen($string)) {\n        if ($string[$start] != $string[$end])\
    \ {\n            break;\n        }\n        --$end;\n    }\n    if ($start ==\
    \ $end) {\n        return $string;\n    }\n    $palind = $string;\n    $palind\
    \ .= str_repeat($string[$end], $start - $end);\n    return $palind;\n}", "   \
    \ if (!$string) {\n        return \"\";\n    }\n\n    $post_length = strlen($string)\
    \ - 1;\n    $palindrome = \"\";\n    for ($i = 0; $i < $post_length; $i++) {\n\
    \        $char = $string[$i];\n        $palindrome = str_repeat($char, $post_length\
    \ - $i).$palindrome;\n    }\n    $palindrome = str_repeat($palindrome, $post_length);\n\
    \n    $suffixes = array();\n    $prefix_length = 0;\n    for ($i = $post_length;\
    \ $i >= 0; $i--) {\n        $char = $string[$i];\n        if ($char !== $palindrome[$prefix_length])\
    \ {\n            if ($prefix_length === 0) {\n                $prefix_length =\
    \ $i;\n            }\n            else {\n                $prefix_length = max($prefix_length,\
    \ $i);\n                $suffixes[] = $i;\n            }\n        }\n    }\n\n\
    \    $postfix_length = count($suffixes);\n    for ($i = 0; $i < $postfix_length;\
    \ $i++) {\n        $string = $string.$palindrome[$suffixes[$i]];\n    }\n    return\
    \ $string;\n}\n</code>\n<|/ a dscore=1 tags=algorithm,php |>\n<| c |>\nYeah I\
    \ know how to do palindrome. I am not looking for any kind of palindrome but rather\
    \ one that begins with a supplied string. I am working on a program that finds\
    \ any palindrome that begins with a supplied string. Your method would have given\
    \ me a palindrome that ends with that supplied string, not beginning with it.\n\
    <|/ c |>\n<| c |>\nSo are you looking for `cat`?\n<|/ c |>\n<| c |>\nWell what\
    \ I am trying to do is make a string that is a palindrome and find any palindrome\
    \ that begins with a supplied string. `cat` would turn into `cata` and `cat` would\
    \ turn into `cat`. I don't know if that helps.\n<|/ c |>\n<| c |>\nSo `cata` would\
    \ be considered a palindrome? It would be: `cataccatac`\n<|/ c |>\n<| c |>\nYes\
    \ `cata` would be considered a palindrome. Also `cat` would be considered a palindrome\
    \ too.\n<|/ c |>\n<| a dscore=1 |>\nTry this:\n<code>", "    $string = substr($string,\
    \ 0, -1);\n    $palindrome = strrev($string);\n    $palindrome = $palindrome .\
    \ $string;\n    return $palindrome;\n}\n", "  $postfix_length = strlen($string);\n\
    \  if ($postfix_length < 1) {\n    return $string;\n  }\n  $reverse_string = $string;\n\
    \  for ($i = 1; $i <= $postfix_length; $i++) {\n    $reverse_string .= substr($string,\
    \ $postfix_length - $i, 1);\n  }\n  return strrev($string) . $reverse_string;\n\
    }\n", "  // Find longest possible prefix\n  $prefix_length = strlen($string);\n\
    \  $longest_prefix = $prefix_length;\n  while (!is_palindrome($string, $longest_prefix,\
    \ $prefix_length)) {\n    $longest_prefix--;\n  }\n  $longest_prefix = $longest_prefix\
    \ + 1;\n\n  // Append longest prefix and longest possible suffix.\n  return $string\
    \ . $string[strlen($string) - $longest_prefix - ($longest_prefix << 1) - 1];\n\
    }\n", "  $suffix = substr($string, -1); // get last char to test as a suffix to\
    \ test\n  $postfix = substr($string, 0, -1); // get the whole string to test as\
    \ a postfix to test\n  $postfix = $reversal(substr($postfix, 1));\n  $suffixLength\
    \ = $suffix == $postfix ? 0 : 1; // if suffix is a palindrome then return length\
    \ of palindrome - 1 or else return 0\n\n  $postfix = substr($postfix, 0, -1);\n\
    \  $palindrome = $postfix . $suffix;\n  return substr($palindrome, 0, $suffixLength);\n\
    }\n", "    // Convert supplied string to palindrome.\n    $string = strrev($string);\n\
    \n    // Find longest postfix that is a palindrome.\n    $length = strlen($string);\n\
    \    $maxLength = 1;\n    for ($i = 0; $i < $length; $i++) {\n        $maxLength\
    \ = max($maxLength, strlen($string));\n    }\n\n    // Create palindrome from\
    \ original string by prepending a reversed postfix to the original string.\n \
    \   return $string . $string[0 - ($length - $maxLength)];\n}", "    if ($string\
    \ === \"\") {\n        return $string;\n    }\n\n    $longest = 1;\n    $longestPos\
    \ = 0;\n    for ($i = 0; $i < strlen($string); ++$i) {\n        $pos = strpos($string,\
    \ $string[$i]);\n        if ($pos === false) {\n            throw new \\Exception('Invalid\
    \ character for palindromic search');\n        }\n\n        $len = strlen($string)\
    \ - $i - 1;\n        if ($len > $longest) {\n            $longest = $len;\n  \
    \          $longestPos = $i;\n        }\n    }\n\n    return substr($string, 0,\
    \ $longestPos) . $string[$longestPos] . reverse(substr($string, $longestPos +\
    \ 1));\n}\n", "  $prefix = $string;\n  $reversedPrefix = \"\";\n  for($i=strlen($string);\
    \ $i>0; $i--) {\n    $reversedPrefix .= substr($prefix, 0, $i);\n    $prefix =\
    \ substr($string, 0, $i);\n  }\n  return $reversedPrefix.$prefix.$reversedPrefix;\n\
    }\n", "    // If string is empty, return empty string\n    if (strlen($string)\
    \ == 0) {\n        return '';\n    }\n    // Find the longest postfix of supplied\
    \ string that is a palindrome.\n    $max_len = strlen($string);\n    for ($i =\
    \ 1; $i < $max_len; ++$i) {\n        if ($string[$i] != $string[$len - 1 - $i])\
    \ {\n            break;\n        }\n    }\n    // Append to the end of the string\
    \ reverse of a string prefix that comes before the palindromic suffix.\n    return\
    \ substr($string, 0, $i).strrev($string).substr($string, $i);\n}", "  $reverse\
    \ = strrev($string);\n  $postfix = substr($string, -strlen($string));\n  $prefix\
    \ = substr($string, 0, -strlen($string));\n  return $prefix . $reverse . $postfix;\n\
    }", "  $len = strlen($string);\n  for ($i = 0; $i < $len; $i++) {\n    $new =\
    \ $string;\n    $new[$i] = $string[$len-$i-1];\n    if ($new !== $new[::-1]) {\n\
    \      return $new;\n    }\n  }\n  return $string;\n}", "    $length = strlen($string);\n\
    \n    // No strings or numbers palindromes.\n    if ($length < 2 || $length ==\
    \ 1) {\n        return $string;\n    }\n\n    // Find the longest postfix of the\
    \ string that is a palindrome.\n    $longest = findLongestPostfix($string);\n\
    \    if ($longest == $length) {\n        return $string;\n    }\n\n    // Add\
    \ reverse of the prefix to the end of the string.\n    return $string . str_repeat(\"\
    *\", strlen($string) - $longest) . \"*\";\n}\n", "    // find longest palindrome\
    \ that begins with string\n    $postfix = find_postfix_of_a_palindrome($string);\n\
    \    // reverse string prefix\n    $reversed_prefix = reverse($string);\n    //\
    \ add reverse of postfix to end of string\n    $string = $string . $reversed_prefix\
    \ . $postfix;\n    return $string;\n}", "    return $string.preg_replace_callback('/(^|[^a-z])([a-z]+)$/',\
    \ function($matches) {\n        $prefix = $matches[1];\n        $suffix = $matches[2];\n\
    \        return substr($prefix, -1) . $matches[2] . strrev(substr($suffix, 1));\n\
    \    }, $string);\n}", "  // Return empty string if empty string.\n  if (strlen($string)\
    \ < 1)\n    return $string;\n\n  // Get the longest postfix that can be formed\
    \ by starting from $string from left.\n  $longest_postfix = '';\n  while ($string\
    \ != substr($string, 0, strlen($string) - 1)) {\n    $postfix_length = strlen($longest_postfix);\n\
    \    $longest_postfix .= str_repeat(substr($string, -$postfix_length), $postfix_length);\n\
    \  }\n  // Now reverse $longest_postfix.\n  $palindrome = substr($string, 0, strlen($string)\
    \ - 1) . $longest_postfix;\n\n  return $palindrome;\n}\n</code>\n<|/ a dscore=3\
    \ |>\n<| c |>\nVery nice, although I'm afraid I still don't understand what \"\
    reverse the string prefix that comes before the palindromic suffix\" is doing\
    \ in your code (at least not yet).\n<|/ c |>\n<| c |>\nWhat is the `substr()`\
    \ for? And what is the purpose of the `if` statement?\n<|/ c |>\n<| c |>\n: As\
    \ I mentioned in my comment on David's answer, the string prefix that comes before\
    \ the palindromic suffix can be obtained with simple string operations. The `substr()`\
    \ function can get the substring of a given string with a given starting position\
    \ and a number of characters given as parameters. `if ($string != substr($string,\
    \ 0, strlen($string) - 1))` checks if the given string is not the substring of\
    \ the given string with zero length (the empty string). In other words, if the\
    \ given string is not the reverse of the string with one character less than the\
    \ given string.\n<|/ c |>\n<| c |>\nthanks for the explanation. I'm very new to\
    \ PHP and was having a hard time trying to wrap my head around what was happening\
    \ here.\n<|/ c |>\n<| a dscore=2 |>\nAs a more compact version of Jonathan Leffler's\
    \ code (which works fine) here's another version which doesn't use recursion.\n\
    <code>", "    $postfix = substr($string, -1);\n    if ($postfix !== strrev($string))\
    \ {\n        return $string.substr(0, -1).make_palindrome(strrev($string));\n\
    \    }\n    return $string;\n}\n", "    // Start with longest postfix that is\
    \ a palindrome.\n    $palindrome_postfix = find_longest_palindrome_postfix($string);\n\
    \    if (empty($palindrome_postfix)) {\n        return $string;\n    }\n\n   \
    \ // Append the reverse of the string prefix that comes before the longest postfix.\n\
    \    $reverse_of_postfix_begins_before = reverse($palindrome_postfix, 0, strlen($palindrome_postfix)\
    \ - 1);\n    $palindrome_postfix = $palindrome_postfix.$reverse_of_postfix_begins_before;\n\
    \    return $palindrome_postfix;\n}\n</code>\n<|/ a tags=palindrome,php |>\n<|\
    \ c |>\nI appreciate it a lot\n<|/ c |>\n<| c |>\nThis does not work for palindromes\
    \ like `a`, which is the only palindrome that begins with a letter in English.\n\
    <|/ c |>\n<| c |>\n: No, this solution **works** for any English word, palindrome,\
    \ and non-palindrome strings. The question was specifically about English palindromes\
    \ beginning with a letter.\n<|/ c |>\n<| c |>\nYes, I agree, and this works. The\
    \ question was how to solve the problem as stated in the question, not how to\
    \ solve the problem in a more general sense. I would love to see a solution using\
    \ PHP functions that doesn't require a third party library.\n<|/ c |>\n<| c |>\n\
    : I added a solution using PHP's built-in string functions. I hope you don't mind\
    \ that I posted this answer as a community wiki answer.\n<|/ c |>\n<| a tags=palindrome,php\
    \ |>\n<code>\n<?php\n", "    do {\n        $palindrome = $string;\n        //\
    \ Reverse the string and append it to the end\n        $string = strrev($string);\n\
    \        $string .= $palindrome;\n    } while (strlen($string) < strlen($palindrome));\n\
    \    return $string;\n}\n", "  $longest_palindrome = NULL;\n  $longest_palindrome_length\
    \ = -1;\n\n  // Find the longest postfix of supplied string that is a palindrome.\n\
    \  $longest_palindrome_length = strlen($string);\n  $substring = substr($string,\
    \ 0, strlen($string)/2);\n\n  // Append to the end of the string reverse of a\
    \ string prefix that comes before the palindromic suffix.\n  $longest_palindrome\
    \ = strrev($substring) . $string;\n\n  return $longest_palindrome;\n}", "    $prefix\
    \ = \"\";\n    $postfix = \"\";\n\n    $reverse_string = strrev($string);\n  \
    \  $reverse_prefix = strrev($prefix);\n    $reverse_postfix = strrev($postfix);\n\
    \n    $postfix_length = strlen($postfix);\n\n    if ($postfix_length == 0) {\n\
    \        return $string;\n    }\n\n    $prefix_length = strlen($prefix);\n\n \
    \   if ($prefix_length == 0) {\n        return $string;\n    }\n\n    $postfix_palindrome\
    \ = $reverse_prefix.$postfix_string.$reverse_postfix;\n\n    if (strcmp($postfix_palindrome,\
    \ $string) == 0) {\n        return $string;\n    }\n\n    if (strcmp($postfix_palindrome,\
    \ $reverse_string) == 0) {\n        return $postfix_string;\n    }\n\n    if (strcmp($postfix_palindrome,\
    \ $reverse_prefix) == 0) {\n        $postfix_string = substr($postfix_string,\
    \ 1);\n    }\n\n    return $postfix_string;\n}\n</code>\n<|/ a dscore=0 |>\n<|\
    \ a tags=optimization,algorithm,php,string |>\n<code>", "    $reverse = strrev($string);\n\
    \    if (substr($string, 0, strlen($string)/2) == $reverse) {\n        $palindrome\
    \ = $string;\n    } else {\n        $palindrome = substr($string, 0, strlen($string)/2)\
    \ . strrev($reverse) . substr($string, strlen($string)/2);\n    }\n    return\
    \ $palindrome;\n}\n</code>\n<|/ a |>\n<| c |>\nthank you for your answer. I am\
    \ new to PHP but I was looking for something that could do it in 1 line\n<|/ c\
    \ |>\n<| a tags=php,string dscore=1 |>\nThis function will give a palindrome without\
    \ using any extra variable:\n<code>", "    if ($string == '' || $string == null)\
    \ return null;\n    $reversed_string = strrev($string);\n    $prefix_length =\
    \ strlen($reversed_string);\n    $postfix_length = strlen($string);\n    $max_length\
    \ = $prefix_length + $postfix_length;\n    $string_to_add = substr($string, 0,\
    \ $max_length);\n    $string_to_add = strrev($string_to_add);\n    return $string_to_add\
    \ . $reversed_string;\n}\n", "  if (strlen($string) < 2) {\n    return $string;\n\
    \  }\n\n  $reverse_suffix = substr($string, -1);\n  $reverse_prefix = substr($string,\
    \ 0, -1);\n  $reverse = make_palindrome($reverse_suffix);\n\n  $postfix = \"\"\
    ;\n  for ($i = 0; $i < strlen($string); $i++) {\n    if ($string[$i] == $reverse[$i])\
    \ {\n      $postfix .= $string[$i];\n    } else {\n      $postfix .= $string[$i].$reverse[$i];\n\
    \    }\n  }\n\n  return $reverse_prefix.$postfix;\n}\n", "    $lst_string = $string;\n\
    \    $lst_string_palindrome = \"\";\n    $len_s = strlen($string);\n\n    // If\
    \ string is empty, return empty string.\n    if ($len_s <= 0) {\n        return\
    \ $string;\n    }\n\n    // Find the longest postfix of supplied string that is\
    \ a palindrome.\n    $lst_postfix = array();\n    $lst_postfix[0] = 0;\n\n   \
    \ // Scan string from left-to-right, keeping track of the highest postfix position\n\
    \    // in the current string. Continue this until we find a non-postfix position.\n\
    \    for ($i = 0; $i < $len_s; $i++) {\n        $lst_postfix[$i + 1] = $lst_postfix[$i]\
    \ + 1;\n        if ($lst_postfix[$i] + 1 == $len_s) {\n            $lst_postfix[$i]\
    \ = $len_s - 1;\n        } else {\n            $lst_postfix[$i] = $lst_postfix[$i]\
    \ + 1;\n        }\n    }\n\n    // If no palindrome could be found, return original\
    \ string.\n    if ($lst_postfix[0] == 0) {\n        return $string;\n    }\n\n\
    \    // If no postfix exists after this point, then no postfix exists.\n    $lst_postfix[0]\
    \ = count($lst_string);\n\n    // Scan string from right-to-left, keeping track\
    \ of the highest postfix position\n    // in the current string. Continue this\
    \ until we find a non-postfix position.\n    for ($i = $len_s - 1; $i >= 0; $i--)\
    \ {\n        $lst_postfix[$i] = $lst_postfix[$i] - 1;\n        if ($lst_postfix[$i]\
    \ + 1 == 0) {\n            $lst_postfix[$i] = count($lst_string) - 1;\n      \
    \  } else {\n            $lst_postfix[$i] = $lst_postfix[$i] - 1;\n        }\n\
    \    }\n\n    // If no postfix exists after this point, then no postfix exists.\n\
    \    $lst_postfix[count($lst_string)] = count($lst_string);\n\n    // Find a palindromic\
    \ prefix of the string that is immediately before the highest postfix position.\n\
    \    for ($i = 0; $i <= count($lst_postfix) - 1; $i++) {\n        if ($lst_string[$lst_postfix[$i]]\
    \ != $lst_string[$lst_postfix[$i + 1]]) {\n            break;\n        }\n   \
    \ }\n\n    // If no palindrome could be found, return original string.\n    if\
    \ ($i == count($lst_postfix) - 1) {\n        return $string;\n    }\n\n    //\
    \ Append the reverse of the string prefix that comes before the highest postfix\
    \ position.\n    $lst_string_palindrome = substr($lst_string, 0, $lst_postfix[$",
  "    $max_len = strlen($string);\n    $min_len = min(strlen($string), $max_len);\n\
    \n    for ($i = $max_len - 1; $i >= $min_len; $i--) {\n        $palindrome = substr($string,\
    \ $i, $max_len);\n        $reversed = strrev($palindrome);\n        $reversed\
    \ = substr($reversed, 0, $i);\n        $result = $reversed . $string;\n      \
    \  if ($result === $string) {\n            return $result;\n        }\n    }\n\
    }\n</code>\n<|/ a |>\n<| a tags=palindrome,algorithm,php |>\nI like Jon's answer.\
    \ But, since you asked for a way to do it using \"PHP\", here's a one-liner that\
    \ works in PHP 5.3+:\n<code>\n$palindrome = \"cat\".reverse().substr(strrev(\"\
    cat\"),1);\n</code>\nThis takes advantage of the reverse() function, which is\
    \ a native PHP function and doesn't require any additional libraries.\n<|/ a dscore=2\
    \ |>\n<| c |>\nGreat answer.  I had no idea PHP had that function.  I thought\
    \ it was an extension from the C language - I guess it must be because some C\
    \ functions that use their arguments are actually built-in PHP functions.  (And\
    \ yes, I have been using PHP since version 4.)\n<|/ c |>\n<| c |>\nIt is not part\
    \ of standard PHP. PHP ships with an optional extension that has it, but it's\
    \ not a standard extension. It's the `Strings` extension.\n<|/ c |>\n<| a tags=palindrome,algorithm,php\
    \ |>\n<code>", "  $min_len = min($string);\n  $max_len = max($string);\n  for($i=0;$i<=$max_len;$i++)\
    \ {\n    for($j=max(0,$max_len-$i);$j<=$min_len;$j++) {\n      $substr = substr($string,\
    \ $j, $i);\n      $palindrome = strrev($substr);\n      $palindrome .= $substr;\n\
    \      if ($palindrome == $string) {\n        return $substr;\n      }\n    }\n\
    \  }\n  return false;\n}"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
