name: HumanEval_31_is_prime
language: php
prompt: "<?php\n// Return true if a given number is prime, and false otherwise.\n\
  // >>> is_prime(6)\n// false\n// >>> is_prime(101)\n// true\n// >>> is_prime(11)\n\
  // true\n// >>> is_prime(13441)\n// true\n// >>> is_prime(61)\n// true\n// >>> is_prime(4)\n\
  // false\n// >>> is_prime(1)\n// false\nfunction is_prime($n) {\n"
tests: "function candidate(...$args) {\n    return is_prime(...$args);\n}\n\nfunction\
  \ test(): void {\n    if (candidate(6) !== false) { throw new Exception(\"Test failed!\"\
  ); }\n    if (candidate(101) !== true) { throw new Exception(\"Test failed!\");\
  \ }\n    if (candidate(11) !== true) { throw new Exception(\"Test failed!\"); }\n\
  \    if (candidate(13441) !== true) { throw new Exception(\"Test failed!\"); }\n\
  \    if (candidate(61) !== true) { throw new Exception(\"Test failed!\"); }\n  \
  \  if (candidate(4) !== false) { throw new Exception(\"Test failed!\"); }\n    if\
  \ (candidate(1) !== false) { throw new Exception(\"Test failed!\"); }\n    if (candidate(5)\
  \ !== true) { throw new Exception(\"Test failed!\"); }\n    if (candidate(11) !==\
  \ true) { throw new Exception(\"Test failed!\"); }\n    if (candidate(17) !== true)\
  \ { throw new Exception(\"Test failed!\"); }\n    if (candidate(85) !== false) {\
  \ throw new Exception(\"Test failed!\"); }\n    if (candidate(77) !== false) { throw\
  \ new Exception(\"Test failed!\"); }\n    if (candidate(255379) !== false) { throw\
  \ new Exception(\"Test failed!\"); }\n}\n\ntest();"
completions: ["    \n    \n    return $n >= 2 && (!$n & 0x1) && is_prime($n / 2);\n\
    }\n", "    if (!$n) {\n        return false;\n    }\n\n    if ($n == 2 || $n ==\
    \ 3) {\n        return true;\n    }\n\n    if (!is_int($n)) {\n        return\
    \ false;\n    }\n\n    // Check to see if n is odd\n    $n = abs($n);\n    if\
    \ ($n % 2) {\n        return false;\n    }\n\n    // Check if n is prime\n   \
    \ if ($n < 3 || $n % 3 == 0) {\n        return true;\n    }\n\n    // Check all\
    \ even numbers, 4 and above.\n    for ($i = 2; $i <= (6 * $n) - 1; $i += 2) {\n\
    \        if ($n % $i == 0) {\n            return false;\n        }\n    }\n\n\
    \    // Check all odd compoents, 3 and above.\n    for ($i = 2; $i <= (6 * $n)\
    \ + 1; $i += 2) {\n        if ($n % $i == 0) {\n            return true;\n   \
    \     }\n    }\n\n    return false;\n}\n</code>\n<|/ a tags=algorithm,php dscore=1\
    \ |>\n<| c |>\nThis does not work, try it with `is_prime(61)` and the script will\
    \ hang indefinitely. The only way to solve this is to change `is_prime` so that\
    \ it works with integers instead of floats.\n<|/ c |>\n<| c |>\nI already tested\
    \ it on php 7.3 & 7.4. All works.\n<|/ c |>\n<| c |>\nTry `is_prime(61)`, and\
    \ the script will hang, because the `sqrt` function works on floats too. You need\
    \ to find a way to make this work with integers instead.\n<|/ c |>\n<| c |>\n\
    , Ok i see. I will edit my answer.\n<|/ c |>\n<| c |>\n, Yes i know. I will edit\
    \ my answer. I did not try it. It seems i did not realized `sqrt` only works on\
    \ float numbers. So i will edit my answer. Thanks for your notice.\n<|/ c |>\n\
    <| a |>\nYou could try this :\n<code>", "  if ($n == 2 || $n == 3) {\n    return\
    \ true;\n  }\n  $max = $n - 2;\n  for ($i = 2; $i <= $max; $i++) {\n    if ($n\
    \ % $i == 0 || $n % ($i + 1) == 0) {\n      return false;\n    }\n  }\n  return\
    \ true;\n}\n", "    $primes = array(\n        2, 3, 5, 7, 11, 13, 17, 19, 23,\
    \ 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97\n    );\n   \
    \ return in_array($n, $primes);\n}\n", "    if ($n < 2) {\n        return false;\n\
    \    }\n\n    if ($n == 2) {\n        return true;\n    }\n\n    if ($n % 2 ==\
    \ 0) {\n        return false;\n    }\n\n    $root = $this->sqrt($n);\n    for\
    \ (; $root >= 2; $root--) {\n        if ($n % $root == 0) {\n            return\
    \ false;\n        }\n    }\n\n    return true;\n}\n", "    if($n == 1) return\
    \ false;\n    if($n == 2 || $n == 3) return true;\n    if($n % 2 == 0 || $n %\
    \ 3 == 0) return false;\n    $m = $n-1;\n    while ($m % 2 == 0) {\n        $m\
    \ /= 2;\n    }\n    for ($i = 3; $i * $i <= $n; $i += 2)\n        if ($n % $i\
    \ == 0 || $n % ($i + 1) == 0)\n            return false;\n    return true;\n}\n",
  "  $t = sqrt(($n-1) / 2);\n  for($x=1; $x<$t; $x++) {\n    if($n % $x == 0) return\
    \ false;\n  }\n  return true;\n}", "  // Remove this line and write your own code\
    \ to test if $n is prime\n  return $n % 2 == 0;\n}\n", "    for ($i = 2; $i <\
    \ $n; ++$i) {\n        if ($n % $i == 0) {\n            return false;\n      \
    \  }\n    }\n    return true;\n}\n", "    if ($n < 2) {\n        return false;\n\
    \    }\n    if ($n <= 1) {\n        return false;\n    }\n    if ($n % 2 === 0)\
    \ {\n        return false;\n    }\n    for ($i = 3; $i * $i <= $n; $i += 2) {\n\
    \        if ($n % $i === 0) {\n            return false;\n        }\n    }\n \
    \   return true;\n}\n", "  for ($i = 0; $i < count($factors); ++$i) {\n    if\
    \ ($factors[$i] * $n == $n) return true;\n  }\n  return false;\n}", "    return\
    \ !is_prime_fast($n, $n);\n}", "    // This implementation is extremely slow.\
    \ It was written during an\n    // online programming contest and is not suitable\
    \ for anything else.\n    // See https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\
    \    $start = 2;\n    $end = ($n >> 1) << 1;\n    ++$end;\n\n    $n = 2 * $n -\
    \ 1;\n\n    while ($start <= $end) {\n        $m = $start++ >> 1;\n        if\
    \ ($n >= $m) {\n            $n = ($n >> 1) ^ 0x3ffffff;\n        } else {\n  \
    \          $n = $n % $m;\n        }\n    }\n\n    return $n <= 1;\n}\n", "  $n\
    \ = abs($n);\n  for ($i = 3; $i <= sqrt($n); ++$i) {\n    if ($n % $i == 0) {\n\
    \      return false;\n    }\n  }\n  return true;\n}\n", "  $n = abs($n);\n  if\
    \ ($n <= 1) return false;\n  $n_log2 = $log2($n);\n  $log_m = $log_m + $n_log2;\n\
    \  $i = (int) floor($log_m);\n  if ($i == $log_m) return false;\n  while ($i %\
    \ $n != 0) {\n    $i++;\n  }\n  return $i == $log_m;\n}\n", "  return $n == 1\
    \ || is_prime($n - 1);\n}\n", "  if ($n == 1)\n    return false;\n  for ($i =\
    \ 0; $i < $n - 1; $i++) {\n    if ($n % $i == 0)\n      return false;\n  }\n \
    \ return true;\n}\n", "  if ($n < 2) {\n    return false;\n  }\n\n  // See http://primes.utm.edu/lists/small/10003.shtml\n\
    \  for ($i = 3; $i < sqrt($n); ++$i) {\n    if ($n % $i === 0) {\n      return\
    \ false;\n    }\n  }\n  return true;\n}\n</code>\n<|/ a tags=python,php,algorithm,ruby,javascript\
    \ dscore=2 |>\n<| a dscore=2 |>\nMy Java solution, just for fun.\n<code>\nprivate\
    \ static boolean prime(final int n) {\n    return n > 1 && 2 <= ((int)Math.sqrt(n)\
    \ + 1) && n % 2 == 0;\n}\n</code>\nThe condition ((int)Math.sqrt(n) + 1) is necessary\
    \ because (Math.sqrt(n) overflows). Just add +1 to it.\n<|/ a tags=python,php,algorithm,ruby,javascript\
    \ |>\n<| c |>\nWhy does (int)Math.sqrt(n) overflow? Shouldn't it be ((int)Math.sqrt(n)\
    \ + 1) ?\n<|/ c |>\n<| c |>\nno. Math.sqrt(n) returns a value >= 0 so casting\
    \ to (int) returns 0 and adding 1 makes it 1.\n<|/ c |>\n<| c |>\nRight, my mistake,\
    \ I didn't get that Math.sqrt(n) was an int\n<|/ c |>\n<| a tags=python,php,algorithm,ruby,javascript\
    \ |>\nThis may seem crazy, but it is really really simple.\n<code>\ndef is_prime(n):\n\
    \    if n == 2:\n        return True\n    elif n % 2 == 0 or n == 1:\n       \
    \ return False\n    else:\n        for i in range(3, int(n**0.5 + 1.1), 2):\n\
    \            if n % i == 0:\n                return False\n        return True\n\
    </code>\n<|/ a dscore=1 |>\n<| a |>\n<code>", "  $result = false;\n  if ($n<2)\
    \ {\n    return false;\n  }\n\n  // Check factors up to sqrt(n).\n  $m = ceil($n/2);\n\
    \  for($i=2;$i<=$m;$i++) {\n    if ($n % $i == 0) {\n      $result = true;\n \
    \     break;\n    }\n  }\n\n  return $result;\n}\n", "    if ($n <= 1) return\
    \ false;\n    if ($n <= 3) return true;\n    if ($n % 2 == 0 || $n % 3 == 0) return\
    \ false;\n\n    $limit = $sqrt_limit = ceil(($n - 1) / 3);\n    for($i = 3; $i\
    \ <= $sqrt_limit; $i += 2) {\n        if ($n % $i == 0 || $n % ($i + 1) == 0)\
    \ return false;\n    }\n\n    return true;\n}\n</code>\nI noticed that your is_prime\
    \ code returns true for numbers which are not prime.  It also returns true for\
    \ numbers that are multiples of 2.  You also don't check numbers greater than\
    \ or equal to 3.\n<|/ a tags=php,primes dscore=0 |>\n<| a tags=php,primes |>\n\
    The following is a modification of the prime number algorithm that uses trial\
    \ division (i.e. divide the number by every number <= sqrt(n)) and checking if\
    \ the remainders are zero.  This algorithm is faster than the other algorithm\
    \ because a square root is quicker.\n<code>", "\tif ($n <= 1) return false;\n\t\
    if ($n == 1) return false;\n\tif ($n == 2) return true;\n\tif ($n % 2 == 0) return\
    \ false;\n\tfor ($i = 3; $i <= sqrt($n); $i += 2) {\n\t\tif ($n % $i == 0) return\
    \ false;\n\t}\n\treturn true;\n}\n", "\t$result = 0;\n\tfor($x = 2; $x < $n; $x++)\
    \ {\n\t\tif($n % $x == 0) {\n\t\t\t$result = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\
    return $result;\n}", "  if (!is_numeric($n) || $n < 1) {\n    throw new InvalidArgumentException(\"\
    is_prime() expects a number\");\n  }\n\n  if ($n == 1) return false;\n  // Remove\
    \ 1 and return false if that doesn't work\n  $n = $n - 1;\n  for ($i = 3; $i <=\
    \ sqrt($n); $i += 2) {\n    if ($n % $i == 0) return false;\n  }\n  return true;\n\
    }\n", "  $i = 4;\n  // Stop if we have any less than 2 primes or we've reached\
    \ the number 2\n  if ($n < 2 || $n % 2 == 0) {\n    return false;\n  }\n  // Even\
    \ numbers have no multiple other than itself and 1\n  if ($n % 2 == 1) {\n   \
    \ return false;\n  }\n  // And odd numbers can't have more than three multiples,\
    \ so the only numbers\n  // that qualify as odd numbers are themselves.\n  for\
    \ ($i = 3; $i <= sqrt($n); $i += 2) {\n    if ($n % $i == 0) {\n      return false;\n\
    \    }\n  }\n  return true;\n}\n", "    if (!isset($GLOBALS['primes'])) {\n  \
    \      $GLOBALS['primes'] = array();\n    }\n\n    if (array_search($n, $GLOBALS['primes'])\
    \ !== false) {\n        return true;\n    }\n\n    if ($n < 2) {\n        return\
    \ false;\n    }\n\n    // We will use the Sieve of Eratosthenes for this purpose\n\
    \    $p = $n;\n    do {\n        $GLOBALS['primes'][] = $p;\n        for ($i =\
    \ 0; $i < $p; ++$i) {\n            $p = (2 * $p) + $i;\n        }\n    } while\
    \ ($p <= $n);\n    unset($p);\n\n    $p = 0;\n    $r = 2;\n    while (true) {\n\
    \        if ($r == $n) {\n            return $GLOBALS['primes'][$p];\n       \
    \ }\n        foreach ($GLOBALS['primes'] as $prime) {\n            if ($prime\
    \ > $r) {\n                continue;\n            }\n            if ($n % $prime\
    \ == 0) {\n                return false;\n            }\n        }\n        $p++;\n\
    \        $r = $p + $r;\n    }\n}", "    if ($n == 1) return false;\n    if ($n\
    \ == 2) return true;\n    if ($n % 2 == 0) return false;\n    if ($n % 3 == 0)\
    \ return false;\n    if ($n % 5 == 0) return false;\n\n    $f = 5; \n    while\
    \ ($f <= sqrt($n)) {\n        if ($n % $f == 0) {\n            return false;\n\
    \        }\n        $f++;\n    }\n    return true;\n}\n</code>\n<|/ q tags=php\
    \ |>\n<| c |>\nThe problem is with `is_prime()`.  It returns false for some of\
    \ the numbers it shouldn't.\n<|/ c |>\n<| c |>\nDo you mean that \"for small integers\
    \ its return true\"?\n<|/ c |>\n<| c |>\nI mean that is_prime is returning true\
    \ when it shouldn't.  I don't see how your is_prime function can work properly\
    \ for small integers, as you always return true if the first parameter is 2.\n\
    <|/ c |>\n<| c |>\n: Yes. But that's not the point. I'm asking about the point\
    \ that OP has made with the question itself.\n<|/ c |>\n<| c |>\n`is_prime(5)\
    \ == True`\n<|/ c |>\n<| a tags=php |>\nYou have an issue with the if statement.\
    \ You need to use == and not =.\n<code>\nif (($n % $f) == 0)\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nYes, that's the point.  But that's not the only problem.  The OP\
    \ has made another mistake.\n<|/ c |>\n<| c |>\nWell spotted, but it's irrelevant\
    \ to the question.  The OP made another mistake, but that mistake was in another\
    \ part of the code.  Thus it was a different question than the one asked.\n<|/\
    \ c |>\n<| c |>\nI see. I thought it was a problem with the if statement because\
    \ he used `==` and not `=`.\n<|/ c |>\n<| a dscore=1 |>\nIn your is_prime function,\
    \ you have the following code:\n<code>\nif ($n == 1) return false;\nif ($n ==\
    \ 2) return true;\nif ($n % 2 == 0) return false;\nif ($n % 3 == 0) return false;\n\
    if ($n % 5 == 0) return false;\n</code>\nIn PHP, the first two checks will always\
    \ be true.  To fix this problem, replace the = with == in your is_prime function.\n\
    <|/ a tags=php |>\n<| c |>\nWow, that was a stupid mistake on my part. Thanks\
    \ for the help!\n<|/ c |>\n<|", "  if ($n < 2) {\n    return FALSE;\n  }\n  if\
    \ ($n < 7) {\n    return true;\n  }\n  if ($n % 2 === 0 || $n <= 3) {\n    return\
    \ false;\n  }\n  $f = 5; // First factor of $n\n  $i = 1;\n  while (true) {\n\
    \    if ($n % $i === 0) {\n      return false; // $n not a prime\n    }\n    $f\
    \ = $i * $i;\n    if ($f > $n) {\n      return false; // $n not a prime\n    }\n\
    \    $i++;\n  }\n  return true;\n}\n", "    $n = intval($n);\n    if ($n < 2)\
    \ {\n        return false;\n    }\n    \n    if ($n < 7) {\n        switch ($n)\
    \ {\n            case 2:\n            case 3:\n            case 5:\n         \
    \   case 7:\n            case 11:\n            case 13:\n            case 17:\n\
    \            case 19:\n            case 23:\n            case 29:\n          \
    \  case 37:\n            case 43:\n            case 59:\n            case 61:\n\
    \            case 67:\n            case 73:\n            case 79:\n          \
    \  case 83:\n            case 89:\n            case 97:\n            case 101:\n\
    \            case 103:\n            case 107:\n            case 109:\n       \
    \     case 113:\n            case 127:\n            case 131:\n            case\
    \ 137:\n            case 135:\n            case 137:\n            case 141:\n\
    \            case 143:\n            case 157:\n            case 153:\n       \
    \     case 159:\n            case 163:\n            case 169:\n            case\
    \ 173:\n            case 175:\n            case 179:\n            case 181:\n\
    \            case 191:\n            case 193:\n            case 193:\n       \
    \     case 193:\n            case 197:\n            case 203:\n            case\
    \ 203:\n            case 207:\n            case 211:\n            case 213:\n\
    \            case 217:\n            case 221:\n            case 223:\n       \
    \     case 227:\n            case 229:\n            case 233:\n            case\
    \ 239:\n            case 241:\n            case 251:\n            case 257:\n\
    \            case 269:\n            case 271:\n            case 273:\n       \
    \     case 277:\n            case 281:\n            case 283:\n            case\
    \ 293:\n            case 307:\n            case 301:\n            case 303:\n\
    \            case 305:\n            case 311:\n            case 313:\n       \
    \     case 313:\n            case 317:\n            case 311:\n            case\
    \ 311:\n            case 311:\n            case 311:\n            case 311:\n\
    \            case 311:\n            case 311:\n            case 311:\n       \
    \     case 311:\n            case 311:\n            case 311:\n            case\
    \ 311:\n            case 311:\n            case 311:\n            case 311:\n\
    \            case 311:\n            case 311:\n            case 311:\n       \
    \     case 311:\n            case 311:\n            case 311:\n            case\
    \ 311:\n            case 311:\n            case 311:\n            case 311:\n\
    \            case 311:\n            case 311:\n            case 311:\n       \
    \     case 311:\n            case 311:\n            case 311:\n            case\
    \ 311:\n            case 311:\n            case 311:\n            case 311:\n\
    \            case 311:\n            case 311:\n            case 311:\n       \
    \     case 311:\n            case 311:\n            case 311:\n            case\
    \ 311:\n            case 311:\n            case 311:\n            case 311:\n\
    \            case 311:\n            case 311:\n", "    $n = abs($n);\n    if ($n\
    \ < 2 || $n == 1)\n        return false;\n    if ($n == 2)\n        return true;\n\
    \    if ($n % 2 == 0)\n        return false;\n    for ($i=3; $i <= sqrt(($n +\
    \ 1)); $i+=2)\n        if ($n % $i == 0)\n            return false;\n    return\
    \ true;\n}", "  if ($n < 2 || $n % 1 == 0) {\n    return false;\n  }\n\n  for\
    \ ($x = 2; $x <= sqrt($n) + 1; $x++) {\n    if ($n % $x == 0) {\n      return\
    \ false;\n    }\n  }\n\n  return true;\n}\n</code>\nI hope this helps someone.\
    \ I just couldn't figure out how to get it to return true if the number is not\
    \ prime and false if it is. So I did this.\n<|/ a dscore=5 |>\n<| c |>\nIt would\
    \ be better if the code was in readable form and properly indented, to make it\
    \ easier to read. I will suggest that you use http://php.net's syntax highlighting,\
    \ for better readability.\n<|/ c |>\n<| c |>\nI like that your program is readable\
    \ and easy to follow. My only suggestion is that you should use some sort of `return`\
    \ statement to return the value, instead of using the `echo` command to print\
    \ the value. I would also suggest using a foreach statement to go through your\
    \ array of prime numbers (i.e. `foreach ($prime as $number)`). This will allow\
    \ you to shorten your code and make it easier to read. Thanks for your help :)\n\
    <|/ c |>\n<| c |>\nI agree with, code should be in a more readable format and\
    \ indented. That's how I got this to work.\n<|/ c |>\n<| c |>\n, thanks for the\
    \ heads-up, I will keep that in mind for the future.\n<|/ c |>\n<| c |>\nI love\
    \ this answer, but I don't understand the purpose of the square root call. Isn't\
    \ the square root of the $n value sufficient?\n<|/ c |>\n<| a dscore=4 tags=php,primes\
    \ |>\nI implemented a function that will return all the prime numbers in an array\
    \ using the Sieve of Eratosthenes, and I did it this way since I thought it would\
    \ be more \"readable\".\n<code>\n<?php", "    if ($n <= 1) return false;\n   \
    \ // Remove even numbers from the potential factors of $n.\n    $factor = array_filter(range(2,\
    \ $n), 'is_prime');\n    // If we've just hit 1 then it's prime.\n    if (count($factor)\
    \ === 1) return true;\n    // If we haven't had a factor for $n then it's composite.\n\
    \    if (!isset($factor[$n])) return false;\n    // If we still have factors then\
    \ it's not prime.\n    return count($factor) > 1;\n}\n", "  for ($n = 2; $n <=\
    \ $n; $n++) {\n    if ($n % $n == 0) {\n      return false;\n    }\n  }\n\n  return\
    \ true;\n}\n\necho \"Done generating primes up to $max_number :\\n\";\nprint_r($primes);",
  "  if ($n < 2) {\n    return false;\n  }\n\n  // Trial division test\n  if ($n %\
    \ 2 === 0) {\n    return false;\n  }\n\n  // Trial division test\n  $i = 3;\n\
    \  while (true) {\n    if ($i * $i > $n) {\n      break;\n    }\n    $i += 2;\n\
    \  }\n\n  // Do Primality test\n  return (($n % $i) === 0);\n}\n", "    if ($n\
    \ <= 1)\n        return false;\n    if ($n == 2)\n        return true;\n    if\
    \ ($n % 2 == 0)\n        return false;\n    if ($n % 3 == 0)\n        return false;\n\
    \    // Calculate all the numbers of form 2^i\n    // and multiply all of them\
    \ with $n\n    // to get a prime number\n    $m = floor($n ** 0.5);\n    for($i=5;$i<$m;$i+=2)\n\
    \        if ($n % $i == 0)\n            return false;\n    return true;\n}", " \
    \   $n = abs($n);\n    if ($n < 2) return false;\n    if ($n <= 3) return true;\n\
    \    if ($n % 2 == 0) return false;\n    if ($n % 3 == 0) return false;\n    if\
    \ ($n % 5 == 0) return false;\n    if ($n % 7 == 0) return false;\n    $x = sqrt($n);\n\
    \    if ($x == intval($x)) return true;\n    if ($x < (intval($x) / 2)) return\
    \ is_prime($x * 2) || is_prime($x * 3) || is_prime($x * 5);\n    return false;\n\
    }", "    if ($n < 2) {\n        return false; // not prime (any numbers less than\
    \ two are composite)\n    }\n\n    // check for special cases (all numbers except\
    \ 2 and 3)\n    if ($n == 2) {\n        return true;\n    }\n    if ($n == 3)\
    \ {\n        return false;\n    }\n\n    // initialize the 'sieve' with the numbers\
    \ 2..n-1\n    $sieve = array_fill(1, $n);\n\n    // if n is prime, nothing left\
    \ to check\n    if ($n == 1) {\n        return true;\n    }\n\n    // only odd\
    \ factors are going to be tested so start the sieve off with 3\n    for ($i =\
    \ 2; $i <= $n; $i += 2) {\n        // the number is not prime if the sieve entry\
    \ is zero\n        if ($sieve[$i] == 0) {\n            return false;\n       \
    \ }\n\n        // add all odd factors to the sieve (these are the 'composite'\
    \ numbers)\n        for ($j = 2; $j <= $i; $j += 2) {\n            $sieve[$j]\
    \ += $sieve[$i - 1];\n        }\n    }\n\n    // if we get here, the number is\
    \ prime\n    return true;\n}\n</code>\nHere is a short script that runs and tests\
    \ the algorithm:\n<code>\n<?php\n$primes = array();\nfor ($i = 1; $i <= 50; $i++)\
    \ {\n    $primes[] = is_prime($i);\n}\n", "  for ($i = 2; $i <= $n; $i++) {\n\
    \    if ($n % $i == 0) {\n      return false;\n    }\n  }\n  return true;\n}",
  "    $is_prime = false;\n    if ($n == 1) return false;\n    if ($n == 2) return\
    \ true;\n    if ($n % 2 == 0) return false;\n    $n3 = (int) (sqrt($n) + 0.5);\n\
    \    for($i = 3; $i <= $n3; $i += 2) {\n        if ($n % $i == 0) {\n        \
    \    $is_prime = true;\n            break;\n        }\n    }\n    return $is_prime;\n\
    }\n", "    if ($n < 2) {\n        return false;\n    }\n\n    for ($i = 2; $i\
    \ < $n; $i++) {\n        if ($n % $i == 0) {\n            return false;\n    \
    \    }\n    }\n\n    return true;\n}\n", "  if ($n <= 1)\n    return false;\n\
    \  for ($i = 2; $i <= $n/2; $i++)\n    if ($n % $i == 0)\n      return false;\n\
    \  return true;\n}\n", "    // http://en.wikipedia.org/wiki/Primality_test#Naive_methods\n\
    \    // 1. If n is less than or equal to 1, return false immediately.\n    if\
    \ ($n <= 1)\n        return false;\n\n    // 2. If n is odd, return false immediately.\n\
    \    if ($n & 1)\n        return false;\n\n    // 3. If n is even and m is odd\
    \ or greater than 1, return false immediately.\n    // >>> is_prime(13)\n    //\
    \ true\n    // >>> is_prime(129)\n    // false\n    if ($n & 1 && $n & ($n >>\
    \ 1))\n        return false;\n\n    // 4. If m is odd, return false immediately.\n\
    \    if ($m & 1)\n        return false;\n\n    // 5. If m is even and n is odd\
    \ or greater than 1, return false immediately.\n    // >>> is_prime(13)\n    //\
    \ true\n    // >>> is_prime(129)\n    // false\n    if ($m & 1 && $n & ($m >>\
    \ 1))\n        return false;\n\n    // 6. If m is even, then\n    if ($m & 1)\n\
    \    {\n        // 1. If n is odd, then\n        if ($n & 1)\n        {\n    \
    \        // 1. If m is odd, return true immediately.\n            // >>> is_prime(13)\n\
    \            // true\n            // >>> is_prime(129)\n            // false\n\
    \            if ($m & 1)\n                return true;\n        }\n\n        //\
    \ 2. If n is even and m is odd, return true immediately.\n        // >>> is_prime(13)\n\
    \        // true\n        // >>> is_prime(129)\n        // false\n        if ($n\
    \ & 1 & $m & 1)\n            return true;\n    }\n\n    // 7. If m is odd and\
    \ n is even and m is odd, return true immediately.\n    // >>> is_prime(13)\n\
    \    // true\n    // >>> is_prime(129)\n    // false\n    if ($m & 1 && $n & 1\
    \ & $m & 1)\n        return true;\n\n    // 8. If n is even and m is even, return\
    \ false immediately.\n    // >>> is_prime(13)\n    // false\n    // >>> is_prime(129)\n\
    \    // false\n    if ($n & 1 && $m & 1)\n        return false;\n\n    // 9. If\
    \ n is even, return false immediately.\n    if ($n & 1)\n        return false;\n\
    \n    // 10. Return true if the number is prime using the sieve of Eratosthenes.\n\
    \    // https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n    $n = $n >> 1;\n\
    \    foreach (range(2, $n) as $m)\n    {\n        if ($n & $m)\n        {\n  \
    \          return false;\n        }\n    }\n    return true;\n}", "    $n1 = $n\
    \ % 2 == 0 ?\n        sqrt($n) :\n        (sqrt(($n - 1) / 2) * $n2);\n\n    return\
    \ ($n1 == $n);\n}\n", "    if ($n < 2) {\n        return false;\n    }\n\n   \
    \ $known_primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    for ($i = 2; $i <= $n; ++$i) {\n \
    \       if (in_array($i, $known_primes)) {\n            continue;\n        }\n\
    \n        foreach ($known_primes as $prime) {\n            if ($prime > $n &&\
    \ $n % $prime === 0) {\n                return false;\n            }\n       \
    \ }\n    }\n\n    return true;\n}\n</code>\n<|/ a |>\n<| a dscore=3 |>\nI wrote\
    \ a PHP implementation to check whether a given number is prime using only arithmetics.\n\
    <code>\n<?php\n\n$number = 51;\n", "    if ($n == 1) { return false; }\n    if\
    \ ($n == 2 || $n == 3) { return true; }\n    if ($n % 2 == 0) { return false;\
    \ }\n    if ($n % 3 == 0) { return true; }\n\n    // TODO: If we know that the\
    \ number is composite (it contains no factors)\n    // and we are using an algorithm\
    \ which does not factor numbers, we could\n    // skip factoring in the loop (and\
    \ speed things up a bit).\n\n    for($i = 5; $i * $i <= $n; $i += 6) { }\n\n \
    \   return $n == $i;\n}", "  if ($n <= 1) return false;\n  if ($n <= 3) return\
    \ true;\n  if ($n % 2 == 0 || $n % 3 == 0) return false;\n  for ($i = 5; $i <=\
    \ sqrt($n); $i += 6) {\n    if (($n%$i == 0) && (($n / $i) % 2 == 0)) return true;\n\
    \  }\n  return false;\n}\n", "    if (!is_numeric($n)) {\n        return false;\n\
    \    }\n    if ($n < 2 || $n <= 3) {\n        return true;\n    }\n    if ($n\
    \ % 2 == 0 || $n % 3 == 0) {\n        return false;\n    }\n\n    // We only need\
    \ to check odd numbers for prime numbers\n    if ($n % 2 == 1) {\n        for\
    \ ($i = 3; $i * $i < $n; $i += 2) {\n            if ($n % $i == 0) {\n       \
    \         return false;\n            }\n        }\n        return true;\n    }\n\
    \n    // Even numbers cannot be primes anymore\n    return false;\n}", "    if\
    \ ($n < 2) {\n        return false;\n    }\n\n    // Test if n is prime.\n   \
    \ // It should do less work than is_prime(sqrt(n)).\n    $limit = (int)sqrt($n);\n\
    \    for($i = 2; $i <= $limit; $i++) {\n        if ($n % $i == 0) {\n        \
    \    return false;\n        }\n    }\n\n    // If we got this far, then n is prime.\
    \  Test if n is a square.\n    // If it is, then n MUST be a prime.\n    $limit\
    \ = (int)sqrt($n);\n    for($i = 2; $i <= $limit; $i++) {\n        if ($n % $i\
    \ == 0) {\n            return false;\n        }\n    }\n\n    // If we got this\
    \ far, then n is prime.  Test if n is a cube root.\n    // If it is, then n MUST\
    \ be a prime.\n    $limit = (int)ceil(sqrt($n));\n    for($i = 2; $i <= $limit;\
    \ $i++) {\n        if ($n % $i == 0) {\n            return false;\n        }\n\
    \    }\n\n    // If we got this far, then n is not prime.\n    return true;\n\
    }\n", "    $m = (int) sqrt($n);\n    for($i = 2; $i < $m; $i++) {\n        if($n\
    \ % $i == 0)\n            return false;\n    }\n    return true;\n}\n", "    if\
    \ ($n == 1) return false;\n    for ($x = 2; $x <= $n; $x++) {\n        if ($n\
    \ % $x == 0) return false;\n    }\n    return true;\n}\n", "    return $n % 2\n\
    \        ? self::is_prime($n - 1) ? true : false\n        : self::is_prime($n\
    \ - 2) ? true : false;\n}\n</code>\n<|/ a tags=php |>\n<| a tags=php |>\nI know\
    \ this question is old, but I came across this problem today, and I wanted to\
    \ share how I solved it.\nI wanted to create a function which returned a value\
    \ based on two inputs. Here's my solution\n<code>", "  $i = 2;\n  $p = 0;\n  while\
    \ (is_prime($i)) {\n    $i += 2;\n    if ($n % $i == 0) {\n      $p++;\n    }\n\
    \  }\n  return $p;\n}\n", "  if ($n<1) return false;\n  // If n is 1 then it's\
    \ definitely prime\n  if ($n==1) return true;\n  // If n is prime then there can\
    \ only be odd factors greater than or equal to n\n  if ($n%2==0) return false;\n\
    \  // Trial division technique - http://en.wikipedia.org/wiki/Primality_test\n\
    \  for ($i=3; $i*i<$n; $i++) {\n    // Not prime if i is even\n    if ($i%2==1)\
    \ return false;\n    // If there's a factor which divides i, then n is not prime\n\
    \    if ($n%$i==0) return false;\n  }\n  return true;\n}", "    if ($n <= 1) {\n\
    \        return false;\n    }\n    // Make n = 6 * 7\n    $n = ($n * 7) + 6;\n\
    \    // Set k\n    $k = 2;\n    // n is prime if there is no number greater than\
    \ n divisible by k\n    while ($n % $k == 0) {\n        $k++;\n    }\n    for\
    \ ($i = 2; $i < $n; $i++) {\n        if ($i % $k == 0) {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n</code>\n<|/ a tags=php,algorithm dscore=2\
    \ |>\n<| c |>\nThe first part of the code doesn't work. For example `is_prime(100)`\
    \ returns `true` whereas `is_prime(101)` returns `false`.\n<|/ c |>\n<| c |>\n\
    I posted this in 2014, when PHP was still PHP4 based. Now that we have PHP5 there\
    \ are a number of new tools which can be used to solve this problem. The question\
    \ as stated was about how to identify prime numbers. There are other methods such\
    \ as checking if it is divisible by 2, 3, 4, 5, 6, 7 or 8, and so on which could\
    \ be used to identify a prime number. Your answer contains no such methods. Please\
    \ consider updating your answer to include new methods, if any. :)\n<|/ c |>\n\
    <| a |>\n<code>", "    if ($n === 0 || $n === 1)\n        return false;\n\n  \
    \  if ($n % 2 == 0 || $n % 3 == 0 || $n % 5 == 0 || $n % 7 == 0)\n        return\
    \ true;\n\n    $limit = 8;\n    $square_root = $limit;\n    for($i = 3; $i * $i\
    \ <= $n; $i += 2)\n        if ($n % $i == 0 || $n % ($i + 2) == 0)\n         \
    \   return false;\n\n    $root = (int) sqrt($n);\n    return $n % $root == 0 ||\
    \ $n % ($root + 2) == 0;\n}\n", "    if ($n < 1) {\n        return false;\n  \
    \  }\n    if ($n == 2 || $n == 3) {\n        return true;\n    }\n    if ($n%2\
    \ == 0 || $n%3 == 0) {\n        return false;\n    }\n    $m = $n/2;\n    $ret\
    \ = true;\n    while ($m != 1) {\n        if ($m%2 == 0 || $m%3 == 0) {\n    \
    \        return false;\n        }\n        $m = $m/2;\n    }\n    return true;\n\
    }\n", "    if ($n <= 2) {\n        return false;\n    }\n    // Sieve of Eratosthenes\
    \ http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n    $a = array();\n    $a[0]\
    \ = 0;\n    $a[1] = 1;\n    for ($i = 2; $i < sqrt($n); $i++) {\n        $a[$i]\
    \ = $a[$i - 1] + $a[$i - 2];\n    }\n    for ($i = 2; $i < $n; $i++) {\n     \
    \   if ($a[$i] <= 1) {\n            return false;\n        }\n    }\n    return\
    \ true;\n}\n", "    if (!isset($n)) {\n        trigger_error('is_prime expects\
    \ a number', E_USER_WARNING);\n        return false;\n    }\n    $n = abs($n);\n\
    \    if ($n <= 1) {\n        return false;\n    }\n    $sqrtn2 = intval(sqrt($n));\n\
    \    for ($i = 1; $i <= $sqrtn2; $i++) {\n        if ($n % $i == 0) {\n      \
    \      return false;\n        }\n    }\n    return true;\n}\n", "    if ($n ==\
    \ 1 || $n == 2) {\n        return true;\n    }\n    $sqrt_n = sqrt($n);\n    $m\
    \ = intval($sqrt_n ** 0.5);\n    foreach (range(0, ($sqrt_n - 1) / 3) as $i) {\n\
    \        if ($n % $i == 0 || $n % ($i + 2) == 0) {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n", "    return ( ! $n%1 ) && is_prime($n/2);\n\
    }\n", "\tif ($n <= 1)\n\t\treturn false;\n\tif ($n == 2)\n\t\treturn true;\n\t\
    if ($n % 2 == 0)\n\t\treturn false;\n\t$root2 = sqrt($n);\n\t$i = 3;\n\twhile\
    \ ($i <= $root2) {\n\t\tif (($n % $i) == 0)\n\t\t\treturn false;\n\t\t$i += 2;\n\
    \t}\n\treturn true;\n}", "    $n = (int) $n;\n    if ($n < 2) {\n        return\
    \ false;\n    }\n\n    // Trial divisors up to sqrt(n).\n    for ($i = 3; $i <=\
    \ sqrt($n); $i += 2) {\n        if ($n % $i == 0) {\n            return false;\n\
    \        }\n    }\n\n    // Return true if the only possible divisor is a square\
    \ root.\n    return $n%2 == 0;\n}\n", "  if ($n === 0 || $n === 1) {\n    return\
    \ false;\n  }\n\n  if ($n % 2 === 0 || $n === 5) {\n    return false;\n  }\n\n\
    \  for ($i = 3; $i <= sqrt(($n - 1)); $i += 2) {\n    if ($n % $i === 0) {\n \
    \     return false;\n    }\n  }\n\n  return true;\n}\n</code>\n<|/ a |>\n<| c\
    \ |>\ni used this to check the if number is prime or not\n<|/ c |>\n<| a dscore=3\
    \ tags=php,primes |>\n<code>\n<?php\n\n$a = 1; // Prime Number starts with 1\n\
    \nwhile (!is_prime($a))\n{\n$a++;\n}\n\necho \"Prime numbers are : \";\nfor($i=$a;\
    \ $i<10; $i++){\necho $i, \"<br>\";\n}\n", "    if (!is_integer($n)) {\n     \
    \   return false;\n    }\n    if ($n < 2) {\n        return false;\n    }\n  \
    \  return !($n == 2);\n}\n", "    if ($n < 2) {\n        return false;\n    }\n\
    \    if ($n == 2 || $n == 3) {\n        return true;\n    }\n    if ($n % 2 ==\
    \ 0) {\n        return false;\n    }\n    $res = $f = 3;\n    for ($i = 5; $i\
    \ <= sqrt($n); $i += 6) {\n        if ($n % $i == 0) {\n            $f = $i;\n\
    \            return false;\n        }\n    }\n    return $f == 3;\n}", "    $factors\
    \   = array();\n    $factors   = self::factors($n);\n    $num      = $n;\n\n \
    \   foreach ($factors as $factor) {\n        $is_factor = ($num % $factor == 0)\
    \ ? true : false;\n        if ($is_factor) {\n            return false;\n    \
    \    }\n        $num = $num / $factor;\n    }\n    return true;\n}\n</code>\n\
    <|/ a tags=php,math dscore=1 |>\n<| a tags=php,math |>\nThis is what worked for\
    \ me. I wanted a quick and easy way to determine if a number had been a factor\
    \ of another number or not. I did not need the prime factors. \n<code>", "   \
    \ $sieve = array(\n        2,\n        3,\n        5,\n        7,\n        11,\n\
    \        13,\n        17,\n        19,\n        23,\n        29,\n        31,\n\
    \        37,\n        41,\n        43,\n        47,\n        53,\n        59,\n\
    \        61,\n        67,\n        71,\n        73,\n        79,\n        83,\n\
    \        89,\n        97\n    );\n    // Remove even numbers from the sieve, leaving\
    \ only the odd ones.\n    foreach ($sieve as $key => $val) {\n        if (($key\
    \ & $n) === 0) {\n            $sieve[$key] = false;\n        }\n    }\n    //\
    \ Test for primality.\n    for ($p = 2; $p < $n; ++$p) {\n        // Check for\
    \ an odd number that's not prime.\n        if (($n & $p) === 0) {\n          \
    \  return false;\n        }\n        // Check if p is prime\n        $n = $sieve[$p];\n\
    \    }\n    return true;\n}\n", "  if ($n < 2) {\n    return FALSE;\n  }\n\n \
    \ $i = 2;\n  while (is_prime($i)) {\n    $i += 2;\n  }\n  return $n > 1 && $n\
    \ % $i == 0;\n}\n", "  if ($n % 2 == 0) {\n    return true;\n  }\n  for ($i =\
    \ 3; $i * $i <= $n; $i+=2) {\n    if ($n % $i == 0) {\n      return false;\n \
    \   }\n  }\n  return true;\n}\n", "    // Prime check: skip even numbers.\n  \
    \  if ($n % 2 === 0) return false;\n\n    // Check all odd numbers for primeness\n\
    \    for ($i = 3; $i * $i <= $n; $i += 2)\n        if ($n % $i === 0) return false;\n\
    \n    // If we made it this far, then the number is prime.\n    return true;\n\
    }\n</code>\nAs you can see, this code makes use of some fairly basic Python programming\
    \ techniques (like list comprehensions). Python is great at things like this,\
    \ and it's a great language for writing complex functions. If you wanted, you\
    \ could write this in PHP, but I prefer Python.\nFor those of you who want to\
    \ do the same thing in PHP, here is the code:\n<code>\n<?php\n", "    $sqrtn =\
    \ ceil(sqrt($n));\n    for($i = 0; $i < $sqrtn; $i++) {\n        if($n % $i ==\
    \ 0)\n            return false;\n    }\n    return ($n <= 1);\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nI like this approach, but I need a return value for the function\
    \ and I am unsure how to implement that.  This is for a homework assignment. \
    \ I know I am supposed to return the boolean, but I do not know where to start.\
    \ I appreciate your help.\n<|/ c |>\n<| c |>\nI edited my original post to show\
    \ my function and how I would use it.\n<|/ c |>\n<| c |>\nThank you so much, this\
    \ is exactly what I was looking for. I also appreciate everyone else who contributed\
    \ and posted here as well.  Thanks again.\n<|/ c |>\n<| c |>\nThis is definitely\
    \ the best approach, since it uses modern mathematics. However, I think this can\
    \ be further improved with caching and the use of memoization techniques [this\
    \ article](http://en.wikipedia.org/wiki/Memoization) may help.\n<|/ c |>\n<| c\
    \ |>\nThis solution is not correct. Try it with 5 as an input value.\n<|/ c |>\n\
    <| a dscore=2 tags=primes,php |>\nI wrote a Python version for this problem, which\
    \ I converted into PHP and this seems to work fine:\n<code>", "    return ($n\
    \ <= 1);\n}", "  if ($n === 0)\n    return FALSE;\n\n  $n = intval($n);\n  if\
    \ ($n < 2)\n    return FALSE;\n\n  $root2 = (int) sqrt($n);\n  for ($i = 3; $i\
    \ <= $root2; $i++)\n    if ($n % $i == 0)\n      return FALSE;\n\n  return TRUE;\n\
    }\n", "\tif ($n == 0)\n\t\treturn false;\n\tif ($n == 1)\n\t\treturn true;\n\t\
    if ($n <= 2)\n\t\treturn false;\n\t// Check only the smallest factors of the number\n\
    \tfor ($i = 3; $i <= sqrt($n); $i += 2) {\n\t\tif ($n % $i == 0)\n\t\t\treturn\
    \ false;\n\t}\n\treturn true;\n}\n", "    $n = abs($n);\n    for($i = 2; $i <=\
    \ sqrt($n); $i++) {\n        if(!($n % $i)) {\n            return false;\n   \
    \     }\n    }\n    return true;\n}", "    $n = (int)$n;\n    if ($n <= 1)\n \
    \       return false;\n    $primes = array(7, 11, 13, 17, 19);\n    $end    =\
    \ $n - 1;\n    if ($n <= $end)\n        return true;\n    for ($i = 2; $i <= $end;\
    \ ++$i) {\n        if ($n % $i == 0)\n            return false;\n    }\n    return\
    \ $primes[$n - 2] == $n - 1;\n}\n", "    $sieve = new Sieve(array(2, 3));\n  \
    \  return $sieve->isPrime($n);\n}\n", "  // Primality test cases:\n  if ($n <=\
    \ 1)\n    return false;\n  if ($n <= 3)\n    return true;\n  // Don't even try.\n\
    \  if ($n % 2 == 0 || $n % 3 == 0)\n    return false;\n  // Do odd numbers only.\n\
    \  for ($i = 3; $i * $i <= $n; $i++)\n    if ($n % $i == 0 || $n % ($i + 2) ==\
    \ 0)\n      return false;\n  return true;\n}\n", "\tif ($n == 1 || !is_numeric($n))\
    \ {\n\t\treturn false;\n\t}\n\t// TODO: Improve the speed of this algorithm by\
    \ skipping some\n\t// non-primes.\n\tif ($n < 7) {\n\t\treturn true;\n\t}\n\t\
    if ($n % 2 == 0) {\n\t\treturn false;\n\t}\n\tif ($n % 3 == 0) {\n\t\treturn false;\n\
    \t}\n\tfor ($i = 5; $i <= sqrt($n); $i += 6) {\n\t\tif ($n % $i == 0) {\n\t\t\t\
    return false;\n\t\t}\n\t}\n\treturn true;\n}\n", "  if ($n < 2) {\n    return\
    \ false;\n  }\n  if ($n == 2) {\n    return true;\n  }\n  for ($i = 3; $i * $i\
    \ <= $n; $i++) {\n    if ($n % $i == 0) {\n      return false;\n    }\n  }\n \
    \ return true;\n}\n", "    if ($n === 0 || $n === 1) return false;\n    $result\
    \ = 0;\n    $root2 = floor(sqrt($n));\n    $n1 = $n - 2;\n    for($i = 1; $i <=\
    \ $root2; ++$i) {\n        $t = $i * $i;\n        $result = $result + ($t * ($n1\
    \ - 1));\n        $t1 = $i * $n1;\n        $result = $result + ($t * ($n1 * 2));\n\
    \        $t1 = $i * $n1 * $n1;\n        $result = $result + ($t * ($n1 * 3));\n\
    \        $t1 = $i * $n1 * $n1 * $n1;\n        $result = $result + ($t * ($n1 *\
    \ 4));\n        $t1 = $i * $n1 * $n1 * $n1 * $n1;\n        $result = $result +\
    \ ($t * ($n1 * 5));\n        $t1 = $i * $n1 * $n1 * $n1 * $n1 * $n1;\n       \
    \ $result = $result + ($t * ($n1 * 6));\n        $t1 = $i * $n1 * $n1 * $n1 *\
    \ $n1 * $n1 * $n1;\n        $result = $result + ($t * ($n1 * 7));\n        $t1\
    \ = $i * $n1 * $n1 * $n1 * $n1 * $n1 * $n1 * $n1;\n        $result = $result +\
    \ ($t * ($n1 * 8));\n        $t1 = $i * $n1 * $n1 * $n1 * $n1 * $n1 * $n1 * $n1\
    \ * $n1;\n        $result = $result + ($t * ($n1 * 9));\n    }\n    return $result\
    \ === 1;\n}", "  if ($n < 2 || $n <= 4) return true;\n  if ($n == 2) return false;\n\
    \  // see https://en.wikipedia.org/wiki/Primality_test#Primality_test_methods\n\
    \  // see http://primes.utm.edu/lists/small/10003.html\n  if ($n % 2==0 || $n\
    \ % 3==0) return false; // odd number\n  // see https://en.wikipedia.org/wiki/Primality_test#Using_linear_algebra_to_check_if_the_number_is_prime\n\
    \  // and http://primes.utm.edu/lists/small/10i.html\n  for ($i=3; $i*i <= $n;\
    \ $i+=2) if ($n % $i == 0 || $n%($i+2)==0) {return false;}\n  return true;\n}\n",
  "    // Return true for all primes less than or equal to *or* equal to\n    // or\
    \ equal to $n\n    for ($n = 1; $n <= $n; $n++) {\n        if ($n % 2 == 0) {\
    \ return false; }\n        if ($n <= 1) { return false; }\n        if ($n == $n\
    \ / 2) { return true; }\n        if ($n % 3 == 0) { return false; }\n        if\
    \ ($n % 5 == 0) { return false; }\n    }\n    return false;\n}\n", "  // Don't\
    \ even bother checking if the number is smaller than 2.\n  if ($n < 2) return\
    \ false;\n\n  // Trial divider which will fail for numbers that are not primes.\n\
    \  // This is not required but makes the code a bit clearer.\n  $divider = 2;\n\
    \n  // Primality testing will return the number as soon as it is known that\n\
    \  // the number is prime.\n  while (true) {\n    // This code can be optimized\
    \ by only testing the even numbers\n    // and checking if the remainder is zero,\
    \ but this should be fine\n    // for most applications.\n    if ($n % $divider\
    \ === 0) return $divider;\n\n    // Next prime number, might as well start dividing\
    \ from the next one\n    // unless we've reached the number we're checking.\n\
    \    $divider++;\n  }\n}\n", "  // This code is very similar to that in Sieve\
    \ of Eratosthenes from\n  // http://stackoverflow.com/a/2039774\n  // I modified\
    \ it slightly to make it faster because my version was\n  // slower for small\
    \ numbers, but it's still fast enough for me.\n  $n = abs($n);\n  if ($n < 2)\
    \ {\n    return false;\n  }\n  // if $n is even then it can only be a prime\n\
    \  if ($n & 1) {\n    return false;\n  }\n  // get first even number < $n\n  $i\
    \ = 1;\n  while ($i * $i < $n) {\n    $i += 2;\n  }\n  // if even and odd are\
    \ equal\n  if ($i === $n) {\n    return true;\n  }\n  // if $i is greater than\
    \ $n then it can only be a prime\n  if ($i > $n) {\n    return false;\n  }\n \
    \ // run up to sqrt($i)\n  $s = 1;\n  for ($j = 2; $j <= $i/2; $j++) {\n    if\
    \ (($j & $n) === 0) {\n      // if $j * $j > $i then it is not a prime\n     \
    \ return false;\n    }\n    // if $j * $j < $i then increment\n    $s ++;\n  }\n\
    \  // if we make it all the way up to sqrt($i) then it is a prime\n  return $s\
    \ === $i;\n}\n", "  $n_sqrt = sqrt($n);\n  for($i=2;$i<=$n_sqrt;$i++) {\n    if($n\
    \ % $i == 0) {\n      return false;\n    }\n  }\n  return true;\n}", "    // Only\
    \ prime numbers can be factorized, and they can only be integers.\n    if ($n\
    \ <= 1)\n        return false;\n\n    // If n is odd, return immediately.\n  \
    \  if ($n % 2 == 0)\n        return true;\n\n    // If n is even, check whether\
    \ any prime number is less than or equal to it.\n    if ($n % 2 == 1) {\n    \
    \    // If any number between 2 and n is even, return false.\n        for ($i\
    \ = 3; $i <= $n; $i += 2)\n            if ($n % $i == 0)\n                return\
    \ false;\n\n        return true;\n    }\n\n    // If n is odd...\n    // If any\
    \ number between 2 and n has an even divisor, return false.\n    if ($n % 2 ==\
    \ 1) {\n        // If any number between 3 and n/2 is even, return false.\n  \
    \      for ($i = 3; $i <= $n; $i += 2)\n            if ($n % $i == 0)\n      \
    \          return false;\n\n        return true;\n    }\n\n    // If n is odd...\n\
    \    // If any number between 3 and n has an odd divisor, return true.\n    if\
    \ ($n % 2 == 1) {\n        // If any number between n/2 and n/3 is odd, return\
    \ true.\n        for ($i = 3; $i <= $n; $i += 2)\n            if ($n % $i == 0)\n\
    \                return true;\n\n        return false;\n    }\n\n    // If n is\
    \ odd...\n    // If n is even, return false if any number between 2 and n/2 is\
    \ even, return true if any number between 3 and n/2 is odd, return true if and\
    \ only if all numbers between n/2 and n are odd.\n    if ($n % 2 == 1) {\n   \
    \     // If any number between 2 and n/2 is even, return true.\n        for ($i\
    \ = 3; $i <= $n; $i += 2)\n            if ($n % $i == 0)\n                return\
    \ true;\n\n        // If any number between 3 and n/2 is odd, return true.\n \
    \       for ($i = 3; $i <= $n; $i += 2)\n            if ($n % $i == 0)\n     \
    \           return false;\n\n        return true;\n    }\n\n    // If n is odd...\n\
    \    // If n is even, return true if any number between 2 and n/2 is even, return\
    \ true if any number between 3 and n/2 is odd, return true if and only if all\
    \ numbers between n/2 and n are odd.\n    if ($n % 2 == 1) {\n        // If any\
    \ number between 2 and n/2 is even, return true.\n        for ($i = 3; $i <= $n;\
    \ $i += 2)\n            if ($n % $i == 0)\n                return true;\n\n  \
    \      // If any number between 3 and n/2 is odd, return true.\n        for ($i\
    \ = 3; $i <= $n; $i += 2)\n            if ($n % $i == 0)\n                return ",
  "    if ($n < 2) {\n        return false;\n    }\n    // 2 is a special case\n \
    \   if ($n === 2) {\n        return true;\n    }\n    // 3 is divisible by any\
    \ odd number\n    else if ($n % 2 == 0 && $n % 3 == 0) {\n        return false;\n\
    \    }\n    // 4 is divisible by every odd number except itself\n    else if ($n\
    \ % 2 == 0 && ($n % 2 != 0 || $n % 3 != 0)) {\n        return false;\n    }\n\
    \    // 5 is divisible by all odd numbers except 2 and 4\n    else if ($n % 2\
    \ == 0 && ($n % 2 != 0 || $n % 3 != 0 || $n % 5 != 0)) {\n        return false;\n\
    \    }\n    // 6 is not divisible by all odd numbers\n    else if ($n % 2 != 0\
    \ && $n % 3 != 0 && $n % 5 != 0) {\n        return false;\n    }\n    // 7 is\
    \ not divisible by any odd number\n    else if ($n % 2 == 0) {\n        return\
    \ false;\n    }\n    // 8 is not divisible by any odd number\n    else if ($n\
    \ % 3 != 0) {\n        return false;\n    }\n    // 9 is not divisible by any\
    \ odd number\n    else if ($n % 5 != 0) {\n        return false;\n    }\n    //\
    \ 10 is not divisible by any odd number\n    else if ($n % 10 != 0) {\n      \
    \  return false;\n    }\n    // 11 is not divisible by any odd number\n    else\
    \ if ($n % 11 != 0) {\n        return false;\n    }\n    // 12 is not divisible\
    \ by any odd number\n    else if ($n % 12 != 0) {\n        return false;\n   \
    \ }\n    // 13 is not divisible by any odd number\n    else if ($n % 13 != 0)\
    \ {\n        return false;\n    }\n    // 14 is not divisible by any odd number\n\
    \    else if ($n % 14 != 0) {\n        return false;\n    }\n    // 15 is not\
    \ divisible by any odd number\n    else if ($n % 15 != 0) {\n        return false;\n\
    \    }\n    // 16 is not divisible by any odd number\n    else if ($n % 16 !=\
    \ 0) {\n        return false;\n    }\n    // 17 is not divisible by any odd number\n\
    \    else if ($n % 17 != 0) {\n        return false;\n    }\n    // 18 is not\
    \ divisible by any odd number\n    else if ($n % 18 != 0) {\n        return false;\n\
    \    }\n    // 19 is not divisible by any odd number\n    else if ($n % 19 !=\
    \ 0) {\n        return false;\n    }\n    // 20 is not divisible by any odd number\n\
    \    else if ($n % 20 != 0) {\n        return false;\n    }\n    // 21 is not\
    \ divisible by any odd number\n    else if ($n % 21 != 0) {\n        return false;\n\
    \    }\n    // 22 is not divisible by any odd number\n    else if ($n % 22 !=\
    \ 0) {\n        return false;\n    }\n    // 23 is not divisible by any odd number\n\
    \    else if ($n % 23 != 0) {\n        return false;\n    }\n    // 24 is not\
    \ divisible ", "  // make sure $n is a number or convert to a number\n  $n = intval($n);\n\
    \  if ($n < 2) {\n    return false;\n  }\n\n  // see if n is prime via trial division\
    \ method - if composite, then not\n  $found = true;\n  for ($i = 3; $i * $i <=\
    \ $n; $i++) {\n    if ($n % $i == 0) {\n      $found = false;\n      break;\n\
    \    }\n  }\n\n  return $found;\n}\n</code>\n<|/ a dscore=1 tags=performance,math,php\
    \ |>\n<| c |>\nI agree with your method of testing primes. But the question was\
    \ about \"performance of PHP built-in functions when they work on large numbers\"\
    . The question is about PHP built-in functions performance on large numbers. Your\
    \ answer is not about that.\n<|/ c |>\n<| c |>\nThis is not a solution to the\
    \ question. He is asking about PHP built-in functions, not about how to make them\
    \ more efficient.\n<|/ c |>\n<| a |>\nHere's an example for prime numbers with\
    \ PHP:\n<code>", "    if ($n == 1) {\n        return false;\n    }\n\n    if ($n\
    \ == 2) {\n        return true;\n    }\n\n    if ($n == 0 || $n == 1 || $n ==\
    \ 3) {\n        return false;\n    }\n\n    if ($n % 2 == 0) {\n        return\
    \ false;\n    }\n\n    $root = $this->sqrt($n);\n    $t = 2;\n\n    while ($root\
    \ >= 2) {\n        if ($n % $root == 0) {\n            return false;\n       \
    \ }\n        $root += $t;\n        $t += 2;\n    }\n    return true;\n}\n", " \
    \   if ($n == 1) return false;\n    // Sieve of Eratosthenes of extreme form (1/n!)^n\n\
    \    // https://oeis.org/A008106 shows that this is faster than the naive approach:\n\
    \    // https://oeis.org/A008106\n    $n2 = $n;\n    $c = $n2 - 1;\n    $sqrt_n\
    \ = $n / $c;\n    for($i=2; $i<$c; $i++) {\n        if(!($i % $c)) continue;\n\
    \        $i2 = $i * $i;\n        $n3 = $n2 / $i;\n        $i4 = $i2 * $i;\n  \
    \      $n4 = $n2 * $i;\n        if($i2 + $n4 - $sqrt_n - $i4 < $n) {\n       \
    \     return false;\n        }\n    }\n    return true;\n}", "  for ($i = 2; $i\
    \ <= sqrt($n); ++$i) {\n    if ($n % $i == 0) return false;\n  }\n  return $n\
    \ == 2 || $n == 3 || $n == 4 || $n == 5;\n}\n", "  // We only need to test up\
    \ to sqrt($n) to avoid floating-point\n  // precision issues.\n  for ($i = 1;\
    \ $i <= sqrt($n); $i++) {\n    if ($n % $i == 0) {\n      return false;\n    }\n\
    \  }\n  return true;\n}\n", "    if ($n % 2 == 0 && $n % 3 == 0)\n        return\
    \ false;\n\n    // See if there is a prime less than the number you are testing\
    \ for\n    for ($i = 3; $i * i <= $n; i += 2)\n        if ($n % $i == 0)\n   \
    \         return false;\n\n    return true;\n}\n", "    if ($n == 1)\n       \
    \ return false;\n    if ($n % 2 == 0 || $n <= 2)\n        return false;\n    $s\
    \ = 3; // Start with small primes.\n    while ($s < $n) {\n        if ($n % $s\
    \ == 0) {\n            // This is not a prime!\n            return false;\n  \
    \      }\n        $s += 2; // Next potential prime.\n    }\n    // If we got here,\
    \ all primes we found were small-prime (or none).\n    // If we didn't find the\
    \ smallest prime, it isn't prime.\n    return true;\n}\n", "    // Return false\
    \ if n is less than 1\n    if ($n < 1) {\n        return false;\n    }\n\n   \
    \ // If the upper triangle of n contains 0, return true.\n    // If an odd # is\
    \ found, return false.\n    // Else, loop through the remaining odd numbers.\n\
    \    // >>> is_prime(0)\n    // true\n    // >>> is_prime(1)\n    // false\n \
    \   // >>> is_prime(2)\n    // true\n    // >>> is_prime(3)\n    // false\n  \
    \  // >>> is_prime(4)\n    // true\n    // >>> is_prime(5)\n    // false\n   \
    \ // >>> is_prime(6)\n    // true\n    // >>> is_prime(7)\n    // false\n    //\
    \ >>> is_prime(8)\n    // true\n    // >>> is_prime(9)\n    // true\n    $upper_triangle\
    \ = pow(2, $n) - 1;\n\n    do {\n        if ($upper_triangle % 2 === 0) {\n  \
    \          return true;\n        }\n    } while ($upper_triangle > 1);\n\n   \
    \ return false;\n}\n", "    $n = $n - 1;\n    \n    if ($n % 2 == 0 || $n == 2\
    \ || $n == 3) {\n        $counter = 0;\n        for ($i = 3; $i <= $n; $i += 2)\
    \ {\n            if ($n % $i == 0) {\n                $counter++;\n          \
    \  }\n        }\n        if ($counter == 0) {\n            return true;\n    \
    \    }\n    }\n    \n    return false;\n}\n", "    if ($n < 2) {\n        return\
    \ false;\n    }\n\n    if ($n <= 3) {\n        return true;\n    }\n\n    // If\
    \ we get here, it means it's not prime because it's a factor of 2.\n    // It\
    \ can only be a factor of 2, or 3, 5, or 7...\n    if ($n % 2 === 0) {\n     \
    \   return false;\n    }\n\n    // If we get here, it means it's prime because\
    \ all it's factors are less then 5.\n    // It can only be a factor of 2, 3, 4,\
    \ 6... or 11, 13, 17, 19, 23, 29...\n    $factor = 3;\n    for ($i = 3; $i <=\
    \ sqrt($n); $i += 2) {\n        if ($n % $i === 0) {\n            return false;\n\
    \        }\n        $factor = $i;\n    }\n    return true;\n}\n</code>\n<|/ a\
    \ dscore=1 |>\n<| c |>\nHow does this solve the problem? It looks like a comment\
    \ on another answer.\n<|/ c |>\n<| a dscore=0 |>\n<code>\n<?php\n", "    if ($n\
    \ <= 1)\n        return false;\n    if ($n == 2)\n        return true;\n\n   \
    \ if ($n % 2 == 0)\n        return false;\n\n    // If we passed the if, it's\
    \ a prime number\n    return true;\n}", "  for ($i = 0; $i < $n; $i++) {\n   \
    \ $t = floor(($n + 1) / 2);\n    if ($n % $t == 0) {\n      return false;\n  \
    \  }\n  }\n  return true;\n}\n$a = [1,2,3];\n$b = [1,2];\n$c = $a | $b; // [1,2,3]\n\
    $d = $a + $b; // [1,2,3]\n$e = $a + 1; // [2,3,4]", "    if ($n === 0 || $n ===\
    \ 1)\n        return false;\n    $f = floor($n);\n    // If n was odd, then f+1\
    \ must be odd.\n    // If f is even, then f+1 and f-2 must be even.\n    // If\
    \ f is odd, then f+1 and f-2 must be odd.\n    return ((($n % 2) == 0) && !($f\
    \ % 2)) || ((($f % 2) == 0) && (($f + 1) & 1));\n}", "    if($n <= 1)\n      \
    \  return false;\n    if(false === is_prime($n-1))\n        return false;\n  \
    \  for($x=2; $x<=$n; $x++) {\n        if($n % $x == 0)\n            return false;\n\
    \    }\n    return true;\n}\n", "    return $n <= 2 || $n % 2 == 0 && $n != 11;\n\
    }\n", "    return is_integer($n) && is_integer(floor($n)) && $n % 1 == 0 && $n\
    \ != 1 && $n != ($n - 1);\n}\n</code>\n<|/ a tags=php,primes |>\n<| a tags=php,primes\
    \ dscore=0 |>\nThe Sieve of Eratosthenes is a good candidate for this problem.\n\
    <|/ a |>\n<| c |>\nSieve of Eratosthenes is O(n^2). How can you tell if an integer\
    \ is prime by checking the odds of all integers up to the given one?\n<|/ c |>\n\
    <| c |>\nYou are absolutely right. I'll update the answer. :)\n<|/ c |>\n<| c\
    \ |>\nThe Sieve of Eratosthenes is O(n^2) but only if you are looking for a prime\
    \ number which is less than or equal to n^2. In fact, the Sieve is also O(n^2)\
    \ even for large n. So, a Sieve of Eratosthenes can only find large primes up\
    \ to n^2.\n<|/ c |>\n<| c |>\n: Actually, a Sieve of Eratosthenes can find large\
    \ primes up to n^2 by looking at all numbers between 2 and sqrt(n).  This has\
    \ complexity O(sqrt(n)).\n<|/ c |>\n<| c |>\n- Yes, but by looking at the numbers\
    \ you are only doing up to sqrt(n).  A number greater than n by one must be greater\
    \ than sqrt(n).  The only thing you are doing is looking at numbers up to sqrt(n).\n\
    <|/ c |>\n<| a |>\n<code>\npublic boolean isPrime(int number){\n    boolean isPrime\
    \ = true;\n    for(int i=2; i<=sqrt(number); i++){\n        if(number%i == 0){\n\
    \            isPrime = false;\n            break;\n        }\n    }\n    return\
    \ isPrime;\n}\n</code>\n<|/ a dscore=0 tags=php,primes |>\n<| a |>\n<code>\n/**\n\
    \ * Checks if a number is prime or not\n *\n * int $number The number to check\n\
    \ * bool Whether it is a prime number or not\n */", "    if ($n <= 1)\n      \
    \  return false;\n    if ($n == 2 || $n == 3)\n        return true;\n\n    $root\
    \ = $this->sqrt($n);\n    for($i = 2; $i <= $root; $i++)\n        if($n % $i ==\
    \ 0)\n            return false;\n    return true;\n}\n", "\tif ($n < 2) {\n\t\t\
    return false;\n\t}\n\tif ($n == 2) {\n\t\treturn true;\n\t}\n\tif ($n % 2 == 0)\
    \ {\n\t\treturn false;\n\t}\n\tfor ($i = 3; $i <= sqrt($n); $i += 2) {\n\t\tif\
    \ ($n % $i == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n", " \
    \   if ($n < 2) {\n        return false;\n    }\n\n    list($div, $mod) = get_prime_factors($n);\n\
    \    return ($mod !== 1);\n}\n\n$n = 96;\n$r = 677;\n\necho is_prime($n) . \"\\\
    n\" . is_prime($r);", "    $n = (int) $n;\n    if ($n < 2) {\n        return false;\n\
    \    }\n    if ($n == 2 || $n == 3) {\n        return true;\n    }\n    $root\
    \ = (int) sqrt(($n * $n) + 1);\n    $a = 1;\n    $b = $n - 1;\n    $c = 1;\n \
    \   while (true) {\n        if ($a * $a + $b * $b <= ($n * ($n - 1) / 2)) {\n\
    \            return false;\n        }\n        $m = (($b * ($b - $a) + $c) % $n);\n\
    \        if ($m == 0) {\n            return true;\n        }\n        $a = $b;\n\
    \        $b = $m;\n        $c = (int) sqrt(($m * ($m - 1)) / 2);\n    }\n}\n</code>\n\
    <|/ a tags=primes,algorithm,php |>\n<| c |>\nThis implementation is incorrect\
    \ and will hang at `is_prime(54321)` (the number `2^54321` is prime).\n<|/ c |>\n\
    <| c |>\nThe code has some typos, e.g. 'r' should be 'n' in `sqrt($n * $n) + 1`\n\
    <|/ c |>\n<| c |>\nI edited this answer to fix the typo and remove the non-primes\
    \ check, which was originally left in.\n<|/ c |>\n<| a tags=primes,algorithm,php\
    \ dscore=5 |>\nAs with most of the other answers, you can implement this fairly\
    \ simply in PHP.\n<code>", "    $result = 0;\n    // Since we only care if the\
    \ number is prime, we only need to check odds.\n    for ($i = 3; $i <= sqrt($n);\
    \ $i += 2) {\n        if ($n % $i == 0) {\n            $result = 1;\n        \
    \    break;\n        }\n    }\n    return $result;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThis is very nice, but it is very inefficient since you're doing\
    \ a square root each iteration. Also note that `sqrt()` is a floating point function,\
    \ and thus `sqrt($n)` may be slightly larger than `$n` due to rounding.\n<|/ c\
    \ |>\n<| c |>\nYou are right that sqrt() may be a little bigger than $n due to\
    \ rounding, but in the case of primes, it will not be a big deal.\n<|/ c |>\n\
    <| c |>\n: Well, that depends on what you define as \"big\".\n<|/ c |>\n<| c |>\n\
    Agreed. That's why I suggested this approach. :-)\n<|/ c |>\n<| c |>\n: I disagree\
    \ with you there. Not only is it not really a big deal, it's quite insignificant\
    \ compared to what it takes to calculate the prime factors of the number. There\
    \ are ways to optimize this algorithm to make it faster, but they would just be\
    \ reworking the original code. I'm a little surprised you're still not seeing\
    \ any significant speed up. My guess is that you're doing this in a loop and you're\
    \ seeing slowdowns because of function calls.\n<|/ c |>\n<| a tags=php |>\nA solution\
    \ that does a better job of determining if a number is a prime is as follows:\n\
    <code>", "    // Implementation from http://rosettacode.org/wiki/Primality_test#PHP\n\
    \    $test = 2;\n    if ($n <= 2) {\n        // Base case: 0 and 1 are not primes.\n\
    \        return false;\n    }\n    if ($n == 3) {\n        // Trial division by\
    \ 3: 1 is not prime.\n        return false;\n    }\n    for ($i = 3; $i <= sqrt($n);\
    \ $i += 2) {\n        if ($n % $i == 0) {\n            // Found one.\n       \
    \     return false;\n        }\n    }\n    // If we get here, no divisors were\
    \ found. Means n is composite.\n    return true;\n}\n", "    $limit = (int) sqrt($n)\
    \ + 1;\n    if ($n < 2) return false;\n    // Test all even numbers up to `sqrt`,\
    \ incrementing `n` by 2.\n    // If a factor of `n` is found after incrementing\
    \ `n` by 2, return false:\n    $limit = $limit * 2 + 1;\n    // The first even\
    \ number to test upon is 2.\n    for ($i = 2; $i <= $limit; ++$i) {\n        if\
    \ ($n % $i == 0)\n            return false;\n    }\n    // If no factor was found,\
    \ the number is prime.\n    return true;\n}\n", "    if ($n < 1) {\n        return\
    \ false;\n    }\n\n    // Don't even have to test any primes less than or equal\
    \ to n.\n    if ($n <= 2) {\n        return true;\n    }\n\n    // Try dividing\
    \ by 2 to eliminate even numbers, which should then be\n    // primes.\n    $test\
    \ = ceil(sqrt($n));\n    for($i = 1; $i <= $test; $i++) {\n        if ($n % $i\
    \ == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n",
  "    for ($i = 2; $i <= sqrt($n); $i++) {\n        if ($n % $i == 0) {\n       \
    \     return false;\n        }\n    }\n    return true;\n}\n", "    // Return\
    \ true if the number is prime and false otherwise.\n    // >>> is_prime(6)\n \
    \   // false\n    // >>> is_prime(101)\n    // true\n    // >>> is_prime(11)\n\
    \    // true\n    // >>> is_prime(13441)\n    // true\n    // >>> is_prime(61)\n\
    \    // true\n    // >>> is_prime(4)\n    // false\n    // >>> is_prime(1)\n \
    \   // false\n    if ($n == 1) {\n        return false;\n    }\n    $is_composite\
    \ = false;\n    // Do fibonacci numbers: every number is divisible by (number\
    \ - 1).\n    // If n is divisible by a number greater than two, the last number\
    \ will\n    // not be prime, but we will still have to test all previous numbers.\n\
    \    // >>> is_prime(13441)\n    // true\n    // >>> is_prime(13)\n    // false\n\
    \    // >>> is_prime(14)\n    // false\n    // >>> is_prime(15)\n    // false\n\
    \    // >>> is_prime(17)\n    // true\n    // >>> is_prime(19)\n    // true\n\
    \    // >>> is_prime(20)\n    // true\n    // >>> is_prime(21)\n    // false\n\
    \    $a = 1;\n    $b = 1;\n    $c = 0;\n    for ($i = 0; $i <= $n; $i++) {\n \
    \       // Do the compositing in four steps.  This guarantees that there is at\n\
    \        // least one number which is not divisible by any number between $a\n\
    \        // and $b (including $b), and that number is prime.\n        if (($n\
    \ % $i) == 0) {\n            $is_composite = true;\n        }\n        $d = $a\
    \ + $b;\n        $a = $b;\n        $b = $c;\n        $c = ($d - ($d / $i) * $i)\
    \ % $i;\n    }\n    return $is_composite;\n}\n", "    // If n is less than or\
    \ equal to 0, then this number is definitely\n    // not prime.  \n    if ($n\
    \ < 1) {\n        return false;\n    }\n    // If n equals 1, then we know that\
    \ the number is prime since we\n    // got this far.  \n    if ($n == 1) {\n \
    \       return true;\n    }\n    // We can skip any even numbers since they are\
    \ either 1 or -1. \n    if ($n % 2 == 0) {\n        return false;\n    }\n   \
    \ // We know that n >= 2, so if n is even it must be odd.  \n    if ($n % 2 ==\
    \ 1) {\n        return true;\n    }\n    // If n > 2, then we can skip all odd\
    \ numbers, because no even number is a factor.\n    for($i = 2; $i < $n; $i++)\
    \ {\n        if ($n % $i == 0) {\n            return false;\n        }\n    }\n\
    \    return true;\n}\n", "  if ($n % 2 == 0) {\n    return false;\n  }\n\n  $m\
    \ = $n - 1;\n  for ($i = 3; $i <= sqrt($n); $i += 2) {\n    if ($n % $i == 0)\
    \ {\n      return false;\n    }\n  }\n\n  return true;\n}\n", "  $isPrime = false;\n\
    \  $isPrime = ($n % 2 === 0);\n  if ($isPrime) {\n    $isPrime = true;\n  }\n\
    \  for ($i = 2; $i <= sqrt($n); $i++) {\n    if ((($n % $i) === 0) || ($n !==\
    \ $i)) {\n      $isPrime = false;\n      break;\n    }\n  }\n  return $isPrime;\n\
    }", "    $n = abs($n);\n\n    if ($n < 2) {\n        return false;\n    }\n\n\
    \    $root  = sqrt($n);\n    $root2 = floor($root / 2);\n    $root6 = floor($root2\
    \ / 6);\n    $root8 = floor($root6 / 8);\n\n    do {\n        if ($n % $root ===\
    \ 0) {\n            return false;\n        }\n\n        if ($n !== 1) {\n    \
    \        $root  = sqrt($n);\n            $root2 = floor($root / 2);\n        \
    \    $root6 = floor($root2 / 6);\n            $root8 = floor($root6 / 8);\n  \
    \      }\n\n        $n--;\n    } while ($root8 > 1);\n\n    return true;\n}\n\
    </code>\n<|/ a dscore=5 |>\n<| c |>\nWhat are all the possible conditions, especially\
    \ when they depend on `$n`?\n<|/ c |>\n<| c |>\nI think the conditions can be\
    \ any number larger than a prime. Because every number that is prime is greater\
    \ than 1.\n<|/ c |>\n<| c |>\nI guess I asked the wrong question.  I was asking\
    \ how this function works and if there were any additional conditions to add to\
    \ the conditions.  Thanks!\n<|/ c |>\n<| c |>\nThe conditions are the number is\
    \ not 1, the number is even, and the number is odd. And for the number, the least\
    \ factor is either 2 or 4, so if `$n` is even then $root2 will always be odd no\
    \ matter what the number is.\n<|/ c |>\n<| c |>\nIf you set `$n = 5` (which is\
    \ even) then `$root2` will also be odd and so `$root6` will be set to zero, making\
    \ `$root8` unchanged.\n<|/ c |>\n<| a tags=php,primes dscore=4 |>\nI use this\
    \ function to check if a number is prime or not.\n<code>", "  if ($n<=1) {\n \
    \   return false;\n  }\n\n  for ($i=2; $i*$i <= $n; $i++) {\n    if ($n%$i ==\
    \ 0) {\n      return false;\n    }\n  }\n\n  return true;\n}\n", "  return !is_prime_fast($n);\n\
    }\n", "    if ($n <= 1 || !is_int($n) || $n <= 2) {\n        return false;\n \
    \   }\n    $n--;\n    if ($n % 2 == 0) {\n        return false;\n    }\n    foreach\
    \ (range(1, $n) as $k) {\n        if ($n % $k == 0) {\n            return false;\n\
    \        }\n    }\n    return true;\n}", "  $n = abs($n);\n\n  if ($n < 2) {\n\
    \    return false;\n  }\n\n  // Test if n is a composite number (i.e. has a prime\
    \ factor).\n  for ($i = 3; $i * $i <= $n; $i++) {\n    if ($n % $i == 0) {\n \
    \     return false;\n    }\n  }\n\n  // Test if n has exactly the same number\
    \ of factors as its square\n  // root (i.e. is a prime power).\n  $m = sqrt($n);\n\
    \  for ($i = 3; $i * $i <= $m; $i++) {\n    if ($n % $i == 0) {\n      return\
    \ false;\n    }\n  }\n\n  return true;\n}\n\n$t = time();\necho \"\\nTest 1: is_prime\\\
    n\";\n$n = rand(1, 1000000);\necho \"$n\\n\";\nprint \"  Prime? \", is_prime($n)\
    \ ? \"true\" : \"false\", \"\\n\";\n$t = time() - $t;\nprint \"  Prime time :\
    \ $t seconds\\n\";\n\n$t = time();\necho \"\\nTest 2: is_prime\\n\";\nfor ($n\
    \ = 1; $n < 100000000; $n++) {\n  $n = rand(1, 1000000);\n  echo \"$n\\n\";\n\
    \  print \"  Prime? \", is_prime($n) ? \"true\" : \"false\", \"\\n\";\n  $t =\
    \ time() - $t;\n  print \"  Prime time : $t seconds\\n\";\n}\n$t = time() - $t;\n\
    print \"  Prime time : $t seconds\\n\";", "    if($n < 2) return false;\n    if($n\
    \ & 1) return false;\n    $x = ($n + 1) / 2;\n    for($i = 3; $i * $i <= $n; $i\
    \ += 2) {\n        if($n % $i == 0) return false;\n    }\n    return $x == 2;\
    \ // is $x even?\n}", "    do {\n        if ($n % 2 === 0 ) {\n            return\
    \ false;\n        }\n        $next = $n+2;\n        if ($next > 3) {\n       \
    \     $next = 61;\n        }\n        $factors_up_to_three = range(1, $next);\n\
    \        $factors = array_diff($factors_up_to_three, array($n));\n        if (count($factors)\
    \ == 3) {\n            return true;\n        }\n        if ($n == 2) {\n     \
    \       return false;\n        }\n        $n += 1;\n    } while($n < 31);\n  \
    \  return false;\n}\n", "\tif ($n < 2 || $n > 1000000000 || $n % 1 != 0 || $n\
    \ % 2 == 0) {\n\t\treturn false;\n\t}\n\n\t// Trial division by primes below 10\
    \ million.\n\t$limit = (int)sqrt($n);\n\t$r = $limit;\n\twhile ($n % $r == 0)\
    \ {\n\t\t$r /= 2;\n\t}\n\n\treturn $limit == $r;\n}\n", "\tif ($n < 2) {\n\t\t\
    return false;\n\t}\n\tif ($n == 2) {\n\t\treturn true;\n\t}\n\tif ($n % 2 == 0)\
    \ {\n\t\treturn false;\n\t}\n\tfor ($i = 3; $i <= sqrt($n); $i += 2) {\n\t\tif\
    \ ($n % $i == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "   \
    \ if ($n < 2) {\n        return false;\n    }\n\n    // check for small factors\
    \ up to sqrt(n)\n    for ($i = 3; $i <= sqrt($n); $i+=2) {\n        if ($n % $i\
    \ == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}",
  "    if ($n <= 1)\n        return true;\n    if (!isset($sqrt[$n]))\n        return\
    \ false;\n    $sqrtn = $sqrt[$n];\n    for ($i = 2; $i <= $sqrtn; $i++)\n    \
    \    if ($n % $i == 0)\n            return false;\n    return true;\n}", "   \
    \ $is_prime = true;\n    for($i = 2; $i < $n; $i++)\n        if(!($n % $i))\n\
    \            $is_prime = false;\n    return $is_prime;\n}\n", "    $n = abs($n);\n\
    \    $m = floor($n/2);\n    for($i=2;$i<$m;$i++){\n        if($n % $i == 0){\n\
    \            return false;\n        }\n    }\n    return true;\n}\n", "    if\
    \ ($n == 2 || $n == 3) {\n        return true;\n    }\n\n    // Check all the\
    \ numbers of form 6n+1 or 6n+1-2\n    if ($n % 6 == 1) {\n        for ($i = 3;\
    \ $i * $i <= $n; $i += 6) {\n            if ($n % $i == 0 || $n % ($i + 2) ==\
    \ 0) {\n                return false;\n            }\n        }\n    }\n\n   \
    \ // Check all the numbers of form 6n+2 or 6n+3\n    if ($n % 6 == 2) {\n    \
    \    for ($i = 2; $i * $i <= $n; $i += 6) {\n            if ($n % $i == 0 || $n\
    \ % ($i + 3) == 0) {\n                return false;\n            }\n        }\n\
    \    }\n\n    // If $n is a perfect square, then its primeness lies on the number\
    \ line between 3 and $n.\n    // If $n is not a perfect square, then ($n-1)/2\
    \ is a prime and only lies on the number line between\n    // 2 and ($n-1)/4.\n\
    \    // Therefore, to test whether $n is a prime we have to check both cases.\n\
    \    if ($n % 6 == 0) {\n        $sqrt_n = $n / 6;\n        $is_prime = ((bool)\
    \ ($sqrt_n == round($sqrt_n)));\n    }\n    else {\n        $is_prime = ($n >=\
    \ 3 && $n <= (int) ($n / 2));\n    }\n\n    return $is_prime;\n}\n", "    // Return\
    \ false if n is less than 2.\n    if ($n < 2) {\n        return false;\n    }\n\
    \n    // Return true only if n is odd and greater than 1.\n    return !($n % 2);\n\
    }\n", "  global $SCRATCHPAD, $SCRATCHPAD_SQRT;\n  $i = $SCRATCHPAD * $SCRATCHPAD;\n\
    \  while ($n % $i) {\n    $i += $SCRATCHPAD;\n  }\n  if ($SCRATCHPAD_SQRT == 1)\
    \ {\n    if ($SCRATCHPAD <= 1) {\n      $SCRATCHPAD_SQRT = 2;\n    } else {\n\
    \      $SCRATCHPAD_SQRT <<= 1;\n    }\n  }\n  $i = (int) sqrt($i);\n  while ($i\
    \ >= 1) {\n    if ($n % $i == 0) {\n      return 0;\n    }\n    $i -= 2;\n  }\n\
    \  return 1;\n}\n", "    if ($n <= 1) {\n        return false;\n    }\n    $n\
    \ = abs($n);\n    // Test odd numbers for primeness\n    if ($n % 2 == 0) {\n\
    \        $x = 1;\n        for ($i = 3; $i * $i <= $n; $i += 2) {\n           \
    \ if ($n % $i == 0) {\n                return false;\n            }\n        }\n\
    \        return true;\n    }\n    // Test even numbers for primeness\n    $x =\
    \ 2;\n    for ($i = 3; $i * $i <= $n; $i += 2) {\n        if ($n % $i == 0) {\n\
    \            return false;\n        }\n    }\n    return true;\n}", "    if ($n\
    \ === 1) { return false; }\n    if ($n <= 1 || !is_prime($n-1)) { return false;\
    \ }\n    if ($n % 2 == 0) { return false; }\n    return is_prime($n/2);\n}\n",
  "  if ($n < 2) {\n    return false;\n  }\n  if ($n == 2) {\n    return true;\n \
    \ }\n\n  for ($m = 2; $m <= $n; $m++) {\n    if ($n % $m == 0) {\n      return\
    \ false;\n    }\n  }\n\n  return true;\n}\n", "    $primes = array(6, 11, 13,\
    \ 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61);\n    return in_array($n, $primes);\n\
    }\n", "    if ($n === 1) {\n        return false;\n    }\n    if ($n % 2 === 0)\
    \ {\n        return false;\n    }\n\n    for($i = 3; $i * $i <= $n; $i++) {\n\
    \        if ($n % $i === 0) {\n            return false;\n        }\n    }\n\n\
    \    return true;\n}\n\n/**\n * Return the greatest common divisor (GCD) of the\
    \ two numbers.\n * See http://www.merriam-webster.com/dictionary/gcd.\n * See\
    \ http://en.wikipedia.org/wiki/Euclidean_algorithm.\n * See http://www.wolframalpha.com/input/?i=x%3D2y+1\n\
    \ * See http://code.activestate.com/recipes/259207/\n */", "  global $base, $sqrt;\n\
    \  if($n == 1) return false;\n  if($n == 2) return true;\n  if($n % 2 == 0) return\
    \ false;\n  if($n % 3 == 0) return false;\n  for($i = 3; $i * $i <= $n; $i+=2)\
    \ {\n    if($n % $i == 0) return false;\n  }\n  return true;\n}", "  if ($n <\
    \ 2 || $n == 0 || $n%2 == 0) { return false; }\n  $limit = (int) sqrt($n);\n \
    \ for($i = 2; $i <= $limit; ++$i) {\n    if($n%$i == 0) { return false; }\n  }\n\
    \  return true;\n}\n", "    if ($n == 2 || $n == 3) return true;\n    if ($n ==\
    \ 0) return false;\n    if ($n%2 == 0 || $n%3 == 0) return false;\n    $m = ($n-1)/2;\n\
    \    for($i=5; $i <= $m; $i += 6) {\n        if ($n % $i == 0 || $n%$i==0) {\n\
    \            return false;\n        }\n    }\n    return ($n>1);\n}\n", "    if\
    \ ($n <= 1)\n        return false;\n    if ($n == 2)\n        return true;\n \
    \   $squareroot = (int) sqrt($n);\n    for($i = 1; $i <= $squareroot; $i++) {\n\
    \        if(!($n % $i))\n            return false;\n    }\n    return true;\n\
    }\n", "  $test = 2;\n  do {\n    $is_prime = ($n % $test) === 0;\n    if ($is_prime)\
    \ break;\n    $test++;\n  } while ($test <= sqrt($n));\n  return $is_prime;\n\
    }\n", "    $k = 2; //sqrt($n)\n    $d = $k; //$k is used twice\n    while($k*$k\
    \ <= $n){\n        $d = $d*$k; //$d is multiplied by $k\n        $k++;\n    }\n\
    \    return $d == 1;\n}", "    if ($n < 2) {\n        return false;\n    }\n \
    \   if ($n == 2 || $n == 3) {\n        return true;\n    }\n    if ($n % 2 ==\
    \ 0 || $n % 3 == 0) {\n        return false;\n    }\n    $i = $n-1;\n    while($i\
    \ >= 2) {\n        if ($i % 2 == 0 || $i % 3 == 0) {\n            return false;\n\
    \        }\n        $i--;\n    }\n    return true;\n}", "    $sieve_array = $this->_sieve_of_eratosthenes(($n-1)\
    \ / 2);\n    foreach ($sieve_array as $val) {\n        if ($n % $val == 0) {\n\
    \            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * Returns\
    \ $a^$b, where $a is a positive integer or zero, and $b is a positive\n * integer.\n\
    \ *\n * @param int $a First number.\n * @param int $b Second number.\n *\n * @return\
    \ int $a^$b.\n */", "    $n = abs($n);\n    if($n < 3) {\n        return $n ==\
    \ 2; \n    }\n\n    if($n % 2 == 0) {\n        return false;\n    }\n\n    for($div\
    \ = $n; $div > 2; $div = $div / 2) {\n        if($div % 2 == 0) {\n          \
    \  return false;\n        }\n    }\n    return true;\n}\n", "    // Return false\
    \ if n is less than 1.\n    if ($n < 1) {\n        return false;\n    }\n\n  \
    \  // Return true if n is greater than or equal to 2.\n    if ($n > 2) {\n   \
    \     return true;\n    }\n\n    // Otherwise, loop until you've found a number\
    \ that is factorized as a\n    // prime number.\n    for($i=3; $i<$n; $i++) {\n\
    \        if ($n % $i == 0) {\n            return false;\n        }\n    }\n\n\
    \    return true;\n}\n", "    $n = abs($n);\n    $nlogn = log($n);\n    $nlogn2\
    \ = $nlogn + 1;\n    $n = sqrt($n);\n    $x = $n;\n    $prime = true;\n    while($x\
    \ !== 1) {\n        if($n % ($x * $x) === 0) {\n            $prime = false;\n\
    \            break;\n        }\n        $x = $x / 2;\n    }\n    return $prime;\n\
    }", "    $n = abs($n);\n    $end = (int) ($sqrtOfN = $n->ldiv($n + 1)->lmod($n));\n\
    \n    foreach (self::$primes as $k => $v) {\n        $nMod = (int) ($k % $end);\n\
    \        if ($nMod === 0 || $n->lmod($nMod)->equals($k)) {\n            if ($nMod\
    \ > $end) {\n                unset($primes[$k]);\n                $end = (int)\
    \ ($n->ldiv($nMod + 1)->lmod($nMod));\n            }\n        }\n    }\n\n   \
    \ return count($primes) > 1 && $n % count($primes) === 0;\n}\n", "    // Check\
    \ range and semi-prime\n    if ($n < 1 || $n % 1 != 0 || $n % 2 == 0) {\n    \
    \    return false;\n    }\n    // Check for perfect power\n    $a = 3;\n    $b\
    \ = 5;\n    $m = $n - 1;\n    // Trial divisors\n    for($i = 2; $i <= $m; $i++)\
    \ {\n        if ($n % $i == 0) {\n            return false;\n        }\n     \
    \   if ($n % $a != 0 && $n % $b != 0) {\n            return false;\n        }\n\
    \        $a = $a * $a + 1;\n        $b = $b * $b;\n    }\n    return true;\n}",
  "  return !($n % 2 === 1 && $n % 4 === 0 && ($n % 6 === 0 || $n % 10 === 0));\n}",
  "  $max = (int) ($sqrt);\n  if ($n < $max) {\n    for ($i = 2; $i <= $n; ++$i) {\n\
    \      if ($n % $i == 0) {\n        return false;\n      }\n    }\n  }\n  return\
    \ true;\n}", "  if ($n == 1) {\n    return false;\n  }\n  // We only need to test\
    \ up to the square root of $n, since the only\n  // even number that divides evenly\
    \ is 2.\n  for ($x = 2; $x < sqrt($n); $x++) {\n    if ($n % $x == 0) {\n    \
    \  return false;\n    }\n  }\n  return true;\n}\n", "  if ($n === 1) return false;\n\
    \n  for ($i = 2; $i <= sqrt($n); $i++) {\n    if ($n % $i == 0) return false;\n\
    \  }\n\n  return true;\n}\n\n$primes = [];\n", "    // Return false if $n is less\
    \ than or equal to 1 or if $n is greater than or equal to 3.\n    if ($n <= 1\
    \ || $n >= 3) return false;\n\n    // Write your code here.\n}\n</code>\n<|/ q\
    \ dscore=0 |>\n<| c |>\nIs this homework? If so please tag it as such.\n<|/ c\
    \ |>\n<| c |>\n: Yes, this is homework. I just realized I forgot my grade. Sorry!\n\
    <|/ c |>\n<| c |>\nSo you are not asking for a solution, but for an idea? What\
    \ is the question? What have you tried? What is your problem?\n<|/ c |>\n<| c\
    \ |>\nOh. Well I haven't been able to find a way to determine whether a number\
    \ is a prime or not. I've been able to determine whether a number is less than\
    \ or equal to 1 through 3. So what I'm thinking is, I should start counting up\
    \ from there and checking if each number is a prime. I hope that answers your\
    \ question. Thanks for taking the time to read this.\n<|/ c |>\n<| c |>\nAre you\
    \ allowed to use division? I see you have used `int` so I'm assuming you know\
    \ how division works, but it sounds like you're supposed to find out if a number\
    \ is a prime without division being involved.\n<|/ c |>\n<| a dscore=1 |>\nI believe\
    \ there are some optimizations that can be done for prime number testing.\nThe\
    \ first optimization you might want to do is to only check odd numbers. If a number\
    \ is odd, the square root of the number will always be odd. So, you can start\
    \ by checking the square root of the number, then squaring that square root and\
    \ checking for primes. If the square root is odd, then there is no need to check\
    \ any further divisors. If the square root is even, then the number is not prime.\n\
    <|/ a tags=php |>\n<| a tags=php |>\nYou should first check whether a number is\
    \ a multiple of 3 or 5 (depending on what you wish to do). If that number is odd\
    \ then you know that it isnt prime, otherwise you can test for primeness. If the\
    \ number is even then test every number between 2 and half the number to see if\
    \ it is prime. The only number that isnt prime is 6 and 7 (as they arent the only\
    \ primes other than 2). \nThat should give you an idea of how to do it. It would\
    \ be nice to make some checks to see if the numbers are prime before doing the\
    \ prime test. \nIf it helps, heres my code (I havent tested it though)\n<code>\n\
    <?php", "  // Normalize the input.\n  $n = intval($n);\n\n  // No constraints\
    \ on factors.\n  assert($n > 1);\n\n  // Check for small factors.\n  if ($n <\
    \ 2) return false;\n\n  // Use Baillie-Wunsch to test for primeness.\n  for($x\
    \ = 2; $x < $n; $x += 2) {\n    if ($n % $x == 0) {\n      return false;\n   \
    \ }\n  }\n\n  return true;\n}", "  return $n == 2 || $n == 3 || $n == 4\n    ||\
    \ $n == 6\n    || ($n == 7\n    && (($n % 2 == 0)\n    || (($n % 3 == 0)\n   \
    \ && (($n % 5 == 0)\n    || (($n % 7 == 0)\n    && ($n % 11 == 0))))));\n}\n",
  "  if ($n == 1) {\n    return false;\n  }\n  for ($i = 3; $i * $i <= $n; $i++) {\n\
    \    if ($n % $i == 0) {\n      return false;\n    }\n  }\n  return true;\n}",
  "    // 1. If n is less than 2, return false immediately.\n    if ($n < 2) {\n \
    \       return false;\n    }\n\n    // 2. If n is odd, return false immediately.\n\
    \    if ($n % 2 != 0) {\n        return false;\n    }\n\n    // 3. If n is even,\
    \ return false immediately.\n    if ($n % 2 == 0) {\n        return false;\n \
    \   }\n\n    // 4. Let i be n / 2. 2. Let j be 1. i. Let k be 0.\n    // i. Repeat,\
    \ while k \u2260 0, do\n    //    1. Let a be n-1.\n    //    2. Let b be k-1.\n\
    \    //    3. Let j be 2. If n is even, divide n by 2.\n    //    4. Let k be\
    \ 0.\n    //    5. If i = j, return true.\n    //    6. Otherwise, return false.\n\
    \    while ($n != 1) {\n        $i--;\n        $a = $n - 1;\n        $b = $k -\
    \ 1;\n        $j = 2;\n        if ($n % $j == 0) {\n            $k = 0;\n    \
    \    }\n        else {\n            $k = 1;\n        }\n        if ($i == $j)\
    \ {\n            return true;\n        }\n    }\n\n    return false;\n}\n", " \
    \ if ($n <= 1) { return false; }\n  foreach (range(2, $n) as $i) { return $i %\
    \ $n !== 0; }\n  return true;\n}", "  $n = intval($n);\n  if ($n <= 1) {\n   \
    \ return false;\n  }\n\n  for ($i = 3; $i <= sqrt($n); $i += 2) {\n    if ($n\
    \ % $i == 0) {\n      return false;\n    }\n  }\n\n  return true;\n}\n", "  return\
    \ ! is_prime_faster($n, 2);\n}\n", "    if ($n < 2) {\n        return false;\n\
    \    }\n\n    // Trial division using Sieve of Eratosthenes.\n    $p = $n - 1;\n\
    \    $primes = array(3, 5, 7);\n    foreach ($primes as $prime) {\n        if\
    \ ($prime > $n) {\n            break;\n        }\n\n        if ($n % $prime ===\
    \ 0) {\n            $p++;\n            if ($p > $prime) {\n                return\
    \ false;\n            }\n        }\n    }\n\n    return true;\n}\n", "  // http://oeis.org/A000044\n\
    \  if ($n < 8) {\n    // Less than or equal to 2\n    return false;\n  }\n\n \
    \ // http://oeis.org/A003409\n  if ($n <= 2) {\n    // Less than or equal to 1\n\
    \    return true;\n  }\n\n  // http://oeis.org/A003533\n  if ($n == 3) {\n   \
    \ // Less than or equal to 2\n    return true;\n  }\n\n  // http://oeis.org/A003580\n\
    \  if ($n == 5) {\n    // Less than or equal to 3\n    return true;\n  }\n\n \
    \ // http://oeis.org/A003585\n  if ($n == 7) {\n    // Less than or equal to 5\n\
    \    return true;\n  }\n\n  // http://oeis.org/A003592\n  if ($n == 9) {\n   \
    \ // Less than or equal to 7\n    return true;\n  }\n\n  // http://oeis.org/A003595\n\
    \  if ($n == 11) {\n    // Less than or equal to 9\n    return true;\n  }\n\n\
    \  // http://oeis.org/A003600\n  if ($n == 13) {\n    // Less than or equal to\
    \ 11\n    return true;\n  }\n\n  // http://oeis.org/A003601\n  if ($n == 17) {\n\
    \    // Less than or equal to 13\n    return true;\n  }\n\n  // http://oeis.org/A003604\n\
    \  if ($n == 19) {\n    // Less than or equal to 17\n    return true;\n  }\n\n\
    \  // http://oeis.org/A003607\n  if ($n == 23) {\n    // Less than or equal to\
    \ 19\n    return true;\n  }\n\n  // http://oeis.org/A003610\n  if ($n == 29) {\n\
    \    // Less than or equal to 23\n    return true;\n  }\n\n  // http://oeis.org/A003615\n\
    \  if ($n == 33) {\n    // Less than or equal to 29\n    return true;\n  }\n\n\
    \  // http://oeis.org/A003618\n  if ($n == 37) {\n    // Less than or equal to\
    \ 33\n    return true;\n  }\n\n  // http://oeis.org/A003621\n  if ($n == 399)\
    \ {\n    // Less than or equal to 37\n    return true;\n  }\n\n  // http://oeis.org/A003624\n\
    \  if ($n == 479) {\n    // Less than or equal to 39\n    return true;\n  }\n\n\
    \  // http://oeis.org/A003627\n  if ($n == 591) {\n    // Less than or equal to\
    \ 49\n    return true;\n  }\n\n  // http://oeis.org/A003630\n  if ($n == 615)\
    \ {\n    // Les", "    if ($n<=1) {\n        return false;\n    }\n    if ($n==2)\
    \ {\n        return true;\n    }\n    $i=3;\n    while ($i<=$n/2) {\n        if\
    \ ($n%$i==0) {\n            return false;\n        }\n        $i += 1;\n    }\n\
    \    return true;\n}\n", "    // Sieve of Eratosthenes (https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes)\n\
    \    $n = $n | 0;\n    return $n >= 3 && $n <= (sqrt($n) + 1) && $n % 2 === 1;\n\
    }\n", "    // http://oeis.org/A000088\n    $n = abs($n);\n\n    // Set $r to $n\
    \ / 2\n    $r = $n / 2;\n\n    // Check if $r is prime\n    for ($i = 2; $i <\
    \ $n; $i++) {\n        if ($n % $i == 0) {\n            $r = $n;\n           \
    \ return false;\n        }\n    }\n\n    // Check if $r is prime\n    if ($r !=\
    \ $n) {\n        return false;\n    }\n\n    return true;\n}\n", "    if ($n<1)\
    \ {\n        return false;\n    }\n    $limit = (int) sqrt($n);\n    $i=2;\n \
    \   while($i <= $limit) {\n        if ($n%$i == 0) {\n            return false;\n\
    \        }\n        ++$i;\n    }\n    return true;\n}\n", "  $primes = array(2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97);\n  $max = (int) sqrt(($n + 1));\n  foreach ($primes as $prime)\
    \ {\n    if ($prime > $max) {\n      return $false;\n    }\n    if ($n % $prime\
    \ === 0) {\n      return false;\n    }\n  }\n  return $true;\n}\n", "  for ($i\
    \ = 0; $i < $n; ++$i) {\n    // If this number is already a prime, return true.\n\
    \    if ($n % $i == 0) {\n      return true;\n    }\n    // If this number is\
    \ a perfect square from 1 to $i, then\n    // the number is composite.\n    else\
    \ if ($i == $n / 2 && $n % $i == 0) {\n      return false;\n    }\n  }\n  return\
    \ true;\n}\n</code>\n<|/ a |>\n<| c |>\nYour function says is_prime on \"101\"\
    \ is true. Should it be false?\n<|/ c |>\n<| c |>\nYes, it's false because it's\
    \ not prime. 101 is a perfect square.\n<|/ c |>\n<| c |>\nThe point is that 101\
    \ is not a perfect square. 101 = 100 + 1 so 1 is not prime. Since it's only tested\
    \ up to 107, it's never tested any higher number.\n<|/ c |>\n<| c |>\nWhat about\
    \ 61 though? 61 = 61 + 1 so 1 is not prime.\n<|/ c |>\n<| c |>\nI thought your\
    \ comment meant is_prime(61) should be false. Your function says is_prime(61)\
    \ is true.\n<|/ c |>\n<| a dscore=4 |>\nThe best approach would be to loop through\
    \ every integer between 1 and the number you wish to check, inclusive.\n<code>\n\
    if ($number > 1) {\n  for ($i=1; $i <= $number; $i++) {\n    if ($i%$number ==\
    \ 0) {\n      //i is a prime number\n    } else {\n      //i is not prime\n  \
    \  }\n  }\n}\n</code>\nIf you only want it to test divisibility of integers up\
    \ to $number just change it to <= instead of <.\n<|/ a tags=primes,php,math |>\n\
    <| c |>\n`if ($i%$number == 0)` - This will also yield `true` if the number is\
    \ a prime number.\n<|/ c |>\n<| c |>\nThe `if` is only checking the remainder\
    \ of the number divided by `$number`, not whether it's prime. That's why I said\
    \ to change it to `<=`.\n<|/ c |>\n<| c |>\nYou are correct. My bad. :)\n<|/ c\
    \ |>\n<| c |>\nThe only problem with this is that it tests ALL integers, including\
    \ the number itself, so a number like 8 will be returned as prime (despite being\
    \ divisible by 1).\n<|/ c |>\n<| a |>\n<code>", "    if (!is_numeric($n)) {\n\
    \        return false;\n    }\n\n    if ($n < 2) {\n        return false;\n  \
    \  }\n\n    if ($n == 1) {\n        return true;\n    }\n\n    $root = (int) floor(sqrt($n));\n\
    \    if ($root == 0) {\n        return false;\n    }\n\n    if ($n % $root ==\
    \ 0) {\n        return false;\n    }\n\n    $i = $n;\n    do {\n        if ($i\
    \ % ($root + 4) == 0) {\n            return false;\n        }\n        if ($i\
    \ % ($root + 1) == 0) {\n            return false;\n        }\n        if ($i\
    \ % ($root + 2) == 0) {\n            return false;\n        }\n        if ($i\
    \ % ($root + 3) == 0) {\n            return false;\n        }\n        if ($i\
    \ % ($root + 5) == 0) {\n            return false;\n        }\n        if ($i\
    \ % ($root + 6) == 0) {\n            return false;\n        }\n        if ($i\
    \ % ($root + 7) == 0) {\n            return false;\n        }\n        if ($i\
    \ % ($root + 8) == 0) {\n            return false;\n        }\n        if ($i\
    \ % ($root + 9) == 0) {\n            return false;\n        }\n        $i = (int)\
    \ ($i / $root);\n    } while ($i > 1);\n\n    return true;\n}\n</code>\n<|/ a\
    \ |>\n<| a dscore=0 |>\nI think I got it. Here the code. Thanks anyway. :)\n<code>\n\
    <?php", "    if ($n < 2) {\n        return false;\n    }\n\n    // A prime is\
    \ a natural number greater than 1.\n    if ($n <= 3) {\n        return true;\n\
    \    }\n\n    // Check that the number is odd.\n    if ($n % 2 === 1) {\n    \
    \    return false;\n    }\n\n    $root2OfN = sqrt($n);\n    if ($root2OfN ===\
    \ intval($root2OfN)) {\n        // The number is prime.\n        return true;\n\
    \    }\n\n    // Check to see if it is divisible by any number less than or equal\
    \ to half the number\n    $root2OfNPlusOne = sqrt($n) + 1;\n    for ($i = 3; $i\
    \ <= $root2OfNPlusOne; $i += 2) {\n        if ($n % $i === 0) {\n            return\
    \ false;\n        }\n    }\n\n    return true;\n}\n</code>\nYou can optimize this\
    \ a little by checking only until sqrt($n) instead of sqrt($n) + 1, but I don't\
    \ think it is worth the effort to do so.\n<|/ a dscore=0 |>\n<| a |>\nYou can\
    \ do it with just one iteration:\n<code>", "  if ($n<=1)\n    return false;\n\
    \  \n  $i=1;\n  while ($i<=$n/2)\n    if ($n%$i==0) {\n      $i=sqrt($i);\n  \
    \    return false;\n    }\n  \n  return true;\n}\n", "    // Don't forget to check\
    \ negative numbers!\n    // Don't forget to check negative numbers!\n    // Don't\
    \ forget to check negative numbers!\n    // Don't forget to check negative numbers!\n\
    \    // Don't forget to check negative numbers!\n    // Don't forget to check\
    \ negative numbers!\n    // Don't forget to check negative numbers!\n    // Don't\
    \ forget to check negative numbers!\n    // Don't forget to check negative numbers!\n\
    \    // Don't forget to check negative numbers!\n    // Don't forget to check\
    \ negative numbers!\n    // Don't forget to check negative numbers!\n    // Don't\
    \ forget to check negative numbers!\n    // Don't forget to check negative numbers!\n\
    \    // Don't forget to check negative numbers!\n    // Don't forget to check\
    \ negative numbers!\n    // Don't forget to check negative numbers!\n    // Don't\
    \ forget to check negative numbers!\n    // Don't forget to check negative numbers!\n\
    \    // Don't forget to check negative numbers!\n    // Don't forget to check\
    \ negative numbers!\n    // Don't forget to check negative numbers!\n    // Don't\
    \ forget to check negative numbers!\n    // Don't forget to check negative numbers!\n\
    \    // Don't forget to check negative numbers!\n    // Don't forget to check\
    \ negative numbers!\n    // Don't forget to check negative numbers!\n    // Don't\
    \ forget to check negative numbers!\n    // Don't forget to check negative numbers!\n\
    \    // Don't forget to check negative numbers!\n    // Don't forget to check\
    \ negative numbers!\n    // Don't forget to check negative numbers!\n    // Don't\
    \ forget to check negative numbers!\n    // Don't forget to check negative numbers!\n\
    \    // Don't forget to check negative numbers!\n    // Don't forget to check\
    \ negative numbers!\n    // Don't forget to check negative numbers!\n    // Don't\
    \ forget to check negative numbers!\n    // Don't forget to check negative numbers!\n\
    \    // Don't forget to check negative numbers!\n    // Don't forget to check\
    \ negative numbers!\n    // Don't forget to check negative numbers!\n    // Don't\
    \ forget to check negative numbers!\n    // Don't forget to check negative numbers!\n\
    \    // Don't forget to check negative numbers!\n    // Don't forget to check\
    \ negative numbers!\n    // Don't forget to check negative numbers!\n    // Don't\
    \ forget to check negative numbers!\n    // Don't forget to check negative numbers!\n\
    \    // Don't forget to check negative numbers!\n    // Don't forget to check\
    \ negative numbers!\n    // Don't forget to check negative numbers!\n    // Don't\
    \ forget to check negative numbers!\n    // Don't forget to check negative numbers!\n\
    \    // Don't forget to check negative numbers!\n    // Don't forget to check\
    \ negative numbers!\n    // Don't forget to check negative numbers!", "  if ($n\
    \ <= 2) return false;\n  if ($n == 1) return false;\n  for ($i = 3; $i <= sqrt($n);\
    \ $i += 2) {\n    if ($n % $i == 0) return false;\n  }\n  return true;\n}\n",
  "  return $n <= 1;\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis is very efficient,\
    \ though a bit unreadable.  As an added bonus, it'll work for any integer - not\
    \ just integers.\n<|/ c |>\n<| c |>\nAgreed. Not only does this perform better,\
    \ it also scales better. Even if you're not concerned with scaling (and can hardly\
    \ measure the difference), I find this to be more readable, easier to understand,\
    \ and is also a lot more maintainable (if you ever need to change it).\n<|/ c\
    \ |>\n<| c |>\nAwesome! Thanks :)\n<|/ c |>\n<| c |>\nThis works. But I think\
    \ `is_prime` is a bit too restrictive. Consider `is_prime(5)` as false, but `is_prime(100)`\
    \ as true.\n<|/ c |>\n<| c |>\nI see what you're saying. I suppose there are a\
    \ number of ways to approach this problem, but I'm not sure there is a \"right\"\
    \ answer to this question. In general, if you're working with integers and you're\
    \ trying to determine whether a given number is prime, it's easier to just check\
    \ to see if it's equal to 1.\n<|/ c |>\n<| a |>\nA simple but effective trick\
    \ is to determine if the number has a divisor.  If it does, the number is not\
    \ prime.  \n<code>\npublic function IsPrime($number) {\n    // If number is even,\
    \ it's a prime.\n    if ($number % 2 == 0) {\n        return false;\n    }\n\n\
    \    // Start from 3, and increments by 2 until no more divisibility by 2 occurs\
    \ \n    // and we hit $number.\n    for ($i = 3; $i <= $number; $i += 2) {\n \
    \       // If $number divided by $i isn't equal to 0...\n        if ($number %\
    \ $i != 0) {\n            // ...then $number isn't prime.\n            return\
    \ false;\n        }\n    }\n\n    // If we get to this point, then $number is\
    \ prime.\n    return true;\n}\n</code>\n<|/ a tags=optimization,php,primes dscore=3\
    \ |>\n<| c |>\nThanks for the solution, but how efficient it is compared to the\
    \ solution I posted and if so how fast is it?\n<|/ c |>\n<| c |>\nThis isn't exactly\
    \ the same.  In the case of 101, the return should be false.  However, this solution\
    \ will find that 101 is a prime number, when it is clearly not.  It is a good\
    \ solution, though, and one I used in a previous question of mine.\n<|/ c |>\n\
    <| a tags=optimization,php,primes |>\nHere ", "  $base = 2;\n  for($i = 0; $i\
    \ <= ceil(log($n, $base) + 1); $i++) {\n    if($n % $base === 0) {\n      return\
    \ false;\n    }\n    $base = $base * 2;\n  }\n  return true;\n}\n", "    if (!is_numeric($n))\
    \ {\n        return false;\n    }\n    $n = intval($n);\n    if ($n == 1) {\n\
    \        return false;\n    }\n    if ($n <= 1) {\n        return true;\n    }\n\
    \    $limit = $n - 1;\n    $bound = 1;\n    do {\n        if ($n % $bound == 0)\
    \ {\n            $bound = $bound + 6;\n        }\n    } while ($n < $limit);\n\
    \    return $n >= 6;\n}\n", "    $factors = 0;\n    if ($n & 1) {\n        $factors++;\n\
    \        $n = $n >> 1;\n    }\n    while ($n > 1) {\n        if ($n & 1) {\n \
    \           $factors++;\n            $n = $n >> 1;\n        } else {\n       \
    \     $n = $n >> 2;\n        }\n    }\n    return $factors == 2;\n}\n", "    foreach\
    \ (range(1, $n) as $k) {\n        if ($n % $k != 0) {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n", "    // Special cases\n    if ($n ==\
    \ 2 || $n == 3) {\n        return true;\n    }\n    if ($n < 2 || $n%2 == 0 ||\
    \ $n%3 == 0) {\n        return false;\n    }\n    \n    // Check all the numbers\
    \ of form 6n+1\n    $limit = int(sqrt($n) + 1);\n    for ($i = 6; $i <= $limit;\
    \ $i++) {\n        $count = ($i * $i) + 1;\n        if ($count <= $n) {\n    \
    \        if ($count == $n) {\n                return true;\n            }\n  \
    \      }\n    }\n    \n    // If we got this far, it must be prime\n    return\
    \ false;\n}\n", "    $n = (int) $n;\n    if ($n < 2) {\n        return false;\n\
    \    }\n\n    // 2 is a special case. 1 is already a prime, so we can't skip it.\n\
    \    if ($n === 2) {\n        return true;\n    }\n\n    // If n is odd, then\
    \ (n - 1) has no factors.\n    if ($n % 2) {\n        return false;\n    }\n\n\
    \    // If n divides evenly into the previous number, then n cannot be a prime.\n\
    \    // For example: 6 and 14 are prime, but 6 and 15 are not.\n    for ($i =\
    \ (int) (sqrt($n) - 1); $i >= 2; $i--) {\n        if ($n % $i === 0) {\n     \
    \       return false;\n        }\n    }\n\n    // If we get here, it means we\
    \ have tested every number from 2 to n-1.\n    // The first prime numbers will\
    \ have an exact factor of n, so that will be our answer.\n    return $n === (3\
    \ * $i + 2);\n}\n", "    if ($n === 1) {\n        return false;\n    }\n    $is_composite\
    \ = function ($number) {\n        return 0 === ($number % 2);\n    };\n    return\
    \ !($n === 2 || $n <= 1 || $n % 100 === 11 || $n % 100 === 70 || $n % 100 ===\
    \ 91 ||\n        !$is_composite($n) || $n % 97 === 70 || $n % 97 === 91);\n}\n",
  "  // We only need to check the first digit, so we can start with the remainder.\n\
    \  // It will still be true though, so we can exit early.\n  $i_rem = $n % 10;\n\
    \n  // We only need to check the second digit, since the other digits will be\
    \ multiples of $i by 1.\n  // So we can just start with the digit.\n  $i_mul =\
    \ $n % 100;\n\n  // While we do have a remainder, continue checking the other\
    \ digits.\n  while ($i_rem != 0) {\n    // If the remaining digits are multiples\
    \ of the current number, then this is not a prime.\n    // We could exit early\
    \ here if $i_rem == 0, but we don't, since we want to return the remainder.\n\
    \    if ($i_mul % $i_rem != 0) {\n      return false;\n    }\n\n    // Divide\
    \ the number by 10, then take the next digit.\n    $i_mul = $i_mul / 10;\n   \
    \ $i_rem = $i_rem % 10;\n  }\n\n  // If we make it here, then the number is a\
    \ prime.\n  return true;\n}\n", "    if ($n <= 1) {\n        return false;\n \
    \   }\n\n    if ($n == 2 || $n == 3) {\n        return true;\n    }\n\n    //\
    \ Set $i = 3, r = 5, and set $c = 2\n    $i = $c = 3;\n    $r = 5;\n\n    // While\
    \ $i <= sqrt($n)\n    while ($i <= sqrt($n)) {\n        // If $n mod $i equals\
    \ 0, $i is prime\n        if ($n % $i == 0) {\n            return false;\n   \
    \     }\n\n        // Set $c = $i * $i + 1, then set $i = $i * $c + 1\n      \
    \  $c *= $i;\n        $i = $c++;\n    }\n\n    // $n is composite\n    return\
    \ true;\n}\n", "    if($n < 1){\n        return false;\n    }\n    $f = 3;\n \
    \   $s = 2;\n    while ($s < $n) {\n        if ($n % $f == 0) {\n            return\
    \ false;\n        }\n        $f = $s * 3 + 1;\n        $s += 2;\n    }\n    return\
    \ true;\n}", "  $n = abs($n);\n  if ($n < 2)\n    return false;\n  // If n is\
    \ 1 then n can be factored as any number.\n  if ($n === 1)\n    return true;\n\
    \  // Check if n is prime by dividing by all odd numbers between 2 and n.\n  //\
    \ If n is greater than 2, then it can only be factored as prime if its\n  // only\
    \ prime factors are 2 and n.\n  for ($i = 2; $i <= $n; $i++)\n    if ($n % $i\
    \ === 0)\n      return false;\n  return true;\n}\n", "  global $primes;\n  $num\
    \ = (int)$n;\n  for ($i = 0; $i < count($primes); $i++) {\n    if ($num % $primes[$i]\
    \ == 0) {\n      return false;\n    }\n  }\n  return $num > 1 && $num < $primes[count($primes)\
    \ - 1];\n}", "    if ($n <= 1) return false;\n    if ($n == 2) return true;\n\
    \    if ($n % 2 == 0) return false;\n    if ($n % 3 == 0) return false;\n    if\
    \ ($n % 5 == 0) return false;\n\n    $root = (int) sqrt($n);\n    for ($i = 3;\
    \ $i <= $root; $i += 2) {\n        if ($n % $i == 0) {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n", "  return is_prime_py($n, Sieve_of_Eratosthenes);\n\
    }\n</code>\n<|/ a tags=php,primes |>\n<| c |>\nThis solution is more efficient\
    \ than others (at least for large numbers)\n<|/ c |>\n<| a dscore=3 |>\nSieve\
    \ of Eratosthenes is one of the simple algorithms to find prime numbers. But it\
    \ is very inefficient, it can take a lot of time.\nThe most efficient algorithm\
    \ is probabilistic prime sieve, it's based on the following observations:\n\n\
    If p is a prime number, then p-1 is also a prime number.\nIf p is not prime number,\
    \ then we find p, then p-1 and p+1 are also prime numbers.\n\nThis algorithm takes\
    \ a long time when finding prime number. Because the sieve is created only once,\
    \ each time we find prime number we only need to test 3 numbers. We need to test\
    \ the numbers between 2 millions (3 millions is the most interesting number).\n\
    You can find some explanation by googling \"probabilistic prime sieve\".\nYou\
    \ can find a php implementation here: https://github.com/jamiejennings/prime-sieve-php\n\
    <|/ a tags=php,primes |>\n<| c |>\nThe link is outdated. Here's the [archived\
    \ version](https://github.com/jamiejennings/prime-sieve-php) of that repository.\n\
    <|/ c |>\n<| a |>\nI tried to make my code as simple as possible and I did a test\
    \ with 10 million numbers and I got this result:\n\nUsing sieve of Eratosthenes\
    \ took 62.63 seconds to find all the primes between 0 to 10,000,000.\nUsing miller-rabin\
    \ took 62.37 seconds to find all the primes between 0 to 10,000,000.\nUsing Miller-Rabin\
    \ Algorithm took 61.34 seconds to find all the primes between 0 to 10,000,000.\n\
    Using Miller-Rabin with Babylonian Method took 61.18 seconds to find all the primes\
    \ between 0 to 10,000,000.\nUsing Sieve of Eratosthenes took 62.55 seconds to\
    \ find all the primes between 0 to 10,000,000.\nUsing sieve of Eratosthenes and\
    \ Babylonian Method took 62.73 seconds to find all the primes between 0 to 10,000,000.\n\
    \nYou can download the source code here.\nHere is the code:\n<code>\n<?php\n",
  "  return $n == 2 || $n == 3 || $n == 5  ||\n    ($n % 6 == 1 && $n % 12 == 1);\n\
    }", "    // If n is less than 2, it must be prime\n    if ($n < 2) {\n       \
    \ return false;\n    }\n\n    // Check if n is divisible by 7 (divisible by 7\
    \ does not mean it is prime)\n    if ($n % 7 == 0) {\n        return false;\n\
    \    }\n\n    // Check if n is divisible by 11 (divisible by 11 does not mean\
    \ it is prime)\n    if ($n % 11 == 0) {\n        return false;\n    }\n\n    //\
    \ All of the numbers that can possibly be primes\n    // start at 2, and only\
    \ go to sqrt(n).\n    // By increments of 2, each new potential prime will require\n\
    \    // two iterations.\n    // e.g. 5, 13, 17, 37, 71, 89, 107, 131, 197, etc\n\
    \    for ($i = 2; $i < $n; $i += 2) {\n        // Check all potential divisors\n\
    \        for ($j = $i; $j < $n; $j += $i) {\n            // If no remainder, then\
    \ n is prime and can be returned.\n            if ($n % $j == 0) {\n         \
    \       return true;\n            }\n        }\n    }\n\n    // If we got here,\
    \ then n is composite\n    return false;\n}\n", "  if ($n < 2 || $n >= $MAX) {\n\
    \    return false;\n  }\n  if ($n < 7) {\n    return $n == 23 || $n == 47 || $n\
    \ == 64 || $n == 74 || $n == 63 || $n == 63;\n  }\n  if ($n >= 7 && $n <= 13)\
    \ {\n    return $n >= 13 && $n % 13 == 0;\n  }\n  if ($n >= 13 && $n <= 17) {\n\
    \    return $n >= 17 && $n % 13 == 0;\n  }\n  if ($n >= 17 && $n <= 19) {\n  \
    \  return $n >= 19 && $n % 17 == 0;\n  }\n  if ($n >= 19 && $n <= 29) {\n    return\
    \ $n >= 29 && $n % 19 == 0;\n  }\n  if ($n >= 29 && $n <= 37) {\n    return $n\
    \ >= 37 && $n % 29 == 0;\n  }\n  if ($n >= 37 && $n <= 43) {\n    return $n >=\
    \ 43 && $n % 37 == 0;\n  }\n  if ($n >= 43 && $n <= 49) {\n    return $n >= 49\
    \ && $n % 43 == 0;\n  }\n  if ($n >= 49 && $n <= 59) {\n    return $n >= 59 &&\
    \ $n % 49 == 0;\n  }\n  if ($n >= 59 && $n <= 67) {\n    return $n >= 67 && $n\
    \ % 59 == 0;\n  }\n  if ($n >= 67 && $n <= 83) {\n    return $n >= 83 && $n %\
    \ 67 == 0;\n  }\n  if ($n % 6 == 0 && $n % 9 == 0) {\n    return $n == 1;\n  }\n\
    \  return false;\n}", "    if ($n < 2) {\n        return false;\n    }\n\n   \
    \ $sieve = array(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139,\
    \ 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229,\
    \ 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317,\
    \ 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421,\
    \ 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521,\
    \ 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619,\
    \ 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733,\
    \ 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839,\
    \ 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953,\
    \ 967, 971, 977, 983, 991, 997);\n    foreach ($sieve as $i => $j) {\n       \
    \ if ($n % $j == 0) {\n            return false;\n        }\n    }\n    return\
    \ true;\n}\n", "    for ($i = 2; $i <= sqrt($n); ++$i)\n        if ($n % $i ==\
    \ 0)\n            return false;\n    return true;\n}\n</code>\n<|/ a dscore=3\
    \ tags=python,sieve-of-eratosthenes,algorithm,php |>\n<| a dscore=3 |>\nI liked\
    \ this solution very much. However since I had to convert it to Python I am adding\
    \ the code here.\n<code>\ndef is_prime(n):\n    limit = int(math.floor(math.sqrt(n)))\n\
    \    if limit == 2:\n        if n % 2 ==0: return False\n        return True\n\
    \    for i in range(3, limit + 1, 2):\n        if n % i == 0: return False\n \
    \   return True\n</code>\n<|/ a tags=python,sieve-of-eratosthenes,algorithm,php\
    \ |>\n<| c |>\nYou could also do `limit = int(math.floor(math.sqrt(n)))` and then\
    \ `for i in range(3, limit + 1, 2):`\n<|/ c |>\n<| a |>\nA variation on Sieve\
    \ of Eratosthenes to handle only multiples of 3 and 5\n<code>\ndef is_prime(x):\n\
    \    n = 2\n    while x <= n:\n        if x % 6 == 0 or x % 7 == 0:\n        \
    \    return False\n        n += 2\n    return True\n</code>\n<|/ a tags=python,sieve-of-eratosthenes,algorithm,php\
    \ dscore=3 |>\n<| c |>\nThis is only true for numbers with prime-factors of 3,\
    \ not 5, 7 and 11, and numbers that are larger than 6.  For instance, 8 or 9 is\
    \ wrong.\n<|/ c |>\n<| a dscore=2 tags=python,sieve-of-eratosthenes,algorithm,php\
    \ |>\nHere is my code. It's simple, it's fast, and it checks for multiples of\
    \ 3 and 5, as requested by others. \n<code>\ndef is_prime(n):\n    if n == 2:\n\
    \        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n\
    \    for i in range(3, n, 2):\n        if n % i == 0:\n            return False\n\
    \    return True\n</code>\n<|/ a |>\n<| a |>\nI used the following to test if\
    \ a number is a prime number.\n<code>\ndef is_prime(n):\n    if n == 2 or n ==\
    \ 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n\
    \    for i in range(5, int(n**0.5), 2):\n        if n % i == 0:\n            return\
    \ False\n    return True\n</code>\n<|/ a tags=python,sieve-of-eratosthenes,algorithm,php\
    \ dscore=2 |>\n<| a dscore=1 tags=python,sieve-of-eratosthenes,algorithm,php |>\n\
    Python code:\n<code>\ndef is_prime(n):\n    if n == 2 or n == 3 or n == 5:", " \
    \   if ($n <= 1) return false;\n    if ($n <= 3) return true;\n    if ($n % 2\
    \ == 0) return false;\n    if ($n % 3 == 0) return true;\n    if ($n % 5 == 0)\
    \ return false;\n    if ($n % 7 == 0) return true;\n    if ($n % 11 == 0) return\
    \ false;\n    if ($n % 13 == 0) return true;\n    if ($n % 17 == 0) return false;\n\
    \n    $num = 0;\n    for ($i = 5; $i * $i <= $n; $i += 6) {\n        $num += $i\
    \ * pow(6, $i - 5);\n    }\n\n    return $num == $n;\n}\n", "    $n = intval($n);\n\
    \    if ($n < 2) {\n        return false;\n    }\n    $factors = array();\n  \
    \  $divisor = 2;\n    while ($divisor <= sqrt($n)) {\n        if ($n % $divisor\
    \ === 0) {\n            $factors[] = $divisor;\n        }\n        $divisor++;\n\
    \    }\n    return count($factors) == 1;\n}", "  if ($n < 2) {\n    return false;\n\
    \  }\n\n  // We can return immediately if $n is less than 2\n  if ($n < 2) {\n\
    \    return false;\n  }\n\n  // Check out the first even number, since it's only\
    \ odd if it's evenly divisible\n  $first_even = 1;\n  while ($first_even < $n)\
    \ {\n    if ($n % $first_even === 0 && $first_even <= $n - 1) {\n      return\
    \ false;\n    }\n    $first_even *= 2;\n  }\n\n  // Now see if the number is a\
    \ prime\n  foreach (range(1, $n) as $i) {\n    // If we've found a divisor and\
    \ a remainder, it's not prime\n    if ($i % $n === 0 && $i % $first_even !== $n)\
    \ {\n      return false;\n    }\n  }\n\n  return true;\n}\n", "  if ($n <= 1)\
    \ {\n    return false;\n  }\n  foreach ([2, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59,\n           61, 67, 71, 73, 79, 83, 89, 97, 101, 103,\
    \ 107, 109, 113, 127, 131,\n           137, 139, 149, 151, 157, 163, 167, 173,\
    \ 179, 181, 191, 193, 197,\n           199, 211, 223, 227, 229, 233, 239, 241,\
    \ 251, 257, 263, 269, 271,\n           277, 281, 283, 293, 307, 311, 313, 317,\
    \ 331, 337, 347, 349, 353,\n           359, 367, 373, 379, 383, 389, 397, 401,\
    \ 409, 419, 421, 431, 433,\n           439, 443, 449, 457, 461, 463, 467, 479,\
    \ 487, 491, 499, 503, 509,\n           521, 523, 541, 547, 557, 563, 569, 571,\
    \ 577, 587, 593, 599, 601,\n           607, 613, 617, 619, 631, 641, 643, 647,\
    \ 653, 659, 661, 673, 677,\n           683, 691, 701, 709, 719, 727, 733, 739,\
    \ 743, 751, 757, 761, 769,\n           773, 787, 797, 809, 811, 821, 823, 827,\
    \ 829, 839, 853, 857, 859,\n           863, 877, 881, 883, 887, 907, 911, 919,\
    \ 929, 937, 941, 947, 953,\n           967, 971, 977, 983, 991, 997] as $prime)\
    \ {\n    if ($n % $prime === 0) {\n      return false;\n    }\n  }\n  return true;\n\
    }\n", "  $n = abs($n);\n\n  // Check that $n is odd and greater than 1.\n  if\
    \ ($n % 2 == 0) {\n    return false;\n  }\n  else {\n    $n1 = $n / 2;\n    $n2\
    \ = $n - $n1;\n\n    // Check for even squares.\n    // If $n2 = 4n, then 2n /\
    \ 2 = 4n\n    // If $n2 = 8n, then 2n / 2 = 4n\n    if ($n2 != $n) {\n      return\
    \ false;\n    }\n\n    // Check first for divisibility by prime numbers.\n   \
    \ for ($i = 3; $i <= sqrt($n); $i += 2) {\n      if ($n % $i == 0) {\n       \
    \ return false;\n      }\n    }\n  }\n\n  return true;\n}\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nThe OP clearly stated that the function returned true... I guess\
    \ they were saying they were getting errors when calling the function\n<|/ c |>\n\
    <| c |>\n- That's a good point. I've updated my answer.\n<|/ c |>\n<| c |>\nI've\
    \ never seen the `sqrt` function used like this before, thank you for pointing\
    \ that out!\n<|/ c |>\n<| c |>\nThank you for your example. I had a similar problem\
    \ and your solution helped me!\n<|/ c |>\n<| c |>\nThank you!\n<|/ c |>\n<| a\
    \ dscore=5 |>\nI have found a better way of doing it here\n<code>"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
