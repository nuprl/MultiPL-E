name: HumanEval_42_incr_list
language: php
prompt: "<?php\n// Return array with elements incremented by 1.\n// >>> incr_list(array(1,\
  \ 2, 3))\n// array(2, 3, 4)\n// >>> incr_list(array(5, 3, 5, 2, 3, 3, 9, 0, 123))\n\
  // array(6, 4, 6, 3, 4, 4, 10, 1, 124)\nfunction incr_list($l) {\n"
tests: "function candidate(...$args) {\n    return incr_list(...$args);\n}\n\nfunction\
  \ test(): void {\n    if (candidate(array()) !== array()) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(array(3, 2, 1)) !== array(4, 3, 2)) { throw\
  \ new Exception(\"Test failed!\"); }\n    if (candidate(array(5, 2, 5, 2, 3, 3,\
  \ 9, 0, 123)) !== array(6, 3, 6, 3, 4, 4, 10, 1, 124)) { throw new Exception(\"\
  Test failed!\"); }\n}\n\ntest();"
completions: ["\t$i = 0;\n\t$ret = [];\n\tforeach ($l as $item) {\n\t\t$ret[$i] =\
    \ $item;\n\t\t$i++;\n\t}\n\treturn $ret;\n}\n", "  $x = array();\n  for ($n =\
    \ 0; $n < count($l); $n++) {\n    $x[$n + 1] = array_shift($l);\n  }\n  return\
    \ $x;\n}\n", "    $r = array();\n    $len = count($l);\n    for ($i = 0; $i <\
    \ $len; $i++) {\n        $r[$i] = $i + 1;\n    }\n    return $r;\n}\n", "\t$l\
    \ = array_values($l);\n\t$l[] = 1;\n\treturn $l;\n}\n", "  return array_map(function($a)\
    \ { return $a + 1; }, $l);\n}", "    $new = array();\n    for ($i = 0; $i < count($l);\
    \ $i++) {\n        $new[$i] = $l[$i] + 1;\n    }\n    return $new;\n}\n", "  $ret\
    \ = array();\n  foreach ($l as $i => $n) {\n    $ret[$i] = $i + 1;\n  }\n  return\
    \ $ret;\n}\n</code>\nExample usage:\n<code>\n$tests = array(\n  array(\"hello\"\
    ),\n  array(array(\"hello\", \"world\")),\n  array(array(1, \"hello\", 5)),\n\
    \  array(array(1, 2, 3, 4, 5)),\n  array(array(array(1, 2, 3), array(4, 5, 6))),\n\
    );\n\n$ret = array();\nforeach ($tests as $test) {\n  $test = incr_list($test);\n\
    \  $ret[] = $test;\n}\n</code>\n<|/ a dscore=1 tags=arrays,php |>\n<| c |>\nThis\
    \ does not seem to work with a nested array. Try this: `$tests = [array(1, \"\
    hello\", 5), array(1, 2, 3, 4, 5), array(array(1, 2, 3), array(4, 5, 6))];`\n\
    <|/ c |>\n<| a tags=arrays,php dscore=1 |>\nPHP 5.3 added a recursive function\
    \ called array_walk_recursive to allow you to do this in one line.\n<code>\n$test\
    \ = array(1 => 'hello', 2 => 'world', 3 => array('a', 'b', 'c'));\narray_walk_recursive($test,\
    \ function($v){return ++$v;});\n</code>\n<|/ a |>\n<| a |>\nThis works in PHP\
    \ >= 5.3.0 and doesn't require you to specify the callback function on each iteration:\n\
    <code>", "  $count = count($l);\n  $a = array_slice($l, 0);\n  foreach ($a as\
    \ &$val) {\n    $val += 1;\n  }\n  return array_slice($a, 0, $count);\n}\n\n/*\n\
    \ * Compute a SHA256 hash of a given string\n * http://rosettacode.org/wiki/SHA-2#PHP\n\
    \ */", "  $newlist = array();\n  foreach ($l as $key => $value) {\n    $newlist[$key]\
    \ = $value + 1;\n  }\n  return $newlist;\n}", "\t$r = array();\n\t$c = count($l);\n\
    \tfor ($i = $c-1; $i >= 0; $i--) {\n\t\t$r[$i] = $l[$i] + 1;\n\t}\n\treturn $r;\n\
    }\n\n", "  $r = array();\n  $len = count($l);\n  for ($i = 0; $i < $len; $i++)\
    \ {\n    $r[$l[$i]] = $i + 1;\n  }\n  return $r;\n}\n</code>\n<|/ a tags=php |>\n\
    <| a |>\n<code>\n$arr = array( 1,2,3,4,5,6,7,8,9,10 );\n$newArr = array();\n$size\
    \ = sizeof($arr);\n$i = 1;\n$prev = $arr[0] ;\nfor($i = 0; $i < $size; $i++){\n\
    \    $newArr[$prev] = $i;\n    $prev = $arr[$i];\n}\n</code>\n<|/ a dscore=4 tags=php\
    \ |>\n<| c |>\n`$prev = $arr[$i];` can be replaced with `$prev = $i;` inside the\
    \ loop. and `sizeof($arr)` can be replaced with `count($arr)`. But I like this\
    \ one.\n<|/ c |>\n<| a |>\nIn PHP7 you can use the new range() function\n<code>\n\
    $array = [1,2,3,4,5,6,7,8,9,10];\n$newArray = range('a', 'z');\n</code>\nThe output\
    \ is an array of strings:\n<code>\nArray ( [0] => a [1] => b [2] => c [3] => d\
    \ [4] => e [5] => f [6] => g [7] => h [8] => i [9] => j [10] => k [11] => l [12]\
    \ => m [13] => n [14] => o [15] => p [16] => q [17] => r [18] => s [19] => t [20]\
    \ => u [21] => v [22] => w [23] => x [24] => y [25] => z )\n</code>\n<|/ a dscore=4\
    \ tags=php |>\n<| a |>\n<code>\n$newArray = array('a', 'b', 'c', 'd', 'e', 'f',\
    \ 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',\
    \ 'w', 'x', 'y', 'z');\n</code>\n<|/ a dscore=3 tags=php |>\n<| a |>\nYou can\
    \ use php array function called array_fill:\n<code>\n$yourarray = array_fill(0,10,\"\
    a\");\n</code>\n<|/ a dscore=3 tags=php |>\n<| a tags=php |>\n<code>", "    $r\
    \ = array();\n    foreach ($l as $k => $v)\n        $r[$k + 1] = $v;\n    return\
    \ $r;\n}\n", "  $r = array();\n  foreach ($l as $k) {\n    $r[$k] = $k + 1;\n\
    \  }\n  return $r;\n}", "  $r = [];\n  $a = array_reverse($l);\n  foreach ($a\
    \ as $k => $v) {\n    $r[$k] = $v + 1;\n  }\n  return $r;\n}\n", "  $result =\
    \ array();\n  foreach ($l as $i => $v) $result[$i + 1] = incr($v);\n  return $result;\n\
    }\n", "  $ret=array();\n  for($i=0; $i<count($l); $i++) {\n    $ret[$i]=$l[$i]+1;\n\
    \  }\n  return $ret;\n}", "  $r = array();\n  $cnt = count($l);\n  for($i = 0;\
    \ $i < $cnt; $i++) {\n    $r[] = $i + 1;\n  }\n  return $r;\n}\n", "  return array_map(\n\
    \    function ($n) { return $n + 1; },\n    $l\n  );\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThis is a really nice approach! I didn't know PHP had `array_reduce`\
    \ :)\n<|/ c |>\n<| a dscore=2 |>\nThis is my approach. \n<code>", "  $r = [];\n\
    \  foreach ($l as $i => $e) {\n    $r[$i] = $e + 1;\n  }\n  return $r;\n}", "\t\
    $n = sizeof($l) - 1;\n\tfor ($i = 0; $i < $n; $i++) {\n\t\t$l[$i + 1] = $l[$i]\
    \ + 1;\n\t}\n\treturn $l;\n}", "  foreach ($l as $i => $v) {\n    $l[$i+1] = $v;\n\
    \  }\n  return $l;\n}\n", "    $ret = array();\n    foreach ($l as $key => $val)\
    \ {\n        $ret[$key] = $val+1;\n    }\n    return $ret;\n}\n</code>\n<|/ a\
    \ tags=sorting,php |>\n<| c |>\nSorry, I think it was a typo (I have corrected\
    \ it).\n<|/ c |>\n<| c |>\nNo, it is still wrong. `incr_list` returns a new array,\
    \ so you cannot iterate over its items directly.\n<|/ c |>\n<| c |>\nIt works\
    \ because your array is sorted on first key. As you can see, I have used an associative\
    \ array (key => value) on second param (`$l`).\n<|/ c |>\n<| c |>\n: thanks for\
    \ your answer, but i can't use the second method you mentioned, as the values\
    \ are in random positions in array and there is no pattern between them, so i\
    \ can't use that method. Is there any other way to sort the array ? Thanks\n<|/\
    \ c |>\n<| c |>\n: i tried your method too but no luck, thanks anyway\n<|/ c |>\n\
    <| a |>\n<code>\n<?php\n$a = array(1, 2, 3, 4, 7, 8, 10);\n\n$arr = array();\n\
    $arr['count'] = count($a);\n$arr['array'] = $a;\n\nksort($arr);\nforeach($arr\
    \ as $key => $value) {\n  $newArray[] = $value['count'] -  $value['array'][$key];\n\
    }\nprint_r($newArray);\n</code>\n<|/ a tags=sorting,php dscore=1 |>\n<| c |>\n\
    `$arr['array'] = $a` is useless, you can remove it.\n<|/ c |>\n<| c |>\nYes, I\
    \ agree. Thanks\n<|/ c |>\n<| a tags=sorting,php |>\nYou can do something like\
    \ that:\n<code>\n$new_array = array_merge(array_slice($old_array, 1), array_slice($old_array,\
    \ 0, 1));\n</code>\nThis approach is more general and also will work on the first\
    \ element of the array.\n<|/ a dscore=0 |>\n<| a dscore=0 tags=sorting,php |>\n\
    You can try this - \n<code>\n$array = array(1, 4, 7, 2, 5, 9, 0);\n$new_array\
    \ = array();\n$index = 1;\nforeach ($array as $val){\n    $new_array[$index] =\
    \ $index - $val;\n    $index++;\n}\nprint_r($new_array);\n</code>\n<|/ a |>\n\
    <| c |>", "  if (!is_array($l))\n    return array($l);\n  $r = array();\n  foreach\
    \ ($l as $i => $v)\n    if ($v)\n      $r[$i + 1] = $v;\n  return $r;\n}\n", " \
    \ if (!is_array($l)) {\n    return false;\n  }\n  $result = [];\n  $i = 1;\n \
    \ foreach ($l as $item) {\n    $result[] = $item + $i;\n    $i++;\n  }\n  return\
    \ $result;\n}", "  foreach ($l as $key => $value) {\n    $l[$key]++;\n  }\n  return\
    \ $l;\n}", "    $ret = array();\n    $i = 0;\n    foreach ($l as $val) {\n   \
    \     $ret[$i] = $val;\n        $i++;\n    }\n    return $ret;\n}", "    $r =\
    \ $l;\n    for ($i = 0, $n = count($l); $i < $n; ++$i) {\n        $r[$i] += 1;\n\
    \    }\n    return $r;\n}\n", "    $r = array();\n    for ($i = 0, $len = count($l);\
    \ $i < $len; $i++) {\n        $r[] = $l[$i] + 1;\n    }\n    return $r;\n}", " \
    \ $newlist = array();\n  $l = is_array($l) ? $l : array($l);\n  $i = 0;\n  //\
    \ Iterating over list.\n  foreach ($l as $item) {\n    $newlist[$i] = $item;\n\
    \    $i++;\n  }\n  // Return array.\n  return $newlist;\n}\n", "  $c = count($l);\n\
    \  if ($c == 0) return array();\n  $o = reset($l);\n  return $c == 1 ? array($o\
    \ + 1) : $o + 1;\n}", "\t$new = array();\n\tfor($i = count($l) - 1; $i >= 0; $i--)\
    \ {\n\t\t$new[] = $l[$i + 1];\n\t}\n\treturn $new;\n}\n", "  for ($i = count($l);\
    \ $i > 0; $i--) {\n    $l[$i] = $l[$i - 1] + 1;\n  }\n  return $l;\n}", "  $result\
    \ = array();\n  foreach ($l as $key => $value) {\n    $result[$key] = $value +\
    \ 1;\n  }\n  return $result;\n}", "\tforeach ($l as &$el) {\n\t\t$el++;\n\t}\n\
    \treturn $l;\n}\n", "  $last = end($l);\n  array_push($l, 1);\n  return array_merge($l,\
    \ $last);\n}", "  $r = array();\n  foreach ($l as $val) {\n    if (!isset($r[$val]))\
    \ {\n      $r[$val] = 0;\n    }\n    $r[$val]++;\n  }\n  return $r;\n}\n", " \
    \   $ret = array();\n    foreach ($l as $key => $value) {\n        $ret[] = $value\
    \ + 1;\n    }\n    return $ret;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nYeah,\
    \ I know, I was just playing around with this and wanted to see if I can get something\
    \ working.\n<|/ c |>\n<| c |>\nI wouldn't say this is a \"good way\", though.\
    \ At some point it will probably become a performance issue. Also, if you need\
    \ to do this in multiple places in your code, it's going to become a bit more\
    \ verbose.\n<|/ c |>\n<| a tags=php |>\nWell, if you don't mind using external\
    \ library (I recommend you to install this library via composer), you can use\
    \ this one (just in case you didn't find it yet):\nhttps://github.com/kartik-v/yii2-array-helper\n\
    And here is example how to use it:\n<code>\n$arr = [\n    1 => 2,\n    2 => 3,\n\
    \    3 => 4,\n];\n\n$arrayHelper = ArrayHelper::getValue(array_keys($arr), 0,\
    \ $arr); // returns 2\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nThe best\
    \ way to create an array incrementing by one on every loop is to use array_map()\
    \ with a callback function, like this:\n<code>\n<?php\n", "  $r = array();\n \
    \ foreach ($l as $i => $v) {\n    if (isset($r[$v])) {\n      $r[$v]++;\n    }\
    \ else {\n      $r[$v] = 1;\n    }\n  }\n  return $r;\n}\n", "  $ret=array();\n\
    \  foreach ($l as $v) $ret[]=$v+1;\n  return $ret;\n}\n", "    $result = [];\n\
    \    foreach ($l as $v) {\n        $result[] = $v + 1;\n    }\n    return $result;\n\
    }\n</code>\n<|/ a tags=php,arrays dscore=1 |>\n<| a dscore=1 tags=php,arrays |>\n\
    I've created one method that I think it could be useful:\n<code>", "  $d = array();\n\
    \  $last_value = end($l);\n  foreach ($l as $value) {\n    $d[] = $value + 1;\n\
    \    if ($value != $last_value) {\n      $d[] = $last_value;\n    }\n  }\n  return\
    \ $d;\n}\n</code>\nOutput:\n<code>\nArray ( \n    [0] => 1 \n    [1] => 2 \n \
    \   [2] => 3 \n    [3] => 4 \n    [4] => 5 \n    [5] => 6 \n    [6] => 7 \n  \
    \  [7] => 8 \n    [8] => 9 \n    [9] => 10 \n    [10] => 11 \n    [11] => 12 \n\
    \    [12] => 13 \n    [13] => 14 \n    [14] => 15 \n    [15] => 16 \n    [16]\
    \ => 17 \n    [17] => 18 \n    [18] => 19 \n    [19] => 20 \n    [20] => 21 \n\
    \    [21] => 22 \n    [22] => 23 \n    [23] => 24 \n    [24] => 25 \n    [25]\
    \ => 26 \n    [26] => 27 \n    [27] => 28 \n    [28] => 29 \n    [29] => 30 \n\
    \    [30] => 31 \n    [31] => 32 \n    [32] => 33 \n    [33] => 34 \n    [34]\
    \ => 35 \n    [35] => 36 \n    [36] => 37 \n    [37] => 38 \n    [38] => 39 \n\
    \    [39] => 40 \n    [40] => 41 \n    [41] => 42 \n    [42] => 43 \n    [43]\
    \ => 44 \n    [44] => 45 \n    [45] => 46 \n    [46] => 47 \n    [47] => 48 \n\
    \    [48] => 49 \n    [49] => 50 \n    [50] => 51 \n    [51] => 52 \n    [52]\
    \ => 53 \n    [53] => 54 \n    [54] => 55 \n    [55] => 56 \n    [56] => 57 \n\
    \    [57] => 58 \n    [58] => 59 \n    [59] => 60 \n    [60] => 61 \n    [61]\
    \ => 62 \n    [62] => 63 \n    [63] => 64 \n    [64] => 65 \n    [65] => 66 \n\
    \    [66] => 67 \n    [67] => 68 \n    [68] => 69 \n    [69] => 70 \n    [70]\
    \ => 71 \n    [71] => 72 \n    [72] => 73 \n    [73] => 74 \n    [74] => 75 \n\
    \    [75] => 76 \n    [76] => 77 \n    [77] => 78 \n    [78] => 79 \n    [79]\
    \ => 80 ", "  $i = 1;\n  $ret = [];\n  foreach($l as $e) {\n    $ret[] = $e+1;\n\
    \  }\n  return $ret;\n}\n", "\t$n = array();\n\tforeach ($l as $i => $v) {\n\t\
    \t$n[$i] = $i + 1;\n\t}\n\treturn $n;\n}\n\n", "  $ret = array();\n  for ($x =\
    \ 0; $x < count($l); $x++) {\n    $ret[$x] = $l[$x] + 1;\n  }\n  return $ret;\n\
    }", "  $r = array();\n  for ($i=0; $i < count($l); $i++) {\n    $r[$i+1] = $l[$i];\n\
    \  }\n  return $r;\n}", "  $ret = array();\n  foreach ($l as $val) {\n    $ret[]\
    \ = $val + 1;\n  }\n  return $ret;\n}\n", "  if (!is_array($l)) {\n    throw new\
    \ InvalidArgumentException('List must be an array');\n  }\n  if (empty($l)) {\n\
    \    return array();\n  }\n  $a = array();\n  $a[] = array_shift($l);\n  foreach\
    \ ($l as $e) {\n    if ($e < $a[count($a)-1]) {\n      $a[count($a)] = $e;\n \
    \   } else {\n      $a[] = $e;\n    }\n  }\n  return $a;\n}\n", "    $i = 0;\n\
    \    foreach ($l as $item) {\n        $i++;\n        $l[$i] = $item;\n    }\n\
    \    return $l;\n}\n", "  $r = array();\n  foreach($l as $k => $v)\n    $r[] =\
    \ $v + 1;\n  return $r;\n}\n</code>\n<|/ a tags=php,arrays,recursion dscore=1\
    \ |>\n<| a dscore=1 |>\nA simple recursive function using array_sum:\n<code>\n\
    $arr = array(1, 2, 3);\n$arr2 = array(5, 3, 5, 2, 3, 3, 9, 0, 123);\n", "  $l\
    \ = array_values($l);\n  $l[0]++;\n  return array_slice($l, 1);\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=php |>\nThe most general solution would be to iterate\
    \ over each element in an array and increment it by one. It will be very slow\
    \ for large arrays, but will still be fast for small arrays:\n<code>", "  $ret\
    \ = $l;\n  array_walk($ret, \"inc_array\");\n  return $ret;\n}", "  $r = array();\n\
    \  foreach ($l as $k => $v) {\n    $r[$k + 1] = $v;\n  }\n  return $r;\n}", "\t\
    $r = array();\n\tforeach ($l as $v) {\n\t\tif (is_null($v)) {\n\t\t\tcontinue;\n\
    \t\t}\n\t\t$r[] = $v + 1;\n\t}\n\treturn $r;\n}\n", "  return array_values($l)\
    \ + array(1);\n}\n", "  $r = array();\n  for ($i = 0, $c = count($l); $i < $c;\
    \ $i++) $r[] = $l[$i] + 1;\n  return $r;\n}\n", "    if (empty($l)) {\n      \
    \  return $l;\n    }\n\n    $r = array();\n    foreach ($l as $e) {\n        if\
    \ (!isset($r[$e])) {\n            $r[$e] = 0;\n        }\n        $r[$e]++;\n\
    \    }\n    return $r;\n}\n", "  foreach ($l as &$item) {\n    if ( !is_int($item)\
    \ )\n      reset($item);\n    $item = ++$item;\n  }\n  return $l;\n}", "  for\
    \ ($c = count($l) - 1; $c > 0; $c--) {\n    $l[$c]++;\n  }\n  return $l;\n}",
  "    $ret = array();\n    foreach ($l as $k => $v) {\n        $ret[$k + 1] = $v;\n\
    \    }\n    return $ret;\n}\n</code>\n<|/ a |>\n<| a tags=increment,arrays,php\
    \ dscore=2 |>\nThe other answers are great, but they also rely on $arr being ordered\
    \ in the first place. Since PHP doesn't guarantee that, in general, associative\
    \ arrays are ordered, you'll have to either sort the array, or use an alternative\
    \ solution.\nHere's how I'd solve this:\n<code>", "    $c = count($l);\n    for\
    \ ($i = $c; $i < 2; $i++) {\n        $l[$i] = $l[$i - 1] + 1;\n    }\n    return\
    \ $l;\n}", "  if ($l === NULL) { return $l; }\n  if (empty($l)) { return array();\
    \ }\n\n  return array_merge($l, array_map(function ($item) { return $item + 1;\
    \ }, $l));\n}\n", "  $a = array();\n  foreach ($l as $val) {\n    $a[] = $val\
    \ + 1;\n  }\n  return $a;\n}", "    foreach ($l as $k => $v) {\n        $l[$k]\
    \ += 1;\n    }\n    return $l;\n}\n\n/**\n * Incr array value with index\n *\n\
    \ * @param array $array\n * @param int $key index\n * @param int $value increment\n\
    \ *\n * @return array\n */", "  $r = array();\n  $i = 0;\n  foreach ($l as $val)\
    \ {\n    $r[$i] = $val + 1;\n    $i++;\n  }\n  return $r;\n}\n", "  $ret = array();\n\
    \  for ($i = 0, $c = count($l); $i < $c; $i++) {\n    $ret[$i] = $i + 1;\n  }\n\
    \  return $ret;\n}\n", "  $n = 0;\n  $l = is_array($l) ? $l : array($l);\n  foreach\
    \ ($l as $e) {\n    $n++;\n    $l[$n] = $e;\n  }\n  return $l;\n}\n", "    if\
    \ (is_array($l)) {\n        $r = [];\n        foreach ($l as $e) {\n         \
    \   $r[] = $e + 1;\n        }\n        return $r;\n    }\n    else {\n       \
    \ trigger_error('incr_list() expects array as first argument.');\n    }\n}\n",
  "    // This works, but it feels so wrong!\n    $l = array_reverse($l);\n    //\
    \ $l[$i + 1] = $l[$i];\n    // $l[$i] = $i + 1;\n    // return array_reverse($l);\n\
    \    array_unshift($l, 1);\n    return array_reverse($l);\n}\n</code>\n<|/ a tags=arrays,php\
    \ |>\n<| a dscore=2 |>\n<code>\n<?php\n$arr = array(1,2,3,4);\n$arr2 = array(5,5,5,2,3,3,9,0,123);\n\
    $arr3 = array();\n$i = 0;\nforeach($arr as $value) {\n    if($i < count($arr2)){\n\
    \        $arr3[$i] = $value;\n        $i++;\n    } else {\n        $arr3[$i] =\
    \ $arr2[$i];\n        $arr3[$i+1] = count($arr);\n        $i++;\n    }\n}\nvar_dump($arr3);\n\
    </code>\n<|/ a tags=arrays,php |>\n<| c |>\nWon't work, since it keeps copying\
    \ the first element as many times as there are values in the second array.\n<|/\
    \ c |>\n<| c |>\nSorry, I misunderstood the question, please see my edited answer.\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>\n$array = array(1,2,3,4);\n$array2 = array(5,5,5,2,3,3,9,0,123);\n\
    $i=0;\nforeach($array as $k=>$v){\n    if($k==0){\n        $array3[$i-1] = $v;\n\
    \    }else{\n        $array3[$i] = $v;\n    }\n    if($k == count($array2)-1){\n\
    \        $array3[$i+1] = $v;\n    }\n    $i++;\n}\nvar_dump($array3);\n</code>\n\
    <|/ a tags=arrays,php |>\n<| a dscore=2 |>\n<code>\n$array3 = array_merge_recursive(\n\
    \    array_slice($array1, 1),\n    array_slice($array2, 0, -1),\n    array_slice($array1,\
    \ 1, -1)\n);\n</code>\n<|/ a tags=arrays,php |>\n<| a tags=arrays,php |>\nThis\
    \ solution will work for any number of arrays passed in. No looping needed.\n\
    <code>\n<?php\n$numOfArrays = func_num_args();\n$arrays = func_get_args();\n\n\
    $array3 = array();\n$array3[] = array_shift($arrays);\n$array3[] = array_shift($arrays);\n\
    \n$i = 0;\nforeach ($arrays as $array)\n{\n    $array", "  $l = array_reverse($l);\n\
    \  for ($i = 0, $n = count($l); $i < $n; $i++) {\n    $l[$i] = $l[$i] + 1;\n \
    \ }\n  return $l;\n}\n\n/**\n * Iterates over an input array, yielding keys and\
    \ values from the\n * input array. Optionally sorts the input using a callback.\n\
    \ *\n * @param array $array The input array.\n * @param callback|null $sort_func\
    \ The function to be used for sorting.\n *\n * @return array An array of the key-value\
    \ pairs from the input array\n *     with keys ordered if $sort_func is not null.\n\
    \ */", "  foreach ($l as $k => $v) {\n    $l[$k] += 1;\n  }\n  return $l;\n}\n",
  "  $r = array();\n  foreach ($l as $k => $v) {\n    if (!is_int($k)) $k = $v;\n\
    \    $r[$k] = $r[$k] ?? $k;\n    $r[$k] += $v;\n  }\n  return $r;\n}\n</code>\n\
    <|/ a tags=arrays,php,sorting |>\n<| c |>\nVery smart solution. Thank you.\n<|/\
    \ c |>\n<| a |>\nHere's a solution that uses array_count_values to count the number\
    \ of times each element appears in the array, and then creates the new array.\
    \ Finally, it uses array_multisort to sort the new array into the order you want.\n\
    <code>", "  $r = array();\n  $c = 0;\n  foreach ($l as $e) {\n    $r[$c++] = $e;\n\
    \    $r[$c++] = $e;\n  }\n  return $r;\n}\n\n/**\n * Increment key of key/value\
    \ pairs.\n * Useful for associative arrays.\n *\n * @see incr_key()\n */", " \
    \ $x = array();\n  $y = count($l) - 1;\n  foreach ($l as $key => $value) {\n \
    \   $x[$key] = $value;\n    if ($y == $key) {\n      $x[$key] = $value + 1;\n\
    \    }\n  }\n  return $x;\n}\n", "    return array_map(function($x, $y) { return\
    \ ++$y; }, $l);\n}\n", "  $r = array();\n  $n = count($l);\n  for ($i = 0; $i\
    \ < $n; ++$i) {\n    if (isset($l[$i])) {\n      $r[$i] = $l[$i] + 1;\n    }\n\
    \  }\n  return $r;\n}", "  foreach ($l as $k => $v)\n    if (!isset($l[$k + 1]))\n\
    \      $l[$k + 1] = $v;\n  asort($l);\n  $out = array();\n  foreach ($l as $k\
    \ => $v)\n    $out[] = $v;\n  return $out;\n}\n", "  $n = 0;\n  foreach ($l as\
    \ $key => $value) {\n    if ($n == 0) {\n      $new[$key] = $value;\n    }\n \
    \   else {\n      $new[$key] = $value + 1;\n    }\n    $n++;\n  }\n  return $new;\n\
    }", "  $n = count($l);\n  $r = array();\n  foreach ($l as $v) {\n    $r[] = $v\
    \ + 1;\n  }\n  return $r;\n}\n</code>\n<|/ a tags=arrays,php |>\n<| a |>\n<code>\n\
    $result = array();\nforeach ($array as $key => $value) {\n    $result[$key]++;\n\
    }\n</code>\nOr if you prefer functional programming style\n<code>\n$result = array_map(function($value){\n\
    \    return $value +1;\n}, $array);\n</code>\n<|/ a tags=arrays,php dscore=5 |>\n\
    <| c |>\nThis way is the most elegant I know\n<|/ c |>\n<| a dscore=5 |>\nIf you\
    \ really want to use array_map with closure:\n<code>\n$array = array(\n    0 =>\
    \ 'zero',\n    1 => 'one',\n    2 => 'two',\n    3 => 'three',\n);\n\nprint_r(array_map(function($v){\n\
    \    return $v+1;\n}, $array));\n</code>\n<|/ a tags=arrays,php |>\n<| a dscore=3\
    \ |>\n<code>\n$array = array(\"A\", \"B\", \"C\");\n$newarray = array();\n\nforeach($array\
    \ as $arr){\n    $newarray[] = ++$arr;\n}\nprint_r($newarray);\n</code>\n<|/ a\
    \ tags=arrays,php |>\n<| a dscore=2 |>\n<code>\n$result = array();\nforeach ($array\
    \ as $key => $value) {\n    $result[$key]++;\n}\n</code>\n<|/ a tags=arrays,php\
    \ |>\n<| a dscore=2 |>\n<code>\n$result = array();\n$i = 0;\nforeach($array as\
    \ $value) {\n   $result[$i] = $value;\n   $i++;\n}\n</code>\n<|/ a tags=arrays,php\
    \ |>\n<| a dscore=2 |>\n<code>\n$result = array();\nforeach($array as $key =>\
    \ $value) {\n    $result[$key]++;\n}\n</code>\n<|/ a tags=arrays,php |>\n<| a\
    \ dscore=2 tags=arrays,php |>\n<code>\n$array = array(\"A\", \"B\", \"C\");\n\
    $newarray = array();\n\nforeach($array as $arr){\n    $newarray[] = ++$arr;\n\
    }\n</code>\n<|/ a |>\n<| a tags=arrays,php |>\nUse array_sum with array_map\n\
    <code>\n$array = array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ", "  $ret = array();\n\
    \  foreach ($l as $e) {\n    $ret[] = $e + 1;\n  }\n  return $ret;\n}\n", "  \
    \  // If l is empty, then the resulting array has 0 elements.\n    if (!empty($l))\
    \ {\n        // Get the first element of l.\n        $first = array_shift($l);\n\
    \n        // Get the rest of l and increment the first element.\n        $r =\
    \ $l;\n        $r[] = $first;\n        $l = $r;\n    }\n\n    // Return result.\n\
    \    return $l;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=arrays,php |>\n<code>",
  "  $l = array_reverse($l);\n  $i = count($l) - 1;\n  $k = 0;\n\n  while (--$i >=\
    \ 0) {\n    $l[$k + 1] += $l[$i];\n    $l[$i] = 0;\n  }\n  return $l;\n}\n", " \
    \ $r = array();\n  foreach ($l as $e) {\n    $r[] = $e + 1;\n  }\n  return $r;\n\
    }\n", "    $a = array();\n    foreach($l as $k) {\n        $a[] = $k+1;\n    }\n\
    \    return $a;\n}", "    $i = 0;\n    $r = array();\n    foreach ($l as $e) {\n\
    \        $r[$i] = $e;\n        $i++;\n    }\n    return $r;\n}\n", "    $n = 0;\n\
    \    foreach ($l as $k => $v) {\n        $l[$k] = ++$n;\n    }\n    return $l;\n\
    }\n", "  $r = array();\n  foreach ($l as $k => $v) {\n    $r[$k + 1] = $v;\n \
    \ }\n  return $r;\n}\n", "  $i = 1;\n  foreach ($l as $n => $s) {\n    $l[$n]\
    \ = $i++ . $s;\n  }\n  return $l;\n}\n", "    $i = 1;\n    foreach ($l as $k =>\
    \ $v) {\n        $l[$k] = $i++;\n    }\n    return $l;\n}\n</code>\nAnd here is\
    \ another version using foreach loops:\n<code>", "    $i = 1;\n    $out = array();\n\
    \    foreach ($l as $item) {\n        $out[] = $item + $i;\n        $i++;\n  \
    \  }\n    return $out;\n}", "  $r=$l;\n  for($i=sizeof($l)-1;$i>=0;$i--) {\n \
    \   $r[$i]++;\n    if($r[$i]===count($r)&&$r[$i-1]===0) {\n      unset($r[$i]);\n\
    \    }\n  }\n  return $r;\n}\n</code>\n<|/ a tags=php |>\n<| c |>\nThanks, but\
    \ the problem is i need to keep track of it myself without using an array. Could\
    \ you give an example?\n<|/ c |>\n<| c |>\nYou can always create an array and\
    \ add each element to it every time you encounter the element you want to keep\
    \ track of. The array will be ordered as if you were tracking them yourself.\n\
    <|/ c |>\n<| c |>\nI added an example to my answer above, please give it a look\
    \ if you feel like it.\n<|/ c |>\n<| c |>\nThanks a lot for your answer, but I\
    \ feel like there must be a more elegant way to do this. I'm just not that good\
    \ in PHP (yet).\n<|/ c |>\n<| c |>\nIf you feel like it you can always accept\
    \ the answer, if it really helped. I don't think there is a better solution than\
    \ keeping track of a \"running\" total of items in a list. Your question was \"\
    how do I keep track of a running total without using an array?\", my answer was\
    \ \"I simply keep track of the running total as an array element in a simple way\
    \ that doesn't require any looping.\" I suggest that if you don't believe my answer\
    \ helped you then you should accept it. Hope that helps! :)\n<|/ c |>\n<| a |>\n\
    If you don't want an array, you could use a class which stores two pieces of data:\
    \ the current \"sum\" and a collection of \"counts\".\n<code>\nclass SumAndCount\n\
    {\n    public $sum;\n    private $counts = array();\n\n    public function addCount($count)\
    \ {\n        $this->counts[] = $count;\n        $this->sum+= $count;\n    }\n\n\
    \    public function getSum()\n    {\n        return $this->sum;\n    }\n\n  \
    \  public function getCounts()\n    {\n        return $this->counts;\n    }\n\
    }\n</code>\nYou could then create a new SumAndCount object whenever you encounter\
    \ a new value and call addCount() on the previous object, or you could use addCount()\
    \ to add the value to the current \"sum\". The getSum() method will return the\
    \ current sum and getCounts() will return the collection of counts.\n<code>\n\
    $counts = new SumAndCount();\n$counts->addCount(1);\n$counts->addCount(1);\n$counts->add",
  "  if (count($l) < 2) {\n    return $l;\n  }\n  $r = [];\n  for ($i = 0, $last =\
    \ array_pop($l); $i < count($l); ++$i) {\n    if ($i == 0) {\n      $r[] = $last;\n\
    \      $last = array_pop($l);\n    }\n    if ($last == $l[$i]) {\n      $last++;\n\
    \    } else {\n      $r[] = $last;\n      $last = $l[$i];\n    }\n  }\n  return\
    \ $r;\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=php,arrays dscore=2 |>\n<code>\n\
    $arr = [1,2,5,5,8,4,4,7,7,7,6];\n", "    $ret = $l; // $l is passed as ref, so\
    \ change its value.\n    foreach ($l as $key => $value) {\n        ++$ret[$key];\n\
    \    }\n    return $ret;\n}", "  $r = array();\n  foreach ($l as $k => $v) {\n\
    \    if (isset($r[$v])) {\n      $r[$v]++;\n    } else {\n      $r[$v] = 1;\n\
    \    }\n  }\n  return $r;\n}\n\n$incr_array_1 = incr_array($array_1);\n$incr_array_2\
    \ = incr_array($array_2);\n\n$total_diff = array_diff_assoc($incr_array_1, $incr_array_2);\n\
    </code>\n<|/ a |>\n<| c |>\nThanks Boris, this worked well for me. I didn't need\
    \ to use array_unique() as the array elements are unique in each case. Great solution,\
    \ thanks again!\n<|/ c |>\n<| a |>\n<code>", "  foreach ($l as &$x) {\n    $x++;\n\
    \  }\n  return $l;\n}", "  $a = array();\n  $i = 0;\n  foreach ($l as $e) {\n\
    \    $a[] = $i++;\n  }\n  return $a;\n}", "  $l = array_values($l);\n  $len =\
    \ count($l);\n  $ret = $l;\n  for($i = $len; $i < count($l); $i++) {\n    $ret[$i]\
    \ = $ret[$i] + 1;\n  }\n  return $ret;\n}\n", "  return array_map(function ($x)\
    \ { return ++$x; }, $l);\n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\nThis problem\
    \ can be solved in many ways. One of the ways is using array_map function:\n<code>\n\
    <?php\n\n$input = array(1, 2, 3);\n\n$result = array_map(function($i)\n{\n   \
    \ return ++$i;\n}, $input);\n\nprint_r($result);\n</code>\nThe output is:\n<code>\n\
    Array\n(\n    [0] => 2\n    [1] => 3\n    [2] => 4\n)\n</code>\n<|/ a tags=arrays,php\
    \ dscore=0 |>\n<| c |>\nYou mean `function($i) { return ++$i; }`?\n<|/ c |>\n\
    <| a tags=arrays,php |>\nI came up with a pretty slick solution.\n<code>\n$incrList\
    \ = function($nums, $key = 'id') {\n  $result = array();\n\n  $result[] = $nums[0];\n\
    \  for ($i = 1; $i < count($nums); $i++) {\n    $result[] = $nums[$i];\n  }\n\n\
    \  return $result;\n};\n\n$nums = [1, 2, 3, 4, 5]; // original array\n$nums =\
    \ $incrList($nums); // new array with incremented values - [1, 2, 3, 4, 5]\n</code>\n\
    You can now do whatever you want with the new array $nums.\n<|/ a dscore=0 |>\n\
    <| a tags=arrays,php dscore=0 |>\nThis is one of the solution in pure php for\
    \ increment the array values.\n<code>", "  $new = array();\n  foreach ($l as $item)\
    \ {\n    $new[] = $item + 1;\n  }\n  return $new;\n}\n", "  $ret = array();\n\
    \  foreach ($l as $k => $v) {\n    $ret[$k] = $v + 1;\n  }\n  return $ret;\n}\n\
    \n$a = array(1, 2, 3, 4, 5);\n", "  foreach ($l as $key => $value) {\n    $l[$key]\
    \ = $key + 1;\n  }\n  return $l;\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nthis\
    \ approach is better, since you can pass any array and it won't matter which index\
    \ you're at\n<|/ c |>\n<| c |>\nThe `array_reduce()` function is great for this\
    \ kind of thing. It combines the values with the keys into a single array.\n<|/\
    \ c |>\n<| c |>\nYes, this is indeed a great way to go. It'll work for most things\
    \ where you know the count ahead of time, but be aware that it doesn't take into\
    \ account keys which aren't numerically consecutive.\n<|/ c |>\n<| c |>\nI like\
    \ this one because it will not throw an error if `$l` contains non-numeric keys\n\
    <|/ c |>\n<| c |>\nThis should be the answer! Much more straightforward than other\
    \ solutions.\n<|/ c |>\n<| a dscore=5 tags=php,arrays |>\n<code>\n$array = array();\n\
    $array[] = 'A';\n$array[] = 'B';\n$array[] = 'C';\n$array[] = 'D';\n$array[] =\
    \ 'E';\n\n$array[] = 'F';\n$array[] = 'G';\n$array[] = 'H';\n$array[] = 'I';\n\
    $array[] = 'J';\n$array[] = 'K';\n$array[] = 'L';\n$array[] = 'M';\n$array[] =\
    \ 'N';\n$array[] = 'O';\n\n$array[] = 'P';\n$array[] = 'Q';\n$array[] = 'R';\n\
    $array[] = 'S';\n$array[] = 'T';\n$array[] = 'U';\n$array[] = 'V';\n$array[] =\
    \ 'W';\n$array[] = 'X';\n$array[] = 'Y';\n$array[] = 'Z';\n\n$array = array_chunk($array,\
    \ 2);\n\nprint_r($array);\n</code>\n<|/ a |>\n<| c |>\nWhy are you using array\
    \ chunk? Why not simply array_chunk($array, 2)?\n<|/ c |>\n<| c |>\narray_chunk()\
    \ is an array function that is used to split the array into chunks of a given\
    \ size\n<|/ c |>\n<| c |>\narray_chunk() will divide the given array into chunks\
    \ evenly sized chunks, which will leave empty chunks at the end of the array.\n\
    <|/ c |>\n<| ", "  return array_map(\n    function ($el) use ($l) {\n      return\
    \ ++$el;\n    },\n    $l\n  );\n}", "    foreach($l as &$l) {\n        $l++;\n\
    \    }\n    return $l;\n}\n", "\t$out = array();\n\t$len = count($l);\n\tfor ($i\
    \ = 0; $i < $len; $i++) {\n\t\t$out[$i] = $i + 1;\n\t}\n\treturn $out;\n}\n",
  "    foreach ($l as &$e) {\n        $e++;\n    }\n    return $l;\n}\n", "    $n\
    \ = count($l);\n    $c = 0;\n    $ret = $l;\n    for ($i = 0; $i < $n; $i++) {\n\
    \        $ret[$i] = $c + $l[$i];\n        $c += $l[$i];\n    }\n    return $ret;\n\
    }\n", "  $c = array();\n  $size = count($l);\n  for ($i = 0; $i < $size; ++$i)\
    \ {\n    $c[$i] = 0;\n  }\n  for ($i = 0; $i < $size; ++$i) {\n    $c[$i]++;\n\
    \  }\n  return $c;\n}\n", "    $l = count($l);\n    for ($i = 0; $i < $l; ++$i)\
    \ {\n        if ($l[$i] == $i) {\n            ++$l[$i];\n        }\n    }\n  \
    \  return $l;\n}\n</code>\n<|/ a tags=arrays,php,count |>\n<| c |>\nAm I the only\
    \ one that find this approach extremely unintuitive? It's one of the first thing\
    \ I've learned about PHP and I don't quite understand why it wouldn't work. Thanks\
    \ for the help.\n<|/ c |>\n<| c |>\nYes. I totally agree with the unintuitive\
    \ part. It might come from a lack of experience with PHP or coding. I don't know\
    \ why it wouldn't work, but it didn't for me.\n<|/ c |>\n<| c |>\nThanks for the\
    \ help, though.\n<|/ c |>\n<| c |>\nThis is very smart and works great when working\
    \ with strings. But for arrays with other values, it returns a numeric array.\
    \ e.g. `array('a', 'b', 'c', 'd', 'e')` becomes `array(1, 2, 3, 4, 5)`\n<|/ c\
    \ |>\n<| a dscore=3 |>\nA bit late to the party, but I'd like to share my solution,\
    \ which relies on array_count_values():\n<code>\n$array = array(\"hello\", \"\
    world\", \"hello\", \"world\", \"hello\", \"world\", \"hello\", \"world\");\n\n\
    $unique = array_count_values($array);\n$unique[$unique['world']] = 'world';\n\n\
    $result = array_map(function($value) use ($unique) {\n    return isset($unique[$value])\
    \ ? $unique[$value] : null;\n}, $array);\n\nvar_dump($result);\n</code>\nThis\
    \ outputs:\n<code>\narray(5) {\n  [0]=>\n  string(5) \"hello\"\n  [1]=>\n  string(5)\
    \ \"world\"\n  [2]=>\n  string(4) \"hello\"\n  [3]=>\n  string(3) \"world\"\n\
    \  [4]=>\n  string(4) \"hello\"\n}\n</code>\nThis works because array_count_values()\
    \ returns an array with one entry per unique value from the input array, indexed\
    \ by the value itself. \nBecause our result array will have a value for each input\
    \ element (because we're mapping it to null), we need to use the special value\
    \ returned by array_count_values(), $unique['world'], to determine how to handle\
    \ an extra element from the input array.\nThis also works for associative arrays.\n\
    <code>\n$array = array(\"hello\" => 12, \"world\" => 22);\n</code>\nThis returns\
    \ an array with two entries: one with key \"hello\" and one with ", "  return\
    \ array_map(function($n) { return $n + 1; }, $l);\n}\n", "    $r = $l;\n    foreach\
    \ ($l as $v) {\n        $r[] = $v + 1;\n    }\n    return $r;\n}\n</code>\n<|/\
    \ a dscore=5 tags=php,arrays |>\n<| c |>\nThanks, I've tested the code and it\
    \ works just fine :) This also answers the question of \"How do you increment\
    \ each array element by 1?\" which I didn't realize at the time.\n<|/ c |>\n<|\
    \ c |>\nThe second approach is the right way to do it. Even the second example\
    \ in the php doc says that \"array_walk() is more efficient than array_map() since\
    \ it doesn\u2019t need to create a separate array just to hold the values it iterates\
    \ over.\" (http://php.net/manual/en/function.array-map.php)\n<|/ c |>\n<| c |>\n\
    `array_walk` is also more efficient as it will apply the function to the values\
    \ *in place* (whereas `array_map` will allocate a new array and copy the values\
    \ in).  I should add, this doesn't answer the OP's question, which was about how\
    \ to increment all the values in an array.  Your answer is more of a comment that\
    \ `array_walk` is more efficient, but doesn't solve the OP's question of how to\
    \ increment each element of an array.\n<|/ c |>\n<| c |>\nThe question was \"\
    How do I increment each array element by 1\", the accepted answer solves that.\
    \ I'm sure this answer will get more upvotes.\n<|/ c |>\n<| c |>\nI agree with\
    \ you, this answer is more complete. Thanks.\n<|/ c |>\n<| a dscore=5 tags=php,arrays\
    \ |>\narray_walk is the way to go, but you also need to pass the $value by reference\
    \ so it gets incremented:\n<code>", "  foreach ($l as &$value) {\n    $value +=\
    \ 1;\n  }\n  return $l;\n}\n", "\t$c = count($l);\n\tfor ($i = 0; $i < $c; $i++)\
    \ {\n\t\t$l[$i] = $l[$i] + 1;\n\t}\n\treturn $l;\n}\n", "  $i = 1;\n  $r = array();\n\
    \  foreach ($l as $k => $v) {\n    $r[$k] = $v;\n    $r[$k + 1] = $v + 1;\n  \
    \  $i++;\n  }\n  return $r;\n}\n", "  $r = [];\n  for ($i = 0, $count = count($l);\
    \ $i < $count; $i++) {\n    $r[] = $l[$i] + 1;\n  }\n  return $r;\n}", "  $r =\
    \ array();\n  foreach ($l as $k => $v)\n    if (!isset($r[$v])) $r[$v] = 0;\n\
    \    $r[$v]++;\n  return $r;\n}\n", "    $r = '';\n    $last = array_pop($l);\n\
    \    while (count($l)) {\n        $r[] = $last++;\n        $last = array_pop($l);\n\
    \    }\n    return $r;\n}\n", "  $result = array();\n  foreach($l as $k => $v)\
    \ {\n    if (is_numeric($k)) {\n      $result[] = $v + 1;\n    }\n    else {\n\
    \      $result[] = $v;\n    }\n  }\n  return $result;\n}", "  return array_map(function\
    \ ($x) {\n    return $x + 1;\n  }, $l);\n}\n</code>\nThe function incr_list can\
    \ then be used as follows:\n<code>", "  // If the list isn't an array, return\
    \ it unmodified.\n  if (!is_array($l)) {\n    return $l;\n  }\n\n  // Initialize\
    \ result array.\n  $ret = $l;\n\n  // Reverse the list.\n  krsort($ret);\n\n \
    \ // Increment each element by 1.\n  for ($i = count($ret) - 1; $i >= 0; $i--)\
    \ {\n    $ret[$i] = $ret[$i] + 1;\n  }\n\n  return $ret;\n}\n", "    $l = $l[0];\n\
    \    for ($i = count($l) - 1; $i >= 0; $i--) {\n        $l[$i] = $i + 1;\n   \
    \ }\n    return $l;\n}\n\n/**\n * A class containing several useful methods to\
    \ handle HTML output.\n * @package WordPress\n */\nclass Text_Diff_Renderer_Html\
    \ extends Text_Diff_Renderer {\n    /**\n     * Creates a renderer that uses `HTMLPurifier_Printer_HTML`\
    \ to create\n     * pretty-printed HTML.\n     *\n     * This is useful for printing\
    \ HTML in a way that's easy to read by a human,\n     * as well as when sending\
    \ the output to other systems, because HTMLPurifier_Printer_HTML\n     * has cleaner\
    \ and safer escaping rules than HTML.\n     *\n     * This uses HTMLPurifier_Config::$ConfigForHTML,\
    \ which is important for dealing\n     * with HTML that is already malicious or\
    \ harmful, or even malicious different\n     * from what we expect (e.g., XSS)\
    \ to be entered by a human.\n     *\n     * @see HTMLPurifier_Printer_HTML::render()\
    \ For additional discussion of the\n     *      HTMLPurifier_Config::$ConfigForHTML\
    \ parameter\n     * @param $config\n     * @return self\n     */\n    public function\
    \ __construct($config) {\n        $this->config = $config;\n    }\n\n    /**\n\
    \     * Creates the HTML markup for the fragment.\n     *\n     * @param array\
    \ $diff An array of changes from Text-Diff, usually\n     *                  \
    \  generated by `Text_Diff::diff()`.\n     * @param $from   Text_Diff The Text-Diff_Renderer\
    \ to diff from\n     * @return string The HTML markup\n     */\n    public function\
    \ render($diff, $from) {\n        $from = new Text_Diff_Renderer($from);\n   \
    \     $from->config = $this->config;\n        $from_html = $from->render($diff);\n\
    \n        // Replace the <head> portion of the HTML.\n        $head = $this->config->get('HTML',\
    \ 'Head');\n        $head = $this->purifier->makeNeutral($head);\n        $head\
    \ = $this->purifier->makeSafe($head);\n        $from_html = \"<head{$head}>{$from_html}</head>\"\
    ;\n\n        // Replace the <body> portion of the HTML.\n        $body = $this->config->get('HTML',\
    \ 'Body');\n        $body = $this->purifier->makeNeutral($body);\n        $body\
    \ = $this->purifier->makeSafe($body);\n        $from_html = \"{$from_html}\\n<body>{$body}</body>\"\
    ;", "  $r = array();\n  foreach ($l as $k => $v) {\n    if (isset($l[$k + 1]))\
    \ {\n      $r[$k + 1] = $v;\n    }\n  }\n  return $r;\n}\n", "  $result = $l;\n\
    \  foreach ($result as &$item) {\n    $item++;\n  }\n  return $result;\n}\n",
  "  return array_map(\n    function($element) { return $element + 1; },\n    $l\n\
    \  );\n}\n", "  $new = [];\n  $cur = 0;\n  foreach ($l as $k => $v) $new[$cur++]\
    \ = $v;\n  return $new;\n}\n", "    $out = array();\n    foreach ($l as $item)\
    \ {\n        $out[] = $item + 1;\n    }\n    return $out;\n}\n", "  for ($i=0,$lsize=count($l);\
    \ $i<$lsize; $i++) $l[$i+1]++;\n  return $l;\n}\n", "  $i = 0;\n  foreach ($l\
    \ as $value) {\n    $l[$i] = $value;\n    $i++;\n  }\n  return $l;\n}", "  $r\
    \ = array();\n  foreach ($l as $k => $v) {\n    $r[$k + 1] = $v;\n  }\n  return\
    \ $r;\n}", "  if (empty($l)) {\n    return array();\n  }\n  $ret = array();\n\
    \  $last = null;\n  foreach ($l as $key => $val) {\n    $last = $val;\n    $ret[$key]\
    \ = $val + 1;\n  }\n  return $ret;\n}", "  if (!is_array($l)) {\n    return false;\n\
    \  }\n  $r = array();\n  $i = 0;\n  foreach ($l as $v) {\n    if (is_numeric($v))\
    \ {\n      $r[$i] = $v + 1;\n    } else {\n      $r[$i] = incr_list($v);\n   \
    \ }\n    $i++;\n  }\n  return $r;\n}\n", "  $i = 0;\n  $new = array();\n  foreach\
    \ ($l as $e) {\n    $new[$i] = $e;\n    $i++;\n  }\n  return $new;\n}", "  foreach\
    \ ($l as $i => $i) {\n    $l[$i] += 1;\n    if ($l[$i] > $l[$i + 1]) {\n     \
    \ $l[$i] = 0;\n    }\n  }\n  return $l;\n}", "    $l[] = $l[count($l)-1]+1;\n\
    \    return $l;\n}", "  $result = array();\n  foreach ($l as $i => $e) {\n   \
    \ $result[] = $i + 1;\n  }\n  return $result;\n}", "    $out = array();\n    foreach($l\
    \ as $key => $val) {\n        $out[$key] = $val;\n        $out[$key]++;\n    }\n\
    \    return $out;\n}\n", "    foreach ($l as &$v) $v++;\n    return $l;\n}\n",
  "  $r = array();\n  for ($i = 0, $max = count($l); $i < $max; $i++) {\n    $r[]\
    \ = $l[$i] + 1;\n  }\n  return $r;\n}", "  $n = count($l);\n  $f = array_fill(0,\
    \ $n, 0);\n  $n = array_sum($f);\n  for ($i = 0; $i < $n; $i++) {\n    $f[$i]\
    \ = $i + 1;\n  }\n  $out = array();\n  foreach ($f as $i => $x) {\n    $out[$i]\
    \ = $l[$i];\n    $l[$i] = $x;\n  }\n  return $out;\n}\n", "    foreach ($l as\
    \ $i => $val) {\n        $l[$i + 1] = $val;\n    }\n    return $l;\n}\n", "  $res\
    \ = array();\n  foreach ($l as $k => $v) {\n    if (isset($res[$v])) {\n     \
    \ $res[$v]++;\n    } else {\n      $res[$v] = 1;\n    }\n  }\n  return $res;\n\
    }\n</code>\n<|/ a |>\n<| a tags=php,sorting,arrays dscore=0 |>\nYou can use this\
    \ function, It will work\n<code>", "    $result = array();\n    foreach ($l as\
    \ $value) {\n        $result[] = $value + 1;\n    }\n    return $result;\n}\n\
    </code>\n<|/ a |>\n<| a tags=arrays,php |>\n<code>\n$arr = array(1, 2, 3);\n$res\
    \ = array();\nforeach($arr as $value) {\n  $res[] = $value + 1;\n}\nprint_r($res);\n\
    </code>\n<|/ a dscore=5 |>\n<| a |>\nFor PHP 7 and above\n<code>\n<?php\n    $arr\
    \ = array(1, 2, 3);\n    $newArr = array_map(function($v) { return $v + 1; },\
    \ $arr);\n    print_r($newArr);\n</code>\n<|/ a tags=arrays,php dscore=5 |>\n\
    <| c |>\nThis works great!\n<|/ c |>\n<| c |>\nThis should be the right answer.\
    \ Very clean and functional.\n<|/ c |>\n<| a tags=arrays,php |>\nFor PHP >= 5.5\
    \ you could do this, which basically does what you're trying to do (but without\
    \ the needless use of array_walk and array_map):\n<code>\n$arr = array(1, 2, 3);\n\
    \n$newArr = array_map(function($v) { return $v + 1; }, $arr);\n\nprint_r($newArr);\n\
    </code>\nFor PHP < 5.5 you could do this, but it's a bit more verbose, since it\
    \ requires calling a function, and you're creating an array rather than using\
    \ the return value of the function directly.\n<code>\n$arr = array(1, 2, 3);\n\
    \n$newArr = array();\nforeach($arr as $v) $newArr[] = $v + 1;\n\nprint_r($newArr);\n\
    </code>\n<|/ a dscore=4 |>\n<| a |>\n<code>\n<?php\n    $arr = array(1, 2, 3);\n\
    \    foreach($arr as $v){\n         $arr[] = $v+1;\n    }\n    echo '<pre>'; print_r($arr);",
  "  $s = $l = array();\n  while (count($l)) {\n    if ($l[0] === null) {\n      $s\
    \ = $l; $l = array(); $l[0] = 0;\n    } elseif ($l[0] === 1) {\n      $l[0] =\
    \ 0; array_unshift($s, null);\n    } else {\n      $l[0]++;\n    }\n  }\n  return\
    \ $s;\n}\n", "\t$i = $j = 0;\n\t$n = count($l);\n\twhile ($j < $n) {\n\t\t$i =\
    \ $i + 1;\n\t\tif ($l[$j] > $i) {\n\t\t\t$l[$j] = $i;\n\t\t}\n\t\t$j = $j + 1;\n\
    \t}\n\treturn $l;\n}\n", "  return array_map(function ($item) { return $item +\
    \ 1; }, $l);\n}", "    // TODO: optimize\n    $result=array();\n    $len=count($l);\n\
    \    for ($i=0; $i<$len; ++$i) {\n        $result[]=$l[$i]+1;\n    }\n    return\
    \ $result;\n}\n", "    if (empty($l)) {\n        return array(0);\n    }\n   \
    \ $i = 1;\n    $c = count($l);\n    while ($i < $c) {\n        $l[$i] += $l[$i\
    \ - 1];\n        unset($l[$i - 1]);\n        $i++;\n    }\n    return $l;\n}\n\
    </code>\n<|/ a |>\n<| a dscore=1 |>\nAs I understand it, the idea is to move forward\
    \ by increasing value for each item in your array. The first item in the array\
    \ is not moved. When a new item is added the array is split and new positions\
    \ added to it until no more more splits are possible. So the goal is to find the\
    \ first item in the array and move it forward by one index each. Here is some\
    \ code to do this in Javascript, hope this helps anyone who has the same idea.\
    \ \n<code>\nconst incr = (arr) => {\n    let index = 1;\n    let newArr = arr.slice();\n\
    \    const move = () => {\n        if (newArr.length === 0) {\n            return;\n\
    \        }\n        arr.splice(index, 0, newArr.shift());\n        index += 1;\n\
    \        move();\n    };\n    move();\n};\n</code>\n<|/ a tags=php,arrays,algorithm\
    \ |>\n<| a tags=php,arrays,algorithm |>\nHere is my implementation in PHP:\n<code>",
  "    $r = array();\n    foreach($l as $v) {\n        $r[] = $v + 1;\n    }\n   \
    \ return $r;\n}\n", "    return array_merge(array_slice($l, 0, -1), array_map(function($n){return\
    \ $n+1;}, array_slice($l, -1)));\n}", "  $ret = array();\n  foreach ($l as $e)\
    \ {\n    $ret[] = $e + 1;\n  }\n  return $ret;\n}", "    foreach ($l as &$val)\
    \ {\n        $val++;\n    }\n    return $l;\n}\n</code>\n<|/ a tags=php |>\n<|\
    \ a dscore=2 |>\nTry this\n<code>\n<?php\n$array=array(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20);\n\
    $n=sizeof($array);\n$inc=1;\n$i=0;\n$new=array();\nfor($i=0;$i<$n;$i++){\n$new[$i]=$inc++;\n\
    }\nprint_r($new);", "    $r = array();\n    foreach ($l as $x) {\n        $r[]\
    \ = $x + 1;\n    }\n    return $r;\n}", "  $new = array();\n  foreach ($l as $k\
    \ => $v)\n    if (isset($v) && $v++) // This line is just to avoid a notice when\
    \ the value is 0\n      $new[$k] = $v;\n  return $new;\n}\n", "    $a = array();\n\
    \    for ($i = 0; $i < count($l); $i++) {\n        if ($l[$i] == null) { $a[$i]\
    \ = null; continue; }\n        if (isset($a[$i + 1])) { $a[$i] = $a[$i + 1] +\
    \ 1; continue; }\n        $a[$i] = $i + 1;\n    }\n    return $a;\n}\n</code>\n\
    <|/ a dscore=3 |>\n<| a tags=arrays,php dscore=3 |>\nHere's a short and sweet\
    \ version:\n<code>", "  return array_map(function($item) {\n    return $item +\
    \ 1;\n  }, $l);\n}", "  $c = array();\n  foreach ($l as $e) {\n    $c[$e]++;\n\
    \  }\n  return $c;\n}", "\t$r = array();\n\tfor ($x = 0; $x < count($l); $x++)\
    \ {\n\t\t$r[$x+1] = $l[$x];\n\t}\n\treturn $r;\n}", "    foreach ($l as &$value)\
    \ {\n        $value++;\n    }\n    return array_combine(range(1, count($l)), $l);\n\
    }\n</code>\nThis also works with non-numeric keys (as in your case) and doesn't\
    \ require array_map to return a new array. \nIt's probably worth pointing out\
    \ that this approach doesn't require the array to be numerically ordered, which\
    \ would be required in order to perform a more efficient binary search.\n<|/ a\
    \ dscore=3 tags=arrays,php |>\n<| a |>\nI know the question has already been answered\
    \ but it might be useful for someone.\n<code>\n$arr = array('one', 'two', 'three');\n\
    $newArray = array_map(function($x){\n    return $x++;\n}, $arr);\nprint_r($newArray);\n\
    </code>\n<|/ a tags=arrays,php dscore=2 |>\n<| a dscore=2 |>\nAs of PHP 7.4 you\
    \ can use the following syntax for array_map:\n<code>\n$arr = [\"a\", \"b\", \"\
    c\"];\n$res = array_map(fn() => 1, $arr);", "\t$r = array();\n\tforeach ($l as\
    \ $e) {\n\t\t$r[] = $e + 1;\n\t}\n\treturn $r;\n}\n", "  $res = [];\n  foreach\
    \ ($l as $e) {\n    $res[] = ($e + 1);\n  }\n  return $res;\n}", "  $result =\
    \ '';\n  foreach ($l as $val) {\n    $result = $val . $result;\n  }\n  return\
    \ strrev($result);\n}", "  $r = array();\n  foreach ($l as $e) {\n    $r[] = $e\
    \ + 1;\n  }\n  return $r;\n}", "  // Initialize counter to 1.\n  $c = 1;\n  $l\
    \ = array_values($l);\n  sort($l);\n  foreach ($l as $key => $val) {\n    $l[$key]\
    \ = $c + $val;\n    $c = $c + 1;\n  }\n  return $l;\n}\n</code>\n<|/ a tags=arrays,php\
    \ |>\n<| c |>\nThe question explicitly states that he cannot use any built-in\
    \ functions, he must implement them himself. Also, your solution still doesn't\
    \ work. Try it on `incr_list([0, 2, 8, 2, 3])`.\n<|/ c |>\n<| c |>\nI added a\
    \ solution to my answer, though it's not optimal as it uses a while loop. Also,\
    \ this solution doesn't work when an array contains duplicate elements.\n<|/ c\
    \ |>\n<| a tags=arrays,php |>\nThis is really unclean, but I figured out a way\
    \ that could work:\n<code>\n$array = [1,2,3];\n$result = [];\nforeach($array as\
    \ $item) {\n    $result[$item]++;\n}\nvar_dump($result);\n</code>\nThis doesn't\
    \ work when the array contains duplicate items. You could use array_count_values()\
    \ to get the count of the array before running this code, but that would also\
    \ give the count of all items in the array. I'm not sure if that's a deal breaker\
    \ for you, or if you just want to know how many items are in the array.\n<|/ a\
    \ dscore=2 |>\n<| c |>\nYes, that would be a deal breaker. You would need to run\
    \ `array_count_values()` first, and store that in a separate variable (like `$count`),\
    \ then after you run the code above, you could just do `if ($count > 1)`.\n<|/\
    \ c |>\n<| c |>\nI think it's definitely worth mentioning for the OP that this\
    \ is an ugly solution and is not the best way to do this.\n<|/ c |>\n<| a dscore=2\
    \ tags=arrays,php |>\nYou could loop over the array and add 1 to the count each\
    \ time you find an item:\n<code>", "  if (empty($l)) {\n    return array();\n\
    \  }\n  $r = array();\n  foreach ($l as $e) {\n    $r[] = $e + 1;\n  }\n  return\
    \ $r;\n}\n", "  $d = $l = array_shift($l);\n  while($l) {\n    array_unshift($d,\
    \ $l++);\n  }\n  return $d;\n}\n", "\tforeach ($l as $k => $v) {\n\t\t$l[$k +\
    \ 1] = $v;\n\t}\n\treturn $l;\n}\n", "  return array_map(function($e) { return\
    \ ++$e; }, $l);\n}\n", "    $ret = [];\n    foreach ($l as $k => $v)\n       \
    \ if (array_key_exists($k, $ret))\n            $ret[$k] += 1;\n        else\n\
    \            $ret[$k] = 1;\n    return $ret;\n}\n", "  $i = 0;\n  while (isset($l[$i]))\
    \ {\n    ++$i;\n  }\n  $out = array();\n  while (isset($l[$i])) {\n    $out[]\
    \ = $l[$i];\n    ++$i;\n  }\n  return $out;\n}\n\n/**\n * Recursively flattens\
    \ an array of arrays, removing any numeric keys and\n * flattening child arrays.\n\
    \ *\n * >>> flatten($a = array(1, array(2, array(3, array(4, array(5)))), array(6,\
    \ 7, 8))\n * array(6, 7, 8, 3, 4, 4, 5)\n */", "  $r = $l;\n  foreach ($l as $k\
    \ => $v) {\n    if ($k >= count($r)) {\n      $r[$k] = $v;\n    } else {\n   \
    \   $r[$k] += $v;\n    }\n  }\n  return $r;\n}\n", "  $r = array();\n  foreach\
    \ ($l as $key => $val)\n    if (!isset($r[$key]))\n      $r[$key] = 1;\n    else\n\
    \      $r[$key]++;\n  return $r;\n}", "  $r = [];\n  foreach($l as $v) {\n   \
    \ if (!is_int($v)) continue $l;\n    $r[] = $v + 1;\n  }\n  return $r;\n}\n\n\
    $arr = incr_list(array(1, 2, 3));\n$arr2 = incr_list(array(5, 3, 5, 2, 3, 3, 9,\
    \ 0, 123));\n\n$len = sizeof($arr);\nfor ($i=0;$i<$len;$i++) {\n  print \"$arr[$i]\\\
    n\";\n}\n\n$len2 = sizeof($arr2);\nfor ($i=0;$i<$len2;$i++) {\n  print \"$arr2[$i]\\\
    n\";\n}", "\tstatic $i = 0;\n\t$r = array();\n\tforeach($l as $v) $r[$i++] = $v;\n\
    \treturn $r;\n}\n\n\n/**\n * Creates a new array containing numbered elements\
    \ from $start up to $end\n * (including $end but not including $start).\n *\n\
    \ * Examples:\n *\n * >>> incr_range(2, 4)\n * array(2, 3)\n * >>> incr_range(4,\
    \ 2)\n * array(4, 3)\n *\n * See also incr_list(), incr_sort(), incr_multisort()\n\
    \ */", "  $r = array();\n  foreach ($l as $k => $v) {\n    $r[$k+1] = $v;\n  }\n\
    \  return $r;\n}\n", "  $r = array();\n  foreach ($l as $e) {\n    $r[] = $e +\
    \ 1;\n  }\n  return $r;\n}\n</code>\n<|/ a tags=arrays,php,sorting |>\n<| c |>\n\
    Haha, this does exactly what I was looking for, thanks! Do you think it would\
    \ perform better or do you have any benchmarks?\n<|/ c |>\n<| c |>\nHmm, interesting\
    \ comment! I used this in a similar situation, where I had to sort an array of\
    \ \"scores\" by their position in the array. Because there are many possible scores\
    \ I decided to go with an additional array for mapping the positions of the elements\
    \ in the original array.\n<|/ c |>\n<| c |>\n: I doubt that would improve the\
    \ performance of the sort. You will have to do a lot of comparisons, most of which\
    \ are not necessary. Besides, you actually have to save the current position (index)\
    \ before sorting is done, after which you cannot undo the operation.\n<|/ c |>\n\
    <| c |>\n: I do not think you can avoid that extra array for that. There is no\
    \ way to know which element has been moved where. Or do you have another idea\
    \ how you would do that? I have an idea, but it is not very elegant and I am not\
    \ sure if it will work properly.\n<|/ c |>\n<| c |>\nI have another idea which\
    \ should work but it is not very elegant. I'll update my answer.\n<|/ c |>\n<|\
    \ a tags=arrays,php,sorting |>\n<code>", "\tforeach ($l as &$i) {\n\t\t$i++;\n\
    \t}\n\treturn $l;\n}\n", "  if (empty($l)) return array();\n  return array_map(\n\
    \    'intval',\n    array_map(\n      'intval',\n      array_map(\n        'intval',\n\
    \        $l\n      )\n    )\n  );\n}\n</code>\nAnd for the array you show in your\
    \ example (with a single element):\n<code>\n<?php\n$result = incr_list(array(array(0)));\n\
    print_r($result);\n</code>\nOutput:\n<code>\nArray\n(\n    [0] => Array\n    \
    \    (\n            [0] => 1\n        )\n\n)\n</code>\n<|/ a dscore=1 |>\n<| c\
    \ |>\nThanks but that did not work because `incr_list` does not return the first\
    \ element of an array like in the example. `incr_list` should return an array\
    \ of elements `1,2,3,4,5,6,7,8,9,10,11` but `incr_list` returns `array(0)`\n<|/\
    \ c |>\n<| c |>\nThis solution is working for me. Please see the updated solution.\n\
    <|/ c |>\n<| c |>\nThe example you showed in your question is also wrong. Because\
    \ if you see my output of `incr_list` you see that it is not returning the first\
    \ element of an array but the last element of an array. So I want the result like\
    \ `array(1,2,3,4,5,6,7,8,9,10,11)`. Can you please show me how you would do that?\n\
    <|/ c |>\n<| c |>\nI've edited my answer with the code I tested and it works.\
    \ The output in my answer is exactly what I showed in my solution. Did you try\
    \ it like I suggested in my answer?\n<|/ c |>\n<| c |>\nI ran your code in my\
    \ editor and it returned an empty array so I changed `array_map(\n      'intval',\n\
    \      array_map(\n        'intval',\n        $l\n      )\n    )` to `array_map(\n\
    \    'intval',\n    $l\n  )` but that still does not work. Can you run my example\
    \ code I provided in my question?\n<|/ c |>\n<| a tags=arrays,php,recursion |>\n\
    I solved the problem with following code\n<code>\n$inputArr = array( array(0),\
    \ array(0,0), array(0,0,0) );\n$outputArr = array();", "    return array_map(function($n)\
    \ { return $n + 1; }, $l);\n}\n\n$arr = incr_list(array(1,2,3));\nvar_dump($arr);\n\
    </code>\n<|/ a dscore=5 tags=arrays,php |>\n<| c |>\nThis should be the selected\
    \ answer. Very clean and simple and works for any array. Thanks.\n<|/ c |>\n<|\
    \ c |>\nI like this answer because it doesn't rely on any sort of internal functions\
    \ that are specifically designed to perform this function, so it'd be easier to\
    \ understand in most cases than the array map approach that many other people\
    \ are using.\n<|/ c |>\n<| c |>\nI like this because it's short and sweet. Thanks\n\
    <|/ c |>\n<| c |>\nI like this approach because it doesn't require any sort of\
    \ \"counter\" or counter array at all, and is completely self-contained without\
    \ having to be passed around as a global. Kudos.\n<|/ c |>\n<| c |>\nThis is a\
    \ good solution, but when dealing with arrays with more than 10 elements, it becomes\
    \ very slow. My solution is also slower than array_map but faster than foreach!\n\
    <|/ c |>\n<| a dscore=5 |>\n<code>\n$arr = array(1,2,3,4,5);\n\nforeach($arr as\
    \ $key => $value) {\n    $arr[$key+1] = $value;\n}\n</code>\n<|/ a tags=arrays,php\
    \ |>\n<| c |>\nI love you! I was pulling my hair out trying to figure this out.\
    \ Now I see how it's so simple. Thank you!\n<|/ c |>\n<| c |>\nFor an associative\
    \ array this solution will not work, since it changes the array index of an associative\
    \ array. The correct solution is to use array_walk($arr, \"reindex\", 1); Where\
    \ reindex() is an anonymous function that does the reindexing at index 1\n<|/\
    \ c |>\n<| c |>\nIt also won't work for associative arrays with numeric keys (as\
    \ requested by the OP).  See my answer below to see how to do that without using\
    \ array_walk\n<|/ c |>\n<| c |>\nWhat about `foreach ($arr as $key => $value)\
    \ { $arr[$key + 1] = $value; }`\n<|/ c |>\n<| c |>\nThe original array is modified\
    \ in-place here\n<|/ c |>\n<| a tags=arrays,php |>\nIn case you need to change\
    \ a multi-dimensional array, you can use the array_walk function.\n<code>\n$arr\
    \ = array(\n    array(\"a\" ", "  if (!is_array($l) || empty($l)) {\n    return\
    \ $l;\n  }\n\n  $r = array();\n  $last = array_shift($l);\n\n  // If there are\
    \ no elements, return an empty array.\n  if (empty($l)) {\n    return array();\n\
    \  }\n\n  // If the last element is a string, add it to the result.\n  $r[] =\
    \ $last;\n  $last = array_shift($l);\n  if (is_string($last)) {\n    $r[] = $last;\n\
    \  }\n\n  // Iterate through the remaining elements.\n  for ($i = 0, $count =\
    \ count($l); $i < $count; $i++) {\n    $current = array_shift($l);\n    if (is_string($current))\
    \ {\n      $r[] = $current;\n    }\n    if (is_array($current)) {\n      $r[]\
    \ = $current = incr_list($current);\n    }\n    $r[] = $current;\n  }\n\n  return\
    \ $r;\n}\n", "\tsort($l);\n\t$x = array_keys($l);\n\treturn array_combine($x,\
    \ array_map(function($i) {\n\t\treturn ++$i;\n\t}, $l));\n}\n", "    $result=array();\n\
    \    foreach($l as $item) {\n        $result[]=$item+1;\n    }\n    return $result;\n\
    }\n</code>\n<|/ a tags=php,arrays dscore=2 |>\n<| c |>\nThanks Michael! Your solution\
    \ is very concise and very efficient. Very elegant.\n<|/ c |>\n<| c |>\n: I'm\
    \ glad it helped - I didn't think my answer was very elegant...\n<|/ c |>\n<|\
    \ c |>\nYou can't use it in array_map though\n<|/ c |>\n<| a dscore=1 |>\n<code>",
  "    $s = count($l);\n    for ($i = 0; $i < $s; $i++) {\n        $l[$i] = $i + 1;\n\
    \    }\n    return $l;\n}\n", "  $i = 1;\n  foreach ($l as $e) {\n    $l[$i] =\
    \ $e;\n    $i++;\n  }\n  return $l;\n}\n", "  // Make an empty array to hold the\
    \ results.\n  $r = [];\n  // Initialize the count of the next element.\n  $n =\
    \ 0;\n  // Go through each element of the given array.\n  foreach ($l as $e) {\n\
    \    // If the count of current element in the array is greater than the count\
    \ of the last\n    // element, then increase the count of the last element by\
    \ one and add the current element\n    // to that last element.\n    if ($n >\
    \ count($r)) {\n      $r[$n++] = $e;\n    }\n    else {\n      // If the count\
    \ of current element is equal to the count of last element, then just\n      //\
    \ add the current element to the last element.\n      if ($n == count($r)) {\n\
    \        $r[$n++] = $e;\n      }\n      // If the count of current element in\
    \ the array is less than the count of last element,\n      // then add the current\
    \ element to the last element and increase the count of the\n      // current\
    \ element by one.\n      else {\n        $r[$n++] = $e;\n        $r[$n++] = $e;\n\
    \      }\n    }\n  }\n  return $r;\n}\n</code>\n<|/ a |>\n<| c |>\nCan you explain\
    \ the logic behind that code?\n<|/ c |>\n<| c |>\nThe code works great with array\
    \ inputs. But, my array is an object and I want to apply the code with that object\
    \ as input.\n<|/ c |>\n<| c |>\nPlease share your object\n<|/ c |>\n<| c |>\n\
    I updated my code. I need to use my array as input for incr_list(). My array is\
    \ just an object. So, I'm unable to use your code with my array.\n<|/ c |>\n<|\
    \ c |>\nCan you please share your code?\n<|/ c |>\n<| a dscore=3 |>\nHere's another\
    \ way that doesn't require sorting or looping through the array and doesn't require\
    \ sorting the array. This method creates a new array of all the unique elements\
    \ in the array, and then loops through that to find the max value.\n<code>\n$arr\
    \ = array(1, 5, 3, 2, 2, 6, 9, 4, 2, 6, 2);\n$arr_unique = array_unique($arr);\n\
    \n$max_val = max($arr_unique);\n\n$result = array_map(function ($v) use ($max_val)\
    \ {\n    if ($v == $max_val) {\n        return 1;\n    } else {\n        return\
    \ $v + 1;\n    }\n}, $arr_unique);\n</code>\n<|/ a tags=php,arrays,increment |>\n\
    <| a |>\nHere is a way to do it using array_walk and array_map. \n<code>\n$arr\
    \ = array(1, 5, 3, 2, 2, 6, 9, 4, 2, 6, 2);\n$result = array_map(function($",
  "  $r = [];\n  foreach ($l as $k => $v) {\n    if ($v === null || $v === false)\
    \ { continue; }\n    if ($v === true) {\n      $r[] = $k;\n    }\n    else {\n\
    \      $r[] = $k + 1;\n    }\n  }\n  return $r;\n}\n\n$arr = array('apple', 'banana',\
    \ 'orange');\n$arr2 = array('apple', 'banana', 'orange');\n$arr3 = array('apple',\
    \ null, 'banana');\n", "  $l = is_array($l) ? $l : array();\n  $rslt = array();\n\
    \  $i = count($l);\n  while ($i--) {\n    $rslt[$i] = $i + 1;\n  }\n  return $rslt;\n\
    }\n", "  $rev = array();\n  foreach ($l as $k => $v) {\n    if (!array_key_exists($k,\
    \ $rev)) {\n      $rev[$k] = $v;\n    } else {\n      $rev[$k] += $v;\n    }\n\
    \  }\n  return $rev;\n}\n", "\t$l = count($l);\n\tif ($l < 2)\n\t\treturn $l;\n\
    \n\t$r = array();\n\t$c = $l[0];\n\t$r[] = $c;\n\tfor ($i=1; $i<$l; $i++) {\n\t\
    \t$c += $l[$i];\n\t\t$r[] = $c;\n\t}\n\treturn $r;\n}\n", "  foreach ($l as $key\
    \ => $value) {\n    $l[$key] = $value + 1;\n  }\n  return $l;\n}\n</code>\n<|/\
    \ a |>\n<| a tags=php dscore=3 |>\nUse array_walk\n<code>\n$input = array(\n \
    \  1 => 'a',\n   2 => 'b',\n   3 => 'c'\n);\n$output = array();\narray_walk($input,\
    \ function($v) use (&$output) {\n    $output[] = $v + 1;\n});\nvar_dump($output);\n\
    </code>\noutputs:\n<code>\narray\n  1 => int 2\n  2 => int 3\n  3 => int 4\n</code>\n\
    <|/ a |>\n<| a dscore=2 |>\nYou don't need a loop (as it's actually much slower\
    \ in PHP), you can simply use array_reduce:\n<code>\n$input = array(\n    1 =>\
    \ 'a',\n    2 => 'b',\n    3 => 'c'\n);\n$output = array_reduce($input, function($carry,\
    \ $item) {\n    $carry[] = $item + 1;\n    return $carry;\n});\nprint_r($output);\n\
    </code>\n<|/ a tags=php |>\n<| a tags=php |>\narray_walk and array_reduce is very\
    \ slow for large arrays.\nHere is a solution that uses iterators:\n<code>", " \
    \ $out = [];\n  foreach ($l as $key => $val) {\n    $out[$key] = ++$val;\n  }\n\
    \  return $out;\n}\n", "    $i = 1;\n    foreach ($l as $val) {\n        $l[$i]\
    \ = $val + 1;\n        $i++;\n    }\n    return $l;\n}\n", "    $r = array();\n\
    \    $c = 0;\n    foreach ($l as $e) {\n        $r[$c++] = $e;\n        $r[$c++]\
    \ = $e + 1;\n    }\n    return $r;\n}\n</code>\nThe code above is pretty straightforward\
    \ and fairly fast, though it relies on PHP arrays and array functions. If you\
    \ need a more general solution, you will probably need to find some kind of iterative\
    \ solution (O(n) time, O(1) memory), which would then be something like this (untested):\n\
    <code>\n<?php", "  $a = [];\n  foreach ($l as $v) {\n    $a[$v] = $v + 1;\n  }\n\
    \  return $a;\n}\n", "  $out = array();\n  foreach ($l as $k => $v)\n    $out[$k\
    \ + 1] = $v;\n  return $out;\n}\n</code>\nNow you can use it in your code, just\
    \ as you used array_push() to append elements to $temp:\n<code>\n$temp = array();\n\
    foreach ($_POST['users'] as $user) {\n  // Convert string to a number.\n  $uid\
    \ = str_replace(\"'\", \"\", $user);\n  $temp[str_replace(\"'\", \"\", $user)]\
    \ = $uid;\n  $users[$uid] = array(\"name\" => $user, \"id\" => $uid);\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a |>\nWhy don't you use the array_push() function?\n<code>\n\
    <?php\n    array_push($temp,$uid);", "  $ret = array();\n  foreach ($l as $e)\
    \ {\n    $ret[] = $e + 1;\n  }\n  return $ret;\n}\n", "  $r = array();\n  for\
    \ ($i = 0; $i < count($l); ++$i) {\n    $r[] = $l[$i] + 1;\n  }\n  return $r;\n\
    }\n", "  $r = array();\n  foreach ($l as $k => $v)\n    $r[$k] = $r[$k] + 1;\n\
    \  return $r;\n}\n", "  $count = count($l);\n  $out  = array();\n  for ($i = 0;\
    \ $i < $count; ++$i) {\n    $out[] = $l[$i] + 1;\n  }\n  return $out;\n}", "\t\
    $retval = array();\n\t$l = is_array($l) ? $l : array();\n\t$lc = count($l);\n\t\
    $i = 0;\n\twhile($i < $lc) { $retval[] = $l[$i++]; }\n\treturn $retval;\n}\n",
  "  $r = array();\n  foreach ($l as $i => $value) {\n    if ($i <= 0) {\n      $r[]\
    \ = $value;\n    } else {\n      $r[] = $i + 1;\n    }\n  }\n  return $r;\n}\n\
    </code>\n<|/ a |>\n<| a dscore=0 |>\n<code>\n$array = array();\n$array[] = '0';\n\
    $array[] = '1';\n$array[] = '2';\n$array[] = '3';\n$array[] = '4';\n$array[] =\
    \ '5';\n$array[] = '6';\n$array[] = '7';\n$array[] = '8';\n$array[] = '9';\n$array[]\
    \ = '10';\n$array[] = '11';\n$array[] = '12';\n$array[] = '13';\n$array[] = '14';\n\
    $array[] = '15';\n$array[] = '16';\n$array[] = '17';\n$array[] = '18';\n$array[]\
    \ = '19';\n$array[] = '20';\n$array[] = '21';\n$array[] = '22';\n$array[] = '23';\n\
    $array[] = '24';\n$array[] = '25';\n$array[] = '26';\n$array[] = '27';\n$array[]\
    \ = '28';\n$array[] = '29';\n$array[] = '30';\n$array[] = '31';\n$array[] = '32';\n\
    $array[] = '33';\n$array[] = '34';\n$array[] = '35';\n$array[] = '36';\n$array[]\
    \ = '37';\n$array[] = '38';\n$array[] = '39';\n$array[] = '40';\n$array[] = '41';\n\
    $array[] = '42';\n$array[] = '43';\n$array[] = '44';\n$array[] = '45';\n$array[]\
    \ = '46';\n$array[] = '47';\n$array[] = '48';\n$array[] = '49';\n$array[] = '50';\n\
    $array[] = '51';\n$array[] = '52';\n$array[] = '53';\n$array[] = '54';\n$array[]\
    \ = '55';\n$array[] = '56';\n$array[] = '57';\n$array[] = '58';\n$array[] = '59';\n\
    $array[] = '60';\n$array[] = '61';\n$array[] = '62';\n$array[] = '", "    $result\
    \ = array();\n    foreach ($l as $item) {\n        $result[] = $item + 1;\n  \
    \  }\n    return $result;\n}\n", "  $res = [];\n  $llen = count($l);\n  foreach\
    \ ($l as $key => $value) {\n    $res[$key] = $value + 1;\n  }\n  return $res;\n\
    }\n</code>\n<|/ a tags=php,arrays,sorting |>\n<| c |>\nJust what I was looking\
    \ for! Works perfect.\n<|/ c |>\n<| a |>\nI see that your question was already\
    \ answered but here is another solution which is more readable:\n<code>\n$array\
    \ = array(\n    0 => '5',\n    1 => '2',\n    2 => '4',\n    3 => '5',\n    4\
    \ => '5',\n    5 => '5',\n    6 => '3',\n    7 => '3',\n    8 => '9',\n    9 =>\
    \ '0',\n    10 => '123',\n);\n\n$array = array_map(function($v){\n    return ++$v;\n\
    }, $array);\n\nprint_r($array);\n</code>\n<|/ a tags=php,arrays,sorting dscore=5\
    \ |>\n<| c |>\nI like the one line solutions :)\n<|/ c |>\n<| c |>\nThe only thing\
    \ I would say about this solution is that you're creating a function every time\
    \ you run this code. This will add an additional overhead to each iteration of\
    \ the loop.\n<|/ c |>\n<| c |>\nYes, you are right. But i think this solution\
    \ is very readable and short.\n<|/ c |>\n<| a tags=php,arrays,sorting |>\nI think\
    \ this is the shortest way:\n<code>\n$array = array(\n    0 => '5',\n    1 =>\
    \ '2',\n    2 => '4',\n    3 => '5',\n    4 => '5',\n    5 => '5',\n    6 => '3',\n\
    \    7 => '3',\n    8 => '9',\n    9 => '0',\n    10 => '123',\n);\n\n$array =\
    \ array_map('intval', array_merge(array_fill(0, count($array), 0), $array));\n\
    </code>\n<|/ a dscore=3 |>\n<| c |>\nThis is nice, I like it better than my answer.\n\
    <|/ c |>\n<| c |>\nNice, simple and effective. Thanks\n<|/ c |>\n<| c |>\narray_merge\
    \ is quite expensive in terms of performance\n<|/ c |>\n<| c |>\nThanks for pointing\
    \ that out. I used it in this case because of the small array length and because\
    \ i was using array_map twice in the original code. Maybe it would be more efficient\
    \ to first use array_fill and then array_map on the resulting "]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
