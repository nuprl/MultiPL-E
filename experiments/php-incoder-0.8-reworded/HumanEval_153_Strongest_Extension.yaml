name: HumanEval_153_Strongest_Extension
language: php
prompt: "<?php\n// You will be given the name of a class (a string) and an array of\
  \ extensions.\n// The extensions are to be used to load additional classes to the\
  \ class. The\n// strength of the extension is as follows: Let CAP be the number\
  \ of the uppercase\n// letters in the extension's name, and let SM be the number\
  \ of lowercase letters \n// in the extension's name, the strength is given by the\
  \ fraction CAP - SM. \n// You should find the strongest extension and return a string\
  \ in this \n// format: ClassName.StrongestExtensionName.\n// If there are two or\
  \ more extensions with the same strength, you should\n// choose the one that comes\
  \ first in the array.\n// For example, if you are given \"Slices\" as the class\
  \ and an array of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then\
  \ you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest\
  \ extension \n// (its strength is -1).\n// Example:\n// >>> Strongest_Extension(\"\
  my_class\", array(\"AA\", \"Be\", \"CC\"))\n// \"my_class.AA\"\nfunction Strongest_Extension($class_name,\
  \ $extensions) {\n"
tests: "function candidate(...$args) {\n    return Strongest_Extension(...$args);\n\
  }\n\nfunction test(): void {\n    if (candidate(\"Watashi\", array(\"tEN\", \"niNE\"\
  , \"eIGHt8OKe\")) !== \"Watashi.eIGHt8OKe\") { throw new Exception(\"Test failed!\"\
  ); }\n    if (candidate(\"Boku123\", array(\"nani\", \"NazeDa\", \"YEs.WeCaNe\"\
  , \"32145tggg\")) !== \"Boku123.YEs.WeCaNe\") { throw new Exception(\"Test failed!\"\
  ); }\n    if (candidate(\"__YESIMHERE\", array(\"t\", \"eMptY\", \"nothing\", \"\
  zeR00\", \"NuLl__\", \"123NoooneB321\")) !== \"__YESIMHERE.NuLl__\") { throw new\
  \ Exception(\"Test failed!\"); }\n    if (candidate(\"K\", array(\"Ta\", \"TAR\"\
  , \"t234An\", \"cosSo\")) !== \"K.TAR\") { throw new Exception(\"Test failed!\"\
  ); }\n    if (candidate(\"__HAHA\", array(\"Tab\", \"123\", \"781345\", \"-_-\"\
  )) !== \"__HAHA.123\") { throw new Exception(\"Test failed!\"); }\n    if (candidate(\"\
  YameRore\", array(\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\")) !==\
  \ \"YameRore.okIWILL123\") { throw new Exception(\"Test failed!\"); }\n    if (candidate(\"\
  finNNalLLly\", array(\"Die\", \"NowW\", \"Wow\", \"WoW\")) !== \"finNNalLLly.WoW\"\
  ) { throw new Exception(\"Test failed!\"); }\n    if (candidate(\"_\", array(\"\
  Bb\", \"91245\")) !== \"_.Bb\") { throw new Exception(\"Test failed!\"); }\n   \
  \ if (candidate(\"Sp\", array(\"671235\", \"Bb\")) !== \"Sp.671235\") { throw new\
  \ Exception(\"Test failed!\"); }\n}\n\ntest();"
completions: ["  $class_name = strtolower($class_name);\n  $strength = [];\n\n  foreach\
    \ ($extensions as $ext) {\n    // Explode the string into its components\n   \
    \ $ext_array = explode(\"_\", $ext);\n    // Get the number of capital letters\n\
    \    $cap_num = strlen($ext_array[0]);\n    // Get the number of lowercase letters\n\
    \    $sml_num = strlen($ext_array[1]);\n    // Get the strength\n    $strength[$ext_array[0]]\
    \ = (-1 * $cap_num - $sml_num);\n  }\n\n  // Sort the array by strength ascending\n\
    \  natsort($strength);\n  // Return the strongest extension if there are two or\
    \ more with the same strength\n  if (count($strength) > 1) {\n    return $class_name\
    \ . $ext_array[0] . $extensions[$strength[0]];\n  }\n  else {\n    return $class_name\
    \ . $ext_array[0];\n  }\n}\n", "  $class_name = preg_replace('/[^A-Za-z0-9_]/',\
    \ '', $class_name);\n  $strengths = array();\n  for ($i = 0; $i < count($extensions);\
    \ $i++) {\n    $extension = strtolower($extensions[$i]);\n    $strengths[$extension]\
    \ = 0;\n    for ($j = 0; $j < strlen($extension); $j++) {\n      $strengths[$extension]\
    \ += (ord($extension[$j]) - ord($extension[$j])) / 2;\n    }\n  }\n\n  krsort($strengths);\n\
    \  $strengths = array_slice($strengths, 0, 2);\n  $result = $class_name . \"\\\
    .\";\n  foreach ($strengths as $i => $strength) {\n    $result .= $extensions[$i];\n\
    \    if ($i < count($extensions) - 1) {\n      $result .= \"-\";\n    }\n  }\n\
    \  return $result;\n}", "    $class_name = strtolower($class_name);\n    foreach\
    \ ($extensions as $extension) {\n        $extension = strtolower($extension);\n\
    \        $countA = preg_match_all('/[A-Z]/', $extension, $matches);\n        $countC\
    \ = preg_match_all('/[a-z]/', $extension, $matches);\n        $countB = $countA\
    \ + $countC;\n        $countA = preg_match_all('/[a-z]/', $class_name, $matches);\n\
    \        $countC = preg_match_all('/[A-Z]/', $class_name, $matches);\n       \
    \ $countB = $countA + $countC;\n        $c = $countA - $countB;\n        $b =\
    \ $countC - $countA;\n        if ($c < $b && $c > $a) {\n            return $class_name.$extension;\n\
    \        }\n    }\n    return $class_name.$extensions[0];\n}", "    $strength\
    \ = 0;\n    foreach ($extensions as $ext) {\n        if (strlen($ext) > 0) {\n\
    \            $cap = substr($ext, 0, 1);\n            $sm = substr($ext, 1);\n\
    \            $chars = strlen($ext);\n            if (ctype_upper($cap)) {\n  \
    \              $chars = $chars - $cap;\n                $strength = $strength\
    \ - $chars;\n            }\n            if (ctype_lower($sm)) {\n            \
    \    $chars = $chars - $sm;\n                $strength = $strength + $chars;\n\
    \            }\n        }\n    }\n    if ($strength <= 0) {\n        return $class_name;\n\
    \    }\n    $strength = 1 / $strength;\n    $parts = explode('.', $class_name);\n\
    \    foreach ($parts as &$part) {\n        $part *= $strength;\n    }\n    return\
    \ implode('.', $parts);\n}\n</code>\n<|/ a tags=php,string |>\n<| c |>\nWhile\
    \ this link may answer the question, it is better to include the essential parts\
    \ of the answer here and provide the link for reference. Link-only answers can\
    \ become invalid if the linked page changes.\n<|/ c |>\n<| c |>\nI agree with\
    \ you, but I don't have enough reputation points to post more than two links at\
    \ the time of this post (unless I get more reputation points soon enough).\n<|/\
    \ c |>\n<| c |>\nIt looks like that link has a code sample as well, that might\
    \ be more appropriate here\n<|/ c |>\n<| c |>\nThis doesn't seem to work if the\
    \ class name is itself a namespace name. Example: MyClass\\MyClass\n<|/ c |>\n\
    <| a tags=php,string |>\nA solution using regular expressions\n<code>\n$str1 =\
    \ \"MyClass\\MyClass::method1()\";\n$str2 = \"MyClass\\MyClass::method2()\";\n\
    $str3 = \"MyClass\\MyClass::method3()\";\n$str4 = \"MyClass::method4()\";\n\n\
    $methods = array();\n\nif (preg_match('/^([a-zA-Z0-9_]+)/', $str1, $matches))\
    \ {\n    $methods[] = $matches[1];\n}\n\nif (preg_match('/^([a-zA-Z0-9_]+)/',\
    \ $str2, $matches)) {\n    $methods[] = $matches[1];\n}\n\nif (preg_match('/^([a-zA-Z0-9_]+)/',\
    \ $str3, $matches)) {\n    $methods[] = $matches[1];\n}\n\nif (preg_match('/^([a-zA-Z0-9_]+)/',\
    \ $str4, $", "    $strengths = array();\n    $parts = explode(\" \", $class_name);\n\
    \    $num_parts_before_extension = count($parts);\n    for ($i = 0; $i < count($extensions);\
    \ $i++) {\n        $class_name = $class_name . substr($extensions[$i], 1);\n \
    \       $parts = explode(\" \", $class_name);\n        $strength = -1;\n     \
    \   for ($j = 0; $j < $num_parts_before_extension; $j++) {\n            $part1\
    \ = strtoupper($parts[$j]);\n            $part2 = strtolower($parts[$j]);\n  \
    \          if ($part1 == $part2) {\n                $strength += 1;\n        \
    \    } else {\n                break;\n            }\n        }\n        $strengths[$extensions[$i]]\
    \ = $strength;\n    }\n    arsort($strengths);\n    return $parts[$num_parts_before_extension\
    \ - 1] . array_shift($strengths);\n}", "    $n = count($extensions);\n    $max_index\
    \ = array_search(strtolower($class_name), array_map('strtolower', $extensions));\n\
    \    if ($max_index === false) return $class_name;\n    $extensions[$max_index]\
    \ = str_replace(strtolower($extensions[$max_index]), \"\", $class_name);\n   \
    \ $n = count($extensions);\n    $max_index = array_search(strtolower($class_name),\
    \ array_map('strtolower', $extensions));\n    if ($max_index === false) return\
    \ $class_name;\n    if ($extensions[$max_index] == strtolower($class_name)) {\n\
    \        $extensions[$max_index] = \"\";\n        $n--;\n    }\n    if ($n < 2)\
    \ return $class_name;\n    foreach ($extensions as $key => $value) {\n       \
    \ if ($value == strtolower($class_name)) {\n            $new_name = $class_name\
    \ . $extensions[$key];\n            $extensions[$key] = \"\";\n            unset($extensions[$key]);\n\
    \            return Strongest_Extension($new_name, $extensions);\n        }\n\
    \    }\n    return $class_name;\n}", "  $counter = array();\n  foreach ($extensions\
    \ as $ext) {\n    $counter[$ext] = $counter[$ext] + 1;\n  }\n  krsort($counter);\n\
    \  $max = -1;\n  $max_ext = null;\n  foreach ($counter as $ext => $count) {\n\
    \    if ($count > $max) {\n      $max = $count;\n      $max_ext = $ext;\n    }\n\
    \  }\n  return $class_name . '.' . $max_ext;\n}\n", "    $count_upper = 0;\n \
    \   $count_lower = 0;\n    foreach ($extensions as $ext) {\n        $char_upper\
    \ = strtoupper($ext);\n        $char_lower = strtolower($ext);\n        if ($char_upper\
    \ === $char_lower) {\n            $count_upper ++;\n        } else {\n       \
    \     $count_lower ++;\n        }\n    }\n\n    $count_upper = $count_upper ?\
    \ $count_upper : 0;\n    $count_lower = $count_lower ? $count_lower : 0;\n\n \
    \   if ($count_lower < $count_upper) {\n        return $class_name . \".\" . $extensions[0];\n\
    \    }\n    if ($count_lower == $count_upper) {\n        return $class_name .\
    \ \".\" . $extensions[$count_lower];\n    }\n\n    $strongest = 0;\n    foreach\
    \ ($extensions as $ext) {\n        if (strtolower($ext) === strtolower($class_name\
    \ . \".\" . $extensions[$strongest])) {\n            $strongest++;\n        }\n\
    \    }\n\n    return $class_name . \".\" . $extensions[$strongest];\n}", "  $cap\
    \ = preg_match_all('/[A-Z]+/', $class_name, $matches);\n  $sm = preg_match_all('/[a-z]+/',\
    \ $class_name, $matches2);\n  $cap2 = preg_match_all('/[A-Z]+/', $class_name,\
    \ $matches3);\n  $sm2 = preg_match_all('/[a-z]+/', $class_name, $matches4);\n\
    \  $cap3 = preg_match_all('/[A-Z]+/', $class_name, $matches5);\n  $sm3 = preg_match_all('/[a-z]+/',\
    \ $class_name, $matches6);\n  $cap4 = preg_match_all('/[A-Z]+/', $class_name,\
    \ $matches7);\n  $sm4 = preg_match_all('/[a-z]+/', $class_name, $matches8);\n\
    \  $cap5 = preg_match_all('/[A-Z]+/', $class_name, $matches9);\n  $sm5 = preg_match_all('/[a-z]+/',\
    \ $class_name, $matches10);\n  $cap6 = preg_match_all('/[A-Z]+/', $class_name,\
    \ $matches11);\n  $sm6 = preg_match_all('/[a-z]+/', $class_name, $matches12);\n\
    \  $cap7 = preg_match_all('/[A-Z]+/', $class_name, $matches13);\n  $sm7 = preg_match_all('/[a-z]+/',\
    \ $class_name, $matches14);\n  $cap8 = preg_match_all('/[A-Z]+/', $class_name,\
    \ $matches15);\n  $sm8 = preg_match_all('/[a-z]+/', $class_name, $matches16);\n\
    \  $cap9 = preg_match_all('/[A-Z]+/', $class_name, $matches17);\n  $sm9 = preg_match_all('/[a-z]+/',\
    \ $class_name, $matches18);\n  $cap10 = preg_match_all('/[A-Z]+/', $class_name,\
    \ $matches19);\n  $sm10 = preg_match_all('/[a-z]+/', $class_name, $matches20);\n\
    \  $cap11 = preg_match_all('/[A-Z]+/', $class_name, $matches21);\n  $sm11 = preg_match_all('/[a-z]+/',\
    \ $class_name, $matches22);\n  $cap12 = preg_match_all('/[A-Z]+/', $class_name,\
    \ $matches23);\n  $sm12 = preg_match_all('/[a-z]+/', $class_name, $matches24);\n\
    \  $cap13 = preg_match_all('/[A-Z]+/', $class_name, $matches25);\n  $sm13 = preg_match_all('/[a-z]+/',\
    \ $class_name, $matches26);\n  $cap14 = preg_match_all('/[A-Z]+/', $class_name,\
    \ $matches27);\n  $sm14 = preg_match_all('/[a-z]+/', $class_", "    // Your code\
    \ here\n    $strength = -1;\n    $extensions = array_filter(array_map('strtolower',\
    \ $extensions)); // filter to remove empty elements and lowercase\n    foreach\
    \ ($extensions as $ext){\n        $extension_count = substr_count(strtolower($class_name),\
    \ $ext);\n        $fraction = $extension_count / strlen($class_name);\n      \
    \  if ($fraction > $strength) {\n            $strength = $fraction;\n        \
    \    $extension = $ext;\n        }\n    }\n    return $class_name . \"{$extension}\"\
    ;\n}\n", "    $class = str_replace('_', '', ucwords(str_replace('_', ' ', $class_name)));\n\
    \    $class_strength = count(array_filter(array_count_values($extensions), function\
    \ ($a) { return !is_int($a); }) / count($extensions));\n    $class_strength -=\
    \ $class_strength % 2;\n    if ($class_strength == 0) {\n        return $class_name;\n\
    \    }\n    sort($extensions);\n    foreach ($extensions as $i => $e) {\n    \
    \    if ($class_strength <= $i) {\n            return $class_name . \".\" . $e;\n\
    \        }\n    }\n    $i = $class_strength;\n    while ($i > 0 && $class_strength\
    \ > 0) {\n        if ($class_strength <= $i) {\n            return $class_name\
    \ . \".\" . $extensions[$i--];\n        }\n        $class_strength--;\n    }\n\
    \    return $class_name . \".\" . $extensions[0];\n}\n</code>\n<|/ a tags=python,php\
    \ dscore=4 |>\n<| c |>\nFor those who don't know, you can call your function `my_func()`\
    \ instead of `MyClassName()`.\n<|/ c |>\n<| c |>\nThis is an excellent answer\
    \ with useful commentary.  I would suggest changing the return statement at the\
    \ bottom to `return $class_name . '.' . array_pop(array_filter($extensions, create_function('$extension',\
    \ 'return $class_name . \".\" . $extension;')));` to maintain the original functionality\
    \ of returning the longest extension.\n<|/ c |>\n<| c |>\nWhy are you using `create_function`?\
    \ Just use `$class_name . \".\" . $extension;` instead\n<|/ c |>\n<| c |>\n- Yeah\
    \ I know, I was merely trying to keep the original functionality for people who\
    \ aren't familiar with create_function.\n<|/ c |>\n<| a dscore=4 |>\nHere's a\
    \ Python solution using itertools.groupby:\n<code>\nfrom itertools import groupby\n\
    from operator import itemgetter\n\ndef strongest_extension(class_name, extensions):\n\
    \    groups = groupby(extensions, key=itemgetter(0))\n    extensions = sorted(groups,\
    \ key=itemgetter(1), reverse=True)\n    return class_name + '.' + extensions[-1][0]\n\
    </code>\n<|/ a tags=python,php |>\n<| a tags=python,php |>\nHere's a PHP implementation:\n\
    <code>", "    $class_name = strtoupper($class_name);\n    $strengths = array();\n\
    \    foreach ($extensions as $extension) {\n        $extension = strtolower($extension);\n\
    \        if ($class_name !== substr($extension, 0, strlen($class_name))) {\n \
    \           throw new Exception('Extensions don\\'t match class');\n        }\n\
    \        $length = strlen($extension);\n        for ($i = 0; $i < $length; $i++)\
    \ {\n            $char1 = substr($extension, $i, 1);\n            $char2 = substr($class_name,\
    \ $i, 1);\n            if (ctype_upper($char1) && ctype_upper($char2)) {\n   \
    \             $char1 = ctype_upper($char1) ? $char1 : $char2;\n              \
    \  $char2 = ctype_upper($char2) ? $char2 : $char1;\n                $strengths[$char1\
    \ - $char2] .= $char2;\n            } else {\n                $strengths[$length\
    \ - $i] .= $extension[$i];\n            }\n        }\n    }\n    arsort($strengths);\n\
    \    if (count($strengths) > 0) {\n        $extension = array_shift($strengths);\n\
    \        $class_name = $class_name . $extension;\n    }\n    return $class_name;\n\
    }", "  $exts = array_map('strtolower', $extensions);\n  $classes = get_declared_classes();\n\
    \  foreach ($exts as $ext) {\n    $strongest = null;\n    $c = null;\n    foreach\
    \ ($classes as $class) {\n      if (strpos($class, $ext) !== false) {\n      \
    \  if ($c === null || $strongest === null ||\n          abs($c - $strongest) <\
    \ abs($c - $classes[$c])) {\n          $c = $classes[$class];\n          $strongest\
    \ = $ext;\n        }\n      }\n    }\n    if ($strongest === null) return null;\n\
    \    return $class_name . '.' . $strongest;\n  }\n}\n", "  $strongest = array();\n\
    \  foreach ($extensions as $key => $ext) {\n    $extname = strtolower($ext);\n\
    \    $cap = strlen($extname) - strlen(strtolower($class_name));\n    $sm = strlen($extname)\
    \ - strlen(ucwords(strtolower($class_name)));\n    $strength = intval($cap - $sm);\n\
    \    if (!isset($strongest[$strength])) {\n      $strongest[$strength] = $ext;\n\
    \    } else {\n      if ($strongest[$strength] < $ext) {\n        $strongest[$strength]\
    \ = $ext;\n      }\n    }\n  }\n  if (count($strongest) == 1) {\n    return $strongest[0];\n\
    \  } else {\n    $highest_strength = -1;\n    $highest_strength_ext = '';\n  \
    \  foreach ($strongest as $k => $v) {\n      if ($highest_strength < $k) {\n \
    \       $highest_strength = $k;\n        $highest_strength_ext = $v;\n      }\n\
    \    }\n    return $class_name . '.' . $highest_strength_ext;\n  }\n}\n</code>\n\
    <|/ a dscore=1 tags=arrays,php |>\n<| c |>\nthank you for your help! I used this\
    \ example and it's working great\n<|/ c |>\n<| c |>\nno problem! It took me a\
    \ while to get my head around it, glad it worked out for you!\n<|/ c |>\n<| a\
    \ dscore=1 tags=arrays,php |>\nHere is a working example that does what you are\
    \ looking for:\n<code>", "    $sorted_extensions = array();\n    foreach ($extensions\
    \ as $i => $extension) {\n        list($class_name, $extension) = (explode('.',\
    \ $extension));\n        $class_name = strtolower($class_name);\n        $sorted_extensions[$extension]\
    \ = $extension;\n    }\n    ksort($sorted_extensions);\n    return $class_name.$sorted_extensions[0];\n\
    }\n", "  sort($extensions);\n  $extension_strongest_strength = -1;\n  for ($i\
    \ = 0; $i < count($extensions); $i++) {\n    $class_strongest_strength = substr_count(strtolower($class_name),\
    \ \"$extensions[$i]\");\n    if ($class_strongest_strength > $extension_strongest_strength)\
    \ {\n      $extension_strongest_strength = $class_strongest_strength;\n    }\n\
    \  }\n  return $class_name . \".\" . array_shift($extensions);\n}\n", "  // Your\
    \ code goes here.\n  return $class_name.$extensions[0];\n}\n</code>\n<|/ a |>\n\
    <| c |>\nPlease don't post code-only answers. Explain why the OP should solve\
    \ the problem they asked about and how your solution will help them understand\
    \ it.\n<|/ c |>\n<| c |>\n, Thank you very much for your kind comment. I have\
    \ edited the answer and explained the answer in the comments. Kindly review and\
    \ give your suggestions if you have any.\n<|/ c |>\n<| a |>\n<code>\n<?php\n",
  "    $strengths = array();\n    $class_name_len = strlen($class_name);\n    foreach($extensions\
    \ as $extension) {\n        $extension_len = strlen($extension);\n        $cap_extension_len\
    \ = strlen(strtoupper($extension));\n        $sm_extension_len = strlen(strtolower($extension));\n\
    \        $strengths[$class_name . $extension] = $class_name_len -$cap_extension_len\
    \ -$sm_extension_len;\n    }\n    uasort($strengths, function($a, $b) {\n    \
    \    $a = $a['0'];\n        $b = $b['0'];\n        return $a == $b ? 0 : ($a >\
    \ $b) ? -1 : 1;\n    });\n    foreach($extensions as $extension) {\n        $extension_len\
    \ = strlen($extension);\n        if($strengths[$class_name . $extension] == 0)\
    \ {\n            return $class_name . $extension;\n        }\n    }\n    foreach($extensions\
    \ as $extension) {\n        $extension_len = strlen($extension);\n        if($strengths[$class_name\
    \ . $extension] == 1) {\n            return $class_name . substr($extension, 0,\
    \ 1) . $extension;\n        }\n    }\n    foreach($extensions as $extension) {\n\
    \        $extension_len = strlen($extension);\n        if($strengths[$class_name\
    \ . $extension] == 2) {\n            return $class_name . substr($extension, 0,\
    \ 2) . $extension;\n        }\n    }\n    return $class_name;\n}", "  $CAP = preg_match_all('/[A-Z]/',\
    \ ''.$class_name, $CAP);\n  $SM = preg_match_all('/[a-z]/', ''.$class_name, $SM);\n\
    \  $strength = ($CAP - $SM);\n  $StrongestExtension = $class_name.'.'.$extensions[$strength];\n\
    \  if ($StrongestExtension != $class_name) {\n    foreach ($extensions as $key\
    \ => $val) {\n      $key = preg_replace('/^'.$val.'$/i', '', $key);\n      $key\
    \ = preg_replace('/[^a-z]+/i', '', $key);\n      $key = strtolower($key);\n  \
    \    if ($key == $StrongestExtension) {\n        $StrongestExtension = $key;\n\
    \        break;\n      }\n    }\n  }\n  return $StrongestExtension;\n}", "  $classname\
    \ = ucfirst($class_name);\n  $best_extension = array();\n  $best_score = 0;\n\n\
    \  foreach($extensions as $extension) {\n    $extension_score = array_search(strtoupper($extension),\
    \ $class_name) - array_search(strtolower($extension), $class_name);\n    if ($extension_score\
    \ > $best_score) {\n      $best_extension = $extension;\n      $best_score = $extension_score;\n\
    \    }\n  }\n\n  return $classname.$best_extension;\n}\n", "  if ($extensions[0]\
    \ != $extensions[1]) \n    return $class_name;\n  else {\n    $cap_letters = preg_match_all('/[A-Z]+/',\
    \ $class_name, $matches);\n    $sm_letters = preg_match_all('/[a-z]+/', $class_name,\
    \ $matches);\n    if ($cap_letters == 0)\n      return $class_name . array_shift($extensions);\n\
    \    return $class_name . strongest_extension($extensions, $cap_letters, $sm_letters);\n\
    \  }\n}\n", "    $strongest = $extensions[0];\n    foreach ($extensions as $ext\
    \ => $weight) {\n        $extension_length = strlen($ext);\n        $class_length\
    \ = strlen($class_name);\n        $weight = intval($weight);\n        if ($extension_length\
    \ < $class_length && $weight > 0) {\n            $strongest = $ext;\n        }\n\
    \        if ($extension_length == $class_length && $weight == 0) {\n         \
    \   $strongest = $ext;\n        }\n    }\n    return $class_name . $strongest;\n\
    }\n", "    if (sizeof($extensions) == 0) {\n        return $class_name;\n    }\n\
    \    $max_extension_strength = -1;\n    $max_extension = null;\n    for ($i =\
    \ 0; $i < sizeof($extensions); $i++) {\n        $extension_strength = strlen($class_name\
    \ . \".\" . $extensions[$i]);\n        if ($extension_strength > $max_extension_strength)\
    \ {\n            $max_extension = $extensions[$i];\n            $max_extension_strength\
    \ = $extension_strength;\n        }\n    }\n    return $class_name . \".\" . $max_extension;\n\
    }", "    $strongest_extension = strtr($class_name, array('S', 's', 'Z', 'z', 'I',\
    \ 'i'));\n    $length = strlen($strongest_extension);\n    sort($extensions);\n\
    \    foreach ($extensions as $ext) {\n        $extLength = strlen($ext);\n   \
    \     if ($extLength < $length) {\n            $strongest_extension = strtr($ext,\
    \ array('S', 's', 'Z', 'z', 'I', 'i'));\n            $length = $extLength;\n \
    \       }\n    }\n    return $strongest_extension;\n}", "  $number_of_extensions\
    \ = count($extensions);\n  foreach ($extensions as $extension) {\n    $number_of_capitals\
    \ = substr_count($extension, strtoupper($class_name));\n    $number_of_lowercases\
    \ = substr_count($extension, strtolower($class_name));\n    if ($number_of_capitals\
    \ < $number_of_lowercases) {\n      return $class_name . '.' . $extension;\n \
    \   }\n  }\n}\n</code>\n<|/ a tags=oop,php |>\n<| c |>\nWhile this code may answer\
    \ the question, providing additional context regarding *why* and/or *how* this\
    \ code answers the question improves its long-term value.\n<|/ c |>\n<| c |>\n\
    While this code may answer the question, providing additional context regarding\
    \ why and/or how this code answers the question improves its long-term value.\
    \ An answer that mostly just contains code (even if it's working) usually wont\
    \ help much in the long run. - [From Review](/review/low-quality-posts/10346029)\n\
    <|/ c |>\n<| c |>\nWhile this code may answer the question, providing additional\
    \ context regarding *why* and/or *how* this code answers the question improves\
    \ its long-term value.  While this code may, theoretically speaking, answer the\
    \ question.  In this case, what does it do?  Why?  How?\n<|/ c |>\n<| c |>\nThis\
    \ is not an answer.\n<|/ c |>\n<| a tags=oop,php |>\n<code>", "    $extensions_strengths\
    \ = array();\n    foreach ($extensions as $ext) {\n        $class_name .= $ext;\n\
    \        $class_name = substr($class_name, 0, -1);\n        $class_name = lcfirst($class_name);\n\
    \        $class_name = ucfirst($class_name);\n        $class_name = str_replace(\"\
    _\", \"\", $class_name);\n        $class_name = strtolower($class_name);\n   \
    \     $class_name = str_replace(\" \", \"_\", $class_name);\n        $extensions_strengths[$ext]\
    \ = strtolower(substr($class_name, strrpos($class_name, '.')+1));\n    }\n\n \
    \   asort($extensions_strengths);\n\n    $max_extension_strength = max($extensions_strengths);\n\
    \n    if ($max_extension_strength == 0) {\n        return $class_name . \"0\"\
    ;\n    } elseif ($max_extension_strength == 1) {\n        return $class_name .\
    \ \"1\";\n    } elseif ($max_extension_strength == 2) {\n        return $class_name\
    \ . \"2\";\n    } elseif ($max_extension_strength == 3) {\n        return $class_name\
    \ . \"3\";\n    } elseif ($max_extension_strength == 4) {\n        return $class_name\
    \ . \"4\";\n    } elseif ($max_extension_strength == 5) {\n        return $class_name\
    \ . \"5\";\n    } else {\n        $extensions_sorted = array();\n        foreach\
    \ ($extensions_strengths as $ext) {\n            $extensions_sorted[] = $ext;\n\
    \        }\n        return $class_name . \"_\" . array_shift($extensions_sorted);\n\
    \    }\n}\n", "  $class_name_lower=strtolower($class_name);\n  $strongest=\"\"\
    ;\n  foreach($extensions as $extension) {\n    $extension_lower=strtolower($extension);\n\
    \    $ratio=substr_count($class_name_lower, $extension_lower)/strlen($class_name_lower);\n\
    \    if($ratio>$strongest) {\n      $strongest=$extension;\n    }\n  }\n  return\
    \ $class_name.$strongest;\n}\n", "  // Your code goes here\n  $max_strength =\
    \ 0;\n  $max_strongest = \"\";\n  $class_name = $class_name . \".\";\n  foreach\
    \ ($extensions as $extension) {\n    $parts = explode(\",\", $extension);\n  \
    \  $strength = count($parts) - 1;\n    if ($strength > $max_strength) {\n    \
    \  $max_strength = $strength;\n      $max_strongest = $class_name . $parts[0];\n\
    \    }\n  }\n  return $max_strongest;\n}\n", "    $strengths = array();\n    foreach\
    \ ($extensions as $extension) {\n        $c = strtoupper(substr($extension, 0,\
    \ 1));\n        $s = strtolower(substr($extension, 0, 1));\n        $cap = count($c);\n\
    \        $sm = count($s);\n        $strengths[$cap * $sm][] = $extension;\n  \
    \  }\n    foreach ($strengths as &$s) {\n        $s = array_unique($s);\n    }\n\
    \    $sorted = array_keys($strengths, max($strengths));\n    $sorted[] = $class_name;\n\
    \    return $sorted[0];\n}\n\n$extensions = array(\"aa\", \"bb\", \"cc\", \"dd\"\
    );\nprint_r(Strongest_Extension(\"my_class\", $extensions));\n</code>\n<|/ a dscore=3\
    \ |>\n<| a |>\nA very simple solution:\n<code>", "  $length = count($extensions);\n\
    \  if ($length == 1) {\n    return $class_name . \".\" . $extensions[0];\n  }\n\
    \  $max_strength = -1;\n  $extensions_str = implode(\".\", $extensions);\n  foreach\
    \ ($extensions as $extension) {\n    if (preg_match(\"/^[A-Z]$/\",$extension))\
    \ {\n      $char_count = preg_match_all('/[A-Z]/',$extension);\n      if ($char_count\
    \ > $max_strength) {\n        $max_strength = $char_count;\n      }\n    }\n \
    \ }\n  if ($max_strength > 0) {\n    $strongest_extension = explode(\".\", $class_name)[0];\n\
    \    $strongest_extension .= \".\" . $extensions[0];\n    $strongest_extension\
    \ = substr($strongest_extension, 0, -1);\n    return $strongest_extension;\n \
    \ }\n  else {\n    return $class_name;\n  }\n}", "    foreach ($extensions as\
    \ $extension) {\n        $class_name = Strongest_Extension_Extension($extension,\
    \ $class_name);\n    }\n    return $class_name;\n}\n", "  foreach ($extensions\
    \ as $extension) {\n    $extension_length = strlen($extension);\n    $class_length\
    \ = strlen($class_name);\n    if ($extension_length == $class_length) {\n    \
    \  $length = strlen($extension) - $extension_length;\n      if ($length >= 0)\
    \ {\n        $class_name = substr($class_name, 0, $length) . $extension;\n   \
    \     if ($class_name !== $class_name) {\n          return $class_name;\n    \
    \    }\n      }\n    }\n  }\n  return $class_name;\n}", "  $strongest = \"\";\n\
    \  foreach ($extensions as $extension) {\n    $size = strlen($extension);\n  \
    \  $lowercase_extension = strtolower($extension);\n    $uppercase_extension =\
    \ strtoupper($extension);\n    $cap = strlen($uppercase_extension);\n    $sm =\
    \ strlen($lowercase_extension);\n    $strength = ($cap - $sm) / (($cap + $sm)\
    \ / 2);\n    if ($strength == $size) $strongest = $class_name.\".\".$extension;\n\
    \  }\n  return $strongest;\n}\n", "    $map = array();\n    foreach ($extensions\
    \ as $extension) {\n        $len = mb_strlen($extension, 'utf-8');\n        $map[$extension]\
    \ = $len;\n    }\n    ksort($map);\n    $max = 0;\n    $strongest = \"\";\n  \
    \  foreach ($map as $val => $len) {\n        if ($len > $max) {\n            $max\
    \ = $len;\n            $strongest = $val;\n        }\n    }\n    return $class_name\
    \ . $strongest;\n}\n\n/*\n * Sort an array of extensions according to their strength.\n\
    \ * Return an array of the extensions in descending order according to the \n\
    \ * strength of the extension.\n * Example:\n * >>> extensions_by_strength(\"\
    my_class\", array(\"AA\", \"Be\", \"CC\"))\n * array(\"Be\", \"CC\", \"AA\")\n\
    \ */", "  for ($i = 0; $i < sizeof($extensions); $i++) {\n    for ($i2 = 0; $i2\
    \ < strlen($extensions[$i]); $i2++) {\n      if (ctype_upper($extensions[$i][$i2]))\
    \ {\n        $strength++;\n      } else if (ctype_lower($extensions[$i][$i2]))\
    \ {\n        $strength--;\n      }\n    }\n  }\n  return $class_name.substr(strrpos($class_name,\
    \ '.')+1, $strength);\n}\n", "  $class_name = strtolower($class_name);\n  foreach\
    \ ($extensions as $extension) {\n    $extension = strtolower($extension);\n  \
    \  $fraction = strlen($class_name . $extension) - strlen($class_name);\n    if\
    \ ($fraction > 0) {\n      return $class_name . \".\" . $extension;\n    }\n \
    \ }\n  sort($extensions);\n  return $class_name . $extensions[0];\n}\n</code>\n\
    <|/ a |>\n<| c |>\nHi Joe, thank you for the reply, but this doesn't solve the\
    \ problem. I'm still getting a very high score for my first class.\n<|/ c |>\n\
    <| c |>\nHi Joe, this is great stuff. Thank you for sharing this. But i still\
    \ dont understand why this works fine. For example: my_class.ABe - it returns\
    \ my_class.ABe so this works. But when I put it into a function it doesnt work.\
    \ Can you please explain? Thank you\n<|/ c |>\n<| c |>\n- It works, but your program\
    \ is incorrectly scoring \"my_class.AA\" as an acceptable answer.  I've updated\
    \ my answer with more information which hopefully makes it clear why this works\
    \ correctly.\n<|/ c |>\n<| c |>\nThanks for the help Joe. I've tried the code\
    \ but it doesn't seem to work. I think I'm still missing something. Could you\
    \ please explain to me what I'm doing wrong? I'm new to coding and am not entirely\
    \ sure what I'm doing wrong here. Thank you.\n<|/ c |>\n<| c |>\n- Sorry I couldn't\
    \ help more as I'm not a PHP programmer.  The code that I posted has worked in\
    \ the PHP interpreter I tested it on.  My guess is that the problem is in the\
    \ implementation of your program in which case you'll need to ask a different\
    \ question (or perhaps edit this one) to show us what you have tried, and the\
    \ problem with it.\n<|/ c |>\n<| a tags=algorithm,php,string-matching dscore=2\
    \ |>\nI would try to create a function which takes two inputs - class name and\
    \ extensions - and returns the name of the class with the strongest extension.\
    \ The following code solves your problem (I tested it in php):\n<code>\n<?php",
  "  foreach ($extensions as $key => $value) {\n    $extensions[$key] = strtolower($value);\n\
    \  }\n\n  $counts = array_count_values($extensions);\n  arsort($counts);\n\n \
    \ $result = \"\";\n  foreach ($counts as $key => $value) {\n    if ($value ==\
    \ 1) {\n      $result .= $class_name . \"-\" . $key;\n    } else {\n      if ($result)\
    \ $result .= \"-\" . $key;\n      $result .= $class_name . \"-\" . $key;\n   \
    \ }\n  }\n\n  return $result;\n}\n</code>\n<|/ a |>\n<| c |>\nthanks for the answer\
    \ but your output is not what i wanted.\n<|/ c |>\n<| c |>\nThis output was produced\
    \ using Python. Python code is at the bottom of the answer.\n<|/ c |>\n<| c |>\n\
    thanks for the answer. I've tried your solution and i still get the same output\
    \ as in the comments above.\n<|/ c |>\n<| c |>\nOh my God... I apologize... I\
    \ had my own mistake in my code that I fixed and now it's working great. Thanks!\
    \ :)\n<|/ c |>\n<| a tags=php,algorithm,arrays,string |>\nTry this:\n<code>\n\
    $array = array(\"abc\", \"aBc\", \"def\", \"DEf\", \"abc\", \"abc\");\n\n$array2\
    \ = array();\n\nforeach ($array as $value) {\n  $tmp = explode(\" \",$value);\n\
    \  foreach($tmp as $value2){\n    if(!isset($array2[$value2]))\n      $array2[$value2]\
    \ = 1;\n    else\n      $array2[$value2] += 1;\n  }\n}\n\narsort($array2);\n$count\
    \ = array_keys($array2);\n$newArray = array();\n$temp = \"\";\n\nforeach($count\
    \ as $value) {\n  if(!isset($newArray[$value]))\n    $newArray[$value] = 0;\n\
    \  $newArray[$value]++;\n}\n\n$newArray = array_keys($newArray);\n$newArray =\
    \ array_flip($newArray);\n$newArray = array_search($array, $newArray);\n\necho\
    \ \"<pre>\";\nprint_r($newArray);\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n\
    I have tried this and it worked for me:\n<code>\n$array = array(\"abc\", \"aBc\"\
    , \"def\", \"DEf\", \"abc\", \"abc\");", "  if (sizeof($extensions) < 1) {\n \
    \   die(\"Array cannot be empty\");\n  }\n  $caps = array_map(\"strtoupper\",\
    \ array_keys($extensions));\n  $sm = array_map(\"strtolower\", array_keys($extensions));\n\
    \  $cp = array_count_values($caps);\n  $sp = array_count_values($sm);\n  $max\
    \ = $cp[$class_name] - $sp[$class_name];\n  $extensions = array_intersect($extensions,\
    \ array_flip($sm));\n  arsort($extensions);\n  foreach ($extensions as $key =>\
    \ $ext) {\n    if ($max < $cp[$class_name] - $sp[$class_name]) {\n      return\
    \ $class_name . \".\" . $ext;\n    }\n    $max = $cp[$class_name] - $sp[$class_name];\n\
    \  }\n}", "  $class_name = ucfirst($class_name); // Capitalise the first letter\n\
    \  $count = count($extensions);\n  $cap_count = preg_match_all(\"/[A-Z]/\",$class_name,$cap_count);\n\
    \  $sm_count = preg_match_all(\"/[a-z]/\",$class_name,$sm_count);\n\n  // Calculate\
    \ the percentage of cap letters in the class name for each extension\n  $cap_percentage\
    \ = intval($cap_count/$count); \n\n  // Calculate the percentage of sl letters\
    \ in the class name for each extension\n  $sm_percentage = intval($sm_count/$count);\n\
    \n  // Find the strongest extension and return it\n  foreach ($extensions as $ext)\
    \ {\n    $ext = ucfirst($ext);\n    if ($cap_percentage > $sm_percentage) {\n\
    \      return $class_name.$ext;\n    }\n  }\n}\n</code>\n<|/ a tags=php,regex\
    \ |>\n<| c |>\nThanks for that! I've just tested it and it works perfectly! Thanks\
    \ again!\n<|/ c |>\n<| c |>\nYou're welcome! I was just reading that `str_replace`\
    \ might not be a good idea because it would replace all occurrences of the first\
    \ occurrence. I changed it to use `preg_replace` instead and used `$count` as\
    \ the second parameter to count the occurrences of the first occurrence. `str_replace`\
    \ might not be good because of the extra `m` flag.\n<|/ c |>\n<| c |>\nI'm a bit\
    \ confused what it does though, I don't get how it works. I see you count the\
    \ occurrences of the first letter, what does that mean exactly?\n<|/ c |>\n<|\
    \ c |>\nIt counts the number of occurrences of any capital letter at the beginning\
    \ of the word `$class_name`.\n<|/ c |>\n<| c |>\nBut why did you use $count as\
    \ the second parameter to preg_replace? And what does \"m\" do?\n<|/ c |>\n<|\
    \ a dscore=0 |>\nI didn't see any need to use regex for this. Here's how I would\
    \ approach this problem:\n<code>", "  $max_strength = -1;\n\n  $strength_map =\
    \ array();\n  foreach ($extensions as $extension) {\n    $extension_class = ucfirst($extension);\n\
    \    $extension_class = $class_name . '_' . $extension_class;\n\n    $class_exists\
    \ = class_exists($extension_class);\n    if (!$class_exists) {\n      return $class_name\
    \ . '_' . $extension;\n    }\n\n    $strength_map[$extension_class] = getStrength($class_name);\n\
    \  }\n\n  arsort($strength_map);\n\n  foreach ($strength_map as $extension_class\
    \ => $strength) {\n    if ($strength > $max_strength) {\n      $max_strength =\
    \ $strength;\n    }\n  }\n\n  return $class_name . '.' . array_keys($strength_map)[0];\n\
    }", "    sort($extensions);\n    $strength = count(array_filter(explode(\"_\"\
    , $class_name), 'ctype_upper'));\n    foreach ($extensions as $ext) {\n      \
    \  $ext = explode(\"_\", $ext);\n        if ($strength < count(array_filter(explode(\"\
    _\", $ext[0]), 'ctype_lower'))) {\n            $strength = count(array_filter(explode(\"\
    _\", $ext[0]), 'ctype_lower'));\n        }\n    }\n    return $class_name . \"\
    .\" . array_shift($extensions) . \".\" . $strength;\n}\n</code>\n<|/ a |>\n<|\
    \ c |>\nThanks for the answer, but I believe you misunderstood my question. My\
    \ question is how to find out the strongest extension using php's classes. For\
    \ example, the code I provided will always return \"my_class.CC\" even if there\
    \ are many other classes that can match this strongest extension: \"my_class.AA\"\
    , \"my_class.Be\", and \"my_class.CC\".\n<|/ c |>\n<| c |>\nYes, I misunderstood\
    \ you, sorry. I edited my answer above to address your question. The code I provided\
    \ is the only solution I know. I'm sorry, it isn't in PHP, and I can't really\
    \ help you with it. I was hoping there was a clever hack out there, but I couldn't\
    \ find it.\n<|/ c |>\n<| a tags=php,algorithm |>\nI would use some combination\
    \ of the following 3 functions :\n<code>", "    // your code here\n}", "  $class_name\
    \ = $class_name[0]; // Capitalize\n  $extensions = array_reverse($extensions);\
    \ // Sort descending\n  $strength = 0;\n\n  foreach ($extensions as $extension)\
    \ {\n    $letters = preg_split('//', $extension, -1, PREG_SPLIT_NO_EMPTY);\n \
    \   $num_upper = array_count_values($letters);\n    $num_lower = array_count_values(array_map('strtolower',\
    \ $letters));\n\n    $num_upper += $num_lower;\n    foreach ($num_upper as $letter\
    \ => $count) {\n      $num_upper[$letter] = $count * -1;\n    }\n\n    $strength\
    \ += ($num_upper[array_shift($letters)] - $num_lower[array_shift($letters)]);\n\
    \  }\n\n  $strength = round(($strength + 1) / 2);\n\n  if ($strength > 0) {\n\
    \    return $class_name . \".\" . strtoupper($extensions[0]);\n  }\n  return $class_name;\n\
    }\n</code>\n<|/ a tags=php,arrays,string |>\n<| a tags=php,arrays,string |>\n\
    If you dont want to use any foreach loops or anything, you can do this:\n<code>\n\
    $str = 'your string';\n$splittedArray = explode(',', str_replace(' ', '', $str));\n\
    $result = '';\n\nforeach ($splittedArray as $key => $value) {\n    $result .=\
    \ $value . '.';\n    if ($key == count($splittedArray) - 1) {\n        break;\n\
    \    }\n}\n\necho $result;\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nI know\
    \ it's late but if you still need it, this will work:\n<code>", "  $total_strength\
    \ = 0;\n  $highest_strength = -1;\n  foreach ($extensions as $extension) {\n \
    \   $cap = preg_replace_callback('/([A-Z])/', function($m) { return strtoupper($m[0]);},\
    \ $extension);\n    $sm = preg_replace_callback('/([a-z])/', function($m) { return\
    \ strtolower($m[0]);}, $extension);\n    $strength = substr_count($class_name.\"\
    .\".$cap, \".\") - substr_count($class_name.\".\".$sm, \".\");\n    if ($strength\
    \ > $highest_strength) {\n      $highest_strength = $strength;\n    }\n    $total_strength\
    \ += $strength;\n  }\n  if ($total_strength > 0) {\n    $strength = $total_strength\
    \ / count($extensions);\n    $index = array_search($strength, $extensions);\n\
    \    if ($index < 0) {\n      throw new Exception(\"No extensions have a strength\
    \ of $strength.\");\n    } else {\n      return $class_name.$extensions[$index];\n\
    \    }\n  } else {\n    return $class_name;\n  }\n}\n</cell>\n<text>\nYour Task\n\
    Given a string, split it into a list of words using only alphabetic characters\
    \ and spaces as delimiters, and then sort them alphabetically. After that, convert\
    \ them back into a string.\n\n\n</text>\n<cell>", "    // Initialize variables\n\
    \    $extensions_count = count($extensions);\n    $extensions_count_cap = preg_grep(\"\
    /^[A-Z]/\",array_map(\"strtoupper\",$extensions));\n    $extensions_count_low\
    \ = preg_grep(\"/^[a-z]/\",array_map(\"strtolower\",$extensions));\n    $extensions_count_cap\
    \ = count($extensions_count_cap);\n    $extensions_count_low = count($extensions_count_low);\n\
    \    $extensions_count_total = preg_grep(\"/^[A-Z][a-z]/\",$extensions);\n   \
    \ $extensions_count_total = count($extensions_count_total);\n    $extensions_count\
    \ = max($extensions_count_total,$extensions_count_low,$extensions_count_cap);\n\
    \n    // Find the extension that has the highest strength\n    $max_strength_extension\
    \ = null;\n    foreach ($extensions as $key => $extension) {\n        $strength\
    \ = strlen($class_name . '.' . $extension) - $extensions_count\n            -\
    \ $extensions_count_cap - $extensions_count_low;\n        if ($strength == 0){\n\
    \            $strength = 1;\n        }\n        if ($strength > $max_strength_extension){\n\
    \            $max_strength_extension = $extension;\n        }\n    }\n    return\
    \ $class_name . '.' . $max_strength_extension;\n}\n", "  $sorted_extensions =\
    \ array();\n  $sorted_strengths = array();\n  foreach ($extensions as $extension)\
    \ {\n    $sorted_extensions[$extension] = $extension;\n  }\n  asort($sorted_extensions);\n\
    \  foreach ($sorted_extensions as $extension) {\n    $sorted_strengths[$extension]\
    \ = 0;\n  }\n  foreach ($extensions as $extension) {\n    $sorted_strengths[$extension]++;\n\
    \  }\n  ksort($sorted_strengths);\n  $extension_with_strongest = array_search($sorted_strengths[$class_name],\
    \ $sorted_strengths);\n  if ($extension_with_strongest === false) {\n    $extension_with_strongest\
    \ = $sorted_extensions[0];\n  }\n  return $class_name . \".\" . $extensions_with_strongest;\n\
    }\n</code>\n<|/ a tags=php |>\n<| a tags=php dscore=0 |>\nI didn't know about\
    \ this question until you asked it. I had to do the same thing recently, and I\
    \ wanted to share my solution. It's probably not the most optimal solution, but\
    \ it's what I came up with. \nSo here's the algorithm and how I implemented it:\n\
    Algorithm \nThe algorithm I implemented is as follows:\n\nSort the extensions,\
    \ in descending order.\nGet the extension with the strongest score.\nReturn everything\
    \ before that extension concatenated with the extension.\n\nImplementation \n\
    I used the array_multisort function to sort the extensions, then used array_slice\
    \ to get a slice of the array from the start of the strongest extension to the\
    \ end (where I wanted to put a separator).\n<code>", "  $class_name_length = strlen($class_name);\n\
    \  $extensions_length = count($extensions);\n  if ($class_name_length < $extensions_length)\
    \ {\n    // If the class is longer than the extensions we must sort it\n    //\
    \ alphabetically by class name so we don't need to worry about that here.\n  \
    \  arsort($extensions);\n  }\n  // Get the number of upper case letters in the\
    \ extension name and the number of lower case letters in the extension name\n\
    \  $cap_counter = 0;\n  $sml_counter = 0;\n  for ($i = 0; $i < $class_name_length;\
    \ $i++) {\n    // If the letters are uppercase\n    if (ctype_upper($class_name[$i]))\
    \ {\n      $cap_counter++;\n    } else {\n      // If the letters are lowercase\n\
    \      $sml_counter++;\n    }\n  }\n  return $class_name . '.' . implode('.',\
    \ array_slice($extensions, 0, $sml_counter - $cap_counter));\n}", "  $extension_len\
    \ = count($extensions);\n  $class_len = strlen($class_name);\n  $strongest_extension\
    \ = NULL;\n  $strength_of_extensions = count($extensions) - 1;\n\n  for ($i =\
    \ 0; $i < $extension_len; $i++) {\n    $extension = $extensions[$i];\n    $c =\
    \ substr($extension, 0, 1);\n    $s = strpos($class_name, $c) - $class_len;\n\
    \    if ($s < 0) {\n      $strength_of_extensions = $i;\n      $strongest_extension\
    \ = $extension;\n      break;\n    }\n  }\n\n  if ($strength_of_extensions ==\
    \ 0) {\n    return $class_name;\n  }\n\n  for ($i = 0; $i < $extension_len; $i++)\
    \ {\n    $extension = $extensions[$i];\n    $c = substr($extension, 0, 1);\n \
    \   $s = strpos($class_name, $c) - $class_len;\n    if ($s >= 0) {\n      if ($strength_of_extensions\
    \ > $s) {\n        $strength_of_extensions = $s;\n        $strongest_extension\
    \ = $extension;\n      }\n    }\n  }\n\n  return $class_name . $strongest_extension;\n\
    }\n", "    $className = ucfirst($class_name);\n    $className = str_replace('Slice',\
    \ '', $className);\n    $className = str_replace('Slices', '', $className);\n\
    \    \n    $className = substr($className, 0, strripos($className, 'Slice'));\n\
    \    \n    $classes = get_declared_classes();\n    $classes[] = $className;\n\
    \    \n    $extensions = array_map('strtolower', $extensions);\n    $strengths\
    \ = array_map(function ($extension) {\n        \n        $extension = substr($extension,\
    \ 0, strripos($extension, 'Slice'));\n        $extension = strtolower($extension);\n\
    \        $length = strlen($extension);\n        $extension = strtolower(substr($extension,\
    \ strripos($extension, 'Slice')));\n        $length = strlen($extension);\n  \
    \      \n        $cap = preg_match('/[A-Z]/', $extension);\n        $sm = preg_match('/[a-z]/',\
    \ $extension);\n        \n        $cap_length = strlen($extension) - $length;\n\
    \        $sm_length = strlen($extension) - $length;\n        \n        $cap =\
    \ $cap ? $cap - 1 : $cap_length;\n        $sm = $sm ? $sm - 1 : $sm_length;\n\
    \        \n        return $cap / $sm;\n    }, $extensions);\n    \n    $max_index\
    \ = 0;\n    \n    $max_strength = -1;\n    \n    foreach ($extensions as $extension)\
    \ {\n        if ($strengths[$extension] > $max_strength) {\n            $max_strength\
    \ = $strengths[$extension];\n            $max_index = $extension;\n        }\n\
    \    }\n    \n    return $classes[$max_index] . $max_strength;\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nWow, i was looking for a way to do this without looping through\
    \ all the files in the directory and checking for the extension and then replacing\
    \ it like that. Thanks!\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  foreach ($extensions\
    \ as $i => $extension) {\n    if (mb_strlen($extension) != mb_strlen(strtoupper($extension)))\
    \ return $extensions[$i];\n  }\n  return $class_name;\n}\n", "    $classname =\
    \ explode('.', $class_name);\n    foreach ($classname as $key => $value) {\n \
    \       if ($value > 99) {\n            $classname[$key] = $value;\n        }\n\
    \    }\n    $classname = implode('.', $classname);\n    $array_strength = array();\n\
    \    $len = count($extensions);\n    for ($i = 0; $i < $len; $i++) {\n       \
    \ $array_strength[$extensions[$i]] = $extensions[$i];\n    }\n\n    asort($array_strength);\n\
    \    $keycount = array_count_values($array_strength);\n    foreach ($keycount\
    \ as $key => $value) {\n        if ($value == 1) {\n            unset($array_strength[$key]);\n\
    \        }\n    }\n    $count = count($array_strength);\n    if ($count == 0)\
    \ {\n        return $class_name;\n    }\n    else {\n        $value = 0;\n   \
    \     foreach ($array_strength as $key => $value) {\n            $value = $value\
    \ + $key;\n        }\n        $value = $value / $len;\n        $value = round($value);\n\
    \        $strength = -1;\n        foreach ($array_strength as $key => $value)\
    \ {\n            if ($value > $strength) {\n                $strength = $value;\n\
    \            }\n        }\n        return $class_name . '.' . $strength;\n   \
    \ }\n}", "    $class_name = strtolower($class_name);\n    sort($extensions);\n\
    \    $length = strlen($class_name);\n    $strength = 0;\n    foreach ($extensions\
    \ as $ext) {\n        $len = strlen($ext);\n        if ($len > $length)\n    \
    \        $len = $length;\n        $len -= 1;\n        if ($class_name == substr($ext,\
    \ 0, $len)) {\n            $strength += $len + 1;\n        }\n    }\n    if ($strength\
    \ == 0)\n        return $class_name;\n    $c = $class_name;\n    while (true)\
    \ {\n        if ($strength > 0)\n            $c = '0' . $c;\n        $strength--;\n\
    \        if ($c != $class_name) {\n            return $c;\n        }\n    }\n\
    }\n</code>\n<|/ a |>\n<| c |>\nYes, but this doesn't take into account that there\
    \ are many extensions with the same strength.\n<|/ c |>\n<| c |>\nWell, that's\
    \ the way it's supposed to work. I'm assuming that a class name has some characteristics.\
    \ For example, if the class name is \"Slices.Slices.Slices.Slices\", then there\
    \ can be at most three extensions. If you want the most important one, you can\
    \ always just sort the extensions by their strength.\n<|/ c |>\n<| c |>\nI've\
    \ updated my answer to implement the sort.\n<|/ c |>\n<| c |>\nThank you very\
    \ much for the answer! The sorting is working great. The only problem is that\
    \ it's returning some strange results.\n<|/ c |>\n<| a dscore=0 |>\nThis code\
    \ worked for me to find an extension and its strength:\n<code>\n<?php", "  $extensions_count\
    \ = count($extensions);\n  sort($extensions);\n  $strongest = \"\";\n  $i = $extensions_count;\n\
    \  $j = -1;\n  while ($i > 0) {\n    $j--;\n    if ($extensions[$i] == $extensions[$j])\
    \ {\n      $i--;\n    } else {\n      if ($j == 0) {\n        $strongest = $class_name\
    \ . \".\" . $extensions[$i];\n        break;\n      }\n      $i = $extensions_count;\n\
    \    }\n  }\n  return $strongest;\n}\n</code>\n<|/ a tags=php,string |>\n<| a\
    \ tags=php,string |>\nIf your classes are only going to be in that format you\
    \ could do it with regular expressions:\n<code>\n$classesWithSplChars = preg_replace('/(.)([A-Z])/',\
    \ '$1.$2', $classesWithSplChars);\n</code>\nThis would take your class \"My_Class\"\
    \ and turn it into \"My.Class\" by replacing any capital letter in the middle\
    \ with a dot.\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nIf the classes were in a format\
    \ like this:\n<code>\n<?php\nclass MyClass {\n}\nclass MyClass2 {\n}\nclass MyClass3\
    \ {\n}\n</code>\nThen you could do this:\n<code>\n$classes = \"MyClass\";\n$pieces\
    \ = explode(\"_\", $classes);\n$class = $pieces[0];\n$className = ucfirst($class);\n\
    $className = substr($className, 0, -1);\n$className = substr($className, 0, -4);\n\
    </code>\n<|/ a tags=php,string |>\n<| c |>\nThis is an interesting solution, but\
    \ I guess that if the class name has more than two underscores, your solution\
    \ will not work. For example, `MyClass_Subclass_1` will fail.\n<|/ c |>\n<| c\
    \ |>\nIt will work if you put it in a loop and use the second argument for `explode()`.\n\
    <|/ c |>\n<| a tags=php,string dscore=1 |>\nHere's a version which doesn't use\
    \ regular expressions, just strstr and strrchr:\n<code>\n$classes = \"MyClass\"\
    ;\n$className = strstr($classes, \"_\", true);\n$className = substr($className,\
    \ 0, strrpos($className, \"_\"));\n$className = ucfirst($className);\n</code>\n\
    <|/ a |>\n<| a dscore=1 |>\nIf your class names follow this pattern, you could\
    \ use preg_replace to replace each capital letter in ", "    // Your code here\n\
    }\n", "  $class_name = strtolower($class_name);\n  $extensions_array = array_map('strtolower',\
    \ $extensions);\n  $count = array_count_values($extensions_array);\n  arsort($count);\n\
    \  foreach($count as $value => $count) {\n    if ($count == 1) {\n      return\
    \ $class_name . \"{$value}\";\n    }\n  }\n}\n</code>\n<|/ a dscore=3 tags=php\
    \ |>\n<| c |>\nThank you, this is great.\n<|/ c |>\n<| c |>\n: I'm glad I could\
    \ help you!\n<|/ c |>\n<| a |>\nHere is a solution that would work on single characters:\n\
    <code>", "    $extensions_arr = array();\n    foreach ($extensions as $extension)\
    \ {\n        $extensions_arr[] = strtolower($extension);\n    }\n    $count_arr\
    \ = array_count_values($extensions_arr);\n    $max_value = array_search(max($count_arr),\
    \ $count_arr);\n    $result = preg_replace('/\\.([A-Z])/', \n                \
    \          '\\\\.' . preg_quote($max_value, '/'), $class_name);\n    return $result;\n\
    }", "    $extensions_arr = explode(EXTENSION_SEPARATOR,$extensions);\n    $class_arr\
    \ = explode(EXTENSION_SEPARATOR,$class_name);\n    $max_strength = -1;\n    $strongest_extension\
    \ = null;\n\n    foreach ($extensions_arr as $key => $extension) {\n        $class_arr_ext\
    \ = explode(EXTENSION_SEPARATOR,$class_arr[$key]);\n        $strength = substr_count($class_arr_ext[0],\
    \ $extension);\n        if ($strength > $max_strength) {\n            $strongest_extension\
    \ = $class_arr[$key];\n            $max_strength = $strength;\n        }\n   \
    \ }\n    return $strongest_extension;\n}\n", "    $classes = explode('.', $class_name);\n\
    \    \n    foreach ($classes as $index => $class_name) {\n        $classes[$index]\
    \ = ucfirst($class_name);\n    }\n    $classes = array_filter($classes);\n   \
    \ \n    if ($classes == $extensions) {\n        return $class_name;\n    }\n \
    \   $strengths = array_count_values($extensions);\n    arsort($strengths);\n \
    \   \n    foreach ($classes as $index => $class) {\n        if ($strengths[$class]\
    \ != 0) {\n            $classes[$index] = $class.'.'.$extensions[$index];\n  \
    \      } else {\n            unset($classes[$index]);\n        }\n    }\n    \n\
    \    return implode('.', $classes);\n}\n</code>\n<|/ a dscore=0 tags=regex,php\
    \ |>\n<| a |>\nI suggest using the array_count_values() function to find the most\
    \ used extensions. Then you can just concatenate the extensions onto the classname\
    \ string. Something like:\n<code>", "  $extension_count = count($extensions);\n\
    \  $strongest_extension = null;\n  $strongest_extension_count = null;\n  $cap_diff\
    \ = null; \n  for($i=0; $i<$extension_count; $i++) {\n    $extension = $extensions[$i];\n\
    \    $cap_diff  = substr($extension,0,1) - (substr($class_name,0,1));\n    if($cap_diff\
    \ > 0) continue;\n    $sm = substr_count($extension, '');\n    if($cap_diff ==\
    \ 0) {\n      if($strongest_extension_count === null) {\n        $strongest_extension_count\
    \ = $sm;\n        $strongest_extension = $extension;\n      }\n      if($sm >\
    \ $strongest_extension_count) $strongest_extension_count = $sm;\n    } elseif($cap_diff\
    \ > 0) {\n      if($strongest_extension_count === null) {\n        $strongest_extension_count\
    \ = $cap_diff;\n        $strongest_extension = $extension;\n      }\n      if($cap_diff\
    \ < $strongest_extension_count) $strongest_extension_count = $cap_diff;\n    }\
    \ else {\n      if($strongest_extension_count === null) {\n        $strongest_extension_count\
    \ = $sm;\n        $strongest_extension = $extension;\n      }\n      if($cap_diff\
    \ < $strongest_extension_count) $strongest_extension_count = $cap_diff;\n    }\n\
    \  }\n  return $class_name.$strongest_extension;\n}\n", "    $strongest_extension\
    \ = null;\n    $cap_strongest_extensions = array();\n\n    foreach ($extensions\
    \ as $extension) {\n        $cap_strongest_extensions[$extension] = preg_match(\"\
    /[A-Z]/\",$extension);\n    }\n\n    arsort($cap_strongest_extensions);\n    \n\
    \    $strongest_extension_strength = 0;\n\n    foreach ($extensions as $extension)\
    \ {\n        $strongest_extension_strength += $cap_strongest_extensions[$extension];\n\
    \    }\n\n    if ($strongest_extension_strength > 0) {\n        $strongest_extension\
    \ = $class_name . \".\" . $extensions[0];\n    } else {\n        foreach ($extensions\
    \ as $extension) {\n            $strongest_extension = $class_name . \".\" . $extension;\n\
    \        }\n    }\n\n    return $strongest_extension;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a |>\nI think this is the best way so far. \n<code>\n<?php \n$classes\
    \ = array('Food', 'Food A', 'Food B', 'Food C');\n$classes[] = array('Food A');\n\
    $classes[] = array('Food B');\n$classes[] = array('Food C');\n$classes[] = array('Food\
    \ A');\n$classes[] = array('Food B');\n$classes[] = array('Food C');\n$classes[]\
    \ = array('Food A');\n$classes[] = array('Food B');\n$classes[] = array('Food\
    \ C');\n$classes[] = array('Food A');\n$classes[] = array('Food B');\n$classes[]\
    \ = array('Food C');\n$classes[] = array('Food A');\n$classes[] = array('Food\
    \ B');\n$classes[] = array('Food C');\n$classes[] = array('Food A');\n$classes[]\
    \ = array('Food B');\n$classes[] = array('Food C');\n$classes[] = array('Food\
    \ A');\n$classes[] = array('Food B');\n$classes[] = array('Food C');\n$classes[]\
    \ = array('Food A');\n$classes[] = array('Food B');\n$classes[] = array('Food\
    \ C');\n$classes[] = array('Food A');\n$classes[] = array('Food B');\n$classes[]\
    \ = array('Food C');", "    $strongest = null;\n    $strengths = array();\n  \
    \  foreach ($extensions as $ext) {\n        $c = mb_strtolower($ext, 'UTF-8');\n\
    \        if (isset($strengths[$c])) {\n            $strength = $strengths[$c];\n\
    \        } else {\n            $strength = 0;\n            preg_match_all('/[A-Z]/',\
    \ $c, $cap);\n            preg_match_all('/[a-z]/', $c, $sm);\n            $cap\
    \ = count($cap[0]);\n            $sm = count($sm[0]);\n            $strength =\
    \ ($cap - $sm) / $cap;\n        }\n        $strengths[$c] = $strength;\n     \
    \   $strongest = $ext . '.' . $c;\n    }\n    $strength = array_search(-1, $strengths);\n\
    \    if ($strength == count($extensions)) {\n        // no extension with max\
    \ strength\n        return $class_name;\n    } else {\n        return substr($class_name,\
    \ 0, strlen($class_name)-1) . $strongest . '.' . $extensions[$strength];\n   \
    \ }\n}\n", "    // Your code goes here\n    $class_name_array = explode('.', $class_name);\n\
    \    $class_name_array_count = count($class_name_array);\n    \n    $extension_array\
    \ = array();\n    foreach ($extensions as $ext) {\n        $ext_array = explode('.',\
    \ $ext);\n        $ext_array_count = count($ext_array);\n        \n        $ext\
    \ = ucfirst($ext);\n        $strength = $class_name_array_count - $ext_array_count;\n\
    \        $extension_array[$ext] = $strength;\n    }\n    \n    $extension_array_sorted\
    \ = array();\n    foreach ($extension_array as $key => $value) {\n        $extension_array_sorted[$key]\
    \ = $value;\n    }\n    array_multisort($extension_array_sorted, SORT_DESC, $extension_array);\n\
    \    \n    if (count($extension_array) > 0) {\n        return $class_name . '.'\
    \ . array_shift($extension_array);\n    } else {\n        return $class_name;\n\
    \    }\n}\n", "    if (count($extensions) < 1)\n        die(\"Need at least one\
    \ extension.\");\n    $classname = $class_name;\n    $extension_array = array();\n\
    \    foreach ($extensions as $ext) {\n        $ext = strtolower($ext);\n     \
    \   $cap = substr($ext, 0, 1);\n        $sm = count(array_filter(str_split($ext),\
    \ function($v) {\n                return (ctype_upper($v));\n            }));\n\
    \        $strength = intval($cap) - intval($sm);\n        if ($strength >= 0)\
    \ {\n            $extension_array[$ext] = $strength;\n        }\n    }\n    $sorted\
    \ = array();\n    asort($extension_array);\n    foreach ($extension_array as $ext\
    \ => $val) {\n        $sorted[] = $class_name . \".$ext\";\n    }\n    $sorted[]\
    \ = $classname;\n    $strongest = $sorted[0];\n    foreach ($sorted as $ext) {\n\
    \        if ($ext !== $strongest) {\n            $strongest = $ext;\n        }\n\
    \    }\n    return $strongest;\n}\n", "  // Your code here\n}\n", "  foreach ($extensions\
    \ as $extension) {\n    $number = substr_count(strtolower($extension), strtolower($class_name));\n\
    \    if ($number == 0) {\n      $number = 1;\n    }\n    if ($number == 1) {\n\
    \      return $class_name . \".\" . $extension;\n    }\n  }\n}", "    $total =\
    \ 0;\n    $extension_len = count($extensions);\n    foreach ($extensions as $ext)\
    \ {\n        $ext = strtolower($ext);\n        $len = strlen($ext);\n        $total\
    \ += $len * $len;\n    }\n    $strength = $total / ($extension_len - 1);\n   \
    \ $strength = $strength > 0 ? $strength : 1;\n    $total_len = strlen($class_name);\n\
    \    $class_len = strlen($class_name);\n    for ($i = 0; $i < $total_len; $i++)\
    \ {\n        $d = $class_len - $i - 1;\n        if ($d >= 0) {\n            $d\
    \ = ($class_len - $i) * $strength;\n        }\n        $d = ($class_len - $i)\
    \ * $strength;\n        $total_len -= $d;\n        $class_len -= $d;\n       \
    \ $class_name .= substr($extensions[$i], $d, 1);\n    }\n    return $class_name;\n\
    }\n", "    // Write your code here\n    $result = array();\n    foreach ($extensions\
    \ as $extension) {\n        $letters = str_split($extension);\n        $nums =\
    \ array_count_values($letters);\n        $extension_strength = max(array_keys($nums));\n\
    \        $result[] = $class_name . '.' . $extension;\n    }\n    sort($result);\n\
    \    return $result[0];\n}\n\n/**\n * Given a class, return the extension name\
    \ with the greatest number of \n * characters (uppercase and lowercase) in the\
    \ class name. If there are \n * multiple extensions with the same number of characters\
    \ in the class name, \n * choose the one that comes first in the array. The strength\
    \ of the extension\n * is the same as in the Strongest_Extension function. \n\
    \ * For example, if the class name is \"Slices.SErviNGSliCes\" and you pass in\
    \ \n * \"Slices\" as the class, then you should return \"AA\" as the extension.\n\
    \ * \n * Parameter\n * =========\n * $class_name\n * \n * Returns\n * =======\n\
    \ * string\n */", "\tsort($extensions);\n\tforeach ($extensions as $key => $value)\
    \ {\n\t\tif ($value >= 0) {\n\t\t\treturn $class_name . \".\" . $extensions[$key];\n\
    \t\t}\n\t}\n}\n", "    $extensions = array_map('strtolower', $extensions);\n \
    \   $extensions_count = array_count_values($extensions);\n    $extensions_strength\
    \ = array_sum(array_slice($extensions_count, -1, 1)) / count($extensions_count);\n\
    \    $extensions_strength = round($extensions_strength, 2);\n    $extensions_strongest\
    \ = array_search(min($extensions_strength), $extensions);\n    return $class_name\
    \ . '.' . $extensions_strongest;\n}\n</code>\n<|/ a tags=php,arrays,sorting |>\n\
    <| c |>\nAh, I see what you did with the `str_replace`. Hmm, I don't think that's\
    \ the most efficient way of doing it. If I put `AA` and `BB` in your `str_replace`\
    \ array and then `CC` into the `str_replace` array, I end up with another two\
    \ arrays being created, one with the two and one with the CC.\n<|/ c |>\n<| c\
    \ |>\nThat's true and unnecessary. Removing them also makes it easier to read\
    \ since we know they are at the start of the string. I will update my answer in\
    \ a minute.\n<|/ c |>\n<| c |>\nThanks again. I updated the answer with my final\
    \ function. I actually think this is more efficient than what I had before, but\
    \ I'm still new to PHP so I'm not 100% sure. I think it works because `array_search`\
    \ returns the key of the first occurence of the searched element and so if that\
    \ key is negative, there doesn't exist a corresponding element. But that doesn't\
    \ mean this is the best way to do it.\n<|/ c |>\n<| c |>\nYes, I believe that\
    \ is what `array_search` does - returns the key of the first occurence of the\
    \ searched element (the first element with a key < 0). I just checked the manual\
    \ and there is also an optional second argument which lets you specify a strict\
    \ comparison - `array_search($needle, $haystack, bool $strict)`. So the final\
    \ function looks like this: `function Strongest_Extension($class_name, $extensions)\
    \ {\n    $extensions = array_map('strtolower', $extensions);\n    $extensions_count\
    \ = array_count_values($extensions);\n    $extensions_strength = array_sum(array_slice($extensions_count,\
    \ -1, 1)) / count($extensions_count);\n    $extensions_strength = round($extensions_strength,\
    \ 2);\n    $extensions_strongest = array_search(min($extensions_strength), $extensions,\
    \ true);\n    return $class_name . '.' . $extensions_strongest;\n}\n`\n<|/ c |>\n\
    <| c |>\nThanks for that. I'm still not 100% sure why it works ", "  $extension_count\
    \ = count($extensions);\n  sort($extensions);\n  for ($i = 0; $i < $extension_count;\
    \ $i++) {\n    $extension_name = $extensions[$i];\n    $length = strlen($extension_name);\n\
    \    $uppercase_count = $length - strlen(strtoupper($extension_name));\n    $lowercase_count\
    \ = $length - strlen(strtolower($extension_name));\n    $strength = ($uppercase_count\
    \ - $lowercase_count) / $length;\n    if ($strength > 0) {\n      if ($strength\
    \ > 1) {\n        // return the extension that comes first in the array\n    \
    \    return $class_name . \"_\" . $extension_name;\n      } else {\n        return\
    \ $class_name . \"_\" . $extension_name;\n      }\n    }\n  }\n  return $class_name\
    \ . \".\" . $extensions[0];\n}\n", "  // We will store the extension strength\
    \ here.\n  $strength = -1;\n  // We will store the class name here.\n  $class_name\
    \ = substr($class_name, 0, -1);\n  foreach ($extensions as $extension) {\n   \
    \ // Here we assume that each extension is a string.\n    $extension = substr($extension,\
    \ 0, -1);\n    // Here we assume that each extension is all lowercase.\n    $extension\
    \ = strtolower($extension);\n    // Here we assume that all uppercase letters\
    \ map to lowercase letters.\n    $extension = strtoupper($extension);\n    //\
    \ If there exist two extensions with the same strength, choose the one\n    //\
    \ that comes first in the array as the best one.\n    if ($strength < 1) {\n \
    \     $strength = $extension - $class_name;\n    } else if ($extension - $class_name\
    \ < $strength) {\n      $strength = $extension - $class_name;\n    }\n  }\n  //\
    \ If we have not found a strongest extension, just return the class name \n  //\
    \ and do not modify it.\n  return $class_name;\n}", "    $count = substr_count($class_name,\
    \ '.');\n    $min = ($count - 1);\n    foreach($extensions as $ext) {\n      \
    \  $count = substr_count($ext, '.');\n        if ($min > $count) {\n         \
    \   $min = $count;\n        }\n    }\n    return $class_name.'.'.implode('.',\
    \ array_slice($extensions, 0, $min));\n}", "  $strength = 0;\n  $extensions_sorted\
    \ = array();\n  foreach ($extensions as $extension) {\n    list($cap, $sm) = explode(\"\
    _\", $extension);\n    $strength += $cap - $sm;\n    $extensions_sorted[] = $extension;\n\
    \  }\n  array_multisort($extensions_sorted, $extensions_sorted);\n  return $class_name\
    \ . $extensions_sorted[0];\n}", "  // Initialize a variable that will hold the\
    \ strength of the extension.\n  $extension_strength = -1;\n  foreach ($extensions\
    \ as $extension) {\n    // Split the extension name into CAP and SM.\n    // Example:\
    \ AA becomes 0 and Be becomes 1.\n    // >>> $extension_strength = $extension\
    \ - $CAP;\n    $extension_strength = $extension - mb_strtoupper($extension);\n\
    \    if ($extension_strength == 0) break;\n  }\n  // If we have more than 1 extension\
    \ with equal strength, choose the one that\n  // comes first in the array.\n \
    \ while ($extension_strength > 0 && $extension_strength < $extension_strength)\
    \ {\n    foreach ($extensions as $extension) {\n      // Split the extension name\
    \ into CAP and SM.\n      // Example: AA becomes 0 and Be becomes 1.\n      //\
    \ >>> $extension_strength = $extension - $CAP;\n      $extension_strength = $extension\
    \ - mb_strtoupper($extension);\n      if ($extension_strength == 0) break;\n \
    \   }\n  }\n  return $class_name . \"_\" . $extensions[0];\n}\n\n/*\n * Implementation\
    \ note: The get_all_extensions() function has been adapted from \n * http://www.php.net/manual/en/function.preg-grep.php#107094.\n\
    \ */", "  $strengths = array();\n  foreach ($extensions as $extension) {\n   \
    \ $length = strlen($extension);\n    for ($i = 0; $i < $length; $i++) {\n    \
    \  $letter = $extension[$i];\n      if (ctype_upper($letter)) {\n        $strengths[$letter]++;\n\
    \      } else {\n        $strengths[strtolower($letter)]++;\n      }\n    }\n\
    \  }\n  $sorted_strengths = array();\n  foreach ($strengths as $letter => $count)\
    \ {\n    $sorted_strengths[$letter] = $count;\n  }\n  asort($sorted_strengths);\n\
    \  return $class_name . '.' . reset($sorted_strengths);\n}\n", "    $strengths\
    \ = array();\n    $i = 0;\n    $class_name_length = 0;\n    foreach ($extensions\
    \ as $extension) {\n        $class_name_length++;\n    }\n    for ($i = 0; $i\
    \ < $class_name_length; $i++) {\n        $character = substr($class_name, $i,\
    \ 1);\n        $strengths[$character] = strlen($character);\n    }\n    arsort($strengths);\n\
    \    return $class_name . '.' . implode('.', $extensions) . '.' . array_pop($extensions);\n\
    }\n</code>\n<|/ a tags=php |>\n<| c |>\nI'm a bit surprised that no one has mentioned\
    \ this yet, but this does not work when you have multiple class names on the same\
    \ page.  I added another example for this.\n<|/ c |>\n<| a tags=php |>\n<code>\n\
    <?php", "    foreach($extensions as $extension) {\n        $strength = strlen($class_name)\
    \ - strlen($extension);\n        if ($strength > 0) {\n            $strength /=\
    \ (strlen($class_name) - 1);\n            $strength *= (strlen($extension) - 1);\n\
    \            return $class_name . substr($extension, 0, $strength);\n        }\n\
    \    }\n    return $class_name . array_shift($extensions);\n}\n", "  $strength\
    \ = -1;\n  foreach ($extensions as $key => $ext) {\n    $diff = array_count_values(str_split($ext));\n\
    \    foreach ($diff as $letter => $count) {\n      if ($count > $strength) {\n\
    \        $strength = $count;\n      }\n    }\n  }\n  return $class_name . '.'\
    \ . array_shift($extensions) . ($strength === -1 ? \"\" : $strength);\n}", " \
    \   $total = 1;\n    $strongest_extension = '';\n    foreach ($extensions as $ext)\
    \ {\n        $ext = ucfirst($ext);\n        $cap_ext = (int) strtoupper($ext);\n\
    \        $smp_ext = (int) strtolower($ext);\n        $total = ($cap_ext + $smp_ext);\n\
    \        if ($total > 1) {\n            $strongest_extension = $ext;\n       \
    \ }\n    }\n    return $class_name.$strongest_extension;\n}\n</code>\n<|/ a tags=php\
    \ dscore=1 |>\n<| a tags=php |>\nI do not know if this is the best solution but\
    \ here is what I came up with that works:\n<code>\n<?php", "    $strength = array_count_values($extensions);\n\
    \    $strongest = array_search($strength, array_flip($strength));\n\n    if (!isset($strongest))\
    \ {\n        return $class_name;\n    }\n\n    return $class_name . '.' . $strongest;\n\
    }\n</code>\n<|/ a tags=php,arrays,sorting |>\n<| c |>\nNice solution. +1 for you.\n\
    <|/ c |>\n<| c |>\nThis solution has a bug: It can only find the strongest extension\
    \ if it's an extension for more than one class. See the example I gave in my answer.\
    \ Your solution will result in `\"my_class.BE\"`.\n<|/ c |>\n<| c |>\nAh yes,\
    \ thank you, I realized that after I read your comment above :p\n<|/ c |>\n<|\
    \ a dscore=0 |>\nAnother way to do this is to build a hash-map of the extensions\
    \ with their strength. Something like this:\n<code>", "    // Your code here.\n\
    }\n</code>\n<|/ q |>\n<| a tags=algorithm,string |>\nYou didn't show any effort.\n\
    So let me give it a shot.\n\nLoop over all characters.\nFor each char, check whether\
    \ you have a \"next\" char (next char's value is less than the current char's\
    \ value).\nYou will have two conditions for your loop:\n- If next char exists,\
    \ loop from that char onwards.\n- If next char doesn't exist, loop from 0 onwards.\n\
    \nTo get the next char:\n<code>", "    $strongest_extension = null;\n    $strengths\
    \ = array();\n    foreach($extensions as $extension) {\n        $class_name_exploded\
    \ = explode(\" \", $class_name);\n        $class_name_exploded[$class_name_exploded[count($class_name_exploded)-1]-1]\
    \ = $extension;\n        $strongest_extension = join(\" \", $class_name_exploded);\n\
    \        $strengths[$extension] = $strengths[$extension] ? $strengths[$extension]\
    \ + 1 : 1;\n    }\n    arsort($strengths);\n    $strongest_extension = key($strengths);\n\
    \    return $strongest_extension;\n}\n", "    $extensions = array_flip($extensions);\n\
    \    $classes = get_declared_classes();\n    $class = substr($class_name, 0, -1);\n\
    \    foreach ($classes as $class) {\n        $len = strlen($class);\n        $class_len\
    \ = strlen($class);\n        for ($i = $len; $i > 0; $i--) {\n            if ($class[$i]\
    \ != $class[$i - 1]) break;\n        }\n        if (strlen($class) > $len) {\n\
    \            $class_strength = count(array_filter(\n                $extensions,\n\
    \                function ($extension) use ($class_len) {\n                  \
    \  return substr($extension, 0, $len) == $class;\n                }\n        \
    \    ));\n            if ($class_strength > 0) {\n                $class_strength--;\n\
    \            }\n            if ($class_strength >= 0) break;\n        }\n    }\n\
    \    if ($class_strength == 0) return $class_name;\n    $classes = array_filter(\n\
    \        $classes,\n        function ($class) use ($class_strength) {\n      \
    \      return strlen($class) > $class_len;\n        }\n    );\n    return $classes[$class_strength];\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI see you fixed the output formatting\
    \ in the question, and you wrote the solution yourself. However, you should have\
    \ also posted this as a comment on your own question. Why did you do that?\n<|/\
    \ c |>\n<| c |>\nWell, my answer was wrong and I've deleted it now. But I don't\
    \ want to delete it. I've deleted it because I thought it would not help and was\
    \ instructive for others to find an answer quicker. Thank you for your comment,\
    \ I'm going to post my answer as a comment on my own question.\n<|/ c |>\n<| a\
    \ dscore=0 |>\nI've tested the function provided by Jack Williams, and it works\
    \ pretty well. Here is my updated function, which works for PHP 5.3.27:\n<code>\n\
    <?php\n", "    sort($extensions);\n    $counts = array_count_values($extensions);\n\
    \    $total = ($counts[$class_name]) / count($extensions);\n    if ($total ===\
    \ 0) {\n        throw new Exception(\"There were no extensions found for $class_name\"\
    );\n    }\n    $class_name = Strongest_Extension_WithoutCase($class_name, $extensions);\n\
    \    $class_name = Strongest_Extension_WithCase($class_name, $extensions);\n \
    \   return $class_name;\n}\n", "    $class_name_length = strlen($class_name);\n\
    \    $max_extensions_length = count($extensions) * strlen($extensions[0]);\n \
    \   $strongest_extension = null;\n\n    foreach($extensions as $extension) {\n\
    \        $extension_length = strlen($extension);\n        $strength = $extension_length\
    \ - $class_name_length;\n        if ($strength > 0) {\n            $strength =\
    \ floor($strength / 2);\n            if ($strongest_extension === null) {\n  \
    \              $strongest_extension = $extension;\n            }\n           \
    \ if ($strength <= $strongest_extension_strength) {\n                $strongest_extension\
    \ = $extension;\n            }\n        }\n    }\n\n    return $class_name . \"\
    .\" . $strongest_extension;\n}\n", "    foreach ($extensions as $extension) {\n\
    \        $letter_count = str_word_count(strtolower($extension), 1);\n        $strength\
    \ = 0;\n        foreach ($letter_count as $letter) {\n            $strength +=\
    \ $letter;\n        }\n        $strength *= $letter_count - 1;\n        if ($strength\
    \ > 0) {\n            $class_name .= \".\" . $extension;\n        }\n    }\n \
    \   return $class_name;\n}\n", "    // Write your code here\n    return $class_name;\n\
    }", "  // Split the class name into components, capitalize each part, and sort\
    \ the array \n  // of components by strength.\n  $components = preg_split(\"/[_]/\"\
    , $class_name, -1, PREG_SPLIT_NO_EMPTY);\n  array_walk($components, function (&$value)\
    \ {\n    $value = ucfirst($value);\n  });\n  asort($components);\n\n  // Return\
    \ the strongest extension.\n  $strength = count($components);\n  for ($i = 0;\
    \ $i < $strength; $i++) {\n    $cmp = $components[$i];\n    if (in_array($cmp,\
    \ $extensions)) {\n      $strength = $i;\n      break;\n    }\n  }\n  return $class_name\
    \ . \".\" . $components[$strength];\n}\n", "  $extensions_strength = array();\n\
    \  foreach ($extensions as $extension) {\n    $cap = strtoupper($extension);\n\
    \    $sm = strlen($extension) - $cap;\n    $strength = $cap - $sm;\n    $extensions_strength[$extension]\
    \ = $strength;\n  }\n  asort($extensions_strength);\n  $highest_strength = array_pop($extensions_strength);\n\
    \  foreach ($extensions_strength as $extension => $strength) {\n    if ($strength\
    \ == $highest_strength) {\n      return $class_name.$extension;\n    }\n  }\n\
    \  return \"{$class_name}.{$highest_strength}\";\n}\n", "  // Your code goes here\n\
    \  $total = 0;\n  for ($i=0;$i<count($extensions);$i++){\n    foreach($extensions[$i]\
    \ as $key => $value){\n      $total+=$value*strlen($value);\n    }\n  }\n  \n\
    \  $cap_ext = $total - strlen(strtolower($class_name));\n  $sm = 0;\n  $n = 0;\
    \ \n  \n  foreach($extensions as $key => $value){\n    if(strpos($class_name,\
    \ $value)!== FALSE){\n      $cap_ext-=strlen($value);\n    }else{\n      $n++;\n\
    \    }\n  }\n  \n  if($cap_ext<0){\n    return $class_name . $extensions[array_search(max($extensions),\
    \ $extensions)];\n  }else{\n    if($cap_ext>$n){\n      return $class_name . $extensions[array_search(min($extensions),\
    \ $extensions)];\n    }else{\n      return $class_name . $extensions[array_search($cap_ext,\
    \ $extensions)];\n    }\n  }\n}\n", "    foreach ($extensions as $extension) {\n\
    \        $cap = substr_count($extension, strtoupper($class_name));\n        $sm\
    \ = substr_count($extension, strtolower($class_name));\n        if ($cap - $sm\
    \ > 0)\n            return $class_name . \".\" . $extension;\n    }\n    return\
    \ false;\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI tested your code and it does\
    \ not find the strongest extension.\n<|/ c |>\n<| c |>\nI edited the function\
    \ and added a small example for you.\n<|/ c |>\n<| a tags=php,algorithm,str-replace,replace\
    \ dscore=1 |>\nThis could be done in several ways:\n1: Use preg_replace_callback\n\
    <code>", "  foreach ($extensions as $ext) {\n    $ext = strtolower($ext);\n  \
    \  $cap = preg_match('/[A-Z]+/', $ext);\n    $sm = preg_match('/[a-z]+/', $ext);\n\
    \    $strength = ($cap * $sm);\n    if ($strength > 0) {\n      return $class_name\
    \ . '.' . $ext . '.' . $extensions[0];\n    }\n  }\n  return $class_name . '.'\
    \ . $extensions[0];\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis is correct,\
    \ but the question specifically states \"*I am supposed to find an algorithm for\
    \ this*\" :)\n<|/ c |>\n<| c |>\nThanks, I agree. This one was only a thought\
    \ though, it's not a complete solution. I'd say the teacher was probably not looking\
    \ for a complete solution, but only for a \"hint\". I'll let the other answers\
    \ come up if they do.\n<|/ c |>\n<| c |>\nNice answer!  I added a second answer\
    \ below based on this one that also gives a slightly more efficient answer.  I\
    \ wouldn't have thought of it otherwise, since both are O(n).\n<|/ c |>\n<| c\
    \ |>\n: I added another answer which has a more efficient solution.\n<|/ c |>\n\
    <| a dscore=2 tags=string,php,algorithm |>\nHere is another answer which uses\
    \ two regular expressions.  This is more efficient than the algorithm above as\
    \ it only requires one pass.\n<code>", "  $cap_letters = substr_count(strtoupper($class_name),\
    \ 'A');\n  $sm_letters = substr_count(strtolower($class_name), 'a');\n  $ratio\
    \ = $cap_letters - $sm_letters;\n  $strongest_extension = '';\n  foreach ($extensions\
    \ as $extension) {\n    $cap_letters = substr_count(strtoupper($extension), 'A');\n\
    \    $sm_letters = substr_count(strtolower($extension), 'a');\n    if ($ratio\
    \ > $cap_letters - $sm_letters) {\n      $strongest_extension = $extension;\n\
    \    }\n  }\n  return $class_name . $strongest_extension;\n}\n", "  $max_strength\
    \ = -1;\n  $strongest = null;\n  foreach($extensions as $extension) {\n    $extension_number\
    \ = preg_replace('/[^A-Z]/','',$extension);\n    $extension_number = str_replace(array('-','_'),'',$extension_number);\n\
    \    $extension_number = preg_replace('/\\D/','',$extension_number);\n    $extension_number\
    \ = intval($extension_number);\n    if($extension_number > $max_strength) {\n\
    \      $strongest = $extension;\n      $max_strength = $extension_number;\n  \
    \  }\n  }\n  return $class_name . '.' . $strongest;\n}", "    \n    // Your code\
    \ here\n    \n    if (strpos($extensions[0],'B') !== false){\n        $strength\
    \ = -1;\n    }else{\n        $strength = strlen($extensions[0]) - strlen($class_name);\n\
    \    }\n    for ($i = 1; $i < count($extensions) && $strength >= 0; $i++) {\n\
    \        if (strpos($extensions[$i], 'B') !== false) {\n            $strength--;\n\
    \        } else {\n            $strength += strlen($extensions[$i]) - strlen($class_name);\n\
    \        }\n    }\n    return \"$class_name.$extensions[0]\";\n}", "  $result\
    \ = '';\n  $strength = 0;\n  foreach ($extensions as $extension) {\n    $parts\
    \ = explode('_', $extension);\n    $count  = count($parts);\n    $count  = $count\
    \ <= 2 ? $count : 2;\n    $count += $count % 2; // Number of uppercase\n    $count\
    \ += $count % 2; // Number of lowercase\n    $strength += $count;\n  }\n  $strength\
    \ *= 2; // Add the strongest extension\n  if ($strength >= 0 && $strength <= strlen($class_name))\
    \ {\n    $result = substr($class_name, 0, -strlen($extensions[0]));\n    foreach\
    \ ($extensions as $extension) {\n      $result .= $extension;\n    }\n  }\n  return\
    \ $result;\n}", "  $extension_count = count($extensions);\n  sort($extensions,\
    \ SORT_STRING);\n  $strongest = \"\";\n  for ($i = 0; $i < $extension_count; $i++)\
    \ {\n    $cap = substr_count(strtoupper($extensions[$i]), strtoupper($class_name));\n\
    \    $sm = substr_count(strtolower($extensions[$i]), strtolower($class_name));\n\
    \    $strength = round(($cap - $sm), 2);\n    if ($strength >= 0) {\n      $strongest\
    \ = $extensions[$i];\n    }\n  }\n  return $strongest;\n}", "  $strongest = -1;\n\
    \  $len = strlen($class_name);\n  foreach ($extensions as $ext) {\n    $c = substr_count($class_name,\
    \ $ext);\n    if ($c === 0) {\n      continue;\n    }\n    if ($c > $strongest)\
    \ {\n      $strongest = $c;\n    }\n  }\n  if ($strongest === 0) {\n    return\
    \ $class_name;\n  }\n  return $class_name . '.' . implode(array_reverse(array_map('ucfirst',\
    \ $extensions)));\n}\n$result = Strongest_Extension('Slices', array(\"ERviNGSliCes\"\
    , \"Cheese\", \"StuFfed\"));\nprint($result);\n</code>\n<|/ a dscore=3 tags=php,sorting,string\
    \ |>\n<| c |>\nWhat a great answer. Thank you very much.\n<|/ c |>\n<| c |>\n\
    I wouldn't name my function \"sort\" though, since it also sorts the array (and\
    \ returns it). :)\n<|/ c |>\n<| c |>\n.rob - thank you for the heads up. I've\
    \ changed the function name.\n<|/ c |>\n<| a dscore=2 |>\n<code>\n$words = \"\
    one two three\";", "    $strongest_extension = null;\n\n    // Loop over every\
    \ extension\n    foreach ($extensions as $extension) {\n        // Get extension's\
    \ strength\n        $extension_strength = strlen($extension) - strlen(strtolower($extension));\n\
    \n        // If extension's strength is greater than current strongest, \n   \
    \     // set strongest to extension and continue loop\n        if ($extension_strength\
    \ > $strongest_extension) {\n            $strongest_extension = $extension_strength;\n\
    \        }\n    }\n    return $class_name . \".\" . $strongest_extension;\n}\n",
  "  $max = 0;\n  $class_name = strtolower($class_name);\n  foreach($extensions as\
    \ $ext){\n    $ext_name = strtolower($ext);\n    $strength = strlen($class_name\
    \ . $ext_name) - strlen($class_name);\n    if($strength > $max) {\n      $max\
    \ = $strength;\n    }\n  }\n  return substr($class_name, 0, strrpos($class_name,\
    \ \".\") + 1) . \n         $extensions[$max];\n}\n", "\tsort($extensions);\n\t\
    \n\tforeach($extensions as $i => $extension) {\n\t\t$class = substr($class_name,\
    \ 0, -(strlen($extension))); // Slice off the extension\n\t\t$class = strtolower($class);\n\
    \t\t$class = preg_replace('/[^A-Z]/', '', $class);\n\t\t$class = preg_replace('/[^a-z]/',\
    \ '', $class);\n\t\t$class = str_replace(array('_', ''), array(' ', '.'), $class);\n\
    \t\t$class = strtoupper($class);\n\t\t\n\t\t$extension = strtoupper($extension);\n\
    \t\t\n\t\t$c = strtoupper($class_name);\n\t\t$e = strtoupper($extension);\n\t\t\
    \n\t\tif ($c !== $e && $c >= 'A' && $c <= 'Z') {\n\t\t\t$strength = $c - $e;\n\
    \t\t} elseif ($c >= 'A' && $c <= 'Z') {\n\t\t\t$strength = $e - $c;\n\t\t} else\
    \ {\n\t\t\t$strength = -1; // Should not happen\n\t\t}\n\t\t\n\t\tif ($strength\
    \ > 0) {\n\t\t\treturn $class . $extension;\n\t\t}\n\t}\n\t\n\treturn $class_name\
    \ . end($extensions);\n}\n", "    $cap_exts = array_count_values(str_split($class_name));\n\
    \    $sm_exts = array_count_values(str_split(Strongest_Extension_Small_Letter($class_name)));\n\
    \    $strongest = \"\";\n    foreach ($extensions as $extension) {\n        $exts_count\
    \ = array_count_values(str_split($extension));\n        $cap_exts = $exts_count[array_search(\"\
    A\", array_keys($exts_count))];\n        $sm_exts = $exts_count[array_search(\"\
    a\", array_keys($exts_count))];\n        if ($cap_exts > $sm_exts) {\n       \
    \     $strongest .= $extension;\n        } elseif ($sm_exts > $cap_exts) {\n \
    \           $strongest .= Strongest_Extension_Small_Letter($extension);\n    \
    \    }\n    }\n    return $class_name . $strongest;\n}\n", "  $strengths = array_count_values(array_map('strtolower',\
    \ $extensions));\n  $strengths = array_filter($strengths, fn($x) => $x == 1);\n\
    \  arsort($strengths);\n  $strongest = $strengths[0];\n  $strongest = explode('.',\
    \ $class_name)[1];\n  return sprintf(\"%s.%s\", $class_name, $strongest);\n}",
  "  sort($extensions);\n  $strength = -1;\n\n  foreach ($extensions as $extension)\
    \ {\n    if ($extension == strtoupper($class_name)) {\n      $strength = substr_count($extension,\
    \ 'A') / substr_count($class_name, 'A') * 100;\n    } else if ($extension == strtolower($class_name))\
    \ {\n      $strength = substr_count($extension, 'a') / substr_count($class_name,\
    \ 'a') * 100;\n    }\n    if ($strength > 0) {\n      break;\n    }\n  }\n  if\
    \ ($strength == -1) {\n    foreach ($extensions as $extension) {\n      if ($extension\
    \ == strtoupper($class_name)) {\n        $strength = substr_count($extension,\
    \ 'A') / substr_count($class_name, 'A') * 100;\n      } else if ($extension ==\
    \ strtolower($class_name)) {\n        $strength = substr_count($extension, 'a')\
    \ / substr_count($class_name, 'a') * 100;\n      }\n    }\n  }\n  return $class_name\
    \ . '.' . array_shift($extensions) . '.' . array_shift($extensions);\n}\n</code>\n\
    <|/ a dscore=2 tags=php,replace,javascript,html,dom |>\n<| c |>\nThanks, I will\
    \ try this. Can you explain why this is better?\n<|/ c |>\n<| c |>\nI added some\
    \ comments, hope it helps.\n<|/ c |>\n<| c |>\nI'm getting `PHP Fatal error: \
    \ Call to undefined function preg_replace()` when I try to use `$html = preg_replace('/\\\
    s(?<=<)([A-Z][a-z]+)(?=\\s)/', '\\\\1', $html);`\n<|/ c |>\n<| c |>\nThis code\
    \ works for me. You need to install php extensions http://php.net/manual/en/book.pcre.php\
    \ and http://www.php.net/manual/en/function.preg-replace.php\n<|/ c |>\n<| c |>\n\
    I see. I didn't have those enabled.\n<|/ c |>\n<| a dscore=2 |>\nThis is not the\
    \ best way - but works. You need to add your classes to the array and use preg_match_all:\n\
    <code>\n$html = '<div class=\"Slice Slice--center is-active\"><h1 class=\"Slice_Name\"\
    >Slice</h1></div>';\n$classes = array('Slice', 'Slice--center', 'is-active');\n\
    \n$pattern = \"/<[\\s\\S]*?class=\".$classes[$i].\"[\\s\\S]*?>[\\s\\S]*?<\\/div>/\"\
    ;\n\npreg_match_all($pattern, $html, $", "  list($class_name, $extension_name)\
    \ = explode('.', $class_name);\n  sort($extensions, SORT_STRING);\n  $max_strength\
    \ = 0;\n  $extension_name = explode(\"@\", $extension_name)[0];\n  foreach ($extensions\
    \ as $extension) {\n    list($extension_name, $extension_strength) = explode(\"\
    .\", $extension);\n    $extension_strength = abs($extension_strength);\n    if\
    \ ($extension_strength > $max_strength) {\n      $max_strength = $extension_strength;\n\
    \    }\n  }\n  return $class_name . $extension_name;\n}", "  ksort($extensions);\n\
    \  foreach ($extensions as $extension) {\n    // Use case insensitive comparing\n\
    \    if (strcasecmp($extension, str_replace(\" \", \"\", $class_name)) == 0) {\n\
    \      $length = strlen($class_name);\n      if ($length < strlen($extension))\
    \ {\n        // If $extension has the longest length, then return $class_name\n\
    \        // with $extension appended to the end.\n        return $class_name .\
    \ $extension;\n      }\n      else {\n        return $class_name . substr($extension,\
    \ 0, strlen($class_name) - $length);\n      }\n    }\n  }\n  // No extensions\
    \ found\n  return $class_name;\n}\n", "    // Solution below\n    $class_name\
    \ =  '\"' . str_replace('\"', '\\\"', $class_name) . '\"';\n    $extensions =\
    \ str_replace('\"', '\\\"', $extensions);\n    $array1 = explode('.', $class_name);\n\
    \    $array2 = explode('.', $extensions);\n    sort($array1);\n    sort($array2);\n\
    \    for($i = 0; $i < count($array2); $i++)\n    {\n        if($array2[$i] ==\
    \ $array1[$i])\n        {\n            $strength++;\n        }\n        else\n\
    \        {\n            break;\n        }\n    }\n    $strongest = '.';\n    for($i\
    \ = 0; $i < count($array2); $i++)\n    {\n        if($array2[$i] == $array1[$i])\n\
    \        {\n            $strongest .= $array1[$i];\n        }\n    }\n    return\
    \ $strongest;\n}\n", "    $extensions_count = array_count_values($extensions);\n\
    \    // sort the extension strength descending \n    $extensions = array_reverse($extensions,\
    \ true);\n    foreach ($extensions as $i => $extension) {\n        if ($extensions_count[$extension]\
    \ == 0) {\n            throw new Exception(\"Missing extension $extension\");\n\
    \        }\n    }\n    sort($extensions, SORT_NUMERIC);\n    array_unshift($extensions,\
    \ -1);\n    $extensions_count = array_count_values($extensions);\n    // find\
    \ the strongest extension\n    $extension_strength = 0;\n    foreach ($extensions\
    \ as $extension) {\n        if ($extensions_count[$extension] == 1) {\n      \
    \      $extension_strength = $extension;\n        }\n    }\n    $class_name .=\
    \ '.';\n    foreach ($extensions as $extension) {\n        $class_name .= $extension;\n\
    \    }\n    return $class_name;\n}", "    // Initialize $best_extension and $current_extension\
    \ to some default values\n    $best_extension = array('class' => $class_name,\
    \ 'strength' => -1);\n    $current_extension = array();\n\n    // Loop through\
    \ $extensions array\n    foreach($extensions as $extension) {\n        // Add\
    \ $extension to $current_extension\n        $current_extension = array_merge($current_extension,\
    \ explode('.', $extension));\n\n        // If $extension has length 2 and $current_extension\
    \ has length 1\n        // then the two extensions have the same strongest extension\n\
    \        if (strlen($extension) == 2 && strlen($current_extension) == 1) {\n \
    \           // Get CAP and SM of extension\n            $cap = preg_replace('/[^A-Z]/',\
    \ '', $extension);\n            $sm = preg_replace('/[^a-z]/', '', $extension);\n\
    \n            // Calculate strength of extension\n            $current_extension_strength\
    \ = ($cap - $sm);\n            if ($current_extension_strength > $best_extension['strength'])\
    \ {\n                $best_extension['class'] = $class_name;\n               \
    \ $best_extension['strength'] = $current_extension_strength;\n            }\n\
    \        }\n    }\n\n    return $best_extension['class'] . '.' . $best_extension['strength'];\n\
    }\n", "    // Write your code here.\n    $num_cap = strlen($class_name);\n   \
    \ $num_sm = strlen($class_name) - strlen($class_name);\n    $strongest_extension\
    \ = str_replace(array(\".\", \"_\"), \"\", $class_name);\n    foreach ($extensions\
    \ as $extension) {\n        $num_cap2 = strlen($extension);\n        $num_sm2\
    \ = strlen($extension) - strlen($extension);\n        $frac = (($num_cap2 - $num_sm2)\
    \ / ($num_cap2 - $num_cap)) - ($num_sm / ($num_cap - $num_sm));\n        if ($frac\
    \ > 0) {\n            $strongest_extension = $strongest_extension.$extension;\n\
    \        }\n    }\n    return $strongest_extension;\n}\n</code>\n<|/ a |>\n<|\
    \ c |>\nThe question says \"Write a Python program that will generate and print\
    \ a Java class name for a given class name and an array of extensions\". Python\
    \ is very similar to Java, so that doesn't make sense. I believe the question\
    \ wants the Java solution, since it's what OP is familiar with. I don't see this\
    \ as a bad answer, but since you've already got the PHP solution, I'd like to\
    \ point out that if he or she were to do the same thing in Python, they would\
    \ have a much easier time figuring out how to translate that to Python.\n<|/ c\
    \ |>\n<| c |>\n- I understand, but that doesn't make this answer not a valid one.\
    \ :)\n<|/ c |>\n<| c |>\nI agree, but I suspect that if you were going to try\
    \ to write this in Python, you would find it much easier. So the OP would probably\
    \ find the answer himself if he or she were to translate this code.\n<|/ c |>\n\
    <| c |>\n- I agree, but I suspect that if you were going to try to write this\
    \ in Python, you would find it much easier. So the OP would probably find the\
    \ answer himself if he or she were to translate this code.\n<|/ c |>\n<| a |>\n\
    The shortest code is to replace _ with ., but if there are more extensions, you\
    \ might want to keep the _ and replace it with .:\n<code>\ndef Strongest_Extension(class_name,\
    \ extensions):\n    class_name = class_name.replace('_', '.')\n    for extension\
    \ in extensions:\n        extension = extension.replace('_', '.')\n        if\
    \ extension in class_name:\n            class_name = class_name.replace(extension,\
    \ '.')\n    return class_name\n</code>\n<|/ a dscore=0 tags=java,python,php |>\n\
    <| c |>\nThe ", "    $strength = -1;\n    $strongest = array();\n    foreach ($extensions\
    \ as $ext) {\n        $length = strlen($ext);\n        if ($length > strlen($class_name))\n\
    \            continue;\n        for ($i = 0; $i < $length; $i++) {\n         \
    \   $strongest[$i] = 0;\n        }\n        $length = strlen($class_name);\n \
    \       for ($i = 0; $i < $length; $i++) {\n            $strongest[$i] = $strongest[$i]\
    \ + ord($class_name[$i]) - ord('a');\n        }\n        $strongest[$length] =\
    \ 0;\n        foreach ($extensions as $ext) {\n            $length = strlen($ext);\n\
    \            for ($i = 0; $i < $length; $i++) {\n                $strongest[$i]\
    \ = max($strongest[$i], ord($ext[$i]) - ord('a'));\n            }\n        }\n\
    \        asort($strongest);\n        if ($strongest[$length] >= $strength) {\n\
    \            $strength = $strongest[$length];\n        }\n    }\n    return $class_name\
    \ . $extensions[$strength];\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThe strength\
    \ can be easily obtained by using the strongest_extension method in the example\
    \ I gave above.\n<|/ c |>\n<| c |>\nThat is true, but your answer does not explain\
    \ how that can be done - in fact, if you don't explain how that can be done I\
    \ will accept your answer.\n<|/ c |>\n<| a dscore=4 |>\n<code>\npublic static\
    \ function strongest_extension($class, $extensions)\n{\n    $strength = -1;\n\
    \    $strongest = array();\n    foreach ($extensions as $ext) {\n        $length\
    \ = strlen($ext);\n        if ($length > strlen($class))\n            continue;\n\
    \        for ($i = 0; $i < $length; $i++) {\n            $strongest[$i] = 0;\n\
    \        }\n        $length = strlen($class);\n        for ($i = 0; $i < $length;\
    \ $i++) {\n            $strongest[$i] = $strongest[$i] + ord($class[$i]) - ord('a');\n\
    \        }\n        $strongest[$length] = 0;\n        foreach ($extensions as\
    \ $ext) {\n            $length = strlen($ext);\n            for ($i = 0; $i <\
    \ $length; $i++) {\n                $strongest[$i] = max($strongest[$i], ord($ext[$i])\
    \ - ord('a'));\n            }\n        }\n        asort($strongest);\n       \
    \ if ($strongest[$length] >= $strength) {", "  $count = array_count_values($extensions);\n\
    \  $extensions_count = array_count_values($extensions);\n  asort($extensions_count);\n\
    \  foreach($extensions_count as $ext => $count) {\n    if ($count > 1) {\n   \
    \   asort($extensions);\n      $index = array_search($ext, $extensions);\n   \
    \   unset($extensions[$index]);\n      break;\n    }\n  }\n  return $class_name\
    \ . '.' . array_shift($extensions);\n}\n", "  $strengths = array_count_values($extensions);\n\
    \  arsort($strengths);\n  $best_extension_key = array_search(min($strengths),\
    \ $strengths);\n  return $class_name.$best_extension_key;\n}\n", "    $strongest\
    \ = -1;\n    $first_index = -1;\n    $extensions_count = count($extensions);\n\
    \    for($i = 0; $i < $extensions_count; $i++) {\n        $name = substr($class_name,\
    \ strrpos($class_name, '.') + 1);\n        $length = strlen($name);\n        $score\
    \ = strongest_extension_score($extensions[$i], $name);\n        if ($score > $strongest)\
    \ {\n            $strongest = $score;\n            $first_index = $i;\n      \
    \  }\n    }\n    if ($first_index != -1) {\n        $class_name = substr($class_name,\
    \ 0, strrpos($class_name, '.'));\n        return $class_name . \".\" . $extensions[$first_index];\n\
    \    } else {\n        return $class_name;\n    }\n}\n</code>\n<|/ a |>\n<| c\
    \ |>\n+1 for making use of the [fraction form](http://en.wikipedia.org/wiki/Fraction).\n\
    <|/ c |>\n<| c |>\nThe `fraction form` doesn't work for me, I get a negative number\
    \ back.\n<|/ c |>\n<| c |>\nAh yeah, I didn't think about that.\n<|/ c |>\n<|\
    \ c |>\nThe example given in the Wikipedia article is wrong - the correct form\
    \ is `'AAA'` (`'AAA' - 'A'` = `0`)\n<|/ c |>\n<| c |>\n+1 for a nice answer. \
    \ I'd just like to note that I don't see any need to use a `for` loop (or a `while`\
    \ loop) here.  The `strrpos` function can take a string, a delimiter, and a start\
    \ position.  You can just do `strrpos($class_name, '.')+1` and pass the `.`\n\
    <|/ c |>\n<| a |>\nI've written a function that will do that for you:\n<code>",
  "  // Write your code here\n}\n", "    // Your code here.\n}\n\n", "  $strongest\
    \ = $class_name;\n  $strongest_ext = array_shift($extensions);\n  $strength =\
    \ 0;\n  foreach ($extensions as $ext) {\n    $strength += substr_count($ext, $class_name);\n\
    \  }\n  if ($strength > 0) {\n    $strongest = $class_name . \"$strongest_ext\"\
    ;\n  }\n  return $strongest;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=string,php\
    \ dscore=0 |>\n<code>\n$str = \"test\";\n$chars = str_split($str);\n$max_chars\
    \ = max($chars);\n\n$str2 = \"\";\nforeach($chars as $char) {\n    if($char ==\
    \ $max_chars) {\n        $str2 .= $char;\n    }\n}\n\necho $str2;\n</code>\n<|/\
    \ a |>\n<| a |>\nIf you have PHP 5.3.0 or above, you can simply use str_pad with\
    \ an offset:\n<code>\necho str_pad($string, $offset, $padString);\n</code>\nExample:\n\
    <code>\n$string = \"abcdef\";\n$offset = 2;\n$padString = \"x\";\necho str_pad($string,\
    \ $offset, $padString); // abxxcdef\n</code>\n<|/ a tags=string,php dscore=0 |>\n\
    <| a dscore=0 tags=string,php |>\nUse str_replace function in php to remove the\
    \ duplicate character.\n<code>\n<?php\n$a = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n\
    echo str_replace($a,'',$a); ", "  // Your code here...\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\nMy solution for this task:\n<code>\n<?php\n    $array\
    \ = array('Slices', 'Stuff', 'Slices', 'StuFfed', 'StuFfed', 'StuFfed', 'Slices',\
    \ 'Slices', 'Slices');\n    $new_array = array();\n    foreach($array as $k =>\
    \ $v){\n      $new_array[$v] = $k;\n    }\n    asort($new_array);\n    print_r($new_array);\n\
    </code>\nOutput: \n<code>\nArray\n(\n    [Slices] => 0\n    [StuFfed] => 1\n \
    \   [Stuff] => 2\n)\n</code>\n<|/ a tags=arrays,sorting,php |>\n<| c |>\nThis\
    \ doesn't answer the question. You need to provide additional information for\
    \ someone to understand how this works.\n<|/ c |>\n<| a dscore=0 |>\nI have modified\
    \ this code a bit. \n<code>\n$newArray = array_count_values($array);\nksort($newArray);\n\
    $key = array_search( max($newArray), array_keys($newArray) );\n</code>\nThis outputs\
    \ \n<code>\nArray\n(\n    [Slices] => 2\n    [Stuff] => 2\n    [StuFfed] => 3\n\
    )\n</code>\nThe key is the value with the highest count. The value with the highest\
    \ count can be found using \n<code>\n$newArray[$key]\n</code>\n<|/ a tags=arrays,sorting,php\
    \ |>\n<| c |>\nYou should explain how this works. Otherwise, your answer will\
    \ be flagged as \"low quality\" and eventually deleted.\n<|/ c |>\n<| c |>\nYeah\
    \ sure but the problem was i wasn't able to explain it in a way that it will be\
    \ understood.\n<|/ c |>\n<| c |>\nThis doesn't answer the question. You need to\
    \ provide additional information for someone to understand how this works.\n<|/\
    \ c |>\n<| a |>\nHere's a simple function to get the key with the highest value.\n\
    <code>", "  $extensions_len = count($extensions);\n  \n  // If there are no extensions,\
    \ return an empty string.\n  if ($extensions_len == 0) {\n    return \"\";\n \
    \ }\n  \n  $strength = 1;\n  $extensions_sorted = $extensions;\n  usort($extensions_sorted,\
    \ function($a, $b) use (&$strength) {\n    return strcasecmp($a, $b) * $strength;\n\
    \  });\n  \n  // Check which one comes first in the sorted array\n  foreach ($extensions_sorted\
    \ as $key => $extension) {\n    if (strcasecmp($extension, $class_name) < 0) {\n\
    \      $strength = -1;\n      break;\n    }\n  }\n  \n  // If there are more than\
    \ 2 extensions with the same strength, choose the one that comes first in the\
    \ array\n  if ($strength > 0) {\n    return $class_name . \".\" . $extensions[0];\n\
    \  }\n  \n  // If there is exactly 1 extension with this strength, return it\n\
    \  foreach ($extensions_sorted as $key => $extension) {\n    if (strcasecmp($extension,\
    \ $class_name) == 0) {\n      return $class_name . \".\" . $extension;\n    }\n\
    \  }\n  \n  // If there is more than 1 extension with this strength, choose the\
    \ one with the smallest number of letters\n  foreach ($extensions_sorted as $key\
    \ => $extension) {\n    if (strcasecmp($extension, $class_name) < 0) {\n     \
    \ return $class_name . \".\" . $extension;\n    }\n  }\n  \n  // There were no\
    \ extensions with the same strength\n  return $class_name;\n}", "    // The array\
    \ is sorted by decreasing order of the strength of the extensions.\n    sort($extensions,\
    \ SORT_NUMERIC);\n\n    // If the array is empty, return an empty string.\n  \
    \  if (empty($extensions)) return \"\";\n\n    // Get the first extension from\
    \ the array.\n    $extension = array_shift($extensions);\n\n    // Calculate the\
    \ strength of the extension.\n    $extension_strength = substr_count($class_name,\
    \ $extension) / strlen($class_name);\n\n    // Return the class name with the\
    \ strongest extension.\n    return \"$class_name.$extension\";\n}", "    $map\
    \ = Array();\n    foreach ($extensions as $extension) {\n        $map = array_merge($map,\
    \ $this->strongest_extension_map($class_name, $extension));\n    }\n    arsort($map);\n\
    \    foreach ($map as $key => $value) {\n        if ($value != 0) {\n        \
    \    return $class_name . \".\" . $extensions[$key];\n        }\n    }\n    return\
    \ false;\n}\n", "  $strongest_extension = array();\n  $extensions_count = count($extensions);\n\
    \  $count_cap_lowercase = 0;\n  $count_cap_uppercase = 0;\n  $count_sm_lowercase\
    \ = 0;\n  $count_sm_uppercase = 0;\n\n  foreach ($extensions as $extension) {\n\
    \    $count_cap_lowercase += strlen(strtoupper($extension));\n    $count_cap_uppercase\
    \ += strlen(strtoupper(substr($extension, 1)));\n    $count_sm_lowercase += strlen(strtolower($extension));\n\
    \    $count_sm_uppercase += strlen(strtolower(substr($extension, 1)));\n  }\n\n\
    \  $strongest_extension_string = $class_name;\n\n  if ($count_cap_lowercase >\
    \ $count_sm_lowercase) {\n    $strongest_extension_string = $strongest_extension_string.\"\
    .\".$extensions[0];\n  }\n  else {\n    $strongest_extension_string = $strongest_extension_string.\"\
    .\".$extensions[1];\n  }\n\n  if ($count_cap_uppercase > $count_sm_uppercase)\
    \ {\n    $strongest_extension_string = $strongest_extension_string.\".\".$extensions[2];\n\
    \  }\n  else {\n    $strongest_extension_string = $strongest_extension_string.\"\
    .\".$extensions[3];\n  }\n\n  return $strongest_extension_string;\n}\n</code>\n\
    <|/ a tags=algorithm,arrays,language-agnostic,language-features dscore=0 |>\n\
    <| c |>\nSo you're saying \"the algorithm should work and is simple enough that\
    \ anyone can read it\"? How about you try and write a more elegant solution?\n\
    <|/ c |>\n<| c |>\nThis algorithm is simple enough for me to understand and understanding\
    \ of others will do no harm.\n<|/ c |>\n<| c |>\nYep. I understand the algorithm\
    \ well enough to understand it can solve most problems. But it isn't as simple\
    \ as you make it sound. To understand it, you need to understand what PHP does.\
    \ I'm not going to do that here. Also, I don't know what language you think you\
    \ wrote this in, but it's impossible to understand what it does without knowing\
    \ it.\n<|/ c |>\n<| c |>\nNo need to take that personally if your algorithm is\
    \ simple enough to be understood by someone who knows PHP. That's why I didn't\
    \ down vote you for that. Just trying to help you. You know what PHP does, why\
    \ don't you rewrite the algorithm in PHP to make it a bit easier for you to understand?\n\
    <|/ c |>\n<| c |>\nI understand PHP well ", "  $best_extension = \"\";\n  foreach($extensions\
    \ as $extension) {\n    $name = strtolower($extension);\n    $count = count(str_split($name));\n\
    \    $cap = count(preg_grep('/^[A-Z]/m', $name));\n    $sm = count(preg_grep('/^[a-z]/m',\
    \ $name));\n    $strength = $cap - $sm;\n    if ($best_extension == \"\" || $strength\
    \ < $best_extension[0]) {\n      $best_extension = array($extension, $strength);\n\
    \    } else if ($strength > $best_extension[0]) {\n      $best_extension[0] =\
    \ $strength;\n      $best_extension[1] = $extension;\n    }\n  }\n  if (count($best_extension)\
    \ > 1) {\n    sort($best_extension);\n    return $class_name . '.' . $best_extension[1];\n\
    \  }\n  return $best_extension[0];\n}\n", "  $extensions_array = array();\n  foreach\
    \ ($extensions as $extension) {\n    $extensions_array[] = $extension;\n  }\n\
    \  $extensions_array_count = count($extensions_array);\n  $strength = -1;\n  $extensions_array_sorted\
    \ = array_count_values($extensions_array);\n  foreach ($extensions_array_sorted\
    \ as $key => $value) {\n    if ($value > $strength) {\n      $strength = $value;\n\
    \    }\n  }\n  if ($strength >= 0) {\n    return $class_name . \".\" . $extensions_array[$strength];\n\
    \  }\n  else {\n    return $class_name;\n  }\n}\n", "    $class_array = explode(\"\
    \\\\\", $class_name);\n    $class_name = $class_array[0];\n    $last_class = end(array_slice($class_array,\
    \ 1));\n    \n    $extensions_array = explode(\"\\\\\", $last_class);\n    $last_extension\
    \ = end($extensions_array);\n    \n    sort($extensions);\n    usort($extensions,\
    \ function($a, $b){\n        if (strpos($a, $last_extension) === 0 && strpos($b,\
    \ $last_extension) === 0) {\n            return strlen($a) - strlen($b);\n   \
    \     }\n        return strcasecmp($a, $b);\n    });\n    return $class_name .\
    \ \".\" . array_shift($extensions);\n}", "    $extensions = array_reverse($extensions);\n\
    \    $cap_strength = 0;\n    $sm_strength = 0;\n    foreach ($extensions as $extension)\
    \ {\n        $cap = preg_replace(\"/[^A-Z]/\", \"\", $extension);\n        $sm\
    \ = preg_replace(\"/[^a-z]/\", \"\", $extension);\n        $cap_strength += $cap\
    \ > $cap_strength ? $cap : $cap_strength;\n        $sm_strength += $sm > $sm_strength\
    \ ? $sm : $sm_strength;\n    }\n\n    return $class_name.\".\".$extensions[$cap_strength\
    \ - $sm_strength];\n}\n", "    $best_extension = null;\n    $best_strength = -1;\n\
    \    foreach ($extensions as $extension) {\n        $extension_strength = strtoupper($extension)\
    \ - strtolower($extension);\n        if ($extension_strength > $best_strength)\
    \ {\n            $best_extension = $extension;\n            $best_strength = $extension_strength;\n\
    \        }\n    }\n    return $class_name . $best_extension;\n}\n</code>\n<|/\
    \ a tags=php,random,math |>\n<| c |>\nHi, I just edited my original post. There\
    \ I describe how I get the extensions from the class. I'm thinking this could\
    \ be a problem\n<|/ c |>\n<| c |>\nI added some code for you. I've tested it and\
    \ it works just fine for me. Make sure you copy the whole code block.\n<|/ c |>\n\
    <| c |>\nHi, I copied the code, but I get the same output :(\n<|/ c |>\n<| c |>\n\
    Oh! I found my mistake, I used your exact code, but I didn't use the correct classes\
    \ and extensions. Thanks a lot!!\n<|/ c |>\n<| a dscore=1 |>\nYou can use this\
    \ function which returns the first extension that is found (you can add more extensions\
    \ to the array if you want to).\n<code>\n/**\n * Gets the extension from the class\
    \ name.\n * string $class_name\n * array\n */", "  for ($i = 0; $i < sizeof($extensions);\
    \ $i++) {\n    $frac = str_split($extensions[$i]) - str_split($class_name);\n\
    \    $frac = $frac[0] * $frac[1] / strlen($extensions[$i]);\n    if ($frac > 0)\
    \ return $class_name . '.' . $extensions[$i];\n  }\n  return $class_name;\n}\n\
    </code>\n<|/ a |>\n<| c |>\nPlease explain your answer too, because this question\
    \ was asked and answered 5 years ago, and there are many users looking for an\
    \ answer to this question.\n<|/ c |>\n<| c |>\nI think it's pretty clear from\
    \ that link. Explaining *why* the function works would be helpful.\n<|/ c |>\n\
    <| a tags=php dscore=2 |>\nThe only way you can get this done is by having each\
    \ extension in your file include the class it needs to use. \n<code>\n<?php\n\
    $name = 'MyClass';\n$extensions = array('Extension1', 'Extension2', 'Extension3');\n\
    foreach ($extensions as $extension) {\n  require \"classes/$name.$extension.php\"\
    ;\n}\n</code>\n<|/ a |>\n<| a tags=php |>\n<code>\n<?php\n$name = 'MyClass';\n\
    $extensions = array('Extension1', 'Extension2', 'Extension3');\nforeach ($extensions\
    \ as $extension) {\n  require \"classes/$name.$extension.php\";\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nI love answers explaining why this works. Please keep\
    \ it around\n<|/ c |>\n<| a tags=php dscore=1 |>\n<code>\n<?php\n$name = 'MyClass';\n\
    $extensions = array('Extension1', 'Extension2', 'Extension3');\nforeach ($extensions\
    \ as $extension) {\n  require \"classes/$name.$extension.php\";\n}", "\t$cap_len\
    \ = count($class_name);\n\t$sm_index = array_search('SM', $class_name);\n\t$cap_index\
    \ = array_search('CAP', $class_name);\n\t$index = min($cap_index, $sm_index);\n\
    \t$strength = $index - $cap_len;\n\treturn $class_name . \".\" . substr($extensions[$index],\
    \ 0, $strength);\n}\n", "  $map = array();\n  $class_length = strlen($class_name);\n\
    \  $extensions_length = count($extensions);\n\n  // Initialize a map\n  for ($i\
    \ = 0; $i < $extensions_length; $i++) {\n    $map[$extensions[$i]] = 0;\n  }\n\
    \n  // Find the strongest extension\n  for ($i = 0; $i < $extensions_length; $i++)\
    \ {\n    $key = substr($extensions[$i], 0, 1);\n\n    if ($map[$key] < 0) {\n\
    \      $map[$key] = $extensions_length;\n    }\n\n    if ($map[$key] > $map[substr($extensions[$i],\
    \ 1, 1)]) {\n      $map[$key] = $map[substr($extensions[$i], 1, 1)];\n    }\n\
    \  }\n\n  // Return class name + strongest extension\n  $strongest_extension =\
    \ substr($class_name, 0, $class_length) . strtolower($extensions[$map[substr($class_name,\
    \ 0, 1)]]);\n  return $strongest_extension;\n}\n", "  // Your code here\n  $class_strength\
    \ = 0;\n  $extension_strength = 0;\n  foreach ($extensions as $extension) {\n\
    \    $class_strength += preg_match_all('/[A-Z]/', $extension);\n    $extension_strength\
    \ += preg_match_all('/[a-z]/', $extension);\n  }\n  \n  $class_strength = round(($class_strength\
    \ / count($extensions)));\n  $extension_strength = round(($extension_strength\
    \ / count($extensions)));\n  \n  $strength = $class_strength - $extension_strength;\n\
    \  \n  return $class_name . '.' . str_replace(' ', '', ucwords(str_replace(' ',\
    \ '', strtolower($extensions[$strength]))))  ;\n}\n</code>\nNow we can do the\
    \ following:\n<code>\n$class = \"Slices\";\n$extensions = array(\"SErviNGSliCes\"\
    , \"Cheese\", \"StuFfed\");\n$strength = Strongest_Extension($class, $extensions);\n\
    echo $strength;\n</code>\nWhich outputs:\n<code>\nSlices.SErviNGSliCes\n</code>\n\
    <|/ a tags=php,arrays,algorithm dscore=2 |>\n<| a tags=php,arrays,algorithm |>\n\
    <code>", "    $extension_count = array();\n    foreach ($extensions as $ext) {\n\
    \        $extension_count[$ext] = substr_count($class_name, $ext);\n    }\n  \
    \  krsort($extension_count);\n    $strongest = end($extension_count);\n    $strongest_index\
    \ = array_search(min($extension_count), $extension_count);\n    return substr($class_name,\
    \ 0, strlen($class_name) - strlen($extensions[$strongest_index]));\n}\n", "\t\
    $class_name = strtolower($class_name);\n\tsort($extensions);\n\t$strength = 0;\n\
    \tforeach ($extensions as $ext) {\n\t\t$ext = strtolower($ext);\n\t\t$cap = strlen(preg_replace('/[^A-Z]/',\
    \ '', $ext));\n\t\t$sm = strlen(preg_replace('/[^a-z]/', '', $ext));\n\t\t$strength\
    \ += $cap - $sm;\n\t}\n\treturn $class_name . $extensions[array_search($strength,\
    \ $extensions)];\n}\n</code>\n<|/ a tags=php |>\n<| c |>\nIt doesn't quite work.\
    \ Try `Strongest_Extension(\"my_class\", array(\"AA\", \"Be\", \"CC\"))` and it\
    \ returns `my_class.BE`\n<|/ c |>\n<| c |>\n: Thanks for pointing that out! I've\
    \ added a fix for the problem you mentioned.\n<|/ c |>\n<| c |>\nThat's nice!\
    \ But I tested it with the values you mentioned, and it still gave `my_class.BE`.\n\
    <|/ c |>\n<| c |>\n: I've fixed the problem with my answer above. Thanks for noticing!\n\
    <|/ c |>\n<| c |>\nI'm getting this error while trying to run your code: `Warning:\
    \ sort() expects parameter 1 to be array, string given`\n<|/ c |>\n<| a tags=php\
    \ |>\nTry this code...\n<code>\n$strongest_extension = '';\n$extensions = array();\n\
    $class_name = \"my_class\";\n$extensions = array('AA', 'Be', 'CC');\n\nforeach\
    \ ($extensions as $ext) {\n    $ext = strtolower($ext);\n    $cap = strlen(preg_replace('/[^A-Z]/',\
    \ '', $ext));\n    $sm = strlen(preg_replace('/[^a-z]/', '', $ext));\n    $strength\
    \ = $cap - $sm;\n\n    if($strength >= 0){\n        $strongest_extension = $class_name\
    \ . $ext;\n        break;\n    }\n}\n\necho $strongest_extension;\n</code>\n<|/\
    \ a dscore=1 |>\n<| a dscore=1 |>\nTry this.\n<code>", "    array_multisort(array_map('strnatcmp',\
    \ $extensions), SORT_DESC, $extensions);\n    $i = 1;\n    $s = strnatcmp($class_name,\
    \ '');\n    while (isset($extensions[$i])) {\n        if ($extensions[$i] == $class_name)\
    \ {\n            return $class_name.$i;\n        }\n        if ($s < 0) {\n  \
    \          $s = $i;\n        }\n        $i++;\n    }\n    return $class_name;\n\
    }\n", "    // Your code here\n    \n    $extensions_array = str_split($class_name);\n\
    \    $total_strength = 0;\n    $best_extension = NULL;\n\n    $extension_count\
    \ = count($extensions);\n    for($i = 0; $i < $extension_count; $i++){\n     \
    \   $extension = strtolower($extensions[$i]);\n        for($j = 0; $j < $extension_count;\
    \ $j++){\n            $lower_extension = strtolower($extensions[$j]);\n      \
    \      $strenght = substr_count($extension, $lower_extension);\n            if($strenght\
    \ != 0){\n                $total_strength += $strenght;\n            }\n     \
    \   }\n        if($total_strength == 0){\n            return $extension;\n   \
    \     }\n        if($total_strength > 0){\n            $best_extension = $extension;\n\
    \            break;\n        }\n    }\n    return $best_extension;\n}\n", "  \
    \  $best_strongest_extension = null;\n    $best_strongest_extension_strength =\
    \ -1;\n\n    foreach($extensions as $ext) {\n        $extension_strength = preg_match('/'.strtoupper($ext).'/',\
    \ $class_name, $matches) ? strlen($matches[0]) - strlen(strtolower($ext)) : 0;\n\
    \        if($extension_strength > $best_strongest_extension_strength) {\n    \
    \        $best_strongest_extension_strength = $extension_strength;\n         \
    \   $best_strongest_extension = $ext;\n        }\n    }\n\n    return $best_strongest_extension;\n\
    }", "  if (count($extensions) < 1) {\n    $extensions[] = NULL;\n  }\n\n  $strongest_extension\
    \ = \"\";\n  $cap_strength = -1;\n  $sml_strength = -1;\n  $cur_extension = \"\
    \";\n  $cur_class_name = \"\";\n  foreach ($extensions as $extension) {\n    if\
    \ (is_string($extension)) {\n      $cur_extension = $extension;\n      $cur_class_name\
    \ = $class_name;\n      $cap_strength = str_ireplace($extension, \"\", $class_name);\n\
    \      $sml_strength = str_ireplace($extension, \"\", $cur_class_name);\n    }\n\
    \    else {\n      $cap_strength = -1;\n      $sml_strength = -1;\n    }\n\n \
    \   if ($cap_strength > $sml_strength) {\n      $strongest_extension = $cur_extension;\n\
    \    }\n  }\n  return $class_name . \".\" . $strongest_extension;\n}\n", "  $total_strength\
    \ = 0;\n  foreach ($extensions as $extension) {\n    $strongest_extension = explode(\"\
    _\", $extension);\n    $total_strength += $strongest_extension[count($strongest_extension)\
    \ - 1];\n  }\n  $total_strength = $total_strength / count($extensions);\n  $lowest_strength\
    \ = -1;\n  foreach ($extensions as $extension) {\n    $strongest_extension = explode(\"\
    _\", $extension);\n    $current_strength = $strongest_extension[count($strongest_extension)\
    \ - 1];\n    if ($current_strength > $total_strength || $current_strength < $lowest_strength)\
    \ {\n      $lowest_strength = $current_strength;\n    }\n  }\n  return $class_name\
    \ . \".\" . implode($extensions, \".\" . $lowest_strength);\n}\n", "    $class_name_length\
    \ = strlen($class_name);\n    \n    $extension_length = count($extensions);\n\
    \    $strength = -1;\n    \n    foreach($extensions as $extension) {\n       \
    \ $extension_length = strlen($extension);\n        $strength += ($class_name_length\
    \ - $extension_length) / 2;\n    }\n    \n    if($strength < 1) {\n        return\
    \ $class_name;\n    }\n    \n    $strength_length = ($strength - 1) * 2;\n   \
    \ \n    return substr($class_name, 0, $strength_length) . \n           strtolower(substr($class_name,\
    \ $strength_length, $extension_length));\n}\n", "    // Here we go ...\n    $count\
    \ = array_count_values($extensions);\n    $max = array_shift(array_keys($count));\n\
    \    foreach ($count as $value => $count) {\n        $max = max($max, $count);\n\
    \    }\n    // We now have the max value, and want to find the strongest extension.\n\
    \    // We have found two extensions with the same strength:\n    // 'AA' and\
    \ 'Be'.\n    // Now we just want to return the first of these two, \n    // which\
    \ we do by looking at its position in the array:\n    // 'AA' has position 0,\
    \ and 'Be' has position 2.\n    // Since these two are in reverse order, the first\
    \ extension\n    // is 'Be', which we return (because it's the first extension\n\
    \    // with position >= 0).\n    foreach ($extensions as $key => $extension)\
    \ {\n        $pos = strpos($extension, $class_name);\n        if ($pos === 0)\
    \ {\n            return $extension;\n        } elseif ($pos > 0) {\n         \
    \   return $extensions[$key - 1];\n        }\n    }\n}\n", "  $class_name = ucfirst($class_name);\n\
    \  $extensions = array_map('strtolower', $extensions);\n  $strength = 0;\n  foreach\
    \ ($extensions as $key => $ext) {\n    $extension = ucfirst($ext);\n    $cap =\
    \ preg_replace('/\\d/', '', $key);\n    $sm = preg_replace('/\\d/', '', $class_name);\n\
    \    $c = preg_replace('/\\d/', '', $extension);\n    $s = preg_replace('/\\d/',\
    \ '', $extension);\n    if ($c > $cap || $s > $sm || ($s == $sm && $c > $cap))\
    \ {\n      if ($s > $sm) {\n        $strength = -1;\n      } else if ($c > $cap)\
    \ {\n        $strength = -1;\n      } else if ($c == $cap && $s > $sm) {\n   \
    \     $strength = -1;\n      } else if ($s == $sm) {\n        $strength = -1;\n\
    \      }\n    } else {\n      $strength = $key - $class_name;\n    }\n  }\n  return\
    \ $class_name . $extensions[array_search($strength, $extensions)];\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a |>\n<code>\n<?php", "  $extensions = array_reverse($extensions);\
    \ // reverse the order\n  $best_extension = null;\n  $best_strength = -1; // default\
    \ value\n  foreach ($extensions as $extension) {\n    $length = strlen($extension);\n\
    \    $class = substr($class_name, 0, $length - 1);\n    $class_name = substr($class_name,\
    \ $length - 1);\n    $class_name = strtolower($class_name);\n    $class_name =\
    \ preg_replace('/[^A-Z]/', '', $class_name); // remove non-letters\n    $class_name\
    \ = ucfirst($class_name); // capitalize first letter\n    $class_name = ucfirst($class_name);\
    \ // capitalize first letter\n    if (strtolower($extension) == $class_name) {\n\
    \      $strength = substr_count($extension, $class_name) / strlen($class_name);\
    \ //calculate strength\n      if ($strength > $best_strength) {\n        $best_strength\
    \ = $strength;\n        $best_extension = $extension;\n      }\n    }\n  }\n \
    \ return $best_extension;\n}\n", "    $strongest_extension = '';\n    $best_strength\
    \ = -1;\n    $best_index = 0;\n    \n    foreach ($extensions as $index => $extension)\
    \ {\n        // Skip extensions with an invalid name\n        if (strpos($extension,\
    \ '.') !== false) {\n            list($extension, $extension_strength) = explode('.',\
    \ $extension);\n        } else {\n            continue;\n        }\n        $extension_strength\
    \ = strtoupper(substr($extension, -1)) - strtoupper(substr($extension, 0, -1));\n\
    \        if ($extension_strength > $best_strength) {\n            $best_strength\
    \ = $extension_strength;\n            $best_index = $index;\n        }\n    }\n\
    \    \n    // Returning null means there was no extension with a strength being\
    \ the lowest\n    if ($best_strength < 0) {\n        return null;\n    }\n   \
    \ \n    // Returning the class name with just the extension\n    // Example: my_class.AA\n\
    \    return $class_name . \".\" . $extensions[$best_index];\n}\n</code>\n<|/ a\
    \ |>\n<| c |>\nThis seems good but is there a way of using regular expressions\
    \ to make it more efficient?\n<|/ c |>\n<| c |>\nIf you're concerned with efficiency,\
    \ you really should be using a language with a built-in string tokenizer (like\
    \ PHP's `explode`) to simplify things.\n<|/ c |>\n<| c |>\n: Yes, but then you've\
    \ got to get rid of the \"a\" or \"e\" character after the first extension (since\
    \ they aren't \"extensions\"), and the spaces after the second extension (since\
    \ \"extensions\" doesn't mean \"a bunch of letters that occur after the first\
    \ extension\", and spaces aren't allowed in class names).\n<|/ c |>\n<| c |>\n\
    That's a really nice solution. Really impressive. I think it could be a little\
    \ shorter by removing the inner foreach loop and using a standard `for` loop\n\
    <|/ c |>\n<| c |>\n: You can't use `for` to loop through an array - you have to\
    \ loop through the array *index*. `for($i=0;$i<count($extensions);$i++) { ...\
    \ }`\n<|/ c |>\n<| a tags=string,regex,php dscore=3 |>\nI wrote a regexp to do\
    \ this:\n<code>\n$s = 'my_class.AA'; // for example\n$t = preg_replace('/(\\w+)(?:\\\
    .([A-Z]+))*/i', '\\1', $s);\n</code>\nOutput:\n<code>\nmy_class\n</code>\n<|/\
    \ a |>\n<| c |>\nYou might want to add `+` to the `[A-Z]+` part otherwise you ",
  "    $class_array = explode('.', $class_name);\n    $max_strength = 0;\n    $max_extension_array\
    \ = array();\n    foreach ($class_array as $class_element){\n        $element_index\
    \ = strlen($class_element) - 1;\n        $element_value = strtoupper(substr($class_element,\
    \ 0, $element_index));\n        $element_strength = strlen($element_value) - strlen($element_value);\n\
    \        if ($element_strength > $max_strength) {\n            $max_strength =\
    \ $element_strength;\n            $max_extension_array = $extensions;\n      \
    \  }\n    }\n    return $class_name . '.' . array_shift($max_extension_array);\n\
    }\n</code>\nAnd then you can do the following test\n<code>\n<?php", "    if (count($extensions)\
    \ == 0) return $class_name;\n    $total_extensions = count($extensions);\n   \
    \ sort($extensions);\n    for ($i = 0; $i < $total_extensions; ++$i) {\n     \
    \   $extension_length = strlen($extensions[$i]);\n        if ($extension_length\
    \ == 0) continue;\n        $cap_length = strlen(strtoupper($extensions[$i]));\n\
    \        if ($cap_length == 0) continue;\n        $sm_length = strlen(strtolower($extensions[$i]));\n\
    \        if ($sm_length == 0) continue;\n        if ($cap_length - $sm_length\
    \ >= $extension_length) {\n            $score = -1;\n        } else {\n      \
    \      $score = $cap_length - $sm_length;\n        }\n        if ($extension_length\
    \ < $extensions[$i][0]) return $class_name . $extensions[$i];\n    }\n    return\
    \ $class_name . $extensions[0];\n}", "   $strengths = array_count_values($extensions);\n\
    \   ksort($strengths);\n   $strength = -1;\n   foreach ($extensions as $ext) {\n\
    \      if ($strengths[$ext] > $strength) {\n         $strength = $strengths[$ext];\n\
    \      }\n   }\n\n   return $class_name.'.'.$extensions[$strength];\n}\n\n$class_name\
    \ = \"Slices\";\n$extensions = array(\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"\
    );\n$class_name = Strongest_Extension($class_name, $extensions);\necho $class_name;\
    \ // Output: Slices.SErviNGSliCes", "    $sorted_extensions = array();\n    foreach\
    \ ($extensions as $key => $value) {\n        $sorted_extensions[$value] = $key;\n\
    \    }\n    $sorted_extensions = array_flip($sorted_extensions);\n    $strongest\
    \ = -1;\n    $extension = null;\n    foreach ($sorted_extensions as $key => $value)\
    \ {\n        if ($value > $strongest) {\n            $strongest = $value;\n  \
    \          $extension = $key;\n        }\n    }\n    return \"$class_name.$extension\"\
    ;\n}\n", "  $max_strength = -1;\n  $max_extension = NULL;\n  foreach ($extensions\
    \ as $extension) {\n    $class_name = $class_name . $extension;\n    $ext = loadClass('Extension',\
    \ $extension);\n    $strength = $ext->extension_strength($class_name);\n    if\
    \ ($strength > $max_strength) {\n      $max_strength = $strength;\n      $max_extension\
    \ = $extension;\n    }\n  }\n  return $class_name . $max_extension;\n}\n", " \
    \   $extensions_str = implode(',', $extensions);\n    $classes = get_declared_classes();\n\
    \    $class_info = array_flip($classes);\n    foreach($extensions as $extension)\
    \ {\n        $class_str = $class_info[$class_name];\n        if (strlen($class_str)\
    \ < strlen($extension)) {\n            $class_str .= str_repeat($class_str[0],\
    \ strlen($extension) - strlen($class_str));\n        }\n        $extension_str\
    \ = substr($extension, 0, strlen($class_str));\n        if (is_numeric(preg_replace('/[0-9]/',\
    \ '', $extension_str))) {\n            $extension_str = str_repeat($extension_str[0],\
    \ $extension_str[1] - $extension_str[0]);\n        }\n        $class_str = str_replace($extension_str,\
    \ $class_str, $class_str);\n        $class_name = substr($class_str, 0, strlen($class_str)\
    \ - strlen($extension_str));\n    }\n    return $class_name;\n}\n", "    $result\
    \ = '';\n    $len = count($extensions);\n    for ($i = 0; $i < $len; $i++) {\n\
    \        $frac = strtoupper($extensions[$i]) - strtolower($extensions[$i]);\n\
    \        if ($frac >= 0) {\n            $strongest = ($frac < $len ? $extensions[$i]\
    \ : $class_name . '.' . $extensions[$i]);\n            $result .= $strongest .\
    \ '.';\n        }\n    }\n    return substr($result, 0, -1);\n}\n", "    $strength\
    \ = array_count_values($extensions)[0];\n    foreach ($extensions as $ext) {\n\
    \        $strength *= strlen($ext);\n    }\n    asort($extensions);\n    foreach\
    \ ($extensions as $ext) {\n        if ($strength == $ext) {\n            return\
    \ $class_name . '.' . $ext;\n        }\n    }\n    $exts = array_keys($extensions,\
    \ $strength);\n    return $class_name . '.' . $exts[0];\n}\n</code>\n<|/ a tags=php,arrays,algorithm\
    \ |>\n<| c |>\nI believe `Arrays.sort` only works in PHP >=5.6\n<|/ c |>\n<| c\
    \ |>\n`asort` works in any PHP version. You could easily create a function that\
    \ implements the same behavior.\n<|/ c |>\n<| c |>\n`asort()` sorts the keys of\
    \ an associative array. `sort()` sorts the elements of an array. `usort` works\
    \ the same way but takes only two arguments. `uasort` also works the same way\
    \ but takes four arguments.\n<|/ c |>\n<| c |>\nI agree with. `asort()` and `uasort()`\
    \ are the same thing. The only difference is how they handle the situation where\
    \ the comparison function is inconsistent (ie. `strcmp()`).\n<|/ c |>\n<| c |>\n\
    Thank you for pointing this out. I've fixed it.\n<|/ c |>\n<| a |>\n<code>\n<?php\n\
    $arr1=array(\"a\",\"b\",\"c\",\"d\",\"e\",\"f\");\n$arr2=array(\"a\",\"b\",\"\
    c\");\n$arr3=array(\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\"\
    );\n", "    $best_ext = strongest_extension($extensions);\n    $class_name = str_replace(\"\
    \ \", \".\", $class_name);\n    return $class_name . \".\" . $best_ext;\n}\n</code>\n\
    And to test:\n<code>\n$extensions = [\"AA\", \"Be\", \"CC\"];\n$class_name = \"\
    my_class\";\necho Strongest_Extension($class_name, $extensions);\n</code>\nOutput:\n\
    <code>\nmy_class.AA\n</code>\n<|/ a tags=php |>\n<| c |>\nThis does not work.\
    \ Try this with `strongest_extension([\"AaBbCc\"]) => AaBbCc`\n<|/ c |>\n<| c\
    \ |>\n, Please read it again! It says \"If there are two or more extensions with\
    \ the same strength, you should choose the one that comes first in the array.\"\
    \ So it means it should return \"AaBbCc\" and not \"AA\"\n<|/ c |>\n<| c |>\n\
    And it is correct. Just the example is wrong!\n<|/ c |>\n<| c |>\nIt works fine\
    \ for me! Please try it out yourself!\n<|/ c |>\n<| c |>\nAnd how would you implement\
    \ the function with different extension names?\n<|/ c |>\n<| a tags=php dscore=2\
    \ |>\n<code>\n<?php\n", "  // your code here\n}\n", "    $class = $class_name;\n\
    \    \n    foreach ($extensions as $extension) {\n        if (strpos($extension,\
    \ \"_\") !== false) {\n            $upper = strpos(strtoupper($extension), \"\
    _\");\n            $lower = strpos(strtolower($extension), \"_\");\n         \
    \   $count = substr_count($extension, \"_\") - $upper - $lower;\n            if\
    \ ($count > 0) {\n                $extension = substr($extension, 0, $upper) .\
    \ substr($extension, $upper);\n            }\n        }\n        \n        if\
    \ ($class == $extension) {\n            $class = \"NULL\";\n        }\n      \
    \  else {\n            if ($class != \"NULL\") {\n                $class = $class\
    \ . \"_\" . $extension;\n            }\n            else {\n                $class\
    \ = $extension;\n            }\n        }\n    }\n    \n    return $class;\n}\n\
    </code>\n<|/ a tags=php,php-5.6 |>\n<| c |>\nThis doesn't seem to be working.\
    \ All that happens is I get back \"NULL\"\n<|/ c |>\n<| c |>\nI added more examples\
    \ and test strings. What do you see when you execute this code?\n<|/ c |>\n<|\
    \ c |>\nThe output I get is \"my_class_NULL\"\n<|/ c |>\n<| c |>\nStrange. I tested\
    \ this code using PHP 5.6.3 and it works there. Does `print_r(array_count_values($extensions));`\
    \ give you anything? If so, please post the output\n<|/ c |>\n<| c |>\nAh, I got\
    \ it. My version of PHP doesn't know that \"array_count_values\" exists. It only\
    \ has \"array_count_keys\". Thanks for the help!\n<|/ c |>\n<| a tags=php,php-5.6\
    \ dscore=0 |>\nYou can try the below function - \n<code>", "    $extensions_count\
    \ = array_count_values($extensions);\n    arsort($extensions_count);\n    foreach\
    \ ($extensions_count as $extension => $count) {\n        if ($count == 1) {\n\
    \            break;\n        }\n    }\n    return $class_name . '.' . substr($extension,\
    \ 0, $count);\n}\n", "    $strength = array();\n    $count = array_count_values($extensions);\n\
    \    arsort($count);\n\n    foreach ($count as $extension => $num) {\n       \
    \ $strength[$extension] = $num;\n    }\n\n    return $class_name . \".\" . $extensions[$strength[strtoupper($extensions[0])]\
    \ - 1];\n}\n", "    $extensions_strengths = array();\n    foreach($extensions\
    \ as $extension) {\n        $class_name = preg_replace(\"/$extension/i\", \"\"\
    , $class_name);\n        $extensions_strengths[$extension] = count(preg_grep(\"\
    /$extension/i\", $class_name));\n    }\n    return $class_name . str_repeat(array_search(-1,\
    \ $extensions_strengths), count($extensions_strengths));\n}", "    $strengths\
    \ = array_count_values($extensions);\n    arsort($strengths);\n    $first_extension\
    \ = array_search(min($strengths), $strengths);\n    return \"$class_name.\" .\
    \ key($first_extension);\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThank you for\
    \ your great answer! I have tested it and its working as I wanted. Could you please\
    \ explain me how is it working? I cannot understand how it works. Thanks again!\n\
    <|/ c |>\n<| c |>\nOk I have added a couple of explanations to my answer.\n<|/\
    \ c |>\n<| a tags=php,arrays |>\nThis problem can also be solved by using array_search()\
    \ and array_count_values():\n<code>\n$array = [\n    'SErviNGSliCes' => 1,\n \
    \   'Cheese' => 1,\n    'StuFfed' => 1\n];\n$strongest = array_search(min($array),\
    \ array_count_values($array));\n</code>\n<|/ a dscore=1 |>\n<| a tags=php,arrays\
    \ |>\n<code>\n<?php\n$arr = array(\n    'SErviNGSliCes' => 1,\n    'Cheese' =>\
    \ 1,\n    'StuFfed' => 1\n);\n$arr['SErviNGSliCes'] = 0;\n$arr['Cheese'] = 1;\n\
    $arr['StuFfed'] = 1;\n\n$arrKeys = array_keys($arr);\n$arrKeysCounts = array_count_values($arrKeys);\n\
    \n$minKey = array_search($arrKeysCounts, array_keys($arrKeysCounts, min(array_values($arrKeysCounts))));\n\
    $strongestExtension = substr($minKey, 0, strlen($minKey) - 1);\n\necho $strongestExtension;\
    \ // SErviNGSliCes\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't seem to\
    \ be the best answer considering the number of different extensions compared to\
    \ the number of different words. I believe that your approach is better in that\
    \ regard.\n<|/ c |>\n<| c |>\nThis doesn't seem to answer OP's question. It just\
    \ does some extra work with arrays and looping but doesn't solve the problem.\n\
    <|/ c |>\n<| c |>\nThank you for your answer! I have tested it and its working\
    \ as I wanted. Could you please explain me how is it working? I cannot understand\
    \ how it works. Thanks again!\n<|/ c |>\n<| c |>\nI added an explan", "    $len\
    \ = strlen($class_name);\n    $strongest = -1;\n    foreach($extensions as $extension)\
    \ {\n        $len = strlen($extension);\n        $fraction = $len / $len;\n  \
    \      if($fraction >= $strongest) {\n            $strongest = $fraction;\n  \
    \      }\n    }\n    return $class_name . \".\" . $strongest . substr($class_name,\
    \ $strongest);\n}", "    $len = strlen($class_name);\n    arsort($extensions);\n\
    \    foreach ($extensions as $key => $ext) {\n        $ext_len = strlen($ext);\n\
    \        $strength = substr_count($class_name.$ext, $class_name);\n        if\
    \ ($strength >= $len + $ext_len) {\n            return $class_name.$ext;\n   \
    \     }\n    }\n}\n", "  $extension_strength = -1;\n  \n  $class_name = strtolower($class_name);\n\
    \  $class_length = strlen($class_name);\n  \n  foreach ($extensions as $extension)\
    \ {\n    $extension = strtolower($extension);\n    $extension_length = strlen($extension);\n\
    \    \n    $extension_strength = $extension_strength + ($extension_length / $class_length);\n\
    \  }\n  return $class_name . substr($class_name, 0, $class_length - $extension_strength)\
    \ . $extensions[0];\n}\n", "    $strongest = 0;\n    $class_names = explode('.',\
    \ $class_name);\n    foreach ($extensions as $ext) {\n        $cap = preg_replace('/[A-Z]/',\
    \ '', $ext);\n        $sm = preg_replace('/[a-z]/', '', $ext);\n        $frac\
    \ = $cap - $sm;\n        $frac = $frac / strlen($class_names) - 1;\n        if\
    \ ($frac > $strongest) {\n            $strongest = $frac;\n        }\n    }\n\
    \    $extension = '';\n    $strongest = abs($strongest);\n    foreach ($class_names\
    \ as $k => $name) {\n        $extension .= ($extension == \"\") ? $name . (strlen($strongest)\
    \ > $k ? $strongest : $k) : \n            ($strongest > $k ? $strongest : $k).'.'.$extension;\n\
    \    }\n    return $class_name.$extension;\n}\n</code>\n<|/ a |>\n<| c |>\nI edited\
    \ my answer to account for the case where multiple extensions has the same strength.\n\
    <|/ c |>\n<| a dscore=0 |>\nHere's my version (it actually finds the biggest extension):\n\
    <code>\n<?php", "  // Find all the upper case letters in the class's name.\n \
    \ $class_name_upper = strtoupper($class_name);\n  $class_name_upper_count = 0;\n\
    \  foreach ($class_name_upper as $k => $v) {\n    if (isupper($v)) {\n      $class_name_upper_count++;\n\
    \    }\n  }\n  // Find all the lower case letters in the class's name.\n  $class_name_lower\
    \ = strtolower($class_name);\n  $class_name_lower_count = 0;\n  foreach ($class_name_lower\
    \ as $k => $v) {\n    if (islower($v)) {\n      $class_name_lower_count++;\n \
    \   }\n  }\n  $class_name_len = $class_name_upper_count + $class_name_lower_count;\n\
    \  // Find the average of the upper-case letters and lower-case letters.\n  $class_name_average\
    \ = $class_name_upper_count + $class_name_lower_count;\n  // Get the strength\
    \ of the extension.\n  $class_name_strength = 0;\n  $class_name_strength_avg =\
    \ 0;\n  for ($i = 0; $i < count($extensions); $i++) {\n    $class_name_extension\
    \ = strtoupper($extensions[$i]);\n    $class_name_extension_len = strlen($class_name_extension);\n\
    \    $class_name_extension_upper = strtoupper($class_name_extension);\n    $class_name_extension_upper_count\
    \ = count($class_name_extension_upper);\n    $class_name_extension_lower = strtolower($class_name_extension);\n\
    \    $class_name_extension_lower_count = count($class_name_extension_lower);\n\
    \    $class_name_extension_len = count($class_name_extension);\n    $class_name_extension_average\
    \ = $class_name_extension_upper_count + $class_name_extension_lower_count;\n \
    \   $class_name_strength = $class_name_strength + $class_name_extension_len;\n\
    \    $class_name_strength_avg = $class_name_strength_avg + $class_name_extension_average;\n\
    \  }\n  // Return the extension that has the highest strength.\n  $class_name_strength_avg\
    \ = intval($class_name_strength_avg / $class_name_len);\n  if ($class_name_strength_avg\
    \ == $class_name_upper_count) {\n    return $class_name . '.' . $extensions[0];\n\
    \  }\n  if ($class_name_strength_avg == $class_name_lower_count) {\n    return\
    \ $class_name . '.' . $extensions[1];\n  }\n  $highest_strength_extension = 0;\n\
    \  for ($i = 0; $i < count($extensions); $i++) {\n    if ($class_name_strength_avg\
    \ == $class_name_len - 1) {\n      return $class_name . '.' . $extensions[$i];\n\
    \    }\n    if ($class_name_strength_avg < $class_name_len - 1) {", "    $best_strongest\
    \ = -1;\n    foreach ($extensions as $extension) {\n        $extension_length\
    \ = strlen($extension);\n        $class_length = strlen($class_name);\n      \
    \  $strength = ($class_length - $extension_length) / $class_length;\n        if\
    \ ($strength > $best_strongest) {\n            $best_strongest = $strength;\n\
    \        }\n    }\n    return $class_name . substr($extensions, $best_strongest);\n\
    }\n</code>\nOutput:\n<code>\n>>> Strongest_Extension(\"my_class\", array(\"AA\"\
    , \"Be\", \"CC\"))\n\"my_class.AA\"\n>>> Strongest_Extension(\"my_class\", array(\"\
    a\", \"B\", \"C\"))\n\"my_class.a\"\n>>> Strongest_Extension(\"my_class\", array(\"\
    Aa\", \"Bb\", \"Cc\"))\n\"my_class.Aa\"\n>>> Strongest_Extension(\"my_class\"\
    , array(\"Aa\", \"Bb\", \"Cc\"))\n\"my_class.Aa\"\n>>> Strongest_Extension(\"\
    my_class\", array(\"Aa\", \"Bb\", \"Cc\"))\n\"my_class.Aa\"\n>>> Strongest_Extension(\"\
    my_class\", array(\"aB\", \"Bb\", \"Cc\"))\n\"my_class.Ab\"\n>>> Strongest_Extension(\"\
    my_class\", array(\"aB\", \"Bb\", \"Cc\"))\n\"my_class.Ab\"\n>>> Strongest_Extension(\"\
    my_class\", array(\"aB\", \"Bb\", \"Cc\"))\n\"my_class.Ab\"\n>>> Strongest_Extension(\"\
    my_class\", array(\"Aa\", \"bB\", \"Cc\"))\n\"my_class.Ab\"\n>>> Strongest_Extension(\"\
    my_class\", array(\"Aa\", \"bB\", \"Cc\"))\n\"my_class.Ab\"\n>>> Strongest_Extension(\"\
    my_class\", array(\"Aa\", \"bB\", \"Cc\"))\n\"my_class.Ab\"\n>>> Strongest_Extension(\"\
    my_class\", array(\"aB\", \"Bb\", \"cC\"))\n\"my_class.Ab\"\n>>> Strongest_Extension(\"\
    my_class\", array(\"aB\", \"Bb\", \"cC\"))\n\"my_class.Ab\"\n>>> Strongest_Extension(\"\
    my_class\", array(\"aB\", \"Bb\", \"cC\"))\n\"my_class.Ab\"\n>>> Strongest_Extension(\"\
    my_class\", array(\"Aa\", \"Bb\", \"cC\"))\n\"my_class.Aa\"\n>>> Strongest_Extension(\"\
    my_class\", array(\"Aa\", \"Bb\", \"cC\"))\n\"my_class.Aa\"\n>>> Strongest_Extension(\"\
    my_class", "  $map = array_count_values($extensions);\n  arsort($map);\n\n  $strongest\
    \ = null;\n  foreach ($map as $ext => $count) {\n    $count = ($count < 2) ? $count\
    \ : 2;\n    if ($count == count($extensions) && $ext === $class_name) {\n    \
    \  return $ext;\n    }\n  }\n\n  return $class_name;\n}\n", "  $sorted_extensions\
    \ = $extensions;\n  natsort($sorted_extensions);\n  foreach ($sorted_extensions\
    \ as $extension) {\n    if (substr($extension, 0, 1) < substr($class_name, 0,\
    \ 1)) {\n      return $class_name . \".\" . $extension;\n    }\n  }\n  return\
    \ $class_name;\n}\n</code>\n<|/ a |>\n<| c |>\nThanks for the help but i think\
    \ its not what i need. Your script is almost like mine, but i need an alternative\
    \ to return the extension name that fits best.\n<|/ c |>\n<| c |>\nWhat do you\
    \ mean by \"best\"? The code I provided returns the extension name that has the\
    \ strongest extension. You might have some luck using some of your code to get\
    \ an alternate solution.\n<|/ c |>\n<| c |>\nI guess i should have been more clear.\
    \ Thanks for your help anyways.\n<|/ c |>\n<| c |>\nI added a potential solution\
    \ for you.\n<|/ c |>\n<| c |>\nAh yeah, that was the tricky part i was missing\
    \ from my code. Thanks man i appreciate it a lot! :) Good luck with the other\
    \ parts of the project.\n<|/ c |>\n<| a dscore=0 tags=string,php,algorithm,permutation\
    \ |>\nI think something like this will work:\n<code>\n$extensions = array(\n'AA',\n\
    'BB',\n'CC',\n'DD',\n'EE',\n'FF',\n'GG',\n'HH',\n'II',\n'JJ',\n'KK',\n'LL',\n\
    'MM',\n'NN',\n'OO',\n'PP',\n'QQ',\n'RR',\n'SS',\n'TT',\n'UU',\n'VV',\n'WW',\n\
    'XX',\n'YY',\n'ZZ'\n);\n$best_extension = 0;\n$best_extension_name = '';\nforeach($extensions\
    \ as $extension)\n{\n    $best_extension_name = $extension . $best_extension_name;\n\
    \    $best_extension = $best_extension + 1;\n}\nif($best_extension > 0)\n{\n \
    \   $best_extension_name = $best_extension_name . '.' . $extensions[$best_extension-1];\n\
    }\n$best_extension_name;\n</code>\n<|/ a |>\n<| c |>\nThanks, but i need to have\
    \ the extension returned instead of an integer, that is the tricky part.\n<|/\
    \ c |>\n<| c |>\nYou would have to change the code to ", "  // This code assumes\
    \ that the extensions are given in ascending order of strength.\n  // This can\
    \ be fixed in the future but is not implemented here yet.\n  \n  $extensions =\
    \ array_flip($extensions);\n  $strengths = array_count_values($extensions);\n\
    \  arsort($strengths);\n  \n  // Get the first extension with strength equal to\
    \ the most frequent.\n  $strongest = null;\n  $strongest_strength = -1;\n  foreach\
    \ ($strengths as $extension_name => $strength) {\n    if ($strongest_strength\
    \ == -1 || $strength >= $strongest_strength) {\n      $strongest_strength = $strength;\n\
    \      $strongest = $extension_name;\n    }\n  }\n  \n  if ($strongest_strength\
    \ == -1) {\n    // No extensions match the most frequent strength. Throw an exception.\n\
    \    throw new Exception(\"No strongest extension was found for $class_name\"\
    );\n  }\n  \n  return $class_name . \".$strongest\";\n}\n", "    $counter = array();\n\
    \    foreach($extensions as $extension) {\n        $name = ucfirst($extension);\n\
    \        $counter[$name]++;\n        $counter[$name . strtolower($extension)]++;\n\
    \        $counter[$name . strtoupper($extension)]++;\n    }\n    $max = max($counter);\n\
    \    $max_name = \"\";\n    foreach($counter as $name => $count) {\n        if\
    \ ($count == $max) {\n            $max_name = $name;\n            break;\n   \
    \     }\n    }\n    return $class_name . \".\" . $max_name;\n}\n</code>\nIt also\
    \ checks whether the class name doesn't have any uppercase letters. \nIf it does,\
    \ it returns the class name with all the uppercase letters.\nIf not, it returns\
    \ the class name with all the lowercase letters.\n<|/ a dscore=4 |>\n<| c |>\n\
    Nice idea, but it fails when you try to find the extension when it's mixed case\
    \ and has a period. `Strongest_Extension(\"myclass\", array(\"AA\", \"BE\", \"\
    CC\"))` returns `myclass.AA` when it should be `myClass.AA`\n<|/ c |>\n<| c |>\n\
    I guess you should not assume that there is only one uppercase character in the\
    \ extension name.\n<|/ c |>\n<| a |>\nI needed this functionality as well, and\
    \ after some research and trials, I got what I think is a good result:\n<code>\n\
    <?php", "    \n    // Sort the extensions by the strongest one (strength == -1)\n\
    \    sort($extensions, SORT_NUMERIC);\n    \n    // Get the number of uppercase\
    \ letters in the extension's name\n    $cap = substr_count($class_name, 'U');\n\
    \    \n    // Get the number of lowercase letters in the extension's name\n  \
    \  $sm = substr_count($class_name, 'l');\n    \n    // Return the extension that\
    \ has the smallest strength.\n    return $extensions[floor($cap - $sm)];\n}\n\
    </code>\n<|/ a tags=php,arrays,algorithm dscore=0 |>\n<| c |>\nThanks, I was looking\
    \ for a way to do it programmatically. Thanks for your answer :)\n<|/ c |>\n<|\
    \ a dscore=0 tags=php,arrays,algorithm |>\nA bit of refactoring would make this\
    \ a little bit easier to read and maintain.\n<code>\n$extensions = array('Slices','StuFfed','Cheese');\n\
    $class = \"Slices\";\n\n$classParts = explode(\"_\", $class);\n$classStrongest\
    \ = Strongest_Extension($class, $extensions);\n$classStrongestParts = explode(\"\
    _\", $classStrongest);\n\n$returnClass = \"\";\n$returnClass = $classParts[0];\n\
    foreach ($classParts as $key => $classPart) {\n    if($key === 0) continue;\n\
    \    $returnClass .= $classPart . \"_\";\n}\n\nreturn $returnClass . $classStrongestParts[1];\n",
  "    if (count($extensions) < 1) {\n        return $class_name;\n    }\n\n    $strongest_extension\
    \ = null;\n    sort($extensions);\n    $array_length = count($extensions);\n \
    \   for ($i = 0; $i < $array_length; $i++) {\n        if ($extensions[$i] > 0)\
    \ {\n            $strongest_extension = $class_name . \"\\\\\" . $extensions[$i];\n\
    \            break;\n        }\n    }\n\n    return $strongest_extension;\n}\n\
    </code>\n<|/ a tags=php |>\n<| c |>\nThis should be the accepted answer. Just\
    \ added my own one because it was a bit different, but a similar solution. +1\
    \ and thanks!\n<|/ c |>\n<| c |>\nI believe this will not work when you have different\
    \ uppercase chars.\n<|/ c |>\n<| a tags=php |>\nI have written this simple script\
    \ which solved my problem.\n<code>\n<?php", "  $n = preg_replace(\"/[^A-Z]+/\"\
    , \"\", $class_name);\n  $m = preg_replace(\"/[^a-z]+/\", \"\", $class_name);\n\
    \  $x = preg_replace(\"/[^A-Za-z]+/\", \"\", $class_name);\n  $cap = preg_replace(\"\
    /[^A-Z]+/\", \"\", preg_replace(\"/[^A-Z]+/\", \"\", $x));\n  $sm = preg_replace(\"\
    /[^a-z]+/\", \"\", preg_replace(\"/[^a-z]+/\", \"\", $x));\n  $x = preg_replace(\"\
    /[^A-Za-z]+/\", \"\", preg_replace(\"/[^A-Za-z]+/\", \"\", $x));\n  $strength\
    \ = -1;\n  $extensions_length = count($extensions);\n  $extensions_found = 0;\n\
    \  for ($i = 0; $i < $extensions_length; $i++) {\n    $length = strlen($extensions[$i]);\n\
    \    if ($x[$i] != $extensions[$i][$length]) {\n      if ($extensions_found ==\
    \ $strength) {\n        $extensions_found = 0;\n        break;\n      }\n    \
    \  $extensions_found = $strength;\n    }\n    $extensions_found++;\n    if ($extensions_found\
    \ > $strength) {\n      $strength = $extensions_found;\n    }\n  }\n  if ($extensions_found\
    \ == $strength) {\n    $extensions_found = 0;\n  }\n  $class = $class_name;\n\
    \  $extension = $class_name . $extensions[$extensions_found];\n  $extension_length\
    \ = strlen($extension);\n  $extension_found = 0;\n  for ($i = 0; $i < $extension_length;\
    \ $i++) {\n    $length = strlen($extension);\n    if ($class[$i] != $extension[$i])\
    \ {\n      if ($extension_found == $strength) {\n        $extension_found = 0;\n\
    \        break;\n      }\n      $extension_found = $strength;\n    }\n    $extension_found++;\n\
    \    if ($extension_found > $strength) {\n      $strength = $extension_found;\n\
    \    }\n  }\n  if ($extension_found == $strength) {\n    $extension_found = 0;\n\
    \  }\n  return $class . $extensions[$extension_found];\n}", "  $len = strlen($class_name);\n\
    \  $cap = $len = strlen($class_name);\n  foreach ($extensions as $key => $value)\
    \ {\n    $cap += $value;\n    if ($cap > $len) {\n      $len = $cap;\n    }\n\
    \  }\n  $cap = $len - strlen($class_name);\n  foreach ($extensions as $key =>\
    \ $value) {\n    $sm = $key;\n    if ($sm < $cap) {\n      $sm = $cap;\n    }\n\
    \    $strength = abs($cap - $sm);\n    if ($strength > 0) {\n      return $class_name\
    \ . \".\" . substr($class_name, 0, $sm) . $value;\n    }\n  }\n  return $class_name\
    \ . \".\" . substr($class_name, 0, $sm) . $extensions[0];\n}", "  foreach ($extensions\
    \ as $extension) {\n    $class_name = $class_name . \".\" . $extension;\n    if\
    \ (class_exists($class_name)) {\n      return $class_name;\n    }\n  }\n  return\
    \ null;\n}", "    $class_array = explode(\".\", $class_name);\n    \n    $new_class_array\
    \ = $class_array;\n    \n    foreach ($extensions as $ext) {\n        list($cap,\
    \ $sm) = explode(\"_\", $ext);\n        $new_class_array[$cap] = $ext;\n    }\n\
    \    \n    return implode(\".\", $new_class_array);\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=arrays,php |>\nI used the same answer by but modified it a little.\n\
    <code>", "\t$extension_count = count($extensions);\n\t$class_name_split = explode('_',\
    \ $class_name);\n\t$extension_count_split = count($class_name_split);\n\t$extension_strength\
    \ = 0;\n\t\n\tfor($i = 0; $i < $extension_count_split; $i++) {\n\t\t$extension_str_count\
    \ = count($class_name_split[$i]);\n\t\t\n\t\tfor($j = 0; $j < $extension_str_count;\
    \ $j++) {\n\t\t\tif($class_name_split[$i][$j] == strtoupper($extensions[$i][$j]))\
    \ {\n\t\t\t\t$extension_strength++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\
    \t$extension_strength = floor(($extension_strength/$extension_count)*100);\n\t\
    \n\t\n\tfor($i = 0; $i < $extension_count; $i++) {\n\t\t$extension_str_count =\
    \ count($class_name_split[$i]);\n\t\t\n\t\tfor($j = 0; $j < $extension_str_count;\
    \ $j++) {\n\t\t\tif($class_name_split[$i][$j] == strtoupper($extensions[$i][$j]))\
    \ {\n\t\t\t\t$extension_strength = $extension_strength - 1;\n\t\t\t\tbreak;\n\t\
    \t\t}\n\t\t}\n\t}\n\t\n\t\n\t\n\t\n\t\n\t\n\treturn $class_name . '_' . strtoupper($extensions[0])\
    \ . str_repeat(substr($extension_strength, 2), -$extension_count);\n}\n", "  for\
    \ ($i = 0; $i < count($extensions); $i++) {\n    if (mb_strtoupper(mb_substr($extensions[$i],\
    \ 0, 1)) > mb_strtoupper(mb_substr($class_name, 0, 1))) {\n      break;\n    }\
    \ else if (mb_strtolower(mb_substr($extensions[$i], 0, 1)) < mb_strtolower(mb_substr($class_name,\
    \ 0, 1))) {\n      break;\n    } else if ($extensions[$i] == $class_name) {\n\
    \      $strength = -1;\n      break;\n    } else {\n      $extensions[$i] = strtolower($extensions[$i]);\n\
    \      $extensions[$i] = mb_strtolower($extensions[$i]);\n      $extensions[$i]\
    \ = mb_substr($extensions[$i], 1);\n      $extensions[$i] = mb_substr($extensions[$i],\
    \ 0, -1);\n      $strength = mb_strtoupper(mb_substr($extensions[$i], 0, 1)) -\
    \ mb_strtoupper(mb_substr($extensions[$i], 0, 1));\n    }\n  }\n  return $class_name.$extensions[array_search($strength,\
    \ $extensions)];\n}", "    // Your code here.\n    \n    $extensions_count = count($extensions);\n\
    \    $strongest_extension = NULL;\n    $strongest_strength = -1;\n\n    for($i\
    \ = 0; $i < $extensions_count; $i++){\n        $strongest_extension .= $class_name.$extensions[$i];\n\
    \        $strength = preg_match(\"/([A-Z]+)([a-z]+)/\", $extensions[$i], $matches);\n\
    \        $strongest_strength = $strength ? $strength - $matches[1] - $matches[2]\
    \ : -1;\n    }\n    return $strongest_extension;\n}\n\n/* \n * Function to display\
    \ the best extension based on given extension name and class\n * Author: Chetan\
    \ Ranpariya\n * Date: 12/27/2016\n * Purpose: To display the best extension based\
    \ on given extension name and class\n */", "\t$class_name = strtolower($class_name);\n\
    \t$extensions = array_map(\n\t\tfunction($extension) {\n\t\t\treturn strtolower($extension);\n\
    \t\t},\n\t\t$extensions\n\t);\n\t\n\t$extension_strength = [];\n\tforeach ($extensions\
    \ as $extension) {\n\t\t$extension_strength[$extension] = 0;\n\t}\n\t\n\tforeach\
    \ ($extensions as $i => $extension) {\n\t\tforeach ($extensions as $j => $other_extension)\
    \ {\n\t\t\tif ($extension == $other_extension) {\n\t\t\t\tcontinue;\n\t\t\t}\n\
    \t\t\tif (preg_match(\"/$extension/\", $other_extension)) {\n\t\t\t\t$extension_strength[$other_extension]\
    \ += 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tarsort($extension_strength);\n\t\n\t$strongest_extension\
    \ = $extensions[0];\n\tforeach ($extension_strength as $extension => $strength)\
    \ {\n\t\tif ($strength > 0) {\n\t\t\t$strongest_extension = $extension;\n\t\t\
    }\n\t}\n\t\n\treturn $class_name . $strongest_extension;\n}\n", "  $CAP = 0;\n\
    \  $SM = 0;\n  foreach ($extensions as $ext) {\n    $CAP += ctype_upper($ext);\n\
    \    $SM += ctype_lower($ext);\n  }\n\n  if ($CAP - $SM == 0) {\n    return $class_name;\n\
    \  }\n\n  return $class_name . Strongest_Extension_Score($class_name, $extensions);\n\
    }\n", "    sort($extensions);\n    \n    $strongest_extension = null;\n    \n\
    \    foreach ($extensions as $k => $extension) {\n        // Capitalize letters\
    \ starting from the first\n        $length = strlen($extension);\n        \n \
    \       $lower_extension = strtolower($extension);\n        $cap_extension = ucfirst($lower_extension);\n\
    \        $capit_extension = ucfirst($cap_extension);\n        $sm = strlen($lower_extension);\n\
    \        $cap = strlen($cap_extension);\n\n        $ratio = $cap / $sm;\n    \
    \    \n        $strength = -1 - ($length - ($cap - $sm));\n        \n        if\
    \ ($ratio > 0.5) {\n            $strength += $length;\n        }\n        \n \
    \       if ($strength >= 0) {\n            if ($strongest_extension == null) {\n\
    \                $strongest_extension = $class_name . \".\" . $capit_extension;\n\
    \            }\n            \n            // Sort them by strength\n         \
    \   if ($strength > $strongest_extension_strength) {\n                $strongest_extension_strength\
    \ = $strength;\n                $strongest_extension = $class_name . \".\" . $extension;\n\
    \            }\n        }\n    }\n    \n    return $strongest_extension;\n}\n\
    </code>\nThe code in the original post has many errors, but this one is the only\
    \ one I find so difficult to fix.\n<|/ a |>\n<| c |>\nYour code gives an error\
    \ on line 10 (the if/else statement). I'm not sure I understand why it would give\
    \ this error.\n<|/ c |>\n<| c |>\nI'm sorry, I forgot to include $strongest_extension_strength\
    \ before I edited my answer, I've just edited it. But still don't get why this\
    \ gives you an error.\n<|/ c |>\n<| c |>\nIt gives me an error on line 10: if\
    \ ($strongest_extension == null) {\n<|/ c |>\n<| c |>\nI'm just guessing that\
    \ maybe you have some hidden character at the beginning of your file, just before\
    \ the <?php\n<|/ c |>\n<| c |>\nI just tried this on my server with exactly the\
    \ same code and it works fine, try copying and pasting my exact code\n<|/ c |>\n\
    <| a tags=php |>\nUse a loop\n<code>\nfor($i = 0; $i < count($extension_name);\
    \ $i++){\n $extension_name[$i];\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\n<code>\n$extension_name[] = $extension;", "    sort($extensions);\n    $strength\
    \ = array();\n    $extensions_count = count($extensions);\n    for ($i = 0; $i\
    \ < $extensions_count; $i++) {\n        $strongest = $extensions[$i];\n      \
    \  $count = 1;\n        for ($j = $i+1; $j < $extensions_count; $j++) {\n    \
    \        if (strcasecmp($extensions[$j], $strongest) === 0) {\n              \
    \  $count++;\n            }\n        }\n        $strength[$i] = $count;\n    }\n\
    \    for ($i = 0; $i < $extensions_count; $i++) {\n        $count = 1;\n     \
    \   for ($j = $i+1; $j < $extensions_count; $j++) {\n            if ($strength[$i]\
    \ >= $strength[$j]) {\n                $count++;\n            }\n        }\n \
    \       if ($count == 1) {\n            return $class_name . \".\" . $extensions[$i];\n\
    \        }\n    }\n}\n", "  // Your code here\n  $strongest_extension = NULL;\n\
    \  $max_strength = -1;\n  foreach ($extensions as $extension) {\n    $extension\
    \ = str_replace('Slices', '', strtolower($extension));\n    if (strlen($extension)\
    \ > 0) {\n      $strength = substr_count($extension, \"ca\") - substr_count($extension,\
    \ \"sm\");\n      if ($strength > $max_strength) {\n        $max_strength = $strength;\n\
    \        $strongest_extension = $extension;\n      }\n    }\n  }\n  if ($strongest_extension\
    \ === NULL && count($extensions) > 0) {\n    $strongest_extension = $extensions[0];\n\
    \  }\n  if ($strongest_extension === NULL) {\n    $strongest_extension = 'NONE';\n\
    \  }\n  return $class_name . '.' . $strongest_extension;\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThanks so much for this! It worked perfectly. I was able to expand it\
    \ to fit my needs.\n<|/ c |>\n<| c |>\nThis is not an efficient algorithm. With\
    \ thousands of extensions, this would be extremely inefficient.\n<|/ c |>\n<|\
    \ a |>\n<code>\n<?php\n$name = 'Slices';\n$extensions = array('SErviNGSliCes',\
    \ 'Cheese', 'StuFfed');\n\n$str = preg_replace_callback('/([a-z])/', function($match)\
    \ use ($name, $extensions){\n    foreach ($extensions as $extension){\n      \
    \  if ($match[1] === substr($extension, 0, 1)) {\n            return $name . '.'\
    \ . $extension;\n        }\n    }\n}, '' . strtolower($name));\n\nvar_dump($str);\n\
    </code>\nOutput\n<code>\nstring(28) \"my_class.SErviNGSliCes\"\n</code>\n<|/ a\
    \ tags=arrays,php dscore=3 |>\n<| c |>\nThanks for the answer. This worked too\
    \ but I was able to expand it to my needs.\n<|/ c |>\n<| c |>\nHmm, didn't quite\
    \ work for me when there are multiple upper case letters in the name. See my answer\
    \ for how I fixed that.\n<|/ c |>\n<| c |>\nI updated the code. Now it works correctly\
    \ with multiple upper case letters in the name.\n<|/ c |>\n<| a dscore=2 |>\n\
    Using array_reduce() you can easily get the desired output:\n<code>\n$name = 'Slices';\n\
    $extensions = array('SErviNGSliCes', 'Cheese', 'StuFfed');\n\n$str = $name ",
  "    $num_uppercase = array_count_values(array_map(\"mb_strtoupper\", $extensions));\n\
    \    $num_lowercase = array_count_values(array_map(\"mb_strtolower\", $extensions));\n\
    \    $strongest = -1;\n    foreach ($extensions as $ext) {\n        if ($num_uppercase[$ext]\
    \ > $num_lowercase[$ext]) {\n            $strongest = $ext;\n        }\n    }\n\
    \    return $class_name . \".\" . $strongest;\n}\n</code>\n<|/ a tags=reflection,php,oop\
    \ |>\n<| c |>\nThe array_count_values() will count the amount of times the extension\
    \ has been used, but will ignore the uppercase letters of the extension.\n<|/\
    \ c |>\n<| c |>\nGood point. I edited my post to add a second way to calculate\
    \ the strongest extension without ignoring the uppercase letters.\n<|/ c |>\n\
    <| c |>\nThis will not work if an extension has two or more classes with the same\
    \ number of uppercase letters. Consider `Foo.AAA` and `Foo.AAA` which both have\
    \ the same number of uppercase letters. The first one will get strongest.\n<|/\
    \ c |>\n<| c |>\nI edited my answer to include your suggestion.\n<|/ c |>\n<|\
    \ c |>\nThanks, this works. But it would be better if someone could explain how\
    \ this is working. Thank you :)\n<|/ c |>\n<| a dscore=1 tags=reflection,php,oop\
    \ |>\nI've done this in the past by extending PHP's reflection capabilities. I\
    \ haven't tested this code, though.\n<code>\nclass MyClass\n{\n    public function\
    \ __construct()\n    {\n        // ...\n    }\n}\n\nclass MyOtherClass\n{\n  \
    \  public function __construct()\n    {\n        // ...\n    }\n}\n\nclass MyThirdClass\n\
    {\n    public function __construct()\n    {\n        // ...\n    }\n}\n", "  $max_strength\
    \ = -1;\n  $max_extension = NULL;\n  foreach ($extensions as $ext) {\n    $len\
    \ = strlen($ext);\n    if ($len > strlen($class_name)) {\n      continue;\n  \
    \  }\n    $cap = strtoupper($ext);\n    $sm = strtolower($ext);\n    $diff = intval($cap\
    \ - $sm);\n    if ($diff > $max_strength) {\n      $max_strength = $diff;\n  \
    \    $max_extension = $ext;\n    }\n  }\n  return $class_name.\".\".$max_extension;\n\
    }\n", "    $fractal_cap = array_count_values(str_split($class_name))[1];\n   \
    \ $fractal_sm = array_count_values(str_split($class_name))[0];\n\n    sort($extensions);\n\
    \    $strongest = false;\n\n    foreach ($extensions as $extension) {\n      \
    \  $fractal_ext = array_count_values(str_split($extension))[1];\n        if ($fractal_cap\
    \ == $fractal_ext) {\n            $fractal_ext *= -1;\n        }\n        if ($fractal_sm\
    \ == $fractal_ext) {\n            $fractal_ext *= -1;\n        }\n\n        if\
    \ ($fractal_cap - $fractal_sm == $fractal_ext) {\n            $strongest = $extension;\n\
    \            break;\n        }\n    }\n\n    return $class_name . $strongest;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI edited the answer to include an example\
    \ of a function that returns the strongest extension.\n<|/ c |>\n<| a dscore=0\
    \ |>\nFor me it looks like an overkill. I've written it for you. Please check\
    \ if this is what you need:\n<code>", "    $strengths = array_count_values($extensions);\n\
    \    $min_strength = array_search(min($strengths), $strengths);\n    $max_strength\
    \ = array_search(max($strengths), $strengths);\n    foreach ($extensions as $extension)\
    \ {\n        $letters = substr_count($extension, ' ');\n        if ($letters ==\
    \ strlen($extension) - $letters + 1) {\n            $strengths[$extension] +=\
    \ $letters / strlen($extension);\n        }\n    }\n    arsort($strengths);\n\
    \    $strongest = $class_name . '.' . key($strengths);\n    $last_extension =\
    \ array_pop($extensions);\n    while (!empty($extensions)) {\n        arsort($strengths);\n\
    \        $candidate = $class_name . '.' . key($strengths);\n        if ($candidate\
    \ == $strongest) {\n            return $last_extension;\n        }\n        $last_extension\
    \ = array_pop($extensions);\n    }\n    return $strongest;\n}\n</code>\n<|/ a\
    \ dscore=2 tags=php |>\n<| c |>\nThank you so much for this answer! I have adapted\
    \ it to my situation and it worked flawlessly!\n<|/ c |>\n<| c |>\nVery nice solution!\
    \ Thanks for sharing! I just want to add that it's worth noting that `array_search`\
    \ returns the first element that matches the search (i.e. the first index), while\
    \ `array_search` returns the key of the element that matches the search (i.e.\
    \ the second element).\n<|/ c |>\n<| c |>\n: Yes, that's right, I've corrected\
    \ the answer. Thanks for noting.\n<|/ c |>\n<| a |>\nTry this code\n<code>\n$classname\
    \ = 'MyClass';\n$extensions = ['AA', 'BB', 'CC'];\n\n$class_name = $classname;\n\
    $extensions_count = count($extensions);\nfor($i=0;$i<$extensions_count;$i++){\n\
    \    $class_name .= '.' . $extensions[$i];\n}\n</code>\n<|/ a tags=php dscore=0\
    \ |>\n<| a |>\nI think this is what you are looking for:\n<code>\n<?php\n$classname\
    \ = 'MyClass';\n$extensions = ['AA', 'BB', 'CC'];\n$class_name = $classname;\n\
    \nforeach ($extensions as $key => $extension) {\n    $class_name .= '.' . $extension;\n\
    }\n</code>\n<|/ a tags=php dscore=0 |>\n<| c |>\nI don't think this is what he\
    \ is looking for, as he wants a string like \"MyClass.AA.BB", "  sort($extensions);\n\
    \  $length = strlen($class_name);\n  \n  foreach($extensions as $extension) {\n\
    \    $class_name = substr($class_name, 0, $length - strlen($extension))\n    \
    \  . $extension;\n  }\n  return $class_name;\n}\n", "  $highest_strength = -1;\n\
    \  $highest_class_name = $class_name;\n  $highest_extension = $class_name;\n \
    \ foreach ($extensions as $extension) {\n    $extension_strength = strlen($extension)\
    \ - strlen(strtoupper($extension));\n    if ($extension_strength > $highest_strength)\
    \ {\n      $highest_strength = $extension_strength;\n      $highest_class_name\
    \ = $class_name;\n      $highest_extension = $extension;\n    }\n  }\n  return\
    \ $highest_class_name . \".\" . $highest_extension;\n}\n", "  $extension_strength\
    \ = array();\n  foreach($extensions as $extension) {\n    $class_name_components\
    \ = explode('_', $class_name);\n    $extension_components = explode('_', $extension);\n\
    \    $class_name_components[] = $extension_components[0];\n    $extension_strength[$extension]\
    \ = strlen($class_name_components);\n  }\n  $sorted_strength = array_sort($extension_strength,\
    \ SORT_STRING);\n  ksort($extension_strength);\n  $strongest_extension_found =\
    \ false;\n  $strongest_extension = \"\";\n  foreach ($sorted_strength as $key\
    \ => $strength) {\n    if ($strength == -1) {\n      $strongest_extension_found\
    \ = true;\n      break;\n    }\n    if ($strongest_extension_found) {\n      $strongest_extension\
    \ = $key;\n    }\n  }\n  if ($strongest_extension_found) {\n    return $class_name.$strongest_extension;\n\
    \  } else {\n    throw new Exception(\"Can't find strongest extension in list\
    \ of extensions \".$extensions);\n  }\n}", "\t\n\tif (count($extensions) == 0)\
    \ return \"\";\n\t\n\t$strengths = array();\n\t\n\tforeach ($extensions as $extension)\
    \ {\n\t\t\n\t\t$name = strtolower($extension);\n\t\t$name = preg_replace('/[^a-z0-9]/',\
    \ '', $name);\n\t\t\n\t\t$class_parts = explode(\"\\\\\", $class_name);\n\t\t\
    $class_name = $class_parts[count($class_parts) - 1];\n\t\t\n\t\t$strength = 0;\n\
    \t\t\n\t\tfor ($i = 0; $i < strlen($name); $i++) {\n\t\t\t\n\t\t\tif ($name[$i]\
    \ == $name[$i+1]) {\n\t\t\t\t$strength++;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\
    \t}\n\t\t}\n\t\t\n\t\t$strengths[$name] = $strength;\n\t}\n\t\n\t$strengths_sorted\
    \ = array();\n\t\n\tforeach ($strengths as $name => $strength) {\n\t\t\n\t\t$strengths_sorted[]\
    \ = array('name' => $name, 'strength' => $strength);\n\t}\n\t\n\tarray_multisort($strengths_sorted['strength'],\
    \ SORT_DESC, $strengths_sorted);\n\t\n\tforeach ($strengths_sorted as $sort_by_strength)\
    \ {\n\t\t\n\t\tif ($sort_by_strength['strength'] == 1) {\n\t\t\t\n\t\t\t$class_name\
    \ .= \".$sort_by_strength['name']\";\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn $class_name;\n\
    }\n", "  $extensions_array = array();\n  foreach ($extensions as $extension) {\n\
    \    $parts = explode('_', $extension);\n    foreach ($parts as $part) {\n   \
    \   $extensions_array[$part] = $extension;\n    }\n  }\n  $strongest_extension\
    \ = -1;\n  foreach ($extensions_array as $extension => $value) {\n    if ($strongest_extension\
    \ == -1) {\n      if (ctype_upper($extension) == ctype_upper($value)) {\n    \
    \    $strongest_extension = $extension;\n      }\n    }\n    if (ctype_lower($extension)\
    \ == ctype_lower($value)) {\n      $strongest_extension = $extension;\n    }\n\
    \  }\n  if ($strongest_extension == -1) {\n    return $class_name.$extensions[0];\n\
    \  }\n  return $class_name.$strongest_extension.$extensions[0];\n}", "  // Write\
    \ your code here.\n\n}\n", "    $extensions_count = count($extensions);\n    $i\
    \ = 0;\n    $strength_max = -1;\n\n    while($i < $extensions_count) {\n     \
    \   $next_extension = $extensions[$i];\n        $next_extension_count = count($extensions);\n\
    \n        $j = 0;\n        $strength_min = -1;\n\n        while($j < $extensions_count)\
    \ {\n            $next_extension_next = $extensions[$j];\n\n            if($next_extension_next\
    \ == $next_extension) {\n                $strength_min = $j;\n            }\n\n\
    \            $j++;\n        }\n\n        $strength = $next_extension_count-$strength_min;\n\
    \n        if($strength >= 0) {\n            if($strength > $strength_max) {\n\
    \                $strength_max = $strength;\n            }\n        }\n\n    \
    \    $i++;\n    }\n\n    sort($extensions);\n    $extension_str = $class_name;\n\
    \    $strength_count = 0;\n\n    foreach($extensions as $extension) {\n      \
    \  $extension_count = count($extensions);\n        $last_extension_str = $extension;\n\
    \n        for($i = $extension_count-1; $i >= 0; $i--) {\n            $extension_next\
    \ = $extensions[$i];\n\n            if($extension_next == $extension) {\n    \
    \            $extension_str .= $extension_next;\n            }\n\n           \
    \ if($extension_count > 1) {\n                $extension_str .= '.'.$extension;\n\
    \            }\n        }\n\n        if($strength_count < $strength_max) {\n \
    \           $extension_str .= '.'.$last_extension_str;\n        }\n\n        $strength_count++;\n\
    \    }\n\n    return $extension_str;\n}\n</code>\n<|/ a |>\n<| a tags=algorithm,php,string,permutation\
    \ |>\nHere is the Python solution:\n<code>\ndef strongestExtension(str,extensions):\n\
    \    exts = set(x[::-1] for x in extensions)\n    i = len(str) - 1\n    extension\
    \ = None\n    count = len(extensions)\n    while i > 0:\n        for j in range(i):\n\
    \            if str[i:] in exts and str[:i] in exts:\n                extension\
    \ = str[:i] + str[i:]\n                count -= 1\n                break\n   \
    \     i -= 1\n    return extension\n</code>\n<|/ a dscore=0 |>\n<| a tags=algorithm,php,string,permutation\
    \ |>\nHere's another solution:\n<code>", "  if (array_count_values($extensions)\
    \ == 1) {\n    return $class_name;\n  }\n  $max_strength = 0;\n  $strongest_ext\
    \ = NULL;\n  foreach ($extensions as $extension) {\n    $strength = substr($extension,\
    \ 0, strlen($extension) - 1);\n    if ($strength > $max_strength) {\n      $max_strength\
    \ = $strength;\n      $strongest_ext = $extension;\n    }\n  }\n  return $class_name\
    \ . '.' . $strongest_ext;\n}\n</code>\nTest Results:\n<code>\n$ php strongest.php\n\
    my_class.AA\nmy_class.BE\nmy_class.CC\nmy_class.DD\n</code>\n<|/ a |>\n<| a dscore=2\
    \ |>\nThis is my solution. It handles both uppercase and lowercase strings with\
    \ any number of extensions.\n<code>", "  $extension_counts = array_count_values($extensions);\n\
    \  arsort($extension_counts);\n  $strongest_extension = $class_name.'.'.$extensions[0];\n\
    \  for ($i = 1; $i < count($extension_counts); $i++) {\n    $fraction = ($extension_counts[$class_name.$extensions[$i]]\
    \ - $extension_counts[$strongest_extension]) / $extension_counts[$class_name.$extensions[$i]];\n\
    \    $strongest_extension = $class_name.'.'.$extensions[$i];\n    if ($fraction\
    \ == 1.0) {\n      break;\n    }\n  }\n  return $strongest_extension;\n}\n", " \
    \   $counts = array();\n    foreach ($extensions as $key => $ext) {\n        $counts[strtoupper($ext)]\
    \ = isset($counts[strtoupper($ext)]) ? $counts[strtoupper($ext)] + 1 : 1;\n  \
    \  }\n    $max_extension = array_search(max($counts), $counts);\n    return $class_name\
    \ . \".\" . $max_extension;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nCan you please\
    \ elaborate on this line? $max_extension = array_search(max($counts), $counts);\n\
    <|/ c |>\n<| c |>\n: This code uses the strongest extension as the name of the\
    \ class. Since `array_search` returns the key of the found element, we need to\
    \ compare the strength of the extension with the value returned by `array_search`\
    \ of the value returned by `max`. Of course, this only works if all extensions\
    \ have a strength greater than zero (as indicated in your example). I don't think\
    \ this is what you want, but perhaps that's not what you're asking for.\n<|/ c\
    \ |>\n<| a dscore=0 |>\nOkay, here's my solution:\n<code>", "    sort($extensions);\n\
    \    $frac = array_count_values($extensions)[strtoupper($extensions[0]) - strtolower($extensions[0])];\n\
    \    return $class_name . '.' . strtoupper(substr($class_name, 0, 1)) . str_repeat('?',\
    \ $frac);\n}\n</code>\nHere is an explanation of how it works:\nThe main algorithm\
    \ is straightforward: sort all the extensions (alphabetically, ignoring the case)\
    \ and then find the most common one.\nIf the most common one is the last extension,\
    \ you need to add the remaining extensions ? in between the first and last characters\
    \ of the first extension (if any).\n<|/ a tags=php,algorithm,classname |>\n<|\
    \ c |>\nWhy not `$frac = array_count_values($extensions)[strtoupper($extensions[0])-strtolower($extensions[0])];`\
    \ instead ?\n<|/ c |>\n<| c |>\n: Good question. I'm a bit tired and forgot about\
    \ that possibility.\n<|/ c |>\n<| c |>\n, I'm getting this error: `Fatal error:\
    \ Call to undefined function array_count_values()`\n<|/ c |>\n<| c |>\n: In PHP\
    \ 5 there is [`array_count_values`](http://php.net/array_count_values) function\
    \ that can be used instead of `array_map` and `array_reduce`.\n<|/ c |>\n<| a\
    \ tags=php,algorithm,classname |>\n<code>", "  $n = strlen($class_name);\n  usort($extensions,\
    \ function($a, $b) {\n    $a_uc = strtoupper($a);\n    $b_uc = strtoupper($b);\n\
    \    if ($a_uc == $b_uc) return 0;\n    return ($a_uc < $b_uc) ? -1 : 1;\n  });\n\
    \  return $class_name . (array_shift($extensions));\n}\n", "    $strongest = -1;\n\
    \n    // Count the number of uppercase letters in the name\n    $count = preg_match_all('/[A-Z]/i',\
    \ $class_name, $matches);\n\n    // Count the number of lowercase letters in the\
    \ name\n    $count2 = preg_match_all('/[a-z]/i', $class_name, $matches);\n\n \
    \   // Determine the number of possible extensions\n    $num = $count + $count2;\n\
    \n    // Assign the strongest extension based on the number of possible extensions\n\
    \    foreach ($extensions as $ext) {\n        if ($ext === $class_name || ($num\
    \ % strlen($ext) >= $strongest)) {\n            $strongest = $num / strlen($ext);\n\
    \        }\n        $num--;\n    }\n\n    // Return the class name with the strongest\
    \ extension appended to the name\n    return $class_name . $strongest . '.' .\
    \ array_shift($extensions);\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nYou shouldn't\
    \ need to use regex. PHP has the `strpos` and `substr` functions to do this.\n\
    <|/ c |>\n<| c |>\nI was thinking about using regex when I posted this but it\
    \ was too much for my taste. Your method is much simpler, I just didn't know where\
    \ to start. I'll post an answer shortly but I'll leave this answer up because\
    \ it's an interesting problem.\n<|/ c |>\n<| c |>\nI've posted an answer which\
    \ I thought I'd share. You could use my code as a base for another answer.\n<|/\
    \ c |>\n<| a dscore=0 |>\nIt's a bit crude, but it works in PHP. It counts the\
    \ number of uppercase letters in the class and compares the number with the number\
    \ of extensions. It returns the class name with the strongest extension.\n<code>\n\
    <?php", "    // Your code here\n}\n"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
