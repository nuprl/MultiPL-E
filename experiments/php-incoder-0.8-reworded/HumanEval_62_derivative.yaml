name: HumanEval_62_derivative
language: php
prompt: "<?php\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] *\
  \ x + xs[2] * x^2 + ....\n// Return derivative of this polynomial in the same form.\n\
  // >>> derivative(array(3, 1, 2, 4, 5))\n// array(1, 4, 12, 20)\n// >>> derivative(array(1,\
  \ 2, 3))\n// array(2, 6)\nfunction derivative($xs) {\n"
tests: "function candidate(...$args) {\n    return derivative(...$args);\n}\n\nfunction\
  \ test(): void {\n    if (candidate(array(3, 1, 2, 4, 5)) !== array(1, 4, 12, 20))\
  \ { throw new Exception(\"Test failed!\"); }\n    if (candidate(array(1, 2, 3))\
  \ !== array(2, 6)) { throw new Exception(\"Test failed!\"); }\n    if (candidate(array(3,\
  \ 2, 1)) !== array(2, 2)) { throw new Exception(\"Test failed!\"); }\n    if (candidate(array(3,\
  \ 2, 1, 0, 4)) !== array(2, 2, 0, 16)) { throw new Exception(\"Test failed!\");\
  \ }\n    if (candidate(array(1)) !== array()) { throw new Exception(\"Test failed!\"\
  ); }\n}\n\ntest();"
completions: ["    $xs = array_slice($xs, 1); //remove $xs[0]\n    if (!count($xs))\
    \ return array(0);\n    $x = array_shift($xs); //remove $x\n    $xs = array_slice($xs,\
    \ 1); //remove $xs[0]\n    $ret = new self($x);\n    foreach ($xs as $_x) {\n\
    \        $ret[$_x + 1] = $ret[$_x + 1] * $x;\n    }\n    return $ret->toArray();\n\
    }\n", "  $ys = array_reverse($xs); // reverse the order of the array and flip\
    \ it so we get the derivative in the order we want.\n  $ys[0] = 0; // we start\
    \ with 0 as the first element of the derivation. \n  $n = count($ys) - 1; // number\
    \ of elements in the derivation \n  $product = 1; // to accumulate product of\
    \ the elements on the derivation \n  while ($n--) {\n    $product *= array_pop($ys);\n\
    \  }\n  return $product;\n}\n", "    $xs = array_map(function($x) {\n        return\
    \ $x * $x;\n    }, $xs);\n    $result = [];\n    do {\n        array_unshift($xs,\
    \ 0);\n        $derivative = 1;\n        foreach ($xs as $x) { $derivative *=\
    \ $x; }\n        array_shift($xs);\n        $result[] = $derivative;\n    } while\
    \ (count($xs));\n    return array_pop($result);\n}\n", "  $x = array_shift($xs);\n\
    \  return array_map(\n    function ($x) { return $x * $x; },\n    range(1, count($xs)\
    \ + 1)\n  ) + [$x];\n}\n</code>\nThe above function will work with any number\
    \ of arguments, including zero, and it will return the result as a one-dimensional\
    \ array.  \nNow, you have a function that, given a set of numbers, will return\
    \ the sum of them:\n<code>", "  $result = [];\n  $x = array_shift($xs);\n\n  foreach\
    \ ($xs as $coefficient) {\n    $result[] = $coefficient * $x;\n  }\n\n  return\
    \ $result;\n}\n</code>\n<|/ a |>\n<| a dscore=1 tags=math,php |>\nIn order to\
    \ use this code, you should install composer. \n<code>", "  $n = count($xs);\n\
    \  $f = $xs[0];\n  $ders = array();\n  for ($i = 1; $i < $n; ++$i) {\n    $ders[]\
    \ = $xs[$i] - $f;\n    $f = $xs[$i];\n  }\n  return $ders;\n}\n", "  return array_map(function($x)\
    \ use ($xs) {\n    return $x * array_shift($xs);\n  }, $xs);\n}\n", "  $d = array();\n\
    \  for ($i = 0; $i < count($xs); $i++) {\n    $d[$i] = array_pop($xs);\n  }\n\
    \  return $d;\n}\n", "  $result = [null, null];\n  for ($i = 0, $len = count($xs);\
    \ $i < $len; $i++) {\n    $result[$i] = $xs[$i];\n  }\n  $result[0] = $result[0]\
    \ * $result[0];\n  $result[1] = $result[1] - $result[0] * $result[1];\n  return\
    \ $result;\n}", "  $r = $xs[1];\n  $r = $r * $xs[2];\n  $r = $r * pow($xs[2],\
    \ $xs[0]);\n  $r = $r * pow(pow(pow($xs[2], $xs[0]), $xs[0]), $xs[0]);\n  for($i\
    \ = 1; $i < $xs[0]; $i++) {\n    $r = $r * $xs[$i];\n  }\n  return array($r);\n\
    }", "    $xs = array_map(null, $xs);\n    return array_map(null, $xs, array_slice($xs,\
    \ 1, null));\n}\n", "  $result = $xs[0];\n  for ($i = 1; $i < count($xs); $i++)\
    \ {\n    $result *= $xs[$i];\n  }\n  return $result;\n}\n", "  // If we have only\
    \ one point then return point at infinity (use zero derivative)\n  if (count($xs)\
    \ == 0) return array(0);\n  $order = count($xs) - 1;\n  // Calculate derivative\
    \ of xth order polynomial as a function of x.\n  // x[0] * x[1] * x[2] * ... *\
    \ x[n]\n  $dy = array(1);\n  for ($i = 0; $i < $order; $i++) {\n    $dy[] = ($xs[$i]\
    \ + 1) * $dy[$i];\n  }\n  return $dy;\n}\n", "  $n = count($xs);\n  if (!$n) return\
    \ array();\n  $d = array();\n  for ($i = 0; $i < $n; ++$i) {\n    $d[] = pow($xs[$i],\
    \ $n);\n  }\n  return $d;\n}", "    if (count($xs) < 1) {\n        return array();\n\
    \    }\n    $xs = array_reverse($xs);\n    $ys = array();\n    foreach ($xs as\
    \ $x) {\n        $y = $xs[count($xs) - 1];\n        for ($i = count($xs) - 1;\
    \ $i > 0; $i--) {\n            $y *= $xs[$i];\n        }\n        $ys[] = $y;\n\
    \    }\n    return $ys;\n}\n</code>\nThen using it to solve the problem of finding\
    \ the coefficients of a polynomial with m coefficients and n variables:\n<code>\n\
    $a = (array_map('intval', explode('*', $a)));\n$m = (count($a) - 1) - ($n + 1);\
    \ // Number of variables minus number of coefficients\n$coeffs = array();\nfor\
    \ ($i = 0; $i < $m; $i++) {\n    $coeffs[] = ($a[$i]); // Use coefficient $i to\
    \ compute coefficients.\n}\n</code>\nThe rest of the program was unchanged from\
    \ the first example:\n<code>\n$poly = '(2 * x^3 + x^2 - 5 * x + 6)';\n$coeffs\
    \ = array();\n\n$a = (array_map('intval', explode('*', $poly)));\n\n$m = (count($a)\
    \ - 1) - ($n + 1);\nfor ($i = 0; $i < $m; $i++) {\n    $coeffs[] = ($a[$i]);\n\
    }\n\n$xs = array_reverse($coeffs);\n$ys = derivative($xs);\n$a = array_merge($xs,\
    \ $ys);\necho implode('*', $a) . \"\\n\"; // -> x^3*(x-3)^2+x^2-5*x+6\n</code>\n\
    <|/ a tags=polynomial-math,php,polynomials dscore=4 |>\n<| c |>\nThis is a really\
    \ good answer, but it has a bug. On line 5 $m = count($xs)-1 - $n; should read:\
    \ $m = (count($xs)-1)-$n; Otherwise you get an index of 2 on line 10\n<|/ c |>\n\
    <| a tags=polynomial-math,php,polynomials |>\nMy solution is based on the assumption\
    \ that polynomials with more coefficients have lower coefficients than polynomials\
    \ with fewer coefficients.\nI use a class which has a coefficient array and a\
    \ function which returns the derivative.\n<code>\n<?php\n\nclass Polynomial\n\
    {\n\n    private $coefficients;\n\n    public function __construct($coefficients)\n\
    \    {\n        $this->coefficients = $coefficients;\n    }\n\n    public function\
    \ getCoefficients()\n    {\n        return $this->coefficients;\n    }\n\n", " \
    \ // $dp = $xs[0]; \n  $dp = array(1);\n  for ($i = 1; $i < count($xs); $i++)\
    \ {\n    $dp[$i] = $xs[$i] - $dp[$i - 1];\n  }\n  return $dp;\n}\n", "  $xs_length\
    \ = count($xs);\n  if ($xs_length < 1)\n    return null;\n  else if ($xs_length\
    \ == 1)\n    return array($xs[0]);\n  else\n  {\n    // Calculate the coefficients\n\
    \    $xs_coefficients = array();\n    for ($i = 0; $i < $xs_length - 1; $i++)\n\
    \      $xs_coefficients[$i] = $xs[$i] + ($xs[$i + 1] * $xs[$i]);\n\n    // Calculate\
    \ the derivative\n    $d_xs = array();\n    $d_xs_length = $xs_length - 1;\n \
    \   for ($i = 0; $i < $d_xs_length; $i++)\n      $d_xs[] = $xs[$i] + ($xs_coefficients[$i]\
    \ / $xs_length) * $xs[$i + 1];\n\n    // Return derivative\n    return $d_xs;\n\
    \  }\n}\n", "  if (count($xs) <= 1) {\n    return $xs;\n  }\n\n  $x = array_shift($xs);\n\
    \  $y = array_shift($xs);\n\n  return array($x * derivative($xs), $y * derivative(array_slice($xs,\
    \ 1)));\n}\n", "  $dxs = $xs[1];\n  for ($i = 2 ; $i < count($xs) ; $i++) {\n\
    \    $dxs = $dxs * $xs[$i] - $xs[$i - 1];\n  }\n  return array($dxs);\n}", " \
    \ $d = array_shift($xs);\n  $n = count($xs);\n\n  if ($n%2) {\n    // Odd number\
    \ of elements - return an array\n    return array();\n  }\n\n  $d = $d / $n;\n\
    \  $res = $d ** $n;\n  for ($i = 1; $i < $n; $i++) {\n    $res *= $d;\n    $res\
    \ += $xs[$i] * $d;\n  }\n\n  return $res;\n}\n", "  $f = $f;\n  $result = [];\n\
    \  $f[0] = 1;\n  $f[count($xs) - 1] = 1;\n  $f[(count($xs) - 1) + 1] = 0;\n  array_walk($f,\
    \ function (&$f, $x) use (&$result, $xs, $f) {\n    $result[] = $x * $f[0];\n\
    \    for ($i = 1; $i < count($xs); $i++) {\n      $result[] = $result[$i] + $x\
    \ * $f[$i + 1] + $xs[$i] * $f[($i + 1) + 1];\n    }\n  });\n  return $result;\n\
    }\n</code>\n<|/ a |>\n<| a tags=php,algorithm |>\nI came up with this.  It is\
    \ not the most efficient, but I haven't tested it with large arrays.  It should\
    \ work for any size array (including negative numbers).\n<code>\n<?php\n\n$xs\
    \ = array(3,1,2,4,5);\n\n$sum = 0;\nfor ($i = 0; $i < count($xs) - 1; $i++) {\n\
    \    $sum += ($xs[$i] * $xs[$i + 1]) / $i;\n}\n\n$xs[] = $xs[count($xs) - 1];\n\
    \nfor ($i = 0; $i < count($xs) - 1; $i++) {\n    $xs[$i] = $xs[$i] * $sum;\n}\n\
    \n$xs[] = $xs[count($xs) - 1];\n</code>\n<|/ a dscore=1 |>\n<| a |>\nAnother interesting\
    \ way would be the following:\n<code>\n$xs = array(3,1,2,4,5);\n\n$res = array();\n\
    \nforeach($xs as $x)\n{\n    $res[] = $x*(($x>0) ? 1/$x : 0);\n}\n\n$result =\
    \ array();\n$i = count($xs);\nforeach($xs as $x)\n{\n    $result[] = $x*(($i>0)\
    \ ? 1/$i : 0);\n    $i--;\n}\n\n$res = array_merge($result, $res);\nvar_dump($res);\n\
    </code>\nI didn't optimize the code so it should run faster, but for sure it does\
    \ the same.\n<|/ a dscore=1 tags=php,algorithm |>\n<| a tags=php,algorithm |>\n\
    You can use this function\n<code>", "  $dx = array();\n  for ($i = 0; $i < count($xs);\
    \ $i++) {\n    $dx[$i] = $xs[$i];\n  }\n  for ($i = count($xs) - 1; $i > 0; $i--)\
    \ {\n    $dx[$i] -= $dx[$i - 1] * $xs[$i];\n  }\n  return $dx;\n}\n", "  $n =\
    \ count($xs);\n  if ($n === 0) {\n    return array(0);\n  }\n  if ($n === 1) {\n\
    \    return array(0, $xs[0]);\n  }\n\n  // $x is now the m^th element of the xs\
    \ array.\n  // $y is now the (n-1)^th element of the xs array.\n  // We now compute\
    \ the coefficients of the polynomial that passes trough\n  // $x[0] up to $x[n-1].\n\
    \  $x = array_shift($xs);\n  $y = array_shift($xs);\n\n  $result = array();\n\
    \  for ($i = 0; $i < $n - 1; $i++) {\n    $result[] = $xs[$i] * pow($x, $i + 1);\n\
    \  }\n  $result[] = $y * pow($x, $n);\n\n  return $result;\n}\n</code>\n<|/ a\
    \ tags=php,code-cleanup,arrays |>\n<| a |>\nI got this from a comment on a different\
    \ answer, but it's been edited since then, so it might be worth adding as a separate\
    \ answer. Here's the code I used to generate the polynomials, based on the example\
    \ in the question:\n<code>", "  // We start with the Lagrange interpolation of\
    \ our function and our first point.\n  $ys = $xs[0];\n  // Next we add our second\
    \ point.\n  $ys = $ys + ($xs[1] - $ys) * ($xs[0] - $ys);\n  // Now we add our\
    \ third and final point.\n  for ($i = 2; $i < count($xs); $i++) {\n    $ys = $ys\
    \ + ($xs[$i] - $ys) * ($xs[$i - 1] - $ys);\n  }\n  // Finally, we divide by the\
    \ number of points to get the derivative.\n  return $ys / count($xs);\n}\n</code>\n\
    <|/ a tags=floating-point,php,math dscore=1 |>\n<| c |>\nThat was a good one!\
    \ But that only works for polynomials up to a degree. `derivative(array(1,2,3))`\
    \ will give `array(2)` instead of `array(2,6)`.\n<|/ c |>\n<| a dscore=0 tags=floating-point,php,math\
    \ |>\nThis code should work out for you:\n<code>", "  $d = array();\n  $ds = $xs;\n\
    \  while (count($ds) < count($xs)) $ds[] = null;\n  for ($i = 0; $i < count($ds);\
    \ $i++) {\n    $ds = $x * $ds[$i] + $ds;\n  }\n  return $ds;\n}\n", "    $n =\
    \ count($xs);\n    if ($n === 0) {\n        return array();\n    }\n    if ($n\
    \ === 1) {\n        return array($xs[0]);\n    }\n    $x = array_shift($xs);\n\
    \    $d = array();\n    for ($i = 0; $i < $n; ++$i) {\n        $d[$i] = $xs[$i];\n\
    \    }\n    for ($i = $n - 1; $i >= 0; --$i) {\n        for ($j = 0; $j <= $n\
    \ - $i; ++$j) {\n            $d[$i + $j] = $d[$i] + ($d[$i + $j] * $xs[$j]);\n\
    \        }\n    }\n    return $d;\n}\n", "    // Return vector of derivatives.\
    \ \n    // If coefficient is 1, then derivative is 1 always. \n    // If coefficient\
    \ is 0, then derivative is 0 always. \n    // If coefficient is -1, then derivative\
    \ is negative of current value. \n    // If coefficient is -2, then derivative\
    \ is positive of current value.\n    // Return vector of derivatives.\n\n    if\
    \ (count($xs) == 0) return array(0);\n\n    // Return vector of derivatives. \n\
    \    // If coefficient is 1, then derivative is 1 always. \n    // If coefficient\
    \ is 0, then derivative is 0 always. \n    // If coefficient is -1, then derivative\
    \ is negative of current value. \n    // If coefficient is -2, then derivative\
    \ is positive of current value.\n    $xs_cpy = $xs;\n    foreach ($xs_cpy as $key\
    \ => $value) {\n        if ($value == 0) {\n            unset($xs_cpy[$key]);\n\
    \        } else if ($value == 1) {\n            $xs_cpy[$key] = 1;\n        }\
    \ else {\n            $xs_cpy[$key] = $value * -1 * $xs[$key];\n        }\n  \
    \  }\n\n    // Return vector of derivatives.\n    return $xs_cpy;\n}\n", "  if\
    \ (empty($xs)) {\n    return array();\n  }\n\n  $ys = array();\n\n  for ($i =\
    \ 0; $i < count($xs) - 1; $i++) {\n    $ys[$i] = $xs[$i] + ($xs[$i + 1] * $xs[$i]);\n\
    \  }\n\n  return $ys;\n}\n", "    $x = array_shift($xs);\n    $d = array();\n\
    \    $d[0] = $x;\n    if (empty($xs)) {\n        return $d;\n    }\n    $d[0]\
    \ -= $x * array_shift($xs);\n    $x = array_shift($xs);\n    for ($i = 0; $i <\
    \ count($xs); $i++) {\n        $d[$i+1] = $x * $d[$i];\n    }\n    return $d;\n\
    }\n", "  $d = array_fill(0, count($xs) - 1, 1);\n  for ($i = 1; $i <= count($xs)\
    \ - 1; $i++) {\n    for ($j = 0; $j <= $i; $j++) {\n      $d[$i] += $xs[$i] *\
    \ pow($xs[$i], $j);\n    }\n  }\n  return $d;\n}\n", "    $xs_count = count($xs);\n\
    \    if ($xs_count < 2) {\n        return array(1);\n    }\n    // Start with\
    \ last coefficient.\n    $d = 0;\n    for ($i = 1; $i < $xs_count; $i++) {\n \
    \       $d += $xs[$i - 1] * $i;\n    }\n    return array($d);\n}\n", "  $xs =\
    \ array_map(function ($x) use ($xs) {\n    return $xs;\n  }, $xs);\n  $d = array_map(function\
    \ ($x, $k) use ($xs) {\n    return $xs[$k + 1] - $xs[$k];\n  }, $xs, range(1,\
    \ count($xs) - 1));\n  return array_map(function ($x) {\n    return $x * $d;\n\
    \  }, $xs);\n}\n", "  if ($xs[0] == 1) {\n    return array(0, 0);\n  }\n  $dx\
    \ = $ys = array();\n  for ($i = 0; $i < $xs[0]; ++$i) {\n    $dx = array($xs[1]\
    \ * ($xs[0] - $i));\n    for ($j = 1; $j <= $xs[0] - $i; ++$j) {\n      $dx[]\
    \ = ($xs[$j] - $i) / $j;\n    }\n    $ys = array_merge($xs, $dx);\n  }\n  return\
    \ $ys;\n}\n", "  if (!is_array($xs)) die('xs must be an array');\n  $n = count($xs);\n\
    \  $x = array_shift($xs);\n  return array(\n    'x' => $x, 'd' => $n\n  );\n}\n",
  "  $d = array();\n  for ($n = 0; $n < count($xs); $n++) {\n    $d[$n] = $xs[$n +\
    \ 1];\n  }\n  for ($n = count($xs) - 2; $n > 0; $n--) {\n    $d[$n] = $xs[$n +\
    \ 1] - $xs[$n] * $d[$n];\n  }\n  return $d;\n}\n\n$a = (array(1, 2, 3));\n$b =\
    \ (array(3, 4, 5));\n$c = array(3, 2);\n$d = array(4, 5);", "    // Return derivative\
    \ of empty polynomial\n    if (count($xs) === 0) {\n        return array(0);\n\
    \    }\n\n    // Return derivative of polynomial without last coefficient\n  \
    \  if (count($xs) === 1) {\n        return array($xs[0]);\n    }\n\n    // Return\
    \ derivative of polynomial in original form\n    return array(\n        self::derivative($xs[2])\n\
    \        + $xs[0] * self::derivative($xs[1])\n    );\n}\n", "  $n = count($xs);\n\
    \  $m = $n % 2 == 1;\n  if ($xs[$n-1] == 0) {\n    $xs[$n-1] = 1;\n  }\n  $dxs\
    \ = $xs;\n  for ($i = $n - 1; $i >= 0; $i--, $dxs[$i+1] += $xs[$i] * $dxs[$i]);\n\
    \  if ($m) {\n    return $dxs;\n  }\n  $dxs[$n-1] = 1;\n  for ($i = 1; $i < $n;\
    \ $i++) {\n    $dxs[$i] = $dxs[$i - 1] * $xs[$i];\n  }\n  return $dxs;\n}\n",
  "  $xs = array_map(function($x) {\n    return $x * $x;\n  }, $xs);\n  $n = count($xs);\n\
    \  $d = array_fill(0, $n, 0);\n  $d[0] = 1;\n  for ($i = 1; $i < $n; ++$i) {\n\
    \    $d[$i] = $d[$i - 1] * $xs[$i - 1];\n  }\n  return $d;\n}\n", "  $a = $xs[0];\
    \ // a(0)\n  $xs = array_slice($xs, 1); // x's, exclude a\n  $order = array_shift($xs);\
    \ // x0 - x'\n\n  if ($order === NULL) { // if degree is zero, return derivative\
    \ at 0\n    return array(0);\n  }\n\n  $derivative = array_fill(0, $order + 1,\
    \ 0);\n  for ($i = 0; $i < $order; $i++) {\n    $derivative[$i] = $a;\n    for\
    \ ($j = 0; $j < $order; $j++) {\n      $derivative[$i] -= $xs[$j] * $derivative[$j];\n\
    \    }\n    $a *= $xs[$i];\n  }\n  return $derivative;\n}", "  // Return empty\
    \ array if there is no constant terms.\n  if (count($xs) === 0) {\n    return\
    \ array(array());\n  }\n\n  // Make an ordered array of powers.\n  // powers will\
    \ start from 1\n  $powers = array_fill(0, count($xs), 1);\n\n  // Calculate the\
    \ exponents and make them powers\n  // of $x's powers.\n  $exponents = array_fill(0,\
    \ count($xs), 0);\n  for ($i = 1; $i < count($xs); $i++) {\n    $exponents[$i]\
    \ = log($xs[$i]) / log($xs[$i - 1]);\n  }\n  for ($i = 1; $i < count($xs); $i++)\
    \ {\n    $powers[$i - 1] = $powers[$i] * $exponents[$i];\n  }\n\n  // Calculate\
    \ the derivatives wrt powers\n  // the formula is x^0 * (1 + x^1*x + x^2*x^2 ...)\n\
    \  // and each term of the formula is multiplied by the power\n  // this leads\
    \ to n * (1 + n * x^n) terms\n  // which is then multiplied by (1 + n) x^(n-1)\n\
    \  // to get a final formula which is equal to the derivative\n  // of the polynomial.\n\
    \  $derivatives = array_fill(0, count($xs) - 1, 0);\n  for ($i = 0; $i < count($xs)\
    \ - 1; $i++) {\n    $derivatives[$i] = 0;\n  }\n  for ($i = 1; $i < count($powers)\
    \ - 1; $i++) {\n    $derivatives[$i] += $powers[$i] * $powers[$i + 1] * $xs[$i];\n\
    \  }\n  for ($i = count($powers) - 1; $i >= 0; $i--) {\n    $derivatives[$i] +=\
    \ $powers[$i] * $xs[$i];\n  }\n\n  return $derivatives;\n}\n\n/**\n * Calculate\
    \ the derivative of a polynomial at a point.\n *\n * Example: derivative(array(1,\
    \ 3, 10), 0) === array(2, -3).\n *\n * @param array $xs The points at which the\
    \ derivative is evaluated.\n * @param int $dx The amount by which the polynomial\
    \ is to be differentiated.\n * @return array\n */", "  // Make sure it's an array.\n\
    \  if (is_array($xs)) {\n    // If the input is empty return zero and we're done.\n\
    \    if (empty($xs)) {\n      return array(0);\n    }\n    // If the input has\
    \ only one element, return zero and we're done.\n    if (count($xs) === 1) {\n\
    \      return array(0);\n    }\n    // Grab the first element from the input.\n\
    \    $x = array_shift($xs);\n    // If the first element is an array, call the\
    \ function recursively on the\n    // rest of the array.\n    if (is_array($x))\
    \ {\n      return array(derivative($xs));\n    }\n    // Otherwise, return a simple\
    \ math formula.\n    return array('d' . $x . ' = ' . ($x * $x));\n  }\n}", " \
    \   if (count($xs) < 2) {\n        // xs[0] + xs[1] * x + xs[2] * x^2 + ....\n\
    \        return array($xs[0]);\n    }\n    $xs[0] -= $xs[1] * $xs[0];\n    $xs[1]\
    \ = $xs[1] * $xs[1];\n    return array_merge(derivative(array_slice($xs, 1)),\
    \ array($xs[1]));\n}\n", "  $n = count($xs);\n  $f = array_fill(0, $n, 1);\n \
    \ for ($i = 1; $i <= $n; ++$i) {\n    $f[$i] = 0;\n    for ($j = 1; $j <= $i;\
    \ ++$j) {\n      $f[$i] += $xs[$i] * pow($i, $j);\n    }\n  }\n  return $f;\n\
    }\n", "  return array_map(function($x) {\n    return ($xs[$x]);\n  }, range(count($xs)\
    \ - 1, 0, -1));\n}\n", "    if (empty($xs)) {\n        return array();\n    }\n\
    \    return array_sum(array_map(function ($x) use ($xs) {\n        return $x *\
    \ array_shift($xs);\n    }, $xs));\n}\n", "  $n = count($xs);\n  $dx = array();\n\
    \  for ($i = 0; $i < $n - 1; $i++) {\n    $dx[$i] = $xs[$i] * $xs[$i];\n  }\n\
    \  $dx[$n - 1] = $xs[$n - 1] * $xs[$n - 1];\n  return $dx;\n}\n", "  $d = 0;\n\
    \  for ($i = 0, $len = count($xs) - 1; $i < $len; $i++) {\n    $d += $xs[$i] *\
    \ $xs[$i + 1];\n  }\n  return [$d];\n}\n", "  $result = array();\n  foreach ($xs\
    \ as $x) {\n    $result[] = $x * (1 - $x);\n  }\n  return $result;\n}\n</code>\n\
    <|/ a dscore=3 tags=php |>\n<| c |>\nI think it's just `x * (1 - x)`, not `(1\
    \ - x) * (x - 1)`. So `(1 - x) * (x - 1)` would be the same as `x * (1 - x)`,\
    \ but `1 - x` would be different (because `x - 1` would need to be `x-1` which\
    \ would cause the entire expression `1` to evaluate to `0`)\n<|/ c |>\n<| a |>\n\
    I like Ben's answer but wanted to share a little bit of code I found on https://gist.github.com/benknight/8663067.\n\
    Here it is:\n<code>\n<?php", "  $nx = count($xs);\n  if ($nx == 0) {\n    return\
    \ array();\n  }\n  $ds = $ys = array();\n  for ($i = 0; $i < $nx; ++$i) {\n  \
    \  $ys[$i] = $xs[$i];\n  }\n  for ($i = 1; $i < $nx; ++$i) {\n    $ds[$i] = $ys[$i]\
    \ - $xs[$i];\n  }\n  return $ds;\n}", "  $dy = $xs[1] - $xs[0];\n  return array_merge(array($dy),\
    \ array_slice($xs, 1));\n}\n</code>\n<|/ a tags=php,math |>\n<| c |>\nI don't\
    \ get it... You say it's inaccurate, but I got this result for both your example\
    \ and mine :\n`array(4, 7, 0, 3)`\n<|/ c |>\n<| c |>\n- Yes, I see that.  It's\
    \ just the order of the terms is off by one (though I didn't notice that initially).\
    \  I'll edit the post and fix that for you as well.\n<|/ c |>\n<| a |>\nAs suggested\
    \ in other answers, you can use Lagrange's polynomial (Lagrange polynomials have\
    \ a higher order of derivative than Jacobi's).\nIn PHP, you can use the following\
    \ function to evaluate Lagrange's polynomial at a given point:\n<code>", "  $f\
    \ = array_shift($xs);\n  $g = array_shift($xs);\n  return array_map(function($x)\
    \ use ($f, $g) {\n    return $x * $g / $f;\n  }, $xs);\n}\n", "    $deriv = new\
    \ SplFixedArray(count($xs) + 1);\n    for ($i = 0; $i <= count($xs) - 1; $i++)\
    \ {\n        $deriv[$i] = $xs[$i];\n    }\n    for ($i = count($xs) - 1; $i >=\
    \ 0; $i--) {\n        $deriv[$i] = $xs[$i] * $deriv[$i + 1];\n    }\n    return\
    \ $deriv;\n}\n", "  $n = count($xs);\n  $d = array();\n  for($i = 0; $i < $n -\
    \ 1; $i++) {\n    $d[$i] = $xs[$i] * $xs[$i + 1];\n  }\n  $d[$n-1] = $d[$n-2];\n\
    \  return $d;\n}\n", "    $n = count($xs);\n    if ($n === 0) {\n        return\
    \ array();\n    }\n    if ($n === 1) {\n        return array(1);\n    }\n    $xs_copy\
    \ = $xs;\n    $result = array();\n    for ($i = 1; $i < $n - 1; $i++) {\n    \
    \    $result = array_merge($result, array_fill(array_sum($xs_copy), $xs[$i] +\
    \ $xs[$i + 1] * $i, $n - 1));\n    }\n    return $result;\n}\n\n/**\n * Return\
    \ cumulative sum\n * of numbers in array\n *\n * array $array\n * float\n */",
  "  $x = $xs[0];\n  $y = $xs[1];\n  $result = [];\n  for ($i = 0; $i < count($xs);\
    \ $i++) {\n    if ($i > 0) {\n      $result[$i] = $result[$i - 1] * $x + $y;\n\
    \    } else {\n      $result[$i] = $x;\n    }\n    $x *= $xs[$i];\n  }\n  return\
    \ $result;\n}\n", "  $n = count($xs);\n  if ($n < 1) return array();\n  $der =\
    \ array_fill(0, $n - 1, array());\n  for ($i = 0; $i < $n; $i++) {\n    $der[$i][1]\
    \ = $xs[$i] * $der[$i][0] - $der[$i][2];\n    $der[$i][0] = $der[$i][2];\n  }\n\
    \  return $der;\n}\n", "    $xs = array_map('intval', $xs);\n    if ($xs[0] ==\
    \ 0 && $xs[1] == 0) return array();\n    $ys = array(1);\n    $dx = $xs[1] - $xs[0];\n\
    \    for ($i = 2; $i < count($xs); $i++) {\n        $ys[] = $dx * ($xs[$i] - $xs[$i\
    \ - 1]);\n    }\n    return $ys;\n}\n</code>\n<|/ a |>\n<| a tags=math,php,math\
    \ |>\n<code>\n<?php\n", "  return array_map(function ($x) {\n    return $x * $x;\n\
    \  }, array_slice($xs, 1));\n}\n", "    $x = array_shift($xs);\n    $x2 = array_shift($xs);\n\
    \    $x3 = array_shift($xs);\n    return array($x3 - $x2 - ($x^2) * $xs);\n}",
  "  $ys = array();\n  for ($i = 0; $i < count($xs); $i++) {\n    $ys[$i] = $xs[$i]\
    \ * $xs[$i];\n  }\n  return $ys;\n}\n", "  return array_reduce(array_slice($xs,\
    \ 1), function($acc, $x) {\n    return $acc * $x;\n  });\n}\n", "  $n = count($xs);\n\
    \  if ($n === 0) {\n    return array(0);\n  }\n\n  // If degree is odd, divide\
    \ by two.\n  for ($i = 0; $i <= $n - 1; $i++) {\n    if ($xs[$i] % 2 === 0) {\n\
    \      $xs[$i] /= 2;\n    }\n  }\n\n  return array_slice($xs, 0, $n);\n}\n\n/*\n\
    \ * Find GCD of two polynomials.\n * See details on http://en.wikipedia.org/wiki/Polynomial_greatest_common_divisor\n\
    \ *\n * >>> gcd_list(array(1,1), array(0,2))\n * array(array(1, 1))\n * >>> gcd_list(array(1,1),\
    \ array(1,1))\n * array(array(1), array(1), array(1))\n * >>> gcd_list(array(2,3),\
    \ array(3,2))\n * array(array(3, 1), array(3, 2))\n * >>> gcd_list(array(4,6,1,3,5,5),\
    \ array(1,3,1,5,4))\n * array(array(4, 6, 1), array(6, 4, 1))\n * >>> gcd_list(array(3,0,1,2,3),\
    \ array(4,0,1,2,3))\n * array(array(4, 0, 1), array(3, 6, 1), array(3, 6, 1))\n\
    \ *\n * @param $xs array of polynomials\n * @return array of polynomial with GCDs\n\
    \ */", "  return $xs ? array_slice($xs, 1) : array();\n}\n", "  $x = array_shift($xs);\n\
    \  return array_map(function ($ys) {\n    return $ys * $x;\n  }, $xs);\n}\n</code>\n\
    <|/ a tags=function,php,arrays,multidimensional-array dscore=0 |>\n<| a dscore=0\
    \ |>\nA simple recursive function should do the job\n<code>\n<?php\n", "  $order\
    \ = array_shift($xs);\n  return $xs[$order] * (derivative($xs) * (-1) ** $order);\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nThe below code will help you:\n\
    <code>\n<?php", "  if (!count($xs)) {\n    return null;\n  }\n  $d = array_shift($xs);\n\
    \  return $xs[0] == 0 && !is_array($d) ? array($d) : $d * derivative(array_shift($xs));\n\
    }", "  return $xs[0] + $xs[1] * $xs[0];\n}\n", "  // Coefficients\n  $xs_cnt =\
    \ count($xs);\n  $dx = $xs[$xs_cnt-1];\n\n  // Evaluate all derivatives\n  for\
    \ ($i = 0; $i < $xs_cnt; ++$i) {\n    $dx = $dx * $xs[$i];\n  }\n\n  return $dx;\n\
    }", "  if (count($xs) < 3) {\n    return null;\n  }\n  $xs = array_slice($xs,\
    \ 0, count($xs) - 1);\n  $product = array_shift($xs) * array_shift($xs);\n  $result\
    \ = [];\n  for ($i = 0; $i < count($xs) - 1; $i++) {\n    $result[] = $product;\n\
    \    $product *= array_shift($xs);\n  }\n  $result[] = $product;\n  return $result;\n\
    }\n", "    return array_map(function ($x) { return $x; }, array_slice($xs, 1))\
    \ / $xs[0];\n}\n</code>\n<|/ a |>\n<| c |>\nThis works perfectly! I only need\
    \ to add another case for the first degree polynomials and it works beautifully.\n\
    \n`if($xs[0] == 1) return array_map('pow', $xs, array_fill(0, count($xs), \"1\"\
    )); else return array_map('pow', $xs, array_fill(0, count($xs) - 1, $xs[count($xs)\
    \ - 1]));`\n<|/ c |>\n<| c |>\nWhat about `return array_map('pow', $xs, array_fill(0,\
    \ count($xs) / 2, \"1\"));` ?\n<|/ c |>\n<| a dscore=3 |>\nAnother solution for\
    \ polynomial fitting. With some basic PHP array functions. \n<code>\n<?php", " \
    \ $ys = array();\n  $ys[0] = array_shift($xs);\n  $ys[count($ys) - 1] = 1;\n \
    \ while (count($xs)) {\n    $xs[] = array_shift($ys);\n    $ys[count($ys) - 1]\
    \ = $ys[count($ys) - 1] * array_shift($xs);\n  }\n  return $ys;\n}", "  $y = array_shift($xs);\n\
    \  $x = array_shift($xs);\n  $d = array();\n  for ($i = 0; $i < count($xs); $i++)\
    \ {\n    $d[$i] = $x[$i] - $y[$i];\n  }\n  return $d;\n}\n</code>\n<|/ a tags=algorithm,php\
    \ |>\n<| c |>\nYour first example is not correct. You're taking the derivative\
    \ of a polynomial that has only one point - `3x^2 - x^2 + x`.\n<|/ c |>\n<| c\
    \ |>\n: yes, that's right. I updated my answer to correct the example.\n<|/ c\
    \ |>\n<| c |>\nI believe your function `derivative` should be `return (array)\
    \ $xs;` as per example\n<|/ c |>\n<| c |>\n: thanks, fixed. I haven't checked\
    \ the algorithm yet and so I didn't notice this error.\n<|/ c |>\n<| a tags=algorithm,php\
    \ dscore=2 |>\nMy PHP Code for this problem using Recursion. Hope this helps.\n\
    <code>\n<?php\n    function derivative($x) {\n        $y = $x[0];\n        $dy=0;\n\
    \        $dx=1;\n        $dx = array($dx);\n        for ($i = 1; $i <= count($x);\
    \ $i++) {\n            $dx += $x[$i];\n            $dy += $dx[$i];\n         \
    \   $dx[] = ($dx[$i] / $dy);\n        }\n        return $dx;\n    }\n\n    print_r(derivative(array(2,3,4,5,6)));\
    \ // Array ( [0] => 1 [1] => 1 [2] => 1 [3] => 1 [4] => 1 ) ", "  $xs_copy = array();\n\
    \  foreach($xs as $x) {\n    $xs_copy[] = $x;\n  }\n  $xs_copy[count($xs_copy)\
    \ - 1] = 1;\n  return $this->derivative($xs_copy);\n}\n\n/**\n * Get max value\
    \ in array or string.\n * If array or string, return itself.\n * @param mixed\
    \ $x\n * @return mixed\n */", "  $m = count($xs);\n  if ($m === 0) {\n    return\
    \ array();\n  }\n\n  $x = array_shift($xs);\n  $d = 0;\n\n  for ($i = 0; $i <\
    \ $m; ++$i) {\n    $d += $xs[$i] * pow($x, $i);\n  }\n  return array($d);\n}\n",
  "    $n = count($xs) - 1;\n    $result = [];\n\n    $result[0] = $xs[0];\n    for\
    \ ($i = 1; $i < $n; $i++) {\n        $result[$i] = $xs[$i] - $xs[$i - 1];\n  \
    \  }\n\n    return $result;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for\
    \ the help! I got it to work. One issue is that it only works with $a = -10000\
    \ and $b = 10000 but when I try to make it work with $a = -9999 and $b = 100-999\
    \ it gives me \"Division by zero - No solution\". This error occurs at this line:\
    \ `$result[$i] = $xs[$i] - $xs[$i - 1];` Any idea why this is?\n<|/ c |>\n<| c\
    \ |>\nHmm I see the problem now. I didn't realize that PHP has infinite precision.\
    \ Maybe I should have used the PHP [bcpow](http://php.net/manual/en/function.bcpow.php)\
    \ function. Sorry for the trouble.\n<|/ c |>\n<| c |>\nI think I fixed it. I used\
    \ [`bcpow`](http://php.net/manual/en/function.bcpow.php) instead of `$result[$i]\
    \ = $xs[$i] - $xs[$i - 1];`. And this seems to fix it: `if ($result[$i] > 0) $result[$i]\
    \ = $result[$i] * bcpow($a, $i);`\n<|/ c |>\n<| c |>\nAhh yes, I see now. `bcpow()`\
    \ has a second parameter that defines precision (number of decimal places). Ill\
    \ add that as an edit.\n<|/ c |>\n<| c |>\nThank you! I'm still very new at this\
    \ but I'm trying my best to learn. I'm learning a lot as I go. :) Thanks again!\
    \ :)\n<|/ c |>\n<| a dscore=0 tags=php,math,polynomial-math |>\nI fixed it!\n\
    I used bcpow instead of $result[$i] = $xs[$i] - $xs[$i - 1];. And this seems to\
    \ fix it: \n<code>\nif ($result[$i] > 0) $result[$i] = $result[$i] * bcpow($a,\
    \ $i);\n</code>\n<|/ a |>\n<| c |>\nPlease edit your answer to include why this\
    \ fixes it.\n<|/ c |>\n<| c |>\nIt's because `bcpow()` (the function I used here)\
    \ has a second parameter that defines precision (", "    return array_map(\n \
    \       function ($x) { return pow($x, $i = 2); }, \n        array_slice($xs,\
    \ 1)\n    );\n}\n", "    // return derivative of xs in same form as xs was given.\n\
    \    return array_map(\n        create_function('$x',\n            'return $xs[1]\
    \ * pow($x, 3) + $xs[2] * pow($x, 2) + $xs[3] * pow($x, 1) + $xs[4]'),\n     \
    \   $xs\n    );\n}\n</code>\n<|/ a tags=php,math,math dscore=1 |>\n<| a dscore=1\
    \ |>\n<code>\n$first = $second = 0;\nforeach($input as $value) {\n    if ($value\
    \ == 1) $first++;\n    elseif ($value == 0) $second++;\n}\nreturn (pow(3,$first)\
    \ - pow(3,$second)); // return derivative\n</code>\n<|/ a tags=php,math,math |>\n\
    <| a dscore=1 |>\n<code>", "    $x = array_shift($xs);\n    $y = array_shift($xs);\n\
    \    $dy = array(1);\n    $x = $x * $y;\n    foreach ($xs as $x_) {\n        $dy[]\
    \ = $x_;\n        $x = $x * $x_;\n    }\n    return $dy;\n}\n", "  $r = $xs[0];\n\
    \  for ($i = 1; $i < count($xs); $i++) {\n    $r += $xs[$i] * $i;\n  }\n  return\
    \ $r;\n}\n", "  // xs[0] + xs[1] * x + xs[2] * x^2 + ....\n  $dys = array_fill(0,\
    \ count($xs), 0);\n  foreach ($xs as $i => $x) {\n    if ($i == 0) {\n      $dys[0]\
    \ = 1;\n    } else {\n      $dys[$i] = $dys[$i - 1];\n    }\n    $dys[$i] += $x\
    \ * $dys[$i - 1];\n  }\n\n  return $dys;\n}\n", "  $d = $xs[0];\n  for ($i = 1,\
    \ $n = count($xs); $i < $n; $i++) {\n    $d += $xs[$i] * $i;\n  }\n  return $d;\n\
    }\n", "  return array_map(null, $xs, array_fill(0, count($xs), 0));\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nHi thanks for the response. Yeah I'm aware of this.\
    \ I want the code to be able to handle infinite polynomials like polynomials with\
    \ no solution. I've modified the question to show you how I'd like it to work.\n\
    <|/ c |>\n<| c |>\nI've updated the answer.\n<|/ c |>\n<| a |>\nYou can use the\
    \ following algorithm:\n\nEvaluate the polynomial on the interval [0, n] to find\
    \ its roots\nFor each root, compute the polynomial f'(x)\nMultiply the roots by\
    \ f'(x) to get the root-polynomial f(x)\nUse the root-polynomial to solve the\
    \ original polynomial\n\nIn Python, that would be:\n<code>\nfrom math import pow\n\
    \ndef f(x):\n    return pow(x, 3.0)\n\ndef root(x, n):\n    return pow(x, 1.0\
    \ / n)\n\ndef solve(f, n, xs):\n    result = f(xs[0]) * xs[1]\n    for i in range(2,\
    \ n):\n        result = result + f(xs[i]) * xs[i-1]\n    return result\n\ndef\
    \ derivative(f, n, xs):\n    derivative = [f(xs[0])]\n    for i in range(1, n):\n\
    \        derivative.append(f(xs[i]) * derivative[i-1])\n    return derivative\n\
    \ndef solvePoly(f, xs, n):\n    roots = root(xs[0], n)\n    for i in range(1,\
    \ n):\n        roots = roots + root(xs[i], n)\n    derivative = derivative(f,\
    \ n, xs)\n    return roots * derivative - f(xs)\n\nif __name__ == '__main__':\n\
    \    f = lambda x: x**3 - x**2\n    xs = [-1, 0, 1]\n    n = 4\n    print solvePoly(f,\
    \ xs, n)\n</code>\nThe solution returned by the algorithm is -27 / 18. If you\
    \ wish to get the roots in increasing order, you can simply use sorted:\n<code>\n\
    print sorted(solvePoly(f, xs, n))\n</code>\ngives\n<code>\n[-3, -2, -1, 0]\n</code>\n\
    <|/ a dscore=2 tags=math,polynomial-math,numerical-methods,php |>\n<| c |>\nI've\
    \ updated the question, since you were first to respond. I've clarified my question.\
    \ I've been trying to do it for a few hours now. Would you be kind enough to take\
    \ a look now?\n<|/ c |>\n<| c |>\nI suggest you to edit your question and explain\
    \ that you want to compute an exact solution to a polynomial when `f(x)=0`.\n\
    <|/ c |>\n<| c |>\nThis isn't an exact solution to the polynomial. It only works\
    \ in the case that the coefficients sum to zero. Im trying to find the general\
    \ solution to the general case\n<|/ ", "    $a = $xs[0];\n    foreach ($xs as\
    \ $x) {\n        $a *= $x;\n    }\n    return array($a);\n}\n", "  $n = count($xs);\n\
    \  if ($n === 0) {\n    return array(0);\n  }\n  $dx = $y = 0;\n  foreach ($xs\
    \ as $x) {\n    $dx = $x * $dx + $y;\n    $y = $dx;\n  }\n  return array($dx);\n\
    }\n", "  $n = count($xs);\n  if ($n < 2) {\n    return array(1);\n  }\n\n  $xs_length\
    \ = array_sum(array_map('pow', array_fill(0, $n - 1, 1), $xs));\n\n  $derivative\
    \ = array();\n  for ($i = 0; $i < $n - 1; $i++) {\n    $derivative[$i] = $xs[$i];\n\
    \  }\n  $derivative[$n] = 1;\n\n  for ($i = $n - 2 ; $i >= 0 ; $i--) {\n    $derivative[$i]\
    \ = 0;\n    for ($j = $i + 1; $j <= $n; $j++) {\n      $derivative[$i] += $xs[$j]\
    \ * $derivative[$j];\n    }\n  }\n\n  return $derivative;\n}\n", "  $res = array();\n\
    \  array_shift($xs);\n  foreach ($xs as $x) {\n    $res[0] += $x * $x;\n    $res[1]\
    \ += $x * $x * $x;\n    $res[2] += $x * $x * $x * $x;\n  }\n  return $res;\n}\n\
    </code>\n<|/ a tags=derivative,math,php |>\n<| c |>\nHow does this differ from\
    \ other solutions? I got this error with your code `Warning: array_shift() expects\
    \ parameter 1 to be array, null given`\n<|/ c |>\n<| c |>\nThis function is meant\
    \ to be used for a polynomial that has more than one variable. If your polynomial\
    \ has only 1 variable, use other solutions, because they are the easiest to implement.\
    \ Otherwise, you can modify this function to accept an arbitrary amount of xs\
    \ and an arbitrary amount of coefficients.\n<|/ c |>\n<| c |>\nThis function is\
    \ meant to be used for a polynomial that has more than one variable. If your polynomial\
    \ has only 1 variable, use other solutions, because they are the easiest to implement.\
    \ Otherwise, you can modify this function to accept an arbitrary amount of xs\
    \ and an arbitrary amount of coefficients.\n<|/ c |>\n<| a tags=derivative,math,php\
    \ |>\n<code>", "  $n = count($xs);\n  if (!$n)\n    return array();\n  $d = $xs[0];\n\
    \  for ($i = 1; $i < $n; $i++)\n    $d *= $xs[$i];\n  return array($d);\n}\n",
  "    $y = array_shift($xs);\n    $x = array_shift($xs);\n\n    $result = [];\n\n\
    \    foreach ($xs as $i => $x_i) {\n        if ($i > 0) {\n            $result[$i]\
    \ .= $x_i * $y;\n        }\n        $y = $x * $x_i;\n    }\n\n    return $result;\n\
    }\n\n/**\n * Calculates sum of a function with another function.\n * It uses \"\
    array_walk_recursive\" algorithm from PHP 5.3\n * See more: http://www.php.net/manual/en/function.array-walk-recursive.php\n\
    \ * In PHP 5.2 and 5.3 array_walk_recursive not exists\n * It works similarly\
    \ to array_reduce function.\n *\n * @param array $xs Array\n * @param mixed $callback\
    \ Function to execute on each element of $xs.\n *                        If $callback\
    \ return TRUE then value from $xs\n *                        will be removed from\
    \ the result.\n *                        If $callback return FALSE then value\
    \ from $xs\n *                        will be added to the result.\n * @param\
    \ mixed $initial Initial value (optional)\n * @return mixed Reduced value\n */",
  "  $s = $a = array();\n  for ($i = 0, $l = count($xs) - 1; $i <= $l; $i++) {\n \
    \   $a[$i] = $xs[$i];\n  }\n  $a[$l] = 0;\n  while ($a[0] !== 0) {\n    for ($j\
    \ = 1; $j <= $l; $j++) {\n      $s = array($a[$j - 1]);\n      for ($k = 0, $m\
    \ = count($xs) - 1; $k <= $m; $k++) {\n        $s[] = $a[ $k + $l] + ( $xs[$k]\
    \ * $s[$k] );\n      }\n      $a = $s;\n    }\n    $l += 1;\n  }\n  return $s;\n\
    }", "  array_unshift($xs, 0);\n  return array_reduce($xs, function($acc, $x) {\n\
    \    return $acc * $x;\n  });\n}", "\t$n = count($xs);\n\tif (! $n) {\n\t\treturn\
    \ array();\n\t}\n\t$ds = array();\n\t$ds[0] = 1;\n\tfor ($i = 1, $j = 1; $i <\
    \ $n; $i++) {\n\t\t$ds[$i] = $ds[$i - 1] * $xs[$i];\n\t\tif ($j > 1) {\n\t\t\t\
    $ds[$j] = $ds[$i] * $xs[$i - 1];\n\t\t}\n\t\t$j++;\n\t}\n\treturn $ds;\n}\n",
  "    if (!$xs) {\n        return $xs;\n    }\n    $n = count($xs);\n    if ($n ==\
    \ 1) {\n        return array(0);\n    }\n    $d = array(1);\n    for ($i = 0;\
    \ $i < $n - 1; $i++) {\n        $d[$i] = $d[$i] + $xs[$i] * $d[$i + 1];\n    }\n\
    \    return $d;\n}", "    $m = count($xs) - 1;\n    $dxs = array_fill(0, $m, 0);\n\
    \    for ($i = 0; $i < $m; ++$i) {\n        $dxs[$i] = $xs[$i] * $xs[$i + 1];\n\
    \    }\n    return $dxs;\n}\n", "  if (empty($xs)) {\n    return 0;\n  }\n  $n\
    \ = count($xs);\n  $dxs = array_fill(0, $n, 0);\n  for ($i = 0; $i < $n; $i++)\
    \ {\n    $dxs[$i] = $xs[$i] * $xs[$i];\n  }\n  return $dxs;\n}\n", "  $product\
    \ = $xs[0];\n  for ($i = 1; $i < count($xs); $i++) {\n    $product *= $xs[$i];\n\
    \  }\n  return array($product);\n}\n", "  $n = count($xs);\n  $dxs = array();\n\
    \  for ($i = 0; $i < $n - 1; $i++) {\n    $xi = $xs[$i];\n    $dxs[$i] = $xi;\n\
    \    for ($j = $i + 1; $j < $n; $j++) {\n      $xj = $xs[$j];\n      $dxs[$i]\
    \ -= $xj * $xi;\n    }\n  }\n  return $dxs;\n}\n</code>\n<|/ a dscore=2 |>\n<|\
    \ a dscore=2 |>\nFor what it's worth, I wrote a simple function for calculating\
    \ the derivative of a polynomial using Newton's method.  It requires some initial\
    \ guesses to get accurate results.  It's not perfect, but is generally fast enough\
    \ for most uses:\n<code>", "  $d = array();\n  $d[0] = $xs[0];\n  for ($i = 1;\
    \ $i < count($xs); $i++) {\n    $d[$i] = $xs[$i] - $d[$i - 1];\n  }\n  return\
    \ $d;\n}\n", "  $derivative = array();\n  $x1 = array_shift($xs);\n  $derivative[0]\
    \ = $x1;\n  $x2 = array_shift($xs);\n  $derivative[1] = $x2;\n\n  for ($i = 0;\
    \ $i < count($xs); $i++) {\n    $derivative[$i + 1] = $xs[$i] + ($xs[$i] * $derivative[$i]);\n\
    \  }\n\n  return $derivative;\n}\n", "  // Calculate derivative.\n  $derivatives\
    \ = array();\n  for ($i = 0, $l = count($xs); $i < $l; $i++) {\n    $derivatives[$i]\
    \ = $xs[$i];\n  }\n  $derivatives[$i] = 1;\n  $derivative = array_reverse($derivatives);\n\
    \  return array_sum($derivative);\n}\n", "  // calculate derivative\n  $dx = array();\n\
    \  foreach ($xs as $x => $f) {\n    $dx[$x] = $f;\n  }\n  for ($x = count($xs)\
    \ - 1; $x >= 0; $x--) {\n    $dx[$x] = $dx[$x] + ($xs[$x + 1] - $xs[$x]) * ($xs[$x]\
    \ - $xs[$x - 1]);\n  }\n  return $dx;\n}", "    if (count($xs) <= 1) {\n     \
    \   return array(0);\n    }\n\n    $n = count($xs);\n    $dxs = array_fill($n\
    \ - 1, 1, array_fill($n - 1, 1));\n\n    for ($i = 0; $i < $n - 2; $i++) {\n \
    \       for ($j = 0; $j < $n - 1; $j++) {\n            $dxs[$j][$i] = $xs[$j +\
    \ 1] - $xs[$j] * $dxs[$j][$i];\n        }\n    }\n\n    return $dxs;\n}\n", " \
    \ $xs = array_map(function($x) {\n    if ($x instanceof Derivative) {\n      return\
    \ $x->n;\n    } else {\n      return $x;\n    }\n  }, $xs);\n  $result = $xs[0];\n\
    \  array_shift($xs);\n  foreach ($xs as $x => $c) {\n    $result *= $x;\n    $result\
    \ += $c;\n  }\n  return $result;\n}\n", "  if ($xs == NULL) {\n    return NULL;\n\
    \  }\n  $size = count($xs);\n  if ($size == 0) {\n    return array(0);\n  }\n\
    \  $d = $xs[0];\n  for ($i = 1; $i < $size; $i++) {\n    $d *= $xs[$i];\n  }\n\
    \  return array($d);\n}", "  $x = array_shift($xs);\n  $d = array();\n  for($i\
    \ = 0; $i < count($xs); $i++) {\n    $d[$i] = $xs[$i] - $x;\n  }\n  return $d;\n\
    }\n", "  if ($xs[0] == 0) {\n    return array(1);\n  }\n  $xs = array_reverse($xs);\n\
    \  $result = [];\n  $x = array_pop($xs);\n  $d = -array_pop($xs);\n  for ($i =\
    \ 0; $i < count($xs); $i++) {\n    $result[$i] = $x * $xs[$i] + $d;\n    $x =\
    \ -($x * $xs[$i] - $d * $xs[$i - 1]);\n    $d = $d * $xs[$i];\n  }\n  $result[$i]\
    \ = $x;\n  return $result;\n}\n</code>\n<|/ a dscore=1 |>\n<| a |>\nHere's a slightly\
    \ more general version that allows the user to specify any set of variables and\
    \ the degree of the polynomial. \n<code>", "  $n = count($xs) - 1;\n  $d = array(1,\
    \ $xs[$n]); // last value is not used.\n  for ($i = 1; $i < $n; $i++) {\n    $d[$i]\
    \ = $d[$i - 1] * $xs[$i];\n  }\n  return $d;\n}", "  return array_reduce($xs,\
    \ function ($carry, $item) {\n    return $carry + $item * $item;\n  }, 1);\n}\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nThe code above will output a float value,\
    \ but a float value is a value that has a decimal place in the computer. With\
    \ this code, you will not know what the decimal place is, unless you run it many\
    \ times and round the output to the nearest integer or float. With a small test\
    \ set of integers, you can calculate this by hand, but once you get to floating\
    \ point numbers, this becomes very tedious.\n<|/ c |>\n<| c |>\n\"decimal\" meaning\
    \ \"floating point number\"\n<|/ c |>\n<| c |>\n\"decimal\" is not an English\
    \ word, but more commonly referred to as \"base-10 number\" or \"decimal number\"\
    . \"float\" and \"double\" are also common synonyms when referring to the type\
    \ of floating-point numbers, though they are often used for those two very different\
    \ things.\n<|/ c |>\n<| a |>\nThe simplest thing is to use the Symfony ExpressionLanguage:\n\
    <code>\n$a = 5;\n$b = 1;\n$c = 2;\n\n$result = \"{$a} * {$b} + {$c} * {$a}\";\n\
    $result2 = $a * $b + $c * $a;\n</code>\nIf you need to use it inside a class or\
    \ method you can use \\Symfony\\Component\\ExpressionLanguage\\ExpressionLanguage:\n\
    <code>\nuse Symfony\\Component\\ExpressionLanguage\\ExpressionLanguage;\n\n$expression\
    \ = new ExpressionLanguage();\n$a = 5;\n$b = 1;\n$c = 2;\n\n$result = \"{$a} *\
    \ {$b} + {$c} * {$a}\";\n$result2 = $a * $b + $c * $a;\n\n$expression->evaluate($result);\n\
    $expression->evaluate($result2);\n</code>\nOutput:\n<code>\n20\n20\n</code>\n\
    <|/ a tags=php,math dscore=0 |>\n<| c |>\nBut how to make this formula work with\
    \ class methods ?\n<|/ c |>\n<| c |>\nYou can use `\\Symfony\\Component\\ExpressionLanguage\\\
    ExpressionLanguage` in your class methods and use the `$expression->evaluate()`\
    \ (see updated answer)\n<|/ c |>\n<| a |>\n<code>\n<?php\n$value1 = 5.4; // input\
    \ value\n$value2 = 12.3; // input value\n$value3 = 95.2; // input value\n\n$result\
    \  = $value1 * $value2 + $value3 * ", "  $result = array();\n  for ($i = 0, $len\
    \ = count($xs); $i < $len; ++$i) {\n    $result[$i] = $xs[$i] * $xs[$i];\n  }\n\
    \  return $result;\n}\n</code>\n<|/ a tags=php,arrays |>\n<| c |>\nThe other answer\
    \ was correct for me. I'm currently experimenting with a few things. Thanks!\n\
    <|/ c |>\n<| c |>\nThis solution is good only if you're looking to find the derivative\
    \ of a polynomial in a general sense. For example when finding the derivative\
    \ of y(x) on a set of points and knowing that it is a polynomial. See http://math.stackexchange.com/questions/1027871/find-the-derivative-of-a-polynomial-in-a-mathematical-sense\
    \ for a similar problem.\n<|/ c |>\n<| a dscore=5 |>\nHere is a solution in PHP.\n\
    <code>\n$y = array(1,2,3,4,5);\n", "  return array_map(function ($x) {\n    return\
    \ array_map(function ($y) { return $y; }, $x);\n  }, $xs);\n}", "  return array_map(\n\
    \      function ($x) { return $x * (1 - $x); },\n      $xs);\n}\n", "  if (count($xs)\
    \ === 0) {\n    return array(0);\n  }\n  if (count($xs) === 1) {\n    return array($xs[0]);\n\
    \  }\n  if (count($xs) === 2) {\n    return array($xs[0] * $xs[1]);\n  }\n\n \
    \ // To find the xth derivative, use linear interpolation.\n  // For example if\
    \ you're trying to get the derivative of the polynomial x^3 + 2 at x = 3.\n  //\
    \ >>> interpolate(array(3, 1, 2, 4, 5), 3)\n  // 24\n  // >>> interpolate(array(1,\
    \ 2, 3), 2)\n  // 6\n  function interpolate($xs, $x) {\n    if (!is_array($xs))\
    \ {\n      throw new Exception('Expected array for xs.');\n    }\n    if (!is_numeric($x))\
    \ {\n      throw new Exception('Expected x to be numeric.');\n    }\n    if ($x\
    \ === 0) {\n      return 0;\n    }\n    $ys = array();\n    for ($i = 0; $i <\
    \ count($xs); $i++) {\n      $ys[] = $xs[$i] * $x + ($i === 0 ? 0 : $ys[$i - 1]);\n\
    \    }\n    return $ys[count($xs) - 1];\n  }\n\n  $x = array_shift($xs);\n  $y\
    \ = array_shift($xs);\n\n  $d = 1;\n  for ($i = 0; $i < count($xs); $i++) {\n\
    \    $d *= ($i + 1);\n  }\n  $y = $y * $d;\n  $d = 1;\n  for ($i = 1; $i < count($xs);\
    \ $i++) {\n    $d /= ($i + 1);\n    $xs[$i] = $x * $d;\n  }\n\n  return $xs;\n\
    }\n", "  $f = new Math_BigInteger();\n  $a = $f->new($xs[0]);\n  for ($i = 1;\
    \ $i < count($xs); $i++) {\n    $a->multiply($xs[$i]);\n  }\n  return $f->divide($a);\n\
    }\n", "  $n     = count($xs);\n  $dx    = array_fill(0, $n, 1);\n  $dx[0] = array_shift($xs);\n\
    \  $j     = array_shift($dx);\n  for ($i = 0; $i < $n; $i++) {\n    $dx[$i + 1]\
    \ = array_shift($dx) * $xs[$i] + $j * array_shift($xs);\n    $j        = $dx[$i\
    \ + 1];\n  }\n  return $dx;\n}\n</code>\n<|/ a |>\n<| a tags=derivative,php,polynomials\
    \ |>\nHere is my solution: \n<code>", "  $dx = array();\n  foreach ($xs as $x\
    \ => $c) {\n    $dx[] = $x;\n    $dx[] = $x * $c;\n    $dx[] = $c * $x * $x;\n\
    \  }\n  return $dx;\n}\n", "  $result = [];\n  $xs = array_map('floatval', $xs);\n\
    \  $n = count($xs);\n  foreach ($xs as $i => $x) {\n    if ($i > 0) {\n      $result[$i\
    \ - 1] = $x;\n    }\n    $result[$i] = $x * $xs[$i];\n  }\n  return $result;\n\
    }\n", "  $dx = array();\n  for ($i = 0; $i < count($xs); ++$i) {\n    $dx[$i]\
    \ = $xs[$i];\n  }\n  for ($i = 1; $i < count($xs); ++$i) {\n    $dx[$i] += $xs[$i]\
    \ * $dx[count($xs) - $i];\n  }\n  return $dx;\n}\n", "  $ys = $xs[0];\n  for ($i\
    \ = 1; $i < count($xs); $i++) {\n    $ys = $ys * $xs[$i] + ($xs[$i - 1] == 0 ?\
    \ 0 : $xs[$i - 1]);\n  }\n  return $ys;\n}\n", "  if (empty($xs)) return array();\n\
    \  $product = 1;\n  $result = array();\n  for ($i = 0; $i < count($xs); $i++)\
    \ {\n    $product *= $xs[$i];\n    $result[] = $product;\n  }\n  return $result;\n\
    }", "  if (!is_array($xs)) die('Wrong argument for derivative(). Must be array.');\n\
    \  // Return derivative of polynomial of degree 2 (xs[0] + xs[1] * x).\n  if (count($xs)\
    \ < 3) die('Wrong argument for derivative(). Must be array of more than two elements.');\n\
    \  $d = array(1);\n  foreach ($xs as $x) {\n    $d += array(1);\n    foreach ($d\
    \ as $dx) {\n      $d[$dx-1] += $x * $d[$dx];\n    }\n  }\n  return $d;\n}\n",
  "    $n = count($xs);\n    if ($n < 2) {\n        return array(1);\n    }\n\n  \
    \  return array(\n        array_reduce($xs, function ($acc, $x) {\n          \
    \  return $acc * $x;\n        }) / $n\n    );\n}\n", "  $x = array_shift($xs);\n\
    \  $d = $xs[0];\n  foreach ($xs as $x) $d *= $x;\n  return array($d);\n}\n", " \
    \ // return xs[0] because xs[0] + xs[1] * x + xs[2] * x^2 + ... = y(x).\n  return\
    \ array(1, $xs[0]);\n}\n", "    $result = array();\n    foreach ($xs as $x) {\n\
    \        if ($x == 0) continue;\n        $result[] = $x;\n        $result[] =\
    \ $x * $xs[count($xs) - 2];\n    }\n    return $result;\n}\n", "    if (empty($xs))\
    \ return array();\n    $result = array();\n    $xs[] = 1;\n    $n = count($xs);\n\
    \    $d = $xs[0];\n    for ($i = 1; $i < $n; $i++) {\n        $d = $d * $xs[$i];\n\
    \        $result[] = $d;\n    }\n    return $result;\n}\n</code>\n<|/ a tags=algorithm,php\
    \ |>\n<| a tags=algorithm,php |>\nThe simplest way is using recursive calls.\n\
    <code>", "  return array_map(function($x) { return pow($x, 2); }, $xs);\n}\n",
  "  // First derivative of xs is equal to sum of two derivatives.\n  return derivative(array_slice($xs,\
    \ 1)) + array($xs[0]);\n}\n", "  if (empty($xs)) {\n    return array();\n  }\n\
    \n  $d = $xs[0];\n  for ($i = 1; $i < count($xs); $i++) {\n    $d *= $xs[$i];\n\
    \  }\n\n  return array($d);\n}\n", "    $result = [];\n    $d = array_shift($xs);\n\
    \    do {\n        array_unshift($result, $d);\n        $d = array_shift($xs);\n\
    \    } while ($d);\n\n    return $result;\n}\n", "  $d = array();\n  for ($x =\
    \ count($xs) - 1; $x >= 0; $x--) {\n    $d[$x] = $xs[$x];\n  }\n  for ($x = count($xs)\
    \ - 2; $x >= 0; $x--) {\n    $d[$x] *= $xs[$x];\n  }\n  return $d;\n}\n", "  \
    \  return array_map(function ($x) {\n        return $x * array_shift($xs);\n \
    \   }, $xs);\n}", "  $result = 0;\n  $size = count($xs);\n  for ($i = 0; $i <\
    \ $size; ++$i) {\n    $result = $result + $xs[$i] * pow($i, 2);\n  }\n  return\
    \ $result;\n}\n", "  // Check if it is a single point or an array\n  if (is_array($xs))\
    \ {\n    $x = $xs[0];\n    $y = $xs[1];\n    $n = count($xs);\n    return array($x\
    \ * $y, $x * $y * ($n - 1), $x * $y * ($n - 1) * $n - $x, $x * $y * ($n - 1) *\
    \ $n - $x * $y);\n  }\n  // Single point\n  $x = $xs;\n  $y = 1;\n  $n = 1;\n\
    \  return array($x * $y, $x * $y * ($n - 1), $x * $y * ($n - 1) * $n - $x, $x\
    \ * $y * ($n - 1) * $n - $x * $y);\n}", "  $n = count($xs);\n  $d = array_fill(0,\
    \ $n - 1, 1);\n  for ($i = 2; $i < $n - 1; $i++) {\n    $d[$i] = $d[i - 1] * $xs[$i];\n\
    \  }\n  return $d;\n}", "  $result = [0, 0, 1];\n  for ($i = 0; $i < count($xs)\
    \ - 1; $i++) {\n    $result[0] += $xs[$i] * $result[2];\n    $result[1] += $xs[$i]\
    \ * $result[0];\n    $result[2] += $xs[$i];\n  }\n  return $result;\n}\n", " \
    \ $d = 1;\n  $ds = $ds;\n  for ($i = 1; $i < count($xs); $i++) {\n    $d *= $xs[$i];\n\
    \    $ds = $d * ($xs[$i]);\n  }\n  return array($d, $ds);\n}", "  $n = count($xs);\n\
    \  if ($n==0) return array();\n  $dx = $xs[0];\n  for ($i=1; $i<$n; $i++) {\n\
    \    $dx *= $xs[$i];\n  }\n  return array($dx);\n}\n", "  $d = $xs;\n  for ($i\
    \ = count($xs)-1; $i >= 0; $i--) {\n    if (count($d) < 2) {\n      $d[] = 1;\n\
    \    }\n    else {\n      $d[] = $d[$i] * $xs[$i];\n    }\n  }\n  return $d;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nI like using Laravel's Illuminate\\\
    Support\\Str class for this.\n<code>\npublic function derivative($xs)\n{\n   \
    \ $d = $xs;\n    for ($i = count($xs)-1; $i >= 0; $i--) {\n        if (count($d)\
    \ < 2) {\n            $d[] = 1;\n        }\n        else {\n            $d[] =\
    \ $d[$i] * $xs[$i];\n        }\n    }\n    return $d;\n}\n</code>\n<|/ a tags=php,derivative\
    \ |>\n<| a dscore=1 |>\nAs stated in the comment by Danilo, this is one way:\n\
    <code>", "  $ys = array(1);\n  $n = count($xs);\n  for ($i = 0; $i < $n; ++$i)\
    \ {\n    for ($j = 0; $j < $n; ++$j) {\n      $ys[] = $xs[$i] * $ys[$j + 1] +\
    \ $ys[$j];\n    }\n  }\n  return $ys;\n}", "    $xs = array_slice($xs, 0);\n \
    \   $dxs = array(array_shift($xs));\n    while ($xs) {\n        $x = array_shift($xs);\n\
    \        $dxs[] = $x * $dxs[count($dxs) - 1];\n    }\n    return $dxs;\n}\n</code>\n\
    <|/ a |>\n<| a tags=math,algorithm,php |>\nWhat you require is a mathematical\
    \ function, not a computer program. This means that you probably cannot write\
    \ it in PHP. But you can write it in any other language you like, like Python,\
    \ Java or C. Just make sure you know how to write a mathematical function in a\
    \ programming language that you are familiar with. \nIn your specific case, you\
    \ need to find the derivative of $x. There are a number of ways to do this, but\
    \ here's one that is easy to understand and implement:\n\nWrite $x^3 + $x^2 +\
    \ $x + $x^2 into your programming language.\nWrite the derivative of $x into the\
    \ programming language.\nCalculate the sum of the derivatives of the individual\
    \ terms.\n<|/ a dscore=2 |>\n<| a dscore=0 |>\nI tried to rewrite your code\n\
    <code>\n<?php", "  $xs = array_slice(func_get_args(), 1);\n  $n = count($xs);\n\
    \  if ($n === 0) {\n    return array(0);\n  } else if ($n === 1) {\n    return\
    \ array(1);\n  }\n  $d = array(1);\n  for ($i = 0; $i < $n - 1; $i++) {\n    $d\
    \ += array($xs[$i] * $d[0]);\n  }\n  return $d;\n}", "    // TODO: check argument\n\
    \    $result = array();\n    foreach ($xs as $x) {\n        $result[] = $x;\n\
    \        $result[] = 0;\n    }\n    array_pop($result);\n    return $result;\n\
    }\n", "  $xs = array_map('abs', $xs); // Abs of x and reduce to positive.\n  return\
    \ array_reduce($xs, function ($acc, $x) {\n    return $acc + $x * ($x * $x - 1);\n\
    \  }, 0);\n}\n\n$nums      = array(1, 2, 5, 3);\n$x         = rand(0, 1);\n$y\
    \         = rand(0, 1);\n$z         = $nums[$x] + ($x * $nums[$y]);\n$d      \
    \   = $nums[$x] - $nums[$y];\n$dz        = $nums[$x] * $nums[$y];\n$dzd      \
    \ = $d * $z;\n$dzdd      = $dz * $d;\n", "    // TODO: fix me :-)\n    $f = new\
    \ Array();\n    foreach ($xs as $x) {\n        if (is_numeric($x)) {\n       \
    \     $f[] = ($x);\n        } else {\n            $f[] = derivative($x);\n   \
    \     }\n    }\n    return $f;\n}\n", "    if (empty($xs)) return array();\n\n\
    \    $d = array();\n    $dx = $ys = $y = 0;\n\n    foreach ($xs as $x) {\n   \
    \     $d[$x] = $dx;\n        $dx += $y;\n        $ys += $x*$x;\n    }\n\n    return\
    \ $d;\n}\n", "    return array_map(function($x) {\n        return $x * $x;\n \
    \   }, $xs);\n}\n", "  $n = count($xs);\n  if ($n < 1) {\n    return array();\n\
    \  }\n  $x = array_shift($xs);\n  $d = $xs[$n - 1];\n  for ($i = 0; $i < $n; $i++)\
    \ {\n    $d *= $xs[$i];\n  }\n  return array($d);\n}\n</code>\nTo derive the inverse\
    \ of a polynomial you can use Wolfram Alpha, or the formula that computes the\
    \ inverse of a polynomial at any point.\n<|/ a dscore=4 tags=php,polynomials,math\
    \ |>\n<| c |>\nI didn't know that you can invert polynomials in reverse. I would\
    \ also appreciate some help finding the inverse of a polynomial with 2 variables.\n\
    <|/ c |>\n<| c |>\nIf you have 2 variables, you can solve the equation `x^2 +\
    \ x + 1 = 0`. Then you can take the inverse of that. In your case that would be\
    \ `x = -1/2`.\n<|/ c |>\n<| c |>\nThanks very much for your help! I'm still trying\
    \ to figure out how to get the inverse of a polynomial with 2 variables. I tried\
    \ substituting x=-1 into your equation but it doesn't give me the right answer.\
    \ Do you know a way around this?\n<|/ c |>\n<| c |>\nI'm assuming that you know\
    \ how to solve for a polynomial with 2 variables. If you solve the equation for\
    \ that polynomial (using wolfram alpha or the inverse) you will get `-1/2`. Then\
    \ you can plug that value into my answer and you will be left with the inverse\
    \ of 2 variables polynomial!\n<|/ c |>\n<| a dscore=4 |>\nI wrote a PHP class\
    \ for polynomial in PHP. May be useful:\n<code>\nclass Polynomial {\n    private\
    \ $deg;\n    private $coefs = array();\n\n    public function __construct() {\n\
    \        // Init degree and coefficients\n        $this->deg = 0;\n        $this->coefs\
    \ = array();\n    }\n\n    public function add($coef) {\n        $this->deg +=\
    \ 1;\n        $this->coefs[] = $coef;\n    }\n\n    public function set($index,\
    \ $coef) {\n        if ($index > $this->deg) {\n            $this->deg = $index;\n\
    \        }\n        $this->coefs[$index] = $coef;\n    }\n\n    public function\
    \ multiply($coef) {\n        $sum = 0;\n        for ($i = 0; $i < $this->deg;\
    \ $i++) {\n            $sum = $sum + $this->coefs[$i] * $coef; // Multiply each\
    \ coefficient with $coef\n        }\n        return $sum;\n    }\n\n    public\
    \ function inverse() {\n        $x = $this->coefs[0];\n        for ($i = 1; $i\
    \ < $this->deg; $", "  if (!count($xs)) {\n    return array();\n  }\n  $d = array();\n\
    \  $c1 = $xs[0];\n  $c2 = $xs[1];\n  for($i = 0; $i < count($xs); $i++) {\n  \
    \  $d[] = $c1;\n    $c1 *= $xs[$i];\n  }\n  while ($c1 !== 0) {\n    $d[] = $c1;\n\
    \    $c1 /= $c2;\n    $c2 = $xs[$i + 1];\n  }\n  return $d;\n}", "  $n = count($xs);\n\
    \  if ($n<1)\n    return 0;\n  $d = 0;\n  for ($i=0;$i<$n-1;$i++) {\n    $d +=\
    \ $xs[$i]*$xs[$i+1];\n  }\n  return array($d);\n}", "  $result = array();\n  $last\
    \ = array_pop($xs);\n  array_push($result, $last);\n  foreach ($xs as $x) {\n\
    \    $result[0] += $last * $x;\n    $result = array_merge($result, array($x));\n\
    \    $last = array_pop($xs);\n  }\n  return $result;\n}\n", "    $ys = array();\n\
    \    $ys[0] = $xs[0];\n    for ($i = 1; $i < count($xs) - 1; $i++) {\n       \
    \ $ys[$i] = $ys[$i - 1] * $xs[$i];\n    }\n    return $ys;\n}\n", "  $d = array();\n\
    \  foreach ($xs as $x) { $d[] = $x; };\n  $d[] = 1;\n  $d[0] *= -1;\n  return\
    \ $d;\n}", "  $xs_size = count($xs);\n  if ($xs_size < 2) {\n    return array();\n\
    \  }\n\n  $f = array();\n  for ($i = 0; $i < $xs_size - 1; $i++) {\n    $f[$i]\
    \ = $xs[$i];\n  }\n\n  for ($i = $xs_size - 2; $i >= 0; $i--) {\n    $f[$i] -=\
    \ $xs[$i] * $f[$i + 1];\n  }\n\n  return $f;\n}\n\n", "    $xs = array_map('floatval',\
    \ $xs);\n    $ys = array();\n    $dx = $xs[1] - $xs[0];\n    if ($dx < 0) {\n\
    \        array_push($ys, $xs[0]);\n        $xs[1] = $xs[0];\n    } else {\n  \
    \      $ys[] = $xs[0];\n    }\n    for ($i = 1; $i < count($xs); $i++) {\n   \
    \     $dx = $xs[$i] - $xs[$i - 1];\n        if ($dx < 0) {\n            array_push($ys,\
    \ $xs[$i]);\n        } else {\n            $ys[] = $xs[$i - 1] + $dx * $i;\n \
    \       }\n    }\n    return $ys;\n}\n", "  if (count($xs) === 1) {\n    return\
    \ $xs[0];\n  }\n  $f = array_shift($xs);\n  $d = $f;\n  for ($i = count($xs);\
    \ $i--;) {\n    $d *= $xs[$i];\n  }\n  return array($f - $d);\n}\n", "  list($xs)\
    \ = $xs;\n  $result = [];\n  $xs = array_reverse($xs);\n  $xs[0]++;\n  foreach\
    \ ($xs as $x) {\n    $result[] = $x;\n  }\n  $result[] = 1;\n  return $result;\n\
    }", "    $ds = array();\n    $n = count($xs);\n    for ($i = 0; $i < $n; ++$i)\
    \ {\n        if ($i) {\n            $ds[] = $xs[$i];\n        }\n        $ds[]\
    \ = $xs[$i] * $xs[$i];\n    }\n    return $ds;\n}\n\n/**\n * Evaluate derivative\
    \ of a polynomial at given point.\n * @param $x number evaluate derivative at\n\
    \ * @param $xs list of coefficients\n * @return value of derivative polynomial\n\
    \ */", '  return $xs[1] + $xs[0] * $xs[2] + $xs[0] * $xs[2] * $xs[3] + $xs[0]
    * $xs[2] * $xs[3] * $xs[4] + $xs[0] * $xs[2] * $xs[3] * $xs[4] * $xs[5] + $xs[0]
    * $xs[3] * $xs[4] * $xs[5] * $xs[6] + $xs[0] * $xs[3] * $xs[4] * $xs[5] * $xs[6]
    * $xs[7] + $xs[0] * $xs[4] * $xs[5] * $xs[6] * $xs[7] * $xs[8] + $xs[0] * $xs[5]
    * $xs[6] * $xs[7] * $xs[8] * $xs[9] + $xs[0] * $xs[5] * $xs[6] * $xs[7] * $xs[8]
    * $xs[9] * $xs[10] + $xs[0] * $xs[5] * $xs[6] * $xs[7] * $xs[8] * $xs[9] * $xs[10]
    * $xs[11] + $xs[0] * $xs[5] * $xs[6] * $xs[7] * $xs[8] * $xs[9] * $xs[10] * $xs[11]
    * $xs[12] + $xs[0] * $xs[5] * $xs[6] * $xs[7] * $xs[8] * $xs[9] * $xs[10] * $xs[11]
    * $xs[12] * $xs[13] + $xs[0] * $xs[5] * $xs[6] * $xs[7] * $xs[8] * $xs[9] * $xs[10]
    * $xs[11] * $xs[12] * $xs[13] * $xs[14] + $xs[0] * $xs[5] * $xs[6] * $xs[7] *
    $xs[8] * $xs[9] * $xs[10] * $xs[11] * $xs[12] * $xs[13] * $xs[14] * $xs[15] +
    $xs[0] * $xs[5] * $xs[6] * $xs[7] * $xs[8] * $xs[9] * $xs[10] * $xs[11] * $xs[12]
    * $xs[13] * $xs[14] * $xs[15] * $', "  return [array_sum(array_map(function($x)\
    \ {\n    return $x * $xs;\n  }, array_slice($xs, 1)))];\n}\n", "  $n = count($xs)\
    \ - 1;\n  $dxs = array();\n  for($i = 0; $i < $n; ++$i) {\n    $dxs[] = ($xs[$i\
    \ + 1] - $xs[$i]) / $xs[$i];\n  }\n  return $dxs;\n}\n", "    if (count($xs) ===\
    \ 0) {\n        return [];\n    }\n    if (count($xs) === 1) {\n        return\
    \ $xs;\n    }\n    $derivation = array_reverse($xs);\n    return array_fill(0,\
    \ count($xs) - 1, $xs[count($xs) - 1] + ($xs[count($xs) - 2] * $derivation[0]));\n\
    }\n</code>\n<|/ a tags=php,arrays,recursion,algorithm |>\n<| c |>\nThis is a great\
    \ answer and should be accepted as such.\n<|/ c |>\n<| c |>\nAwesome! Very helpful!\n\
    <|/ c |>\n<| a tags=php,arrays,recursion,algorithm |>\nRecursive solution, based\
    \ on array_reduce:\n<code>", "  // Return empty array if coefficient count is\
    \ 0.\n  if (empty($xs)) return array();\n\n  // Return empty array if count of\
    \ coefficients is 1.\n  if (count($xs) == 1) return array(0);\n\n  // Return empty\
    \ array if count of coefficients is 2.\n  if (count($xs) == 2) return array(1);\n\
    \n  // Return empty array if count of coefficients is more.\n  if (count($xs)\
    \ > 2) {\n    array_shift($xs);\n    $ys = array();\n    foreach ($xs as $x) {\n\
    \      $ys[] = ($x * $x);\n    }\n    return array($ys);\n  }\n\n  // Return empty\
    \ array if count of coefficients is 1.\n  if (count($xs) == 1) return array(0);\n\
    \n  $d = $xs[0] * $xs[1];\n  for ($i = 2; $i < count($xs); $i++) {\n    $d *=\
    \ ($xs[$i] - $xs[$i - 1]);\n  }\n\n  return array($d);\n}", "    return array_map(function\
    \ ($x) {\n        return pow($x, 2);\n    }, $xs);\n}\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nIt might be worth explaining what this does and why it works.\n\
    <|/ c |>\n<| a |>\nThe simplest solution would be to use the formula for the derivative\
    \ of the polynomial f(x) here:\nhttps://en.wikipedia.org/wiki/Derivative#Formulas_for_the_derivative\n\
    The formula is \n\nwhere n is the degree of the polynomial\n\nThis formula gives\
    \ the derivative of the polynomial f(x) at x.\nThe python code to do so would\
    \ be:\n<code>\ndef f(x):\n    return x**3 + x**2 + x\n\ndef deriv(f):\n    def\
    \ fprime(x):\n        return 3*x**2 - 2*x + 1\n    return fprime\n</code>\n<|/\
    \ a tags=python,polynomials,math,polynomials dscore=5 |>\n<| c |>\nThis doesn't\
    \ really answer the OP's question.  It might be better to put it in a comment\
    \ under the accepted answer.\n<|/ c |>\n<| c |>\nWhat if it's a power of a different\
    \ function than the polynomial? For example: x^2 -> f(x)^2 -> f(g(x))^2.\n<|/\
    \ c |>\n<| c |>\nThis is not a solution if you need the derivative of a polynomial\
    \ of the form `p(x)`, where `p(x)` is itself a polynomial of degree `n-1`. What\
    \ you are doing is taking the derivative of a polynomial with degree `n` and this\
    \ will not give you the desired result.\n<|/ c |>\n<| c |>\nIt seems that the\
    \ formulas above is correct for most polynomials, I tested it with different polynomial\
    \ formulae and they all give the expected results. So the formula is correct and\
    \ should be accepted. The formulas in the accepted answer give the wrong answer\
    \ for some polynomials.\n<|/ c |>\n<| c |>\nThis is wrong. Consider `f(x) = x^4`\
    \ with `x = 2`. Now consider `fprime(x) = x^4 + 2*x + 1`. Now the formula gives\
    \ the derivative of `f` at `x`, whereas the answer here gives the derivative of\
    \ `fprime` at `x`.\n<|/ c |>\n<| a |>\nYou can use the following functions to\
    \ get the derivative:\n<code>\ndef f(x):\n    return x * x\n\ndef f_prime(x):\n\
    \    return 2 * x\n\ndef deriv(f, x):\n    return f_prime(x) * f(x)\n\nprint(deriv(f,1))\n\
    </code>\n<|/ a tags=python,polynomials,math,polynomials dscore=4 |>\n<| c |>\n\
    this answer doesn't take in to account the fact that `f(x) = x^", "    return\
    \ array_map(function ($x) { return $x * $xs; }, range(1, count($xs) - 1));\n}\n\
    </code>\n<|/ a dscore=0 tags=php |>\n<| c |>\nThis looks like a great solution,\
    \ but when I try to run it I get an error, `syntax error, unexpected '' (T_ENCAPSED_AND_WHITESPACE),\
    \ expecting identifier (T_STRING) or variable (T_VARIABLE) or number (T_NUM_STRING)`.\
    \ Any ideas on how to fix this?\n<|/ c |>\n<| c |>\nYou need to put this in a\
    \ function, then call that function inside the `array_map` call I made. The `''`\
    \ error is because you didn't put a `function derivative($xs){}` inside the `array_map`\
    \ call.\n<|/ c |>\n<| a tags=php |>\nYou can solve this without using arrays.\
    \ The following code generates the power series using simple math.\n<code>\n<?php",
  "    $result = 0;\n    foreach ($xs as $x => $coefficient) {\n        $result -=\
    \ $coefficient * $x;\n    }\n    return $result;\n}\n", "  $d = $xs[0];\n  for\
    \ ($i = 1; $i < count($xs); $i++) {\n    $d *= $xs[$i];\n  }\n  return $d;\n}",
  "  $dys = array();\n  for ($i = 0; $i < count($xs); ++$i) {\n    $dys[$i] = $xs[$i];\n\
    \  }\n  for ($i = 0; $i < count($xs) - 1; ++$i) {\n    $dys[$i] += $dys[$i + 1]\
    \ * $xs[$i + 1];\n  }\n  return $dys;\n}\n", "  $d = array();\n  for ($i = 0;\
    \ $i < count($xs) - 1; $i++) {\n    $d[$i] = $xs[$i] * $xs[$i - 1];\n  }\n  $d[$i]\
    \ = $xs[$i];\n  return $d;\n}\n", "\t$x = $xs[0];\n\t$n = count($xs) - 1;\n\t\
    if ($n < 0) throw new Exception('Not enough coefficients!');\n\t$d = $xs[$n];\n\
    \t$xs = array_slice($xs, $n);\n\tif (count($xs) < 2) return array($d);\n\t$result\
    \ = [];\n\twhile ($x != 0) {\n\t\t$result[] = $x;\n\t\t$x = $x * $n - $d;\n\t\t\
    $n = $n - 1;\n\t}\n\tarray_unshift($result, $d);\n\treturn $result;\n}\n", " \
    \ $n = count($xs);\n  $d = $xs[1];\n  for ($i = 0; $i < $n - 1; $i++) {\n    $d\
    \ *= $xs[$i + 1];\n  }\n  return array($d, $xs[$n - 1]);\n}\n", "    return array_reduce($xs,\
    \ create_function('$v,$k', '$k+$v'), 0);\n}\n</code>\n<|/ a |>\n<| a dscore=2\
    \ |>\nIf you just want it for one case (first element of the array), you can just\
    \ use array_shift. Otherwise, you can write a recursive function to calculate\
    \ the derivative.\n<code>", "    $xs_length = count($xs);\n    if ($xs_length\
    \ < 1) {\n        return array(1);\n    }\n    $deriv = array(1);\n    for ($i\
    \ = 1; $i < $xs_length - 1; $i++) {\n        $deriv[] = ($xs[$i] - $xs[$i - 1])\
    \ / $xs[$i];\n    }\n    $deriv[] = 0;\n    return $deriv;\n}", "  $ds = array_pad(array(0),\
    \ count($xs) + 1);\n  for ($i = 0; $i <= count($xs); $i++) {\n    $ds[$i] = $xs[$i];\n\
    \    for ($j = 0; $j <= $i; $j++) {\n      $ds[$i] += $xs[$j] * $ds[$j + 1];\n\
    \    }\n  }\n  return $ds;\n}", "  return array_slice($xs, 0, count($xs) - 1)\
    \ * (\n         array_pop($xs) - array_shift($xs))\n         + array(array_pop($xs))\n\
    \         ;\n}", "  $d = array_shift($xs);\n  return $xs[0] - $d * array_shift($xs);\n\
    }", "  $x = array_shift($xs);\n  return $xs === array() ? array(1) : ($x * derivative(array_merge($xs,\
    \ array($x))));\n}\n", "  $n = count($xs);\n  if ($n == 0) {\n    return array(0);\n\
    \  }\n  if ($n == 1) {\n    return array(1);\n  }\n  return array(\n    array_shift($xs)\
    \ * array_reduce($xs, function($result, $x) {\n      return $result + $x * $x;\n\
    \    })\n  );\n}", "  $ys = array_merge(array(0), $xs);\n  $d = $xs[1];\n  for\
    \ ($i = 2; $i < count($xs) - 1; ++$i) {\n    $d *= $ys[$i - 1];\n  }\n  return\
    \ $d;\n}\n", "  if (count($xs) == 0)\n    return array();\n  elseif (count($xs)\
    \ == 1)\n    return array($xs[0]);\n\n  $d = $xs[0];\n  for ($i = 1; $i < count($xs);\
    \ $i++)\n    $d *= $xs[$i];\n\n  return $d;\n}\n", "  $d = array();\n  $d[0] =\
    \ 1;\n  for($i = 1; $i < count($xs) - 1; ++$i) {\n    $d[$i] = $d[$i - 1] * $xs[$i];\n\
    \  }\n  return $d;\n}\n", "    $ys = array();\n    $xs = array_reverse($xs);\n\
    \    foreach ($xs as $x => $y) {\n        $ys[] = pow($x, $y) / array_reduce($xs,\
    \ create_function('$x, $y', 'return $x * $y;'));\n    }\n    return array_reverse($ys);\n\
    }\n", "  $ys = array_shift($xs);\n  $dy = $xs;\n  foreach ($xs as $x) {\n    $dy\
    \ = $dy[0] * $x + $dy[1];\n  }\n  return $dy;\n}", "  $xs[] = 1;\n  $p = $xs;\n\
    \  $d = $xs;\n  for ($i = 1; $i < count($xs); $i++) {\n    $p = $p + $xs[$i] *\
    \ $i;\n    $d[$i] = $p[$i];\n  }\n  return $d;\n}", "    // We have array of coefficients\
    \ now.\n    // To make it simple, get all powers of x, from 0 to highest power\
    \ of x (i.e. highest power).\n    $powers = array_map(function($x){return $x **\
    \ count($xs);}, range(1,count($xs) - 1));\n    // Multiply all powers of the array\
    \ with coefficients.\n    $res = array_reduce($powers, function($acc, $cur){ \n\
    \        return array_merge($acc, array_fill(0, count($xs), $cur)); \n    });\
    \ \n    // Remove powers which have a coefficient equals to 0.\n    $res = array_filter($res,\
    \ function($cur){ return !array_sum($cur); });\n    // Get polynomial coefficients\
    \ as arrays.\n    $res = array_map(function($x){ return $xs; }, $res);\n    return\
    \ $res;\n}\n", "    return array_map(function($x) {\n        return $x[1];\n \
    \   }, $xs);\n}\n", "  return array_shift($xs) + ($xs * ($xs * ($xs * ($xs * ($xs\
    \ * 3) + 1) + 1) + 1));\n}\n</code>\n<|/ a tags=php,multiplication,arrays,numbers\
    \ |>\n<| a tags=php,multiplication,arrays,numbers |>\nAs you can see from other\
    \ answers, there is probably a better way to do it. This is the one I ended up\
    \ using after reviewing others:\n<code>", "  $y = $xs[0];\n  if (count($xs) ==\
    \ 1) return array($y);\n\n  $x = array_shift($xs);\n  return array(\n    1 =>\
    \ $y,\n    $x => derivative($xs),\n  );\n}\n\n$xs = array(3, 1, 2, 4, 5);\n$xs_deriv_1_4\
    \ = derivative($xs);\nprint '<table>';\nprint '<tr><td>x1</td><td>'.$xs[0].'</td></tr>';\n\
    print '<tr><td>x2</td><td>'.$xs[1].'</td></tr>';\nprint '<tr><td>x3</td><td>'.$xs[2].'</td></tr>';\n\
    print '<tr><td>x4</td><td>'.$xs[3].'</td></tr>';\nprint '<tr><td>x5</td><td>'.$xs[4].'</td></tr>';\n\
    print '<tr><td>xs_deriv_1_4</td><td>'.$xs_deriv_1_4[0].'</td></tr>';\nprint '<tr><td>xs_deriv_1_4^2</td><td>'.$xs_deriv_1_4[1].'</td></tr>';\n\
    print '<tr><td>xs_deriv_1_4^3</td><td>'.$xs_deriv_1_4[2].'</td></tr>';\nprint\
    \ '<tr><td>xs_deriv_1_4^4</td><td>'.$xs_deriv_1_4[3].'</td></tr>';\nprint '<tr><td>xs_deriv_1_4^5</td><td>'.$xs_deriv_1_4[4].'</td></tr>';\n\
    print '</table>';", "  // if first argument is an array, assume it is an array\
    \ of coefficients\n  if (is_array($xs[0])) {\n    return array_map(function ($x)\
    \ { return $x * $xs[1]; }, $xs);\n  }\n  // else if first argument is a number,\
    \ assume it is an offset or a power\n  else {\n    return array_map(function ($x)\
    \ { return $x * $xs; }, range(1, count($xs)));\n  }\n}\n", "  $n = count($xs);\n\
    \  if ($n === 0) {\n    return 0;\n  }\n  $d = 0;\n  for ($i = 0; $i < $n - 1;\
    \ $i++) {\n    $d += ($xs[$i] * $xs[$n - 1 - $i]);\n  }\n  return $d;\n}\n", " \
    \ $n = count($xs);\n  if ($n < 1) {\n    return array();\n  }\n  $f = array_shift($xs);\n\
    \  $d = array();\n  for ($i = 0; $i < $n; ++$i) {\n    $d[$i] = $xs[$i] - $f;\n\
    \  }\n  return $d;\n}\n", "  $x = $xs[0];\n  $y = 0;\n  for ($i = 1; $i < count($xs);\
    \ $i++) {\n    $y += $xs[$i] * $i;\n  }\n  return array($y - $x, $y);\n}\n", " \
    \ if (!is_array($xs)) {\n    throw new \\InvalidArgumentException('Argument should\
    \ be an array.');\n  }\n  $result = [];\n  $x = array_shift($xs);\n  for ($i =\
    \ 0; $i < count($xs); ++$i) {\n    $result[$i] = $xs[$i] - $x;\n    $x = $result[$i];\n\
    \  }\n  return $result;\n}\n", "  $xs_length = count($xs);\n  $f = array();\n\
    \  for ($i = 0; $i < $xs_length; ++$i) {\n    $f[$i] = 1;\n    $f[$i] -= $xs[$i]\
    \ * $i;\n  }\n  return $f;\n}\n", "    $result = [];\n    $xs = array_map(function\
    \ ($x) { return pow($x, 2); }, $xs);\n    $products = array_map(function ($product)\
    \ { return pow($product, 2); }, $xs);\n    foreach ($products as $product) {\n\
    \        $result[] = $product;\n    }\n    $result[] = 1;\n    return array_map(function\
    \ ($value) { return $value / array_sum($result); }, $xs);\n}\n</code>\n<|/ a tags=algorithm,math,php\
    \ dscore=1 |>\n<| c |>\nThe input is a list. `array_sum($result)` will give the\
    \ sum of all elements in the given array, so `array_sum` is unnecessary.\n<|/\
    \ c |>\n<| c |>\nYes, you're right. I added it to the code above. I meant to get\
    \ rid of it when I realized that `array_sum` is indeed unnecessary.\n<|/ c |>\n\
    <| a tags=algorithm,math,php dscore=1 |>\nI think this is the shortest and fastest\
    \ way. No loops and no recursion. It just sums up each coefficient of the polynomial\
    \ using array_reduce. Also uses no recursion and no loops.\n<code>", "  $f = array_shift($xs);\n\
    \  return array($f);\n}\n", "  $n = count($xs);\n  $d = $xs[0];\n  for ($i = 1;\
    \ $i < $n - 1; $i++) {\n    $d *= $xs[$i];\n  }\n  return array($d);\n}\n", " \
    \ list($x, ) = static::normalize($xs);\n\n  $dx = array();\n  foreach ($xs as\
    \ $x_item) {\n    $dx[] = 1 / $x_item;\n  }\n  return $dx;\n}\n\n/**\n * Returns\
    \ array of all items from first array and all items from\n * second array. Items\
    \ from first array will be after items from second\n * array.\n * >>> array_union(array(1,\
    \ 1, 2, 3), array(2, 3, 4, 5))\n * array(1, 1, 2, 3, 4, 5)\n * >>> array_union(array(1,\
    \ 2), array(2, 3, 4))\n * array(2, 1, 3, 2, 4)\n * >>> array_union(array(1, 2,\
    \ 3), array(1, 3))\n * array(1, 2, 3, 1)\n */", "  $xs = array_slice($xs, 0, 1);\n\
    \  $f = current($xs);\n  $xs = array_slice($xs, 1);\n  $d = [];\n  for ($i = 0,\
    \ $j = count($xs); $i < $j; $i++) {\n    $a = $xs[$i];\n    $xs[$i] = $f;\n  \
    \  $f = $a * $xs[$i];\n    $xs[$i] = $a;\n    $d[] = $f;\n  }\n  return $d;\n\
    }\n", "  return array_map(function($x) {\n    return pow($x, (count($xs) - 1));\n\
    \  }, $xs);\n}\n", "  $xs[0] -= $xs[1] * $xs[1];\n  return $xs;\n}\n", "  // First\
    \ calculate powers of the polynomial\n  $res = array(1);\n  foreach ($xs as $x)\
    \ {\n    $res += $res[$res.length - 1] * $x;\n  }\n\n  // Get rid of last one\n\
    \  array_pop($res);\n\n  // Return derivative\n  return $res;\n}"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
