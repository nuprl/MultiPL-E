name: HumanEval_56_correct_bracketing
language: php
prompt: "<?php\n// brackets is a string of \"<\" and \">\".\n// return true if every\
  \ opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"\
  <\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"\
  <<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunction correct_bracketing($brackets)\
  \ {\n"
tests: "function candidate(...$args) {\n    return correct_bracketing(...$args);\n\
  }\n\nfunction test(): void {\n    if (candidate(\"<>\") !== true) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(\"<<><>>\") !== true) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(\"<><><<><>><>\") !== true) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(\"<><><<<><><>><>><<><><<>>>\") !== true)\
  \ { throw new Exception(\"Test failed!\"); }\n    if (candidate(\"<<<><>>>>\") !==\
  \ false) { throw new Exception(\"Test failed!\"); }\n    if (candidate(\"><<>\"\
  ) !== false) { throw new Exception(\"Test failed!\"); }\n    if (candidate(\"<\"\
  ) !== false) { throw new Exception(\"Test failed!\"); }\n    if (candidate(\"<<<<\"\
  ) !== false) { throw new Exception(\"Test failed!\"); }\n    if (candidate(\">\"\
  ) !== false) { throw new Exception(\"Test failed!\"); }\n    if (candidate(\"<<>\"\
  ) !== false) { throw new Exception(\"Test failed!\"); }\n    if (candidate(\"<><><<><>><>><<>\"\
  ) !== false) { throw new Exception(\"Test failed!\"); }\n    if (candidate(\"<><><<><>><>>><>\"\
  ) !== false) { throw new Exception(\"Test failed!\"); }\n}\n\ntest();"
completions: ["  $open = preg_grep(\"/^<+[^>]*>$/\", $brackets);\n  $close = preg_grep(\"\
    /^<[^>]*>+$/\", $brackets);\n  return count($open) == count($close);\n}\n", " \
    \   $stack = array();\n    $brackets = preg_replace('/(<)/', \"\\0\", $brackets);\n\
    \    $brackets = preg_replace('/(>)/', \"\\0\", $brackets);\n    $brackets = preg_replace('/(<\\\
    /)/', \"\\0\", $brackets);\n    $brackets = preg_replace('/(>\\/)/', \"\\0\",\
    \ $brackets);\n    $brackets = preg_replace('/(<\\//)/', \"\\0\", $brackets);\n\
    \    $brackets = preg_replace('/(>\\//)/', \"\\0\", $brackets);\n    $brackets\
    \ = preg_replace('/(<\\?)/', \"\\0\", $brackets);\n    $brackets = preg_replace('/(>\\\
    ?)/', \"\\0\", $brackets);\n    $brackets = preg_replace('/(<\\!)/', \"\\0\",\
    \ $brackets);\n    $brackets = preg_replace('/(>\\!)/', \"\\0\", $brackets);\n\
    \    $brackets = preg_replace('/(<\\!\\!)/', \"\\0\", $brackets);\n    $brackets\
    \ = preg_replace('/(>\\!\\!)/', \"\\0\", $brackets);\n    $brackets = preg_replace('/(<\\\
    !\\?>)/', \"\\0\", $brackets);\n    $brackets = preg_replace('/(>\\!\\?>)/', \"\
    \\0\", $brackets);\n    $brackets = preg_replace('/(<\\!\\?>\\!)/', \"\\0\", $brackets);\n\
    \    $brackets = preg_replace('/(>\\!\\?>\\!)/', \"\\0\", $brackets);\n    $brackets\
    \ = preg_replace('/(<\\!\\?>\\!\\!)/', \"\\0\", $brackets);\n    $brackets = preg_replace('/(>\\\
    !\\?>\\!\\!)/', \"\\0\", $brackets);\n    $brackets = preg_replace('/(<\\!\\?>\\\
    !\\!\\!)/', \"\\0\", $brackets);\n    $brackets = preg_replace('/(>\\!\\?>\\!\\\
    !\\!)/', \"\\0\", $brackets);\n    $brackets = preg_replace('/(<\\!\\?>\\!\\!\\\
    !\\!)/', \"\\0\", $brackets);\n    $brackets = preg_replace('/(>\\!\\?>\\!\\!\\\
    !\\!)/', \"\\0\", $brackets);\n    $brackets = preg_replace('/(<\\!\\?>\\!\\!\\\
    !\\!\\!)/', \"\\0\", $brackets);", "  return substr($brackets, 0, 1) === '<' &&\
    \ substr($brackets, -1, 1) === '>';\n}\n", "    $brackets = str_replace(\"<<><>>\"\
    , \"<><>\", $brackets);\n    return preg_match_all(\"/<\\=(?=<)/\", $brackets);\n\
    }\n", "  if(!$brackets || strlen($brackets)==0) {\n    return true;\n  }\n  $opens\
    \ = array_count_values(str_split($brackets));\n  $closes = array_count_values(str_split(str_repeat(\"\
    </$brackets>\", count($opens))));\n  if($opens == $closes)\n    return false;\n\
    \  else\n    return true;\n}\n", "    $brackets = preg_quote($brackets, '/');\n\
    \    $brackets = explode('>', $brackets);\n    $count = 0;\n    foreach ($brackets\
    \ as $key => $value) {\n        if (substr($value, -1, 1) === '/') {\n       \
    \     $count++;\n            $brackets[$key] = $value;\n        }\n    }\n   \
    \ return $count === 1;\n}\n", "    $result = true;\n    $count = 0;\n    foreach\
    \ ($brackets as $char) {\n        if ($char == \">\") {\n            $count++;\n\
    \        } else {\n            $count--;\n        }\n        if ($count < 0) {\n\
    \            $result = false;\n            break;\n        }\n    }\n    return\
    \ $result;\n}\n</code>\nThe result is that your code is correct!\n<|/ a |>\n<|\
    \ c |>\n`<>` is considered a right angle bracket for `<`; `<<>>` is considered\
    \ a right angle bracket for `<<>`; `>>>` is not considered a right angle bracket\
    \ for `>>`; and `<<><><>>` is considered a left angle bracket for `<<<>`; and\
    \ `<<<><>>` is considered a right angle bracket for `>><`\n<|/ c |>\n<| c |>\n\
    thank you for the comment, I modified my answer accordingly. I think the OP doesn't\
    \ care about that though, since he stated \"any combination of < and >\", so I\
    \ guess I misunderstood the question. Thanks again\n<|/ c |>\n<| a |>\nIn addition\
    \ to the other suggestions, if you only want a boolean value back, use the preg_match()\
    \ function.\nhttp://php.net/manual/en/function.preg-match.php\n<|/ a tags=php\
    \ dscore=1 |>\n<| a dscore=1 |>\nA PHP solution:\n<code>\n<?php\n", "  $opening\
    \ = array(\"<\", \">\");\n  $closing = array(\"<<\", \">>\");\n\n  $opening_brackets\
    \ = preg_match_all('/' . implode('|', $opening) . '/i', $brackets, $match);\n\
    \  $closing_brackets = preg_match_all('/' . implode('|', $closing) . '/i', $brackets,\
    \ $match);\n  if ($opening_brackets === 1 && $closing_brackets === 1) {\n    return\
    \ true;\n  } else {\n    return false;\n  }\n}\n", "    $result = false;\n   \
    \ $stack = [];\n\n    foreach ($brackets as $b) {\n        if ($b == '<') {\n\
    \            $stack[] = $b;\n        }\n        if ($b == \">\") {\n         \
    \   $stack[] = array_pop($stack);\n        }\n    }\n    if (!empty($stack)) {\n\
    \        $result = false;\n    } else {\n        $result = true;\n    }\n    return\
    \ $result;\n}\n", "\t$n = strlen($brackets);\n\tfor ($i = 0; $i < $n; $i++) {\n\
    \t\tif ($brackets[$i] !== \"<\" && $brackets[$i] !== \">\") return false;\n\t\
    }\n\treturn true;\n}", "    // If this function is passed an empty string, don't\
    \ do anything.\n    if ($brackets == '') {\n        return false;\n    }\n\n \
    \   // If the brackets string has zero length, return false.\n    if (strlen($brackets)\
    \ == 0) {\n        return false;\n    }\n\n    // If the brackets string has two\
    \ closing brackets, return false.\n    if (strpos($brackets, '>>') === false)\
    \ {\n        return false;\n    }\n\n    // If the string has only one opening\
    \ bracket, return false.\n    if (strpos($brackets, '<') === false) {\n      \
    \  return false;\n    }\n\n    // If there's an even number of opening brackets\
    \ followed by a single\n    // closing bracket, return false.\n    if (preg_match('/(<)\\\
    1/', $brackets, $match)) {\n        return false;\n    }\n\n    // If there's\
    \ an odd number of opening brackets, return false.\n    if (preg_match('/(<[^>]*>)\\\
    1/', $brackets, $match)) {\n        return false;\n    }\n\n    // If there's\
    \ a closing bracket at the start of the string, return false.\n    if (preg_match('/(<[^>]*>)/',\
    \ $brackets, $match)) {\n        return false;\n    }\n\n    // Otherwise, return\
    \ true.\n    return true;\n}", "    $brackets = preg_replace('/^<+|\\>+$/', '',\
    \ $brackets);\n    $brackets = preg_replace('/^<*+|\\*>+$/', '', $brackets);\n\
    \    $brackets = preg_replace('/^<+*+|\\*>+*+$/', '', $brackets);\n    $brackets\
    \ = preg_replace('/^<+*\\>+$/', '', $brackets);\n    $brackets = preg_replace('/^<*\\\
    >+$/', '', $brackets);\n    $brackets = preg_replace('/^<*\\>*$/', '', $brackets);\n\
    \    return ($brackets === '<>');\n}", "  for ($i = 0; $i < strlen($brackets);\
    \ ++$i) {\n    if ($brackets[$i] == \"<\") {\n      if (substr($brackets, ($i+1),\
    \ 1) == \">\") {\n        return true;\n      }\n    }\n  }\n  return false;\n\
    }\n", "    $count = 0;\n    $opening_brackets = array();\n    $closing_brackets\
    \ = array();\n    foreach ($brackets as $bracket) {\n        if ($bracket == \"\
    <\") {\n            $opening_brackets[] = $bracket;\n        } else {\n      \
    \      $closing_brackets[] = $bracket;\n        }\n    }\n    foreach ($opening_brackets\
    \ as $bracket) {\n        ++$count;\n        foreach ($closing_brackets as $close_bracket)\
    \ {\n            if ($bracket != $close_bracket) {\n                break;\n \
    \           }\n        }\n    }\n    return $count == count($opening_brackets);\n\
    }\n</code>\n<|/ a |>\n<| c |>\nYes, that's a much simpler way to do it. I was\
    \ looking for a way that didn't require O(n^2) time complexity. But since I asked\
    \ the question I thought I'd take a stab at it. I suppose if there were more than\
    \ a few brackets, it would be better to store them in an array. Though I'd probably\
    \ just keep them all in one array and just keep track of where the last \"open\"\
    \ bracket ended up. That way it wouldn't be too hard to find where the first \"\
    close\" bracket would begin.\n<|/ c |>\n<| a tags=php,string,string-parsing,regex\
    \ dscore=3 |>\nYou could use strtok to break it into an array of tokens and then\
    \ explode each one with <<<END>>> and then check for the correct number of <<<\
    \ tokens and <<< tokens for each one in the END>>.\n<code>\n$test = \"<<><>><><\"\
    ;\n$test = strtok($test, '<<<END>><><');\n\n$tokenCounter = 0;\nwhile($test)\n\
    {\n    $endOfTokens = strtok(\"END\");\n    $startOfTokens = strtok(\"<\");\n\n\
    \    if($endOfTokens == $tokenCounter)\n    {\n        $tokenCounter++;\n    }\n\
    \    else\n    {\n        echo \"The brackets don't match!\";\n        break;\n\
    \    }\n\n    if($startOfTokens == $tokenCounter)\n    {\n        $tokenCounter++;\n\
    \    }\n    else\n    {\n        echo \"The brackets don't match!\";\n       \
    \ break;\n    }\n\n    $test = strtok(\"<<<END>><><\");\n}\n</code>\n<|/ a |>\n\
    <| c |>\nIt would be better to use the third argument of `strtok()` to split on\
    \ both '<' and '>', rather than using two different delimiters.\n<|/ c |>\n<|\
    \ c |>\nYea", "  return preg_match('/([<]{2}|[>]{2})/', $brackets);\n}\n", " \
    \ for ($i = 0; $i < strlen($brackets); $i++) {\n    // if we're in a string, then\
    \ we need to match this closing bracket to the opening bracket\n    // so we'll\
    \ use a negative lookahead assertion to check if we're not in a string.\n    //\
    \ if we're not in a string, then we can just check if the current char is a \"\
    <\" or a \">\"\n    if (preg_match(\"~^[^<]*</?$~\", $brackets, $match) &&\n \
    \       preg_match(\"~^[^>]*>?$~\", $brackets, $match)) {\n      // if they match,\
    \ then we have a match\n      // if the opening and closing brackets match then\
    \ we have a match\n      if ($match[0] === $brackets && $match[1] === $brackets)\
    \ {\n        // they match and we're at the start of a string\n        // so if\
    \ we want to find the end of a string, we need to start with the opposite string\n\
    \        $opposite_brackets = str_replace(\">\", \"\", $brackets);\n        $opposite_brackets\
    \ = str_replace(\"<\", \"\", $opposite_brackets);\n        if ($opposite_brackets\
    \ === $brackets) {\n          return false;\n        }\n      }\n    }\n  }\n\
    \  return true;\n}\n", "    foreach(explode(\"<>\", $brackets) as $open) {\n \
    \       foreach(explode(\"<>\", $open) as $close) {\n            if($open != $close)\n\
    \                return false;\n        }\n    }\n    return true;\n}\n</code>\n\
    If performance matters, I suggest you use a lookup table, instead of array_flip()\n\
    <|/ a dscore=2 |>\n<| a |>\nI've just written a javascript function that I believe\
    \ does this\n<code>", "\tforeach (str_split($brackets) as $pair) {\n\t\t$match\
    \ = preg_match(\"/^<(.*?)>$/\", $pair);\n\t\tif ($match === 1) {\n\t\t\tif (preg_match(\"\
    /^<(.*?)>/\", $brackets, $match2) === 1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\
    \t}\n\t}\n\treturn true;\n}\n", "  // initialize a stack\n  $stack = array();\n\
    \n  // for each opening bracket, push it to the stack\n  for ($i=0; $i<strlen($brackets);\
    \ $i++) {\n    $stack[] = $brackets[$i];\n  }\n\n  // keep looping while stack\
    \ is not empty\n  while (!empty($stack)) {\n    // pop the top element\n    $bracket\
    \ = array_pop($stack);\n\n    // if this is not an opening bracket, return false\n\
    \    if (!in_array($bracket, array('<', '>'))) {\n      return false;\n    }\n\
    \n    // otherwise if this is not an open bracket, continue\n    if (!in_array($brackets[$i],\
    \ array('>', '<'))) {\n      continue;\n    }\n\n    // otherwise if this is not\
    \ an open bracket, continue\n    if (!in_array($brackets[$i], array('>', '<')))\
    \ {\n      continue;\n    }\n\n    // otherwise if this is not an open bracket,\
    \ continue\n    if (!in_array($brackets[$i], array('>', '<'))) {\n      continue;\n\
    \    }\n\n    // otherwise if this is not an open bracket, continue\n    if (!in_array($brackets[$i],\
    \ array('>', '<'))) {\n      continue;\n    }\n\n    // otherwise if this is not\
    \ an open bracket, continue\n    if (!in_array($brackets[$i], array('>', '<')))\
    \ {\n      continue;\n    }\n\n    // otherwise if this is not an open bracket,\
    \ continue\n    if (!in_array($brackets[$i], array('>', '<'))) {\n      continue;\n\
    \    }\n\n    // otherwise if this is not an open bracket, continue\n    if (!in_array($brackets[$i],\
    \ array('>', '<'))) {\n      continue;\n    }\n\n    // otherwise if this is not\
    \ an open bracket, continue\n    if (!in_array($brackets[$i], array('>', '<')))\
    \ {\n      continue;\n    }\n\n    // otherwise if this is not an open bracket,\
    \ continue\n    if (!in_array($brackets[$i], array('>', '<'))) {\n      continue;\n\
    \    }\n\n    // otherwise if this is not an open bracket, continue\n    if (!in_array($brackets[$i],\
    \ array('>', '<'))) {\n      continue;\n    }\n\n    // otherwise if this is not\
    \ an open bracket, continue\n    if (!in_array($brackets[$i], array('>', '<')))\
    \ {\n      continue;\n    }\n\n    // otherwise if this is not an open bracket,\
    \ continue\n    if (!in_array($brackets[$i], array('>', '<'))) {\n      continue;\n\
    \    }\n\n    // otherwise if this is not an open bracket, continue\n    if (!in_array($brackets[$i],\
    \ array('>', '<'))) {\n      continue;\n    }\n\n    // otherwise if this is not\
    \ an open bracket, continue\n    if (!in_array($brackets[$i], ", "  return count($brackets)\
    \ == strlen($brackets) && !preg_match('/^<<.+>>$/s', $brackets);\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nYour function will return true for `<<<<>>>` which\
    \ is wrong.\n<|/ c |>\n<| c |>\nOh, yeah, I forgot to add `<` at the start and\
    \ `>` at the end. I will edit the answer :)\n<|/ c |>\n<| a tags=php,arrays,loops,string\
    \ |>\nYou can use a regular expression and preg_match_all function\n<code>\n<?php\n\
    \n$text = '<<<>>>';\n\n$regex = '~<<<([><])*([^<>]*)>*<<<([><])*([^<>]*)>*<<<([><])*([^<>]*)>*~';\n\
    \nif (preg_match_all($regex, $text, $matches)) {\n    var_dump($matches);\n}\n\
    </code>\n<|/ a dscore=0 |>\n<| a dscore=0 tags=php,arrays,loops,string |>\nFor\
    \ this particular case you could use the following regular expression:\n<code>\n\
    $pattern = '/<(>)+/';\n</code>\nAnd then check that the number of matches is equal\
    \ to the number of < > characters you need to have.\n<|/ a |>\n<| a dscore=0 |>\n\
    Here is a simplistic approach to this, which counts the opening and closing characters\
    \ and then performs a comparison:\n<code>\n$opens = '<';\n$closes = '</';\n$data\
    \ = '<<<>>>';\n", "  $brackets = str_replace(array(\"<\", \"<<\"), array(\">\"\
    , \"<<\"), $brackets);\n  $brackets = str_replace(array(\">\", \">>\"), array(\"\
    <\", \"<\"), $brackets);\n  return preg_match(\"/^<\\^>/\", $brackets);\n}", " \
    \ return preg_match('/<[^>]+>/', $brackets) > 0;\n}\n", "    $opening = array();\n\
    \    $closing = array();\n    $opening[$brackets] = true;\n    while (count($opening)\
    \ > 0) {\n        if (count($opening) > 0) {\n            $last = array_pop($opening);\n\
    \        } else {\n            $last = array_pop($closing);\n        }\n     \
    \   if ($last != false) {\n            $closing[$last] = true;\n        } else\
    \ {\n            $closing[$last] = false;\n        }\n    }\n    return count($opening)\
    \ == 0 && count($closing) == 0;\n}\n\n$brackets = \"\";\n$pos = 0;\n$len = strlen($query);\n\
    while (++$pos < $len) {\n    if ($brackets === \"\") {\n        if ($query[$pos]\
    \ === \"<\") {\n            $brackets = \"<\";\n        } elseif ($query[$pos]\
    \ === \">\") {\n            $brackets = \">\";\n        } else {\n           \
    \ $brackets = \"\";\n        }\n    } elseif ($query[$pos] === $brackets) {\n\
    \        if ($brackets === \"<\") {\n            $brackets = \"\";\n        }\
    \ else {\n            $brackets = \"\";\n        }\n    } else {\n        if ($brackets\
    \ === \"<\") {\n            $brackets = \"\";\n        } elseif ($query[$pos]\
    \ === \"<\") {\n            $brackets = \"<\";\n        } else {\n           \
    \ $brackets = \"\";\n        }\n    }\n}\n\n$brackets = str_repeat(\"<<<\", count($query)\
    \ - 1 - $pos);\nif ($correct_bracketing($brackets)) {\n    // print to screen\n\
    \    echo $brackets;\n} else {\n    // print to screen\n    echo \"\";\n}", " \
    \ $open_brackets = preg_split('/([<>])/', $brackets, -1, PREG_SPLIT_NO_EMPTY);\n\
    \  $closed_brackets = preg_split('/([<>])/', $brackets, -1, PREG_SPLIT_NO_EMPTY\
    \ | PREG_SPLIT_DELIM_CAPTURE);\n  $opened = false;\n  foreach ($open_brackets\
    \ as $key => $opening) {\n    if (!isset($closed_brackets[$key])) return false;\n\
    \    if ($opening != $closed_brackets[$key]) return false;\n    if ($opened) {\n\
    \      if ($key + 1 < count($closed_brackets) &&\n          $opening.'<>'.$closed_brackets[$key+1].'<>'\
    \ != $closed_brackets[$key+1].$closed_brackets[$key]) {\n        return false;\n\
    \      }\n    } else {\n      if ($key != 0) return false;\n      $opened = true;\n\
    \    }\n  }\n  return true;\n}\n", "    $opening_brackets = explode(\"<\", $brackets);\n\
    \    $closing_brackets = explode(\">\", $brackets);\n    foreach ($opening_brackets\
    \ as $key => $value) {\n        if ($key < count($closing_brackets) && !strcmp($value,\
    \ $closing_brackets[$key])) {\n            return false;\n        }\n    }\n \
    \   return true;\n}\n", "    $counts = array_count_values(str_split($brackets));\n\
    \    $correct_counts = array();\n    foreach ($counts as $key => $val) {\n   \
    \     if ($val != 1) {\n            $correct_counts[$key] = $val;\n        }\n\
    \    }\n\n    return count($correct_counts) == 1;\n}\n</code>\n<|/ a dscore=4\
    \ tags=regex,php |>\n<| c |>\n+1. For those who want to solve this puzzle: \"\
    what happens when an opening bracket is never closed?\"\n<|/ c |>\n<| c |>\n:\
    \ If the string is `<<><>>`, then `<<><>>` has four opening brackets and two closing\
    \ brackets, and both have one closing bracket. Two brackets with one closing bracket\
    \ are fine, but three brackets with no closing brackets would not be fine.\n<|/\
    \ c |>\n<| c |>\n: Thanks again. Didn't even think of that one. :)\n<|/ c |>\n\
    <| c |>\n: This was the best solution I could think of. +1 for the most concise\
    \ (and fastest) solution. I'm wondering if there's a way to do the same thing\
    \ in perl, but that's a topic for another day.\n<|/ c |>\n<| c |>\n: I looked\
    \ into it (perl), but haven't really gotten to it. Looks like someone posted a\
    \ [similar question](http://stackoverflow.com/questions/376639/regex-for-matching-closed-and-inside-open-tags-with-perl).\n\
    <|/ c |>\n<| a dscore=4 |>\nThis is also a solution (PHP version < 5.3.0)\n<code>",
  "    $brackets = explode('<', $brackets);\n    return $brackets[0] === '>' && $brackets[1]\
    \ === '<';\n}\n", "    return preg_match_all('/<+>/m', $brackets) && preg_match_all('/<+>/m',\
    \ $brackets);\n}\n</code>\n<|/ a tags=php,parsing,string,regex dscore=0 |>\n<|\
    \ c |>\nYour first solution worked perfectly and is a nice simple way to do this.\
    \ I ended up going with your second option as it's less complicated and is easier\
    \ to read. Thanks for the quick response!\n<|/ c |>\n<| a |>\nI would use a regex\
    \ like this to match each < and >\n<code>\n<(.*?)>\n</code>\nBut I guess it could\
    \ be tricky if there are things like <<<> but that would be an easy fix to make\
    \ it more specific. \nThe basic idea here is to capture any text between the <\
    \ and > and put it in a capturing group. Then use the first group to match anything\
    \ between < and >\n<|/ a tags=php,parsing,string,regex dscore=0 |>\n<| c |>\n\
    Yes, I thought about doing something like this, but then how would I parse it\
    \ so that I pull out everything between the two sets of brackets? So that if there\
    \ were two sets of brackets, it would return something like: [\"<\", \"hello\"\
    , \">\", \"<\", \"<\", \"<\", \"<\", \"<\", \"<\", \"<\", \"<\", \">\", \">\"\
    ]\n<|/ c |>\n<| a tags=php,parsing,string,regex dscore=0 |>\nI believe that this\
    \ would do what you want:\n<code>\n$str = \"<hello><><><><><><><><>\";\n\n$array\
    \ = preg_split('/(\\<[^>]+\\>)/', $str, null, PREG_SPLIT_NO_EMPTY | PREG_SPLIT_DELIM_CAPTURE);\n\
    \n$array = array_filter($array);\n\nvar_dump($array);\n</code>\nOutput:\n<code>\n\
    array(8) {\n  [0]=>\n  string(5) \"<hello>\"\n  [1]=>\n  string(3) \"hello\"\n\
    \  [2]=>\n  string(0) \"\"\n  [3]=>\n  string(0) \"\"\n  [4]=>\n  string(0) \"\
    \"\n  [5]=>\n  string(0) \"\"\n  [6]=>\n  string(0) \"\"\n  [7]=>\n  string(0)\
    \ \"\"\n}\n</code>\n<|/ a |>\n<| a tags=php,parsing,string,regex dscore=0 |>\n\
    <code>", "  // A helper function which returns true when brackets are balanced\n\
    \  // correctly.\n  // >>> is_valid_bracket(\"<\")\n  // true\n  // >>> is_valid_bracket(\"\
    <>\")\n  // true\n  // >>> is_valid_bracket(\"><<>\")\n  // true\n  // >>> is_valid_bracket(\"\
    <<><>>\")\n  // false\n  function is_valid_bracket($brackets) {\n    // This algorithm\
    \ is slightly optimized from the one used in Python\n    // version 2.6.2\n  \
    \  // >>> is_valid_bracket(\"<\")\n    // False\n    // >>> is_valid_bracket(\"\
    <<\")\n    // False\n    // >>> is_valid_bracket(\"<>\")\n    // True\n    //\
    \ >>> is_valid_bracket(\"<<><\")\n    // True\n    // >>> is_valid_bracket(\"\
    ><<>\")\n    // False\n    // >>> is_valid_bracket(\"<<><>>\")\n    // False\n\
    \    // >>> is_valid_bracket(\"<<><>>\")\n    // True\n    // >>> is_valid_bracket(\"\
    <<<\")\n    // False\n    // >>> is_valid_bracket(\"<<<\")\n    // False\n   \
    \ // >>> is_valid_bracket(\"><\")\n    // False\n    // >>> is_valid_bracket(\"\
    ><\")\n    // False\n    // >>> is_valid_bracket(\"><<\")\n    // False\n    //\
    \ >>> is_valid_bracket(\"><<\")\n    // False\n    // >>> is_valid_bracket(\"\
    >>>>\")\n    // False\n    // >>> is_valid_bracket(\">>>>\")\n    // False\n \
    \   // >>> is_valid_bracket(\">>>\")\n    // False\n    // >>> is_valid_bracket(\"\
    >>>\")\n    // True\n    // >>> is_valid_bracket(\">>>\")\n    // True\n    //\
    \ >>> is_valid_bracket(\"<\")\n    // True\n    // >>> is_valid_bracket(\"<<\"\
    )\n    // True\n    // >>> is_valid_bracket(\"<>\")\n    // True\n    // >>> is_valid_bracket(\"\
    <<><\")\n    // True\n    // >>> is_valid_bracket(\"><<>\")\n    // True\n   \
    \ // >>> is_valid_bracket(\"<<><>>\")\n    // True\n    // >>> is_valid_bracket(\"\
    <<><>>\")\n    // True\n    // >>> is_valid_bracket(\"<<<\")\n    // True\n  \
    \  // >>> is_valid_bracket(\"<<<\")\n    // True\n    // >>> is_valid_bracket(\"\
    ><\")\n    // True\n    // >>> is_valid_bracket(\"><\")\n    // True\n    // >>>\
    \ is_valid_bracket(\"><<\")\n    // True\n    // >>> ", "\t$result = true;\n\t\
    $brackets = explode(\"<\", $brackets);\n\tforeach ($brackets as $b) {\n\t\t$result\
    \ &= $b;\n\t}\n\treturn $result;\n}\n", "    $brackets = explode('>', $brackets);\n\
    \    $counts = array_count_values($brackets);\n    return array_sum($counts) ==\
    \ count($brackets);\n}\n", "    $brackets = str_split($brackets);\n    $valid\
    \ = array_map('trim', $brackets);\n\n    if (count($valid) == 1) {\n        return\
    \ false;\n    }\n\n    $open = array_search('>', $valid);\n    $close = array_search('<',\
    \ $valid);\n    if ($open === false || $close === false) {\n        return false;\n\
    \    }\n\n    return true;\n}\n</code>\n<|/ a tags=php dscore=1 |>\n<| c |>\n\
    Good one. I've just found a case where this fails: if you have `<><>`, it returns\
    \ true.\n<|/ c |>\n<| c |>\nJust fixed that case\n<|/ c |>\n<| c |>\nHaha I beat\
    \ you to it! +1\n<|/ c |>\n<| a dscore=1 |>\n<code>\n$brackets    = \"<><>\";\
    \ // Input string.\n$bracketsArr = str_split($brackets);\n$bracketsArr = array_filter($bracketsArr);\n\
    \n$openBrackets = array_diff($bracketsArr, array('<', '>'));\n$closedBrackets\
    \ = array_diff($bracketsArr, array('>', '<'));\n\n$valid = $openBrackets !== $closedBrackets;\n\
    \nprint_r($valid); // Outputs bool(true)\n</code>\n<|/ a tags=php |>\n<| a |>\n\
    This solution also fails when you have only a single opening bracket or closing\
    \ bracket.\n<code>\n$input = \"<><>\";\n\n$open = array();\n$close = array();\n\
    \nif (preg_match_all('/<+(.*)>+/m', $input, $open)) {\n  foreach ($open[1] as\
    \ $i => $value) {\n    $open[] = $value[0];\n  }\n}\n\nif (preg_match_all('/<+(.*)>+/m',\
    \ $input, $close)) {\n  foreach ($close[1] as $i => $value) {\n    $close[] =\
    \ $value[0];\n  }\n}\n\nvar_dump($open, $close);\n\nvar_dump(count($open) == count($close));\n\
    </code>\n<|/ a tags=php dscore=1 |>\n<| a dscore=1 |>\nI agree with Amit, that\
    \ Regex is the way to go. However, if you want to keep it simple, you can use\
    \ a while loop :\n<code>\n$input = \"<><>\";\n\n$open = array();\n$close = array();\n\
    \nwhile($input){\n   $pos = strpos($input, '<');\n   if($pos === false){\n   \
    \   $pos = strpos($input, '>');", "  $brackets = preg_replace('/<+>/', '', $brackets);\n\
    \  return preg_match_all('/<+>/s', $brackets) === count($brackets) - 1;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThis won't work if the input string contains nested\
    \ brackets, such as \"([])\".\n<|/ c |>\n<| c |>\nWell, that's what it *should*\
    \ do.\n<|/ c |>\n<| a tags=php,algorithm |>\n<code>", "  $brackets = array_map('trim',\
    \ explode(\"\\n\", $brackets));\n  $brackets = array_map(function($s) {\n    return\
    \ trim($s);\n  }, $brackets);\n  return !$brackets;\n}\n</code>\n<|/ a tags=string,regex,php\
    \ |>\n<| c |>\nThat is awesome.  I'm still trying to wrap my head around how array_map\
    \ works.  Is it just applying the function to a given array?  If so, then how\
    \ does this work?\n\n $brackets = array_map(function($s) {\n    return trim($s);\n\
    \  }, $brackets);\n\nWhy do we need a callback here?\n<|/ c |>\n<| c |>\nYes,\
    \ it just applys a function to the array. The function simply trims each item\
    \ in the array because `array_map` will trim all items in the array (unless you\
    \ specify `false` as the first argument, which is what we do here).\n<|/ c |>\n\
    <| c |>\nAwesome, thanks for your help with that.  I still have a lot to learn\
    \ about this language.  This is probably the type of thing I should have been\
    \ able to figure out on my own.  Thanks again.\n<|/ c |>\n<| a dscore=3 |>\nHere\
    \ is another solution, maybe not very readable:\n<code>\n$text = \"This string\
    \ has some [brackets] which [should be handled] and [another]\";\n\n$pattern =\
    \ '~\\[([^]]*)]~';\n$replacement = '[$1]';\n\n$result = preg_replace($pattern,\
    \ $replacement, $text);\n</code>\n<|/ a tags=string,regex,php |>\n<| a dscore=3\
    \ |>\nIf you only need to remove brackets from one place, you can use str_replace\
    \ with regex like this:\n<code>\n$string = preg_replace('/\\[([^\\]]+)\\]/', '',\
    \ $string);\n</code>\n<|/ a tags=string,regex,php |>\n<| c |>\n+1 for the nice\
    \ regex. but this may fail when you have a bracket inside a bracket like [aaa]b[ccc]dd\
    \ - this one will result in \"bdd\"\n<|/ c |>\n<| a tags=string,regex,php dscore=2\
    \ |>\nA solution without regex:\n<code>\n$string = '[bracket 1] this is some text\
    \ with some [brackets]';\n\n$brackets = array('[]','<>');\n\n$string = preg_replace('/('.\
    \ implode('|', $brackets).')/','[\\\\1]',$string);\n</code>\n<|/ a |>\n<| c |>\n\
    If you don't want the brackets to be replaced when they are precede", "  $brackets\
    \ = preg_replace(\"(<)|\\(<|\\/<|>)|\\(>|<=|>=|>>)|\\(<=|>=|<|>)|\\/<|>|>>|\\\
    (>|>>=|>>|<<|\")\" ,\"\" ,$brackets);\n  if ($brackets == '<')\n    return false;\n\
    \  if ($brackets == '>')\n    return true;\n  if ($brackets == '<=')\n    return\
    \ true;\n  if ($brackets == '>=')\n    return true;\n  if ($brackets == '=')\n\
    \    return true;\n  if ($brackets == '<=')\n    return true;\n  if ($brackets\
    \ == '>=')\n    return true;\n  if ($brackets == '>')\n    return true;\n  if\
    \ ($brackets == '<')\n    return false;\n  return false;\n}", "  // get length\
    \ of brackets\n  $bracketsLength = (strlen($brackets) - 1);\n  // looping through\
    \ brackets\n  for ($i = 0; $i < $bracketsLength; $i++) {\n    // opening brackets\
    \ have a corresponding closing bracket\n    if ($brackets[$i] !== '<') {\n   \
    \   // not even one closing bracket exists\n      // so no opening bracket\n \
    \     return false;\n    }\n  }\n  // we have an opening bracket\n  return true;\n\
    }\n", "\treturn preg_match('/(?<=\\s)<+/', $brackets) === 0\n\t\t&& preg_match('/(?<=>)-+>/',\
    \ $brackets) === 0;\n}\n", "    for($i=0; $i<strlen($brackets); $i++) {\n    \
    \    if ($brackets[$i] == '<') {\n            $left = $brackets[$i];\n       \
    \     $right = $brackets[$i+1];\n            if ($left == \">\" && $right == \"\
    <\") {\n                $brackets = substr($brackets, 0, $i).substr($brackets,\
    \ strlen($brackets)-1);\n                $i++;\n            }\n        }\n   \
    \ }\n    return $brackets;\n}\n", "  // remove any whitespace.\n  $brackets =\
    \ preg_replace('/\\s+/', '', $brackets);\n\n  // remove all \"<>\"s.\n  $brackets\
    \ = preg_replace('/<+>/', '', $brackets);\n\n  // remove all \"<>\"s.\n  $brackets\
    \ = preg_replace('/<+>/', '', $brackets);\n\n  // remove all \"<>\"s.\n  $brackets\
    \ = preg_replace('/<+>/', '', $brackets);\n\n  // remove all \"<>\"s.\n  $brackets\
    \ = preg_replace('/<+>/', '', $brackets);\n\n  // remove all \"<>\"s.\n  $brackets\
    \ = preg_replace('/<+>/', '', $brackets);\n\n  // remove all \"<>\"s.\n  $brackets\
    \ = preg_replace('/<+>/', '', $brackets);\n\n  // remove all \"<>\"s.\n  $brackets\
    \ = preg_replace('/<+>/', '', $brackets);\n\n  // remove all \"<>\"s.\n  $brackets\
    \ = preg_replace('/<+>/', '', $brackets);\n\n  // remove all \"<>\"s.\n  $brackets\
    \ = preg_replace('/<+>/', '', $brackets);\n\n  // remove all \"<>\"s.\n  $brackets\
    \ = preg_replace('/<+>/', '', $brackets);\n\n  // remove all \"<>\"s.\n  $brackets\
    \ = preg_replace('/<+>/', '', $brackets);\n\n  // remove all \"<>\"s.\n  $brackets\
    \ = preg_replace('/<+>/', '', $brackets);\n\n  // remove all \"<>\"s.\n  $brackets\
    \ = preg_replace('/<+>/', '', $brackets);\n\n  // remove all \"<>\"s.\n  $brackets\
    \ = preg_replace('/<+>/', '', $brackets);\n\n  // remove all \"<>\"s.\n  $brackets\
    \ = preg_replace('/<+>/', '', $brackets);\n\n  // remove all \"<>\"s.\n  $brackets\
    \ = preg_replace('/<+>/', '', $brackets);\n\n  // remove all \"<>\"s.\n  $brackets\
    \ = preg_replace('/<+>/', '', $brackets);\n\n  // remove all \"<>\"s.\n  $brackets\
    \ = preg_replace('/<+>/', '', $brackets);\n\n  // remove all \"<>\"s.\n  $brackets\
    \ = preg_replace('/<+>/', '', $brackets);\n\n  // remove all \"<>\"s.\n  $brackets\
    \ = preg_replace('/<+>/', '', $brackets);\n\n  // remove all \"<>\"s.\n  $brackets\
    \ = preg_replace('/<+>/', '', $brackets);\n\n  // remove all \"<>\"s.\n  $brackets\
    \ = preg_replace('/<+>/', '', $brackets);\n\n  // remove all \"<>\"s.\n  $", " \
    \ foreach (str_split($brackets) as $char) {\n    if (!isset($brackets[$char]))\
    \ {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Inserts the\
    \ given text at the correct position to create a valid tag\n * from scratch.\n\
    \ *\n * @param string $text the tag to create\n * @return string a valid tag\n\
    \ */", "    // remove white space and split into array\n    $brackets = str_replace('\
    \ ', '', $brackets);\n    $brackets = explode(\"<<\", $brackets);\n    $brackets\
    \ = explode(\">>\", $brackets);\n\n    // loop through array\n    foreach ($brackets\
    \ as $pair) {\n        // test if pair matches another in array\n        foreach\
    \ ($brackets as $other_pair) {\n            // return true if each pair match\
    \ other\n            if ($pair == $other_pair) {\n                return false;\n\
    \            }\n        }\n    }\n    // return true if each pair matches one\
    \ another\n    return true;\n}\n</code>\n<|/ a |>\n<| c |>\nThanks for your time!\
    \ It didn't work though.\n\nI used `<<>>` as input and it still returned false.\
    \ Thanks for the comment though.\n<|/ c |>\n<| a tags=regex,php |>\n<code>\n$string\
    \ = \"<<>>\";\n\nif (preg_match('/<<.+>>/', $string, $match)) {\n   echo $match[0];\
    \ \n} else {\n   echo \"NOT MATCHED\";\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\nIn order to check if a string contains a pattern, you can use preg_match\
    \ function.\n<code>\n<?php\n\n$string = \"<<>>\";\n\nif (preg_match('/<<.+>>/',\
    \ $string)) {\n   echo \"Matched\";\n} else {\n   echo \"NOT MATCHED\";\n}\n</code>\n\
    <|/ a tags=regex,php |>\n<| c |>\nThanks! I forgot to mention I used `<<>>` as\
    \ input and it's still returning false for me. Thanks for the help though.\n<|/\
    \ c |>\n<| a dscore=0 tags=regex,php |>\nYou can use:\n<code>\npreg_match_all('!<<(.*?)>>!',\
    \ $string, $matches);\n</code>\nand $matches will be an array with all matches.\n\
    <|/ a |>\n<| c |>\nThe `m` modifier should be removed.\n<|/ c |>\n<| c |>\nThanks,\
    \ fixed it ;)\n<|/ c |>\n<| a |>\nIn addition to the other answers here, here's\
    \ a regex that checks if a string contains two specific patterns:\n<code>\n<?php\n\
    \n$string = \"<<>>\";\n\nif (preg_match('/<<.+>>/', $string)) {\n   echo \"Matched\"\
    ;\n} else {\n   echo \"NOT MATCHED\";\n}\n</code>\nYou can test it here\n<|/ a\
    \ tags=regex,php dscore=0 |>\n<| c |>\n", "    $len = strlen($brackets);\n   \
    \ if ($len < 1) {\n        return false;\n    }\n    $stack = array();\n    $brackets_used\
    \ = array();\n    $brackets_used = array('>');\n    for ($i = 0; $i < $len; $i++)\
    \ {\n        $c = $brackets[$i];\n        if ($c == '>') {\n            $stack_top\
    \ = array_pop($stack);\n            $stack[count($stack) - 1] .= $c;\n       \
    \     if ($stack_top != '') {\n                $stack[count($stack) - 1] .= $stack_top;\n\
    \            }\n        } else {\n            $stack[] = $c;\n        }\n    \
    \    if (!in_array($c, $brackets_used)) {\n            $brackets_used[] = $c;\n\
    \        }\n    }\n    if ($stack != array()) {\n        return false;\n    }\n\
    \    return true;\n}", "  $brackets_array = explode(\"<\", $brackets);\n  foreach($brackets_array\
    \ as &$b) {\n    if($b !== \"<\") return false;\n  }\n  return true;\n}", "  return\
    \ !preg_match(\"/<[^<>]+>$/\", $brackets);\n}\n", "  return strlen($brackets)\
    \ == str_replace(array(\"<\",\">\"),array(\"<\",\">\"),$brackets);\n}\n", "  foreach\
    \ ($brackets as $k => $b) {\n    // \"<\" is not a closing bracket, so we need\
    \ to add an opening bracket.\n    if ($k >= 0 && $k < strlen($brackets) - 1 &&\
    \ $brackets[$k + 1] === '<') {\n      $brackets[$k + 1] = \"<\";\n    }\n    //\
    \ \">\" is not a opening bracket, so we need to remove an opening bracket.\n \
    \   if ($k >= 0 && $k >= strlen($brackets) - 1 && $brackets[$k + 1] === \">\"\
    ) {\n      $brackets[$k + 1] = \"\";\n    }\n  }\n  return $brackets[0] === $brackets[strlen($brackets)\
    \ - 1];\n}\n", "  $open_brackets = preg_split('/[\\<\\>]/', $brackets);\n  $closed_brackets\
    \ = preg_split('/[\\<\\>]/', $brackets);\n  foreach ($open_brackets as $key =>\
    \ $open) {\n    $match = false;\n    foreach ($closed_brackets as $close_key =>\
    \ $close) {\n      if ($open == $close ) {\n        $match = true;\n      }\n\
    \    }\n    if (!$match) {\n      return false;\n    }\n  }\n  return true;\n\
    }\n", "    $count = 0;\n    $brackets = preg_replace(\"/<[!]+/\", \"<\", $brackets);\n\
    \    while(strpos($brackets, \">\") !== false) {\n        $brackets = str_replace(\"\
    >\", \"\", $brackets);\n        $brackets = str_replace(\"<\", \"\", $brackets);\n\
    \        $count++;\n    }\n    return ($count == strlen($brackets));\n}\n</code>\n\
    <|/ a |>\n<| c |>\nI'm having difficulty figuring out how to incorporate that\
    \ into my code. I'm very new to PHP and I apologize if I'm missing the obvious.\n\
    <|/ c |>\n<| c |>\nI'm sorry, I'm afraid I'm just not getting it.\n<|/ c |>\n\
    <| c |>\nNo problem. I updated my answer with some code. I hope it helps.\n<|/\
    \ c |>\n<| c |>\nThis is great! I really appreciate it!\n<|/ c |>\n<| a tags=function,arrays,php,validation\
    \ dscore=0 |>\nYou can use str_replace to replace the > and < characters with\
    \ a space, then use trim to remove trailing spaces, and finally check to see if\
    \ there are any spaces:\n<code>\nif ( !preg_match( '~^[ ]*$~', $str ) ){\n   \
    \ // invalid\n}\n</code>\nThe above code checks for any number of spaces at the\
    \ start of the string. The ^ and $ symbols denote the beginning and end of the\
    \ string. The [ ] means any number of spaces.\nThe ^ symbol will make the match\
    \ match anything that does not start with the start of the string. The * symbol\
    \ will match 0 or more characters. The $ symbol will make the match match anything\
    \ that does not end with the end of the string.\n<|/ a |>\n<| a |>\nA more general\
    \ solution:\n<code>", "    $brackets = str_replace(\"<<\", \"<\", $brackets);\n\
    \    $brackets = str_replace(\">>\", \">\", $brackets);\n    return preg_match(\"\
    /<([^>]+)>$/\", $brackets) === 1;\n}\n</code>\n<|/ a tags=recursion,php,arrays\
    \ |>\n<| c |>\nThis works when there's only one opening and closing bracket, but\
    \ it fails when the first opening bracket is followed by an opening bracket of\
    \ the same type (opening bracket)\n<|/ c |>\n<| c |>\n, fixed it by adding a check\
    \ for that case.\n<|/ c |>\n<| c |>\nThank you, this is a very elegant solution.\
    \ I would like to learn more about PHP, so would you mind explaining how this\
    \ function works?\n<|/ c |>\n<| c |>\nThis doesn't work if the brackets aren't\
    \ pairs, it returns true when the brackets are pairs, false when they're not.\
    \ e.g. `<<<` is valid, but `<<` is invalid.\n<|/ c |>\n<| a tags=recursion,php,arrays\
    \ dscore=1 |>\nHere is my solution. Hope it helps.\n<code>\n<?php\n\n$string =\
    \ <<<EOT\nThis is an example of a simple string that contains:\na lot of text\
    \ that needs brackets\nthat need to be grouped to make the code\nmore readable\n\
    and easier to edit later\nEOT;\n\n$string = \"This is an example of a simple string\
    \ that contains:\na lot of text that needs brackets\nthat need to be grouped to\
    \ make the code\nmore readable\nand easier to edit later\";\n\n$openBracket =\
    \ '<>';\n$closeBracket = '</>';\n\n$openBracket = str_replace(array('<','>'),\
    \ array('<','>'), $openBracket);\n$closeBracket = str_replace(array('<','>'),\
    \ array('<','>'), $closeBracket);\n\n$newString = preg_replace_callback('/('.$openBracket.')/',\
    \ function($matches) use ($closeBracket) {\n    return substr($matches[0], 0,\
    \ -1 * strlen($closeBracket));\n}, $string);\n\necho $newString;\n</code>\n<|/\
    \ a |>\n<| c |>\nThe last line is not working properly, it outputs \"<<<\" instead\
    \ of \"<<<\". Anyway, I appreciate your answer and will use it for the future.\
    \ Thanks.\n<|/ c |>\n<| a tags=recursion,php,arrays |>\nI used a recursive function\
    \ as I like having control on when my function will end (so I used a ", "\t$brackets\
    \ = str_replace(array('>', '<', '>', '>', '>', '>'), array('>', '<', '>', '>',\
    \ '>', '>'), $brackets);\n\t// return false if the brackets string is empty\n\t\
    if ($brackets === '') {\n\t\treturn false;\n\t}\n\t$bracketsArray = explode('<',\
    \ $brackets);\n\t// return true if every opening bracket has a corresponding closing\
    \ bracket.\n\tforeach ($bracketsArray as $i => $bracket) {\n\t\t$leftBracket =\
    \ $bracketsArray[$i - 1];\n\t\t$rightBracket = $bracketsArray[$i + 1];\n\t\tif\
    \ ($leftBracket !== '<' || $rightBracket !== '>') {\n\t\t\treturn false;\n\t\t\
    }\n\t}\n\treturn true;\n}", "    return preg_match_all('/<+/', $brackets)!==0;\n\
    }\n", "    // Count how many times a bracket appears.\n    $openBrackets = substr_count($brackets,\
    \ '<');\n    $closeBrackets = substr_count($brackets, '>');\n    if ($openBrackets\
    \ == $closeBrackets) {\n        // If brackets are balanced, a closed bracket\
    \ is never followed by an opening bracket.\n        return false;\n    }\n   \
    \ // If there are at least as many opening brackets as closing brackets, brackets\
    \ are not balanced.\n    return ($openBrackets > $closeBrackets);\n}", "  return\
    \ !preg_match('/<[^>]*>[^<]*<[^>]*>/', $brackets);\n}\n", "  if ($brackets ===\
    \ \"<\") {\n    return true;\n  }\n  if ($brackets === \"<>\") {\n    return false;\n\
    \  }\n  if ($brackets === \"<<><>>\") {\n    return true;\n  }\n  if ($brackets\
    \ === \"><<>\") {\n    return false;\n  }\n}", "    $brackets_arr = explode(\"\
    <\", $brackets);\n    $correct = false;\n    foreach ($brackets_arr as $key =>\
    \ $value) {\n        if ($value == \">\") {\n            $brackets_arr[$key] =\
    \ $value;\n            $correct = true;\n        }\n    }\n    return $correct;\n\
    }\n", "\tforeach (explode(\"<\", $brackets) as $opening) {\n\t\tforeach (explode(\"\
    >\", $brackets) as $closing) {\n\t\t\tif ($opening != $closing) return false;\n\
    \t\t}\n\t}\n\treturn true;\n}\n", "  $matches = preg_match_all(\"/<(.+?)(?>[^<>]+)?>/g\"\
    , $brackets, $matches);\n  return $matches[1] == array_unique($matches[1]);\n\
    }\n", "    // YOUR CODE HERE\n    return preg_match(\"/<([^<]+)>/\", $brackets,\
    \ $result) !== FALSE && preg_match(\"/<\\/([^<]+)>/\", $brackets, $result) !==\
    \ FALSE;\n}\n</code>\n<|/ a tags=php,regex,validation |>\n<| c |>\n+1. Although\
    \ this doesn't answer his question, your answer is more thorough than mine, so\
    \ I upvoted it :)\n<|/ c |>\n<| c |>\nThanks, it's really good! But if i use it\
    \ in my project, it returns false. Why? If i use another example (for example\
    \ <aaa>bbb<ccc>ddd</aaa>) it works right!\n<|/ c |>\n<| c |>\n- It works for me\
    \ in PHP's interactive shell. Are you sure you're passing it in correctly? Are\
    \ you sure you're giving it a match?\n<|/ c |>\n<| c |>\nYes, i passed it correctly.\
    \ My code (http://pastebin.com/m5uR5gYQ) returns false. Why?\n<|/ c |>\n<| c |>\n\
    - `return preg_match(\"/^<([^<]+)>$/\", $brackets, $result) !== FALSE;` is an\
    \ easier way to do this. Can you post your entire function? It may have something\
    \ else you're doing wrong.\n<|/ c |>\n<| a |>\nUsing a regexp to validate XML\
    \ is asking for trouble.  Use a parser to parse the XML and then validate it.\n\
    If you must use a regexp, here's one that might work for you:\n<code>\n<?php\n\
    \n$data = <<< EOF\n<books>\n  <book name=\"book1\">\n    <chapter>\n      <para>\n\
    \        <para>\n          This is an example text\n        </para>\n      </para>\n\
    \    </chapter>\n  </book>\n  <book name=\"book2\">\n    <chapter>\n      <para>\n\
    \        <para>\n          This is an example text\n        </para>\n      </para>\n\
    \    </chapter>\n  </book>\n</books>\nEOF;\n\n$xml = simplexml_load_string($data);\n",
  "    $opening_brackets = array('<', '>');\n    $closing_brackets = array('>', '<');\n\
    \    foreach ($brackets as $bracket => $bracket_string) {\n        if (!in_array($bracket,\
    \ $opening_brackets)) {\n            return false;\n        }\n        foreach\
    \ ($opening_brackets as $key => $opening_bracket) {\n            if ($bracket_string\
    \ == $opening_bracket) {\n                if ($key < count($closing_brackets)\
    \ - 1) {\n                    if ($closing_brackets[$key + 1] != $bracket) {\n\
    \                        return false;\n                    }\n              \
    \  }\n            }\n        }\n    }\n    return true;\n}\n\n/**\n * Return an\
    \ array with all the tags in the given string.\n * @param string $string The string\
    \ to parse for tags.\n * @param bool $use_callback\n * @return array\n */", " \
    \ $result = true;\n  for ($i = 0; $i < strlen($brackets); $i++) {\n    if (!is_right_bracket($brackets,\
    \ $i)) {\n      $result = false;\n      break;\n    }\n  }\n  return $result;\n\
    }", "  foreach (preg_split(\"/[\\<\\>]\", $brackets) as $bracket) {\n    if (substr($bracket,\
    \ 0, 1) !== \"<\" && substr($bracket, 0, 1) !== \">\") {\n      return false;\n\
    \    }\n    if (substr($bracket, -1, 1) !== \"<\" && substr($bracket, -1, 1) !==\
    \ \">\") {\n      return false;\n    }\n  }\n  return true;\n}\n", "  $open_brackets\
    \ = preg_split('/\\s*<\\s*/', $brackets);\n  $closed_brackets = preg_split('/\\\
    s*>\\s*/', $brackets);\n\n  return count($open_brackets) - 1 == count($closed_brackets);\n\
    }", "  $open_brackets = explode(\"<<\", $brackets);\n  foreach ($open_brackets\
    \ as &$open_bracket) {\n    if ($open_bracket == \">\") {\n      $open_bracket\
    \ = \"<\";\n    }\n  }\n  unset($open_bracket);\n  $closed_brackets = explode(\"\
    >>\", $brackets);\n  foreach ($closed_brackets as &$closed_bracket) {\n    if\
    \ ($closed_bracket == \"<\") {\n      $closed_bracket = \">\";\n    }\n  }\n \
    \ unset($closed_bracket);\n  return count(array_unique($open_brackets)) == count($open_brackets);\n\
    }\n", "    $stack = array();\n    $in_quotes = false;\n    for($i = 0, $len =\
    \ strlen($brackets); $i < $len; $i++) {\n        $letter = $brackets[$i];\n  \
    \      // If we're in a quoted string, look for the next letter.\n        if ($in_quotes)\
    \ {\n            if ($letter == '\"' || $letter == \"'\") {\n                if\
    \ ($i+1 < $len && $brackets[$i+1] == $letter) {\n                    $stack[]\
    \ = $letter;\n                    $i++;\n                    $len--;\n       \
    \         }\n                // If all we've seen are quotes, we're done.\n  \
    \              if ($len == 0) {\n                    return $stack == array('\"\
    ');\n                }\n            }\n        }\n\n        // If we're not in\
    \ a quoted string, look for a bracket.\n        if (!$in_quotes && $letter !=\
    \ '<' && $letter != '>') {\n            if ($letter == '(' || $letter == '[' ||\
    \ $letter == '{') {\n                $stack[] = $letter;\n            } else {\n\
    \                if ($stack) {\n                    // Make sure we're actually\
    \ in a bracket.\n                    if ($stack[count($stack)-1] != $letter) {\n\
    \                        return false;\n                    }\n              \
    \      array_pop($stack);\n                } else {\n                    return\
    \ false;\n                }\n            }\n        }\n    }\n}\n", "\t$brackets\
    \ = explode(\"<\", $brackets);\n\tforeach ($brackets as &$bracket) {\n\t\t$bracket\
    \ = trim($bracket);\n\t}\n\t$brackets = array_unique($brackets);\n\treturn count($brackets)\
    \ == 2;\n}\n", "  global $open_brackets, $closed_brackets;\n\n  // Create an array\
    \ of all brackets.\n  $brackets = explode(\"<<\", $brackets);\n  $open_brackets\
    \ = array_slice($brackets, 0, count($brackets)-2);\n  $closed_brackets = array_slice($brackets,\
    \ count($brackets)-2);\n\n  $result = array();\n  foreach ($open_brackets as $open)\
    \ {\n    foreach ($closed_brackets as $closed) {\n      $result[] = $open . $closed\
    \ . \"</>\";\n    }\n  }\n\n  return empty($result);\n}\n</code>\n<|/ a |>\n<|\
    \ c |>\nI ended up using this solution. I actually ended up using the first solution\
    \ because I didn't have much time to play with it properly, and the next problem\
    \ I ran into was that I had to deal with multiple HTML tags per line. By using\
    \ the second solution, I was able to easily clean up the HTML code from the database\
    \ and insert it into a textarea for use with the WYSIWYG editor in my Rails app.\
    \ Thank you so much for the help!\n<|/ c |>\n<| a dscore=0 |>\nAnother approach\
    \ is to do regex replacement on the input that has been entered.\nFor example\
    \ (using PHP):\n<code>\n$input = preg_replace(\"/<\\/?\\w+[^>]*>/i\", \"\", $input);\n\
    </code>\nThis will remove anything in any tag, e.g. <b> or <i>, etc.\nI use this\
    \ method and it works pretty well.\n<|/ a tags=php,jquery,wysiwyg,javascript,html\
    \ |>\n<| a tags=php,jquery,wysiwyg,javascript,html |>\nI went through this exercise\
    \ a while back, even though I never did it because I didn't know what my target\
    \ environment was. Unfortunately I ended up using an HTML markup editor like CKEditor\
    \ to do the heavy lifting for me, which was a pretty decent solution. I ended\
    \ up with something like this:\n<code>\n<script type=\"text/javascript\">\n  \
    \  function check() {\n        var content = $(\"#content\").val();\n        alert(\"\
    Content is \" + content);\n        if (checkValid(content)) {\n            alert(\"\
    OK!\");\n        }\n        else {\n            alert(\"Not OK!\");\n        }\n\
    \    }\n\n    function checkValid(content) {\n        var valid = true;\n\n  \
    \      // Only allow HTML tags\n        var tags = /<\\/?[^>]*>/gi;\n        var\
    \ tagsRegExp = new RegExp(tags);\n        var validHTML = content.match(tagsRegExp);\n\
    \        valid = valid && validHTML;\n\n        // Only allow HTML attributes\n\
    \        var attributes = /^", "  return preg_match_all(\"~(^<+|\\G<+)~\",$brackets,$matches)\
    \ && preg_match_all(\"~(^>+|\\G>+)~\",$brackets,$matches);\n}\n", "  $len = strlen($brackets);\n\
    \  for ($i = 0; $i < $len; ++$i) {\n    $char = substr($brackets, $i, 1);\n  \
    \  if (!is_numeric($char)) {\n      if ($char === '<') {\n        $next = $len\
    \ - $i;\n        $next = $next > 0 ? $brackets[$next] : '';\n        if ($next\
    \ !== '>') {\n          return false;\n        }\n      }\n    }\n  }\n  return\
    \ true;\n}\n", "    $brackets = explode(\" \", $brackets);\n    foreach ($brackets\
    \ as $bracket ) {\n        if($bracket == \">\" || $bracket == \"<\" || $bracket\
    \ == \"()\"){\n            return false;\n        }\n    }\n    return true;\n\
    }\n", "    $bracket_stack = array();\n    $open_count = array();\n    for ($i\
    \ = 0; $i < strlen($brackets); $i++) {\n        if ($brackets[$i] === '<') {\n\
    \            $bracket_stack[] = $brackets[$i];\n            $open_count[] = 1;\n\
    \        } else {\n            $open_count[] -= 1;\n            if ($open_count[]\
    \ === 0) {\n                $close_i = array_pop($bracket_stack);\n          \
    \      if ($brackets[$i] !== $close_i) {\n                    return false;\n\
    \                }\n            }\n        }\n    }\n    return true;\n}\n</code>\n\
    <|/ a tags=php,string |>\n<| c |>\nThat is the answer I've been looking for! Thanks\
    \ a lot!\n<|/ c |>\n<| c |>\nHe did not say \"only in PHP\". He said \"only in\
    \ any language\".\n<|/ c |>\n<| c |>\nYes that's right. I only need it for PHP.\
    \ It was just for learning purposes. I only need to learn the PHP syntax (I'm\
    \ not a PHP-master), so I do not need to write code for PHP. That's why I used\
    \ \"only in PHP\" instead of \"only in PHP\"\n<|/ c |>\n<| c |>\n: You're absolutely\
    \ right, but OP said \"in any language\", so I thought I'd point out something\
    \ that may have helped him figure out how to solve it in PHP or whatever other\
    \ language he might want to use.\n<|/ c |>\n<| c |>\n: What does \"only in PHP\"\
    \ mean?\n<|/ c |>\n<| a dscore=2 tags=php,string |>\nJust to add my two cents\
    \ here for a different approach that doesn't use stacks or recursion. Instead\
    \ it just keeps track of the current and last character (as well as the position)\
    \ and checks if these two are different.\n<code>\n<?php\n\n$string = '<<><>>';\n\
    \n$count = 1;\n\nfor ($i = 0; $i < strlen($string); $i++) {\n\n    if ($string[$i]\
    \ === '<') {\n        $count++;\n    } else {\n        $count--;\n    }\n\n  \
    \  if ($count === 0) {\n        $last_char = $string[$i - 1];\n        break;\n\
    \    }\n\n}\n\nif ($last_char === '<') {\n    echo \"True\";\n} else {\n    echo\
    \ \"False\";\n}\n", "  // Initialize a stack for our search.\n  $stack = array();\n\
    \  // Push each opening bracket onto the stack.\n  array_push($stack, \"<\");\n\
    \  // Continue looping while there are brackets still to process.\n  while ($stack->count()\
    \ != 0) {\n    // Pop the top element off the stack.\n    $top = array_pop($stack);\n\
    \    // If it's not a closing bracket, continue to the next bracket.\n    if ($top\
    \ != \">\") {\n      // Otherwise, the stack will contain the closing bracket,\
    \ so we're\n      // done.\n      $stack->push($top);\n      continue;\n    }\n\
    \    // Otherwise, there are still brackets left on the stack, so we're\n    //\
    \ done.\n    return false;\n  }\n  // If we made it this far, there's not any\
    \ brackets left on the stack,\n  // so the bracketing is correct.\n  return true;\n\
    }", "  $brackets = explode(\"<<>>\", $brackets);\n  $opening_brackets = array();\n\
    \  $closing_brackets = array();\n  foreach ($brackets as $b) {\n    // >>> b =\
    \ \"<\"\n    // >>> < is the first character of $brackets\n    // >>> \"<\" is\
    \ the first character of $opening_brackets\n    // >>> \"<\" is the last character\
    \ of $opening_brackets\n    // >>> the last character in $opening_brackets is\
    \ not the last character of $closing_brackets\n    // >>> the last character in\
    \ $closing_brackets is not the first character of $opening_brackets\n    // >>>\
    \ the last character in $opening_brackets is different than the first character\
    \ in $closing_brackets\n    if ($b[0] != \"<\") {\n      if (empty($opening_brackets))\
    \ {\n        // >>> the opening brackets are not empty but do not start with \"\
    <\"\n        return false;\n      }\n      $opening_brackets = array_pop($opening_brackets);\n\
    \      if ($opening_brackets[0] != \"<\") {\n        // >>> the opening brackets\
    \ do not start with \"<\"\n        return false;\n      }\n      $opening_brackets\
    \ = substr($opening_brackets, 1);\n    }\n    if ($b != $opening_brackets) {\n\
    \      // >>> $b is not equal to $opening_brackets\n      return false;\n    }\n\
    \    if ($b[strlen($b) - 1] != \">\") {\n      // >>> $b is not equal to $opening_brackets\n\
    \      return false;\n    }\n    $closing_brackets[] = $b;\n  }\n  foreach ($closing_brackets\
    \ as $b) {\n    if ($b[0] != \"<\") {\n      // >>> $b is not equal to $opening_brackets\n\
    \      return false;\n    }\n  }\n  return true;\n}\n", "  for ($i = 0; $i < strlen($brackets);\
    \ $i++) {\n    if (!($brackets[$i] === \"<\" && $brackets[$i+1] === \">\")) {\n\
    \      return false;\n    }\n  }\n  return true;\n}\n", "    $brackets = preg_replace('/[<>]/',\
    \ '', $brackets);\n    $brackets = explode(\"<<\", $brackets);\n    $brackets\
    \ = preg_replace('/<</', '', $brackets);\n    $brackets = preg_replace('/>>/',\
    \ '', $brackets);\n    $brackets = explode(\">>\", $brackets);\n    return count(array_diff($brackets,\
    \ $brackets)) == 0;\n}\n", "    $stack = array();\n    $open_brackets = array();\n\
    \    $closed_brackets = array();\n    for ($i = 0; $i < strlen($brackets); $i++)\
    \ {\n        switch ($brackets[$i]) {\n            case \"<\":\n             \
    \   if (!empty($open_brackets)) {\n                    $stack[] = $open_brackets;\n\
    \                    $open_brackets = array();\n                }\n          \
    \      $closed_brackets[] = $brackets[$i];\n                break;\n         \
    \   case \">\":\n                $open_brackets[] = $brackets[$i];\n         \
    \       break;\n            case \"\":\n                // empty string is treated\
    \ as having no brackets at all.\n                break;\n            default:\n\
    \                // anything else is a syntax error since brackets have to match\
    \ exactly.\n                return false;\n        }\n    }\n    if (!empty($open_brackets))\
    \ {\n        $stack[] = $open_brackets;\n    }\n\n    // All brackets are closed\
    \ on the last stack item, so the last item in the array will be empty.\n    //\
    \ The stack will look like this after the loop:\n    // array(\n    //     array(\n\
    \    //         \"<\",\n    //         \"\",\n    //         \"\",\n    //   \
    \  ),\n    //     array(\n    //         \"<<\",\n    //         \"\",\n    //\
    \         \"\",\n    //     ),\n    //     array(\n    //         \"<\",\n   \
    \ //         \"<\",\n    //         \"\",\n    //     ),\n    //     array(\n\
    \    //         \"<\",\n    //         \"<>\",\n    //         \"\",\n    // \
    \    ),\n    // )\n    // We have to pop everything from the stack and push them\
    \ back into brackets.\n    $stack = array_pop($stack);\n    $brackets = \"\";\n\
    \    foreach ($stack as $open_bracket) {\n        foreach ($open_bracket as $i\
    \ => $char) {\n            if ($char != \"\") {\n                $brackets .=\
    \ $char;\n            } else {\n                $brackets .= array_pop($closed_brackets);\n\
    \            }\n        }\n    }\n    return $brackets;\n}\n</code>\n<|/ a |>\n\
    <| c |>\nYeah this is what i was thinking of doing, I was hoping there might be\
    \ a built in php function for this but i guess not.\n<|/ c |>\n<| c |>\nYeah,\
    \ but that would make it pretty much useless. You'd need to use some kind of state\
    \ machine in PHP anyway to account for nested brackets.\n<|/ c |>\n<| c |>\nI\
    \ don't think it can be done without using some sort of state machine. At least\
    \ not without creating an infinite loop. At least not without creating a PHP ",
  "  return $brackets !== \"<\" && $brackets !== \">\" && $brackets !== \"<>\";\n\
    }\n", "\t$opening_brackets = preg_split('/<|>/', $brackets);\n\tforeach ($opening_brackets\
    \ as $b) {\n\t\t$closing_brackets[$b] = $b;\n\t}\n\tforeach (array_keys($closing_brackets)\
    \ as $b) {\n\t\tif ($b !== $b) {\n\t\t\tunset($closing_brackets[$b]);\n\t\t}\n\
    \t}\n\t$closed = array_keys($closing_brackets);\n\treturn $closed === array_keys($opening_brackets);\n\
    }\n", "  $open = strpos($brackets, \"<\");\n  $close = strpos($brackets, \">\"\
    );\n  return ($open !== $close);\n}\n", "  // Write your code here.\n  $brackets\
    \ = preg_replace('/<|>/', '', $brackets);\n  $opening_brackets = array();\n  $closing_brackets\
    \ = array();\n  foreach ($brackets as $char) {\n    $opening_brackets[$char] =\
    \ true;\n  }\n  for ($i = 1; $i < strlen($brackets); $i++) {\n    $char = substr($brackets,\
    \ $i, 1);\n    if (isset($opening_brackets[$char])) {\n      $opening_brackets[$char]\
    \ = false;\n    }\n  }\n  foreach ($opening_brackets as $char => $value) {\n \
    \   $closing_brackets[$char] = true;\n  }\n  foreach ($closing_brackets as $char\
    \ => $value) {\n    $opening_brackets[$char] = false;\n  }\n  foreach ($opening_brackets\
    \ as $char => $value) {\n    if ($value !== true) {\n      return false;\n   \
    \ }\n  }\n  return true;\n}\n</code>\n<|/ a dscore=1 tags=php,arrays,function\
    \ |>\n<| a dscore=1 tags=php,arrays,function |>\nI have tried many approaches\
    \ above to solve this problem but no one worked for me , So i did this and it's\
    \ working 100% for me \n<code>", "  if($brackets == '')\n    return false;\n \
    \ $open = preg_match_all('/<+/', $brackets, $matches);\n  if($open == 0)\n   \
    \ return false;\n\n  $close = preg_match_all('/>+/', $brackets, $matches);\n \
    \ if($close == 0)\n    return false;\n\n  return ($open + $close) == count($matches[0]);\n\
    }\n", "    $open = array();\n    $close = array();\n    $inTag = false;\n    for\
    \ ($i = 0; $i < strlen($brackets); $i++) {\n        if ($brackets[$i] == \"<\"\
    ) {\n            if ($inTag) {\n                $close[] = $i;\n            }\
    \ else {\n                $open[] = $i;\n            }\n        } else if ($brackets[$i]\
    \ == \">\") {\n            if (!$inTag) {\n                $open[] = $i;\n   \
    \         }\n        } else {\n            if (!$inTag) {\n                $inTag\
    \ = true;\n            }\n        }\n    }\n    $open = array_reverse($open);\n\
    \    return array_sum($open) == count($open);\n}\n</code>\n<|/ a |>\n<| a |>\n\
    This regex will match a bracketed expression:\n<code>\n/([^\\(\\)]{2,})(?:\\(|\\\
    s)([^\\(\\)]{2,})/g\n</code>\nExplanation:\n<code>\n([^\\(\\)]{2,})    match a\
    \ group of 2 or more characters that are neither parentheses or brackets\n(?:\
    \             start of a non-capturing group\n  \\(            match a left parenthesis\n\
    \  |             or\n  \\s            match whitespace\n)               end of\
    \ non-capturing group\n([^\\(\\)]{2,})   match a group of 2 or more characters\
    \ that are neither parentheses or brackets\n</code>\n<|/ a tags=php,regex,brackets\
    \ dscore=1 |>\n<| c |>\nThis doesn't match any brackets in strings such as `foo\
    \ (bar)`, just two and only two (unbalanced) parentheses.\n<|/ c |>\n<| c |>\n\
    , that's true. Fixed now.\n<|/ c |>\n<| c |>\nThis answer fails on `foo (bar foo)`.\
    \ It also fails for `foo (bar foo) (baz qux)`\n<|/ c |>\n<| c |>\nIt fails if\
    \ there are uneven number of `(` & `)` pair.\n<|/ c |>\n<| c |>\n, I was just\
    \ about to post an answer which does that. :-)\n<|/ c |>\n<| a tags=php,regex,brackets\
    \ |>\nA simple way would be to use preg_replace_callback:\n<code>\n<?php\n$input\
    \ = '[foo] bar [foo] baz (qux) [foo] boo [foo] moo';\n$output = preg_replace_callback(\n\
    \    '/\\[([^\\]]+)\\]/',\n    function($match) {\n        return $match[1] .\
    \ preg_replace_callback(\n            '/\\(([^\\)]", "    $brackets = explode(\"\
    <<\", $brackets);\n    $brackets = explode(\">>\", $brackets);\n    return count($brackets)\
    \ == count(array_filter(\n        $brackets,\n        function($x) { return $x\
    \ !== \"<\"; }\n    ));\n}\n</code>\n<|/ a |>\n<| c |>\nThis looks interesting,\
    \ but I'm having a hard time understanding what it does. It seems more complicated\
    \ than I expected\n<|/ c |>\n<| c |>\nThe algorithm is simple: for each closing\
    \ bracket (from left to right), find the opening bracket (from right to left)\
    \ whose two sides are the same (that is, remove them if they are), then check\
    \ if the left side is empty or the right side is empty.\n<|/ c |>\n<| c |>\nWhat\
    \ about this one: https://eval.in/558526. It returns true for that string.\n<|/\
    \ c |>\n<| c |>\nI see what you are talking about.  I edited my answer to include\
    \ a solution that only looks at pairs of brackets, and it doesn't use regex.\n\
    <|/ c |>\n<| a tags=php,algorithm dscore=3 |>\nFor a general solution, I would\
    \ use regexes. The function below checks whether the input $string is correct\
    \ (based on your comments to other answers).\n<code>\n/**\n * string $string\n\
    \ * bool\n */", "    $brackets = str_replace(array('<', '>'), array('&lt;', '&gt;'),\
    \ $brackets);\n    $brackets_count = count($brackets);\n    for ($i = 0; $i <\
    \ $brackets_count; $i++) {\n        if ($brackets[$i] === \"<\" && substr($brackets,\
    \ $i, $i + 1) === \">\") {\n            $brackets = substr_replace($brackets,\
    \ \"<\", $i, 1);\n            $brackets_count--;\n        }\n    }\n    return\
    \ $brackets_count % 2 === 0;\n}\n\n/**\n * Converts UTF-8 strings to HTML entities.\
    \ All other characters are\n * left unchanged.\n *\n * $title is expected to be\
    \ UTF-8.\n */", "  $brackets = explode(\" \", $brackets);\n  foreach ($brackets\
    \ as $key => $value) {\n    if (strlen($value) > 1) {\n      $open_bracket = $value;\n\
    \      $open_brackets = explode(\"<\", $open_bracket);\n      foreach ($open_brackets\
    \ as $key => $value) {\n        if ($value != $open_brackets[$key + 1]) {\n  \
    \        return false;\n        }\n      }\n      $close_bracket = $open_brackets[count($open_brackets)\
    \ - 1];\n      $close_brackets = explode(\">\", $close_bracket);\n      foreach\
    \ ($close_brackets as $key => $value) {\n        if ($value != $close_brackets[$key\
    \ + 1]) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n\
    }\n</code>\n<|/ a dscore=2 tags=python,php,regex |>\n<| c |>\nWhat is this `\\\
    \\1`?\n<|/ c |>\n<| c |>\nThe backreference `\\1` refers to the first captured\
    \ group in the regular expression. In this case it's the first captured group\
    \ of the last set of brackets. So that would mean that \"(<\" and \"(>)\" are\
    \ captured and are referred to by `\\1` in the regex.\n<|/ c |>\n<| c |>\nSo why\
    \ do we need the first capturing group here? Is it not possible to just look for\
    \ the first \">\" or \"<\"?\n<|/ c |>\n<| c |>\nIt will work, but you might want\
    \ to check that it actually is a balanced bracket set. Otherwise you could get\
    \ false positives.\n<|/ c |>\n<| c |>\nYes, that is why I specifically used `\\\
    \\1` as a backreference. Otherwise it would capture both brackets. But as long\
    \ as `<>` are balanced brackets, this should work.\n<|/ c |>\n<| a dscore=2 |>\n\
    You can make use of regular expressions for this.\nHere is an example in PHP:\n\
    <code>\n<?php\n\n$brackets = \"<>\";\n\n$regexp = '/^(<([^<]*)>)(?!$)/';\n\nif\
    \ (preg_match($regexp, $brackets)) {\n  echo \"Match!\";\n} else {\n  echo \"\
    No match\";\n}\n</code>\n<|/ a tags=python,php,regex |>\n<| c |>\nSo what's the\
    \ point of using regular expressions if this can be done with just basic string\
    \ manipulation?\n<|/ c |>\n<| c |>\nBecause this solution", "  return preg_match('/<['\
    \ . $brackets . ']+>/', $brackets);\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=php,regex,string\
    \ |>\nTry this\n<code>\n<?php\n$str = \"<tag1 tag2>tag3</tag1 tag2>\";\npreg_match_all('~<([^>]+)>~',$str,$matches);\n\
    print_r($matches);", "    $stack = array();\n    $bracketing = true;\n    $opening_pairs\
    \ = array_filter(preg_split('/[\\<\\>]/', $brackets));\n\n    foreach($opening_pairs\
    \ as $pair) {\n        if ($pair == '<') {\n            if (empty($stack)) {\n\
    \                $bracketing = false;\n                break;\n            } else\
    \ {\n                array_push($stack, $stack[count($stack) - 1]);\n        \
    \    }\n        } else {\n            if (empty($stack)) {\n                $bracketing\
    \ = false;\n                break;\n            }\n\n            array_pop($stack);\n\
    \        }\n    }\n\n    return $bracketing;\n}\n", "    $opening_brackets = preg_match_all(\"\
    /[<]+/\", $brackets, $m);\n    $closing_brackets = preg_match_all(\"/[>]+/\",\
    \ $brackets, $m);\n    $all_opening_brackets = $opening_brackets == count($m[0]);\n\
    \    $all_closing_brackets = $closing_brackets == count($m[0]);\n    if ($all_opening_brackets\
    \ && $all_closing_brackets) {\n        return true;\n    }\n    return false;\n\
    }\n", "    $stack = array();\n    $open = 0;\n    $close = 0;\n    foreach ($brackets\
    \ as $c) {\n        if ($c == \"<\") {\n            $stack[] = $open;\n      \
    \      $open++;\n        } elseif ($c == \">\") {\n            $open--;\n    \
    \        if ($open == 0) return false;\n            $close++;\n        } else\
    \ {\n            if ($open == 0) return false;\n            $close++;\n      \
    \  }\n    }\n    if ($close != $open) return false;\n    return true;\n}\n", " \
    \   $brackets = preg_replace('/[<>]/', '', $brackets);\n    return $brackets ===\
    \ '<>' || $brackets === '<';\n}\n</code>\nAnd here's a test case:\n<code>\nvar_dump(\n\
    \    correct_bracketing(\"<<><>>\"),\n    correct_bracketing(\"<\"),\n    correct_bracketing(\"\
    <>\")\n);\n</code>\nResult:\n<code>\nbool(true)\nbool(true)\nbool(false)\n</code>\n\
    <|/ a tags=php,regex |>\n<| c |>\nGood answer, but I think it might be better\
    \ to use `str_replace` instead of `preg_replace` since it would be less resource-intensive.\n\
    <|/ c |>\n<| c |>\nAgreed, `str_replace` would be preferable. The reason I chose\
    \ `preg_replace` was because I was already using regex :)\n<|/ c |>\n<| c |>\n\
    Yeah, sorry I should have said that in the question, thanks for your answer! :)\n\
    <|/ c |>\n<| a dscore=1 |>\nYou can use preg_split to split a string into an array\
    \ with either < or > as the delimiter.  Then test the array to see if every item\
    \ is \">\" or \"<\".  If the string didn't have the delimiter it's valid.  Otherwise,\
    \ it's invalid.\n<code>\n<?php\n$test = \"<><><><>\";\n", "    $opening_brackets\
    \ = $closing_brackets = false;\n\n    for ($i = 0; $i < strlen($brackets); $i++)\
    \ {\n        if ($brackets[$i] === \"<\") {\n            $opening_brackets = !$opening_brackets;\n\
    \        } elseif ($brackets[$i] === \">\") {\n            $closing_brackets =\
    \ !$closing_brackets;\n        }\n    }\n\n    return ($opening_brackets && $closing_brackets);\n\
    }\n", "  // make sure $brackets is properly formatted, i.e. with each character\n\
    \  // separated by a space.\n  if (strlen($brackets) != strlen(explode(' ', $brackets)))\
    \ {\n    die(\"Wrong brackets format: $brackets\");\n  }\n\n  $opening_brackets\
    \ = explode(' ', $brackets);\n  $closing_brackets = array();\n\n  // create a\
    \ stack of opening brackets\n  $stack = array();\n  foreach ($opening_brackets\
    \ as $bracket) {\n    $stack[] = $bracket;\n  }\n\n  // go through the stack from\
    \ the end of the array\n  // and reverse the order of the brackets\n  for ($i\
    \ = count($opening_brackets) - 1; $i >= 0; $i--) {\n    if ($opening_brackets[$i]\
    \ != $stack[count($stack) - 1]) {\n      // the closing bracket is not the same\
    \ as the one at the top of the stack\n      // so this bracket is not correctly\
    \ formed\n      return false;\n    }\n\n    $closing_brackets[] = $stack[count($stack)\
    \ - 1];\n    array_pop($stack);\n  }\n\n  return $closing_brackets == $opening_brackets;\n\
    }\n", "    // If the brackets string is empty, return false\n    // If the brackets\
    \ string is null, return false\n    if ($brackets == '') {\n        return false;\n\
    \    } elseif ($brackets == null) {\n        return false;\n    } else {\n   \
    \     // Initialize a boolean to false\n        $correct_bracket = false;\n  \
    \      // Iterate over each opening bracket\n        for ($i = 0; $i < strlen($brackets);\
    \ $i++) {\n            // If the next character is not a closing bracket, return\
    \ false\n            if ($brackets[$i] != \"<\") {\n                return false;\n\
    \            }\n            // Increment $i by 1\n            $i++;\n        \
    \    // If the next character is also not a closing bracket, return false\n  \
    \          if ($brackets[$i] != \"<\") {\n                return false;\n    \
    \        }\n            // Increment $i by 1\n            $i++;\n            //\
    \ If the next character is not a closing bracket, return false\n            if\
    \ ($brackets[$i] != \">\") {\n                return false;\n            }\n \
    \           // Increment $i by 1\n            $i++;\n            // If $i exceeds\
    \ the length of the brackets string, return false\n            if ($i > strlen($brackets)\
    \ - 1) {\n                return false;\n            }\n            // Set $correct_bracket\
    \ to true\n            $correct_bracket = true;\n        }\n        // Return\
    \ $correct_bracket\n        return $correct_bracket;\n    }\n}\n", "  $stack =\
    \ array();\n  foreach (explode(\"<<\", $brackets) as $open) {\n    $stack[] =\
    \ $open;\n  }\n  foreach (explode(\">>\", $brackets) as $close) {\n    $stack[]\
    \ = $close;\n  }\n  $result = true;\n  while ($stack) {\n    if (end($stack) ==\
    \ \"\") {\n      $stack = array_pop($stack);\n      continue;\n    }\n    if ($close\
    \ != array_pop($stack)) {\n      $result = false;\n      break;\n    }\n  }\n\
    \  return $result;\n}", "  if (empty($brackets)) return false;\n  if (strlen($brackets)\
    \ < 2) return false;\n\n  // We will run through all brackets in reverse order\
    \ to check they\n  // are correctly paired.\n  $open = array_reverse(explode($brackets,\
    \ \">\"));\n  $close = array_reverse(explode($brackets, \"<\"));\n\n  foreach\
    \ ($close as $k => $c){\n    // Skip over any \"<\" that isn't closed by an opening\
    \ bracket.\n    if ($c != \"<\" && ! array_search($c, $open)) return false;\n\
    \  }\n\n  foreach ($open as $k => $c){\n    // Skip over any \">\" that isn't\
    \ opened by a closing bracket.\n    if ($c != \">\" && ! array_search($c, $close))\
    \ return false;\n  }\n\n  return true;\n}\n", "  for ($i = 0; $i < strlen($brackets);\
    \ ++$i) {\n    // if we're not at a closing bracket, then this isn't a correct\
    \ bracket.\n    if (!isset($brackets[$i + 1])) return false;\n  }\n\n  // if the\
    \ only opening brackets weren't closed, then this isn't a correct bracket.\n \
    \ if (!$brackets[0]) return false;\n\n  // this looks good, so add it.\n  return\
    \ $brackets[1] !== $brackets[2];\n}\n", "  global $brackets_map;\n  // find the\
    \ first opening bracket\n  $first_open = strpos($brackets, '<');\n  // find the\
    \ last closing bracket\n  $last_close = strrpos($brackets, '>');\n  // if the\
    \ first character of the first bracket is NOT an opening bracket...\n  if ($first_open\
    \ === false || $first_open === 0) {\n    // if the last character of the last\
    \ bracket is NOT a closing bracket...\n    if ($last_close === false || $last_close\
    \ === 0) {\n      // then the bracketing is not correct\n      return false;\n\
    \    }\n    // else, if the last character of the last bracket is an opening bracket...\n\
    \    else {\n      // then the first bracket is correct.\n      return true;\n\
    \    }\n  }\n  // else, if the first character of the first bracket is a opening\
    \ bracket...\n  else {\n    // then the bracketing is correct.\n    return ($brackets_map[$brackets[$first_open]][$brackets[$last_close]]);\n\
    \  }\n}\n</code>\nThis produces the following results:\n<code>\n$brackets_map\
    \ = array(\n  '<' => array(\n    '>' => false,\n  ),\n  '<' => array(\n    '>'\
    \ => true,\n  ),\n  '<' => array(\n    '<' => true,\n    '>' => true,\n  ),\n\
    );\n\nvar_dump($brackets_map);\narray(3) {\n  [\"<\"]=>\n  array(1) {\n    [\"\
    <\"]=>\n    bool(false)\n  }\n  [\"<\"]=>\n  array(1) {\n    [\"<\"]=>\n    bool(true)\n\
    \  }\n  [\"<\"]=>\n  array(3) {\n    [\"<\"]=>\n    bool(true)\n    [\"<\"]=>\n\
    \    bool(true)\n    [\">\"]=>\n    bool(true)\n  }\n}\n\nvar_dump(correct_bracketing(\"\
    <\"));\nbool(false)\n</code>\n<|/ a |>\n<| c |>\nThanks so much for your reply.\
    \  I went and took a look at the article you linked to but I'm still a bit confused\
    \ as to how the code works when it is trying to find the first opening bracket\
    \ and last closing bracket.  At the end of the code you posted, the return statement\
    \ says this: `return ($brackets_map[$brackets[$first_open]][$brackets[$last_close]]);`\
    \ Can you help me understand how it finds these two pieces of information?\n<|/\
    \ c |>\n<| c |>\nI believe that the code uses `strpos` and `strrpos`.  I believe\
    \ that the code finds the first opening bracket, and then `strpos` finds the last\
    \ closing bracket.  I beli", "    $open = str_replace(\"<<\", \"\", $brackets);\n\
    \    $close = str_replace(\">>\", \"\", $brackets);\n    $open_list = array_map(\"\
    trim\", explode(\",\", $open));\n    $close_list = array_map(\"trim\", explode(\"\
    ,\", $close));\n    if (count($open_list) != count($close_list)) {\n        return\
    \ false;\n    }\n    foreach ($open_list as $index => $open) {\n        if (!isset($close_list[$index]))\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\n", "  \
    \  return $brackets === '<>';\n}", "\tfor ($i = 0, $c = strlen($brackets); $i\
    \ < $c; $i++) {\n\t\tif ($brackets[$i] !== \"<\") return false;\n\t\t$i++;\n\t\
    \twhile ($brackets[$i] === \">\") {\n\t\t\t$i++;\n\t\t}\n\t\twhile (isset($brackets[$i])\
    \ && $brackets[$i] !== \"<\") {\n\t\t\t$i++;\n\t\t}\n\t\tif ($i >= $c) return\
    \ false;\n\t}\n\treturn true;\n}\n", "  // Your code here\n}\n\"\"\"\n", "   \
    \ $brackets = str_replace(\"<<><>>\",\">><<\",$brackets);\n    $brackets = str_replace(\"\
    <<<\",\"<<\",$brackets);\n    $brackets = str_replace(\">>\",\"<\",$brackets);\n\
    \    $brackets = str_replace(\"<\",\">\",$brackets);\n    $brackets = str_replace(\"\
    <<\",\"\",$brackets);\n    $brackets = str_replace(\">>\",\"\",$brackets);\n \
    \   $brackets = str_replace(\"<<<\",\"\",$brackets);\n    $brackets = str_replace(\"\
    >>>\",\"\",$brackets);\n    return strlen($brackets) == 0;\n}\n", "  $brackets\
    \ = preg_replace(\"/(<)/\", \"<\", $brackets);\n  $brackets = preg_replace(\"\
    /(>)/\", \">\", $brackets);\n  return $brackets === \"<>\";\n}\n", "  $open_brackets\
    \ = 0;\n  foreach ($brackets as $b) {\n    if ($b == '<') {\n      $open_brackets++;\n\
    \    }\n    if ($b == '>') {\n      $open_brackets--;\n    }\n    if ($open_brackets\
    \ != 0) {\n      return 0;\n    }\n  }\n  return 1;\n}\n", "    $brackets = explode(\"\
    <\", $brackets);\n    foreach ($brackets as $key => $bracket) {\n        if ($bracket\
    \ != \">\") {\n            $brackets[$key] = \">\";\n        }\n    }\n    return\
    \ implode(\">\", $brackets) == $brackets;\n}\n", "  if ($brackets == null || $brackets\
    \ === '' || $brackets === '<') {\n    // nothing to correct\n    return true;\n\
    \  }\n  $openingBrackets = preg_match_all('/([<>])/', $brackets, $matches);\n\
    \  if ($openingBrackets === false) {\n    // couldn't match a bracket\n    return\
    \ false;\n  }\n  $numOpeningBrackets = count($matches[0]);\n  $numClosedBrackets\
    \ = 0;\n  for ($i = 0; $i < $numOpeningBrackets; $i++) {\n    if ($matches[1][$i]\
    \ === '<') {\n      $numClosedBrackets++;\n    }\n  }\n  return $numOpeningBrackets\
    \ === $numClosedBrackets;\n}\n\n/**\n * Reformats a string to be more human readable\
    \ and easier to debug.\n * Useful for debugging.\n * Output is sent to STDOUT.\n\
    \ * Example: 'Hello, world!' becomes 'Hello!'.\n * @param string $str The string\
    \ to reformat.\n * @param string $delimiter The delimiter to use.\n * @return\
    \ void\n */", "  for ($i = 0; $i < strlen($brackets); $i++) {\n    if ($brackets[$i]\
    \ !== \"<\" && $brackets[$i] !== \"<\") {\n      return FALSE;\n    }\n    if\
    \ ($brackets[$i] === \">\") {\n      $open_count = 1;\n      $close_count = 1;\n\
    \      while (($i + 1 < strlen($brackets)) && $brackets[$i + 1] !== \">\") {\n\
    \        if ($brackets[$i + 1] === \"<\") {\n          $open_count++;\n      \
    \  } else if ($brackets[$i + 1] === \"<\") {\n          $close_count++;\n    \
    \    }\n        $i++;\n      }\n      return $open_count !== $close_count;\n \
    \   }\n  }\n  return TRUE;\n}\n", "  return preg_match_all(\"/<\\/*([a-z0-9_]{2,}>)$/i\"\
    , $brackets);\n}\n", "  return preg_replace(\"/<\\|([^>]*)>/\"\n    , \"<$1\"\
    \ . \"\\\\$2<\"\n    , preg_quote($brackets));\n}\n\n", "    $pairs = explode(\"\
    \ \", $brackets);\n    foreach ($pairs as $key => $val) {\n        if ($val !=\
    \ \"<>\") {\n            $pairs[$key] = \"<<\" . $val . \">>\";\n        }\n \
    \   }\n    return implode(\" \", $pairs) == $brackets;\n}\n", "  $open_brackets\
    \ = array_filter(explode(\"<\", $brackets), \"strlen\");\n  $closed_brackets =\
    \ array_filter(explode(\">\", $brackets), \"strlen\");\n\n  foreach ($open_brackets\
    \ as $open) {\n    if (!empty($closed_brackets) && !array_search($open, $closed_brackets))\
    \ {\n      return false;\n    }\n  }\n  return true;\n}\n</code>\nThis works because\
    \ array_search uses strict comparison, so it compares $open with $closed_brackets\
    \ using === rather than ==.\n<|/ a tags=php,arrays,search |>\n<| c |>\nThanks,\
    \ I didn't know that array_search had strict comparison.\n<|/ c |>\n<| c |>\n\
    : Actually, that doesn't work! It only returns true if all open brackets are closed,\
    \ not if all open brackets are open. See the example I added.\n<|/ c |>\n<| c\
    \ |>\nI see. But it does work if you change `$open_brackets = array_filter(explode(\"\
    <\", $brackets), \"strlen\");` to `$open_brackets = array_filter(explode(\"<\"\
    , $brackets), \"strlen\", ARRAY_FILTER_USE_BOTH);`. So even though my initial\
    \ solution did work, I guess it does work because it's using `array_filter` with\
    \ both `ARRAY_FILTER_USE_BOTH` and `ARRAY_FILTER_USE_KEY`. I tested with 5.3.8.\n\
    <|/ c |>\n<| c |>\n: Yes, the solution works, but the way I wrote it does not.\n\
    <|/ c |>\n<| c |>\n: Well, I guess you meant that my initial solution did not\
    \ work because I was using the wrong comparison operator for strict comparison.\
    \ Yes, I should have been using `===` for the strict comparison. Thanks for pointing\
    \ that out.\n<|/ c |>\n<| a dscore=3 |>\nThis works:\n<code>", "  return preg_replace('/<[^<>]*>/',\
    \ '', $brackets) == '';\n}\n", "\tif ($brackets == \"\") {\n\t\treturn true;\n\
    \t}\n\t$len = strlen($brackets);\n\t$stack = array();\n\tfor ($i = 0; $i < $len;\
    \ ++$i) {\n\t\t$curr = $brackets[$i];\n\t\t$stack[] = $curr;\n\t\tif ($curr ==\
    \ \"<\") {\n\t\t\t$stack = array_reverse($stack);\n\t\t}\n\t}\n\t$rev = array_reverse($stack);\n\
    \treturn $stack == $rev;\n}\n", "  // return true if every opening bracket has\
    \ a corresponding closing bracket.\n  // >>> correct_bracketing(\"<\")\n  // false\n\
    \  // >>> correct_bracketing(\"<>\")\n  // true\n  // >>> correct_bracketing(\"\
    <<><>>\")\n  // true\n  // >>> correct_bracketing(\"><<>\")\n  // false\n  return\
    \ preg_match('/<(\\{|\\[|\\(|<)>/', $brackets);\n}\n</code>\n<|/ a tags=regex,php\
    \ dscore=0 |>\n<| c |>\nYou probably want to avoid matching `<<><>>` because of\
    \ the `<` character in the middle.\n<|/ c |>\n<| c |>\nYes you're right. I missed\
    \ that in the specification.\n<|/ c |>\n<| a tags=regex,php |>\n<code>\n<?php\n\
    \n$str = '<<>><<>><<><><>';\n\n$pattern = '~^(?:<<>|<(?![<>])>)$~m';\n\nif (preg_match($pattern,\
    \ $str)) {\n    echo \"MATCH!\\n\";\n} else {\n    echo \"NO MATCH\\n\";\n}\n\
    </code>\nExplanation:\n<code>\n^               # match start of line\n(?:    \
    \         # start non capture group\n    <<>|       # match <<> or <\n    <  \
    \          # match < literally\n    (            # start capture group #1\n  \
    \    (?![<>])   # make sure we don't match a < followed by a >\n    )        \
    \    # end capture group #1\n    >            # match > literally\n)         \
    \      # end non capture group\n$               # match end of line\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nYes you are right. The problem is that it doesn't\
    \ work for strings like `<<>><<>><<><><>`\n<|/ c |>\n<| c |>\nThen you should\
    \ update your question and give all possible cases of input strings. In your comment\
    \ you stated that `<<><>>` should match but `<<>><<><><>` shouldn't match. That\
    \ is different than your original question\n<|/ c |>\n<| c |>\nNo, that's what\
    \ it means. I'm going to edit my question to clarify.\n<|/ c |>\n<| c |>\nThank\
    \ you so much for the answer. I've tested it and it works great for strings like\
    \ `<<>><<>><<><><>`, `<<>><<><><>`, etc... However, it does not work for  `<<>><<>><<><><>`,\
    \ `<<><>><<>><<><><>`, `<<>><<><><>`, etc", "  $opening_brackets = preg_split(\"\
    /[\\<\\>]/\", $brackets, -1, PREG_SPLIT_NO_EMPTY);\n  $correct_brackets = array();\n\
    \  foreach ($opening_brackets as $opening_bracket) {\n    $closing_bracket = (strlen($opening_bracket)\
    \ < strlen($brackets)) ? $opening_bracket[strlen($opening_bracket) - 1] : \"\"\
    ;\n    if ($opening_bracket != $closing_bracket) {\n      $correct_brackets[]\
    \ = $opening_bracket;\n    }\n  }\n  return $correct_brackets == $opening_brackets;\n\
    }\n", "  if (strlen($brackets) < 2) return false;\n\n  // keep a stack of opening\
    \ brackets\n  $stack = array();\n  for ($i = 0; $i < strlen($brackets); $i++)\
    \ {\n    $bracket = $brackets[$i];\n    if ($bracket == \"<\") $stack[] = $bracket;\n\
    \    else if ($bracket == \">\") $top = array_pop($stack);\n    if (empty($stack))\
    \ return false;\n  }\n\n  return true;\n}\n</code>\n<|/ a tags=php,regex |>\n\
    <| c |>\nVery nice. Thanks. But I think there should be a way to do it with regex.\
    \ I am learning regex and I like it, but sometimes the regex is too cryptic for\
    \ me to comprehend.\n<|/ c |>\n<| c |>\nI added some regex which I believe is\
    \ pretty close.\n<|/ c |>\n<| c |>\nNice. Thanks. Just to make sure I understand\
    \ this correctly. So this regex works on the example I gave, but would not work\
    \ on something like \"<<>\", right?\n<|/ c |>\n<| c |>\nYes, it would not work\
    \ on something like \"<<>\".\n<|/ c |>\n<| c |>\nOh, I just realized that `<<<`\
    \ was also not accepted. I fixed it.\n<|/ c |>\n<| a dscore=3 |>\nYou could use\
    \ a simple regex to match all opening brackets and check if the content of the\
    \ brackets is correct.\n<code>\n(?:^|\\G)(\\[(?:(?!\\[\\[).)*\\])\n</code>\nSee\
    \ a demo on regex101.com.\nThe (?:^|\\G) means \"beginning of the string or after\
    \ a match already found\" and \\G means the last match. The contents of the brackets\
    \ are only possible if they don't contain [..]. You may want to modify \\G to\
    \ something else. E.g. (?!\\A)|\\G would mean \"beginning of the string or after\
    \ a match already found\" or not (but not the match).\n<code>\n$pattern = '~(?:^|\\\
    G)(\\[(?:(?!\\[\\[).)*\\])~';\n$string = '<<><>>';\n\nif (preg_match_all($pattern,\
    \ $string, $matches)) {\n    $valid = array_reduce($matches[0], 'valid_opening_brackets',\
    \ true);\n    echo $valid ? 'valid' : 'not valid';\n}\n", "  $open = strpos($brackets,\
    \ '<');\n  $close = strpos($brackets, '>');\n  return $open !== false && $close\
    \ !== false && $open < $close;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI thought\
    \ about something along those lines but wasn't sure if that was going to be too\
    \ slow for something as small as a password change form where each character will\
    \ have a few hundred possibilities before it gets \"caught\".\n<|/ c |>\n<| c\
    \ |>\nI updated my answer to include an algorithm that doesn't use regular expressions.\
    \ It's not terribly efficient, but is much easier to read than a regular expression\
    \ and doesn't require the function to be passed the entire string. The downside\
    \ is that I haven't tested it against a large string yet, and it's probably not\
    \ foolproof as I haven't tested it against your test cases.\n<|/ c |>\n<| c |>\n\
    Thanks for the update. That is far more concise. My code was getting very long\
    \ and complicated and I wasn't sure if I needed to use arrays to store the individual\
    \ characters or if there was a simpler way of doing it. I will test this out to\
    \ see if it is fast enough for what I am doing.\n<|/ c |>\n<| c |>\nI just tested\
    \ it out and it doesn't work for my purposes. I still need it to work with strings\
    \ such as '<<>><<<>><><><>>'\n<|/ c |>\n<| c |>\nI made a small change to the\
    \ code so the opening characters are matched up with the closing characters. Also,\
    \ I updated the variable names to match your original examples. Does this work\
    \ for you?\n<|/ c |>\n<| a dscore=0 |>\nThis code is not optimized. But It can\
    \ easily be optimized. \n<code>\n<?php\n", "  return preg_match('!<~!', $brackets)\
    \ && preg_match('!~>!', $brackets);\n}", "\t$opening_brackets = explode(\"<\"\
    , $brackets);\n\t$closing_brackets = explode(\">\", $brackets);\n\tforeach ($opening_brackets\
    \ as $opening_bracket => $closing_bracket) {\n\t\tif ($opening_bracket < $closing_bracket)\
    \ {\n\t\t\t$opening_brackets[$opening_bracket] = $closing_bracket;\n\t\t}\n\t\
    }\n\treturn count($opening_brackets) == count($closing_brackets);\n}\n", "  $stack\
    \ = array();\n  $found = false;\n  foreach ($brackets as $char) {\n    if ($char\
    \ === '<') {\n      if (empty($stack)) {\n        $found = true;\n      } else\
    \ {\n        $stack[] = $char;\n      }\n    } else if ($char === '>') {\n   \
    \   if (empty($stack)) {\n        $found = true;\n      }\n      $stack = array_pop($stack);\n\
    \    } else {\n      if ($stack) {\n        return false;\n      }\n    }\n  }\n\
    \  if ($stack) {\n    return false;\n  }\n  return $found;\n}", "    $brackets\
    \ = explode('>', $brackets);\n    $correct_brackets = array();\n    foreach ($brackets\
    \ as $b) {\n        if ($b[0] === '<') {\n            if ($b = strstr($brackets,\
    \ $b)) {\n                $correct_brackets[] = $b[1];\n            }\n      \
    \  }\n    }\n    return count($correct_brackets) == count(array_unique($correct_brackets));\n\
    }\n</code>\n<|/ a tags=php,arrays,regex |>\n<| c |>\nI like it! I'm going to test\
    \ it out and let you know how it goes.\n<|/ c |>\n<| c |>\nThanks so much, I've\
    \ tested it and it's working great. Thank you for the help!\n<|/ c |>\n<| a dscore=0\
    \ tags=php,arrays,regex |>\nIt would be more efficient to use regular expressions\
    \ to do this. The reason for this is that PHP can use regular expressions as an\
    \ argument to a function. Also, you can use the preg_match_all() function to do\
    \ exactly what you want with just one line of code:\n<code>\n<?php", "  if ($brackets\
    \ === \"<\") { $brackets = \"<<<\"; } // replace \"<\" with \"<<<\"\n  if ($brackets\
    \ === \">\") { $brackets = \">>>>\"; } // replace \">\" with \">>>>\"\n\n  //\
    \ returns true if every opening bracket has a corresponding closing bracket.\n\
    \  $stack = explode(\"<\", $brackets);\n  for ($i = 0; $i < count($stack); ++$i)\
    \ {\n    if ($stack[$i] !== \">\") { break; }\n  }\n\n  return $i !== count($stack)\
    \ - 1;\n}\n</code>\n<|/ a |>\n<| a dscore=0 tags=algorithm,regex,php |>\nThis\
    \ might not be the most elegant solution, but it seems to work fine. Using regex\
    \ and preg_replace_callback we could replace these with '<' before and '>' after\
    \ them. We would then just need to use str_replace to replace any extra spaces\
    \ left from <> to <>. This should leave us with the following:\n<code>\n$text\
    \ = \"<<<>>> >>> <<< >>>>> <<< >>>>\";\n$text = preg_replace_callback(\"/\\<(.*?)\\\
    >/\",\n  function($matches) {\n    return str_replace('>', ' ', $matches[0]);\n\
    \  },\n  $text);", "  foreach (str_split($brackets) as $open) {\n    if ($open\
    \ !== \"<\") return false;\n  }\n\n  return true;\n}\n", "  $opening_brackets\
    \ = 0;\n  $closing_brackets = 0;\n  for ($i = 0; $i < strlen($brackets); $i++)\
    \ {\n    if ($brackets[$i] == \"<\") {\n      $opening_brackets++;\n    } else\
    \ if ($brackets[$i] == \">\") {\n      $closing_brackets++;\n    }\n  }\n  if\
    \ ($opening_brackets == $closing_brackets) {\n    return true;\n  }\n  return\
    \ false;\n}\n", "  return preg_match('/<<>(.*?)(>>)$/s', $brackets);\n}\n", " \
    \ // convert from string to array of chars.\n  $brackets_array = str_split($brackets);\n\
    \  // check every char for opening bracket.\n  foreach($brackets_array as $key\
    \ => $val) {\n    if(!is_numeric($val)) {\n      // opening bracket.\n      if(!array_key_exists($val,\
    \ $brackets_array)) {\n        // opening bracket not found.\n        // return\
    \ false.\n        return false;\n      }\n    }\n  }\n  // check every char for\
    \ closing bracket.\n  foreach($brackets_array as $key => $val) {\n    if(is_numeric($val))\
    \ {\n      // closing bracket.\n      if(!array_key_exists($val, $brackets_array))\
    \ {\n        // closing bracket not found.\n        // return false.\n       \
    \ return false;\n      }\n    }\n  }\n  // return true.\n  return true;\n}\n",
  "    $opening = array(\"<\", \"(\");\n    $closing = array(\">\", \")\");\n    $return\
    \ = false;\n    for ($i = 0; $i < strlen($brackets); ++$i) {\n        // Find\
    \ the opening bracket.\n        $found = false;\n        for ($j = 0; $j < strlen($opening);\
    \ ++$j) {\n            if ($brackets[$i] == $opening[$j]) {\n                $found\
    \ = true;\n                break;\n            }\n        }\n\n        // Did\
    \ we find the opening bracket?\n        if ($found) {\n            // Find the\
    \ closing bracket.\n            $found = false;\n            for ($j = 0; $j <\
    \ strlen($closing); ++$j) {\n                if ($brackets[$i] == $closing[$j])\
    \ {\n                    $found = true;\n                    break;\n        \
    \        }\n            }\n\n            // Did we find the closing bracket?\n\
    \            if ($found) {\n                // If we found the closing bracket\
    \ then we have found the pair.\n                $brackets[$i] = $closing[$j];\
    \ // swap them\n                $return = true;\n            }\n        }\n  \
    \  }\n    return $return;\n}\n</code>\n<|/ a tags=php,regex,string |>\n<| a tags=php,regex,string\
    \ |>\nThis is a really simple answer to your question but it's really hard to\
    \ tell if your original string is always formatted like that. If this is the case,\
    \ you're only looking for a regular expression.\n<code>\nif (preg_match('/\\<\\\
    >/', '<>'))\n{\n    echo 'yes';\n}\nelse\n{\n    echo 'no';\n}\n</code>\n<|/ a\
    \ dscore=2 |>\n<| c |>\n+1 for being the first to answer with the code (it wasn't\
    \ obvious to me that this was what the OP was asking).\n<|/ c |>\n<| c |>\nThanks\
    \ for your answer, but that's not what I was asking.  I guess I should have been\
    \ more clear in my question.  I'm trying to determine if each opening bracket\
    \ has a corresponding closing bracket.\n<|/ c |>\n<| c |>\nI apologize for the\
    \ misunderstanding, I didn't realize you weren't looking for the code but for\
    \ the logic.\n<|/ c |>\n<| a tags=php,regex,string dscore=1 |>\n<code>\npreg_match_all('/\\\
    <(.*?)\\>/', $string, $matches);\n\n$opening_brackets = $matches[1];\n$closing_brackets\
    \ = array_diff(str_split($string), $opening_brackets);\n\n$count_opening_brackets\
    \ = count($opening_brackets);\n$count_closing_brackets = count($", "  $open_brackets\
    \ = array_filter(explode(\"<<\", $brackets));\n  $closed_brackets = array_filter(explode(\"\
    >>\", $brackets));\n  $all_brackets = array_merge(array_keys($open_brackets),\
    \ array_keys($closed_brackets));\n  return count(array_diff($all_brackets, $open_brackets))\
    \ == 0;\n}", "    $count = 0;\n    $brackets_count = count($brackets);\n    for($i\
    \ = 0; $i < $brackets_count; $i++) {\n        if ($brackets[$i] != \">\") { \n\
    \            $count++;\n        }\n        if ($brackets[$i] == \"<\" && $brackets[$i+1]\
    \ == \"<\") {\n            $count++;\n        }\n        if ($brackets[$i] ==\
    \ \"<\" && $brackets[$i+1] == \">\") {\n            $count++;\n        }\n   \
    \ }\n    return $count == $brackets_count;\n}", "  $brackets = explode('>', $brackets);\n\
    \  $open = array();\n  foreach ($brackets as $b) {\n    if ($b !== '<') $open[]\
    \ = $b;\n  }\n  $closed = array();\n  foreach ($brackets as $b) {\n    if ($b\
    \ !== '>') $closed[] = $b;\n  }\n  return !count(array_diff($open, $closed));\n\
    }\n</code>\n<|/ a tags=php,html,parsing dscore=0 |>\n<| c |>\nI've tried this\
    \ one before, but I thought about using RegEx instead of looping every character,\
    \ but this one works perfectly too. Thanks!\n<|/ c |>\n<| c |>\n: Yes, a regex\
    \ is probably more efficient than a loop. However, if you are doing this parsing\
    \ for more than a couple thousand strings, a loop will be more efficient than\
    \ a regex.\n<|/ c |>\n<| a |>\nTry this PHP code.\n<code>\n<?php\n$html_string\
    \ = '<table>\n    <tr>\n        <td>\n            <table id=\"1\">\n         \
    \       <tr>\n                    <td>\n                        <div id=\"3\"\
    >\n                            <div id=\"4\"></div>\n                        </div>\n\
    \                    </td>\n                </tr>\n            </table>\n    \
    \    </td>\n    </tr>\n</table>';\n\n$dom_doc = new DOMDocument();\n$dom_doc->loadHTML($html_string);\n\
    $domx = new DOMXPath($dom_doc);\n$divs = $domx->query('//div');\n\n$final_array\
    \ = [];\n$count = 1;\nforeach($divs as $div){\n    echo $div->nodeValue . \"<br>\"\
    ;\n    $final_array[$count++] = $div->nodeValue;\n}\nprint_r($final_array);",
  "  $brackets = explode('><', $brackets);\n  foreach($brackets as $i => $b) {\n \
    \   $last_bracket = array_pop($brackets);\n    if ($b !== $last_bracket) {\n \
    \     // This is not correct bracketing.\n      return false;\n    }\n  }\n  return\
    \ true;\n}\n", "    $brackets = explode(\"<<>>\", $brackets);\n    $brackets =\
    \ array_map(\"trim\", $brackets);\n    $last_bracket = array_pop($brackets);\n\
    \    foreach ($brackets as $bracket => $open) {\n        if ($bracket != $last_bracket)\
    \ {\n            return false;\n        }\n    }\n    return true;\n}", "    $bracket_counts\
    \ = array();\n    $brackets = explode(\"<\", $brackets);\n    foreach ($brackets\
    \ as $b) {\n        if (!isset($bracket_counts[$b])) {\n            $bracket_counts[$b]\
    \ = 1;\n        } else {\n            $bracket_counts[$b]++;\n        }\n    }\n\
    \    foreach ($brackets as $b) {\n        if (!isset($bracket_counts[$b])) {\n\
    \            return false;\n        }\n    }\n    return true;\n}\n</code>\n<|/\
    \ a dscore=0 |>\n<| a dscore=0 |>\n<code>\n$string = \"<<><>>\";\n", "  if ( !\
    \ is_string($brackets) or strlen($brackets) != 2) {\n    return false;\n  }\n\
    \  $opening_brackets = array('<', '>');\n  $closing_brackets = array('>', '>');\n\
    \  return array_diff($opening_brackets, $closing_brackets)\n    == array_intersect($opening_brackets,\
    \ $closing_brackets);\n}\n", "  for ($i = 0; $i < strlen($brackets); $i++) {\n\
    \    if ($brackets[$i] == '<') {\n      for ($j = 0; $j < $i; $j++) {\n      \
    \  if ($brackets[$j] != '<') {\n          return false;\n        }\n      }\n\
    \    }\n  }\n  return true;\n}", "  return preg_match(\"/^<{0,10}<+{0,10}$/\"\
    , $brackets);\n}\n</code>\n<|/ a |>\n<| c |>\nThe code you provided works, except\
    \ for when brackets are not in the right place. Like in the example I gave before,\
    \ when I try to run the code on <<><>> it returns false, when it should be true.\n\
    <|/ c |>\n<| c |>\n: Try running it with \"<>\".\n<|/ c |>\n<| c |>\n: I made\
    \ an edit which checks bracketing correctness.\n<|/ c |>\n<| c |>\n: The code\
    \ is still broken for \"<>\" though.\n<|/ c |>\n<| c |>\n: Yes it is. Try it now.\n\
    <|/ c |>\n<| a |>\nThis is a variant of the classic KMP algorithm, with some additional\
    \ checks (see my answer here):\n<code>\n/**\n * \\string $input\n * bool\n */\n\
    public function bracketsCorrect($input)\n{\n    $input = str_replace(array('{',\
    \ '<', '>', '}'), array('&#123;', '&lt;', '&gt;', '&#125;'), $input);\n    if\
    \ (strlen($input) < 3) return false; // too small\n    $maxlen = max(strlen($input)\
    \ - 1, 0);\n    $minlen = min(strlen($input) - 1, 0);\n    if ($minlen != $maxlen)\
    \ return false; // not same length\n    $pattern = array(str_repeat('{0,10}',\
    \ $maxlen), str_repeat('{0,10}', $maxlen), str_repeat('{0,10}', $maxlen), str_repeat('{0,10}',\
    \ $minlen), str_repeat('{0,10}', $minlen), str_repeat('{0,10}', $minlen), str_repeat('{0,10}',\
    \ $minlen), str_repeat('{0,10}', $minlen), str_repeat('{0,10}', $minlen), str_repeat('{0,10}',\
    \ $minlen), str_repeat('{0,10}', $minlen), str_repeat('{0,10}', $minlen));\n \
    \   for ($i = 0; $i < $maxlen; $i++) $pattern[0] .= '{';\n    for ($i = 1; $i\
    \ < $maxlen; $i++) $pattern[$maxlen - 1] .= '{';\n    for ($i = 1; $i < $maxlen;\
    \ $i++) $pattern[1] .= '}';\n    for ($", "  $opening = str_replace(\"<<\", \"\
    >>\", $brackets);\n  $opening = str_replace(\"<<<\", \">>>>\", $opening);\n  return\
    \ $opening === $brackets;\n}\n", "  if (strlen($brackets)===0) return false;\n\
    \  for ($i = 0; $i < strlen($brackets); $i++) {\n    $char = $brackets[$i];\n\
    \    if ($char!=='<' && $char!=='>') return false;\n  }\n  return true;\n}\n",
  "    $open_brackets = preg_grep(\"/(<)/\", $brackets);\n    $closed_brackets = preg_grep(\"\
    /(>)/\", $brackets);\n\n    return count($open_brackets) == count($closed_brackets);\n\
    }\n</code>\n<|/ a dscore=2 tags=regex,php |>\n<| c |>\nThis looks pretty good,\
    \ I'll give it a try when I get home.\n<|/ c |>\n<| c |>\nThis works, but only\
    \ in certain cases. I added another comment to my original post. I was able to\
    \ test this case by making a string that had a matching open bracket, and a closing\
    \ bracket that didn't close. Looking at that case, it works, but the other test\
    \ case fails. I think it might be because of the way the string is created in\
    \ PHP - maybe the bracket is treated as a separate character, so when the regex\
    \ searches for the closing bracket it doesn't find it. I will accept your answer\
    \ anyway since it does work, I just have to figure out how to get it to work in\
    \ my scenario.\n<|/ c |>\n<| c |>\nI tested this in all combinations, including\
    \ brackets that don't close. I think this regex works with PHP 5.3 and PHP 5.4\
    \ also.\n<|/ c |>\n<| c |>\nI see that this works with the test cases I provided,\
    \ but I can't seem to make it work for the actual code. Could it be because there\
    \ is another PHP function above this that makes the string with brackets, so it\
    \ might conflict with the regex?\n<|/ c |>\n<| c |>\nNo, it wouldn't conflict\
    \ unless you were trying to match the brackets within another string. The function\
    \ doesn't change the string being searched. You should try adding a `var_dump`\
    \ of the string being searched, to see what it's actually searching.\n<|/ c |>\n\
    <| a tags=regex,php |>\nThis should work, using preg_match_all and lookarounds:\n\
    <code>\npreg_match_all(\"/(?<=<)([^>]*)(?=<)|(?<=<)([^>]*)(?=>)/g\",\n    $input,\
    \ \n    $matches);\n\nprint_r($matches[1]);\n</code>\nThe regexp looks for opening\
    \ tags in the order that appear in the string and returns the tags in capture\
    \ group 1.\n<|/ a dscore=2 |>\n<| c |>\nThis works great! However, I see that\
    \ it does not work if the string does not end with a closing bracket. Is there\
    \ a way to modify it so that it works for strings that don't have a closing bracket\
    \ at the end?\n<|/ c |>\n<| c |>", "  foreach (str_split($brackets) as $char)\
    \ {\n    if ($char !== \"<\" && $char !== \">\") {\n      return false;\n    }\n\
    \  }\n  return true;\n}\n", "    foreach (preg_split('/[\\<\\>]/', $brackets)\
    \ as $b) {\n        if ($b !== '<' && $b !== '>') {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n", "  $brackets = explode(\">\", $brackets);\n\
    \  $new_brackets = array();\n  $open_brackets = array();\n  foreach ($brackets\
    \ as $index => $bracket) {\n    if ($bracket == \"<\") {\n      $open_brackets[]\
    \ = $index;\n    } else {\n      $new_brackets[$open_brackets[$index - 1]] = $bracket;\n\
    \    }\n  }\n  return ($new_brackets == array_reverse($new_brackets));\n}", " \
    \ $open_brackets = explode(\"<\", $brackets);\n  foreach ($open_brackets as &$open_bracket)\
    \ {\n    if ($open_bracket == \">\") {\n      return true;\n    }\n  }\n  return\
    \ false;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\n<code>", "  $brackets\
    \ = preg_replace('/[<>]/','><',$brackets);\n  return preg_match('/><',$brackets);\n\
    }", "  for ($i = 0; $i < strlen($brackets); $i++) {\n    if ($brackets[$i] !=\
    \ \"<\" && $brackets[$i] != \">\") return false;\n  }\n  return true;\n}\n</code>\n\
    <|/ a dscore=2 tags=php |>\n<| c |>\nPlease don't include solutions with links\
    \ to external sites. Include the relevant information directly in your post. Links\
    \ rot, and people shouldn't have to go off-site to help you. Also, you shouldn't\
    \ include solutions that are already covered elsewhere. Instead, link to the relevant\
    \ information so that people can find it more easily. Thanks!\n<|/ c |>\n<| c\
    \ |>\nYou don't need to check the entire string, just check each character and\
    \ keep a boolean flag.\n<|/ c |>\n<| c |>\n: Yes, you're right, but I didn't want\
    \ to change too much in the code. I'm still learning PHP and I wanted to give\
    \ the OP the chance to solve his problem without having to rewrite his code completely,\
    \ which is often the case with answers on SO.\n<|/ c |>\n<| c |>\n: Thanks for\
    \ the suggestion. Fixed it.\n<|/ c |>\n<| a dscore=1 tags=php |>\n<code>\n<?php",
  "  $open_brackets = preg_split('/([<>])/', $brackets);\n  return array_reduce($open_brackets,\
    \ function($correct, $open) {\n    return $correct && array_search($open, array_keys($open_brackets))\
    \ !== false;\n  }, true);\n}\n</code>\n<|/ a tags=code-injection,php,security\
    \ |>\n<| c |>\nYou can't use a regex to parse html with regex. http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags\n\
    <|/ c |>\n<| c |>\n: Yes, but that question doesn't ask about parsing HTML, and\
    \ it only contains HTML tags. And it isn't necessary to be parsing HTML; you don't\
    \ have to. The only thing that matters is that the string contains *valid* HTML\
    \ tags. The question does not say anything about parsing HTML.\n<|/ c |>\n<| c\
    \ |>\n: I already said that in my answer. I was just pointing out that the question\
    \ was about parsing HTML with regex, not how to parse HTML with regex. And I realize\
    \ that the linked question doesn't mention anything about HTML; I just wanted\
    \ to point out that there is no need for a regex here (because the OP doesn't\
    \ want to *parse* HTML).\n<|/ c |>\n<| c |>\n: My point was that regexes can have\
    \ security problems and are often more trouble than they are worth. Using a dedicated\
    \ DOM library (which I recommend) is probably a better solution than trying to\
    \ parse it with regex.\n<|/ c |>\n<| c |>\n: I did not know that about regexes.\
    \ Do you know of a place that lists all the things that can go wrong with them?\n\
    <|/ c |>\n<| a tags=code-injection,php,security dscore=1 |>\nIf you're trying\
    \ to prevent HTML injection on some page, your best bet is to follow this practice:\n\
    <code>", "  for ($i = 0; $i < strlen($brackets); $i++) {\n    $opening = $brackets[$i];\n\
    \    $closing = $brackets[$i + 1];\n    if ($opening == $closing) {\n      unset($brackets[$i]);\n\
    \      $brackets[$i + 1] = \"\";\n    } else {\n      return false;\n    }\n \
    \ }\n  return true;\n}\n", "  $brackets = preg_replace('/<(.*?)>/', '', $brackets);\n\
    \  $brackets = preg_replace('/<(.*?)(>)?/', '', $brackets);\n  return $brackets\
    \ === '<>';\n}\n", "    $opening_brackets = array_filter($brackets, create_function('$v',\
    \ 'return $v==\"<\";'));\n    $closing_brackets = array_filter($brackets, create_function('$v',\
    \ 'return $v==\">\";'));\n    return count($opening_brackets) == count($closing_brackets);\n\
    }\n", "    $brackets = explode(\"<\", $brackets);\n    $ret = true;\n    for ($i\
    \ = 0; $i < count($brackets); $i++) {\n        if ($brackets[$i] != \">\") {\n\
    \            $ret = false;\n            break;\n        }\n    }\n    return $ret;\n\
    }\n", "  $opening_brackets_count = count(preg_grep('/<[<>]/i', $brackets));\n\
    \  if ($opening_brackets_count === 0) {\n    return false;\n  }\n\n  $closing_brackets_count\
    \ = count(preg_grep('/<\\/[<>]/i', $brackets));\n  if ($closing_brackets_count\
    \ !== $opening_brackets_count) {\n    return false;\n  }\n\n  return true;\n}\n\
    </code>\n<|/ a dscore=2 tags=php,preg-match-all,regex,preg-match |>\n<| c |>\n\
    thanks for your answer but I can't use recursive regex because my string is not\
    \ necessarily bracket-free.\n<|/ c |>\n<| a dscore=1 |>\nHere's a non-recursive\
    \ version using strpos:\n<code>\n$pattern = '~<((?>[^><]|<(?!/?(?:[<>]|$))+>)+)>~';\n\
    if (preg_match($pattern, $subject, $matches)) {\n    $matches = $matches[0];\n\
    }\n</code>\nThis matches a string of one or more <...>.  It works because when\
    \ you have two consecutive <...> in a row, the regex engine backtracks by looking\
    \ for the second one.  So it matches your pattern correctly.  But if you add another\
    \ set of consecutive <...> like <...><...>, it won't match your pattern.  So it\
    \ finds a match for the first one, then backtracks and finds the second one.\n\
    <|/ a tags=php,preg-match-all,regex,preg-match |>\n<| c |>\nThanks Steve. Your\
    \ solution works great, and I learned a couple of new tricks with regex. :)\n\
    <|/ c |>\n<| a dscore=1 tags=php,preg-match-all,regex,preg-match |>\nHow about\
    \ using lookaround assertions?\n<code>\n(?<=>[^<>]*?(?=<))|(?<=<)[^<>]*?(?=<)\n\
    </code>\nExplanation:\nThe lookbehind (?<=>[^<>]*?(?=<)) checks for any number\
    \ of non-< characters followed by a single <.  This is followed by the lookahead\
    \ (?=<), which checks for a single < followed by the non-< characters again.\n\
    <|/ a |>\n<| a |>\nYou could try something like this:\n<code>\n$string = '<abcd><fghj><efgh><><><efgh>';\n\
    $pattern = \n  '~\n    (?# Match opening bracket)\n    <\n    (?:\n      # Match ",
  "  $brackets = explode(\"<>\", $brackets);\n  foreach ($brackets as $key => $value)\
    \ {\n    if ($key > 0) {\n      if (substr($value, 0, 1) != substr($brackets[$key\
    \ - 1], 1)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n",
  "  $opening_brackets = str_split($brackets);\n  $correct_bracketing = false;\n \
    \ foreach ($opening_brackets as $key => $value) {\n    if ($value !== \"<\" &&\
    \ $value !== \">\") {\n      $correct_bracketing = false;\n      break;\n    }\n\
    \    $correct_bracketing = true;\n  }\n  return $correct_bracketing;\n}\n", " \
    \   if ($brackets === null) {\n        return false;\n    }\n    $brackets = explode(\"\
    <\", $brackets);\n    $result = [];\n    foreach ($brackets as $opening) {\n \
    \       if (!isset($result[substr($opening, 0, 1)]) || $result[substr($opening,\
    \ 0, 1)] !== \"<\" || !isset($result[substr($opening, -1, 1)]) || $result[substr($opening,\
    \ -1, 1)] !== \"<\") {\n            $result[\"<\"] = [];\n            $result[substr($opening,\
    \ 0, 1)] = $opening;\n        }\n        $result[substr($opening, 0, 1)][] = substr($opening,\
    \ 1);\n    }\n    $result = [];\n    foreach ($brackets as $closing) {\n     \
    \   if (!isset($result[substr($closing, 0, 1)]) || $result[substr($closing, 0,\
    \ 1)] !== \"<\" || !isset($result[substr($closing, -1, 1)]) || $result[substr($closing,\
    \ -1, 1)] !== \"<\") {\n            $result[\"<\"] = [];\n            $result[substr($closing,\
    \ 0, 1)] = $closing;\n        }\n        $result[substr($closing, 0, 1)][] = substr($closing,\
    \ 1);\n    }\n    foreach ($result as $tag => $brackets) {\n        if (count($brackets)\
    \ < 2) {\n            unset($result[$tag]);\n        } else {\n            $result[$tag]\
    \ = \"<\" . implode(\">\", $brackets) . \">\";\n        }\n    }\n    return !empty($result);\n\
    }\n", "\tglobal $open_brackets, $closed_brackets;\n\n\t$matches = preg_split('/(<[^<>]*>)/',\
    \ $brackets, -1, PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY);\n\t$num_matches\
    \ = count($matches);\n\n\tif ($num_matches == 0) {\n\t\treturn false;\n\t}\n\n\
    \t// Make sure there are not more closing brackets than opening brackets\n\tif\
    \ ($num_matches > count($closed_brackets)) {\n\t\treturn false;\n\t}\n\n\t// Make\
    \ sure there are no opening brackets that are not closed\n\tforeach ($open_brackets\
    \ as $key => $bracket) {\n\t\tif ($bracket != $matches[0]) {\n\t\t\treturn false;\n\
    \t\t}\n\t}\n\n\t// Make sure every opening bracket has a corresponding closing\
    \ bracket\n\tforeach ($matches as $key => $bracket) {\n\t\tif (!isset($open_brackets[$bracket]))\
    \ {\n\t\t\treturn false;\n\t\t}\n\t\tif ($bracket != $closed_brackets[$open_brackets[$bracket]])\
    \ {\n\t\t\treturn false;\n\t\t}\n\t\tunset($open_brackets[$bracket]);\n\t}\n\n\
    \t// Make sure there are no unclosed brackets\n\tif (!empty($open_brackets)) {\n\
    \t\treturn false;\n\t}\n\n\treturn true;\n}\n", "    $stack = [];\n    foreach(str_split($brackets)\
    \ as $bracket) {\n        array_push($stack, $bracket);\n        $bracket = $bracket[1];\n\
    \        if(strlen($bracket) < 2)\n            break;\n        if($bracket ===\
    \ \"<\") {\n            array_push($stack, \"<\");\n        }\n        elseif($bracket\
    \ === \">\") {\n            array_push($stack, \"<\");\n            array_push($stack,\
    \ \"<\");\n        }\n        elseif($bracket === \"<<\") {\n            array_push($stack,\
    \ \"<<\");\n        }\n        elseif($bracket === \">>\") {\n            array_push($stack,\
    \ \"<<\");\n            array_push($stack, \"<\");\n        }\n        elseif($bracket\
    \ === \">>\") {\n            array_push($stack, \"<<\");\n            array_push($stack,\
    \ \"<<\");\n        }\n        elseif($bracket === \"<><\") {\n            array_push($stack,\
    \ \"<<\");\n            array_push($stack, \"<<\");\n            array_push($stack,\
    \ \"<<\");\n        }\n        elseif($bracket === \">><\") {\n            array_push($stack,\
    \ \"<<\");\n            array_push($stack, \"<<\");\n            array_push($stack,\
    \ \"<<\");\n            array_push($stack, \"<\");\n        }\n        elseif($bracket\
    \ === \"<>\") {\n            array_push($stack, \"<<\");\n            array_push($stack,\
    \ \"<<\");\n            array_push($stack, \"<\");\n            array_push($stack,\
    \ \"<\");\n            array_push($stack, \"<\");\n        }\n    }\n    return\
    \ count($stack) == 0;\n}", "  $brackets = str_replace(array(\"<\", \">\"), array(\"\
    <<\", \">>\"), $brackets);\n  $brackets = str_replace(array(\"<<\", \"<\", \"\
    >>\"), array(\"<<\", \"<\", \">>\"), $brackets);\n  return str_replace(\"<<\"\
    , \"\", $brackets) === \"\";\n}\n</code>\n<|/ a tags=algorithm,php |>\n<| a tags=algorithm,php\
    \ |>\nThis solution uses PHP closures and array_reduce.\n<code>\n<?php\n", " \
    \ return preg_match('/^<+$/', $brackets) && preg_match('/^>+$/', $brackets);\n\
    }", "  $brackets = str_split($brackets);\n  array_walk($brackets, 'find_matching_bracket');\n\
    \  return count($brackets) == count(array_unique($brackets));\n}\n", "  // make\
    \ sure there aren't any duplicate brackets\n  if ($brackets === NULL) {\n    return\
    \ false;\n  }\n\n  $count = 1;\n  $correct = true;\n  foreach ($brackets as $opening)\
    \ {\n    // make sure there aren't any duplicate brackets\n    if ($opening ===\
    \ NULL) {\n      return false;\n    }\n\n    $last = $closing = NULL;\n    for\
    \ ($i = 0; $i < strlen($opening); $i++) {\n      $char = $opening[$i];\n     \
    \ if ($char === '<') {\n        if ($count > 1) {\n          $correct = false;\n\
    \          break;\n        }\n        $count++;\n      }\n      if ($char ===\
    \ '>') {\n        $count--;\n        if ($count < 0) {\n          $correct = false;\n\
    \          break;\n        }\n        $closing = $opening;\n      }\n    }\n \
    \   if ($correct) {\n      if ($last !== $closing) {\n        $correct = false;\n\
    \        break;\n      }\n    } else {\n      break;\n    }\n  }\n  return $correct;\n\
    }\n\n/**\n * Returns the proper padding character for the given file format.\n\
    \ */", "    return str_replace(array(\"<\", \"<<\", \">>\"), array('&lt;', '&gt;&gt;',\
    \ '&gt;&gt;'), $brackets);\n}", "\tfor ($i = 0; $i < strlen($brackets); $i++)\
    \ {\n\t\tif ($brackets[$i] == \"<\") {\n\t\t\tfor ($j = 1 + $i; $j < strlen($brackets);\
    \ $j++) {\n\t\t\t\tif ($brackets[$j] == \">\") {\n\t\t\t\t\treturn false;\n\t\t\
    \t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tif ($brackets[$i] == \"<\") {\n\
    \t\t\tcontinue;\n\t\t}\n\t\tif ($brackets[$i] == \">\") {\n\t\t\treturn false;\n\
    \t\t}\n\t}\n\treturn true;\n}\n", "  $brackets = preg_replace('/\\>/', '', $brackets);\n\
    \  $brackets = preg_replace('/<([^>]+)>([^>]+)$/', '', $brackets);\n  \n  // check\
    \ for an unexpected number of brackets\n  return (strlen($brackets) & 1) == 1;\n\
    }\n", "    $open_count = preg_match_all('/<\\/?([^>]*)>/', $brackets, $matches);\n\
    \    $close_count = preg_match_all('/<\\/?([^>]*)/', $brackets, $matches);\n \
    \   return $open_count === $close_count;\n}\n", "  $open = strpos($brackets, \"\
    <\");\n  $close = strpos($brackets, \">\");\n  return $open < $close;\n}\n", " \
    \ $stack = array($brackets);\n  while (count($stack)) {\n    $next = array_pop($stack);\n\
    \    if ($next == \">\") {\n      $next = \"<\";\n    }\n    if ($next == \"<\"\
    ) {\n      $next = \">\";\n    }\n    if ($next == \">>\") {\n      $next = \"\
    <\";\n    }\n    if ($next == \"<>\") {\n      $next = \">\";\n    }\n    if ($next\
    \ != \"<\" && $next != \">\") {\n      return false;\n    }\n    $stack[] = $next;\n\
    \  }\n  return true;\n}\n", "  return preg_match('/<(\\/)(.+?)(>)/', $brackets);\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 tags=regex,php |>\n<code>", "  return\
    \ preg_match_all('/(<+)/', $brackets, $matches) &&\n         count($matches[0])\
    \ == count(preg_split('/(<+>)/', $brackets));\n}\n</code>\n<|/ a tags=parsing,php\
    \ |>\n<| c |>\nInteresting solution, but I don't think it handles brackets correctly\
    \ with nested brackets correctly.\n<|/ c |>\n<| c |>\n: I updated the answer to\
    \ handle nested brackets. I used a [recursive function](http://en.wikipedia.org/wiki/Recursion_(computer_science)),\
    \ but this is just another way of doing it.\n<|/ c |>\n<| c |>\n: I added another\
    \ possible way of doing this using a regular expression. My first instinct was\
    \ to parse it with `preg_match_all()`, but it might be easier to just use `preg_split()`.\n\
    <|/ c |>\n<| a dscore=2 |>\nIf you can count on valid nested brackets, you can\
    \ just explode() on the opening brackets. That is guaranteed to work if your brackets\
    \ always match.\n<code>\n$string = \"((foo) (bar) (baz)) (bak) (bark) ( ((foo)\
    \ (bar) (baz)) (bak) (bark) ( ((foo) (bar) (baz)) (bak) (bark) ( ((foo) (bar)\
    \ (baz)) (bak) (bark) ( ((foo) (bar) (baz)) (bak) (bark) ( ((foo) (bar) (baz))\
    \ (bak) (bark) ( ((foo) (bar) (baz)) (bak) (bark) ( ((foo) (bar) (baz)) (bak)\
    \ (bark) ( ((foo) (bar) (baz)) (bak) (bark) ( ((foo) (bar) (baz)) (bak) (bark)\
    \ ( ((foo) (bar) (baz)) (bak) (bark) ( ((foo) (bar) (baz)) (bak) (bark) ( ((foo)\
    \ (bar) (baz)) (bak) (bark) ( ((foo) (bar) (baz)) (bak) (bark) ( ((foo) (bar)\
    \ (baz)) (bak) (bark) ( ((foo) (bar) (baz)) (bak) (bark) ( ((foo) (bar) (baz))\
    \ (bak) (bark) ( ((foo) (bar) (baz)) (bak) (bark) ( ((foo) (bar) (baz)) (bak)\
    \ (bark) ( ((foo) (bar) (baz)) (bak) (bark) ( ((foo", "    $brackets = preg_replace(\"\
    @<@\", \"<\", $brackets);\n    $brackets = preg_replace(\"@>@\", \">\", $brackets);\n\
    \    $brackets = preg_replace(\"@<<@\", \"<<\", $brackets);\n    $brackets = preg_replace(\"\
    @>>@\", \">>\", $brackets);\n    $brackets = preg_replace(\"@<>>@\", \"<>>\",\
    \ $brackets);\n    $brackets = preg_replace(\"@<<<@\", \"<<<\", $brackets);\n\
    \    $brackets = preg_replace(\"@>>>>@\", \">>>\", $brackets);\n    $brackets\
    \ = preg_replace(\"@<->@\", \"<->\", $brackets);\n    $brackets = preg_replace(\"\
    @<=@\", \"<=\", $brackets);\n    $brackets = preg_replace(\"@>=@\", \">=\", $brackets);\n\
    \    $brackets = preg_replace(\"@<=>@\", \"<=>\", $brackets);\n    $brackets =\
    \ preg_replace(\"@=>@\", \">=>\", $brackets);\n    $brackets = preg_replace(\"\
    @=><@\", \"=><\", $brackets);\n    $brackets = preg_replace(\"@<->@\", \"<->\"\
    , $brackets);\n    $brackets = preg_replace(\"@<=>@\", \"<=>\", $brackets);\n\
    \    $brackets = preg_replace(\"@<=>@\", \"<=>\", $brackets);\n    $brackets =\
    \ preg_replace(\"@<=>@\", \"<=>\", $brackets);\n    $brackets = preg_replace(\"\
    @=><@\", \"=><\", $brackets);\n    $brackets = preg_replace(\"@=><@\", \"=><\"\
    , $brackets);\n    $brackets = preg_replace(\"@=><@\", \"=><\", $brackets);\n\
    \    $brackets = preg_replace(\"@=><@\", \"=><\", $brackets);\n    $brackets =\
    \ preg_replace(\"@<=>@\", \"<=>\", $brackets);\n    $brackets = preg_replace(\"\
    @<=>@\", \"<=>\", $brackets);\n    $brackets = preg_replace(\"@<=>@\", \"<=>\"\
    , $brackets);\n    $brackets = preg_replace(\"@<=>@\", \"<=>\", $brackets);\n\
    \    $brackets = preg_replace(\"@<=>@\", \"<=>\", $brackets);\n    $brackets =\
    \ preg_replace(\"@<=>@\", \"<=>\", $brackets);\n    $brackets = preg_replace(\"\
    @<=>@\", \"<=>\", $brackets);\n    $brackets = preg_replace(\"@<=>@\", \"<=>\"\
    , $brackets);\n    $brackets = ", "  $open = strpos($brackets, \"<\");\n  $close\
    \ = strpos($brackets, \">\");\n  if ($open === false || $close === false) {\n\
    \    return false;\n  }\n  return ($open !== false && $close !== false);\n}\n",
  "  $brackets = trim($brackets);\n  if ($brackets == '') {\n    return true;\n  }\n\
    \  $brackets = explode('<', $brackets);\n  $opened = 0;\n  for ($i = 0; $i < count($brackets);\
    \ $i++) {\n    if ($brackets[$i] == '') {\n      $opened--;\n    } else if ($brackets[$i]\
    \ != '<') {\n      return false;\n    }\n  }\n  $brackets = explode('>', $brackets);\n\
    \  $opened = 0;\n  for ($i = 0; $i < count($brackets); $i++) {\n    if ($brackets[$i]\
    \ == '') {\n      $opened++;\n    } else if ($brackets[$i] != '>') {\n      return\
    \ false;\n    }\n  }\n  return (count($brackets) == $opened);\n}\n", "    // Loop\
    \ through the string and check each character for matching the other character.\n\
    \    $count = substr_count($brackets, '<');\n    for ($i = 0; $i < $count; $i++)\
    \ {\n        if ($brackets[$i] !== '>') {\n            return false;\n       \
    \ }\n    }\n    return true;\n}", "  $bracket_depths = preg_split(\"/({[^}]*}[^<>]*>?)|\\\
    (([^()]*)\\)/\", $brackets);\n  $last_closed = -1;\n  for ($i = 1; $i < count($bracket_depths);\
    \ ++$i) {\n    if ($bracket_depths[$i] == null) {\n      continue;\n    }\n  \
    \  if ($last_closed + 1 != $bracket_depths[$i]) {\n      return false;\n    }\n\
    \    $last_closed = $i;\n  }\n  return true;\n}\n", "    // Loop through every\
    \ opening bracket.\n    $open_brackets_count = strlen($brackets) - 1;\n    for($i\
    \ = 0; $i < $open_brackets_count; $i++) {\n        $current = $brackets[$i];\n\
    \        // Move one character forward.\n        $next = substr($brackets, $i+1,\
    \ 1);\n        $next_length = strlen($next) - 1;\n        // If we're at the end\
    \ of the string, we can skip checking further.\n        if($next_length == 0)\
    \ {\n            break;\n        }\n        // Make sure the next character is\
    \ the right one.\n        if($next != $current) {\n            return false;\n\
    \        }\n        // Move one character forward.\n        $next = substr($brackets,\
    \ $i+1, 1);\n        $next_length = strlen($next) - 1;\n        // If we're at\
    \ the end of the string, we can skip checking further.\n        if($next_length\
    \ == 0) {\n            break;\n        }\n    }\n    return true;\n}\n", "  //\
    \ get length of brackets\n  $brackets_length = strlen($brackets);\n  // initialize\
    \ return value\n  $correct = true;\n  // initialize counters\n  $opens = 0;\n\
    \  $closes = 0;\n  // loop through characters in brackets\n  for ($i=0; $i < $brackets_length;\
    \ $i++) {\n    // get current character\n    $char = $brackets[$i];\n    // if\
    \ character is opening, increment counter\n    if ($char == '<') {\n      $opens++;\n\
    \      // if opening counter equals closing counter, return false\n      if ($opens\
    \ == $closes)\n        $correct = false;\n    }\n    // if character is closing,\
    \ decrement counter\n    else if ($char == '>') {\n      $closes--;\n    }\n \
    \ }\n  // return correct value\n  return $correct;\n}", "  // We use recursion\
    \ to keep track of whether the bracketing has been\n  // correct.\n  $opened =\
    \ false;\n  $i = 0;\n  while ($i < strlen($brackets)) {\n    // The character\
    \ at position $i is not a bracket.\n    $char = substr($brackets, $i, 1);\n  \
    \  if ($char == \"<\") {\n      $opened = true;\n      if ($opened) {\n      \
    \  $i++;\n      }\n      // This is the end of the bracket, so we're done here.\n\
    \      // We are finished if there are no more brackets.\n      if ($i >= strlen($brackets))\
    \ { return false; }\n    }\n    else if ($char == \">\") {\n      $opened = false;\n\
    \      if ($opened) {\n        $i++;\n      }\n      // This is the end of the\
    \ bracket, so we're done here.\n      // We are finished if there are no more\
    \ brackets.\n      if ($i >= strlen($brackets)) { return false; }\n    }\n   \
    \ else if ($char == \"<\") {\n      $opened = true;\n      if ($opened) {\n  \
    \      $i++;\n      }\n      // This is the end of the bracket, so we're done\
    \ here.\n      // We are finished if there are no more brackets.\n      if ($i\
    \ >= strlen($brackets)) { return false; }\n    }\n    $i++;\n  }\n  // If we get\
    \ to here, it means we were correct.\n  return true;\n}\n", "  return preg_match('/<('.\
    \ $brackets .')+/', $brackets);\n}\n", "    return preg_match_all('/<([\\/]{0,1})>/i',\
    \ $brackets, $matches);\n}\n", "  // \"(\" and \")\" must be balanced\n  if (strpos($brackets,\
    \ \"(\") !== false && strpos($brackets, \")\") !== false) {\n    // get the opening\
    \ bracket that has a corresponding closing bracket\n    $open_bracket = strpos($brackets,\
    \ \")\");\n    if ($open_bracket !== false) {\n      $open_bracket = strpos($brackets,\
    \ \")\", $open_bracket+1);\n      if ($open_bracket !== false) {\n        $open_bracket++;\
    \ // move past the matching closing bracket\n      }\n      else {\n        $open_bracket\
    \ = strlen($brackets);\n      }\n    }\n    else {\n      $open_bracket = strlen($brackets);\n\
    \    }\n\n    // get the opening bracket that has a corresponding closing bracket\n\
    \    $close_bracket = strpos($brackets, \"(\", $open_bracket);\n    if ($close_bracket\
    \ !== false) {\n      $close_bracket = strpos($brackets, \")\", $close_bracket+1);\n\
    \    }\n    else {\n      $close_bracket = false;\n    }\n\n    if ($close_bracket\
    \ !== false) {\n      $brackets = substr($brackets, 0, $open_bracket).substr($brackets,\
    \ $close_bracket+1);\n    }\n    else {\n      // didn't find matching closing\
    \ bracket, return false\n      return false;\n    }\n  }\n  return true;\n}\n",
  "    foreach (explode(\"<\", $brackets) as $i => $open_symbol) {\n        if ($open_symbol\
    \ != \"<\") {\n            continue;\n        }\n        $closing_bracket = end($open_symbol);\n\
    \        foreach (explode(\">\", $brackets, $i + 1) as $j => $close_symbol) {\n\
    \            if ($close_symbol != \">\") {\n                continue;\n      \
    \      }\n            $open_bracket = key($close_symbol);\n            if ($open_bracket\
    \ !== $closing_bracket) {\n                return false;\n            }\n    \
    \    }\n    }\n    return true;\n}\n</code>\n<|/ a |>\n<| c |>\nWow, that's brilliant.\
    \ Thank you!\n<|/ c |>\n<| a tags=php,parsing,string |>\n<code>\n<?php\n$string\
    \ = '<<<>>>';\n\n$result = preg_replace('/([<<<])/', '$1$1', $string);\n\nif (preg_match('/([>>>])/',\
    \ $result)) {\n    echo 'true';\n} else {\n    echo 'false';\n}", "  $bracket_arrays\
    \ = str_split($brackets);\n  $result       = true;\n  foreach ($bracket_arrays\
    \ as $bracket) {\n    if (strpos($bracket, '<') === false) {\n      $result =\
    \ false;\n      break;\n    }\n  }\n  return $result;\n}", "\t$opens = explode(\"\
    <\", $brackets);\n\t$closes = explode(\">\", $brackets);\n\tforeach ($opens as\
    \ $key => $value) {\n\t\tif (!isset($closes[$key])) return false;\n\t\t$op = $closes[$key];\n\
    \t\t$opens[$key] = \"<\" . $op;\n\t\t$closes[$key] = $op . \">\";\n\t}\n\treturn\
    \ true;\n}\n", "  $result = [];\n  for ($ii = 0; $ii < strlen($brackets); $ii++)\
    \ {\n    // if next char is a bracket, close current bracket, push opening bracket,\n\
    \    // and add current char to result.\n    if ($brackets[$ii] === \">\" || $brackets[$ii]\
    \ === \"<\") {\n      $last_bracket = array_pop($result);\n      $opening_bracket\
    \ = $brackets[$ii];\n      // ignore cases where a closing bracket is missing,\
    \ such as \"<<>>\".\n      if ($opening_bracket !== \">\" && $opening_bracket\
    \ !== \"<\") {\n        // if the opening bracket is missing, there is no matching\
    \ closing bracket.\n        if ($last_bracket === false) {\n          return false;\n\
    \        }\n        // push last char to result and continue.\n        else {\n\
    \          $result[] = $last_bracket;\n        }\n      }\n      // push current\
    \ char to result and continue.\n      else {\n        $result[] = $brackets[$ii];\n\
    \      }\n    }\n    // if next char is a bracket, push it to result.\n    else\
    \ {\n      $result[] = $brackets[$ii];\n    }\n  }\n  return count($result) ===\
    \ strlen($brackets);\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nIt could be better\
    \ to have two arrays, one with openings and one with closings.  That way if the\
    \ first array is shorter than the second, it will still work.\n<|/ c |>\n<| c\
    \ |>\nI think your answer is more elegant than mine. Just one thing, `in_array`\
    \ returns the index of the element, not the value of the element itself. So if\
    \ you're looking for `<<>>`, you probably want `array_search` instead.\n<|/ c\
    \ |>\n<| c |>\nYes, your right. My code just returns the index of the opening\
    \ bracket. I will edit my answer.\n<|/ c |>\n<| c |>\nGood answer. You could add\
    \ `if(!in_array($brackets[$ii], $brackets, true)) continue;` in order to avoid\
    \ error in case `$brackets[$ii]` equals `false` or `null`.\n<|/ c |>\n<| a tags=php,regex,regex-lookarounds\
    \ |>\n<code>\n<?php\n\n$input = '<><>>>><<<><>>>';\n$output = '';\n\nfor ($i =\
    \ 0; $i < strlen($input); $i++) {\n  $output .= ($input[$i] === '<') ? '>' : '<';\n\
    }\n\nvar_dump($output);\n</code>\n<|/ a dscore=3 |>\n<| c |>", "  $brackets_map\
    \ = array_flip(str_split($brackets));\n  return array_sum($brackets_map) == count($brackets_map);\n\
    }\n", "  $openings = array_filter(explode(\"<<\", $brackets), function($x) { return\
    \ $x !== \"<\" });\n  $closings = array_filter(explode(\">>\", $brackets), function($x)\
    \ { return $x !== \">\" });\n  return $openings === $closings;\n}\n", "  $opening_brackets\
    \ = preg_split('/<<<+>/U', $brackets, -1, PREG_SPLIT_NO_EMPTY);\n  $closing_brackets\
    \ = preg_split('/>>>>+>/U', $brackets, -1, PREG_SPLIT_NO_EMPTY);\n\n  $opening_brackets\
    \ = array_map('trim', $opening_brackets);\n  $closing_brackets = array_map('trim',\
    \ $closing_brackets);\n\n  if (count($opening_brackets) != count($closing_brackets))\
    \ {\n    return false;\n  }\n\n  foreach ($opening_brackets as $i => $open) {\n\
    \    if (!isset($closing_brackets[$i])) {\n      return false;\n    }\n\n    if\
    \ ($open != $closing_brackets[$i]) {\n      return false;\n    }\n  }\n\n  return\
    \ true;\n}\n", "    // return true if every opening bracket has a corresponding\
    \ closing bracket.\n    // >>> correct_bracketing(\"<\")\n    // false\n    //\
    \ >>> correct_bracketing(\"<>\")\n    // true\n    // >>> correct_bracketing(\"\
    <<><>>\")\n    // true\n    // >>> correct_bracketing(\"><<>\")\n    // false\n\
    \    if (strlen($brackets) === 1) {\n        return $brackets !== \"<\";\n   \
    \ }\n    return preg_match(\"/\\\\<\\\\</\", $brackets) === 0;\n}\n\n", "    //\
    \ Don't count <> as opening brackets.\n    $brackets = str_ireplace(\"<>\", \"\
    \", $brackets);\n    $open_brackets = array();\n    $closing_brackets = array();\n\
    \    foreach ($brackets as $b) {\n        if ($b == \"<\") {\n            $open_brackets[]\
    \ = $b;\n        }\n        if ($b == \">\") {\n            $closing_brackets[]\
    \ = $b;\n        }\n    }\n    return count($open_brackets) == count($closing_brackets);\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThank you!  I am now able to parse and evaluate\
    \ my custom language, which is pretty interesting.\n<|/ c |>\n<| c |>\nIf you\
    \ can do it in javascript, I'm sure you can do it in php :-)  Maybe this will\
    \ help you do it in php:\nhttp://stackoverflow.com/questions/2689005/how-to-use-php-to-parse-html-correctly\n\
    <|/ c |>\n<| c |>\nYes, I could.  It was more so a matter of how much experience\
    \ I had, and I wanted to get a working solution in PHP.  Thanks again for taking\
    \ the time to help me with this.  I appreciate it.\n<|/ c |>\n<| a |>\nThe easiest\
    \ way would be to use Regular Expressions. In php you can do something like \n\
    <code>\n$var = 'This is<is> a <test>';\npreg_match_all('/\\<(.*?)\\>/U',$var,$matches);\n\
    foreach($matches[1] as $value) {\n    echo $value . \"\\n\";\n}\n</code>\n<|/\
    \ a tags=php,parsing,regex dscore=1 |>\n<| c |>\nThank you!  Your solution was\
    \ a little more comprehensive than others.  I appreciate it.\n<|/ c |>\n<| a tags=php,parsing,regex\
    \ |>\nI think you are looking for something like this:\n<code>\n<?php\n\n$html\
    \ = '<table>\n            <tr>\n                <td>\n                    <table>\n\
    \                        <tr>\n                            <td>\n            \
    \                    <h3> Test1</h3>\n                            </td>\n    \
    \                    </tr>\n                    </table>\n                </td>\n\
    \            </tr>\n            <tr>\n                <td>\n                 \
    \   <h3> Test2</h3>\n                </td>\n            </tr>\n        </table>';\n",
  "    $open = preg_split('/(\\<\\<)/', $brackets);\n    $close = preg_split('/(\\\
    >\\>\\>)/', $brackets);\n\n    if ($open[0] != $close[0]) {\n        return false;\n\
    \    } else {\n        return true;\n    }\n}\n", "  foreach (str_split($brackets)\
    \ as $bracket) {\n    if ($bracket === '>') {\n      return true;\n    } elseif\
    \ ($bracket === '<') {\n      return false;\n    }\n  }\n  return false;\n}\n",
  "    $count = 0;\n    for($i = 0; $i < strlen($brackets); $i++) {\n        $c =\
    \ $brackets[$i];\n        if($c === \"<\") {\n            ++$count;\n        }\
    \ else if($c === \">\") {\n            --$count;\n            if($count < 0) {\n\
    \                return false;\n            }\n        }\n    }\n    return $count\
    \ === 0;\n}\n</code>\n<|/ a dscore=3 tags=java,regex,php |>\n<| c |>\nThanks,\
    \ I used the other answer, but this one works :)\n<|/ c |>\n<| c |>\nThis one\
    \ actually fails on brackets such as `[([()]]`\n<|/ c |>\n<| c |>\n, yes, that's\
    \ what makes this problem so complex. I'm hoping that a regex will eventually\
    \ fix this problem.\n<|/ c |>\n<| c |>\nYeah I came to that conclusion too. I\
    \ think a regex will eventually fix this problem. [Looking at it now]\n<|/ c |>\n\
    <| c |>\nI guessed that it would fail but couldn't prove it. It seems obvious\
    \ now, but I'm still wondering if there are other cases like that where the regex\
    \ solution would fail. Not much of a problem to check for though\n<|/ c |>\n<|\
    \ a dscore=3 |>\nThis is my solution:\n<code>\nimport java.util.regex.Pattern;\n\
    import java.util.regex.Matcher;\nimport java.util.Scanner;\n\npublic class Main\
    \ {\n    public static void main(String[] args) {\n        Scanner scanner = new\
    \ Scanner(System.in);\n        String s = scanner.nextLine();\n        boolean\
    \ valid = checkValidBrackets(s);\n        System.out.println(\"valid: \" + valid);\n\
    \    }\n\n    private static boolean checkValidBrackets(String s) {\n        Pattern\
    \ pattern = Pattern.compile(\"\\\\[([^\\\\[\\\\]])*\\\\]\");\n        Matcher\
    \ matcher = pattern.matcher(s);\n        boolean valid = matcher.find();\n   \
    \     return valid;\n    }\n}\n</code>\nIt uses Pattern and Matcher from java.util.regex\
    \ package. Pattern matches brackets with brackets without brackets, so [^\\[\\\
    ]]* part matches brackets without brackets. Matcher finds brackets and returns\
    \ true if found otherwise it returns false. \nThe only problem here that it will\
    \ not match brackets with square brackets, for example [[]] won't match because\
    \ [ is inside square brackets but [] not. With this small change it will work\
    \ :)\n<|/ a tags=java,regex,php |>\n<| a dscore=", "\t$result = false;\n\t$brackets\
    \ = explode(\"<\", $brackets);\n\tforeach ($brackets as $b) {\n\t\tif (!in_array($b,\
    \ $brackets)) {\n\t\t\t$result = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn $result;\n\
    }\n", "  $pairs = explode(\"<<>>\", $brackets);\n  if (count($pairs) < 2) return\
    \ false;\n  $openings = explode(\"<\", $pairs[0]);\n  $closings = explode(\">\"\
    , $pairs[1]);\n  foreach ($openings as $i => $opening) {\n    foreach ($closings\
    \ as $j => $closing) {\n      if ($opening != $closing) return false;\n    }\n\
    \  }\n  return true;\n}\n", "  preg_match_all('/<\\/?(\\w+)/', $brackets, $matches);\n\
    \  return count($matches[0]) === strlen($brackets);\n}", "    $count = 0;\n  \
    \  $opening_brackets = preg_match_all('/<+/',$brackets,$match);\n    for ($i =\
    \ 0; $i < $opening_brackets; $i++) {\n        $count += $match[0][$i];\n    }\n\
    \    $closing_brackets = preg_match_all('/>+/',$brackets,$match);\n    for ($i\
    \ = 0; $i < $closing_brackets; $i++) {\n        $count -= $match[0][$i];\n   \
    \ }\n    return ($count == 0);\n}", "  // If the string has less than 3 characters,\
    \ it can't have any brackets.\n  if (strlen($brackets) < 3) return false;\n\n\
    \  // Split the string into an array of each of the opening brackets.\n  $brackets\
    \ = explode(\"<\", $brackets);\n\n  // Cycle through the array of brackets.\n\
    \  for ($i = 0; $i < count($brackets); $i++) {\n    // If we have already iterated\
    \ through the entire string, return false.\n    if ($i == count($brackets) - 1)\
    \ return false;\n    // If we have already iterated through the entire string,\
    \ return false.\n    if ($i == count($brackets) - 2) return false;\n    // If\
    \ this bracket matches the one after it, then return false.\n    if ($brackets[$i\
    \ + 1] == $brackets[$i]) {\n      return false;\n    }\n  }\n  // If we got this\
    \ far, every opening bracket matched the last bracket.\n  return true;\n}", " \
    \   foreach ($brackets as $b) {\n        if ($b == \"<\") return false;\n    \
    \    if ($b == \">\") return true;\n    }\n    return false;\n}", "  return preg_match(\"\
    /<+(.+?)+>+<+\\1\\>+</+(.+?)+>+<+/\", $brackets);\n}\n", "  preg_match_all('/<\\\
    /?([a-zA-Z]+)/', $brackets, $matches);\n  return array_sum($matches[1]) == 0;\n\
    }\n", "   $open = explode(\"<\", $brackets);\n   $close = explode(\">\", $brackets);\n\
    \   $correct_open = array_diff($open, $close);\n   return count($correct_open)\
    \ == 0;\n}", "    $opening = preg_quote($brackets[0]);\n    $closing = preg_quote($brackets[1]);\n\
    \    $pattern = \"/^[$opening][$closing]+$/\";\n    $matches = preg_match($pattern,\
    \ $brackets);\n    return !$matches;\n}\n</code>\n<|/ a |>\n<| c |>\nThis should\
    \ be the accepted answer. This is an example of doing exactly what the OP was\
    \ asking for. Plus I don't need to write more code. Much cleaner and easier to\
    \ read than my own solution.\n<|/ c |>\n<| a dscore=2 |>\n<code>\n<?php\n\n$string='<foo>';\n\
    $pattern='/<(/|.*?(?=<))/';\necho preg_replace($pattern, '<', $string);\n"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
