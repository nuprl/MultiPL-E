name: HumanEval_59_largest_prime_factor
language: php
prompt: "<?php\n// Return the largest prime factor of n. Assume n > 1 and is not a\
  \ prime.\n// >>> largest_prime_factor(13195)\n// 29\n// >>> largest_prime_factor(2048)\n\
  // 2\nfunction largest_prime_factor($n) {\n"
tests: "function candidate(...$args) {\n    return largest_prime_factor(...$args);\n\
  }\n\nfunction test(): void {\n    if (candidate(15) !== 5) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(27) !== 3) { throw new Exception(\"Test failed!\"\
  ); }\n    if (candidate(63) !== 7) { throw new Exception(\"Test failed!\"); }\n\
  \    if (candidate(330) !== 11) { throw new Exception(\"Test failed!\"); }\n   \
  \ if (candidate(13195) !== 29) { throw new Exception(\"Test failed!\"); }\n}\n\n\
  test();"
completions: ["    if ($n <= 2) {\n        return $n;\n    }\n\n    $largest = 2;\n\
    \    $factor = 2;\n\n    while ($n >= $factor) {\n        if ($n % $factor ===\
    \ 0) {\n            $largest = $factor;\n        }\n        $factor += 1;\n  \
    \  }\n\n    return $largest;\n}\n</code>\n<|/ a |>\n<| a |>\n<code>\n<?php\n\n\
    $n = 4; // n is the number whose largest prime factor we want to find\n$i = 0;\
    \ // i is the variable which is incremented each time we find a factor\n", " \
    \   $nstr = $n;\n    $factor = 1;\n    while ($nstr > 1) {\n        if ($nstr\
    \ % 2 == 0) {\n            $nstr = (int)($nstr / 2);\n        } elseif ($nstr\
    \ % 3 == 0) {\n            $nstr = (int)($nstr / 3);\n        } else {\n     \
    \       break;\n        }\n        $factor++;\n    }\n    return $factor;\n}",
  "  $n = abs($n);\n\n  for ($i = 2; $i <= sqrt($n); $i++) {\n    if ($n % $i == 0)\
    \ {\n      $factors[$i] = $i;\n      if ($n%$i == 0) {\n        return $i;\n \
    \     }\n    }\n  }\n  return $n;\n}", "    if ($n < 2) {\n        return 1;\n\
    \    }\n    $n = abs($n);\n    $f = 1;\n    foreach (range(2, $n) as $i) {\n \
    \       $f2 = $f;\n        $f = $i / $f;\n        if ($f != $f2) {\n         \
    \   return $f2;\n        }\n    }\n    return $f;\n}\n</code>\n<|/ a dscore=1\
    \ tags=performance,php,primes |>\n<| c |>\nA few corrections: you're not supposed\
    \ to put `return` inside the loop, and if you're going to use a loop, just use\
    \ while.\n<|/ c |>\n<| c |>\nI fixed the return inside the loop\n<|/ c |>\n<|\
    \ c |>\nThis solution is O(n\xB2). A more efficient method is to keep track of\
    \ the primes you found so far, and only test numbers that are not already in the\
    \ list.\n<|/ c |>\n<| c |>\nIf there are many primes, a hashtable will be faster.\n\
    <|/ c |>\n<| c |>\nThe return should not be in the loop. Just do a `return $f`\
    \ after the loop.\n<|/ c |>\n<| a |>\nYou can use a variable that will hold the\
    \ largest prime number found. Start with 1 and check if its divisible by all the\
    \ prime numbers from 2 to n. If it isn't, then store the number in a variable\
    \ (largest prime found). Then go ahead and check if it divides n and if so store\
    \ the biggest prime number found. After that you can stop the algorithm as this\
    \ biggest prime number will surely be a prime number.\nThe code would look something\
    \ like this:\n<code>\n$largestPrimeFound = 0;\n\nfor($i=2; $i<=$n; $i++){\n  \
    \  if($largestPrimeFound != 0 && $i%$largestPrimeFound != 0){\n        $largestPrimeFound\
    \ = 0;\n        break;\n    }\n\n    if($i%$n==0){\n        $largestPrimeFound\
    \ = $i;\n    }\n}\n</code>\n<|/ a dscore=1 tags=performance,php,primes |>\n<|\
    \ c |>\nNot really, because if $i is a prime number it'll be divided by it self\
    \ as well.\n<|/ c |>\n<| c |>\nThat was a typo, fixed it. Also the second if statement\
    \ is just checking if $i is a divisor of $n, and since it has to be a divisor,\
    \ it's already a prime number.\n<|/ c |>\n<| c |>\nThis would be O(n^2) in the\
    \ worst case. An algorithm that runs in ", "  $factor = 1;\n  for($i = 1; $i <=\
    \ sqrt($n); $i++) {\n    if($n % $i == 0) {\n      $factor = $i;\n    }\n  }\n\
    \  return $factor;\n}\n", "  return $n == 2\n     || $n % 4 == 0 && $n % 100 !=\
    \ 11\n     || ($n % 4 == 0 && $n % 100 == 11) || !$n\n      ? 1\n      : max((int)$n/2,\
    \ (int)ceil(sqrt($n)));\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=php,algorithm,mathematical-optimization\
    \ |>\nThis is not a solution to this exact problem, but it is an alternative solution\
    \ to your problem. Although I didn't see a solution posted here, it might come\
    \ handy for people searching for this kind of problem too.\nThe solution is based\
    \ on converting a number to a binary and then finding out how many 1's are in\
    \ it. The solution is pretty much self explanatory, but here is the code -\n<code>\n\
    <?php\n\n$number = 1234561;\n", "  $primes = array(2, 3);\n  for($m = $n; $m %\
    \ 2 == 0; $m /= 2) {\n    $primes[1]++;\n  }\n  for($m = $n; $m % 3 == 0; $m /=\
    \ 3) {\n    $primes[2] += $primes[1];\n  }\n  for($m = $n; $m % 5 == 0; $m /=\
    \ 5) {\n    $primes[2] += $primes[1];\n  }\n  for($m = $n; $m % 7 == 0; $m /=\
    \ 7) {\n    $primes[2] += $primes[1];\n  }\n  for($m = $n; $m % 11 == 0; $m /=\
    \ 11) {\n    $primes[2] += $primes[1];\n  }\n  for($m = $n; $m % 13 == 0; $m /=\
    \ 13) {\n    $primes[2] += $primes[1];\n  }\n  for($m = $n; $m % 17 == 0; $m /=\
    \ 17) {\n    $primes[2] += $primes[1];\n  }\n  return $primes[1];\n}", "    if\
    \ ($n <= 1) {\n        return $n;\n    }\n    $i = 2; $max_factor = $n;\n    while\
    \ ($i <= $max_factor) {\n        if ($n % $i == 0) {\n            $i = $i + 2;\n\
    \        } else {\n            $n = $n / $i;\n            $max_factor = $i;\n\
    \        }\n    }\n    return $max_factor;\n}", "    $i = 2; //initialize the\
    \ i loop variable\n    $factor = 2; //initialize the factor variable\n    while($i\
    \ <= sqrt($n)) {\n        $prime = true;\n        for($j = 2; $j <= $i; ++$j)\
    \ {\n            if($n % $j == 0) {\n                $prime = false;\n       \
    \         break;\n            }\n        }\n        if($prime) {\n           \
    \ $factor = $i;\n            $i = $i + 1;\n        } else {\n            $i =\
    \ $i + 2;\n        }\n    }\n    return $factor;\n}\n$n = 13195;\n$factor = 2;\n\
    $p = largest_prime_factor($n);\n$n = $n / $p;\necho $p.'<br>';\n$factor = $p +\
    \ $factor;\necho $factor;", "  $nprimes = $nfactors = $factors = 0;\n  for ($i\
    \ = 2; $i <= $n; $i++) {\n    if (($n % $i) == 0) {\n      $nprimes++;\n     \
    \ $nfactors = $i;\n    }\n  }\n  for ($i = $nfactors; $i > 0; $i--) {\n    $factors\
    \ = $factors + $i;\n    while ($n % $i == 0) {\n      $nprimes--;\n      $factors++;\n\
    \      $n = $n / $i;\n    }\n  }\n  return $factors > $nprimes ? $factors : $nprimes;\n\
    }", "    if ($n == 1) {\n        return 2;\n    }\n    $i = 0;\n    foreach (range(2,\
    \ $n) as $prime) {\n        if ($n % $prime === 0) {\n            $i = $prime\
    \ + $i;\n        }\n    }\n    return $i;\n}\n</code>\n<|/ a dscore=4 |>\n<| c\
    \ |>\nThanks for providing such a thorough answer!\n<|/ c |>\n<| a |>\n<code>\n\
    <?php", "    $m = $n;\n    $p = 2;\n    while ($m != 1) {\n        $m = $n % $p;\n\
    \        $p++;\n    }\n    return $p;\n}\n", "  $max = sqrt($n);\n  $i = 1;\n\
    \  while (true) {\n    for ($p = 3; $p * p <= $max; $p+=2) {\n      if ($n % $p\
    \ == 0) {\n        $max = $p;\n        break;\n      }\n    }\n    $i++;\n   \
    \ if ($i == 100) {\n      break;\n    }\n  }\n  return $max;\n}", "  for ($i =\
    \ 2; $i <= $n; $i++) {\n    if ($n % $i == 0)\n      break;\n  }\n  return $i;\n\
    }\n</code>\n<|/ a tags=biginteger,php |>\n<| c |>\nYour code is wrong, it doesn't\
    \ work for prime numbers with more than 3 digits. You can test it with this example:\
    \ largest_prime_factor(52428897747821700)\n<|/ c |>\n<| c |>\n: Yes, it is! See\
    \ [this demo](https://3v4l.org/M1ZYm).\n<|/ c |>\n<| c |>\nI didn't realize that\
    \ $i is initialised as 2... But yes, that's exactly the solution I'm looking for.\n\
    <|/ c |>\n<| c |>\nNo, `$i` is initialised as `2` because that's the first prime\
    \ factor of 2. Then you add 2 to it. `2` isn't prime so you get `3`, and then\
    \ you add 2 to `3` to get `5`, and then you add `5` to `3` to get `7`, and then\
    \ you add 7 to `5` to get `11`. So it goes on like that until it hits the number\
    \ you pass in.\n<|/ c |>\n<| a |>\nIf you want prime factors only, not numbers,\
    \ you can use this:\n<code>", "  // Sieve of Eratosthenes gives us primes of the\
    \ form 6k+1.\n  $primes = array_filter(range(1, $n), function($k) {\n    return\
    \ $k * $k <= $n;\n  });\n  return max($primes);\n}\n", "    if ($n < 2) return\
    \ null;\n    $primes = array(3);\n    for ($i = 2; $i <= sqrt($n); ++$i) {\n \
    \       while ($n % $i == 0) {\n            ++$primes[$i];\n            while\
    \ (++$primes[$i] > $n) --$i;\n        }\n    }\n    return count($primes) == 1\
    \ ? $primes[0] : null;\n}\n", "  global $primes;\n  if (!isset($primes[$n])) return\
    \ null;\n\n  $nfactors = array();\n  $r = $n = $nfactors[$n] = 1;\n  while ($r\
    \ > 2) {\n    while ($n % $primes[$n]) {\n      $nfactors[$n++] = 0;\n    }\n\
    \    $r /= $primes[$n];\n  }\n  while ($n > 1) {\n    $nfactors[$n--] = 0;\n \
    \ }\n  $primes[$n] = $r;\n  return $r;\n}", "\tif ($n<2) { return 2; }\n\tif ($n%2==0)\
    \ { return $n; } // Can't be prime\n\t$f = largest_prime_factor($n/2);\n\treturn\
    \ ($f*$f)==$n ? $f : -1;\n}", "  $ret = [];\n  $n = intval($n);\n  $num_factor\
    \ = 2;\n  for ($i = 2; $i <= $n; $i++) {\n    $num_factor *= $i;\n    if ($num_factor\
    \ > $n) {\n      break;\n    }\n    if ($n % $i == 0) {\n      $ret[] = $i;\n\
    \      if ($i == 2) {\n        break;\n      }\n    }\n  }\n  return count($ret)\
    \ == 1 ? $ret[0] : $ret;\n}\n", "    $i = 3;\n    while(true) {\n        if ($i\
    \ * $i == $n) { // Check divisibility by all primes up to sqrt(n)\n          \
    \  return $i;\n        }\n        $i += 2;\n    }\n}", "  if ($n < 2) {\n    return\
    \ 1;\n  }\n\n  $factor = 1;\n  $limit = $sqrt($n);\n  for ($i = 2; $i <= $limit;\
    \ ++$i) {\n    $i_squared = $i * $i;\n    // If $n / $i is greater than or equal\
    \ to one, divide by $i and\n    // increase the factor count. This will keep going\
    \ for ever\n    // $i >= 2, because any prime factor will divide by 2 and increase\n\
    \    // the divisor count.\n    if ($n / ($i_squared + $i) >= 2) {\n      $factor++;\n\
    \    }\n  }\n\n  return $factor;\n}\n", "    if ($n < 2) {\n        return null;\n\
    \    }\n\n    $i = 2;\n    $j = 2;\n\n    while ($j <= $n) {\n        if ($n %\
    \ $j == 0) {\n            $i = $j;\n        }\n\n        $j += 2;\n    }\n\n \
    \   return $i;\n}\n", "    $limit = ceil(log($n) / log(2)) - 1;\n    for($factor\
    \ = 2; $factor <= $limit; $factor++) {\n        $candidate = $n * $factor;\n \
    \       if ($candidate < $n && $candidate % $factor == 0) {\n            return\
    \ $factor;\n        }\n    }\n    return $limit;\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nThis is not the most optimal solution, but I like this one the best.\n\
    <|/ c |>\n<| c |>\nYes, you are right, it is not the most optimal solution. I\
    \ have posted an optimized one as a comment below, and I will be very thankful\
    \ if you give me an advice to make it more optimized. I will be very thankful\
    \ if you give me an advice to make it more optimized. I will be very thankful\
    \ if you give me an advice to make it more optimized. I will be very thankful\
    \ if you give me an advice to make it more optimized. I will be very thankful\
    \ if you give me an advice to make it more optimized. I will be very thankful\
    \ if you give me an advice to make it more optimized. I will be very thankful\
    \ if you give me an advice to make it more optimized. I will be very thankful\
    \ if you give me an advice to make it more optimized. I will be very thankful\
    \ if you give me an advice to make it more optimized. I will be very thankful\
    \ if you give me an advice to make it more optimized. I will be very thankful\
    \ if you give me an advice to make it more optimized. I will be very thankful\
    \ if you give me an advice to make it more optimized. I will be very thankful\
    \ if you give me an advice to make it more optimized. I will be very thankful\
    \ if you give me an advice to make it more optimized. I will be very thankful\
    \ if you give me an advice to make it more optimized. I will be very thankful\
    \ if you give me an advice to make it more optimized. I will be very thankful\
    \ if you give me an advice to make it more optimized. I will be very thankful\
    \ if you give me an advice to make it more optimized. I will be very thankful\
    \ if you give me an advice to make it more optimized. I will be very thankful\
    \ if you give me an advice to make it more optimized. I will be very thankful\
    \ if you give me an advice to make it more optimized. I will be very thankful\
    \ if you give me an advice to make it more optimized. I will be very thankful\
    \ if you give me an ad", "    $primes = array();\n    $factor = 2;\n    while\
    \ ($n % $factor == 0) {\n        $primes[] = $factor;\n        $n /= $factor;\n\
    \    }\n    return count($primes) == 1 ? $primes[0] : $factor;\n}", "  // n is\
    \ guaranteed > 1\n  for($i = (int)sqrt($n); $i >= 2; --$i) {\n    if($n % $i ==\
    \ 0) {\n      return $i;\n    }\n  }\n  \n  return $n; // n is not prime\n}\n",
  "    $n = abs($n);\n\n    $factor = 1;\n    while ($n != 1) {\n        if ($n %\
    \ 2 == 0) {\n            $n = $n / 2;\n        } else if ($n % 3 == 0) {\n   \
    \         $n = $n / 3;\n        } else {\n            $n = $n * 3 + 1; // not\
    \ a prime\n        }\n        $factor++;\n    }\n    return $factor;\n}\n", " \
    \ $n = abs($n);\n  $i = 1;\n  while (1) {\n    // if $n % $i has no remainder\
    \ and is larger than the largest $i\n    // we've already found a factor. If $i\
    \ is larger than $n then we'll\n    // need to test whether it's larger than the\
    \ square root of $n\n    if ($n % $i == 0) {\n      if ($n > $i * sqrt($i)) {\n\
    \        return $n;\n      }\n      $i++;\n    }\n    else {\n      $n = ($n /\
    \ $i) | 0;\n      if ($n == 1) {\n        return $n;\n      }\n      $i = 2;\n\
    \    }\n  }\n}\n", "\t$n = abs($n);\n\tif ($n <= 1) return $n;\n\t\n\t// Limit\
    \ search to factor of about 10 or less - this is the limit\n\t// tested when factoring\
    \ from the smallest factor 2 up to (I think)\n\t// the next power of 10.\n\tfor\
    \ ($factor = 3; $factor < min($n%10, 5); $factor++) {\n\t\tif ($n % $factor ==\
    \ 0) {\n\t\t\treturn $factor;\n\t\t}\n\t}\n\t\n\t$limit = 10;\n\tfor ($factor\
    \ = min($n%10, 5); $factor <= $limit; $factor++) {\n\t\tif ($n % $factor == 0)\
    \ {\n\t\t\treturn $factor;\n\t\t}\n\t}\n\t\n\treturn $limit;\n}\n", "  $i = 2;\
    \ $j = 2; $m = 1;\n  while ($j <= sqrt($n)) {\n    while ($n % $i == 0) {\n  \
    \    $m++; $n /= $i;\n    }\n    ++$i;\n    ++$j;\n  }\n  return $m;\n}", "  $n\
    \ = abs($n);\n  $x = $n-1;\n  $y = $n+1;\n  while ($x > 0 && $y <= PHP_INT_MAX)\
    \ {\n    ++$x;\n    ++$y;\n    if ($x % $n == 0 || $y % $n == 0) {\n      $x =\
    \ $y = $n = 1;\n    }\n  }\n  if ($x != 1) {\n    return $x;\n  } else {\n   \
    \ return $y;\n  }\n}\n\n$prime_factors = array(3, 7, 11, 13, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97);\n\necho implode(\" x \"\
    , array_map(largest_prime_factor, range(1, 50)));\n", "  $i = 2; $result = 1;\n\
    \  for (; $i <= $n; $i++) {\n    $result = max($result, $n % $i);\n  }\n  return\
    \ $result;\n}\n", "    $n = abs($n);\n    $i = 2;\n    while (!is_prime($n)) {\n\
    \        if ($n % $i == 0) {\n            $n /= $i;\n            break;\n    \
    \    }\n        $i++;\n    }\n    return $n;\n}\n", "  return (int)ceil(sqrt($n)*sqrt($n)/(1+$n));\n\
    }\n</code>\n<|/ a tags=primes,factors,php,largest-prime |>\n<| c |>\nThanks for\
    \ sharing the code. Though it isn't the most efficient code, it does run faster\
    \ than the other solutions here.\n<|/ c |>\n<| a dscore=3 tags=primes,factors,php,largest-prime\
    \ |>\nHere is my solution which uses Largest Prime Factor algorithm.\nIt will\
    \ return the largest prime factor for a given integer and also the list of factors.\
    \ You can modify the code to return the list of factors too. \n<code>\n<?php",
  "    $n = abs($n);\n    $m = $n;\n    $i = 11;\n    while($i <= $m){\n        if(!($n\
    \ % $i)){\n            $m = $i;\n        } else {\n            $i = $i+2;\n  \
    \      }\n    }\n    return $m;\n}\n", "    $n = abs($n);\n    $m = $n;\n    $factor\
    \ = 2;\n    $found = false;\n    while ($found == false and $m > 1) {\n      \
    \  if ($m % $factor) {\n            $found = true;\n        } else {\n       \
    \     $m = $m / $factor;\n            $factor++;\n        }\n    }\n    return\
    \ $factor;\n}", "  $i = 3;\n  while($i <= sqrt($n)) {\n    if($n % $i == 0) {\n\
    \      if($i > $n) { break; }\n      else { $n = $n / $i; }\n    }\n    else {\n\
    \      $i += 2;\n    }\n  }\n  return $n;\n}", "    $n = abs($n);\n    $max =\
    \ $n;\n    for($i = 2; $i <= $n/2; $i++) {\n        if($n % $i == 0) {\n     \
    \       $max = $i;\n        }\n    }\n    return $max;\n}\n", "    $n = $n->copy();\n\
    \    $n->is_prime(true);\n    $n->is_odd(false);\n    $n->scale_by_radix(2, true);\n\
    \    $n->reduce(true);\n    return $n->is_prime() ? $n->copy() : NULL;\n}\n",
  "  for ($n = $n % 2; $n <= 3; $n = ($n / 2)) {\n    $i = 2;\n    while ($i * $i\
    \ <= $n) {\n      if (($n % $i) == 0) {\n        $n = $n / $i;\n        break;\n\
    \      }\n      $i++;\n    }\n  }\n  return $n;\n}\n", "    $i = $n = $factor\
    \ = 2;\n    while($n > 1)\n    {\n        $i++;\n        $n /= $factor;\n    \
    \    $factor++;\n    }\n    return $factor;\n}\n", "    if ($n == 1) {\n     \
    \   return $n;\n    }\n    // http://en.wikipedia.org/wiki/Primality_test#Naive_methods\n\
    \    $n++;\n    $x = 3;\n    while($x ** $n < $n) {\n        $x++;\n    }\n  \
    \  if ($x != $n) {\n        $factors[$x] = $x;\n        $n--;\n    }\n    while($n\
    \ % $x == 0) {\n        $n--;\n        $x++;\n    }\n    return $x;\n}\n", " \
    \   $factors = array(2);\n    for ($factor = 3; $factor <= $n/2; $factor++) {\n\
    \        if ($n % $factor == 0) {\n            if ($n / $factor > $factor) {\n\
    \                $factors[] = $factor;\n            }\n            break;\n  \
    \      }\n    }\n    if (empty($factors)) {\n        return 2;\n    } else {\n\
    \        return max($factors);\n    }\n}\n", "  $sieve = new Sieve($n);\n  return\
    \ $sieve->largestPrimeFactor();\n}\n\nclass Sieve extends SieveBase {\n  // Constructor.\
    \ Initializes the sieve, storing all primes <= n into\n  // the sieve, and setting\
    \ the n value to its square root.\n  function __construct($n) {\n    parent::__construct($n);\n\
    \    $this->primes = range(1, $n);\n  }\n\n  // Returns all the primes <= n that\
    \ are in the sieve.\n  function primes() {\n    return $this->primes;\n  }\n\n\
    \  // Returns the prime factor of the given number n. Assumes that n is\n  //\
    \ a prime.\n  function primeFactor($n) {\n    $i = $n = $n-1;\n    $sieve = new\
    \ Sieve($n);\n    do {\n      if ($sieve->isPrime($i)) {\n        $sieve->increment($i);\n\
    \      }\n      $i = $sieve->largestPrimeFactor();\n    } while ($i > 1);\n  \
    \  return $i;\n  }\n\n  // Returns true if the given number is prime. Assumes\
    \ that n is a prime.\n  function isPrime($n) {\n    $sieve = new Sieve($n);\n\
    \    return $sieve->isPrime($n);\n  }\n\n  // Returns true if the given number\
    \ is prime.\n  function isPrime($n) {\n    return ($n % 2) == 0;\n  }\n\n  //\
    \ Increments the number by 1. Assumes that n is a prime.\n  function increment($n)\
    \ {\n    $this->primes[$n] = true;\n  }\n\n  // Returns the largest prime factor\
    \ of n.\n  function largestPrimeFactor() {\n    $n = $this->n;\n    if ($n <=\
    \ 2) {\n      return 1;\n    }\n\n    // If the number is already prime, return\
    \ the largest prime factor of\n    // it.\n    if ($this->isPrime($n)) {\n   \
    \   $this->n = $this->n;\n      return $this->primeFactor($n);\n    }\n\n    //\
    \ Otherwise, we will need to find the next larger prime and increment it.\n  \
    \  $i = $n-1;\n    while ($i > 2) {\n      $i = $this->primeFactor($i);\n    }\n\
    \n    // Now that we have identified the next larger prime, we can increment\n\
    \    // the number by one.\n    $this->increment($i);\n\n    return $i;\n  }\n\
    }\n\nclass SieveBase {\n  // Stores the list of primes <= n.\n  public $primes\
    \ = array();\n\n  // Stores the number being tested for primeness.\n  public $n;\n\
    \n  // Returns true if the given number is prime. Assumes that n is a prime.\n\
    \  function isPrime($n) {\n    if ($n <= ", "  $max = 1 << ($n - 1);\n  for ($i\
    \ = 2; $i <= $max; $i++) {\n    $max *= $i;\n    if ($n % $i == 0) {\n      return\
    \ $i;\n    }\n  }\n  return $max;\n}", "  $n = $n - 1; // Python doesn't allow\
    \ negative numbers\n  $prime_factor = 2;\n  while (true) {\n    if ($n % $prime_factor\
    \ == 0) {\n      return $prime_factor;\n    }\n    $prime_factor++;\n  }\n}\n",
  "    $a = $n-1;\n    $b = $n+1;\n    $n = 0;\n    $res = 1;\n    while ($b !== 1)\
    \ {\n        while ($a%$b === 0) {\n            $a++;\n            $n++;\n   \
    \     }\n        $b--;\n    }\n    return $n;\n}", "    if ($n < 2) {\n      \
    \  return 1;\n    }\n    $factor = 2;\n    $max = 2;\n    while ($n % $factor\
    \ > 0) {\n        if (++$factor > $max) {\n            $factor = $max;\n     \
    \   }\n        $max *= $factor;\n    }\n    return $factor;\n}\n</code>\n<|/ a\
    \ tags=prime-factoring,primes,php,prime-number |>\n<| c |>\nI like this. I changed\
    \ it up a little so it always returns 2, and also changed the for loop to go upto\
    \ sqrt($n).\n<|/ c |>\n<| a dscore=3 |>\nI wrote a prime number library in PHP\
    \ to solve this kind of problems http://github.com/rcepegs/PrimeNumber/tree/master\n\
    This library is very efficient and is very easy to use.\n<|/ a tags=prime-factoring,primes,php,prime-number\
    \ |>\n<| c |>\nIt works great! I needed it for my coding assignment, but thanks\
    \ for the tip.\n<|/ c |>\n<| a dscore=3 |>\nI wrote a php library that can solve\
    \ this problem. \nhttp://www.jonasjohn.de/snippets/php/primes.htm\n<|/ a tags=prime-factoring,primes,php,prime-number\
    \ |>\n<| a dscore=2 tags=prime-factoring,primes,php,prime-number |>\nThis is an\
    \ answer I found in a PHP question about prime factorization where you need a\
    \ general formula to factor a number:\n<code>\n<?php", "  $m = $n >> 1;\n  while\
    \ ($m && $n % $m == 0) {\n    $m >>= 1;\n  }\n  return $m > 1 ? ($n + 1) : 1;\n\
    }\n\n/**\n * Converts a UTF-8 encoded string into UCS-4\n *\n * See http://en.wikipedia.org/wiki/UTF-8\n\
    \ *\n * @param $str the UTF-8 encoded string to convert\n * @return string UCS-4\
    \ encoded string\n */", "    $a = $n = 2 * $n + 1;\n    $b = $a * $a + 1;\n  \
    \  $d = $b * $b - $a * $a - $a * $a * $a;\n\n    // return $a if $d > 0\n    return\
    \ $d === 0 ? $a : min($a, $b);\n}\n", "  $n = abs($n);\n  $primes = array();\n\
    \n  for ($p = 2; $p * $p <= $n; $p++) {\n    if (!isPrime($n)) {\n      break;\n\
    \    }\n    for ($i = 2; $i * $i <= $n; $i++) {\n      if ($n % $i == 0) {\n \
    \       $primes[] = $i;\n        if ($n >= $i * $i || $n % ($i + $i) == 0) {\n\
    \          break;\n        }\n      }\n    }\n  }\n\n  return count($primes) >\
    \ 0 ? $primes[count($primes) - 1] : -1;\n}\n", "    $i = 2;\n    $largest = 1;\n\
    \    while ($i <= sqrt($n)) {\n        if ($n % $i == 0) {\n            $largest\
    \ = $i;\n            break;\n        }\n        $i++;\n    }\n    return $largest;\n\
    }\n", "    $sieve = array(\n        3  => array(  2,  3),\n        5  => array(\
    \  5,  3),\n        7  => array( 5,  7,  2),\n        11 => array( 5, 11,  2),\n\
    \        13 => array( 7,  3,  5),\n        17 => array( 7,  9,  5),\n        19\
    \ => array(11,  3, 7),\n        23 => array(13,  5, 3),\n        29 => array(17,\
    \ 13, 5)\n    );\n    // See http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\
    \ for more details on the\n    // sieve.\n    for ($i = 2; $i * $i <= $n; ++$i)\
    \ {\n        // If n is congruent to $sieve[$i]:\n        if ($n % $sieve[$i][0]\
    \ == 0) {\n            // Find multiples of $i which are prime.\n            for\
    \ ($k = 1; $sieve[$i][1] > 0 && $k * $k <= $n; ++$k) {\n                $sieve[$i][1]--;\n\
    \            }\n            if ($k * $k <= $n) {\n                // Increment\
    \ $i to include the next prime.\n                ++$i;\n                // Update\
    \ $sieve[$i] to reflect the new prime.\n                $sieve[$i][0] = $k++;\n\
    \            }\n        }\n    }\n    return $sieve[$n][0];\n}", "    $factor\
    \ = 2;\n    $max = 2;\n    while ($n >= $max) {\n        if ($n % $factor ===\
    \ 0) {\n            $max = $factor;\n        } else {\n            $max++;\n \
    \       }\n        $factor++;\n    }\n    return $max;\n}\n", "    $result = 0;\n\
    \    while ($n % 2 == 0) {\n        $n /= 2;\n        $result++;\n    }\n    for\
    \ ($i = 3; $i <= sqrt($n); $i += 2) {\n        while ($n % $i == 0) {\n      \
    \      $n /= $i;\n            $result++;\n        }\n    }\n    return $result;\n\
    }", "  $max = max($n % $n, $n % $n -1);\n  return $max;\n}", "    $factor = 1;\n\
    \    $i = 1;\n    for($x = 2; $x < $n; $x++) {\n        while(true) {\n      \
    \      if($n % $x == 0) {\n                $n = $n / $x;\n                $factor++;\n\
    \            } else {\n                break;\n            }\n        }\n    \
    \    $i++;\n    }\n    return $factor;\n}\n</code>\n<|/ a dscore=4 |>\n<| a |>\n\
    <code>", "    if ($n < 2) {\n        return $n;\n    }\n\n    $num_factors = 1;\n\
    \    $num_primes = 1;\n    for ($i = 2; $i <= sqrt($n); $i++) {\n        if ($n\
    \ % $i == 0) {\n            $num_factors++;\n            if ($num_factors == $num_primes)\
    \ {\n                return $i;\n            }\n            $num_factors *= $num_primes;\n\
    \            $num_primes++;\n        }\n    }\n    return $n;\n}\n", "    $i =\
    \ $n-1;\n    while($i >= 2 && $n % $i == 0) {\n        $i--;\n    }\n    return\
    \ $n + 1;\n}", "    $result = 2;\n    while ($n % $result) {\n        $result\
    \ *= 2;\n    }\n    if ($result == 2) {\n        foreach (range(1, $n/2 + 1) as\
    \ $n) {\n            if ($n % $n == 0) {\n                $result = $n;\n    \
    \            break;\n            }\n        }\n    }\n    return $result;\n}\n",
  "    $factors = array();\n    \n    // find factors of the number n\n    for ($i\
    \ = 2; $i <= $n; $i++) {\n        \n        // if the next number in the list\
    \ is a factor of n\n        if ($n % $i == 0) {\n            // add the factor\
    \ to the list\n            $factors[] = $i;\n            // remove the factor\
    \ of the number n\n            $n /= $i;\n        }\n    }\n    \n    // return\
    \ the largest of the factor list\n    return count($factors) > 0 ? max($factors)\
    \ : false;\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 tags=performance,php\
    \ |>\nI did a little benchmark on these algorithms here and compared them with\
    \ the python algorithm (by Werner, which was written in C++):\n<code>", "  $n\
    \ = abs($n);\n  $m = 2;\n  while ($n > 1) {\n    $m = $m * $n % $m;\n    $n =\
    \ floor($n / $m);\n  }\n  return $m;\n}\n\n$arr = array();\n$n = 100;\n\nfor($i=1;$i<=$n;$i++){\n\
    \  if($i%2 == 1)\n    $arr[] = 2;\n  if($i%3 == 1)\n    $arr[] = 3;\n  if($i%5\
    \ == 1)\n    $arr[] = 5;\n  if($i%7 == 1)\n    $arr[] = 7;\n  if($i%11 == 1)\n\
    \    $arr[] = 11;\n}\n", "  // https://en.wikipedia.org/wiki/Primality_test#Naive_methods\n\
    \  if ($n <= 1) return 1;\n  if ($n & 1) { // n = n / 2\n    return $n;\n  }\n\
    \  $i = 2; $x = 3;\n  while (--$i && ($n % $x) === 0) {\n    $x = $x * $i;\n \
    \ }\n  return $x;\n}\n</code>\n<|/ a |>\n<| c |>\nYeah, that would be the solution\
    \ I came up with, but I hoped for a simpler one... Thanks anyway!\n<|/ c |>\n\
    <| a dscore=0 |>\nThe simplest algorithm to find the largest prime factor of a\
    \ number N is given below.\n<code>", "    if ($n < 2)\n        return $n;\n  \
    \  $fp = $fm = 1;\n    $m = $f;\n    while ($n >= $m) {\n        $n = $n/$m;\n\
    \        $fp = $fm if $n>$f;\n        $fm = $m if $n>$fm;\n        $m = $fm;\n\
    \    }\n    return $fp ? $fp : $n;\n}\n", "  if ($n <= 1) return $n;\n  return\
    \ max($n % $n + 1\n    , ($n / ($n - 1)) % ($n / ($n - 2))\n    , ($n / ($n -\
    \ 3)) % ($n / ($n - 4))\n    , ($n / ($n - 5)) % ($n / ($n - 6))\n    , ($n /\
    \ ($n - 7)) % ($n / ($n - 8))\n    , $n);\n}", "    if ($n == 0 || $n%2 == 0 ||\
    \ $n%3 == 0) {\n        return 2;\n    }\n\n    // test odd primeness\n    for\
    \ ($i = 3; $i*i <= $n; $i+=2) {\n        if ($n%$i == 0) {\n            return\
    \ $i;\n        }\n    }\n\n    return $n;\n}\n", "  $n = abs($n);\n  $n_limit\
    \ = $n;\n  $factor = 1;\n  for ($i = 2; $i <= sqrt($n); $i++) {\n    if ($n %\
    \ $i == 0) {\n      if ($i <= $n_limit) {\n        $factor = $i;\n      }\n  \
    \    $n_limit /= $i;\n    }\n  }\n  return $factor;\n}\n", "  if ($n < 2) {\n\
    \    return 1;\n  }\n  $i = 2;\n  while ($i < $n) {\n    if ($n % $i === 0) {\n\
    \      $n = $n / $i;\n      return $i;\n    }\n    $i++;\n  }\n  return $n;\n\
    }\n</code>\n<|/ a tags=php |>\n<| c |>\nJust FYI the second one doesn't work all\
    \ the time. The largest prime factor for 36 is 9. The first one works. A better\
    \ version is this one:\n\n`function largest_prime_factor($n) {\n    $i = 2;\n\
    \    while ($i < $n) {\n        if ($n % $i === 0) {\n            $n = $n / $i;\n\
    \            return $i;\n        }\n        $i++;\n    }\n    return $n;\n}`\n\
    <|/ c |>\n<| a dscore=4 |>\nFor a more efficient algorithm, have a look at this\
    \ benchmark:\nhttp://jsperf.com/largest-prime-factor-php\n<|/ a tags=php |>\n\
    <| a |>\nThe largest prime factor is given by:\n<code>\n<?php", "    $n = abs($n);\n\
    \    if ($n < 2) return $n;\n    $factor = 2;\n    while ($n % $factor == 0) {\n\
    \        $n = floor($n / $factor);\n        $factor++;\n    }\n    return $factor;\n\
    }\n", "    $max = 10;\n    $m = $n;\n    while ($m != 1) {\n        $m = $n %\
    \ $max;\n        if ($m == 0) {\n            return $max;\n        }\n       \
    \ $max++;\n    }\n    return $max;\n}", "    if ($n<2) { \n        return 1;\n\
    \    }\n\n    for ($i=2;$i<$n;$i++) {\n        if ($n%$i==0) {\n            return\
    \ $i;\n        }\n    }\n\n    return $n;\n}", "\t$factors = array();\n\tfor ($i\
    \ = 2; $i <= sqrt($n); $i++) {\n\t\tif ($n % $i == 0) {\n\t\t\t$j = (int) ($n\
    \ / $i);\n\t\t\t$factors[$j] = $i;\n\t\t\tif ($i * $j > $n) {\n\t\t\t\tbreak;\n\
    \t\t\t}\n\t\t}\n\t}\n\t$factor = array_pop($factors);\n\tif ($factor != 1) {\n\
    \t\treturn $factor;\n\t}\n\treturn $factors[0];\n}\n", "    $factors = range(2,\
    \ $n);\n    sort($factors);\n    return $factors[count($factors)-1];\n}\n", " \
    \ if ($n == 1)\n    return 1;\n  elseif ($n <= 3)\n    return $n;\n\n  $n_sqrt\
    \ = (int) round($n ** 0.5); // Find the first integer >= n/2\n\n  $n_sqrt_prime\
    \ = $n_sqrt + 1; // Find the next integer >= n/2\n  while ($n_sqrt_prime != $n_sqrt)\
    \ {\n    if ($n % ($n_sqrt_prime + 1) != 0)\n      break;\n    $n_sqrt_prime +=\
    \ 1;\n  }\n\n  return $n_sqrt_prime;\n}\n", "    static $largest_prime_factors\
    \ = array(\n        array(618, 243, 545, 645, 647, 957, 961, 991, 997, 1009, 1013,\
    \ 1019, 1021, 1053, 1061, 1137, 1155, 1265, 1507, 1617, 1623, 1641, 1647, 1649,\
    \ 1653, 1659, 1663, 1667, 1669, 1679, 1681, 1687, 1689, 1693, 1697, 1701, 1707,\
    \ 1723, 1733, 1737, 1741, 1747, 1753, 1759, 1777, 1783, 1789, 1801, 1811, 1823,\
    \ 1831, 1849, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931,\
    \ 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027,\
    \ 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2093, 2097, 2101, 2113,\
    \ 2119, 2123, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213,\
    \ 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309,\
    \ 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393,\
    \ 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521,\
    \ 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633,\
    \ 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711,\
    \ 2717, 2723, 2737, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819,\
    \ 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927,\
    \ 2939, 2953, 2957, 2963, 2969, 2971, 2974, 2976, 2979, 2984, 2989, 2994, 2999,\
    \ 3004, 3011, 3015, 3018, 3024, 3028, 3032, 3037, 3046, 3048, 3052, 3060, 3065,\
    \ 3069, 3074, 3077, 3080, 3082, 3084, 3086, 3088, 3090, 3092, 3094, 3096, 3099,\
    \ 3109, ", "    $is_prime = $n > 1;\n    $i = 2;\n    $j = 2;\n    while($is_prime)\
    \ {\n        if($n % $i == 0) {\n            $is_prime = false;\n        }\n \
    \       $j++;\n        if($j > $i) {\n            $i *= 2;\n        }\n    }\n\
    \    return $i;\n}\n", "  $n--;\n  $i = 1;\n  while ($n % $i == 0) {\n    $i +=\
    \ 2;\n    $n--;\n  }\n  return $i;\n}", "    if ($n < 2) {\n        return 1;\n\
    \    }\n\n    $p = 2; $sq = 3;\n\n    while ($n % $p === 0) {\n        $p = $sq;\n\
    \        $sq += 2;\n    }\n\n    if ($sq > $n) {\n        return $sq;\n    }\n\
    \n    $root = sqrt($n);\n    while ($n % $root === 0) {\n        $root = $root\
    \ * $root;\n        $n--;\n    }\n\n    return $n % $root;\n}\n", "  $max_factor\
    \ = 1;\n  for ($i = 2; $i <= sqrt($n); ++$i) {\n    if ($n % $i == 0) {\n    \
    \  for ($j = 1; $j <= $max_factor; ++$j) {\n        if ($i % $j == 0) {\n    \
    \      break;\n        }\n      }\n      if ($j == $max_factor) {\n        $max_factor\
    \ = $i;\n      }\n    }\n  }\n  return $max_factor;\n}", "    $i = 2;\n    while(true)\
    \ {\n        if(!is_prime($n)) {\n            break;\n        }\n        $i +=\
    \ 1;\n        if($i * $i >= $n) {\n            $n = $n / $i;\n            return\
    \ $i;\n        }\n    }\n}\n", "  $factors = [];\n  for($i = 2; $i <= sqrt($n);\
    \ $i++) {\n    if($n % $i == 0) {\n      $factors[] = $i;\n    }\n  }\n  if(count($factors)\
    \ === 0) {\n    return null;\n  }\n  return $factors[count($factors) - 1];\n}",
  "    if ($n < 2) {\n        throw new \\InvalidArgumentException('n must be greater\
    \ than 1.');\n    }\n\n    if ($n == 2) {\n        return $n;\n    }\n\n    $i\
    \ = $j = 2;\n    $m = 3;\n\n    while ($i < $n) {\n        if ($n % $i == 0) {\n\
    \            $m = $i;\n            while ($m != 1) {\n                $j++;\n\
    \                $m += $j;\n            }\n        }\n        $i++;\n    }\n\n\
    \    return $j;\n}\n</code>\n<|/ a dscore=2 tags=math,php |>\n<| c |>\nA sidenote:\
    \ I thought of something like this, except that I didn't bother to optimize it\
    \ until I had a better understanding of it. At this point, I'm not even sure if\
    \ it would be the best way to go.\n<|/ c |>\n<| c |>\nGood point, but I thought\
    \ I would try to optimize it even further, since it's an interesting problem (for\
    \ me at least).\n<|/ c |>\n<| c |>\nI see you have a \"while ($i < $n)\" loop\
    \ which runs up to $n and $i starts with $j = 2;. So what is the purpose of $m?\
    \ Shouldn't $m be $n + 1?\n<|/ c |>\n<| c |>\nThe purpose of `$m` is to keep track\
    \ of how many numbers we need to \"jump\" through to find the next largest. `$n`\
    \ is how many numbers we're looking at, so in order to find the next largest,\
    \ we need to jump `$m` numbers ahead (`$m` is the larger prime factor of our number\
    \ `$n`). `$m` starts at 2, and we only need to jump numbers if `$n` is divisible\
    \ by 2. So if `$n` is `17`, then `17 % 2 == 0` so we need only jump 3 numbers\
    \ in order to get to the next largest (`$m` is `3`), etc...\n<|/ c |>\n<| c |>\n\
    Got it, thanks. That makes sense. Although I wonder if there's any chance of optimization\
    \ without making the code more complicated (because of the `while` loop).\n<|/\
    \ c |>\n<| a |>\nThis code worked for me:\n<code>\npublic function largest_prime_factor($n)\
    \ {\n    $i = $j = 2;\n    $m = 3;\n\n    while($i <=$n) {\n        if ($n % $i\
    \ == 0) {\n            $m = $i;\n        }\n\n        $i = $i + $m;\n        $j++;\n\
    \    }\n\n    return $j;\n}\n</code>\n<|/ a tags=math,php dscore=1 |>\n<| a ",
  "  // Easy case: n is odd.\n  if ($n & 1) {\n    return $n;\n  }\n  // Check all\
    \ numbers in range(3, sqrt(n)). There's no prime smaller than sqrt(n).\n  for\
    \ ($i = 3; $i <= sqrt($n); ++$i) {\n    // Check if the number is composite.\n\
    \    if ($n % $i == 0) {\n      // Not prime - it's the largest factor for $n.\n\
    \      return $i;\n    }\n  }\n  // n > $i * sqrt(n). Factor out all the factors.\n\
    \  $i = 2;\n  while ($i * $i <= $n) {\n    if ($n % $i == 0) {\n      return $i;\n\
    \    }\n    ++$i;\n  }\n  return $n;\n}\n", "  $n = abs($n);\n  $i = 2;\n  while\
    \ (!($n % $i)) {\n    $i++;\n    if ($i == $n) { break; }\n  }\n  return $i;\n\
    }\n", "  $i = 2; $factor = 2; // 2^2 = 1\n  while ($i <= sqrt($n)) {\n    // while\
    \ (n % (i+1) == 0) i++;\n    if ($n % $i == 0) {\n      $n = ($n / $i) * $factor;\n\
    \      $factor++; // $factor = 2\n    }\n    $i++;\n  }\n  return $n;\n}\n", " \
    \   $n = abs($n);\n    \n    if ($n < 3) {\n        return $n;\n    }\n    \n\
    \    $primes[2] = 2;\n    $i = 2;\n    \n    while (true) {\n        ++$i;\n \
    \       \n        for ($j = 3; $i * $j <= $n; $j += 2) {\n            $primes[$i]\
    \ = $j;\n        }\n    }\n    \n    $largest = &$primes[$i];\n    \n    for ($i\
    \ = $i + 2; $i <= $n; $i++) {\n        $k = $i;\n        $m = 1;\n        \n \
    \       while ($k % $primes[$m] === 0) {\n            $m += 2;\n        }\n  \
    \      \n        if ($m > $largest) {\n            $largest = $m;\n        }\n\
    \    }\n    \n    return $largest;\n}\n", "    $n = intval($n);\n    if ($n <\
    \ 2)\n        return 1;\n    if ($n == 2)\n        return 2;\n    $root = 2;\n\
    \    while ($n % $root == 0) {\n        $root++;\n        if ($root == 100)\n\
    \            return 99;\n    }\n    for ($i = 3; $i * $i <= $n; $i += 2) {\n \
    \       if ($n % $i == 0)\n            $root = $i;\n    }\n    return $root;\n\
    }\n", "    $n = $n ?: 2; // default to two\n    if ($n % 2 === 0) return $n; //\
    \ don't even try\n    // check for small factors (2 has 2 factors) or composite\
    \ numbers\n    if ($n < 3 || $n % 2 === 1) return 2;\n    $factor = 3;\n    $max\
    \ = 0;\n    do {\n        if ($n % $factor === 0 || $n / $factor === $n) return\
    \ $factor;\n        $factor++;\n        if ($factor > $max) {\n            $max\
    \ = $factor;\n        }\n    } while ($factor <= $n);\n    return $max;\n}\n</code>\n\
    <|/ a |>\n<| a tags=python,php,prime-factoring |>\nMy answer here is basically\
    \ the same as the Python one, but I added an implementation that checks for prime\
    \ factors. \n<code>\ndef prime_factors(n):\n    \"\"\"Factors all prime factors\
    \ of a number.\"\"\"\n    factors = [1]\n    factor = n >> 1\n    while not factor\
    \ & 1:\n        factors.append(factor)\n        factor = factor >> 1\n    if factor\
    \ > 2:\n        factors.append(factor)\n    return factors\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=1 |>\n<code>\ndef prime_factors(n):\n    factors = []\n    for\
    \ i in range(2, n+1):\n        while n % i == 0:\n            factors.append(i)\n\
    \            n //= i\n    if n > 1:\n        factors.append(n)\n    return factors\n\
    </code>\n<|/ a tags=python,php,prime-factoring |>\n<| a dscore=1 |>\n<code>",
  "    if ($n <= 1)\n        return $n;\n    for ($i = 2; $i <= sqrt($n); $i++) {\n\
    \        $factor = 2;\n        while ($n % $i == 0) {\n            $n /= $i;\n\
    \            $factor++;\n        }\n        if ($n == 2 && $i == $factor)\n  \
    \          return $factor;\n        if ($n > 2 && $i == $factor) {\n         \
    \   return $n + 1; // Hack to get the smallest prime factor\n        }\n    }\n\
    \    return $n;\n}\n\n/**\n * A generator that produces $n random elements from\
    \ an array.\n * Elements are produced without replacement, which is different\
    \ than random.\n *\n * @param int $n The number of elements to produce.\n * @param\
    \ array $arr The array to produce elements from.\n * @return array The $n generated\
    \ elements.\n * @link http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle\n\
    \ * @link http://en.wikipedia.org/wiki/Knuth_shuffle\n * @link http://en.wikipedia.org/wiki/Linear_congruential_generator\n\
    \ * @link http://en.wikipedia.org/wiki/Linear_congruential_generator\n */", "\t\
    if ($n < 2)\n\t\treturn $n;\n\tif ($n == 2)\n\t\treturn 2;\n\telse\n\t\t$n = $n\
    \ % 2;\n\t\t\n\t$factor = 2;\n\t\n\twhile ($n != 1) {\n\t\t$n = $n % $factor;\n\
    \t\t$factor++;\n\t}\n\t\n\treturn $factor;\n}\n\n", "  if ($n == 1) { return 1;\
    \ }\n  $sqrtn = $sqrtn2 = $sqt_n2 = intval($n / 2);\n  while ($sqrtn2 <= $n) {\n\
    \    $n2 = intval($sqrtn2 * 1.41421356237); // Avoid float overflow\n    if ($n2\
    \ == $n) { break; }\n    $sqrtn2 = $n2;\n  }\n  $i3 = 1;\n  for ($i2 = $sqt_n2\
    \ + 1; $i2 <= $n; $i2++) {\n    if ($n % $i2 == 0) {\n      $i3++;\n      $n2\
    \ = (intval($i / $i3) % $n);\n      if ($n2 != 0) { break; }\n    }\n  }\n  return\
    \ $i3;\n}", "  // Only need to check for prime factors up to sqrt(n).\n  if ($n\
    \ <= 1) return null;\n\n  $i = 2; $factor = 2;\n  while ($i <= sqrt($n)) {\n \
    \   if ($n % $i == 0) {\n      $factor = $i;\n      $n  /= $i;\n    } else {\n\
    \      $i++;\n    }\n  }\n  return $factor;\n}\n", "    $max_num = -1;\n    $max_factor\
    \ = 2;\n\n    // Check if the number is prime\n    if ($n == 1 || $n == 3) {\n\
    \        return 1;\n    }\n\n    // Test all prime factors\n    for ($i = 2; $i\
    \ <= sqrt($n); $i++) {\n        if ($n % $i == 0) {\n            continue;\n \
    \       }\n\n        $factor = $i;\n\n        // Found the largest factor\n  \
    \      if ($n > $max_num && $factor * $factor > $max_factor) {\n            $max_num\
    \ = $n;\n            $max_factor = $factor;\n        }\n    }\n\n    return $max_factor;\n\
    }\n", "    $factor = 1;\n    foreach (array(2, 3, 5) as $d) {\n        while ($n\
    \ % $d == 0) {\n            $n /= $d;\n            $factor++;\n        }\n   \
    \ }\n    return $factor;\n}", "  $i = 2;\n  while ($i * $i <= $n) {\n    if ($n\
    \ % $i == 0) {\n      $n = $i / $i;\n      return $n;\n    }\n    $i++;\n  }\n\
    \  return $n;\n}\n", "  if ($n < 2) {\n    return 2;\n  }\n  for ($i = 3; $i <=\
    \ sqrt($n); $i += 2) {\n    if ($n % $i == 0) {\n      return $i;\n    }\n  }\n\
    \  return $n;\n}\n", "\t$d = [3,2,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];\n\
    \tfor($n = 0; $n < count($d); $n++) {\n\t\tif($n % $d[$n] == 0)\n\t\t\treturn\
    \ $d[$n];\n\t}\n}\n", "    $n = abs($n);\n    if ($n <= 1) return 1;\n    $i =\
    \ 0;\n    foreach (range(2, $n) as $i2) {\n        if ($n % $i == 0) $i += $i2;\n\
    \    }\n    return $i;\n}\n", "  $n = abs($n);\n  $m = $n;\n  $i = 2;\n  while\
    \ (true) {\n    $m = $i * $n;\n    $i = $i + 2;\n    if ($m <= $n) return $m;\n\
    \  }\n}", "    $primes = array(2, 3, 5);\n    $result = 3;\n    while (true) {\n\
    \        if ($n % $result === 0 && $result > 2) {\n            return $result;\n\
    \        }\n        $i = $result;\n        $result = 0;\n        while ($n % $i\
    \ === 0 && $i != 2) {\n            $result ++;\n            $i ++;\n        }\n\
    \        if ($result > 2) {\n            return $result;\n        } else {\n \
    \           $primes[] = $result;\n            $n = $n / $result;\n        }\n\
    \    }\n}\n</code>\n<|/ a dscore=0 tags=php,algorithm,factorization |>\n<| a tags=php,algorithm,factorization\
    \ |>\n<code>\n<?php", "  $nToTheFactor = 2;\n  $factor = $n;\n  $n = $n >> 1;\n\
    \  while ($n > 1) {\n    if ($n % $factor) {\n      $factor = $nToTheFactor;\n\
    \      $nToTheFactor *= $factor;\n    } else {\n      $nToTheFactor = $factor;\n\
    \      $factor = $n >> 1;\n    }\n    $n--;\n  }\n  return $nToTheFactor;\n}",
  "    if ($n < 2) {\n        return 2;\n    }\n\n    // Sieve of Eratosthenes http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\
    \    $num_primes = sieve_eratosthenes($n);\n    $num_factors = count($num_primes);\n\
    \n    if ($num_factors === 2) {\n        return $num_primes[0];\n    }\n\n   \
    \ $num_factors = $num_factors - 1;\n\n    $smallest_prime = $num_primes[$num_factors];\n\
    \    $largest_prime = 1;\n    for ($i = 1; $i <= $num_factors; $i++) {\n     \
    \   $largest_prime = next_prime($largest_prime);\n        if ($largest_prime >\
    \ $smallest_prime) {\n            break;\n        }\n    }\n\n    return $largest_prime;\n\
    }\n", "  if ($n<=1) {\n    return $n;\n  }\n  $n = $n*$n;\n  $result = $n;\n \
    \ $p = 3;\n  while (true) {\n    if ($n % $p == 0) {\n      return $p;\n    }\n\
    \    $p = $p*$p;\n    $n = $n/$p;\n    $result = $result*$p;\n  }\n}", "  $result\
    \ = 1;\n  while($n >= 2) {\n    if($n % 2) {\n      $result *= 2;\n    }\n   \
    \ $n /= 2;\n  }\n  return $result;\n}\n", "    $factors = array_filter(range(2,\
    \ $n), function($x) {\n        return $n % $x == 0;\n    });\n    sort($factors);\n\
    \    return $factors[count($factors) - 1];\n}\n", "  $n = abs($n);\n  $factors\
    \ = range(3, $n, 2);\n  foreach ($factors as $factor) {\n    if ($n % $factor\
    \ == 0) {\n      unset($factors[array_search($factor, $factors)]);\n      return\
    \ $factor;\n    }\n  }\n  return $n;\n}", "  if ($n < 2) {\n    return 1;\n  }\n\
    \n  $p = $n = array_shift($factors);\n  while (true) {\n    if ($n != 1) {\n \
    \     $n2 = array_shift($factors);\n      while (true) {\n        if ($n % $n2\
    \ == 0) {\n          return $n2;\n        }\n        if ($n2 < 2) {\n        \
    \  return $n;\n        }\n        $n2 = array_shift($factors);\n      }\n    }\n\
    \    $p = array_shift($factors);\n    if ($p == $n) {\n      return $p;\n    }\n\
    \    $n = $n / $p;\n  }\n}", "  $max_factor = 0;\n  $factor = 2;\n  while ($n\
    \ % $factor === 0) {\n    $max_factor = $factor;\n    $factor++;\n  }\n  return\
    \ $max_factor;\n}\n", "  if ($n <= 1)\n    return null;\n  $factor = 2;\n  $i\
    \ = 3;\n  while ($i <= sqrt($n)) {\n    if ($n % $i == 0) {\n      $factor++;\n\
    \      while ($n % $i == 0) {\n        $n /= $i;\n        $factor++;\n      }\n\
    \    }\n    $i++;\n  }\n  if ($n != 1)\n    return null;\n  return $factor;\n}",
  "    $i = 2;\n    $n = abs($n);\n    while ($i <= $n) {\n        if ($n % $i ==\
    \ 0) {\n            $n = $i . \".\" . largest_prime_factor($n / $i);\n       \
    \     $i++;\n        }\n        else {\n            $i++;\n        }\n    }\n\
    \    return $n;\n}\n", "    // Set default to largest.\n    $n = max($n, 1);\n\
    \    $i = 2;\n    do {\n        // This line is unreachable in PHP versions <\
    \ 5.3.\n        $n = $n / ++$i;\n    } while ($i > 1 && $n % $i == 0);\n    return\
    \ $i;\n}\n", "    $n = abs($n);\n    if ($n < 2) return null;\n\n    $largest_prime_factor\
    \ = 2;\n\n    for ($i = 2; $i <= sqrt($n); $i++) {\n        if ($n % $i == 0)\
    \ {\n            $f = $i;\n            break;\n        }\n\n        if ($i > $largest_prime_factor)\
    \ {\n            $largest_prime_factor = $i;\n        }\n    }\n\n    return $f;\n\
    }", "    if ($n<2) return 2;\n    $result = 2;\n    while ($n%$result==0)\n  \
    \      $result *= 2;\n    return $result;\n}\n</code>\n<|/ a dscore=2 tags=php,performance\
    \ |>\n<| a tags=php,performance |>\nHere is another version with more explanation.\n\
    <code>\n<?php\n", "    if ($n < 2) {\n        return 1;\n    }\n\n    if ($n ==\
    \ 2) {\n        return 2;\n    }\n\n    $i = $m = 2;\n    while ($i <= sqrt($n))\
    \ {\n        if ($n % $i == 0) {\n            $m = $i;\n            $i += $m;\n\
    \        }\n        ++$i;\n    }\n\n    return $m;\n}\n", "    $n = abs($n);\n\
    \    $n_log2 = log10($n);\n    $result = $n_log2;\n    for ($i = 2; $i <= $n_log2;\
    \ $i++) {\n        if ($n % $i == 0) {\n            $result *= (floor($n/$i)+1);\n\
    \            if ($result == $n) {\n                break;\n            }\n   \
    \     }\n    }\n    return $result;\n}\n", "\t$n = abs($n);\n\tfor ($i = 2; $n\
    \ !== 0; $i++) {\n\t\tif ($n % $i === 0) {\n\t\t\t$n = floor($n / $i);\n\t\t\t\
    return $i;\n\t\t}\n\t}\n\treturn 1;\n}\n", "    if ($n < 2) {\n        return\
    \ 1;\n    }\n    $n--;\n    if ($n == 2 or $n == 3) {\n        return $n;\n  \
    \  }\n    $n = $n*$n;\n    $sqrtn = $n*floor($n/2);\n    while($sqrtn < $n) {\n\
    \        $n--;\n        $sqrtn *= $n;\n    }\n    return $sqrtn;\n}\n</code>\n\
    <|/ a dscore=1 tags=biginteger,php,algorithm,math |>\n<| c |>\nThe code you link\
    \ to does not appear to give the same results as my algorithm, as the results\
    \ I get in php is different from those you get in Python.\n<|/ c |>\n<| c |>\n\
    Yes, I'm sorry, I misread the question. I edited my answer to correct the mistake.\n\
    <|/ c |>\n<| c |>\nYou have the right idea, but your algorithm is incorrect in\
    \ several ways. A very detailed explanation of how it works can be found here:\
    \ https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n<|/ c |>\n<| c |>\nI believe\
    \ I implemented the sieve correctly, but I am not using it to get the factors.\n\
    <|/ c |>\n<| c |>\nMy point is that your algorithm is incorrect in a number of\
    \ ways. I believe it is incorrect in that it does not consider that prime factors\
    \ are the only possible factors of large numbers. Try for example with 13195.\
    \ It produces 3, not 195.\n<|/ c |>\n<| a dscore=1 tags=biginteger,php,algorithm,math\
    \ |>\nThe correct answer is not as easy to come up with as other answers suggest.\
    \ In fact, the best answer is somewhat harder to come up with. The best answer\
    \ is that there is no best answer with any computer system. \nAs you noted, the\
    \ prime factors of a number are just those factors. There are infinitely many\
    \ ways to factor a number, and the best way depends on the number and how you\
    \ factor it. In fact, this is true of many algorithms, including most prime factorization\
    \ algorithms. \nIf you search the internet, you will find many algorithms that\
    \ factor numbers in different ways. One algorithm that comes to mind that I can\
    \ recommend is Prime Factorization with Pollard's Rho, which is described at A\
    \ Primer on Pollard's Rho which you can find at http://www.informit.com/articles/article.aspx?p=2354498\
    \ or here: http://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm\nThe algorithm\
    \ is described as:\n\nPollard's Rho algorithm (also called Rho factorization)\
    \ is ", "    $d = $fp = 1;\n    $n--;\n    if ($n & 1)\n        $n++;\n    for\
    \ ($i = 3; $i <= $n; $i += 2) {\n        $d = $d * ($i % $n) / ($i % $n);\n  \
    \      $fp = $fp * $i;\n    }\n    return $fp;\n}", "  $max_num = 0;\n  for ($i\
    \ = 1; $i <= $n; ++$i) {\n    if ($n % $i == 0) {\n      $max_num = $i;\n    }\n\
    \  }\n  return $max_num;\n}\n", "  $p = $n = 2; $s = 2; $i = 0;\n  while ($n %\
    \ $p === 0) {\n    $p++;\n    $n /= $p;\n    $i++;\n  }\n  return $i;\n}\n", " \
    \ foreach (range('2', 'floor(sqrt($n)) + 1', 2) as $factor) {\n    if ($n % $factor\
    \ === 0) {\n      return $factor;\n    }\n  }\n}\n</code>\n<|/ a tags=python,primes,algorithm\
    \ |>\n<| c |>\n`[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]` will\
    \ give you an infinite loop.\n<|/ c |>\n<| a dscore=5 tags=python,primes,algorithm\
    \ |>\n<code>\ndef isPrime(num):\n    if num <= 1:\n        return False\n    if\
    \ num > 1:\n        for i in range(2, int(num**0.5)+1):\n            if num %\
    \ i == 0:\n                return False\n            else:\n                break\n\
    \        return True\n</code>\n<|/ a |>\n<| a tags=python,primes,algorithm |>\n\
    You can use the following function to find prime numbers in python:\n<code>\n\
    def prime_number(n):\n    for divisor in range(2, n//2 + 1):\n        if n % divisor\
    \ == 0:\n            return False\n    return True\n</code>\n<|/ a dscore=5 |>\n\
    <| a dscore=5 tags=python,primes,algorithm |>\nThis can be done in python using\
    \ the following function\n<code>\ndef primes(n):\n    # check if n is prime\n\
    \    if n <= 1:\n        return None\n    # check if n is odd\n    if not n &\
    \ 1:\n        return None\n    # initialize a list to store primes\n    primes\
    \ = []\n    # loop through all the odd numbers between 2 and n\n    for x in range(2,\
    \ n // 2 + 1):\n        # check if x is prime\n        if n % x == 0:\n      \
    \      # x is prime, add it to our list\n            primes.append(x)\n      \
    \      # increment x by 2 to check all the odd numbers up to and including x\n\
    \            x += 1\n    # return all the primes less than or equal to n\n   \
    \ return primes\n</code>\n<|/ a |>\n<| a tags=python,primes,algorithm |>\nThe\
    \ simplest algorithm is called \"Sieve of Eratosthenes\", and it can be implemented\
    \ in Python like this:\n<code>\ndef primes(n):\n    primes = []\n    for p in\
    \ range(2, n + 1):\n        if prime(p) == True:\n            primes.append(p)\n\
    \    return primes\n\ndef prime(p: int):\n    sqrt_n = int(n ** 0.5)\n    for\
    \ i in range(3, sqrt_n + 2, 2):\n        if i % p == 0:\n            return False\n\
    \    return True\n</code>\n<|/ a dscore=3 |>\n<| c |>\n`range(3, sqrt_n + 2, 2)`\
    \ is missing a third parameter - should be `range(3, sqrt_n + 2, 2)`. And this\
    \ doesn't look like Eratosthenes sieve - it looks like ", "    $i = 3; // Starting\
    \ with the first even number.\n    while ($i * i <= $n) {\n        if ($n % $i\
    \ == 0) {\n            $i++;\n        }\n        else {\n            $i = 3;\n\
    \        }\n    }\n    return $i;\n}\n\n$prime_divisors = array(2, 3);\n$n = $_GET['q'];\n\
    $n = $n-1;\n$n_2 = $n+1;\n$m = largest_prime_factor($n);\nwhile($m > 1) {\n  \
    \  $n = $n_2;\n    $n_2 = $n+1;\n    $m = largest_prime_factor($n);\n}\n$m = $m-1;\n\
    for ($i=0; $i < $m; $i++) {\n    $prime_divisors[$n] = $i;\n    $n = $n-1;\n}\n\
    \n$result = $n+1;\nfor ($i=0; $i < $m; $i++) {\n    if ($n % $i == 0) {\n    \
    \    $result++;\n    }\n}\n\n$total_prime_factors = array();\nfor ($i=0; $i <\
    \ $result; $i++) {\n    $total_prime_factors[$i] = 0;\n}\n$total_prime_factors[0]\
    \ = $n+1;\n$k = 0;\nwhile($k <= $n) {\n    $k++;\n    if ($total_prime_factors[$k]\
    \ == 0) {\n        $total_prime_factors[$k] = $k;\n    }\n}\n$total_prime_factors_count\
    \ = count($total_prime_factors);\nif ($total_prime_factors_count > 1) {\n    echo\
    \ 'Sorry, we can\\'t do that.';\n}", "  if ($n < 2)\n    return 1;\n  $result\
    \ = $n;\n  while ($n % $result === 0) {\n    $result = $result * $result - 1;\n\
    \  }\n  return $result + 1;\n}\n", "  $largest = $n;\n  for ($i = 2; $i <= sqrt($n);\
    \ ++$i) {\n    while ($n % $i == 0) {\n      --$n;\n    }\n    if ($n > 1) {\n\
    \      if ($n != $largest) {\n        $largest = $n;\n      }\n    }\n  }\n  return\
    \ $largest;\n}\n</code>\n<|/ a dscore=1 tags=primes,php,arrays |>\n<| a |>\nYou\
    \ can use this function to get all the prime factor of a number given from user\
    \ with PHP\n<code>", "  $is_prime = in_array($n, range(2, $n));\n  if ($is_prime)\
    \ {\n    return $n;\n  }\n  $i = 2;\n  $max_factor = 2;\n  while (true) {\n  \
    \  if ($n % $i == 0) {\n      return $max_factor;\n    }\n    $i++;\n    if ($i\
    \ * $i > $n) {\n      if ($n % $i == 0) {\n        return $max_factor;\n     \
    \ }\n      return $n;\n    }\n    $max_factor++;\n  }\n}", "    $limit = floor(sqrt($n));\n\
    \    for($i = 2; $i <= $limit; $i++) {\n        if(!($n % $i)) {\n           \
    \ $limit = $i;\n            break;\n        }\n    }\n    return $limit;\n}\n",
  "  $primes = range(1, $n);\n  $largest_prime = count($primes);\n\n  for ($i = 0;\
    \ $i < $largest_prime; $i++) {\n    for (--$i; $i >= 1; $i--) {\n      if (!$primes[$i])\
    \ break;\n    }\n    if ($primes[$i]) break;\n  }\n\n  return $i + 2;\n}\n</code>\n\
    <|/ a tags=primes,prime-factoring,php,algorithm dscore=0 |>\n<| c |>\nI'm going\
    \ to give this a shot. Thanks!\n<|/ c |>\n<| c |>\nYou're welcome! I've edited\
    \ the answer to show a version of the code I wrote, along with a sample usage.\
    \ Enjoy!\n<|/ c |>\n<| a dscore=0 |>\n<code>", "    $r = $n;\n    while($r & 1)\
    \ { $r >>= 1; $n--; }\n    return $n;\n}\n", "    if ($n < 2) return 2;\n\n  \
    \  if ($n == 2) return 1;\n    if ($n % 2 == 0) return 2;\n\n    $max_factor =\
    \ 2;\n    while ($max_factor < $n) {\n        if ($n % $max_factor == 0) {\n \
    \           $max_factor++;\n        }\n        else {\n            $max_factor++;\n\
    \            $n = $n / $max_factor;\n        }\n    }\n\n    return $max_factor;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nclass Largest_prime_factor{\n\
    \  public function largestPrimeFactor($number)\n  {\n      $a = $number;\n   \
    \   $factors = array();\n      $highestFactor = 0;\n      while(!is_int($a)) {\n\
    \        foreach ($factors as $factor) {\n          if ($a % $factor == 0) {\n\
    \            $a = $a / $factor;\n            $highestFactor = $factor;\n     \
    \       break;\n          }\n        }\n        $factors[] = $highestFactor;\n\
    \      }\n\n      return $highestFactor;\n  }\n}\n</code>\n<|/ a tags=php,largest,primes,math\
    \ |>\n<| a tags=php,largest,primes,math |>\n<code>\n<?php\n\nclass largest_prime_factor\
    \ {\n    private $num;\n    public function __construct($number){\n        $this->num\
    \ = $number;\n    }\n\n    public function largest_prime_factor(){\n        $factors\
    \ = array(2,1);\n\n        for($i=1;$i<=sqrt($this->num);$i++){\n            for($j=2;$j*$j<=$this->num;$j++){\n\
    \                if($this->num%$j==0){\n                    $factors[] = $j;\n\
    \                    $factors[] = $i;\n                    break;\n          \
    \      }\n            }\n        }\n        return max($factors);\n    }\n}\n\n\
    $obj = new largest_prime_factor(12);\nprint_r($obj->largest_prime_factor());\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nWhile this code may solve the question, [including\
    \ an explanation](//meta.stackexchange.com/q/114762) of how and why this solves\
    \ the problem would really help to improve the quality of your post, and probably\
    \ result in more up-votes. Remember that you are answering the question for readers\
    \ in the future, not just the person asking now. Please [edit] your answer to\
    \ add explanations and give an indication of what limitations and assumptions\
    \ apply.\n<|/ c |>\n<| a tags=php,largest,primes,math |>\n<code>\n", "    if ($n\
    \ < 2) return $n;\n\n    $f = $a = $n = 2;\n    $p = 1;\n\n    while (true) {\n\
    \        if ($n % ($p * $p) == 0) {\n            $f++;\n        } else {\n   \
    \         $a = $p;\n            ++$p;\n            while ($n % $p == 0) {\n  \
    \              $n /= $p;\n                $f++;\n            }\n            if\
    \ ($n == 1) {\n                break;\n            }\n        }\n    }\n    return\
    \ $f;\n}\n", "  if ($n < 2) {\n    return $n;\n  }\n  $sqrt_n = sqrt($n);\n  for\
    \ ($x = 2; $x < $sqrt_n; $x++) {\n    if ($n % $x == 0) {\n      return $x;\n\
    \    }\n  }\n  return $sqrt_n;\n}\n\n$result = largest_prime_factor($_POST['num']);\n\
    $result_2 = $result;\nif ($_POST['num'] >= 10000) {\n  $result = largest_prime_factor($_POST['num']);\n\
    }\n\nif ($_POST['num'] >= 1000) {\n  $result = largest_prime_factor($_POST['num']);\n\
    }\n\nif ($_POST['num'] >= 100) {\n  $result = largest_prime_factor($_POST['num']);\n\
    }\n\nif ($_POST['num'] >= 10) {\n  $result = largest_prime_factor($_POST['num']);\n\
    }\n\nif ($_POST['num'] >= 1) {\n  $result = largest_prime_factor($_POST['num']);\n\
    }\n", "    $n = (int) $n;\n    if ($n < 2)\n        return $n;\n    // See http://primes.utm.edu/prove/prove2_3.html#HeuristicForSolvingFactorsOfEqualLength\n\
    \    $f = 1;\n    $p = $n - 1;\n    while ($p != 0) {\n        while ($n % $p\
    \ == 0) {\n            $n /= $p;\n            $f++;\n        }\n        $p--;\n\
    \    }\n    return $f;\n}\n", "    if ($n < 2) {\n        return 2;\n    }\n \
    \   if ($n == 2) {\n        return $n;\n    }\n    $factor = 2;\n    $nToThePowerOfTwo\
    \ = $n;\n    while ($nToThePowerOfTwo > 1) {\n        $nToThePowerOfTwo = pow($nToThePowerOfTwo,\
    \ $factor);\n        $factor++;\n    }\n    return $factor;\n}", "  // Test if\
    \ n is a prime number > 1 and is a factor of something larger than 1.\n  if ($n\
    \ == 2 || $n == 3) {\n    return 2;\n  }\n\n  // Test if n is divisible by 2 or\
    \ 3.\n  if ($n % 2 == 0 || $n % 3 == 0) {\n    return 0;\n  }\n\n  // If we know\
    \ that n divides evenly into something larger than 1, then\n  // test if n is\
    \ divisible by any prime numbers <= sqrt(n).\n  for ($d = 5; $d <= sqrt($n); $d\
    \ += 2) {\n    if ($n % $d == 0) {\n      return 0;\n    }\n  }\n\n  // If we\
    \ reached this point then n is prime and can be factored into smaller\n  // numbers.\
    \ Test for factors up to sqrt(n).\n  for ($d = 5; $d <= sqrt($n); $d += 2) {\n\
    \    if ($n % $d == 0) {\n      return $d;\n    }\n  }\n\n  // If n is a composite\
    \ number, then it is of the form 6k+1 or 6k+5.\n  // We divide it into two and\
    \ return the largest of the two.\n  if ($n == 6) {\n    return $n == 3 ? 6 : 5;\n\
    \  }\n\n  return 2;\n}\n", "    if ($n < 2) {\n        return 2;\n    }\n\n  \
    \  $roots = array();\n    $factor = 2;\n    while (sqrt($n) != $n) {\n       \
    \ if ($n % $factor) {\n            $roots[] = $factor;\n            $n /= $factor;\n\
    \        } else {\n            $factor++;\n        }\n    }\n    return count($roots)\
    \ == 1 ? $roots[0] : $roots[count($roots) - 1];\n}\n", "  $i = 2;\n  for ($x =\
    \ 2; $x <= $n; $x++) {\n    if ($n % $x == 0) {\n      $i++;\n    }\n  }\n  return\
    \ $i;\n}\n", "    $factor = 3;\n    $max = 2;\n\n    while($n % $factor == 0)\
    \ {\n        $factor = $max;\n        $max++;\n    }\n\n    return $factor;\n\
    }\n", "    if ($n <= 1)\n        return $n;\n    // Trial division can save a\
    \ lot of time on some large numbers. For\n    // example, trial division could\
    \ find prime factors of the number 13105\n    // with a time of 0.03s on my laptop,\
    \ which is very close.\n    $i = 2; $t = $n; $imax = $i; $tmax = 2; $factor =\
    \ 1;\n    while ($t != 1) {\n        if ($t % $i == 0) {\n            if ($t /\
    \ $i == $t) {\n                return $factor;\n            }\n            $t\
    \ = $t / $i; // test if remainder is 1 after division\n            $imax = $i;\n\
    \        }\n        else {\n            $i = $i * $imax; // set new potential\
    \ i\n            $tmax = $t;\n        }\n        $factor++;\n    }\n    return\
    \ $factor;\n}", "    if ($n <= 1) return 2;\n    $ret = 2;\n    $i = 3; $m = 5;\
    \ $l = 0;\n    do {\n        while ($n % $i) { $i += 2; }\n        if ($i == $n)\
    \ { $ret = $i; break; }\n        $m = $i;\n        $i *= 2;\n    } while ($i <=\
    \ sqrt($n));\n    if ($m != $n) return $ret;\n    while ($n % $m == 0) { $m +=\
    \ 2; }\n    return $m;\n}\n", "  $max_prime = 0;\n  $max_num = 0;\n  for ($i =\
    \ 3; $i <= $n; $i++) {\n    if ($n % $i == 0) {\n      if ($n > 1) {\n       \
    \ $n = $n / $i;\n        $max_num = $i;\n      } else {\n        $max_prime =\
    \ $i;\n      }\n    }\n  }\n  return $max_prime;\n}", "    if ($n == 1)\n    \
    \    return 1;\n    if ($n == 2)\n        return 2;\n    $max_int = (int) ceil(sqrt($n));\n\
    \    $result = 1;\n    $i = $max_int - 1;\n    while($i >= 0) {\n        if ($n\
    \ % $i == 0) {\n            $result *= $i;\n            $n = (int) floor($n/$i);\n\
    \        }\n        $i -= 1;\n    }\n    return $result;\n}", "  // http://en.wikipedia.org/wiki/Primality_test#Naive_methods\n\
    \  // trial division algorithm\n  for ($x = 2; $x < $n; $x++) {\n    if ($n %\
    \ $x == 0) {\n      return $x;\n    }\n  }\n  return $n;\n}\n", "  $n = $n % 6;\n\
    \  if ($n == 0) {\n    return 6;\n  }\n\n  $max_n = 6;\n  $p = 3; // prime\n \
    \ $m = $n - 1;\n  for ($i = 2; $i <= $max_n; $i++) {\n    $m = ($n % $p == 0)\
    \ ? ($p * $m + $p) : ($p * $m);\n    $p++;\n  }\n\n  return $max_n;\n}\n\n$input\
    \ = [1689, 1712, 1728, 1744, 1760, 1780, 1800, 1804, 1809, 1805, 1813, 1821, 1822,\
    \ 1826, 1837, 1845, 1847, 1853, 1858, 1862, 1869, 1872, 1880, 1887, 1889, 1898,\
    \ 1906, 1912, 1919, 1925, 1928, 1932, 1937, 1945, 1951, 1957, 1969, 1981, 1986,\
    \ 1989, 1994, 1997, 1998, 2003, 2011, 2017, 2027, 2034, 2043, 2048, 2053, 2066,\
    \ 2072, 2079, 2088, 2093, 2099, 2102, 2103, 2116, 2122, 2126, 2129, 2131, 2134,\
    \ 2142, 2146, 2149, 2154, 2156, 2161, 2162, 2164, 2166, 2168, 2172, 2173, 2179,\
    \ 2184, 2186, 2188, 2194, 2199, 2204, 2208, 2211, 2215, 2218, 2221, 2224, 2229,\
    \ 2234, 2237, 2239, 2241, 2245, 2247, 2251, 2254, 2255, 2257, 2260, 2262, 2265,\
    \ 2268, 2271, 2273, 2274, 2277, 2281, 2284, 2286, 2288, 2291, 2296, 2303, 2306,\
    \ 2311, 2313, 2315, 2318, 2320, 2322, 2324, 2326, 2328, 2330, 2331, 2334, 2336,\
    \ 2338, 2340, 2342, 2344, 2347, 2349, 2351, 2354, 2356, 2359, 2362, 2364, 2366,\
    \ 2368, 2371, 2374, 2377, 2379, 2382, 2385, 2387, 2388, 2391, 2393, 2396, 2399,\
    \ 2401, 2403, 2405, 2406, 2407, 2409, 2411, 2413, 2415, 2417, 2419, 2421, 2423,\
    \ 2425, 2428, 2430, 2432, 2434, 2436, 2438, 2440, 2442, 2445, 2448, 2460, 2462,\
    \ 2465, 2467, 2469, 2471, 2473, 2475, 2477, 2479, 2482, 2484, 2486, 2489, 2491,\
    \ 2493, 2495, 2498, 2501, 2503, 2505, 2508, 25", "    $is_prime = true;\n    $factor\
    \ = 2;\n    for($i = 2; $i * $i < $n; $i++) {\n        if($n % $i == 0) {\n  \
    \          $is_prime = false;\n        }\n        if($is_prime) {\n          \
    \  $factor = $i;\n            break;\n        }\n    }\n    return $factor;\n}",
  "  if ($n < 2) {\n    return null;\n  }\n  if ($n == 2) {\n    return 2;\n  }\n\n\
    \  // See \"Primality Test\" by George Marsaglia\n  // https://math.stackexchange.com/questions/12373/primality-test-with-mod-arithmetic\n\
    \  for ($i = 2; $i * $i <= $n; $i++) {\n    // \"i * i\" will overflow the type\
    \ we use to store $i and hence wrap around\n    if ($i * $i == $n) {\n      return\
    \ $i;\n    }\n  }\n}\n", "  $factors       = array();\n  $remainder     = 1;\n\
    \  $n             = abs($n);\n  $p             = 2;\n\n  while ($n >= $p) {\n\
    \    while ($n % $p == 0) {\n      $factors[]  = $p;\n      $n        /= $p;\n\
    \      $p        += 1;\n    }\n\n    if ($remainder == 0) {\n      array_pop($factors);\n\
    \      $remainder    = $n % $p;\n      $p          += 1;\n    }\n  }\n\n  return\
    \ $factors[count($factors) - 1] + 1;\n}\n</code>\n<|/ a tags=php,algorithm,primes\
    \ |>\n<| a tags=php,algorithm,primes |>\nIn case you are still looking for a concise\
    \ way to implement this in php (using laravel)\n<code>\npublic function is_prime($number)\n\
    {\n    $isPrime = true;\n    \n    foreach (array_slice($this->factors(), $number)\
    \ as $factor) {\n        if ($number % $factor === 0) {\n            $isPrime\
    \ = false;\n        }\n    }\n\n    return $isPrime;\n}\n\n/**\n * Get all prime\
    \ factors for a given number\n * \n * int $number\n * array\n */\nprotected function\
    \ factors()\n{\n    $factors = [];\n    $isPrime = true;\n\n    for (; $number\
    \ >= 1; $number /= 2) {\n        if ($number % 2 === 0) {\n            $isPrime\
    \ = false;\n        }\n\n        for ($i = 3; $i * $i <= $number; $i += 2) {\n\
    \            if ($number % $i == 0) {\n                $isPrime = false;\n   \
    \         }\n        }\n        \n        if ($isPrime === true) {\n         \
    \   $factors[] = $number;\n        }\n    }\n\n    return $factors;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThis is not an answer to the question. He wants to\
    \ know the prime factors of the number, not whether a given number is a prime.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>\n<?php", "    $p = 2; $i = $j = 2;\n    while\
    \ ($n > 1 && $n % $j == 0) { $p = $j; $j++; $n = ($n % $j == 0) ? $n / $j : 0;\
    \ }\n    return $p;\n}", "    $i = 2; $s = 2; $max = 2;\n    // while ( $i*$i\
    \ < $n ) {\n    while ($i * $i <= $n) {\n        $s = $i * $i;\n        if ($n\
    \ > $s) { $max = $s; }\n        $i += 2; // skip even numbers\n    }\n    return\
    \ $max;\n}\n</code>\n<|/ a |>\n<| c |>\nThe only problem with the first one is\
    \ that it returns negative values when they shouldn't and doesn't seem to work\
    \ with values over about 2^32. Surely it can be made to work without being too\
    \ slow? It works by checking if each number is a factor, and if it's not, adding\
    \ it to the prime list. Could it be optimized somehow?\n<|/ c |>\n<| c |>\nYes,\
    \ the second one can work that out to stop it returning negative numbers.\n<|/\
    \ c |>\n<| c |>\n: I don't quite understand how the first one is unreliable. Do\
    \ you mean that it returns incorrect results for numbers that are not primes?\
    \ For instance, I get `13` as a prime factor, which is not prime. I'm assuming\
    \ that's a typo -- your second solution should work as long as the factors are\
    \ integers instead of floats.\n<|/ c |>\n<| c |>\nAh, you were right. My mistake,\
    \ sorry.\n<|/ c |>\n<| a |>\nI recently wrote this function that would generate\
    \ prime factors and exponents in a fairly efficient manner. It can be modified\
    \ to work out prime factors of very large numbers, as long as you take into account\
    \ that very large numbers are very rarely prime numbers.\nThe idea is that you\
    \ start with a large list of primes, and then remove them and divide them in half\
    \ until you have a list of pairs. Each time you remove the prime from the list\
    \ of primes you divide it by that prime, until it has no remaining primes left.\n\
    <code>", "    $n = abs($n);\n    $root = $n;\n\n    $factor = 1;\n    while ($factor\
    \ <= $root) {\n        $root = floor(($root + $factor - 1) / ($factor + 1)); //\
    \ += instead of =, because we could get into an infinite loop before getting the\
    \ correct factor for the root\n        $factor++;\n    }\n    return $factor;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nI believe the question is about PHP and I believe\
    \ the code you have provided is for C#\n<|/ c |>\n<| c |>\n: Yeah, this one is\
    \ C#. But the algorithm is the same. I'll add it to my answer.\n<|/ c |>\n<| a\
    \ dscore=0 |>\nThis answer is in C#, although I don't think you can do this in\
    \ PHP.\n<code>\nint largest_prime_factor(int n)\n{\n    long count = 1 << ((long)Math.Log(n,\
    \ 2));\n\n    for(int i = 1; i < n; ++i)\n    {\n        int p = (int)Math.Pow(i,\
    \ 2);\n\n        if(p > count)\n        {\n            count = p;\n        }\n\
    \    }\n\n    return (int)Math.Ceiling(count);\n}\n</code>\n<|/ a tags=big-o,algorithm\
    \ |>\n<| c |>\nHow can this be O(log n) when the algorithm is O(n)?\n<|/ c |>\n\
    <| c |>\nThe question states that it is about big-O, not complexity.  And it states\
    \ that this algorithm is O(n). You seem to know that which is great (but you still\
    \ haven't explained why it is O(n)).\n<|/ c |>\n<| c |>\nOh, I see what you mean.\
    \ Yeah, the original algorithm was a lot more complicated. I was just trying to\
    \ give a simpler one since it seemed like he was having difficulty wrapping his\
    \ head around it.\n<|/ c |>\n<| c |>\nThe question didn't state complexity until\
    \ after I posted my answer\n<|/ c |>\n<| c |>\nIt also doesn't say O(log n) until\
    \ after I posted my answer. I was just trying to explain that he wasn't even sure\
    \ what he was looking for\n<|/ c |>\n<| a dscore=0 |>\nIn PHP you could do this\
    \ using the gmp_facotry extension:\n<code>", "    foreach (array_range(2, $n)\
    \ as $test) {\n        if ($n % $test === 0) {\n            return $test;\n  \
    \      }\n    }\n    return $n;\n}\n", "    if ($n <= 1)\n        return 1;\n\
    \    $highest = $n;\n    $highest_prime = null;\n    $i = $j = 2;\n    while ($j\
    \ * $j <= $highest) {\n        if ($n % $j == 0) {\n            $k = $j;\n   \
    \         while ($k <= $highest) {\n                if ($n % $k == 0) {\n    \
    \                break;\n                }\n                $k++;\n          \
    \  }\n            $highest_prime = $j;\n        }\n        $j++;\n    }\n    return\
    \ $highest_prime ? $highest_prime : $highest;\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| a tags=php,algorithm |>\nTo get max prime factor from 1000 to 10000 :\n<code>\n\
    public function maxPrimeFactor() {\n    $maxPrimeFactor = 0;\n    $primes = $this->getPrimes();\n\
    \    foreach ($primes as $prime) {\n        $maxPrimeFactor = min($maxPrimeFactor,\
    \ $prime * $prime);\n    }\n    return $maxPrimeFactor;\n}\n\npublic function\
    \ getPrimes() {\n    $primes = array();\n    for ($i = 1; $i < 10; $i++) {\n \
    \       for ($j = 2; $j * $j <= $i; $j++) {\n            if ($i % $j == 0) {\n\
    \                array_push($primes, $j);\n                $j++;\n           \
    \ }\n        }\n    }\n    return $primes;\n}\n</code>\n<|/ a dscore=0 |>\n<|\
    \ c |>\nI believe this would fail for `maxPrimeFactor() = 17`. As it would output\
    \ `16*17` as the factor, which does not equal `17`. Also, please add comments\
    \ to your answer to explain why your code is better than the OP's code.\n<|/ c\
    \ |>\n<| c |>\nYou're right, I updated my answer with a more efficient method.\n\
    <|/ c |>\n<| a dscore=0 |>\nThe code is to find the largest prime factor of input\
    \ number n with time complexity O(n)\n<code>\n$n=48;\n", "  $i = 2; $p = $n +\
    \ 1; $factors = [];\n  for (; $i <= $n; $i++) {\n    while ($n % $i) {\n     \
    \ if ($i == $p) {\n        array_push($factors, $i);\n      } else {\n       \
    \ $p = $i;\n      }\n      $i++;\n    }\n  }\n  return max($factors);\n}\n</code>\n\
    <|/ a tags=php |>\n<| a |>\nA very simple solution (for anyone looking for the\
    \ answer) is to return the greatest prime factor of $n. This code does not require\
    \ division. I am not familiar with the math behind it, but it seems to work well\
    \ enough.\n<code>\n<?php\n", "    $factor = 2; // largest\n    for($i = 2; $i\
    \ <= $n; $i++) {\n        if($n % $i == 0) {\n            $factor = $i;\n    \
    \        break;\n        }\n    }\n    return $factor;\n}\n", "    $max = $n--;\n\
    \    for($i = 1; $i < $n && $n % $i == 0; $i--);\n    return $i;\n}\n", "    $primes\
    \ = array(2);\n    for ($i = 3; $i <= $n; $i += 2) {\n        for ($j = 3; $j\
    \ * $j <= $i; $j++) {\n            if ($i % $j == 0) {\n                break;\
    \ // not a prime\n            }\n        }\n        $primes[] = $i;\n    }\n \
    \   return $primes[count($primes) - 1];\n}\n", "    \n    // Set all variables\
    \ to zero as this operation is done inplace.\n    $x = 0;\n    $y = 0;\n    $z\
    \ = 0;\n    $m = 0;\n    \n    // Test for prime and composite numbers up to $n.\n\
    \    if ($n < 2) {\n        return 1;\n    }\n    \n    // Test for factors up\
    \ to sqrt($n).\n    for ($i = 1; $i <= sqrt($n); $i++) {\n        if ($n % $i\
    \ == 0) {\n            $x++;\n        } else if ($i % $n == 0) {\n           \
    \ $y++;\n        } else {\n            $z++;\n        }\n    }\n    \n    // If\
    \ the numbers tested are not prime or composite, return $n.\n    if ($x == 0 &&\
    \ $y == 0 && $z == 0) {\n        return $n;\n    }\n    \n    // Test for prime\
    \ only.\n    if ($x == 0 && $y == 0) {\n        return 2;\n    }\n    \n    //\
    \ Return smallest prime factor of $n.\n    if ($x > $y) {\n        return $x;\n\
    \    } else {\n        return $y;\n    }\n}", "\t$n = abs($n);\n\t$factors = array();\n\
    \tfor ($x = 2; $x < $n; $x++) {\n\t\tif ($n % $x == 0) {\n\t\t\t$n = floor($n/$x);\n\
    \t\t\t$factors[] = $x;\n\t\t}\n\t}\n\treturn max($factors);\n}", "    $n = abs($n);\n\
    \    $max_factor = 2;\n    $i = 1;\n    while (n > 1) {\n        $i += 2;\n  \
    \      $n = $n % $max_factor;\n        $max_factor *= $i;\n    }\n    return $max_factor;\n\
    }\n</code>\n<|/ a dscore=2 tags=php,math |>\n<| c |>\nThis is really elegant.\n\
    <|/ c |>\n<| c |>\n: I wouldn\u2019t recommend using this in production. First\
    \ of all, it\u2019s *very* slow. Second, it\u2019s rather inefficient. Third,\
    \ it\u2019s no more than a little more than a little bit of code that\u2019s hard\
    \ to read, and I suspect that it would not perform as well on large values of\
    \ `n`.\n<|/ c |>\n<| c |>\n: Of course you *should* use the right tool for the\
    \ job. That\u2019s why I said \u201Cshould\u201D and provided a solution that\
    \ isn\u2019t \u201Cbad\u201D, even though it isn\u2019t as efficient as yours.\n\
    <|/ c |>\n<| c |>\n: \u201CSecond, it\u2019s rather inefficient.\u201D I wonder\
    \ what kind of performance you think it is. I suspect it\u2019s at least as fast\
    \ as the algorithm in the question, which is what everyone here is already using.\n\
    <|/ c |>\n<| c |>\n: The reason for efficiency is that the OP explicitly said\
    \ \u201Cnot efficient at all\u201D. So yes, I agree that it\u2019s not that inefficient\
    \ as the algorithm in the question \u2013 but I believe it would be less readable,\
    \ not slower, and more inefficient on large values of `n`. Also, your solution\
    \ has another flaw \u2013 it\u2019s not guaranteed to work for any `n`. That\u2019\
    s why I said \u201Cshouldn\u2019t use\u201D.\n<|/ c |>\n<| a dscore=2 |>\nA little\
    \ bit of simple mathematics is all you need to do this. We can take the number\
    \ n, say n=729. 729 can be split into primes easily (it's already a prime!), so\
    \ let's find the largest prime factor of this number. We can split this number\
    \ into 2s and 3s, so 729 can be split into 7, 29 and 2. Since 2 is the largest\
    \ prime factor of 729, we can say that 7 is the largest prime factor of 729. Because\
    \ of that, we know that we can divide the 729 into 7*29*2=1479, and therefore\
    \ the largest prime factor of 1479 is 14.\nNow, let's do the same thing with the\
    \ 1479 number. 1479 can be divided into 14*79*2=912. ", "    if ($n <= 1)\n  \
    \      return 1;\n    else\n        return $n % $n ?\n            $largest_prime_factor(floor($n\
    \ / $n)) :\n            $largest_prime_factor($n / $n);\n}", "\t$f = 1; // First\
    \ prime factor\n\t$t = 2; // Next prime factor\n\n\t// While $n >= 2\n\twhile($n\
    \ >= 2) {\n\t\t// If $f already has the largest factor\n\t\tif($f > $t) {\n\t\t\
    \t// Break the loop immediately since there are no more factors\n\t\t\tbreak;\n\
    \t\t}\n\n\t\t// If $t is larger, set $f to $t\n\t\tif($t > $n) {\n\t\t\t$f = $t;\n\
    \t\t} else {\n\t\t\t// If $n is still too big, set $t to $f+1\n\t\t\t$t = $f;\n\
    \t\t}\n\t}\n\n\t// Return $f\n\treturn $f;\n}\n\n/**\n * Checks if a value is\
    \ numeric\n *\n * @param mixed $val\n * @return bool\n */", "    $max_factor =\
    \ 1;\n    $max_divisor = 1;\n    for($i = 2; $i <= floor($n/2); $i++) {\n    \
    \    if ($n % $i == 0) {\n            $max_divisor = $i;\n        } else {\n \
    \           if ($max_divisor == $i) {\n                $max_factor = $max_divisor;\n\
    \            }\n            $max_divisor = 1;\n        }\n    }\n    return $max_factor;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a |>\nYou can find all prime numbers below n\
    \ with following code:\n<code>", "  $s = $x = 0;\n  $i = 1;\n  while (true) {\n\
    \    if (($n % $i) === 0) {\n      $x = $i;\n      $s = 1;\n    }\n    if ($s\
    \ === 0) {\n      break;\n    }\n    $i += $s;\n  }\n  return $x;\n}\n</code>\n\
    This code has a few advantages:\n\nIt doesn't use any loops (just for loops)\n\
    It doesn't require an extra library (I'm assuming you're using PHP 5.3+). You\
    \ can just use PHP internal functions for things like this.\n\nIn order to use\
    \ this code, I recommend making a function called largest_prime_factor that takes\
    \ n as a parameter. For example:\n<code>", "  $n = abs($n);\n  for($i = 2; $i\
    \ <= sqrt($n); $i++) {\n    if($n % $i == 0) {\n      return $i;\n    }\n  }\n\
    \  return $n;\n}\n", "  $n_factors = [];\n  // Primes smaller than the square\
    \ root are endless.\n  if ($n < 2) return $n;\n  // Trial division is easy to\
    \ optimize, since all even primes can\n  // be divided by at least two even primes.\n\
    \  for ($d = 2; $d < $n; $d += 2) {\n    if ($n % $d == 0) return $d;\n  }\n \
    \ // If we get here, no prime factor was found.\n  // Compute the prime factorization\
    \ of the number.\n  // See HAC, Algorithm 14.9.3 pp. 33-34 for a detailed analysis\
    \ of\n  // the prime factorization algorithm.\n  for ($p = 1; $p * $p < $n; $p\
    \ += 2) {\n    for ($i = 2; $i * $i <= $n; $i += 2) {\n      if ($n % $i == 0)\
    \ {\n        $n_factors[] = $i;\n        while ($n % $i == 0) {\n          $n\
    \ /= $i;\n          $n_factors[] = $i;\n        }\n        if ($n == 1) return\
    \ $p;\n      }\n    }\n  }\n  return 1;\n}\n", "  $i = 2;\n  while($i < $n) $i\
    \ += $n % $i;\n  return $i;\n}\n", "    $factor = 2;\n    $limit = $n; //set limit\
    \ to $n since n may be big\n    $i = 2; //start at 2\n    while($i <= $limit)\
    \ { //start at 2 and increment by 2 until limit\n        if($n % $i == 0) { //if\
    \ n is divisible by i, n%i is 0 so $i is not prime\n            $factor++; //increment\
    \ factor by 1\n        }\n        $i++; //increment by 2\n    }\n    return $factor;\
    \ //return the largest prime factor of n\n}\n", "    $factor = 1;\n    for($i\
    \ = 1; $i <= $n; $i++) {\n        $test = $i * $i;\n        while($test < $n)\
    \ {\n            $test += $i;\n            $factor++;\n        }\n    }\n    return\
    \ $factor;\n}\n", "  $i = 1;\n  while ($n % $i) {\n    $i++;\n  }\n  return $i;\n\
    }", "  $factors = array();\n  for ($x = 2; $x <= $n; $x++) {\n    if ($n % $x\
    \ == 0) {\n      $factors[] = $x;\n      $n /= $x;\n    }\n  }\n  return count($factors)\
    \ > 0 ? array_pop($factors) : null;\n}\n</code>\nBut I cannot get the following\
    \ code working. What am I doing wrong? \n<code>\n<?php", "  $n = abs($n);\n  $r\
    \ = $n;\n  $factor = 2;\n  while ($n > 2) {\n    $r = ($r*$factor) % $n;\n   \
    \ $n = ($n-1) / $factor;\n    $factor++;\n  }\n  return $r;\n}\n</code>\n<|/ a\
    \ |>\n<| a tags=primes,algorithm,math,php dscore=4 |>\nA simple algorithm:\n\n\
    Start with 2\nLoop while there are more primes than you need\nFor each prime p,\
    \ divide by sqrt(p)\nIf remainder is zero, it's a prime\n\nIf you have many primes\
    \ then you'll have to store them in a list or something.\nThe basic algorithm\
    \ is pretty easy to implement, and it only takes about 0.5 seconds to find the\
    \ largest prime factor of $n\n<|/ a |>\n<| c |>\n+1 this is what i would do too.\
    \ also i would check for prime number only up to sqrt(n) and i would store prime\
    \ numbers in an array and check against them in next step.\n<|/ c |>\n<| a |>\n\
    Here is my implementation in PHP 5:\n<code>", "    $i = 2;\n    while ($i <= sqrt($n))\
    \ {\n        if ($n % $i == 0) {\n            return $i;\n        }\n        $i\
    \ += 1;\n    }\n    return $n;\n}\n", "    if ($n < 2)\n        return $n;\n\n\
    \    $n2 = $n / 2;\n    $prime = 2;\n    $factor = 1;\n\n    while ($n2 >= $prime)\
    \ {\n        $n2 /= $prime;\n        $factor += $prime;\n        $prime += 2;\n\
    \    }\n    return $factor;\n}\n</code>\n<|/ a |>\n<| c |>\nI believe the algorithm\
    \ that has already been implemented is a better solution than the accepted answer\
    \ -- it seems to be the fastest, and its also not dependent on any third-party\
    \ library. Also, it seems like a pretty clean algorithm to me. +1 for including\
    \ a Python example\n<|/ c |>\n<| a |>\n<code>", "    $pmin = 2;\n    $pmax = 31;\n\
    \    $factors = [];\n    for($i = 2; $i <= $n; $i++) {\n        $j = $pmax;\n\
    \        while(!($i&1)) {\n            $i = $i/2; // divide by 2\n           \
    \ $j++;\n            if($j > $pmax) {\n                $j = $pmax;\n         \
    \   }\n        }\n        if($i <= $j) {\n            $factors[$j] = $i;\n   \
    \     }\n        if($i > $j) {\n            $pmin = $j;\n        }\n        if($i\
    \ > $pmax) {\n            $pmax = $i;\n        }\n    }\n    return $factors[$pmax];\n\
    }", "\t$factors = [];\n\tfor ($i = 2; $i <= $n; $i++) {\n\t\tif ($n % $i === 0)\
    \ {\n\t\t\t$factors[] = $i;\n\t\t\twhile ($n % $i === 0) {\n\t\t\t\t$n /= $i;\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn count($factors) > 1 ? $factors[0] : $n;\n}\n", " \
    \   $n = abs($n);\n    $i = 2; while ($i <= sqrt($n)) {\n        if ($n % $i ==\
    \ 0) {\n            $n = (int) ($n / $i); $i += 1;\n        } else {\n       \
    \     $i += 2;\n        }\n    }\n    return $n;\n}", "  $primes = array(2,3,5);\n\
    \  if ($n%2==0) { $primes[1] = 2; }\n  for ($i=3; $i>=1; $i--) {\n    if ($n%$i==0)\
    \ {\n      $n = $n/$i;\n      $primes[$i] = $i;\n    } else {\n      break;\n\
    \    }\n  }\n  return $primes[count($primes)-1];\n}\n", "  $i = 2;\n  while (1)\
    \ {\n    while ($n % $i==0) { $i++ }\n    if ($i==1 || $n%$i==0) { return $i }\n\
    \    $i++;\n  }\n}\n", "  $i = 2; $primes = array(2);\n  while ($n >= $i) {\n\
    \    for ($j = array_pop($primes); $i * $j <= $n; $j++) {\n      $primes[] = $j\
    \ * $i;\n    }\n    $i += $primes[count($primes) - 1];\n  }\n  return $primes[count($primes)\
    \ - 1];\n}\n</code>\n<|/ a |>\n<| c |>\nHow do I know if my integer is prime?\n\
    <|/ c |>\n<| c |>\nThe OP asked for a prime factorization; prime factors come\
    \ from the definition of prime numbers (https://en.wikipedia.org/wiki/Prime_number).\
    \ You can find a definition of them in Wikipedia (https://en.wikipedia.org/wiki/Primality_test)\
    \ and here: http://mathworld.wolfram.com/PrimalityTest.html.\n<|/ c |>\n<| c |>\n\
    Yes but why are you dividing by 3 every time? Also, the OP is asking for largest\
    \ prime factor, not for largest *prime*.\n<|/ c |>\n<| c |>\nBecause if I don't\
    \ divide by 3, the factorization won't be correct.\n<|/ c |>\n<| c |>\nThe OP's\
    \ algorithm doesn't find largest prime factorization; it finds largest prime factor.\
    \ `largest_prime_factor` finds largest prime factor in integer factorization (I\
    \ mean the factorization where all the factors are multiples of their primes).\
    \ Prime factorization is the decomposition of a number into its prime factors.\n\
    <|/ c |>\n<| a tags=math,php,algorithm,primes,java dscore=0 |>\nHere's a brute\
    \ force solution:\n<code>\n<?php\n    $x = $_GET['x'];\n\n    function isPrime($x)\
    \ {\n        for ($i = 1; $i <= sqrt($x); $i++) {\n            if ($x % $i ==\
    \ 0) {\n                return false;\n            }\n        }\n        return\
    \ true;\n    }\n\n    $largestPrimeFactor = 1;\n    for ($i = 1; $i <= $x; $i++)\
    \ {\n        if (isPrime($i)) {\n            $largestPrimeFactor = $i;\n     \
    \       break;\n        }\n    }\n\n    echo \"The Largest Prime Factor is \"\
    \ . $largestPrimeFactor;", "  $i = 2;\n  while (true) {\n    if ($n % $i == 0)\
    \ {\n      return $i;\n    }\n    $i += $i > $n ? 1 : 2;\n  }\n}\n", "  $factor\
    \ = 2;\n  $max_factor = 2;\n  while ($n % $factor != 0) {\n    $factor++;\n  \
    \  if ($max_factor < $factor) {\n      $max_factor = $factor;\n    }\n  }\n  return\
    \ $factor;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nNot bad, but is `largest_prime_factor`\
    \ guaranteed to always return a prime?\n<|/ c |>\n<| c |>\nNope, I'm sure it isn't.\n\
    <|/ c |>\n<| c |>\nNope, nope, nope! The [Sieve of Eratosthenes](http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes)\
    \ should have been your first thought. BUT, no, no it is not guaranteed.\n<|/\
    \ c |>\n<| a dscore=0 tags=php |>\n<code>\n<?php", "  $sqrtn = sqrt($n);\n  $prime_factors\
    \ = array(3);\n  $next_p = 3; // Start at 3\n\n  // Try all possible primes p\
    \ <= sqrt(n)\n  // Skip p if it is already tested or we've found a larger factor\n\
    \  while ($next_p <= $sqrtun) {\n    // Check the remaining n - p to see if it's\
    \ a prime\n    if ($n % $next_p == 0) {\n      // Yep, can be divided by current\
    \ highest prime factor\n      $prime_factors[] = $next_p;\n      $n /= $next_p;\n\
    \    } else {\n      // Not prime so continue searching\n      $next_p++;\n  \
    \  }\n  }\n\n  return $prime_factors[count($prime_factors) - 1];\n}\n", "    $primes\
    \ = array(2, 3);\n    for ($i=3; $i*$i <= $n; $i+=2) {\n        if ($n%$i == 0)\
    \ {\n            $primes[] = $i;\n            if ($i != $n) {\n              \
    \  for ($j=$i*$i; $j<$n; $j+=2*$i) {\n                    if ($n%$j == 0) {\n\
    \                        $primes[] = $j;\n                        break;\n   \
    \                 }\n                }\n            }\n        }\n    }\n    sort($primes,\
    \ SORT_NUMERIC);\n    return $primes[count($primes)-1];\n}\n", "    $i = 2;\n\
    \    $f = 2;\n    while ($i <= sqrt($n)) {\n        if ($n % $i == 0) {\n    \
    \        if ($f <= $i) {\n                $f = $i;\n            }\n          \
    \  $i++;\n        } else {\n            $n = $i << ($i - 1);\n            $i =\
    \ 2;\n        }\n    }\n    return $f;\n}\n", "    if ($n == 1)\n        return\
    \ 1;\n    if ($n == 2 || $n == 3) return 2;\n    if ($n%2 != 0) return 0;\n\n\
    \    $m = $n-1;\n    for ($i=3; $i*$i <= $m; $i+=2) {\n        if ($m%$i == 0)\n\
    \            return $i;\n    }\n    return 0;\n}\n</code>\n<|/ a dscore=4 |>\n\
    <| c |>\nThe last paragraph should be \"return 0\" not \"return false\". As I\
    \ understand it, \"return false\" should really be \"die\"ed.\n<|/ c |>\n<| c\
    \ |>\n: Yes, that is correct. I used the phrase \"return 0\" to indicate that\
    \ the function should return `0` if it determines that a particular number has\
    \ at least two factors. I edited the post to correct this. Thanks.\n<|/ c |>\n\
    <| c |>\nI think it's actually more correct to say \"return 0\" because \"return\
    \ false\" will return a boolean true/false value, so it will probably return true\
    \ or false depending on whether your function finds a factor. The original version\
    \ returned a number so \"return 0\" was more correct.\n<|/ c |>\n<| c |>\n: You\
    \ are correct. I edited the post to correct this. Thanks!\n<|/ c |>\n<| c |>\n\
    Wow, I just discovered that my code didn't work for this question, but I haven't\
    \ tested my code against the other answers here. I guess I should have added more\
    \ test cases. Anyway, thanks to everyone who responded! I learned a lot from all\
    \ your answers.\n<|/ c |>\n<| a tags=php,prime-factoring,math |>\nHere's a very\
    \ simple way to do it:\n<code>\n<?php", "    // Use a sieve of Eratosthenes for\
    \ the largest prime factor of n <= 32\n    // This makes it much faster than using\
    \ the Sieve of Atkin\n    $sieve = array();\n    for($i = 2; $i * $i <= $n; $i++)\
    \ {\n        if(!isset($sieve[$i])) {\n            $sieve[$i] = $i;\n        \
    \    for(; $i * $i <= $n; $i++)\n                $sieve[$i] = 0; // set $sieve[$i]\
    \ = 0 if the corresponding number in the sieve array is 0\n        }\n    }\n\n\
    \    $result = $sieve[$n];\n    if($result != 0)\n        return $result;\n\n\
    \    $result = $n;\n    for($i = 2; $i * $i <= $n; $i++)\n        if(!isset($sieve[$i]))\
    \ {\n            $result = $i;\n            $n--;\n            break;\n      \
    \  }\n\n    return $result;\n}\n</code>\n<|/ a |>\n<| c |>\nThe question is about\
    \ finding largest prime factor. Your approach doesn't work.\n<|/ c |>\n<| c |>\n\
    The question is about finding largest prime factor. Your approach doesn't work.\
    \ Try it on the numbers 10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9+10^9",
  "  return $n == 1 ||\n    ( $n % 2 == 0 && $n % 3 == 0 ) ||\n    $n % 5 == 0 ?\n\
    \      3 :\n      (5 | largest_prime_factor(ceil(sqrt5($n))));\n}\n", "  if ($n\
    \ <= 1) {\n    return 1;\n  }\n  $largest_prime_factor = 2;\n  for ($i = 3; $i\
    \ * $i <= $n; $i += 2) {\n    if ($n % $i == 0) {\n      $largest_prime_factor\
    \ = $i;\n      break;\n    }\n  }\n  return $largest_prime_factor;\n}", "    $result=1;\n\
    \    $n=abs($n);\n    for($i=2;$i<=$n/2;$i++) {\n        if ($n%$i==0) {\n   \
    \         $result=$i;\n            break;\n        }\n    }\n    return $result;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a tags=php,prime-factoring,math dscore=1 |>\n\
    This answer finds the smallest prime factor of any positive integer in PHP\n\n\
    <code>", "    $fp = fopen(\"php://stdout\",\"w\");\n    $primes = 0;\n    for($i=2;$i<=$n;$i++)\n\
    \    {\n        $prime_count = 0;\n        for($j=2;$j<$i;$j++)\n        {\n \
    \           if($i%$j == 0) $prime_count++;\n        }\n        if($prime_count\
    \ == $i)\n        {\n            $primes++;\n            fwrite($fp,$i.\" \");\n\
    \        }\n    }\n    return $primes;\n}", "    $n1 = $prime = 1;\n    $n2 =\
    \ $largest = 2;\n    while ($n >= $largest) {\n        $bigger = $n2;\n      \
    \  $n2 = $n1;\n        $n1 = $prime;\n        $prime = $bigger;\n        $largest\
    \ = $n2;\n    }\n    return $n1;\n}", "    $factor = 2; // any number greater\
    \ than 1\n    while ($n % $factor == 0) {\n        $factor++;\n    }\n    return\
    \ $factor;\n}", "  $factors = array();\n  while ($n % 2 == 0) { $n /= 2; }\n \
    \ while ($n % 3 == 0) { $n /= 3; }\n  while ($n % 5 == 0) { $n /= 5; }\n  while\
    \ ($n % 7 == 0) { $n /= 7; }\n  while ($n % 11 == 0) { $n /= 11; }\n  while ($n\
    \ % 13 == 0) { $n /= 13; }\n  while ($n % 17 == 0) { $n /= 17; }\n  while ($n\
    \ % 19 == 0) { $n /= 19; }\n  while ($n % 23 == 0) { $n /= 23; }\n  while ($n\
    \ % 29 == 0) { $n /= 29; }\n  while ($n % 37 == 0) { $n /= 37; }\n  while ($n\
    \ % 41 == 0) { $n /= 41; }\n  while ($n % 43 == 0) { $n /= 43; }\n  while ($n\
    \ % 47 == 0) { $n /= 47; }\n  while ($n % 53 == 0) { $n /= 53; }\n  while ($n\
    \ % 59 == 0) { $n /= 59; }\n  while ($n % 61 == 0) { $n /= 61; }\n  while ($n\
    \ % 67 == 0) { $n /= 67; }\n  while ($n % 71 == 0) { $n /= 71; }\n  while ($n\
    \ % 73 == 0) { $n /= 73; }\n  while ($n % 79 == 0) { $n /= 79; }\n  while ($n\
    \ % 83 == 0) { $n /= 83; }\n  while ($n % 89 == 0) { $n /= 89; }\n  while ($n\
    \ % 97 == 0) { $n /= 97; }\n  $factors[$n] = 1;\n  while (!array_key_exists($n,\
    \ $factors)) {\n    $i++;\n    if ($i > 20) {\n      throw new InvalidArgumentException('n\
    \ must be larger than prime');\n    }\n  }\n  return $factors[$n];\n}\n", "  \
    \  $primes = array();\n    $primes[2] = $n;\n    $factor = 2;\n    while ($factor\
    \ * $factor <= $n) {\n        $primes[$factor] = $n / $factor;\n        $factor++;\n\
    \    }\n    return $primes[$factor];\n}\n", "\t$n = abs($n);\n\t$n_length = strlen($n);\n\
    \t$max_factor = 1;\n\t$max_factor_index = 0;\n\tfor ($i = 1; $i < $n_length; $i++)\
    \ {\n\t\t$candidate_factor = 2;\n\t\tfor ($j = 2; $j < $i; $j++) {\n\t\t\tif ($n\
    \ % $j == 0) {\n\t\t\t\t$candidate_factor *= $j;\n\t\t\t}\n\t\t}\n\t\tif ($candidate_factor\
    \ > $max_factor) {\n\t\t\t$max_factor = $candidate_factor;\n\t\t\t$max_factor_index\
    \ = $i;\n\t\t}\n\t}\n\treturn $max_factor;\n}", "  $max = floor(sqrt($n));\n \
    \ for ($i = 2; $i <= $max; $i++) {\n    if ($n % $i == 0)\n      $max = $i;\n\
    \  }\n  return $max;\n}\n", "  $factor = 1;\n  $max = 0;\n  for ($i = 1; $i <=\
    \ $n; $i++) {\n    $test = $n % $i;\n    if ($test != 0) {\n      $factor = $i;\n\
    \      $max = $i;\n    }\n  }\n  return $factor;\n}\n", "    $i = 2; $max_factor\
    \ = $n;\n    while ($i <= sqrt($n)) {\n        if ($n % $i == 0) {\n         \
    \   $n = $i . $n / $i;\n        } else {\n            $i += 2;\n        }\n  \
    \      if ($n > $max_factor) $max_factor = $n;\n    }\n    return $max_factor;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThanks Mr. David, I'll try it and get back to you\
    \ about my results.\n<|/ c |>\n<| c |>\nHi Mr. David, as I mentioned in the comment\
    \ above, I'm trying to find the largest prime factor of each number (i.e. \"The\
    \ largest prime factor of 25 is 5\" instead of \"The largest prime factor of 25\
    \ is 6\"). I'm not sure if I should use your code or a different approach, but\
    \ I really appreciate your effort in helping me.\n<|/ c |>\n<| c |>\nSo you want\
    \ both 6 and 5 as output? And what is the largest prime factor of a number that\
    \ has no prime factors at all? I guess you should clarify your question\n<|/ c\
    \ |>\n<| c |>\nHi Mr. David, sorry if I wasn't clear enough. I'm trying to find\
    \ the largest prime factor of each number (i.e. \"The largest prime factor of\
    \ 25 is 5\" instead of \"The largest prime factor of 25 is 6\"). Also, there are\
    \ some numbers that don't have any prime factors at all (i.e. \"The largest prime\
    \ factor of 25 is 0\"). I'm really sorry for this, but I'm trying to figure out\
    \ what to do with this last situation.\n<|/ c |>\n<| c |>\nSo you want both \"\
    6\" and \"5\" in output? Then your problem should be solved using my code and\
    \ not the other one. Can you please give some examples with input numbers where\
    \ you want to see two factors?\n<|/ c |>\n<| a tags=php,factors,math,algorithm,primes\
    \ |>\nTry this one:\n<code>", "  global $counter;\n  \n  if ($counter) {\n   \
    \ return $counter;\n  }\n  \n  // Test to see if the number is a prime.\n  if\
    \ ($n === 1) {\n    return 1;\n  }\n  \n  $counter = 1;\n  $prime = 2;\n  \n \
    \ // Loop through the prime factors of n.\n  for ($i = 2; $i <= $n; $i++) {\n\
    \    // Test to see if the prime factor of n divides n.\n    if (($n % $prime)\
    \ !== 0) {\n      break;\n    }\n    \n    // Increase the counter.\n    $counter++;\n\
    \    \n    // Decrease the prime factor.\n    $prime++;\n  }\n  \n  // Return\
    \ the value of the largest prime factor.\n  return $counter;\n}", "    if ($n<2\
    \ || $n%2==0 || $n%5==0) {\n        return $n;\n    }\n    $i=3;\n    $k=3;\n\
    \    $m=2;\n    while($i*$i<$n) {\n        if($n%$i==0) {\n            $m=$i;\n\
    \        }\n        $i=$i+$k;\n        $k=$k+2;\n    }\n    return $m;\n}\n",
  "    // If the number is already prime then its factor is 1.\n    if ($n%2 == 0)\
    \ {\n        return 1;\n    }\n\n    // Get the prime factorization of the number.\n\
    \    $fs = $factors = array_map(\n        'intval',\n        array_filter(\n \
    \           range(2, $n),\n            function ($n) { return $n%2 != 0; }\n \
    \       )\n    );\n\n    // Return the largest prime factor of the number.\n \
    \   return max($factors);\n}\n</code>\n<|/ a tags=php,primes,factors |>\n<| a\
    \ tags=php,primes,factors |>\nHere is working code for getting a prime number:\n\
    <code>", "  if (!$n) return 1;\n  // See http://web.archive.org/web/201301010035/http://arxiv.org/pdf/1102.2591.pdf\n\
    \  // for the conjecture that 2 is the largest prime factor of n\n  if ($n <=\
    \ 17) return 2;\n  if ($n <= 19) return 3;\n  if ($n <= 23) return 5;\n  if ($n\
    \ <= 29) return 7;\n  if ($n <= 31) return 11;\n  if ($n <= 43) return 13;\n \
    \ if ($n <= 47) return 15;\n  if ($n <= 57) return 17;\n  if ($n <= 71) return\
    \ 19;\n  if ($n <= 79) return 21;\n  if ($n <= 83) return 23;\n  return 29;\n\
    }\n"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
