name: HumanEval_145_order_by_points
language: php
prompt: "<?php\n// Write a function which sorts the given array of integers\n// in\
  \ ascending order according to the sum of their digits.\n// Note: if there are several\
  \ items with similar sum of their digits,\n// order them based on their index in\
  \ original array.\n// For example:\n// >>> order_by_points(array(1, 11, -1, -11,\
  \ -12))\n// array(-1, -11, 1, -12, 11)\n// >>> order_by_points(array())\n// array()\n\
  function order_by_points($nums) {\n"
tests: "function candidate(...$args) {\n    return order_by_points(...$args);\n}\n\
  \nfunction test(): void {\n    if (candidate(array(1, 11, -1, -11, -12)) !== array(-1,\
  \ -11, 1, -12, 11)) { throw new Exception(\"Test failed!\"); }\n    if (candidate(array(1234,\
  \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46)) !== array(0, 2, 3,\
  \ 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457)) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(array()) !== array()) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(array(1, -11, -32, 43, 54, -98, 2, -3)) !==\
  \ array(-3, -32, -98, -11, 1, 2, 43, 54)) { throw new Exception(\"Test failed!\"\
  ); }\n    if (candidate(array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)) !== array(1, 10,\
  \ 2, 11, 3, 4, 5, 6, 7, 8, 9)) { throw new Exception(\"Test failed!\"); }\n    if\
  \ (candidate(array(0, 6, 6, -76, -21, 23, 4)) !== array(-76, -21, 0, 4, 23, 6, 6))\
  \ { throw new Exception(\"Test failed!\"); }\n}\n\ntest();"
completions: ["    $sum = array_sum($nums);\n    $num_sorted = array();\n    foreach\
    \ ($nums as $i => $num) {\n        $digits = str_split($num);\n        $num_sorted[$i]\
    \ = $digits[$sum - $num];\n    }\n    return $num_sorted;\n}\n", "    return array_reduce($nums,\
    \ function ($carry, $num) {\n        $digits =  str_split($num);\n        return\
    \ $carry != '' ? $carry . substr(array_sum($digits), 0, 1) : $num;\n    });\n\
    }\n", "    // TODO: write your function here\n    $ordering = array();\n    foreach($nums\
    \ as $num => $num) {\n        for($i = strlen($num); $i > 0; $i--) {\n       \
    \     $num = substr($num, 0, $i).$num;\n        }\n        $ordering[$num] = $num;\n\
    \    }\n    arsort($ordering);\n    return array_values($ordering);\n}", "  //\
    \ sort by digits, highest first\n  uksort($nums, 'sort_by_digits');\n  // flatten\
    \ resulting array\n  return call_user_func_array('array_merge', $nums);\n}\n",
  "    if (empty($nums)) {\n        return array();\n    }\n    $sums = array_map(function($num)\
    \ {\n        return intval(array_sum(str_split($num)));\n    }, $nums);\n    ksort($sums);\n\
    \    $result = array();\n    foreach ($sums as $i => $sum) {\n        if ($sum\
    \ == 0) {\n            $result[] = $nums[$i];\n        } else {\n            $result[]\
    \ = array_search($i, $sums);\n        }\n    }\n    return $result;\n}\n", " \
    \   $nums = array_filter($nums, 'is_int');\n    \n    // Find sum of digits\n\
    \    $sum = array_sum($nums);\n    \n    // Sort array by sum\n    usort($nums,\
    \ function ($a, $b) use ($sum) {\n        return $sum - $a - $b;\n    });\n  \
    \  \n    return $nums;\n}\n", "    $sum = 0;\n    $sums = array();\n    foreach\
    \ ($nums as $n => $v) {\n        $sum += $v;\n        $sums[$n] = $sum;\n    }\n\
    \    ksort($sums, SORT_NUMERIC);\n    return array_values($sums);\n}\n</code>\n\
    <|/ a tags=php,sorting dscore=2 |>\n<| a tags=php,sorting dscore=2 |>\nIf you\
    \ don't care about performance, simple array_multisort() will do the trick:\n\
    <code>\n$arr = array(\n    array('name'=>'John', 'age'=>21, 'gender'=>'male'),\n\
    \    array('name'=>'Mary', 'age'=>20, 'gender'=>'female'),\n    array('name'=>'Jane',\
    \ 'age'=>19, 'gender'=>'female'),\n    array('name'=>'Jack', 'age'=>21, 'gender'=>'male')\n\
    );\n$arr = array_multisort(array_map('array_sum', $arr), SORT_DESC, $arr);\nvar_dump($arr);\n\
    </code>\n<|/ a |>\n<| c |>\nThis is great! I did have one thing that was causing\
    \ problems. I ended up doing this: array_multisort(array_map('array_sum', array_map('array_keys',\
    \ $arr)), SORT_DESC, $arr);\n<|/ c |>\n<| c |>\nI'm glad it helped. Yes, I didn't\
    \ check it. I just copied the code from the answer I linked. But I guess it's\
    \ easy to add array_values to it. You can edit your answer and add that part too.\n\
    <|/ c |>\n<| a tags=php,sorting |>\nThe code below sorts by number of digits in\
    \ each string and puts them in a descending order based on the number of digits\
    \ in each string.\n<code>\n<?php\n\n$strings = array(\n    array(\n        \"\
    text\" => \"foo\",\n        \"sort\" => 1,\n    ),\n    array(\n        \"text\"\
    \ => \"bar\",\n        \"sort\" => 1,\n    ),\n    array(\n        \"text\" =>\
    \ \"foo2\",\n        \"sort\" => 2,\n    ),\n    array(\n        \"text\" => \"\
    bar2\",\n        \"sort\" => 2,\n    ),\n    array(\n        \"text\" => \"foo3\"\
    ,\n        \"sort\" => 3,\n    ),\n    array(\n        \"text\" => \"bar3\",\n\
    \        \"sort\" => 3,\n    ),\n);\n\nusort($strings, \"compare\");\n", "   \
    \ $sums = array_map(function($n) {\n        return sprintf('%0.1f', $n);\n   \
    \ }, $nums);\n    asort($sums);\n    return array_map(function($sum) {\n     \
    \   return array_search($sum, $sums);\n    }, $sums);\n}\n", "  // Write your\
    \ code here\n}\n", "    $sums = array_map('intval', array_sum($nums));\n    asort($sums);\n\
    \    return array_map(function ($i) { return $nums[$i]; }, array_keys($sums));\n\
    }\n", "  $sums = array();\n  foreach ($nums as $num) {\n    $sums[$num] = 0;\n\
    \  }\n  foreach ($sums as $sum => $num) {\n    $sums[$sum] += $num;\n  }\n  asort($sums);\n\
    \  return $sums;\n}\n", "    return array_reduce(\n        $nums,\n        function($out,\
    \ $i) {\n            $out[] = $i;\n            $out[] = $i + $out[0];\n      \
    \      return $out;\n        },\n        array()\n    );\n}\n</code>\n<|/ a tags=php,arrays,sorting\
    \ |>\n<| c |>\nThis assumes that elements are distinct\n<|/ c |>\n<| c |>\nYes\
    \ my fault. I just updated my solution to account for that.\n<|/ c |>\n<| c |>\n\
    This seems a bit over-complicated to me.  Why not just sum all the digits in the\
    \ first place and compare that?\n<|/ c |>\n<| c |>\nWhy not sum up all the digits\
    \ and then compare that instead? I find this way simpler to understand.\n<|/ c\
    \ |>\n<| c |>\nI don't think this would be faster - it would be an O(n) operation\
    \ anyway.\n<|/ c |>\n<| a dscore=0 |>\n<code>\n<?php", "  if (empty($nums)) return\
    \ array();\n  foreach ($nums as $i => $num) {\n    $nums[$i] = $nums[$i] + 0;\n\
    \  }\n  // Sort the elements of the array using the values of the array\n  //\
    \ as sorting keys\n  natsort($nums);\n  $sum = array_sum($nums);\n  $res = array();\n\
    \  foreach ($nums as $i => $num) {\n    if ($sum == $i) {\n      $res[] = $num;\n\
    \    } else {\n      $j = array_search($sum, $nums);\n      if ($j === false)\
    \ $j = 0;\n      $res[$j] = $num;\n      $sum -= $i;\n    }\n  }\n  return $res;\n\
    }\n", "    $sorted = [];\n    foreach ($nums as $num) {\n        $sum = 0;\n \
    \       while ($num > 0) {\n            $sum += $num % 10;\n            $num /=\
    \ 10;\n        }\n        $sorted[] = $sum;\n    }\n    array_multisort($sorted,\
    \ $nums);\n    return $nums;\n}\n", "  $sorted = [];\n  foreach ($nums as $i =>\
    \ $num) {\n    $digits = str_split($num);\n    $sum = 0;\n    foreach ($digits\
    \ as $digit) {\n      $sum += $digit;\n    }\n    $sorted[$i] = $sum;\n  }\n \
    \ natsort($sorted);\n  return array_values($sorted);\n}\n</code>\n<|/ a |>\n<|\
    \ c |>\nThank you very much, I will try this and get back to you.\n<|/ c |>\n\
    <| c |>\nYes it worked for me, I didn't know it could work this way\n<|/ c |>\n\
    <| a |>\n<code>", "  sort($nums);\n\n  // $sums[$i] = sum($nums[$i:])\n  $sums\
    \ = array_map(function($num) {\n    return strlen($num);\n  }, array_slice($nums,\
    \ 0, -1));\n  asort($sums);\n\n  return array_slice($nums, 0, -1);\n}\n", "  \
    \  usort(\n        $nums,\n        function($a, $b) {\n            $sum1 = $a\
    \ + $b;\n            $sum2 = $a + $b;\n            $difference = $sum1 - $sum2;\n\
    \            $difference = $difference % 10;\n\n            return $difference;\n\
    \        }\n    );\n\n    return $nums;\n}\n", "    $ordered = [];\n    $sums\
    \ = array_sum($nums);\n    foreach ($nums as $index => $num) {\n        $ordered[$index]\
    \ = $num;\n    }\n    asort($ordered);\n    foreach ($ordered as $index => $num)\
    \ {\n        $ordered[$index] = $sums[$index];\n    }\n    return $ordered;\n\
    }\n", "  // Find sum of all digits.\n  $sum = 0;\n  foreach ($nums as $num) {\n\
    \    $sum += $num;\n  }\n  // Sort based on this sum.\n  usort($nums, function($a,\
    \ $b) {\n    return $sum - $a;\n  });\n  return $nums;\n}\n</code>\n<|/ a tags=algorithm,arrays,php\
    \ dscore=1 |>\n<| a tags=algorithm,arrays,php dscore=1 |>\n<code>\n<?php\n\n$array\
    \ = array(\n  array(1, 4, -3, 4),\n  array(-1, -2, -1, 2),\n  array(1, 2, -3,\
    \ 4),\n  array(-1, -2, -1, 2),\n  array(1, 4, -3, 4),\n  array(-1, -2, -1, 2),\n\
    \  array(1, 4, -3, 4),\n  array(-1, -2, -1, 2),\n  array(1, 4, -3, 4),\n  array(-1,\
    \ -2, -1, 2),\n  array(1, 4, -3, 4),\n  array(-1, -2, -1, 2)\n);\n\n$newArray\
    \ = array();\n\nforeach ($array as $key => $values) {\n\n  $newArray[$key] = array();\n\
    \  $sum = 0;\n\n  foreach ($values as $value) {\n    $sum += $value;\n  }\n\n\
    \  if ($sum >= 0 && $sum < 10) {\n    $newArray[$key][] = $sum;\n  }\n\n}\n\n\
    var_dump($newArray);\n", "  // Sort the $nums array in ascending order using the\
    \ array_multisort\n  // function.  The callback function is defined to sort by\
    \ the\n  // first value of the array (which is the sum of the digits).\n  array_multisort(\n\
    \    array_map(\n      'intval',\n      array_reverse(\n        array_map(\n \
    \         'strval',\n          array_reverse(\n            array_map(\n      \
    \        'trim',\n              array_reverse(\n                array_map(\n \
    \                 'intval',\n                  $nums))))))),\n    SORT_ASC, $nums);\n\
    \  return $nums;\n}\n", "\t$sums = array_sum($nums);\n\tif ($sums > 0) {\n\t\t\
    array_multisort($nums, $sums);\n\t} else {\n\t\tarray_multisort($nums);\n\t}\n\
    }\n", "  // Use $nums as temporary array of integers\n  // whose digits will be\
    \ summed.\n  $sum_arr = array_map(function($num) { return str_pad($num, 0, STR_PAD_LEFT);\
    \ }, $nums);\n  sort($sum_arr);\n  return array_map(function($sum_str) { return\
    \ array_search($sum_str, $sum_arr); }, $sum_arr);\n}\n</code>\nThe above function\
    \ works only for arrays with integers consisting of digits (0 to 9) and strings.\
    \ The following function can be used to sort an arbitrary array of objects, assuming\
    \ the objects have a method getPoints() which returns an array of integers:\n\
    <code>\n<?php", "  // TODO: Write this function.\n}", "  $sorted = array();\n\
    \  usort($nums, function($a, $b) {\n    return $a + $b;\n  });\n  $sorted = array_reverse($sorted);\n\
    \  return $sorted;\n}\n", "  // Create a table of sums and their counts,\n  //\
    \ and each entry will be a pair of (sum, count)\n  $sums = array_count_values(array_map('intval',\
    \ array_filter(array_map('intval', $nums))));\n\n  // Sort by sum in descending\
    \ order\n  arsort($sums, SORT_NUMERIC);\n\n  // Then, sort by the sum in ascending\
    \ order\n  $result = array_keys($sums);\n  foreach ($sums as $k => $v) {\n   \
    \ $result[$k] = $k + 1;\n  }\n  return $result;\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nThis returns an array containing only the values where the sum of the\
    \ digits is the same as the count of the values.  I need it to return the values\
    \ where the sum is the same.  For example, if the array is { 2, 5, 7, 1, 3, 6,\
    \ 4, 8 }, I would want it to return { 2, 7, 4, 6 } and { 5, 3, 8, 1 }\n<|/ c |>\n\
    <| a tags=php,sorting,arrays |>\n<code>\n$arr = [2, 5, 7, 1, 3, 6, 4, 8];\n$res\
    \ = [];\nfor($i=0;$i<count($arr);$i++){\n    if($arr[$i] == $arr[$i+1]){\n   \
    \     unset($arr[$i+1]);\n    }\n    $sum = 0;\n    for($j=$i;$j<count($arr);$j++){\n\
    \        $sum += $arr[$j];\n    }\n    $res[$sum] = $arr[$i];\n}\n$result = array_values($res);\n\
    </code>\noutput:\n<code>\nArray\n(\n    [0] => 2\n    [1] => 7\n    [2] => 4\n\
    \    [3] => 6\n)\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis works beautifully.\
    \  Thank you very much!  I just had to change a few things to get the exact output\
    \ I needed, and I'm sure I'll make them myself in the future :)\n<|/ c |>\n<|\
    \ c |>\nI modified it a bit to make it work.  It was giving me the wrong output\
    \ when the first two numbers were the same, but I fixed it by unsetting the value\
    \ after the first iteration (I only needed to unset it once).\n<|/ c |>\n<| a\
    \ tags=php,sorting,arrays |>\nThis is my solution.\n<code>\n<?php\n$arr = array(2,\
    \ 5, 7, 1, 3, 6, 4, 8);\n$newArr = array();\n$sum = 0;\nfor ($i = 0; $i < count($arr);\
    \ $i++) {", "  arsort($nums);\n  return $nums;\n}\n", "  $sums = array_sum($nums);\n\
    \  array_walk($nums, function(&$num) { $num *= -1; }, $sums);\n  return array_merge($nums);\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks for your answer, but it is actually\
    \ not what I need. Your code sorts according to its original position in the array.\
    \ I need it to sort the array according to its sum of its digits.\n<|/ c |>\n\
    <| c |>\nAh I see. I've edited my answer.\n<|/ c |>\n<| c |>\nThanks for the edit!\
    \ I tested your updated code and it doesn't really do what I want... It sorts\
    \ according to its original position in the array. Also, it doesn't allow for\
    \ negative numbers.\n<|/ c |>\n<| c |>\nYou were right about the original position.\
    \ I forgot to return `$nums` from the function. I updated the answer with the\
    \ correction.\n<|/ c |>\n<| a tags=sorting,arrays,php |>\nThis should do the trick:\n\
    <code>", "  if (!$nums) {\n    return array();\n  }\n  $arr = array();\n  foreach\
    \ ($nums as $i => $num) {\n    $d = array_sum(str_split($num));\n    if (!isset($arr[$d]))\
    \ {\n      $arr[$d] = array();\n    }\n    $arr[$d][] = $nums[$i];\n  }\n  foreach\
    \ ($arr as $d => $nums) {\n    sort($nums);\n  }\n  $ret = array();\n  foreach\
    \ ($arr as $nums) {\n    foreach ($nums as $num) {\n      $ret[] = $num;\n   \
    \ }\n  }\n  return $ret;\n}\n</code>\n<|/ a tags=sorting,php dscore=3 |>\n<| c\
    \ |>\nI see no reason why this should fail.  Are you sure that the input is correct\
    \ for the function to be used?\n<|/ c |>\n<| a dscore=2 |>\n<code>\n$array = array();\n\
    $array = array(3, 6, 9, 7, 8, 10, 2, 5, 1, 9, 11, -12, -13, 15, 14, 4, 1, -13,\
    \ -12, -9, -7, -7, 4, 15, 14, -3, -3, -4, -3, -4, -4, -7, -3, -7, 7, -9, -7, 9,\
    \ -1, 9, -1, -9, -9, -6, -9, -7, -9, -7, -9, -9, -9, -9, -9, 7, -10, -10, -9,\
    \ 10, -7, 10, -7, 10, -10, 8, -7, -7, -7, 10, -7, 9, -7, -7, -7, -7, -7, 10, 10,\
    \ -10, -10, 10, -9, 9, 9, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7,\
    \ -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7,\
    \ -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7,\
    \ -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7,\
    \ -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7,\
    \ -7, -7, -7, -7, -7, -7, ", "    $ordered = [];\n    $counts = array_count_values($nums);\n\
    \    foreach ($counts as $index => $count) {\n        $ordered[$index] = $index;\n\
    \    }\n    array_multisort(array_map('array_sum', $ordered), SORT_ASC, $nums);\n\
    \    return $nums;\n}\n", "  return $nums;\n}", "  if (empty($nums))\n    return\
    \ $nums;\n\n  $sums = array_sum($nums);\n  $idxs = array_keys($nums, $sums);\n\
    \  sort($idxs);\n  return array_map(function($k) { return $nums[$k]; }, $idxs);\n\
    }\n", "  if (empty($nums)) {\n    return array();\n  }\n  $resultArr = array();\n\
    \  $maxPoints = array_reduce($nums, function($maxPoint, $num) {\n    return max($maxPoint,\
    \ $num);\n  });\n  $minPoints = array_reduce($nums, function($minPoint, $num)\
    \ {\n    return min($minPoint, $num);\n  });\n  for ($i = 0; $i < count($nums);\
    \ $i++) {\n    $resultArr[] = $nums[$i];\n  }\n  uasort($resultArr, function($a,\
    \ $b) {\n    return $a + $b;\n  });\n  foreach ($resultArr as $key => $value)\
    \ {\n    $nums[$key] = $value;\n  }\n  for ($i = 0; $i < count($nums); $i++) {\n\
    \    $nums[$i] = $nums[$i] - $minPoints + $maxPoints;\n  }\n  return $nums;\n}",
  "  // Implement the algorithm for sorting an array of integers in ascending order\n\
    \  // according to the sum of their digits.\n  // Don't forget to sort the array\
    \ first.\n  \n  $sums = array_sum($nums);\n  sort($nums);\n  \n  foreach ($nums\
    \ as $index => $num) {\n    if ($sums[$index] == 0) {\n      return $nums;\n \
    \   }\n    $sums[$index] -= $num;\n  }\n  \n  return $nums;\n}\n", "  $result\
    \ = [];\n\n  foreach ($nums as $n) {\n    $parts = str_split($n);\n    $sum =\
    \ 0;\n    foreach ($parts as $part) {\n      $sum += intval($part);\n    }\n \
    \   $result[] = $sum;\n  }\n\n  // sort them in descending order\n  array_multisort($result,\
    \ SORT_DESC);\n\n  return $result;\n}", "  // Write your code here.\n  return\
    \ array_map('orderByPoints', $nums);\n}", "  $sorted_nums = array();\n  $sorted_index\
    \ = 0;\n  $sorted_num_sum = 0;\n  $sorted_num_sum2 = 0;\n  foreach ($nums as $num)\
    \ {\n    $digits = explode('', $num);\n    $num_sum = 0;\n    $num_sum2 = 0;\n\
    \    foreach ($digits as $digit) {\n      $num_sum += $digit;\n      $num_sum2\
    \ += $digit * $digit;\n    }\n    if ($num_sum == $sorted_num_sum) {\n      $sorted_nums[$sorted_index]\
    \ = $num;\n      $sorted_num_sum2 = $sorted_num_sum2;\n      $sorted_num_sum +=\
    \ $num_sum;\n      $sorted_index++;\n    } else if ($num_sum2 > $sorted_num_sum2)\
    \ {\n      $sorted_nums[$sorted_index] = $num;\n      $sorted_num_sum2 = $num_sum2;\n\
    \      $sorted_num_sum = $num_sum;\n      $sorted_index++;\n    }\n  }\n  return\
    \ $sorted_nums;\n}\n", "  if (!is_array($nums)) $nums = array($nums);\n  $nums_copy\
    \ = array_reverse($nums);\n  $sums = array_sum($nums_copy);\n  arsort($sums);\n\
    \  $points = array();\n  foreach ($sums as $sum) {\n    foreach ($nums_copy as\
    \ $key => $num) {\n      if ($sum == $num) $points[] = $nums_copy[$key];\n   \
    \ }\n  }\n  return $points;\n}", "  $sorted_arr = [];\n  for ($i = 0, $length\
    \ = count($nums); $i < $length; $i++) {\n    $digits = str_split($nums[$i]);\n\
    \    $sorted_arr[$digits] = $i;\n  }\n  natsort($sorted_arr);\n  return array_values($sorted_arr);\n\
    }", "  sort($nums, SORT_NUMERIC);\n  $sums = array_sum($nums);\n  usort($nums,\
    \ function($a, $b) use ($sums) {\n    return $sums - $a - $b;\n  });\n  return\
    \ $nums;\n}\n", "    uasort($nums, function ($a, $b) {\n        $sum1 = $a + $b;\
    \ // a +b is the same as $a + $b, without overflow\n        $sum2 = $sum1; //\
    \ $sum2 is just $sum1\n        $sum = 0;\n        foreach (str_split($sum2) as\
    \ $digit) {\n            $sum += (int)$digit;\n        }\n        return $sum\
    \ - $a;\n    });\n    return $nums;\n}\n", "    if (empty($nums)) {\n        return\
    \ $nums;\n    }\n\n    // Sort the numbers in descending order\n    // by looking\
    \ at the sum of their digits.\n    $sums = array_sum($nums);\n\n    asort($nums);\n\
    \    asort($sums);\n\n    $nums = array_merge($nums, array_fill(0, count($sums),\
    \ $sums));\n\n    // Re-sort the given array\n    return array_reverse($nums);\n\
    }\n\n$a1 = array();\n$a2 = array();\n$a3 = array();\n$a4 = array();\n\n$a3 = array('first'=>1,'second'=>2,'third'=>3,'fourth'=>4,'fifth'=>5);\n\
    $a4 = array('first'=>1,'second'=>2,'third'=>3,'fourth'=>4,'fifth'=>5);\n$a1 =\
    \ array('first'=>1,'second'=>2,'third'=>3,'fourth'=>4,'fifth'=>5);\n\n$a2 = array('first'=>1,'second'=>2,'third'=>3,'fourth'=>4,'fifth'=>5);\n\
    $a4 = array('first'=>1,'second'=>2,'third'=>3,'fourth'=>4,'fifth'=>5);\n\n$a4\
    \ = array('first'=>1,'second'=>2,'third'=>3,'fourth'=>4,'fifth'=>5);\n$a2 = array('first'=>1,'second'=>2,'third'=>3,'fourth'=>4,'fifth'=>5);\n\
    \n$a3 = array('first'=>1,'second'=>2,'third'=>3,'fourth'=>4,'fifth'=>5);\n$a3\
    \ = array('first'=>1,'second'=>2,'third'=>3,'fourth'=>4,'fifth'=>5);\n\n$a1 =\
    \ array('first'=>1,'second'=>2,'third'=>3,'fourth'=>4,'fifth'=>5);\n$a1 = array('first'=>1,'second'=>2,'third'=>3,'fourth'=>4,'fifth'=>5);\n\
    $a1 = array('first'=>1,'second'=>2,'third'=>3,'fourth'=>4,'fifth'=>5);\n$a1 =\
    \ array('first'=>1,'second'=>2,'third'=>3,'fourth'=>4,'fifth'=>5);\n$a1 = array('first'=>1,'second'=>2,'third'=>3,'fourth'=>4,'fifth'=>5);\n\
    $a1 = array('first'=>1,'second'=>2,'third'=>3,'fourth'=>4,'fifth'=>5);\n$a1 =\
    \ array('first'=>1,'second'=>2,'third'=>3,'fourth'=>4,'fifth'=>5);", "    usort($nums,\
    \ create_function(\n        '$n1, $n2', \n        'return $n1 <=> $n2; '\n   \
    \ ));\n    return $nums;\n}\n", "    $numsSorted = array();\n    $sumOfDigits\
    \ = 0;\n    foreach ($nums as $key => $num) {\n        // Use array_search() so\
    \ that duplicate elements are removed from the array.\n        $sortedKey = array_search($num,\
    \ array_values($numsSorted));\n        if ($sortedKey === FALSE) {\n         \
    \   $sumOfDigits += $num;\n        } else {\n            $numsSorted[$sortedKey]\
    \ = $num;\n            unset($numsSorted[$key]);\n        }\n    }\n    return\
    \ $numsSorted;\n}\n", "    $sum = 0;\n    foreach ($nums as $n) {\n        $sum\
    \ += intval($n);\n    }\n    return array_filter($nums, function($n) use (&$sum)\
    \ {\n        $n = intval($n);\n        return $n != 0 && $n == $sum;\n    });\n\
    }\n", "  $sums = array_sum($nums);\n  $orders = array();\n  foreach ($nums as\
    \ $i => $num) {\n    $orders[$i] = $i;\n  }\n  // Sort from largest to smallest\n\
    \  rsort($orders);\n  foreach ($orders as $i => $order) {\n    $sums[$i] += $order;\n\
    \  }\n  return array_map(function ($num) use ($sums) {\n    return $sums[$num];\n\
    \  }, $nums);\n}\n", "    if (empty($nums)) return array();\n    $sum_of_digits\
    \ = array_sum($nums);\n    return array_map(function ($n) use ($sum_of_digits)\
    \ {\n        return $sum_of_digits > $n ? $sum_of_digits - $n : $n;\n    }, $nums);\n\
    }\n", "  return array_reduce($nums, function($carry, $item) {\n    $carry += floor($item/10)\
    \ * $item%10;\n    return $carry;\n  }, 0);\n}\n", "  if (empty($nums)) return\
    \ array();\n  $sums = array_sum($nums);\n  $order = array();\n  $i = 0;\n  while\
    \ (!empty($sums)) {\n    $j = 0;\n    foreach ($sums as $s) {\n      if ($s ==\
    \ $sums) {\n        $order[$i] = $nums[$j];\n        $j++;\n      }\n    }\n \
    \   $i++;\n    $sums = array_sum($nums);\n  }\n  return $order;\n}", "  $numsSorted\
    \ = array_reverse($nums);\n  usort($numsSorted, function ($a, $b) {\n    // Reverse\
    \ sort with sum of digits first\n    return $a + $b - ($a + $b) * preg_replace('/(\\\
    d+)$/', '', $a) - ($a + $b) * preg_replace('/(\\d+)$/', '', $b);\n  });\n  return\
    \ $numsSorted;\n}\n", "  $sum_arr = [];\n  for ($i = 0; $i < count($nums); $i++)\
    \ {\n    $sum_arr[$i] = array_sum($nums[$i]);\n  }\n  usort($nums, function($a,\
    \ $b) {\n    return strnatcmp($sum_arr[$a], $sum_arr[$b]);\n  });\n  return $nums;\n\
    }", "    $sums = array_sum($nums);\n    $ord = array_map(\n        function($num)\
    \ use ($sums) {\n            $digits = array_map(\n                function($x)\
    \ use ($sums) { return $x*10 + $sums; },\n                str_split($num)\n  \
    \          );\n            return max($digits);\n        },\n        $nums\n \
    \   );\n    return $ord;\n}\n</code>\n<|/ a dscore=3 tags=php,arrays,sorting |>\n\
    <| c |>\nA few notes: `array_sum` and `array_map` are not available in my version\
    \ of php (5.5.9). The first one is not available in php 5.4 (I need the array_sum\
    \ function for the `array_map` function), and `array_map` does only work on single\
    \ values, not arrays. I replaced them by `array_walk` and `array_map`. It works\
    \ much faster.\n<|/ c |>\n<| c |>\n: Okay, sorry about that. `array_sum` would\
    \ have to be `array_walk` then.\n<|/ c |>\n<| a |>\n<code>\n$result = array();\n\
    \nforeach ($array as $item) {\n    $result[$item] = $item;\n}\n\narsort($result);\n\
    </code>\nWill not work if you have more than one element with the same sum. For\
    \ that you'll have to use usort() together with array_count_values().\n<|/ a dscore=2\
    \ tags=php,arrays,sorting |>\n<| c |>\nHow can this work? The result will be an\
    \ array with only one key\n<|/ c |>\n<| c |>\n: That's what I said; it will work\
    \ if you have more than one element with the same sum. For that you'll have to\
    \ use usort() together with array_count_values().\n<|/ c |>\n<| a |>\nI came up\
    \ with a solution using array_reduce() and a closure for array_sum(). While I\
    \ was trying to figure out the best way to sort the array I noticed the following\
    \ pattern in my arrays:\n\nI used this pattern as a way to sort a bunch of arrays\
    \ by their respective sum. Here is what I came up with:\n<code>", "    sort($nums,\
    \ SORT_NUMERIC);\n    $result = [];\n    $prev = 0;\n    foreach ($nums as $num)\
    \ {\n        if ($num != $prev) {\n            $prev = $num;\n            $result[]\
    \ = $num;\n        }\n    }\n    return $result;\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\n`-` is not a valid part of a number, so `0` should be the highest/smallest\
    \ number. `-11` should be the highest/lowest number. `1` should be the second\
    \ highest/lowest number.\n<|/ c |>\n<| c |>\nNotice that `-` is not part of the\
    \ number. `-11` is *negative* 11.\n<|/ c |>\n<| c |>\nI think you're confusing\
    \ two concepts. Negative numbers are still numbers. Numbers that have a - in front\
    \ of them are not negative numbers. It's just how negative numbers are displayed\
    \ that makes it look like they are negative numbers.\n<|/ c |>\n<| c |>\nSorry,\
    \ I misunderstood your statement. I am not confusing negative numbers with negative\
    \ numbers. Sorry for the misunderstanding.\n<|/ c |>\n<| c |>\nNo, that's fine,\
    \ I was just clarifying what you were saying. Negative numbers still have a \"\
    -\" in front of them just like positive numbers do.\n<|/ c |>\n<| a dscore=1 |>\n\
    Here is my solution:\n<code>\n$array1 = array(111, 110, -1, -10, -1, -10, -5);\n",
  "  if (!$nums) return $nums;\n  usort($nums, function($a, $b) use ($nums) {\n  \
    \  $sum = 0;\n    foreach ($nums as $i) {\n      $sum += $i;\n    }\n    return\
    \ $sum - $b;\n  });\n  return $nums;\n}\n", "  $sums = array_map(function($n)\
    \ { return $n; }, $nums);\n  array_multisort($sums, array_keys($sums), $nums);\n\
    \  return $nums;\n}\n</code>\n<|/ a tags=php,sorting,arrays dscore=5 |>\n<| c\
    \ |>\nI appreciate all the answers but  I accepted this because it was the easiest\
    \ to understand and it does exactly what I need.  I did have to add some code\
    \ to make it work for my purpose.\n<|/ c |>\n<| c |>\nI needed this too, but I\
    \ needed to sort by two parameters: one is a count of occurence in an array and\
    \ the other is by an associative key of an array element that I am sorting by.\n\
    <|/ c |>\n<| c |>\nGreat solution! However, I noticed that if you have a string\
    \ '11' it will sort it after '2', because it compares character-wise.\n<|/ c |>\n\
    <| c |>\n: I believe the comparison is done character-wise - and thus '11' is\
    \ after 2\n<|/ c |>\n<| c |>\n: I did a little research and found that your solution\
    \ is a lot faster than the other solutions posted here. So, I've adapted it to\
    \ my needs which is to sort by the length of strings. https://gist.github.com/falkedesign/735994ee0d0b4af3be896dbddb084e76\n\
    <|/ c |>\n<| a tags=php,sorting,arrays |>\nYou can use usort with closure:\n<code>\n\
    $a = array(2, 5, 7, 1, 7, 1, 1, 2, 1);\n\nusort($a, function($a, $b) {\n    return\
    \ $a <=> $b;\n});\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis is the right answer\
    \ for me - it allows the comparison of multiple fields (like sorting by name,\
    \ last name, etc.).\n<|/ c |>\n<| c |>\nNote that in PHP 5.3, the order of `<=>`\
    \ is changed: http://php.net/manual/en/migration54.new-features.php\n<|/ c |>\n\
    <| a tags=php,sorting,arrays |>\narray_multisort can do exactly what you need:\n\
    <code>\n$array = array(1, 2, 3, 4, 5);\n$sorted = array_multisort($array, SORT_DESC,\
    \ SORT_NUMERIC, $array);\n</code>\nOutputs:\n<code>\nArray\n(\n    [0] => 5\n\
    \    [1] => 4\n    [2] => 3\n    [3", "  $map = array();\n  foreach ($nums as\
    \ $n => $sum) {\n    $key = $sum % 10;\n    if (!isset($map[$key])) {\n      $map[$key]\
    \ = $n;\n    } else if ($map[$key] < $n) {\n      $map[$key] = $n;\n    }\n  }\n\
    \  return array_values($map);\n}\n", "  // Write your code here\n  $sums = array_map(function\
    \ ($num) {\n    return array_sum(str_split($num));\n  }, $nums);\n  $result =\
    \ array_search(min($sums), $sums);\n  return $nums[$result];\n}\n</code>\n<|/\
    \ a dscore=0 |>\n<| a tags=sorting,php dscore=0 |>\nA simple way is to use strnatcmp()\
    \ and implement the function as such:\n<code>", "  if (empty($nums)) {\n    return\
    \ array();\n  }\n  $result = array();\n  $carry = 0;\n  foreach ($nums as $idx\
    \ => $num) {\n    // We have $num - $carry to subtract, and $carry to add up\n\
    \    $result[] = $num - $carry;\n    // Move to next element to process further\n\
    \    $carry = $num;\n  }\n  // If $carry remains, then it means that there were\
    \ duplicates\n  // Remove them from original array and add them to the result\
    \ array\n  if ($carry > 0) {\n    while (count($result) >= 1) {\n      // Remember\
    \ the highest number we find in result\n      $max_sum = max($result);\n     \
    \ unset($result[$max_sum]);\n      $result[] = $carry;\n      $carry = 0;\n  \
    \  }\n    // Add remainder to result and carry to the last element\n    if ($carry\
    \ > 0) {\n      $result[] = $carry;\n    }\n  }\n  return $result;\n}\n", "  \
    \  if (!$nums) return $nums;\n    \n    // create sum of digits array\n    $sum_digits\
    \ = array_map(function($i) { return $i%10; }, $nums);\n    \n    // sort the original\
    \ array by the sum of digits\n    usort($nums, function($a, $b) use ($sum_digits)\
    \ {\n        return $sum_digits[$a] - $sum_digits[$b];\n    });\n    \n    return\
    \ $nums;\n}\n", "    // Sort the numbers based on their sum\n    // return array_reduce($nums,\
    \ function($carry, $item) {\n    //     return $carry + $item;\n    // }, 0);\n\
    \n    foreach ($nums as $key => $val) {\n        $sum = 0;\n        for ($i =\
    \ $key; $i >= 0; $i--) {\n            $sum = $sum + $nums[$i];\n        }\n  \
    \      $nums[$key] = $sum;\n    }\n\n    arsort($nums);\n\n    return $nums;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis works, but it is slower than sorting the array\
    \ and just swapping values if the sum of two numbers is the same. Of course it\
    \ takes more time, but on larger arrays it can be much faster.\n<|/ c |>\n<| c\
    \ |>\nThis doesn't work well, with duplicate values or a number that is evenly\
    \ divisible.\n<|/ c |>\n<| c |>\nIf you have any duplicates, this will break.\
    \  It also breaks for even numbers that are evenly divisible and have duplicates.\n\
    <|/ c |>\n<| c |>\nWhy do you think that this doesn't work well? I tested this\
    \ on arrays with duplicate values, and it worked. If you are referring to even\
    \ numbers with duplicates, it does work. I don't know what you are referring to.\
    \ Can you provide an example?\n<|/ c |>\n<| c |>\n: You are mistaken. Your code\
    \ won't work correctly for even numbers that are evenly divisible (e.g., `[1,1,2,3]`\
    \ -> `[2,1,3,1]`), but it will work for all cases where there are duplicates (e.g.,\
    \ `[2,2,2,2]` -> `[2,2,2,2]`). My code breaks for those cases, because I keep\
    \ track of which number has which position in the array (by using the `key` of\
    \ the original array, not its value).\n<|/ c |>\n<| a dscore=3 tags=sorting,arrays,php\
    \ |>\nThis can easily be done with usort with a custom callback function:\n<code>",
  "  $sums = array_map('strval', array_count_values($nums));\n  asort($sums);\n  return\
    \ array_intersect_key($nums, $sums);\n}", "    if (!$nums)\n        return array();\n\
    \    $num_map = array();\n    foreach ($nums as $n) {\n        $n = str_split($n);\n\
    \        $digit = 0;\n        foreach ($n as $char) {\n            $digit += intval($char);\n\
    \            $num_map[$digit][] = $n;\n        }\n    }\n    return array_map(function\
    \ ($n) {\n        return array_sum($n);\n    }, array_values($num_map));\n}\n",
  "    if (empty($nums)) return $nums;\n    $nums[] = 0;\n    $sum = 0;\n    foreach\
    \ ($nums as $n) {\n        if ($n < 0) $n *= -1;\n        $sum += $n;\n      \
    \  $nums[$n] = $sum;\n    }\n    ksort($nums);\n    return array_reverse($nums);\n\
    }\n", "  if (!is_array($nums) || !count($nums))\n    return array();\n\n  $digits\
    \ = array_sum($nums);\n  $arr = array();\n  $j = 0;\n  for ($i = 0; $i < count($nums);\
    \ ++$i) {\n    $arr[$i] = $nums[$i];\n    while (isset($digits[$j])) {\n     \
    \ $arr[$i] = ($arr[$i] - $digits[$j]) % 10;\n      $j = ($j + 1) % count($nums);\n\
    \    }\n  }\n\n  return $arr;\n}\n", "  $points = array_map(function ($n) {\n\
    \    return $n[0] + $n[1];\n  }, $nums);\n  sort($points, SORT_NUMERIC);\n  return\
    \ array_map(function ($n) {\n    return $nums[$n];\n  }, $points);\n}\n", "  //\
    \ Write your code here.\n}\n", "  // Write your code here.\n}\n", "  if (!is_array($nums))\
    \ {\n    return array();\n  }\n  $nums = array_map('intval', $nums);\n  $result\
    \ = array();\n  foreach ($nums as $index => $num) {\n    $sum = 0;\n    foreach\
    \ (str_split($num) as $digit) {\n      $sum += intval($digit);\n    }\n    $result[$index]\
    \ = $sum;\n  }\n  asort($result);\n  return array_values($result);\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThis solution worked perfectly for me. Easy, effective,\
    \ and fast for what I was trying to do.  Thank you!\n<|/ c |>\n<| a tags=sorting,php\
    \ |>\nHere you go. This will take your numbers and sort them in ascending order\
    \ according to their sum of the digits. To reverse the sort, just use array_reverse().\
    \ \n<code>\n<?php\n\n$nums = array(1, 11, -1, -11, -12);\n\n$sorted = array();\n\
    \n$sum = 0;\nforeach ($nums as $num) {\n    foreach (str_split($num) as $digit)\
    \ {\n        $sum += intval($digit);\n    }\n    $sorted[$sum] = $num;\n    $sum\
    \ = 0;\n}\n\n$sorted = array_values($sorted);\nvar_dump($sorted);", "    $sums\
    \ = array_map(function($num) {\n        return $num % 10 + $num / 10;\n    },\
    \ $nums);\n\n    return array_map(function($sum) use ($sums) {\n        uasort($sums,\
    \ function($a, $b) use ($sum) {\n            return ($sums[$sum] - $sums[$a])\
    \ - $sums[$b];\n        });\n        return array_pop($sums);\n    }, $sums);\n\
    }\n</code>\nTesting:\n<code>\nprint_r(order_by_points(array(9, 5, -1, -9, 2)));\n\
    print_r(order_by_points(array()));\nprint_r(order_by_points(array(9, 5, -1, -9,\
    \ 2, 7, -2, 2)));\nprint_r(order_by_points(array(9, 5, -1, -9, 2, 7, -2, 3, -2)));\n\
    print_r(order_by_points(array(9, 5, -1, -9, 2, 7, -2, 3, -2, 4)));\nprint_r(order_by_points(array(9,\
    \ 5, -1, -9, 2, 7, -2, 3, -2, 4, 8)));\nprint_r(order_by_points(array(9, 5, -1,\
    \ -9, 2, 7, -2, 3, -2, 4, 8, -2)));\nprint_r(order_by_points(array(9, 5, -1, -9,\
    \ 2, 7, -2, 3, -2, 4, 8, -2, 5)));\nprint_r(order_by_points(array(9, 5, -1, -9,\
    \ 2, 7, -2, 3, -2, 4, 8, -2, 5, 12)));\nprint_r(order_by_points(array(9, 5, -1,\
    \ -9, 2, 7, -2, 3, -2, 4, 8, -2, 5, 12, -1)));\nprint_r(order_by_points(array(9,\
    \ 5, -1, -9, 2, 7, -2, 3, -2, 4, 8, -2, 5, 12, -1, 14)));\nprint_r(order_by_points(array(9,\
    \ 5, -1, -9, 2, 7, -2, 3, -2, 4, 8, -2, 5, 12, -1, 14, -2)));\nprint_r(order_by_points(array(9,\
    \ 5, -1, -9, 2, 7, -2, 3, -2, 4, 8, -2, 5, 12, -1, 14, -2, 15)));\n</code>\nResult:\n\
    <code>\nArray\n(\n    [0] => 9\n    [1] => 5\n    [2] => -1\n    [3] => -9\n \
    \   [4] => 2\n    [5] => -7\n    [6] => -2\n)\nArray\n(\n)\nArray\n(\n    [0]\
    \ => 9\n    [1] => 5\n    [2] => -1\n    [3] => -9\n    [4] => 2\n    [5] => -7\n\
    \    [6] => -2\n    [7] => -3\n    [8] => -2\n)\nArray\n(\n    [0] => 9\n    [1]\
    \ => 5\n    [2] => -1\n    [3] => -9\n    [4] => 2\n    [5] => -7\n    [6] =>\
    \ -2\n    [7] => -3\n    [8] => ", "  // Sort by points sum.\n  arsort($nums);\n\
    \  $nums = array_reverse($nums);\n  return $nums;\n}", "    // Sort in ascending\
    \ order based on total sum of their digits.\n    // This will be slow for huge\
    \ arrays, but is guaranteed to be\n    // correct for smaller ones (O(n logn)\
    \ vs. O(n^2)).\n    sort($nums, SORT_NUMERIC);\n\n    // Sum up digits from 1\
    \ to 9 for each number (from 0 to 9).\n    $digits = array();\n    for ($i = 0;\
    \ $i < count($nums); ++$i) {\n        $digits[$i] = array_sum(str_split($nums[$i]));\n\
    \    }\n\n    // Sort again based on original array index.\n    sort($digits,\
    \ SORT_NUMERIC);\n\n    return $digits;\n}\n", "    sort($nums);\n    uasort($nums,\
    \ function($a, $b) { return $a + $b; });\n    return $nums;\n}\n\n$nums = order_by_points($nums);",
  "    $sorted = array();\n    foreach ($nums as $num) {\n        $point = 0;\n  \
    \      for ($i = strlen($num); $i > 0; $i--) {\n            $point += substr($num,\
    \ $i, 1) * pow(10, $i);\n        }\n        $sorted[] = $num;\n        $sorted[]\
    \ = $point;\n    }\n    array_multisort($sorted, $nums);\n    return $nums;\n}",
  "  $sorted_arr = array();\n  for ($i = 0; $i < count($nums); $i++) {\n    // Initialize\
    \ sum to zero.\n    $sum = 0;\n    // Iterate through the current number $num.\n\
    \    for ($j = 0; $j < strlen($nums[$i]); $j++) {\n      // Get the current digit.\n\
    \      $digit = $nums[$i][$j];\n      // Add it to the sum so far.\n      $sum\
    \ += $digit;\n    }\n    // If the sum is different from the current number,\n\
    \    // push the current number into $sorted_arr.\n    if ($sorted_arr[$i] !=\
    \ $sum) {\n      $sorted_arr[$i] = $sum;\n    }\n  }\n  return $sorted_arr;\n}",
  "  if (empty($nums)) return array();\n  \n  $sums = array_map(function($n) {\n \
    \   return $n->sum();\n  }, $nums);\n  $sum = array_sum($sums);\n  ksort($sums);\n\
    \  $result = array();\n  foreach ($sums as $k => $v) {\n    if ($sum >= $k) array_push($result,\
    \ $k);\n  }\n  return array_map(function($n) {\n    return $nums[$n];\n  }, $result);\n\
    }\n", "  $result = array();\n  foreach ($nums as $key => $num) {\n    $sum_of_digits\
    \ = 0;\n    for ($i = 0; $i < strlen($num); $i++) {\n      $sum_of_digits += $num{$i};\n\
    \    }\n    // Store the number with the highest sum of digits\n    $result[$key]\
    \ = $num;\n  }\n  return $result;\n}\n", "  // Create a hash map of sums and their\
    \ order\n  $sums = array_sum($nums);\n  arsort($nums);\n  $nums = array_map(function($v)\
    \ use($sums) {\n    $hash = 0;\n    foreach (str_split($v) as $digit) {\n    \
    \  $hash += $digit;\n    }\n    return $sums - $hash;\n  }, $nums);\n\n  return\
    \ $nums;\n}", "    // Write your code here.\n    return $nums;\n}\n", "  $sort\
    \ = array();\n  $sum = 0;\n  foreach ($nums as $num => $value) {\n    $sum +=\
    \ $value;\n    $sort[$sum] = $num;\n  }\n  asort($sort);\n  return $sort;\n}\n\
    </code>\n<|/ a tags=php,arrays dscore=0 |>\n<| c |>\nPlease add further details\
    \ to expand on your answer, such as working code or documentation citations.\n\
    <|/ c |>\n<| a |>\n<code>", "    $sum_of_digits = array_sum($nums);\n    if (!$sum_of_digits)\
    \ {\n        return array();\n    }\n    uasort($nums, function($a, $b) use ($sum_of_digits)\
    \ {\n        $sum = $a + $b + $sum_of_digits;\n        if ($sum === 0) {\n   \
    \         return 0;\n        }\n        return $sum < 0 ? -1 : 1;\n    });\n \
    \   return $nums;\n}\n</code>\nIf you don't want to use array_sum you can do it\
    \ like this:\n<code>", "    $sorted_nums = array();\n    $running_sum = 0;\n \
    \   $count = count($nums);\n    for ($i = 0; $i < $count; $i++) {\n        $digit\
    \ = $nums[$i];\n        if ($digit < 0) {\n            $digit = -$digit;\n   \
    \     }\n        if ($running_sum >= $digit) {\n            $sorted_nums[$i] =\
    \ $running_sum;\n        } else {\n            $running_sum += $digit;\n     \
    \       $sorted_nums[$i] = $i;\n        }\n    }\n    return $sorted_nums;\n}\n",
  "\t$result = array();\n\tforeach ($nums as $i => $num) {\n\t\t$sum = 0;\n\t\tforeach\
    \ (str_split($num) as $digit) {\n\t\t\t$sum += intval($digit);\n\t\t}\n\t\t$result[$i]\
    \ = $num;\n\t\t$result[$i]['order'] = $sum;\n\t}\n\tuasort($result, 'order_by_points_cmp');\n\
    \treturn array_values($result);\n}\n", "    return array_map('strval', array_map(function\
    \ ($n) {\n        return count($nums) * $n;\n    }, $nums));\n}", "  natsort($nums,\
    \ SORT_NUMERIC);\n  $sums = array_map('intval', array_map(function($n) { return\
    \ strval($n); }, $nums));\n  arsort($sums);\n  foreach ($nums as $i => $num) {\n\
    \    $sums[$i] = $sums[$i] - $num;\n  }\n  return array_map(function($n) { return\
    \ $n - $sums[$i]; }, $nums);\n}\n</code>\n<code>\n<?php", "    if (empty($nums))\
    \ {\n        return array();\n    }\n    $points = [];\n    $sum = array_sum($nums);\n\
    \    foreach ($nums as $index => $value) {\n        $points[] = $value;\n    \
    \    $points[] = ($index * $value) / $sum;\n    }\n    array_multisort($points,\
    \ $nums, SORT_ASC, $nums);\n    return $nums;\n}\n", "  natsort($nums);\n  uasort($nums,\
    \ function($a, $b) use ($nums) {\n    return $nums[$a] - $nums[$b];\n  });\n \
    \ return $nums;\n}\n</code>\n<|/ a dscore=5 tags=sorting,php,arrays |>\n<| c |>\n\
    Awesome! Thank you for this! I ran the script and it worked perfectly. Thanks!\n\
    <|/ c |>\n<| a tags=sorting,php,arrays dscore=5 |>\nYou could write a comparison\
    \ function, and pass it to usort() like this:\n<code>", "  if (empty($nums)) {\n\
    \    return $nums;\n  }\n  $sums = array_sum($nums);\n  usort($nums, function\
    \ ($a, $b) use ($sums) {\n    return $sums - $a - $b;\n  });\n  return $nums;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a tags=php,arrays,sorting dscore=1 |>\n<code>",
  "    $sums = array_sum($nums);\n    $result = array();\n    foreach ($nums as $index\
    \ => $num) {\n        if ($num != 0) {\n            $result[$index] = $num;\n\
    \            if (isset($sums[$index])) {\n                $result[$index] += $sums[$index];\n\
    \            }\n        }\n    }\n    return array_values($result);\n}\n", " \
    \   if (empty($nums)) {\n        return array();\n    }\n    $sum = array_sum($nums);\n\
    \    $ret = array();\n    foreach ($nums as $k => $v) {\n        $ret[$k] = $v;\n\
    \    }\n    asort($ret);\n    foreach ($nums as $k => $v) {\n        if ($v !=\
    \ $sum) {\n            $ret[$k] = $sum;\n        }\n    }\n    return $ret;\n\
    }\n</code>\nTest your solution:\n<code>", "  if (empty($nums)) {\n    return array();\n\
    \  }\n  $digits = array_sum($nums);\n  asort($nums);\n  $ret = array();\n  foreach\
    \ ($nums as $i => $num) {\n    $ret[$i] = $num;\n    if ($digits == $num) {\n\
    \      $ret[$i] = $i;\n    }\n  }\n  return $ret;\n}\n", "  $sum = array_sum($nums);\n\
    \  $nums[] = $sum;\n  asort($nums);\n  return array_values($nums);\n}\n</code>\n\
    <|/ a dscore=2 tags=php,sorting |>\n<| a dscore=1 |>\nI used this method to sort\
    \ my array in descending order. \n<code>\n$array = array(\n    array('id'=>2,\
    \ 'name'=>'Clark'),\n    array('id'=>1, 'name'=>'Jenny'),\n    array('id'=>3,\
    \ 'name'=>'Jordan'),\n    array('id'=>4, 'name'=>'Josh'),\n    array('id'=>6,\
    \ 'name'=>'Kevin'),\n);\n", "  if (empty($nums)) {\n    return array();\n  }\n\
    \  $sorted_nums = array();\n  foreach ($nums as $index => $num) {\n    $num =\
    \ abs($num);\n    $digits = str_split($num);\n    $digits_count = count($digits);\n\
    \    $sum_of_digits = array_sum($digits);\n    $sorted_nums[$index] = $sum_of_digits;\n\
    \  }\n  asort($sorted_nums);\n  $sorted_nums = array_values($sorted_nums);\n \
    \ return $sorted_nums;\n}\n</code>\nTest\n<code>\n$test_array = array(\n  array(1,\
    \ 11, -1, -11, -12),\n  array(1, 7, 1, 6, 5),\n  array(4, 3, 6, 9, 2),\n  array(),\n\
    \  array(4),\n);\necho '<table>';\nforeach ($test_array as $nums) {\n  echo '<tr>';\n\
    \  foreach ($nums as $num) {\n    echo '<td>', $num, '</td>';\n  }\n  echo '</tr>';\n\
    }\necho '</table>';\nprint '<br>';\nprint '<table border=1>';\necho '<tr>';\n\
    echo '<th>Points</th>';\n$sorted_nums = order_by_points($test_array);\nforeach\
    \ ($sorted_nums as $index => $num) {\n  echo '<th>', $index, '</th>';\n}\necho\
    \ '</tr>';\nforeach ($test_array as $nums) {\n  echo '<tr>';\n  foreach ($nums\
    \ as $num) {\n    echo '<td>', $num, '</td>';\n  }\n  echo '</tr>';\n}\necho '</table>';\n\
    </code>\nOutput\n<code>\n<table>\n<tr>\n<td>1</td>\n<td>11</td>\n<td>-1</td>\n\
    <td>-11</td>\n<td>-12</td>\n</tr>\n<tr>\n<td>1</td>\n<td>7</td>\n<td>1</td>\n\
    <td>6</td>\n<td>5</td>\n</tr>\n<tr>\n<td>4</td>\n<td>3</td>\n<td>6</td>\n<td>9</td>\n\
    <td>2</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>4</td>\n<td></td>\n<td></td>\n\
    </tr>\n<tr>\n<td>4</td>\n</tr>\n</table>\n\n<table border=1>\n<tr>\n<th>Points</th>\n\
    <th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n</tr>\n<tr>\n<th>0</th>\n<th>0</th>\n\
    <th>0</th>\n<th>0</th>\n<th>0</th>\n</tr>\n<tr>\n<th>1</th>\n<td>1</td>\n<td>7</td>\n\
    <td>6</td>\n<td>4</td>\n</tr>\n<tr>\n<th>2</th>\n<td>11</td>\n<td>", "  $sums\
    \ = array_sum($nums);\n  if ($sums === 0) {\n    return $nums;\n  }\n  $result\
    \ = array();\n  foreach ($nums as $index => $num) {\n    $result[$index] = $sums\
    \ - $num;\n  }\n  asort($result);\n  return $result;\n}\n", "  $result = [];\n\
    \  foreach ($nums as $num) {\n    $tmp = 0;\n    while (true) {\n      $tmp +=\
    \ ($num & 1) ? $num : -$num;\n      $num >>= 1;\n      if (!$num) break;\n   \
    \ }\n    $result[] = $tmp;\n  }\n  asort($result);\n  $result = [];\n  foreach\
    \ ($result as $key => $num) {\n    $result[$key] = $nums[$key];\n  }\n  return\
    \ $result;\n}", "    $map = array();\n    foreach ($nums as $num) {\n        $n\
    \ = $num % 10;\n        if (!isset($map[$n])) {\n            $map[$n] = 1;\n \
    \       } else {\n            $map[$n] += 1;\n        }\n    }\n    $sorted =\
    \ array();\n    foreach ($map as $key => $value) {\n        $sorted[$key] = $nums[$key];\n\
    \    }\n    array_multisort($sorted, $nums);\n    return $nums;\n}\n</code>\n\
    <|/ a tags=sorting,php,arrays |>\n<| a dscore=2 tags=sorting,php,arrays |>\nI\
    \ wrote an answer that is based on this one, which takes account of the possibility\
    \ of duplicated numbers. \nThe function takes as an argument an array in which\
    \ the values represent numbers (in the example: $values) and an array in which\
    \ the keys represent indexes (in the example: $indexes).\nThe function first sort\
    \ the indexes according to the values using the function sortByVal (which is based\
    \ on the function of Jack Cooper).\nThe function then builds an array that contains\
    \ the pairs ($value[$index], $index) for each index. Finally, the array is sorted\
    \ by keys according to the values.\n<code>", "  if (!$nums)\n    return array();\n\
    \  $points = array();\n  $sums = array_map(function($n) { return strval($n); },\
    \ $nums);\n  asort($sums);\n  foreach($sums as $i => $sum) {\n    $points[$i]\
    \ = $nums[$i];\n  }\n  return $points;\n}\n", "  $sum_of_digits = array_sum($nums);\n\
    \n  if ($sum_of_digits === 0) {\n    return $nums;\n  }\n\n  $nums = array_map(function\
    \ ($n) {\n    return $n * 10 + floor($sum_of_digits / 10);\n  }, $nums);\n\n \
    \ // Sort by digits from right to left\n  usort($nums, function($a, $b) { return\
    \ $b - $a; });\n\n  return $nums;\n}\n</code>\nI modified the example in the documentation\
    \ to show the two cases where it can occur.\nEdit: I ran into some cases where\
    \ a negative number was ordered before a positive number. I had to add the two\
    \ possible cases to my example and check if there were any negatives before positives.\n\
    <code>\n<?php", "    if (empty($nums)) {\n        return array();\n    }\n\n \
    \   $sums = array();\n    foreach ($nums as $num) {\n        $num = array_sum(str_split($num));\n\
    \        $sums[$num] = $num;\n    }\n    asort($sums);\n\n    return array_map(function($num)\
    \ { return $nums[$num] }, array_keys($sums));\n}\n</code>\n<|/ a tags=php,arrays,sorting\
    \ dscore=1 |>\n<| a |>\nYou can try this simple approach :\n<code>\n<?php\n\n\
    $data = array(\n    array('name'=>'name1', 'score'=>4),\n    array('name'=>'name2',\
    \ 'score'=>1),\n    array('name'=>'name3', 'score'=>5),\n    array('name'=>'name4',\
    \ 'score'=>9),\n);\n\nuasort($data, function ($a, $b) {\n    return $b['score']\
    \ - $a['score'];\n});\n\n$data = array_map(function ($val) {\n    return $val['score'];\n\
    }, $data);\n\n$data = array_flip($data);\n\nprint_r($data);\n</code>\nOutput :\n\
    <code>\nArray\n(\n    [9] => 9\n    [5] => 5\n    [1] => 1\n    [4] => 4\n)\n\
    </code>\n<|/ a tags=php,arrays,sorting dscore=1 |>\n<| c |>\nWow, that is cool!\
    \ I did not know about `array_flip`. Thank you!\n<|/ c |>\n<| a tags=php,arrays,sorting\
    \ |>\n<code>\n$nums = array(5,3,4,7,2,9);\n$sums = array_sum($nums);\n$newArray\
    \ = array();\n$i = 0;\nforeach($nums as $n) {\n    if(isset($sums[$i]) && $sums[$i]\
    \ == $n) {\n        $newArray[] = $n;\n    } else {\n        $newArray[] = $nums[$i];\n\
    \    }\n    $i++;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis sorts the array\
    \ by value, not by index. Which is what OP asked for.\n<|/ c |>\n<| a dscore=0\
    \ |>\nThis is my simple solution:\n<code>\n<?php\n\n$array = [\n    ['index' =>\
    \ 1, 'value' => 0],\n    ['index' => 2, 'value' => 1],\n    ['index' => 3, 'value'\
    \ => 2],\n    ['index' => 4, 'value' => 3],\n    ['index' => 5, 'value' => 4],\n\
    \    ['index' => 6, 'value' => 5],\n    ['index' => 7, 'value' => 6],\n", "  return\
    \ $nums;\n}\n", "  // Write your code here\n  $sums = array_map(function($v){\n\
    \   return array_sum(str_split($v));\n  },$nums);\n  arsort($sums);\n  return\
    \ array_map(function($v){\n   return $nums[array_search($v, $sums)];\n  },$sums);\n\
    }\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>\n<?php", "  // Sort $nums into\
    \ ascending order based on their sum\n  $num_arr = array();\n  foreach ($nums\
    \ as $num) {\n    $num_arr[] = $num;\n  }\n  asort($num_arr);\n  $rev = array_reverse($num_arr);\n\
    \  return $rev;\n}\n</code>\nI hope this will help\n<|/ a tags=arrays,algorithm,php\
    \ |>\n<| a tags=arrays,algorithm,php |>\nOne of the most efficient algorithm to\
    \ find the largest sum of consecutive elements. A modified version of Kevin's\
    \ answer.\n<code>", "    usort($nums, function($a, $b) {\n        $a = number_format($a,\
    \ 0);\n        $b = number_format($b, 0);\n        return $a <=> $b;\n    });\n\
    \    return $nums;\n}\n", "  $sum_points = 0;\n  foreach ($nums as $num) {\n \
    \   $sum_points += $num;\n  }\n  return $nums;\n}\n", "  $sorted_arr = [];\n \
    \ foreach ($nums as $num) {\n    $sum_of_digits = array_sum(str_split($num));\n\
    \    if (isset($sorted_arr[$sum_of_digits])) {\n      $sorted_arr[$sum_of_digits][]\
    \ = $num;\n    } else {\n      $sorted_arr[$sum_of_digits] = [$num];\n    }\n\
    \  }\n  ksort($sorted_arr);\n  return $sorted_arr;\n}\n", "    $sorted = array();\n\
    \    foreach($nums as $key => $num) {\n        $sum = array_sum(str_split($num));\n\
    \        if(!isset($sorted[$sum])) {\n            $sorted[$sum] = $key;\n    \
    \    }\n    }\n    return array_values($sorted);\n}\n</code>\n<|/ a dscore=1 tags=php,sorting,arrays\
    \ |>\n<| a |>\nTry this simple sort function with callback:\n<code>", "\t$sum\
    \ = 0;\n\t$length = count($nums);\n\tfor ($i = 0; $i < $length; $i++) {\n\t\t\
    $sum += $nums[$i];\n\t\t$nums[$i] = $sum;\n\t}\n\tarsort($nums);\n\treturn $nums;\n\
    }\n", "  // write your code here\n}\n", "    $result = array();\n    // Use the\
    \ first number to initialize sum and rest numbers.\n    $sum = array_shift($nums);\n\
    \    foreach ($nums as $n) {\n        // Sum up the digits of current number.\n\
    \        $sum += $n % 10;\n        // If the sum equals to last number, push current\
    \ number to the result.\n        if ($sum === $n) {\n            $result[] = $n;\n\
    \            // Reset the sum.\n            $sum = 0;\n        }\n    }\n    return\
    \ $result;\n}\n", "  if (empty($nums))\n    return array();\n\n  // Initialize\
    \ $sum and $index to hold value of each integer in $nums\n  $sum = 0;\n  $index\
    \ = 0;\n\n  // Calculate $sum and $index for all elements in $nums\n  // until\
    \ $sum becomes 0.\n  while (1) {\n    $index++;\n    $sum = $sum + $nums[$index];\n\
    \    if ($sum == 0) {\n      $break; // Break if $sum is 0 after adding all elements\n\
    \    }\n  }\n\n  // Store the sorted array in $sorted array\n  $sorted = array();\n\
    \  for ($i = 0; $i < $index; $i++) {\n    $sorted[$i] = $nums[$i];\n  }\n  //\
    \ Reverse sort the $nums according to $sorted\n  array_reverse($nums, $sorted);\n\
    \n  return $sorted;\n}\n", "    if (empty($nums)) {\n        return array();\n\
    \    }\n\n    // sort the given array\n    usort($nums, \"sort_by_points\");\n\
    \n    // return the sorted array\n    return $nums;\n}\n", "  if (!$nums) return\
    \ array();\n  $points_by_sum = array();\n  $sorted_points = array();\n  foreach\
    \ ($nums as $num) {\n    $points_by_sum[$num] = 0;\n  }\n  foreach ($nums as $num)\
    \ {\n    if ($num >= 0) $points_by_sum[$num] += $num;\n  }\n  ksort($points_by_sum);\n\
    \  foreach ($points_by_sum as $num => $points) {\n    $sorted_points[$num] = $points;\n\
    \  }\n  return $sorted_points;\n}", "  $sums = array_sum($nums);\n  return array_map(function($sum)\
    \ use ($nums) { return $nums[$sum]; },\n      array_count_values($nums));\n}\n\
    </code>\n<|/ a dscore=5 |>\n<| c |>\nNice and short solution! Thanks!\n<|/ c |>\n\
    <| c |>\nI tried to run your example with php 7.0 and got an error `PHP Parse\
    \ error:  syntax error, unexpected '[' in /.../index.php on line 21`. Do you know\
    \ what can be the problem ?\n<|/ c |>\n<| c |>\nI forgot the `use` keyword. Try\
    \ now\n<|/ c |>\n<| c |>\nThanks. I used `use` keyword like you did, and `array_map`\
    \ with first argument of `use`. And I got an error `array_map(): Argument #2 should\
    \ be an array in /.../index.php on line 15` but I checked and it works fine. Do\
    \ you have an idea why I get that error?\n<|/ c |>\n<| c |>\nAha, I find that\
    \ my example only works when my array has at least one element of value `0` because\
    \ `array_sum($nums)` returns `0`\n<|/ c |>\n<| a dscore=4 |>\nThis should also\
    \ work:\n<code>\nusort($arr, [$this, 'compare']);\n", "  // 1. Sort the array\
    \ (with arbitrary sorting algorithm) based on the\n  // digits sum in descending\
    \ order\n  // 2. Sort them based on the first number's index in descending order\n\
    \  // 3. (Optional) If two items have similar sum, order them based on their index\
    \ in original array.\n  // e.g.: >>> order_by_points(array(1, 11, -1, -11, -12))\n\
    \  //      array(-1, -11, 1, -12, 11)\n  //      >>> order_by_points(array(1,\
    \ -12, -1, -11, -11))\n  //      array(-1, -11, -12, 1, -11)\n  arsort($nums,\
    \ -1, 1);\n  foreach ($nums as $key => $val) {\n    $nums[$key] = $key;\n  }\n\
    \  $nums = array_reverse($nums, 1);\n  return $nums;\n}\n</code>\n<|/ a tags=algorithm,php\
    \ |>\n<| c |>\nThat works.  Any ideas why mine would give the wrong results?\n\
    <|/ c |>\n<| c |>\nBecause it is sorting, not choosing the right one based on\
    \ its sum.\n<|/ c |>\n<| c |>\nAh, right.  I see.  So that means my original code\
    \ should work because it's choosing based on a sum.  Thanks!\n<|/ c |>\n<| a dscore=0\
    \ |>\nYou can do it easily with array_reduce:\n<code>\n<?php\n\n$nums = [-1,-3,4,0,10,42,8,6,-20,5,10,-10];\n\
    \n$sums = array_reduce(\n    $nums,\n    function ($sums, $val) {\n        $sums[$val]\
    \ = array_sum(array_slice($nums, $val));\n        return $sums;\n    },\n    []\n\
    );\n\nuasort(\n    $sums,\n    function ($a, $b) use ($sums) {\n        return\
    \ $sums[$b] - $sums[$a];\n    }\n);\n\n$nums= array_values($sums);\n\nprint_r($nums);\n\
    </code>\n<|/ a tags=algorithm,php |>\n<| c |>\nThe problem is he didn't want to\
    \ sort the array, so he needed an algorithm based on a sum.\n<|/ c |>\n<| c |>\n\
    I read his comment in his question\n<|/ c |>\n<| c |>\nOkay, that wasn't clear\
    \ from the question, I'll remove my downvote. Thanks for your contribution.\n\
    <|/ c |>\n<| a |>\nYou can just use foreach to calculate sums of elements, and\
    \ then sort them using usort function and by custom compare function.\n", "  \
    \  foreach ($nums as $num => $point) {\n        $sum = 0;\n        $digits = str_split($num);\n\
    \        foreach ($digits as $digit) {\n            $sum += $digit;\n        }\n\
    \        $order[$num] = $point;\n        $order[$sum] = $point;\n    }\n    asort($order);\n\
    \    return array_values($order);\n}\n\n/**\n * Test to see if a value is in a\
    \ given set of values\n *\n * @param mixed $val value to find\n * @param array\
    \ $values values to search\n * @return bool true if value is in the set\n */",
  "  $points = [];\n  for ($i = 0, $n = count($nums); $i < $n; ++$i) {\n    $points\
    \ = array_merge($points, array_count_values($nums[$i]));\n  }\n  arsort($points);\n\
    \  return array_keys($points);\n}\n</code>\n<|/ a dscore=3 tags=php,arrays |>\n\
    <| a dscore=2 |>\n<code>\n$numbers = [\n    0, 6, 8, 13, 20, 21, 29, 35, 47, 54,\
    \ 59,\n];\n\n$new_numbers = array_combine(\n    array_filter(\n        array_map('intval',\
    \ array_sum(array_map('intval', array_keys($numbers)))\n    ),\n    array_keys($numbers)\n\
    );\n\nvar_dump($new_numbers);\n</code>\n<|/ a tags=php,arrays |>\n<| a |>\nAnother\
    \ solution using array_reduce():\n<code>\n$result = array_reduce($array, function($carry,\
    \ $value) {\n    $carry[$value] = true;\n    return $carry;\n}, array());\n\n\
    print_r($result);\n</code>\nThe above snippet produces output similar to Michael\
    \ O'Neill's answer:\n<code>\nArray\n(\n    [1] => 1\n    [6] => 1\n    [8] =>\
    \ 1\n    [13] => 1\n    [20] => 1\n    [21] => 1\n    [29] => 1\n    [35] => 1\n\
    \    [47] => 1\n    [54] => 1\n    [59] => 1\n)\n</code>\n<|/ a tags=php,arrays\
    \ dscore=2 |>\n<| c |>\nIt's actually a little more elegant than the other solutions\
    \ because you end up having a sorted array and you also don't have to do anything\
    \ more complicated. Nice.\n<|/ c |>\n<| a |>\nYou could use the following function:\n\
    <code>", "    $results = array();\n    $digits = array();\n    $sums = array();\n\
    \    foreach ($nums as $i => $num) {\n        $digits[$i] = substr($num, 0, 1);\n\
    \        $sums[$i] = array_sum(str_split($digits[$i]));\n        $results[$i]\
    \ = $nums[$i];\n    }\n    arsort($sums);\n    foreach ($sums as $i => $sum) {\n\
    \        $results[$i] = $results[$i];\n    }\n    return array_values($results);\n\
    }\n</code>\nThis code will take your array of numbers and order them in ascending\
    \ order according to the sum of their digits. For example, order_by_points(array(1,\
    \ 11, -1, -11, -12)) would return array(-1, -11, 1, -12, 11). And order_by_points(array())\
    \ would return array().\nI hope this helps.\n<|/ a dscore=0 |>\n<| a tags=php,sorting\
    \ |>\n<code>\n<?php\n\nclass OrderByDigits implements Comparable\n{\n    public\
    \ $numbers = array();\n    public function __construct($numbers)\n    {\n    \
    \    $this->numbers = $numbers;\n    }\n    public function getNumbers()\n   \
    \ {\n        return $this->numbers;\n    }\n    public function getNumbersSorted()\n\
    \    {\n        $sorted = array();\n        foreach ($this->numbers as $key =>\
    \ $value) {\n            $sorted[$key] = substr($value, 0, 1);\n        }\n  \
    \      asort($sorted);\n        return array_values($sorted);\n    }\n    public\
    \ function __toString()\n    {\n        foreach ($this->getNumbersSorted() as\
    \ $value) {\n            echo $value.',';\n        }\n    }\n    public function\
    \ compareTo($numbers)\n    {\n        $numbers_sorted = $this->getNumbersSorted();\n\
    \        if ($numbers_sorted == $this->getNumbersSorted()) {\n            return\
    \ 0;\n        }\n        if ($numbers_sorted > $this->getNumbersSorted()) {\n\
    \            return -1;\n        }\n        return 1;\n    }\n}\n\n$numbers =\
    \ array(1, 11, -1, -11, -12);\n$numbers_sort = new OrderByDigits($numbers);\n\n\
    $result = $numbers_sort->getNumbersSorted();\necho '<pre>';\nprint_r($result);\n\
    echo '</pre>';\n</code>\n<|/ a dscore=0 |>\n<| a |>\nAs you said that you are\
    \ using PHP 7 you can use an anonymous function:\n<code>\n$numbers = array(1,\
    \ 11, -1, -11, -12);\nusort($numbers, function ($a, $b) {\n    return strlen($a)\
    \ - strlen($b);\n});\n</code>", "  $map = array_count_values($nums);\n  ksort($map);\n\
    \  $numsOrdered = array_keys($map);\n  sort($numsOrdered);\n  return $numsOrdered;\n\
    }\n</code>\n<|/ a tags=arrays,php dscore=0 |>\n<| a dscore=0 |>\n<code>\n<?php\n",
  "  uasort($nums, create_function('$a,$b', 'return $a<$b ? -1 : $a==$b ? 0 : 1;'));\n\
    \  return $nums;\n}", "  $num_sums = array_sum($nums);\n  $sorting_keys = array();\n\
    \  foreach($nums as $i => $num) {\n    $sorting_keys[$num] = $i;\n  }\n  asort($sorting_keys);\n\
    \  $result = array();\n  foreach($sorting_keys as $key => $i) {\n    $result[$i]\
    \ = $nums[$key];\n  }\n  ksort($result);\n  return $result;\n}\n", "    return\
    \ array_reduce($nums, function($carry, $item) {\n        $carry['sum'] = $carry['sum']\
    \ + $item['points'];\n        return $carry;\n    });\n}\n", "  $sorted = array();\n\
    \  $sums = array();\n  for ($i = 0, $n = count($nums); $i < $n; ++$i) {\n    $sums[]\
    \ = array_sum(str_split($nums[$i]));\n    $sorted[$i] = $nums[$i];\n  }\n  asort($sums,\
    \ SORT_NUMERIC);\n  foreach ($sums as $i => $sum) {\n    $sorted[$i] = $sorted[$i];\n\
    \  }\n  foreach ($sorted as $i => $num) {\n    $sorted[$i] = $nums[$i];\n  }\n\
    \  return $sorted;\n}\n", "  $result = [];\n  foreach ($nums as $index => $num)\
    \ {\n    $sum = 0;\n    foreach (str_split($num) as $digit) {\n      $sum += $digit\
    \ * pow(10, strlen($digit) - 1);\n    }\n    $result[$index] = $sum;\n  }\n  ksort($result);\n\
    \  return $result;\n}\n", "    // Your code goes here\n    $ordered = array();\n\
    \    $sum = 0;\n    foreach($nums as $num) {\n        foreach(str_split($num)\
    \ as $char) {\n            $sum += $char;\n        }\n        $ordered[$sum] =\
    \ $num;\n    }\n    usort($ordered, 'sumsort');\n    return $ordered;\n}\n", " \
    \   sort($nums, SORT_NUMERIC);\n    return $nums;\n}", "\t$res = array();\n\t\
    foreach ($nums as $key => $num) {\n\t\t$sum = 0;\n\t\tforeach (str_split($num)\
    \ as $digit) {\n\t\t\t$sum += $digit;\n\t\t}\n\t\t$res[$key] = $sum;\n\t}\n\t\
    asort($res);\n\treturn $res;\n}", "  // Write your logic here\n  if (count($nums)\
    \ < 2) {\n    return $nums;\n  }\n  $digits = array_sum($nums);\n  return array_filter($nums,\
    \ function($i) use ($digits) {\n    return $digits == $i;\n  });\n}", "    $numsSorted\
    \ = array();\n\n    foreach ($nums as $key => $value) {\n        if ($key > 0)\
    \ {\n            $sum = 0;\n            foreach ($nums as $innerKey => $innerValue)\
    \ {\n                $sum += $innerValue;\n                $numsSorted[$key] =\
    \ $innerValue;\n            }\n            $numsSorted[$key] = $sum;\n       \
    \ }\n    }\n\n    array_multisort($numsSorted, SORT_ASC, $nums);\n    return $nums;\n\
    }\n", "  foreach ($nums as $key => $value) {\n    $sum = 0;\n    foreach (str_split($value)\
    \ as $digit) {\n      $sum += $digit;\n    }\n    $nums[$key] = $sum;\n  }\n \
    \ usort($nums, function($a, $b) {\n    return $b - $a;\n  });\n  return $nums;\n\
    }", "  $result = array();\n  $sums = array();\n  // Sum each item of $nums.\n\
    \  foreach ($nums as $num) {\n    $sums[$num] += $num;\n  }\n  // Sort $nums based\
    \ on the sum value of their digits.\n  // If two or more items have the same sum\
    \ of digits, order them in\n  // original $nums array.\n  foreach ($sums as $key\
    \ => $sum) {\n    $result[$key] = $nums[$key];\n  }\n  return $result;\n}", " \
    \ if (!is_array($nums))\n    return array();\n  $sums = array_sum($nums);\n  $orders\
    \ = array_fill(0, count($nums), 0);\n  foreach ($nums as $i => $v) {\n    $orders[$sums[$i]]\
    \ = $i;\n  }\n  return array_intersect_key($nums, $orders);\n}\n", "  $sorted\
    \ = array();\n  foreach($nums as $num) {\n    $digits_sum = array_sum(str_split($num));\n\
    \    if ($digits_sum) {\n      $sorted[] = $num;\n    }\n  }\n  usort($sorted,\
    \ function ($a, $b) {\n    return strcmp(count_digits($a), count_digits($b));\n\
    \  });\n  return $sorted;\n}\n", "    $results = array();\n    foreach($nums as\
    \ $num => $index) {\n        $sum = 0;\n        foreach($num as $key => $digit)\
    \ {\n            $sum += $key * $digit;\n        }\n        $results[$index] =\
    \ $sum;\n    }\n    array_multisort($results, SORT_ASC, $nums);\n    return $nums;\n\
    }\n", "  // Copy $nums\n  $nums_copy = $nums;\n  // Use $nums_copy as stack for\
    \ numbers\n  $stack = array();\n  // Initialize $sum and $index\n  $sum = 0;\n\
    \  $index = 0;\n  // Sort $nums_copy in ascending order\n  usort($nums_copy, 'order_by_points_function');\n\
    \  // While there are still numbers\n  while ($nums_copy) {\n    // Pop an element\
    \ from $nums_copy\n    array_pop($nums_copy);\n    // Add it to $sum\n    $sum\
    \ += $nums_copy[0];\n    // Add it to $stack\n    array_push($stack, $nums_copy[0]);\n\
    \  }\n  // Return sorted array\n  return $stack;\n}", "  sort($nums, SORT_NUMERIC);\n\
    \n  $indexed_nums = array_combine(\n    array_map('intval', array_values($nums)),\n\
    \    $nums\n  );\n\n  $sorted_nums = array();\n  $sorted_nums_size = -1;\n\n \
    \ foreach ($indexed_nums as $num => $original_index) {\n    if ($sorted_nums_size\
    \ == -1) {\n      $sorted_nums_size = count($sorted_nums);\n    }\n    if (!isset($sorted_nums[$sorted_nums_size]))\
    \ {\n      $sorted_nums[$sorted_nums_size] = $original_index;\n    } else {\n\
    \      if ($sorted_nums_size < $sorted_nums[$sorted_nums_size]) {\n        $sorted_nums_size\
    \ = $sorted_nums[$sorted_nums_size];\n      }\n    }\n  }\n  sort($sorted_nums,\
    \ SORT_NUMERIC);\n  return $sorted_nums;\n}\n</code>\n<|/ a |>\n<| c |>\nThanks\
    \ but I think there is a mistake, in the last line should be return $sorted_nums\n\
    <|/ c |>\n<| a |>\nI used the array_multisort function, like this:\n<code>\n<?php\n\
    $input = array(1,2,5,4,6,1,3);\n$input_sorted = array();\nforeach($input as $key=>$value)\
    \ {\n    $input_sorted[$key] = $input[$key];\n}\narray_multisort($input_sorted,\
    \ $input);\nprint_r($input);", "    $nums_size = sizeof($nums);\n    for($i =\
    \ 0; $i < $nums_size; $i++) {\n        $sum = 0;\n        $j = $i;\n        while($j\
    \ < $nums_size && $nums[$j] > 0) $sum += $nums[$j++];\n        if($sum != 0) $nums[$i]\
    \ = $sum;\n    }\n    return $nums;\n}\n", "  $sum = array_sum($nums);\n  return\
    \ array_map(function ($num) use ($sum) {\n    $numWithSum = array_map(function\
    \ ($i) use ($sum) {\n      return $i * $sum / $i;\n    }, $num);\n    $numWithSumSum\
    \ = array_sum($numWithSum);\n    return array_search($numWithSumSum, $numWithSum);\n\
    \  }, $nums);\n}\n", "  return array_reduce($nums, function($a, $b) {\n    return\
    \ $b > $a ? $b : $a;\n  });\n}\n", "    $sum_points = 0;\n    $nums_len = count($nums);\n\
    \    for ($i = 0; $i < $nums_len; $i++) {\n        $num = $nums[$i];\n       \
    \ $digits = array_filter(str_split($num));\n        $points_len = count($digits);\n\
    \        for ($d = 0; $d < $points_len; $d++) {\n            $sum_points += $digits[$d];\n\
    \        }\n    }\n\n    $sorted_nums = array();\n    foreach ($nums as $k =>\
    \ $num) {\n        $digits = array_filter(str_split($num));\n        $points_len\
    \ = count($digits);\n        $sum = 0;\n        for ($d = 0; $d < $points_len;\
    \ $d++) {\n            $sum += $digits[$d];\n        }\n\n        if ($sum ==\
    \ $sum_points) {\n            $sorted_nums[$k] = $num;\n        }\n    }\n\n \
    \   return $sorted_nums;\n}\n", "  $num_sums = array_sum($nums);\n  arsort($nums);\n\
    \  foreach ($nums as $index => $num) {\n    if ($num_sums == $num) {\n      return\
    \ $nums;\n    }\n  }\n  return $nums;\n}", "  if (empty($nums)) return array();\n\
    \  $total_digits = array_sum(array_map('intval', $nums));\n  $nums_by_digit =\
    \ array();\n  foreach ($nums as $num => $i) {\n    $nums_by_digit[$num] = intval($i\
    \ / $total_digits);\n  }\n  // Sort by sum\n  uasort($nums_by_digit, function($a,\
    \ $b) {\n    return $a + $b - $nums_by_digit[abs($b)];\n  });\n  return array_keys($nums_by_digit);\n\
    }\n", "  return $nums;\n}\n", "  // Compute sum of all digits in all input numbers.\n\
    \  $sum = 0;\n  for ($i = 0; $i < count($nums); ++$i) {\n    $sum += $nums[$i];\n\
    \  }\n\n  // Sort all numbers with the same sum.\n  usort($nums, function($a,\
    \ $b) use ($sum) {\n    return $sum - $a - $b;\n  });\n\n  return $nums;\n}\n\
    </code>\nOutput:\n<code>\narray(9) {\n  [0]=>\n  int(-1)\n  [1]=>\n  int(-1)\n\
    \  [2]=>\n  int(1)\n  [3]=>\n  int(-2)\n  [4]=>\n  int(0)\n  [5]=>\n  int(1)\n\
    \  [6]=>\n  int(1)\n  [7]=>\n  int(2)\n  [8]=>\n  int(3)\n}\n</code>\n<|/ a tags=algorithm,php,sorting\
    \ |>\n<| a tags=algorithm,php,sorting |>\nThe best way to sort by \"points\" is\
    \ probably to first sort by \"points\" descending then by \"name\" ascending.\
    \ Something like:\n<code>\n$people = array(\n    array(\"name\" => \"Amy Hirst\"\
    , \" points\" => -1000),\n    array(\"name\" => \"Kim Baker\", \" points\" =>\
    \ -1),\n    array(\"name\" => \"Kristen Baker\", \" points\" => 1),\n    array(\"\
    name\" => \"Bob Baker\", \" points\" => 2),\n);\n\nusort($people, function($a,\
    \ $b) use ($people) {\n    return $b[\"points\"] - $a[\"points\"];\n});\nsort($people);\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nThis is how I would do it.  However, you\
    \ still need to sort by points descending before you sort by name ascending.\n\
    <|/ c |>\n<| c |>\nThat makes sense. Although the OP didn't say anything about\
    \ that.\n<|/ c |>\n<| c |>\nThe OP didnt say anything about sorting by points\
    \ descending before sorting the names, but i agree that this is a valid solution.\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>\n<?php", "  sort($nums, SORT_NUMERIC);\n  foreach\
    \ ($nums as $i => $v) {\n    if (isset($nums[$i + 1])) {\n      if ($nums[$i +\
    \ 1] != $v) {\n        $nums[$i] = $nums[$i + 1];\n      }\n    }\n  }\n  return\
    \ $nums;\n}\n", "  $sum = array_sum($nums);\n  usort($nums, function($a, $b) use\
    \ ($sum) {\n    return $sum - $sum + $a - $b;\n  });\n  return $nums;\n}\n", " \
    \   $result = [];\n    $sum_of_digits = 0;\n\n    // Sort using original array\
    \ if possible.\n    if (count($nums) && count($nums[0])) {\n        $nums = array_map('intval',\
    \ $nums);\n        usort($nums, function ($a, $b) use (&$sum_of_digits) {\n  \
    \          return strcmp(sum_of_digits($a), sum_of_digits($b));\n        });\n\
    \    }\n\n    // Sort using digits of sums if no original array available.\n \
    \   elseif (count($nums)) {\n        foreach ($nums as $num => $digit) {\n   \
    \         $sum_of_digits += $digit;\n            $result[$num] = $digit;\n   \
    \     }\n\n        usort($result, function ($a, $b) use (&$sum_of_digits) {\n\
    \            return strcmp(sum_of_digits($a), sum_of_digits($b));\n        });\n\
    \    }\n\n    return $result;\n}\n</code>\n<|/ a dscore=0 tags=sorting,php,arrays\
    \ |>\n<| c |>\nThanks for your answer. Your code will work fine if there only\
    \ one element in the array. But, if there are more than one element with the same\
    \ sum, they will be sorted in descending order as we need. But if we use your\
    \ function `order_by_points` in `$result[$num] = $digit;`, the result will be\
    \ `array(1, 11, -1, -11, -12)` in the previous example rather than `array(-12,\
    \ -11, 1, 11, -1)`. Can you please suggest how to fix it? Thanks a lot!\n<|/ c\
    \ |>\n<| c |>\nThanks for pointing out. I have fixed it. Take a look now.\n<|/\
    \ c |>\n<| a dscore=0 tags=sorting,php,arrays |>\nI used usort and array_count_values,\
    \ this way I can keep my code as short as possible, only 4 lines. \nFirst of all,\
    \ I make my own function that calculates sum of the digits of the number:\n<code>",
  "  if (!$nums) {\n    return array();\n  }\n  $sum = 0;\n  $result = array();\n\
    \  foreach ($nums as $num) {\n    $sum += $num;\n    $result[$sum] = $num;\n \
    \ }\n  return $result;\n}\n</code>\nThe result is as expected: it sorts the array\
    \ in ascending order based on sum of its digits, where two numbers with identical\
    \ sums come together. The function above is O(n) and the sorting algorithm in\
    \ the answer is O(n log n). Hope this helps!\n<|/ a |>\n<| c |>\nThis is great,\
    \ but I really need to know which two numbers were grouped together and in what\
    \ order.\n<|/ c |>\n<| c |>\nThis approach assumes that the array already contains\
    \ all the possible sums. If not, it would be possible to store the sums in a map\
    \ or a sorted array as you iterate, rather than calculating them for every item\
    \ in the array. You might also want to consider storing the sums along with the\
    \ indices of the original array so you can easily get them back.\n<|/ c |>\n<|\
    \ c |>\nIt would seem that you can do this in O(n) time and O(n log n) space if\
    \ you pre-calculate each sum and index pair, then sort that array by sum value.\
    \ Since your original data structure already has sum and index pairs you can do\
    \ this in O(n log n) time. I'm going to leave this answer here because it's more\
    \ general, but I'll edit it to include a general solution based on your solution.\n\
    <|/ c |>\n<| a dscore=0 |>\nHere is a solution based on your answer. It's O(n\
    \ log n), but it takes more space because it keeps some additional info about\
    \ numbers with similar sums. Also, I'm not sure if there are some faster ways\
    \ to do this.\n<code>\n<?php\n$tests = array(\n    'array(1, 11, -1, -11, -12)',\n\
    \    'array(0)',\n    'array(12, 1)',\n    'array(12, 1, 12, -12, -11)',\n   \
    \ 'array(1, 11, 12, -1)',\n    'array(5, 11, 10, 7, 8)',\n    'array(13, 14, 16,\
    \ 17, 19, 25, 30, 34, 38, 42, 45, 49, 52, 57, 60, 62, 65, 70, 75, 79, 84, 90,\
    \ 99, 102, 104, 107, 110, 113, 117, 120, 123, 125, 127, 129, 131, 134, 136, 138,\
    \ 140, 143, 145, 147, 149, 150, 152, 154, 155, 157, 159, 161, 162, 164, 166, 168,\
    \ 171, 173, 175, 177, 179, 182, 185, 188, 192, 194, 196, 198, 201, ", "  $sorted\
    \ = array_map(function($a) {\n    return $a[0] + $a[1];\n  }, $nums);\n  asort($sorted);\n\
    \  return $sorted;\n}\n", "  if (empty($nums))\n    return array();\n  $keys =\
    \ array_keys($nums);\n  sort($keys, SORT_NUMERIC);\n  $vals = array_values($nums);\n\
    \  foreach ($keys as $key)\n    $nums[$key] = $vals[$key];\n  return $nums;\n}",
  "    $result = array();\n    $points_by_sum = $points = array();\n    $sum = 0;\n\
    \    foreach ($nums as $key => $num) {\n        $points[$sum] = $key;\n      \
    \  $sum += $num;\n        $points_by_sum[$sum] = $points;\n    }\n    $nums_by_sum\
    \ = $nums;\n    asort($nums_by_sum);\n    foreach ($nums_by_sum as $key => $num)\
    \ {\n        if ($sum > 0) {\n            foreach ($points_by_sum[$sum] as $sum2\
    \ => $points) {\n                if ($sum2 == $key) {\n                    $result[]\
    \ = $num;\n                    unset($nums_by_sum[$key], $points_by_sum[$sum],\
    \ $points[$sum2]);\n                    break;\n                }\n          \
    \  }\n        } else {\n            $result[] = $num;\n        }\n        $sum\
    \ -= $num;\n    }\n    return $result + $nums_by_sum;\n}", "    if (empty($nums))\
    \ {\n        return array();\n    }\n\n    $total = 0;\n    foreach ($nums as\
    \ $num) {\n        $total += $num;\n    }\n\n    $numsArr = array();\n    foreach\
    \ ($nums as $i => $num) {\n        if ($total > 0) {\n            $num = ceil($total\
    \ / 10);\n            $numsArr[$i] = $num;\n            $total -= $num * 10;\n\
    \        } else {\n            $numsArr[$i] = $num;\n        }\n    }\n\n    return\
    \ $numsArr;\n}", "    $sorted = array();\n    $digits = array();\n    $sum_points\
    \ = 0;\n\n    foreach($nums as $num) {\n        $digits[] = $num % 10;\n     \
    \   $sum_points -= $num % 10;\n    }\n\n    array_multisort($digits, SORT_ASC,\
    \ $nums);\n\n    foreach($nums as $key => $num) {\n        $sorted[$key] = $num;\n\
    \    }\n\n    $sorted = array_merge($sorted, $digits);\n    $sorted = array_unique($sorted);\n\
    \n    $sorted = array_keys($sorted);\n    $sorted = array_values($sorted);\n\n\
    \    return $sorted;\n}\n", "  if (empty($nums)) {\n    return array();\n  }\n\
    \  $sum_of_digits = array_sum($nums);\n  return array_map(function($n) use ($sum_of_digits)\
    \ {\n    return ($sum_of_digits == $n) ? $n : ((string) $n . (string) abs($sum_of_digits-$n));\n\
    \  }, $nums);\n}\n", "    foreach ($nums as $i => $v) {\n        $v += 0;\n  \
    \      $res[] = $v;\n    }\n    ksort($res);\n    return array_values($res);\n\
    }\n", "  $len = count($nums);\n  for ($i = 0; $i < $len; ++$i) {\n    $nums[$i]\
    \ = $nums[$i] + 0;\n  }\n  return array_map(function ($a) use ($nums) {\n    return\
    \ $nums[$a];\n  }, array_keys($nums));\n}", "  $nums_sorted = array();\n  $sums\
    \ = array();\n  foreach ($nums as $num) {\n    // Store the sum of digits found\
    \ in original numbers\n    // Note that $num is actually a string, as pointed\
    \ out by\n    // @davidrich.\n    $sum = 0;\n    while (list($num, $remainder)\
    \ = each($num)) {\n      $sum += $remainder;\n    }\n    // Store the original\
    \ number in the sorted array\n    $nums_sorted[] = $num;\n    // Store the sum\
    \ of digits found in original numbers in the sorted array\n    $sums[$sum] = $sum;\n\
    \  }\n  ksort($sums);\n  // Sort the numbers in descending order according to\
    \ the sum of digits of\n  // each number\n  uasort($nums_sorted, function($a,\
    \ $b) use ($sums) {\n    // If sums of digits equal, sort the numbers in ascending\
    \ order based in their original index\n    if (isset($sums[$a + $b]) && $sums[$a\
    \ + $b] == $sums[$b + $a]) {\n      return $a - $b;\n    }\n    // Otherwise,\
    \ sort the numbers in descending order based in their original index\n    return\
    \ $b - $a;\n  });\n  return $nums_sorted;\n}", "  asort($nums, array($this, 'sum'));\n\
    \  return $nums;\n}\n", "  $arr = array_reverse($nums);\n  $sum = array_sum($arr);\n\
    \  $order = array();\n  foreach ($arr as $key => $value) {\n    $order[$key] =\
    \ $sum - $value;\n  }\n  return $arr + $order;\n}\n</code>\n<|/ a tags=php,arrays,sorting\
    \ |>\n<| c |>\nWhat is this $arr variable holding?\n<|/ c |>\n<| c |>\nsorry i\
    \ forgot to add that in code . but i have edited the question and added the $arr\
    \ variable .\n<|/ c |>\n<| a dscore=4 |>\nThe simplest approach is to just sort\
    \ the array and then re-index it:\n<code>\n$a = array('-1', '2', '10', '5', '25',\
    \ '-5');\n$a = array_map(function ($e) { return $e * -1; }, $a);\nsort($a);\n\
    $a = array_reverse($a);\n</code>\n<|/ a tags=php,arrays,sorting |>\n<| c |>\n\
    I like this solution a lot because you don't have to use any extra variables.\n\
    <|/ c |>\n<| c |>\nI like it, but this solution doesn't seem to work with negative\
    \ numbers. I made a slight modification to make it work for negative numbers too:\
    \ $a = array_map(function ($e) { return abs($e * -1); }, $a);\n<|/ c |>\n<| c\
    \ |>\nGood point, thanks! I believe `abs` also works for negative numbers, but\
    \ I'm less familiar with PHP than I should be to know for sure.\n<|/ c |>\n<|\
    \ a |>\nThis was my solution:\n<code>\n<?php\n$numbers = array(\n    \"-5\" =>\
    \ array(\"a\" => \"-5\"),\n    \"-1\" => array(\"b\" => \"-1\"),\n    \"0\" =>\
    \ array(\"c\" => \"0\"),\n    \"1\" => array(\"d\" => \"1\"),\n    \"2\" => array(\"\
    e\" => \"2\"),\n    \"3\" => array(\"f\" => \"3\"),\n    \"4\" => array(\"g\"\
    \ => \"4\"),\n    \"5\" => array(\"h\" => \"5\")\n);\n", "    $nums = array_reverse($nums);\n\
    \    $sum = array_sum($nums);\n    $results = array();\n    $index = 0;\n    while\
    \ ($index < count($nums)) {\n        $num = $nums[$index];\n        $digits =\
    \ substr($sum, strlen($sum) - $index, strlen($sum));\n        if ($digits == $num)\
    \ {\n            $results[] = $index;\n            $index++;\n        }\n    }\n\
    \    return array_flip($results);\n}\n", "  $result = [];\n  foreach ($nums as\
    \ $k => $v) {\n    $sum = $v;\n    foreach (str_split($v) as $v) {\n      $sum\
    \ += intval($v);\n    }\n    $result[$k] = $sum;\n  }\n  asort($result);\n  foreach\
    \ ($result as $k => $v) {\n    $result[$k] = $nums[$k];\n  }\n  return $result;\n\
    }\n", "    $sorted = array();\n    foreach($nums as $num) {\n        $sum = array_sum(str_split($num));\n\
    \        $sorted[] = $nums[$sum == 0 ? count($nums) : array_search($sum, $nums)];\n\
    \    }\n    return $sorted;\n}\n", "    $sum_of_digits = array();\n    foreach($nums\
    \ as $num) {\n        $sum_of_digits[] = array_sum(str_split($num));\n    }\n\
    \    array_multisort($sum_of_digits, $nums);\n    return $nums;\n}\n", "\t$nums\
    \ = array_reverse($nums);\n\tforeach($nums as $index => $num) {\n\t\t$sum = 0;\n\
    \t\tfor($i = strlen($num) - 1; $i >= 0; $i--) {\n\t\t\t$sum += intval(substr($num,\
    \ $i, 1));\n\t\t}\n\t\t$nums[$index] = $sum;\n\t}\n\t$nums = array_reverse($nums);\n\
    \tusort($nums, 'compare_numbers');\n\treturn array_reverse($nums);\n}\n", "  $points\
    \ = array();\n  $prev_point = NULL;\n  foreach ($nums as $num) {\n    $point =\
    \ $num;\n    if ($point == 0) {\n      continue;\n    }\n    if ($point > 0 &&\
    \ $point <= 9) {\n      $point++;\n    }\n    $points[] = $point;\n    if ($prev_point\
    \ != null) {\n      if ($prev_point > 0 && $prev_point <= 9) {\n        $prev_point++;\n\
    \      }\n      if ($point > $prev_point) {\n        $points[] = $prev_point;\n\
    \      }\n    }\n    $prev_point = $point;\n  }\n  asort($points);\n  return $points;\n\
    }\n", "  foreach ($nums as $k => $v) {\n    if ($k == 0) {\n      $new[$k] = $v;\n\
    \    }\n    else {\n      $sum = 0;\n      foreach ($nums as $k2 => $v2) {\n \
    \       $sum += $v2 / $k;\n        if ($sum != $v) {\n          $new[$k] = $v2;\n\
    \        }\n      }\n    }\n  }\n  return $new;\n}", "  $sum_points = 0;\n  foreach\
    \ ($nums as $key => $num) {\n    $sum_points -= floor($num / 10) * 10;\n    $sum_points\
    \ -= floor($num / 100) * 100;\n    $sum_points -= floor($num / 1000) * 1000;\n\
    \    $sum_points += $num;\n  }\n  return $sum_points;\n}", "    // sort in descending\
    \ order\n    $nums = array_reverse($nums);\n    \n    // for each item, sum the\
    \ digits using array_sum(), and sort them\n    // according to this sum\n    $sums\
    \ = array_sum($nums);\n    $nums = array_sort($nums, function($a, $b) use ($sums)\
    \ {\n        return ($a + $b) / $sums - $a / $sums - $b / $sums;\n    });\n  \
    \  \n    return $nums;\n}\n", "\t$result = array();\n\n\t// Go through each item\
    \ in $nums\n\t// If the item has digits ($item has non-zero length),\n\t// Add\
    \ it to $result, then add the sum of its digits to $result\n\tforeach($nums as\
    \ $item) {\n\t\t// If item has digits, add it to $result\n\t\tif(!empty($item))\
    \ {\n\t\t\t$result[] = $item;\n\t\t\t// Add its sum to $result\n\t\t\t$result[]\
    \ = array_sum(str_split($item));\n\t\t}\n\t}\n\n\t// Sort $result array in ascending\
    \ order\n\tarray_multisort($result);\n\n\t// Return $nums in ascending order\n\
    \treturn $nums;\n}\n", "  // Sort the numbers based on the sum of their digits\n\
    \  usort(\n    $nums,\n    function ($a, $b) {\n      return strnatcmp(strval(array_sum(str_split(strval($a)))),\n\
    \                        strval(array_sum(str_split(strval($b))));\n    }\n  );\n\
    \n  return $nums;\n}\n", "  sort($nums);\n  $result = [];\n  foreach ($nums as\
    \ $k => $v) {\n    if (isset($result[$v])) {\n      unset($result[$v]);\n    }\n\
    \    $result[$v] = $k;\n  }\n  return $result;\n}", "  $ordered = array();\n \
    \ foreach ($nums as $num) {\n    $ordered[] = $num;\n  }\n  natsort($ordered);\n\
    \  return $ordered;\n}\n", "    $sums = array_map(function ($num) {\n        return\
    \ array_sum(str_split($num));\n    }, $nums);\n    asort($sums);\n    return array_map(function\
    \ ($num) use ($sums) {\n        return array_search($num, $sums);\n    }, $nums);\n\
    }\n</code>\nThe final function might look like this:\n<code>", "    $sort = array();\n\
    \    foreach($nums as $n){\n        $t = 0;\n        for($i=0;$i<strlen($n);$i++){\n\
    \            $t+= $n[$i]*pow(10,$i);\n        }\n        if(!isset($sort[$t])){\n\
    \            $sort[$t] = $n;\n        }else{\n            $index = $sort[$t];\n\
    \            $sort[$t] = $nums[$index];\n            $sort[$index] = $t;\n   \
    \     }\n    }\n    return $sort;\n}", "  // TODO: Implement this\n}\n$points\
    \ = array(\n  array(1, 4, 9, 3, 6),\n  array(-1, 4, -2, -3, -6),\n  array(1, 4,\
    \ 9, 3, 6),\n  array(-1, 4, -2, -3, -6)\n);\n$result = order_by_points($points);\n\
    echo \"<pre>\";\nprint_r($result);\necho \"</pre>\";", "  // Sort the given array\
    \ in ascending order according to the sum of their digits\n  usort($nums, function($a,\
    \ $b) {\n    $sum = 0;\n    foreach (str_split($a) as $char) {\n      $sum +=\
    \ intval($char);\n    }\n    foreach (str_split($b) as $char) {\n      $sum +=\
    \ intval($char);\n    }\n    return $sum;\n  });\n  return $nums;\n}\n", "   \
    \ return array_reduce($nums, function ($carry, $item) {\n        $carry += $item\
    \ < 0 ? -$item : $item;\n        return $carry;\n    }, 0);\n}\n", "  // write\
    \ your code here\n  $points = array();\n  $sums = array();\n  foreach ($nums as\
    \ $num) {\n    $points[] = $num;\n    $sums[] = strval($num);\n  }\n  array_multisort($sums,\
    \ $points);\n  return $points;\n}\n", "    $sorted = [];\n    foreach ($nums as\
    \ $item) {\n        $sorted[] = $item;\n    }\n    array_multisort($sorted, $nums);\n\
    \    return $nums;\n}\n", "\tglobal $total, $sorted, $index;\n\tif (empty($nums))\
    \ return array();\n\tusort($nums, '_sort_by_points');\n\tforeach ($nums as $i\
    \ => $num) {\n\t\t$index[$i] = $i;\n\t\t$total[$i] = $total + ($num * pow(10,\
    \ count($nums) - 1 - $i));\n\t}\n\tasort($nums);\n\t$sorted = array();\n\tforeach\
    \ ($nums as $i => $num) {\n\t\t$sorted[$i] = $index[$i];\n\t}\n\treturn $sorted;\n\
    }\n", "    sort($nums, SORT_NUMERIC);\n    $sums = array_sum($nums);\n    $ret\
    \ = [];\n    foreach ($nums as $i => $n) {\n        $ret[$i] = $n;\n    }\n  \
    \  return $ret;\n}\n", "  $result = array();\n  foreach ($nums as $i => $n) {\n\
    \    $result[$i] = $n;\n  }\n  // Sort $result with array_multisort according\
    \ to\n  // the sum of its elements.\n  array_multisort($result, SORT_ASC, $nums);\n\
    \  return $result;\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=php,algorithm,arrays,sorting\
    \ |>\nFor this kind of problems I usually use a recursive function.\nIn this case\
    \ I would take the first element and sort it by the sum of the remaining elements.\
    \ Then recursively call the function with the first element and the remaining\
    \ elements, and sort the returned array.\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n\
    Here is my solution, tested in php.\n<code>", "    $sum_of_points = 0;\n    foreach\
    \ ($nums as $key => $num) {\n        $sum_of_points += $num;\n    }\n\n    foreach\
    \ ($nums as $key => $num) {\n        $nums[$key] = $num - $sum_of_points;\n  \
    \  }\n\n    return $nums;\n}\n", "  $sums = array_map(function ($n) {\n    return\
    \ $n[0];\n  }, $nums);\n  array_multisort($sums, $nums);\n  return $nums;\n}\n\
    </code>\n<|/ a dscore=4 |>\n<| a dscore=2 tags=php,algorithm |>\nMy take on it:\n\
    <code>", "  $sums = array();\n  $len = count($nums);\n  for ($i = 0; $i < $len;\
    \ $i++) {\n    $sums[$nums[$i]] = 0;\n  }\n  for ($i = 0; $i < $len; $i++) {\n\
    \    $sums[$nums[$i]] += $i;\n  }\n  arsort($sums);\n  for ($i = 0; $i < $len;\
    \ $i++) {\n    $nums[$i] = $sums[$i];\n  }\n  return $nums;\n}\n</code>\n<|/ a\
    \ tags=algorithm,php dscore=2 |>\n<| c |>\nYour answer looks much cleaner indeed\
    \ but the problem is that it is time consuming. I have an input of 100k integers\
    \ (random numbers I guess) and the script times out after 10 minutes. I will need\
    \ to try my solution by putting it on a separate server.\n<|/ c |>\n<| c |>\n\
    I added an answer, which I thought could work - but I can't help you with running\
    \ a script on a different server. :)\n<|/ c |>\n<| c |>\nI added a version which\
    \ should be faster, if your array is really big.\n<|/ c |>\n<| c |>\nI've been\
    \ thinking of trying the other answers and will try the new one as soon as I can\
    \ test it (I'm travelling). Thanks a lot for your help so far.\n<|/ c |>\n<| c\
    \ |>\nThis one should be the accepted answer. Nice work.\n<|/ c |>\n<| a dscore=2\
    \ |>\nThe only thing I can think of is to sort each digit in the array separately,\
    \ and put it together at the end. Since you are comparing two digits at once,\
    \ I think sorting by digits is going to take you a long time.\n<code>\n<?php\n",
  "  // Clone original array.\n  $nums_arr = array();\n  foreach ($nums as $num) {\n\
    \    $nums_arr[] = $num;\n  }\n\n  usort(\n    $nums_arr,\n    function($a, $b)\
    \ {\n      // Sum of digits in two numbers is same.\n      if ($a == $b) {\n \
    \       return 0;\n      }\n\n      // Sum of digits in two numbers is different.\n\
    \      $a_digits = array_sum(str_split($a, 1));\n      $b_digits = array_sum(str_split($b,\
    \ 1));\n\n      if ($a_digits == $b_digits) {\n        return $a < $b ? 1 : -1;\n\
    \      }\n\n      // Sum of digits in two numbers is same.\n      return $a_digits\
    \ < $b_digits ? 1 : -1;\n    }\n  );\n\n  return $nums_arr;\n}\n", "    $sum_of_points\
    \ = 0;\n    foreach ($nums as $num) {\n        $sum_of_points += $num;\n    }\n\
    \    return array_values(array_filter($nums, function($num) use ($sum_of_points)\
    \ {\n        return $num != '' && $sum_of_points > $num;\n    }));\n}\n", "  sort($nums,\
    \ SORT_NUMERIC);\n  $sum = 0;\n  for ($i = 0; $i < count($nums); ++$i) {\n   \
    \ $sum -= $nums[$i];\n    if ($sum < 0) {\n      $sum = 0;\n    }\n  }\n  return\
    \ $nums;\n}\n", "  if (empty($nums)) {\n    return array();\n  }\n  // Store the\
    \ total of each part of each integer.\n  // For example, the total of 1, 11, -1\
    \ and -11 is 9, which means that\n  // 1 is at position 0 and the rest are at\
    \ 9.\n  $points = array();\n  foreach ($nums as $num) {\n    $points[] = $num;\n\
    \  }\n\n  // Sort them in descending order. Thus, the larger number will be on\
    \ top.\n  array_multisort($points, SORT_DESC);\n\n  // Get the original ordering\
    \ by the total of each part of each integer.\n  $points_by_total = array();\n\
    \  foreach ($points as $i => $point) {\n    $points_by_total[$i] = $i;\n  }\n\n\
    \  return array_values($points_by_total);\n}\n</code>\n<|/ a |>\n<| c |>\nThanks\
    \ for your answer. Your first function works fine, but I could not make it work\
    \ for the second one. The function `sort_by_points` is supposed to take an array\
    \ of positive and negative numbers and sort it by the total of their digits. For\
    \ example, `sort_by_points(array(1, 11, -1, -11, -12))` should return `array(-1,\
    \ -11, 1, -12, 11)`.\n<|/ c |>\n<| c |>\nI updated my answer. I tested it on several\
    \ examples and it works fine. Let me know if it works for you too.\n<|/ c |>\n\
    <| c |>\nI just added my own answer. I had no idea this solution exists.\n<|/\
    \ c |>\n<| a tags=php,algorithm,sorting,arrays |>\nYou can create an array of\
    \ all the sums and sort using that array\n<code>\n<?php\n\n$array = array(-101,111,-102,110,-111);\n\
    \n$totals = array();\n\nforeach($array as $value){\n    $totals[$value] = $value*1;\n\
    }\n\nksort($totals);\n$array = array_keys($totals, max($totals));\n</code>\nThis\
    \ way you can sort by largest to smallest\n<|/ a dscore=0 |>\n<| c |>\nThanks\
    \ for your answer. Your first function works fine, but I could not make it work\
    \ for the second one. The function `sort_by_points` is supposed to take an array\
    \ of positive and negative numbers and sort it by the total of their digits. For\
    \ example, `sort_by_points(array(1, 11, -1, -11, -12))` should return `array(-1,\
    \ -11, 1, -12, 11)`.\n<|/ c |>\n<| a tags=php,algorithm,sorting,arrays |>\nI did\
    \ a lot of research and came up with this solution. It's not as good as it could\
    \ be ", "    // Sort $nums using the sort_digits function\n    sort($nums, SORT_NUMERIC);\n\
    \    $sums = array_sum($nums);\n\n    // Create an array of key => value pairs\n\
    \    $new_array = array();\n    foreach ($nums as $key => $num) {\n        $new_array[$key]\
    \ = $num;\n    }\n    foreach ($new_array as $key => $num) {\n        $new_array[$key]\
    \ = $sums - $num;\n    }\n\n    return $new_array;\n}\n", "    sort($nums);\n\
    \    $sorted_points = array();\n    $sums = array_map(\n        function ($num)\
    \ { return ($num < 0) ? -$num : $num; },\n        $nums\n    );\n    foreach ($sums\
    \ as $index => $sum) {\n        $sorted_points[$index] = $nums[$index];\n    }\n\
    \    return $sorted_points;\n}\n", "  $n = count($nums);\n  $sums = array_fill(0,\
    \ $n, 0);\n  for ($i = 0; $i < $n; $i++) {\n    $sums[$i] = $nums[$i];\n  }\n\
    \  arsort($sums);\n  return array_keys($sums);\n}\n", "  $sum = array_sum($nums);\n\
    \  $map = array_map(function($item) use ($sum) {\n    return $item > 0 ? $item\
    \ / $sum : $sum - $item;\n  }, $nums);\n  return array_map(function($item) use\
    \ ($map) {\n    return $map[$item];\n  }, $nums);\n}", "\tglobal $sum;\n\t$sum\
    \ = 0;\n\tforeach ($nums as $key => $value) {\n\t\t$sum += $value;\n\t\t$nums[$key]\
    \ = $value;\n\t}\n\tarray_multisort($nums, SORT_ASC, $sum);\n\treturn $nums;\n\
    }\n", "    sort($nums);\n    $points = array();\n    $size = count($nums);\n \
    \   $index = 0;\n    $index2 = 0;\n    $sum = 0;\n    foreach ($nums as $n) {\n\
    \        $index++;\n        $sum += $n;\n        $points[$index] = $n;\n     \
    \   if ($sum < 0) {\n            $sum = 0;\n            $index--;\n        }\n\
    \        if ($index == $size - 1) {\n            $index++;\n            $sum =\
    \ 0;\n        }\n    }\n    $result = array();\n    foreach ($points as $n) {\n\
    \        $result[] = $n;\n    }\n    return $result;\n}\n", "    if (!is_array($nums))\n\
    \        return array();\n    $sums = array_sum($nums);\n    return array_intersect_key($nums,\
    \ array_flip(array_keys($nums, $sums)));\n}\n", "    // write your code here\n\
    \    $sums = array_sum($nums);\n    asort($nums);\n    $result = array();\n  \
    \  foreach ($nums as $key => $value) {\n        if ($sums == $value) {\n     \
    \       $result[$key] = $value;\n        }\n    }\n    return $result;\n}\n",
  "  if (empty($nums)) {\n    return array();\n  }\n  $sums = array_sum($nums);\n\
    \  ksort($sums);\n  $order = array();\n  foreach ($sums as $i => $sum) {\n   \
    \ $order[$i] = $nums[$i];\n  }\n  return $order;\n}\n", "  $nums = array_reverse($nums);\
    \ // reverse the order of the array.\n  foreach ($nums as $i => $num) {\n    $sum\
    \ = 0; // start sum at zero\n    foreach (str_split($num) as $digit) {\n     \
    \ // add each digit to the sum and keep track of the current sum\n      $sum +=\
    \ $digit;\n      $total[$i][] = $sum; // store the sum\n    }\n  }\n  // sort\
    \ the sums and store them in order\n  for ($i = 0; $i < count($nums); $i++) {\n\
    \    ksort($total[$i]);\n  }\n  // rebuild the original array with sums\n  return\
    \ array_merge($nums);\n}", "    $sorted = array();\n    foreach ($nums as $key\
    \ => $val) {\n        $digits = str_split($val);\n        $sum = 0;\n        foreach\
    \ ($digits as $digit) {\n            $sum += (int) $digit;\n        }\n      \
    \  $sorted[$key] = $sum;\n    }\n    asort($sorted);\n    return $sorted;\n}\n\
    </code>\nIt will be much more efficient to sort the array by its sum rather than\
    \ its index. It can also be easily extended to find sum of each pair of points.\n\
    <code>", "  if (empty($nums)) {\n    return array();\n  }\n  // Build a map of\
    \ sums and their positions.\n  $sums = array();\n  foreach ($nums as $i => $num)\
    \ {\n    $sums[$num] = 0;\n  }\n  for ($i = 0, $j = count($nums); $j < $i; ++$i)\
    \ {\n    $sums[$nums[$i]] += $i;\n  }\n  // Sort according to sum.\n  ksort($sums);\n\
    \  $nums = array_values($sums);\n  return $nums;\n}", "    $sum = array_sum($nums);\n\
    \    return array_map(function($num) use ($sum) {\n        return $sum - $num;\n\
    \    }, $nums);\n}\n", "  usort($nums, function($a, $b) {\n    // Sort $b first\n\
    \    $b_sum = 0;\n    foreach ($b as $val) {\n      $b_sum += $val;\n    }\n \
    \   return $b_sum - $a;\n  });\n  return $nums;\n}"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
