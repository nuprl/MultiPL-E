name: HumanEval_100_make_a_pile
language: php
prompt: "<?php\n// Given a positive integer n, you have to make a pile of n levels\
  \ of stones.\n// The first level has n stones.\n// The number of stones in the next\
  \ level is:\n// - the next odd number if n is odd.\n// - the next even number if\
  \ n is even.\n// Return the number of stones in each level in an array, where element\
  \ at index\n// i represents the number of stones in the level (i+1).\n// Examples:\n\
  // >>> make_a_pile(3)\n// array(3, 5, 7)\nfunction make_a_pile($n) {\n"
tests: "function candidate(...$args) {\n    return make_a_pile(...$args);\n}\n\nfunction\
  \ test(): void {\n    if (candidate(3) !== array(3, 5, 7)) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(4) !== array(4, 6, 8, 10)) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(5) !== array(5, 7, 9, 11, 13)) { throw new\
  \ Exception(\"Test failed!\"); }\n    if (candidate(6) !== array(6, 8, 10, 12, 14,\
  \ 16)) { throw new Exception(\"Test failed!\"); }\n    if (candidate(8) !== array(8,\
  \ 10, 12, 14, 16, 18, 20, 22)) { throw new Exception(\"Test failed!\"); }\n}\n\n\
  test();"
completions: ["    $pile = array();\n\n    if ($n%2 == 1) {\n        $pile[] = $n;\n\
    \    } else {\n        for ($i = 0; $i < $n; $i += 2) {\n            $pile[] =\
    \ $i;\n        }\n    }\n\n    return $pile;\n}\n", "    $arr = array();\n   \
    \ $i = 1;\n    $arr[$i] = $n;\n    for ($i = 1; $i < $n; $i++) {\n        if ($i\
    \ % 2 == 0) {\n            $arr[$i] += $i;\n        } else {\n            $arr[$i]\
    \ += $i / 2;\n        }\n    }\n    return $arr;\n}\n", "    if ($n < 1) {\n \
    \       return array();\n    }\n\n    $result[] = $n;\n    $next_odd_number =\
    \ $next_even_number = $n;\n\n    while ($next_odd_number % 2 != 0) {\n       \
    \ $next_odd_number += 1;\n    }\n    while ($next_even_number % 2 == 0) {\n  \
    \      $next_even_number -= 1;\n    }\n\n    $pile[$next_odd_number] = $n - $next_odd_number;\n\
    \    $pile[$next_even_number] = $n - $next_even_number;\n\n    array_shift($pile);\n\
    \n    $number_of_piles = sizeof($pile) - 1;\n    foreach ($pile as $key => $value)\
    \ {\n        $number_of_piles += $value;\n    }\n\n    return array_map('intval',\
    \ $pile);\n}\n</code>\n<|/ a tags=math,php |>\n<| c |>\nThank you. I'll try that\
    \ and post the results.\n<|/ c |>\n<| c |>\nI added my code to the question. I\
    \ tried to convert it into PHP but I'm getting an error.\n<|/ c |>\n<| c |>\n\
    This code looks fine to me, except for the `if ($n < 1)` which should probably\
    \ be `if ($n < 0)` since `make_a_pile(0)` should return `[0]`.\n<|/ c |>\n<| c\
    \ |>\nSorry about the n<1 error. I am working on this problem and I accidentally\
    \ typed 1 in the question box. The code actually works but I am getting a fatal\
    \ error from the IDE because of the error. I can't figure out what the issue is.\n\
    <|/ c |>\n<| c |>\nI just checked it with the code you provided. It's giving me\
    \ a fatal error. I think it's because I am not returning anything in the first\
    \ line of the function. I tried adding `return $result;` but I get the same error.\n\
    <|/ c |>\n<| a dscore=1 tags=math,php |>\nI understand that this is an old post,\
    \ but here is my solution: \n<code>\npublic function makeArray(int $n): array\n\
    {\n    $array = [0];\n\n    for($i = 1; $i <= $n; $i++) {\n        $array[] =\
    \ round($i / 2);\n    }\n\n    return $array;\n}\n</code>\n<|/ a |>\n<| a tags=math,php\
    \ |>\nIn PHP, you can make use of pow() to find the number of levels required.\n\
    <code>", "    $arr = array();\n    for ($i = 0; $i < $n; $i++)\n        $arr[]\
    \ = $i + 1;\n    if ($n % 2 == 0)\n        array_push($arr, $n);\n    return $arr;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThank you for not just providing a solution but\
    \ also explaining it.\n<|/ c |>\n<| c |>\nI tested this and it is working fine\
    \ for my case. Thank you very much for helping me\n<|/ c |>\n<| c |>\nWhat if\
    \ I have 2 even numbers ?\n<|/ c |>\n<| a tags=algorithm,php |>\nI see two solutions:\n\
    \nUse a for loop and increment i by 2 as you go through the array. This is the\
    \ most straight forward solution, however it can be very slow with large arrays.\
    \ The second solution uses recursion to do the same thing.\n<code>\n$myArray =\
    \ [1, 2, 3, 4, 5];\n", "  if ($n == 0) return array();\n  return make_a_pile(n\
    \ - 1) + make_odd_or_even($n);\n}", "  $i = 1;\n  $a = [];\n  while ($i <= $n)\
    \ {\n    if ($n % 2) {\n      $a[$i] = $n;\n      $n = $n / 2;\n    } else {\n\
    \      $a[$i] = $n * 2 + 1;\n      $n = $n / 2;\n    }\n    $i++;\n  }\n  return\
    \ $a;\n}\n", "    if ($n < 1) return [];\n    $even = true;\n    $stones = range(1,\
    \ $n);\n    while ($even && $stones[count($stones) - 1] < $n) {\n        $even\
    \ = !$even;\n        array_pop($stones);\n    }\n    if ($even) return array_merge(\n\
    \        [$n],\n        $stones,\n        make_a_pile($n - 1)\n    );\n    return\
    \ $stones;\n}\n", "  $levels = array();\n  for ($i = 0; $i <= $n; $i++) {\n  \
    \  $levels[] = ($i+1);\n  }\n\n  if ($n%2 == 0) {\n    $levels[] = ($n+1);\n \
    \ }\n\n  return $levels;\n}\n", "  $arr = [];\n  for ($i = 0; $i < $n; $i++) {\n\
    \    $arr[$i + 1] = $i + 1;\n  }\n  return $arr;\n}\n", "    $result = [];\n \
    \   if ($n == 1) {\n        return $result;\n    }\n    for ($i = 0; $i < $n;\
    \ $i++) {\n        if ($i % 2 == 0) {\n            $result[] = ($i + 1);\n   \
    \     } else {\n            $result[] = (2 * $i + 1);\n        }\n    }\n    return\
    \ $result;\n}\n", "    $result = array();\n    if ($n % 2 == 0) {\n        $result[]\
    \ = $n;\n        $result[] = $n / 2;\n    }\n    $result[] = $n / 2;\n    $result[]\
    \ = $n / 2;\n    return $result;\n}\n</code>\n<|/ a dscore=1 tags=recursion,algorithm,php\
    \ |>\n<| c |>\nI like this solution as it is concise and simple. I'd like to know\
    \ why my question was down voted.\n<|/ c |>\n<| c |>\nI think it is because your\
    \ question doesn't show any attempt at solving the problem yourself. As such,\
    \ it's more of a code request. It also doesn't show any attempt at doing this\
    \ problem yourself, either. You could have done some research on how to solve\
    \ the problem, and then came here to ask about how to code it, but you'd be better\
    \ off finding someone to do it for you. There are plenty of resources online that\
    \ can help you with this, so your question doesn't need to be down voted.\n<|/\
    \ c |>\n<| c |>\nI thought it was self explanatory. I've added my own attempt.\
    \ I don't believe it can be done without recursion.\n<|/ c |>\n<| c |>\nIf you\
    \ think your code is good enough for others to understand, perhaps you should\
    \ think about voting it up. I agree with your answer being good, but someone would\
    \ have to upvote it.\n<|/ c |>\n<| a |>\nTry this\n<code>", "    $stones = [];\n\
    \    $level = 1;\n    $numStonesInLevel = 0;\n    while ($n--) {\n        if ($level\
    \ % 2) {\n            $stones[] = $numStonesInLevel;\n            $numStonesInLevel\
    \ += 2;\n        } else {\n            $stones[] = $numStonesInLevel;\n      \
    \      $numStonesInLevel++;\n        }\n        $level++;\n    }\n    $stones[]\
    \ = $numStonesInLevel;\n    return $stones;\n}\n</code>\nTest:\n<code>\n$arr =\
    \ make_a_pile(3);\nvar_dump($arr);\n</code>\nOutput\n<code>\narray (size=4)\n\
    \  0 => int 3\n  1 => int 5\n  2 => int 7\n  3 => int 3\n</code>\nExplanation\n\
    \nSince we know that every level will have exactly 3 stones, we can create an\
    \ array that contains 3 elements (first level has 3 stones, second level has 5\
    \ stones, etc).\nWe start with an empty array and start adding stones to it (starting\
    \ with the first level: 3 stones). At each level we check if the level is odd\
    \ or even (level 0 is odd, level 1 is even). Then we just add (+2) or add (1)\
    \ to our current number of stones in the level ($numStonesInLevel). We add the\
    \ number of stones in the last level ($numStonesInLevel) to the array.\n<|/ a\
    \ dscore=0 |>\n<| c |>\nThe output for this should be `[5,3,5,7]`\n<|/ c |>\n\
    <| c |>\nYes, you are right, I just edited the answer. Thanks.\n<|/ c |>\n<| c\
    \ |>\nThis answer is incorrect. In the question, stones are added to a pile of\
    \ stones until `n` is reached. For example, the function should return `[5, 3,\
    \ 3, 7]` if the input is `make_a_pile(6)`.\n<|/ c |>\n<| a |>\nYou can use array_chunk\
    \ to separate all the array into an array with odd index and an array with even\
    \ index. Like this:\n<code>\n$data = [5, 3, 8, 3, 6, 6, 5, 6];\n$odds = array_chunk($data,\
    \ 2);\n$even = array_chunk($data, 1);\nprint_r($odds);\nprint_r($even);\n</code>\n\
    <|/ a tags=php,arrays,algorithm dscore=0 |>\n<| c |>\nThis only works for an odd\
    \ amount of data. For an even amount, this would result in 2 arrays containing\
    \ 1 element each. Notice how the expected output is 4 arrays, each containing\
    \ 3 elements.\n<|/ c ", "    if ($n < 1) return [];\n    if ($n % 2 == 0) {\n\
    \        return array_map(function ($x) { return $x * $x; }, make_a_pile($n/2));\n\
    \    } else {\n        return array_map(function ($x) { return $x + $x; }, make_a_pile($n/2));\n\
    \    }\n}\n", "    $pile = array(1);\n    for ($i = 1; $i <= $n; $i += 2) {\n\
    \        $pile[] = $i;\n    }\n    $pile[] = $n - 1;\n    return $pile;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nYou wrote that your expected output is `[3, 5, 7]`\
    \ but your expected output in the question seems to be `[5, 3, 7]`\n<|/ c |>\n\
    <| c |>\nYou are not counting right number of stones in each level, the highest\
    \ value should be 7 not 6\n<|/ c |>\n<| c |>\n- That's a typo. I'm fixing the\
    \ question.\n<|/ c |>\n<| c |>\nPlease check the question again I've edited it\n\
    <|/ c |>\n<| c |>\n- Please see the update\n<|/ c |>\n<| a tags=arrays,math,php,algorithm\
    \ |>\n<code>", "    if ($n <= 1)\n        return array(1);\n    if ($n & 1)\n\
    \        return array($n);\n    $counts = make_a_pile($n % 2);\n    $counts[]\
    \ = $n % 2 ? $counts[] : $counts[] + $counts[$n - 1];\n    return $counts;\n}\n\
    </code>\n<|/ a tags=php,algorithm |>\n<| a tags=php,algorithm dscore=1 |>\n<code>",
  "\t$a = array();\n\tfor ($i = 1; $i <= $n; $i += 2) {\n\t\tarray_push($a, $i);\n\
    \t}\n\treturn $a;\n}\n", "    if ($n%2 == 0) return array($n);\n    return array($n%2\
    \ + 1, $n/2 + 1);\n}\n", "\t$pile = array(0);\n\t$levels = array();\n\tfor ($i\
    \ = 0; $i < $n; $i++) {\n\t\t$next_level = $i + 1;\n\t\t$levels[] = $next_level;\n\
    \t\tif (($i + 1) % 2 == 0) {\n\t\t\t$next_level = 2 * $next_level;\n\t\t}\n\t\t\
    $pile[] = $next_level;\n\t}\n\treturn $levels;\n}\n", "    $pile = array();\n\
    \    for ($i = 0; $i < $n; $i++) {\n        $pile[$i] = ($i + 1) % 2 ? $pile[$i\
    \ + 1] : $pile[$i];\n    }\n    return $pile;\n}\n", "  $arr = [];\n  for ($i\
    \ = 1; $i <= $n; $i++) {\n    if ($n % 2 === 0) {\n      $arr[] = $i;\n    } else\
    \ {\n      $arr[] = $i + $i;\n    }\n  }\n  return $arr;\n}\n", "    $pilles =\
    \ array($n);\n    if($n % 2 === 0){\n        $pilles[] = $n;\n    }else{\n   \
    \     $pilles[] = $n*2;\n    }\n    for($i = 0; $i < $n/2; $i++) {\n        $pilles[]\
    \ = $pilles[$i]*2 + $pilles[$i+1];\n    }\n    return $pilles;\n}\n</code>\n<|/\
    \ a tags=php |>\n<| c |>\ni used the code but it returns only 1 answer for the\
    \ testcase\n<|/ c |>\n<| a tags=php |>\n<code>\n<?php", "    $x = $n = $n_odd\
    \ = 0;\n    $arr = array();\n    while ($n > 0) {\n        $arr[] = $n_odd;\n\
    \        $n_odd++;\n        if ($n % 2 == 0) {\n            $x++;\n        }\n\
    \        $n++;\n    }\n    return $arr;\n}", "    $nums = array();\n    \n   \
    \ if ($n & 1) $nums[] = $n;\n    \n    $next = $n >> 1;\n    if ($n & 1) $nums[]\
    \ = $next;\n    \n    while ($n) {\n        $next = $n % 2 ? $next + 1 : $next\
    \ + 2;\n        $nums[] = $next;\n        $n = floor($n/2);\n    }\n    \n   \
    \ return $nums;\n}\n", "    $pile = array();\n    $levels = 1;\n    for ($i =\
    \ 1; $i < $n; $i++) {\n        $pile[$i] = $levels;\n        $levels *= 2;\n \
    \   }\n    return $pile;\n}\n", "  $pile = array();\n  if ($n % 2 == 1) {\n  \
    \  $pile[] = $n;\n  }\n  else {\n    $pile[] = ($n % 2 + 1) * $n;\n  }\n  for\
    \ ($i = 2; $i < $n; $i += 2) {\n    $pile[] = $pile[$i];\n  }\n  return $pile;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis is a better answer than mine.  Although\
    \ I'm curious what that function does and why it works.  Can you explain that?\n\
    <|/ c |>\n<| c |>\nIt's an O(1) algorithm, meaning the run-time should be O(1).\
    \ It's basically a nested for loop with a variable that increments by 2 and checks\
    \ if the value of variable divides evenly. Since it doesn't, it continues until\
    \ it does. [Here](http://php.net/manual/en/language.operators.arithmetic.php)\
    \ is the documentation.\n<|/ c |>\n<| c |>\nThis doesn't seem to work when n is\
    \ a non-integer. For example, `make_a_pile(7)` returns `array(7, 3, 7, 1)` instead\
    \ of `array(7, 3, 7)`\n<|/ c |>\n<| a dscore=1 tags=algorithm,php,numbers |>\n\
    It sounds like you may have misunderstood the problem as this looks to me to be\
    \ quite a silly question.\nIn other words, it seems really straightforward to\
    \ me. Just add two numbers together, and if you get a result that is odd or even,\
    \ multiply that result by two. Just take care to round the result down to the\
    \ next lowest integer after adding all numbers.\n<|/ a |>\n<| a dscore=1 |>\n\
    <code>", "    $res = Array();\n    $res[0] = $n;\n    \n    if ($n%2 ==1) {\n\
    \        $res[1] = $n - 1;\n    }\n    \n    if ($n%2 ==0) {\n        $res[2]\
    \ = $n - 2;\n    }\n    \n    return $res;\n}\n", "    $stones = array();\n  \
    \  $stones[] = $n;\n    if ($n % 2 == 0) {\n        for ($i = 2; $i <= $n; $i++)\
    \ {\n            $stones[] = $stones[($n - $i) / 2];\n        }\n    } else {\n\
    \        for ($i = 2; $i <= $n; $i += 2) {\n            $stones[] = $stones[($n\
    \ - $i) / 2];\n        }\n    }\n    return $stones;\n}\n", "    $pile = array();\n\
    \    for($i = 0; $i < $n; $i += 2) {\n        $pile[] = $i;\n    }\n    for($i\
    \ = 1; $i < $n; $i += 2) {\n        $pile[] = $n - $i;\n    }\n    return $pile;\n\
    }", "    $pile = array();\n    $pile[] = $n;\n    if ($n % 2 == 0){\n        $i\
    \ = 1;\n        while ($i < $n){\n            $pile[] = $i+$n;\n            $i\
    \ += $n / 2;\n        }\n    } else {\n        $i = 1;\n        while ($i < $n){\n\
    \            $pile[] = $i-$n;\n            $i += $n / 2;\n        }\n    }\n \
    \   return $pile;\n}", "    $pile = array();\n    $pile[0] = $n;\n    $even =\
    \ $pile[1];\n    $odd = $pile[2];\n\n    if ($odd % 2 === 0 || $even % 2 === 0)\
    \ {\n        return $pile;\n    }\n\n    $pile[1] = $odd + ($even / 2);\n    $even\
    \ = $pile[1];\n\n    for ($i = 3; $i <= $n; $i++) {\n        $pile[$i] = $odd\
    \ + ($even / 2);\n        $even = $pile[$i];\n    }\n\n    return $pile;\n}\n",
  "    $count = 0;\n    $pile = array();\n    for ($i = 0; $i < $n; $i++) {\n    \
    \    $pile[$i] = $count++;\n    }\n    return $pile;\n}\n\n/**\n * Given an array\
    \ containing only 1, 0 and -1, return an array whose elements are the positions\
    \ of elements whose value is 1.\n * Return an empty array if no such elements\
    \ exist.\n * \n * Complexity: O(n)\n * \n * Source: https://stackoverflow.com/a/4375975/1067003\n\
    \ * \n * @param array $arr \n * @return array \n */", "    if ($n <= 0) return\
    \ [];\n    if ($n%2 == 0) return [$n*2+1];\n    return [$n*2+1];\n}\n", "  $result\
    \ = array();\n  if ($n == 0) return $result;\n  if ($n % 2 == 0) return make_a_pile($n/2).$n;\n\
    \  $result = make_a_pile($n-1) + $n/2;\n  return $result;\n}", "    $stones =\
    \ array(0);\n    if ($n === 0) {\n        return array(0);\n    }\n    if ($n\
    \ % 2) {\n        return array(1);\n    }\n    return array_merge(make_a_pile($n-1),\
    \ array($n&1 ? 2 : 1));\n}", "\t$pile = array();\n\tfor ($i = 0; $i < $n; $i++)\
    \ {\n\t\t$pile[] = count($pile) % 2 == 0 ? $n : $n*2;\n\t}\n\treturn $pile;\n\
    }\n", "    $i = 1;\n    $pile = [];\n    for ($j = 1; $j <= $n; $j++) {\n    \
    \    if ($j % 2 == 0) {\n            $pile[] = $j;\n        } else {\n       \
    \     $pile[] = $i;\n            $i += $j % 2 === 1 ? $j + 1 : $j;\n        }\n\
    \    }\n    return $pile;\n}\n</code>\nThe above code should do the trick, with\
    \ a small modification it can be made more elegant, and more efficient.  \nNow\
    \ the question is how do we solve it?  We don't know how many levels we're going\
    \ to make, so we need a recursive solution.  Here it is in PHP:\n<code>", "  \
    \  list($odd, $even) = array($n%2, $n%2);\n    if ($even !== 0) {\n        throw\
    \ new Exception('Must be odd!');\n    }\n    $pile = [1, 2];\n    for ($i = 3;\
    \ $i <= $n; $i++) {\n        if ($i % 2 === 0) {\n            $pile[] = $pile[$odd\
    \ + $pile[$even]];\n        } else {\n            $pile[] = $pile[$odd];\n   \
    \     }\n    }\n    return $pile;\n}\n", "    $pile = array();\n    if ($n%2 ==\
    \ 1) {\n        $pile[] = $n+1;\n    }\n    else {\n        $pile[] = $n+2;\n\
    \    }\n    for ($i = 2; $i < $n; $i += 2) {\n        $pile[] = $n+$i;\n    }\n\
    \    return $pile;\n}\n</code>\n<|/ a |>\n<| c |>\nJust out of curiosity, how\
    \ would you do this recursively?\n<|/ c |>\n<| c |>\nI didn't know this can be\
    \ done recursively. Thank you for sharing.\n<|/ c |>\n<| a tags=php,algorithm\
    \ |>\n<code>", "    $pile = [];\n    while($n >= 1) {\n        $pile[] = $n;\n\
    \        if($n % 2 == 0) {\n            $n = (int) ($n / 2);\n        } else {\n\
    \            $n = $n - (int) ($n / 2);\n        }\n    }\n    return $pile;\n\
    }\n", "    $pile = array();\n    $i = 0;\n    if ($n != 0) {\n        $pile[0]\
    \ = $n;\n        $i++;\n    }\n    while ($n != 0) {\n        if ($n % 2 == 1)\
    \ {\n            $pile[$i] = $pile[$i-1];\n            $i++;\n        }\n    \
    \    $n = $n-1 + ($n-1);\n        $pile[$i] = $n;\n        $i++;\n    }\n    return\
    \ $pile;\n}\n</code>\n<|/ a tags=php,math |>\n<| c |>\nIf you're going to go down\
    \ this path, I might recommend going through it with a pencil and paper and writing\
    \ out the values for all cases (i.e. what does it look like when n is even, what\
    \ does it look like when n is odd, what does it look like when n is 42 ... how\
    \ does the answer change depending on whether n was even or odd? etc). It'll be\
    \ much easier than trying to figure out what the code does - just try running\
    \ it on some cases.\n<|/ c |>\n<| c |>\nYes. It is very helpful to solve such\
    \ problems\n<|/ c |>\n<| a tags=php,math |>\nThis is my solution in PHP:\n<code>",
  "    if ($n == 0) {\n        return array(0);\n    }\n    $odd = ($n % 2 == 1);\n\
    \    $even = ($n % 2 == 0);\n    $pile = array();\n    for ($i = 0; $i < $n; ++$i)\
    \ {\n        if ($odd && $i == 0) {\n            $pile[] = ($n + 1);\n       \
    \ } else if ($even && $i == $n) {\n            $pile[] = ($n + 2);\n        }\
    \ else {\n            $pile[] = $i + 1;\n        }\n    }\n    return $pile;\n\
    }\n\n/**\n * Complete the countingStones function below.\n *\n * This is the Coin\
    \ Change problem.  It is a variation of the bin packing problem.\n *\n * Given\
    \ a set of n coin values, how many combinations of coins can be used to\n * make\
    \ up change for amountToMake.\n *\n * See http://www.codewars.com/kata/552bd7e1cd9bc12c000ac55\
    \ for more examples.\n *\n * @param int amountToMake - How many coins to make\
    \ up.\n * @param array coins - An array of coin values.\n *\n * @return int\n\
    \ */", "  $arr = [];\n  array_push($arr, $n);\n  if (is_odd($n)) {\n    $n = $n\
    \ + ($n % 2 == 1 ? 1 : 0);\n  } else {\n    $n = $n + ($n % 2 == 0 ? 1 : 0);\n\
    \  }\n  for ($i = 2; $i <= $n; $i++) {\n    $arr[] = is_odd($i) ? $i : $i + 1;\n\
    \  }\n  return $arr;\n}\n</code>\nOutput\n<code>\n$input = array(3, 5, 7);\necho\
    \ \"The input array is $input\\n\";\necho \"The output array is \" . implode(',\
    \ ', make_a_pile($input)) . \"\\n\";\n\nThe input array is array(3, 5, 7)\nThe\
    \ output array is 3, 5, 7, 9, 11, 13, 15, 17, 19\n</code>\n<|/ a tags=function,php,arrays\
    \ |>\n<| c |>\nThis solution is simple and elegant! thanks.\n<|/ c |>\n<| c |>\n\
    How about [this one](http://stackoverflow.com/questions/32953905/how-can-i-put-an-array-in-a-pile\
    \ )? Ha!\n<|/ c |>\n<| a tags=function,php,arrays |>\nTry this:\n<code>\n<?php",
  "    $array = [];\n    if ($n % 2 == 0) {\n        array_push($array, array_sum(make_a_pile(ceil($n\
    \ / 2))) * 2);\n    } else {\n        $i = 1;\n        array_push($array, 1);\n\
    \        foreach (make_a_pile(ceil($n / 2)) as $p) {\n            $array[] = $p\
    \ + $i;\n            $i++;\n        }\n    }\n    return $array;\n}\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\nYes, this one is faster than mine. +1.\n<|/ c |>\n\
    <| c |>\nI'm not a php programmer, so I couldn't understand your code :) I appreciate\
    \ your help though !\n<|/ c |>\n<| c |>\nMy code doesn't work - it fails on `make_a_pile(11)`.\
    \ I think it's a typo, or a mistake in my code that I didn't notice until I saw\
    \ your answer - thanks for finding it!\n<|/ c |>\n<| c |>\nI didn't notice it\
    \ because my code has a typo - it's `array_push($array, array_sum(make_a_pile(ceil($n\
    \ / 2)))` not `array_push($array, array_sum(make_a_pile(ceil($n / 2)))` - sorry\
    \ for that confusion.\n<|/ c |>\n<| c |>\nNo problem ! It worked for me now. Thank\
    \ you so much for helping me out !\n<|/ c |>\n<| a tags=php,recursion,algorithm,dynamic-programming\
    \ |>\nMy recursive solution:\n<code>\n$stone_array = array();\n$stone_array[]\
    \ = 1;\n", "    if (!is_int($n) || $n < 1) {\n        die('make_a_pile() expects\
    \ parameter 1 to be a positive integer.');\n    }\n\n    if ($n == 1) {\n    \
    \    return array($n);\n    }\n\n    if ($n % 2 == 0) {\n        return make_a_pile($n\
    \ - 1) + array($n / 2);\n    }\n\n    return make_a_pile($n / 2) + array($n %\
    \ 2);\n}", "    $pile = array();\n    if ($n<=1) {\n        $pile[0] = $n;\n \
    \       return $pile;\n    }\n    $x = $n%2;\n    if ($x==0) {\n        $pile[0]\
    \ = make_a_pile($n/2)+1;\n        $pile[1] = make_a_pile($n/2)+1;\n        return\
    \ $pile;\n    }\n    $pile[0] = make_a_pile($n/2)+1;\n    $pile[1] = make_a_pile($n/2+1);\n\
    \    return $pile;\n}\n</code>\nNow we are almost there. We need to get the number\
    \ of stones at each level:\n<code>\n<?php", "\t$n = abs($n);\n\t$result = [];\n\
    \tfor ($i = 1; $i <= $n; ++$i) {\n\t\t$result[] = abs($i) % 2 === 0 ?\n\t\t\t\
    $i % 2 === 0 ? $i : $i + 1 :\n\t\t\t$i % 2 === 1 ? $i : $i + 1;\n\t}\n\treturn\
    \ $result;\n}\n\n/**\n * @param array $array\n * @return array\n */", "    $pile\
    \ = array();\n    if ($n<=0)\n        return $pile;\n    $pile[] = $n;\n    if\
    \ ($n%2==0)\n        return $pile;\n    $next = 2; // next odd number to add to\
    \ level\n    do {\n        $pile[] = $next;\n        if ($next%2==0)\n       \
    \     return $pile;\n        $next+=2;\n    } while ($n>0);\n}\n", "  if ($n ==\
    \ 1) {\n    return array($n);\n  }\n  if ($n % 2 == 0) {\n    return make_a_pile($n\
    \ / 2) . array($n % 2);\n  } else {\n    return make_a_pile($n / 2) . array($n\
    \ % 2);\n  }\n}\n", "  if ($n < 2) {\n    return array();\n  }\n\n  $pile = array();\n\
    \  $pile[0] = $n;\n  $n = $n % 2;\n  while ($n > 0) {\n    if ($n % 2 === 0) {\n\
    \      $pile[] = $n;\n    } else {\n      $pile[] = 1 + ($n / 2);\n    }\n   \
    \ $n = $n / 2;\n  }\n\n  return $pile;\n}\n", "    if ($n < 1) return array();\n\
    \    if ($n == 1) return array(1);\n\n    // the odd number\n    $odds = range(2,\
    \ $n);\n    $odds[] = $n; // add the last one\n    foreach ($odds as $k) {\n \
    \       // the even number\n        $evens = range($k, $n+1);\n        $evens[]\
    \ = $n+1; // add the last one\n        foreach ($evens as $i) {\n            $result[$k][$i]\
    \ += 1;\n        }\n    }\n    return $result;\n}\n</code>\n<|/ a tags=php,arrays,algorithm,multidimensional-array\
    \ dscore=0 |>\n<| a dscore=0 |>\n<code>\n<?php\n", "    $array = array();\n  \
    \  $array[$n] = $n++;\n    for($i = 1; $i <= $n; $i = $i + $n % 2 == 0 ? $i +\
    \ 1 : $i + 2) {\n        $array[$i] = $n;\n    }\n    return $array;\n}\n</code>\n\
    <|/ a tags=php dscore=0 |>\n<| a tags=php dscore=0 |>\n<code>\n<?php\n$n=4;\n\
    $pile=array(1,2,4,8);\n\nfor($i=0;$i<$n;$i++)\n{\n    if($i%2==0)\n    {\n   \
    \     $pile[$i]=$pile[$i-1];\n        $pile[$i]=$pile[$i]+1;\n    }\n    else\n\
    \    {\n        $pile[$i]=$pile[$i-1]+2;\n    }\n}\nprint_r($pile);", "\t$array\
    \ = [];\n\tfor ($i = 1; $i <= $n; $i += 2) {\n\t\t$array[] = $i;\n\t}\n\treturn\
    \ $array;\n}\n", "    $result = [];\n    for($i=1; $i<=$n; $i++) {\n        if($i%2\
    \ == 0) {\n            $result[$i] = 0;\n        } else {\n            $result[$i]\
    \ = $i+1;\n        }\n    }\n    return $result;\n}\n</code>\nI used array_filter\
    \ with array_values to get the final result. The array key will be the level (i+1)\
    \ while the value will be the number of stones in that level. So, level 1 has\
    \ 5 stones, level 2 has 7 stones, etc.\n<|/ a dscore=2 |>\n<| a tags=arrays,php,multidimensional-array\
    \ |>\n<code>\n$stones = array(\n    array(5, 2, 3),\n    array(7, 9, 6, 4),\n\
    \    array(3, 8, 9),\n    array(4, 1),\n    array(4, 8)\n);\n\n$result = [];\n\
    $level = 0;\n$stone = 0;\nforeach ($stones as $stone) {\n    if ($stone > count($stones)\
    \ - 1) {\n        $level++;\n        $result[($level - 1)] = $stone;\n    } else\
    \ {\n        $result[($level - 1)][] = $stone;\n    }\n}\n\nvar_dump($result);\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nThe logic of how you count the stones and\
    \ populate the array was very helpful. Thank you!\n<|/ c |>\n<| a |>\nI like using\
    \ foreach loops whenever possible, they're often faster than for loops. \n<code>\n\
    <?php\n\n$stones = [\n    array(5, 2, 3),\n    array(7, 9, 6, 4),\n    array(3,\
    \ 8, 9),\n    array(4, 1),\n    array(4, 8)\n];\n\n$levels = 0;\n$levels[] = array_fill_keys(array_keys($stones[0]),\
    \ 0);\n\nforeach ($stones as $stone) {\n    // If the next stone has an extra\
    \ stone in it\n    if(count($stone) != count($stones[($stones !== count($stones))\
    \ ? $stones ++ : 0]))\n        // Add one to the level and add all the stones\n\
    \        $levels[count($levels) - 1] += array_sum(array_slice($stone, 0, count($stone)));\n\
    }\n\nvar_export($levels);\n</code>\n<|/ a tags=arrays,php,multidimensional-array\
    \ dscore=1 |>\n<| a tags=arrays,php,multidimensional-array |>\nHere's a simple\
    \ solution using a for loop.\n<code>\n$stones = array(\n    array(5, 2, 3),\n\
    \    array(7, 9, 6, 4),\n    array(3, 8, 9),\n    array(4, 1),\n    array(4, 8)\n\
    );", "\t$levels[] = $n;\n\tif( $n % 2 == 0 ) {\n\t\t$levels[] = $n + ( $n & 1\
    \ );\n\t}\n\treturn $levels;\n}\n", "    $stones = array();\n    $stones[] = $n;\n\
    \    if ($n % 2) {\n        for ($i = 1; $i < $n; $i++) {\n            $stones[]\
    \ = $i % 2 ? $n : $i * 3 + 1;\n        }\n    } else {\n        for ($i = 1; $i\
    \ < $n; $i++) {\n            $stones[] = $n % 2 ? $n : $i * 3;\n        }\n  \
    \  }\n    return $stones;\n}\n", "    while(is_int($n) && $n >= 1) {\n       \
    \ $n = $n % 2 == 0 ? $n*2+1 : $n*2+2;\n    }\n    $array = array();\n    while($n\
    \ >= 1) {\n        $array[] = $n;\n        $n = $n % 2 == 0 ? $n/2+1 : $n/2+2;\n\
    \    }\n    return $array;\n}\n", "    if ($n < 0) return NULL;\n    $pile = array();\n\
    \    if ($n > 0) {\n        $pile[0] = make_a_pile($n-1);\n        if (($n % 2)\
    \ == 0) $pile[1] = make_a_pile($n/2);\n        else $pile[1] = make_a_pile($n/2\
    \ + 1);\n    }\n    return $pile;\n}", "    $stones = array();\n    for ($i=0;\
    \ $i<$n; $i++) {\n        if ($i%2 == 0) $stones[] = $i+1;\n        else $stones[]\
    \ = $i+2;\n    }\n    return $stones;\n}\n\n$n = 3;\n$stones = make_a_pile($n);\n\
    print_r($stones);\n</code>\n<|/ a tags=php,arrays,math,algorithm |>\n<| c |>\n\
    Please use English everywhere - it's very annoying to have to leave it out to\
    \ read your code.\n<|/ c |>\n<| c |>\nI did not have enough time to convert this\
    \ to English right now, but I did it in a couple of minutes. Should I include\
    \ it in my answer? Thanks.\n<|/ c |>\n<| c |>\nThanks ! I didn't know about this\
    \ \"even and odd\" thing about integers :)\n<|/ c |>\n<| c |>\nI fixed a small\
    \ bug in the first version. Hopefully my edits make your post more readable.\n\
    <|/ c |>\n<| c |>\nHaha, nice! I didn't notice that mistake!\n<|/ c |>\n<| a dscore=1\
    \ |>\n<code>\n$stones = array(1,3,5,7);\n$result = count($stones);\n$odds = array_filter($stones,\
    \ function($v) use (&$result) { return $v & 1; });\n$evens = array_filter($stones,\
    \ function($v) use (&$result) { return $v & 2; });\nforeach($odds as $odd) {\n\
    \    $result -= $odd;\n}\nforeach($evens as $even) {\n    $result += $even;\n\
    }\nreturn $result;\n</code>\n<|/ a tags=php,arrays,math,algorithm |>\n<| a dscore=0\
    \ |>\n<code>\n<?php\n$stones = array(1,3,5,7,9);\n$num_levels = count($stones);\n\
    $level = array();\n$total_level = count($stones);\n\nfor($i=1;$i<$total_level;$i++){\n\
    \    if($i%2==0){\n        $level[$i] = $stones[$i];\n        $num_levels = $i-2;\n\
    \    }\n}\n\necho \"Level 1: \" . $level[1] . \"<br/>\";\necho \"Level 2: \" .\
    \ $level[2] . \"<br/>\";\necho \"Level 3: \" . $level[3] . \"<br/>\";\necho \"\
    Level 4: \" . $level[4] . \"<br/>\";\necho \"Level 5: \" . $level[5] . \"<br/>",
  "    if ($n == 0) {\n        return array();\n    }\n    return array_merge(make_a_pile(ceil($n/2)),\
    \ array($n % 2 == 0 ? 1 : 2));\n}", "    $pile = array();\n    for ($i = 0; $i\
    \ < $n; $i++) {\n        $pile[$i] = $i;\n    }\n    array_push($pile, $n & 1\
    \ ? count($pile) - 1 : count($pile) - 2);\n    return $pile;\n}\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\nI'm sorry, I'm not that good at programming. Could you\
    \ please explain what is going on in your code? Also is there a way to write this\
    \ code without using the modulus? I'm just wondering because that would be a lot\
    \ more fun.\n<|/ c |>\n<| c |>\nIt's not that complicated if you look at the example\
    \ in the link. I'll add the explanation in a few minutes.\n<|/ c |>\n<| c |>\n\
    Thank you for the explanation. I'm still not very familiar with PHP. I understand\
    \ the first part but I don't understand what you mean by $n & 1 ? count($pile)\
    \ - 1 : count($pile) - 2. Could you please explain how that line works?\n<|/ c\
    \ |>\n<| c |>\nWhen you do `$n & 1` you get the bit of the number `1` which is\
    \ at position `1` of the binary representation of the number. The number `1` has\
    \ the binary representation `0b0001`. So `0b0001` is a binary number `1`. If we\
    \ add two such numbers we get a number with binary representation `0b0010` which\
    \ is equal to `2`. We do that because 1 plus 1 equals 2. `count($pile)` counts\
    \ the number of elements in the array `$pile`.\n<|/ c |>\n<| a tags=php |>\n<code>\n\
    <?php", "    return array_fill(0, $n, 0);\n}\n</code>\n<|/ a dscore=0 |>\n<| c\
    \ |>\nYou don't have to return the array with the number of stones in the level,\
    \ you can return it by reference and change the value by `return`ing it. `return\
    \ &$n[$n%2];`\n<|/ c |>\n<| c |>\n-ii- thanks for that, never thought of that.\n\
    <|/ c |>\n<| a dscore=0 |>\nI tried to solve this problem by using a global array\
    \ $stones, to store which stone belongs to the current array index.\n<code>\n\
    <?php\n\n$stones = [\n    0 => 0,\n    1 => 1,\n    2 => 2,\n    3 => 3,\n];\n\
    \n$stonesLength = 8;\n", "    $pile = [0 => 0];\n    if ($n > 0) {\n        $pile\
    \ = make_a_pile($n - 1) + [0 => $n / 2];\n    }\n    return $pile;\n}\n", "  \
    \  // initialize a pile array\n    $pile = array();\n\n    // for each level of\
    \ pile array\n    for ($i = 0; $i < $n; $i++) {\n        // find next odd or even\n\
    \        if ($i % 2 === 0) {\n            $pile[] = $i;\n        } else {\n  \
    \          $pile[] = $n - $i;\n        }\n    }\n\n    return $pile;\n}\n", " \
    \   $arr = [$n];\n    $temp = $n;\n    while ($temp > 1) {\n        if ($temp\
    \ % 2 == 0) {\n            $temp -= 2;\n        } else {\n            $temp--;\n\
    \        }\n        $arr[] = $temp;\n    }\n    return $arr;\n}\n</code>\n<|/\
    \ a |>\n<| a |>\nHere is a recursive php version without using array_merge:\n\
    <code>\n<?php", "  $array = array();\n  for ($i = 1; $i <= $n; $i++) {\n    if\
    \ ($i % 2 == 0) {\n      $array[] = $i;\n    } else {\n      $array[] = $n - $i;\n\
    \    }\n  }\n  return $array;\n}\n", "    $pile = array();\n    for ($i = 0; $i\
    \ < $n; $i++) {\n        $pile[$i] = $n % 2 == 0 ? $i+1 : $i+2;\n        $n /=\
    \ 2;\n    }\n    return $pile;\n}\n", "    $pile = array();\n    $pile[0] = $n;\n\
    \    for ($i = 1; $i <= $n; $i++) {\n        if ($n % 2 == 1) {\n            $pile[$i]\
    \ = $pile[$i - 1];\n        } else {\n            $pile[$i] = $pile[$i - 1] +\
    \ $pile[$i - 2];\n        }\n    }\n    return $pile;\n}\n", "\tassert(is_integer($n)\
    \ && $n > 0);\n\t$r = array();\n\tif ($n & 1) {\n\t\t$r[] = $n;\n\t}\n\twhile\
    \ ($n > 0) {\n\t\t$t = $n & ~1;\n\t\tif ($n & 1) {\n\t\t\t$r[] = $t;\n\t\t} else\
    \ {\n\t\t\t$r[] = ($t + $n) / 2;\n\t\t}\n\t\t$n = $t;\n\t}\n\treturn $r;\n}\n",
  "    $pile = array();\n    $pile[$n] = $n;\n    for($i = 1; $i <= $n; $i++) {\n\
    \        $n = 2 * $n + $i % 2 == 0 ? $i % 2 : -$i % 2;\n        $pile[$i] = $pile[$n\
    \ - 1];\n    }\n    return $pile;\n}\n", "    $array = [];\n    $array[] = $n;\n\
    \    for($i = 1; $i < $n; $i++) {\n        $array[] = ceil($n / 2);\n        $n\
    \ = $n % 2;\n    }\n    return $array;\n}\n", "    $pile = array();\n    $stones\
    \ = $n;\n    $pile[] = $stones;\n    if ($n % 2 === 0) {\n        for ($i = 1;\
    \ $i <= $n; $i++) {\n            $stones = $stones - $i + $i;\n            $pile[]\
    \ = $stones;\n        }\n    } else {\n        for ($i = 1; $i <= $n; $i++) {\n\
    \            $stones = $stones - $i + $i;\n            $pile[] = $stones;\n  \
    \      }\n    }\n\n    return $pile;\n}\n", "    $n = $n - 1;\n    $pile = array();\n\
    \    $pile[$n] = $n;\n    $count = 0;\n    for ($i = 1; $i <= $n; $i++) {\n  \
    \      $count = $count + $pile[$i];\n        $pile[$i] = $count % 2 == 0 ? $count\
    \ + 1 : $count;\n    }\n    return $pile;\n}\n", "    if ($n == 0)\n        return\
    \ array(0);\n    if ($n & 1)\n        $n++;\n    $a = make_a_pile($n - 1);\n \
    \   $a[] = $n % 2 ? $a[0] + $a[1] : $a[1] + $a[0];\n    return $a;\n}\n", "  \
    \  return array_fill(0, $n, $n%2==0 ? $n+1 : $n);\n}", "  $arr = array();\n  for\
    \ ($i = 1; $i <= $n; $i += 2) {\n    $arr[] = $i;\n  }\n  return $arr;\n}\n",
  "    $arr = [];\n    for ($i = 0; $i < $n; $i++) {\n        if ($i % 2 === 0) {\n\
    \            $arr[] = 2*$i;\n        } else {\n            $arr[] = $i;\n    \
    \    }\n    }\n    return $arr;\n}\n$arr = make_a_pile(3);\nprint_r($arr);\n",
  "    $a = array();\n    $count = 0;\n    if ($n > 0) {\n        $a[] = $n;\n   \
    \     $count = $n;\n    }\n    while ($count > 0) {\n        if ($count & 1) {\n\
    \            $a[] = ceil($count / 2);\n        } else {\n            $a[] = floor($count\
    \ / 2);\n        }\n        $count /= 2;\n    }\n    return $a;\n}", "    $pile\
    \ = array();\n    $pile[0] = $n;\n    $pile[count($pile) - 1] = ($n % 2 == 0)\
    \ ? $pile[count($pile) - 1] : $pile[count($pile) - 1] * 3;\n    return $pile;\n\
    }\n", "  if ($n <= 0) {\n    return 0;\n  }\n  $s = array();\n  $n = $n % 2;\n\
    \  for ($i = 1; $i <= $n; $i++) {\n    if ($i % 2 === 0) {\n      $s[] = $i;\n\
    \    } else {\n      $s[] = ($i + 1);\n    }\n  }\n  return $s;\n}\n", "    $n\
    \ = $n * 2;\n    $s = floor($n / 2);\n    return array_fill(0, $n, $s);\n}\n",
  "\t$nums = array();\n\tif ($n == 1)\n\t\t$nums[] = 1;\n\telseif ($n % 2 != 0) {\n\
    \t\t$nums[] = $n / 2;\n\t\t$n--;\n\t}\n\twhile ($n > 0) {\n\t\tif ($n % 2 == 0)\n\
    \t\t\t$nums[] = $n / 2;\n\t\t$n--;\n\t}\n\treturn $nums;\n}", "    $num = $n %\
    \ 2;\n    if($num == 0) {\n        return array($n);\n    }\n    $res = make_a_pile($n/2);\n\
    \    $res[$n%2] = $n%2 + 1;\n    return $res;\n}\n", "    $pile = array();\n \
    \   $i = 1;\n    while ($i <= $n) {\n        $pile[] = $i;\n        if ($i % 2\
    \ == 0) {\n            $i++;\n        } else {\n            $i += $i % 2 == 1\
    \ ? $i + 1 : $i + 1;\n        }\n    }\n    return $pile;\n}\n", "    $stones\
    \ = array($n);\n    $n++;\n    while ($n) {\n        $n = $n % 2 ? $n : $n * 3\
    \ / 2;\n        $stones[] = $n;\n    }\n    return $stones;\n}\n</code>\n<code>",
  "    if (!is_int($n)) {\n        throw new InvalidArgumentException(\"$n must be\
    \ an integer.\");\n    }\n    if ($n < 1) {\n        throw new InvalidArgumentException(\"\
    $n must be positive.\");\n    }\n    if (is_int($n & 1)) {\n        return array_fill(0,\
    \ $n + 1, $n + 1);\n    }\n    return array_fill(0, $n + 1, $n);\n}", "  $a =\
    \ [];\n  for ($i = 0; $i < $n; $i++) {\n    $a[] = $i + 1;\n    $a[$i % 2] +=\
    \ $i / 2 > $n / 2 ? 1 : 2;\n  }\n  return $a;\n}\n", "    $result = array();\n\
    \    // add the first level of stones\n    $result[] = ($n % 2 == 0) ? $n : $n\
    \ + 1;\n    // find the next odd or even number\n    $next = ($n % 2 == 0) ? $n\
    \ : $n + 1;\n    // find the number of stones in the next level\n    $result[++$next]\
    \ = ($next % 2 == 0) ? $next : $next + 1;\n    $result[$n + 1] = $n;\n    return\
    \ $result;\n}\n</code>\n<|/ a tags=php,arrays |>\n<| c |>\nWhat about a case where\
    \ n is odd? e.g. $n=3\n<|/ c |>\n<| a dscore=1 |>\nThis seems to do what you're\
    \ after, though I haven't tested it extensively.\n<code>", "    return make_a_pile_helper($n,\
    \ 1, 1);\n}\n", "  $stone_array = [];\n  if ($n == 1) {\n    $stone_array[] =\
    \ 1;\n  }\n  for ($i = 1; $i <= $n; $i++) {\n    if ($n % 2 == 0) {\n      $stone_array[]\
    \ = $stone_array[$i - 1];\n      $stone_array[] = ($stone_array[$i - 1] + $stone_array[$i\
    \ - 1]) / 2;\n    } else {\n      $stone_array[] = $stone_array[$i - 1];\n   \
    \   $stone_array[] = ($stone_array[$i - 1] + $stone_array[$i - 1] + 1) / 2;\n\
    \    }\n  }\n  return $stone_array;\n}\n", "  $arr = array();\n  for ($i = 0;\
    \ $i < $n; $i++) {\n    $arr[$i + 1] = floor($n / 2);\n    $n = $n % 2;\n  }\n\
    \  return $arr;\n}\n", "    if ($n < 1) {\n        return null;\n    }\n\n   \
    \ $array = array();\n    for ($i = 0; $i < $n; $i++) {\n        $array[] = (int)($n\
    \ / 2);\n        $n = $n % 2;\n    }\n\n    return $array;\n}\n", "    $levels\
    \ = array();\n    for ($i = 0; $i < $n; $i += 2) {\n        $levels[] = $n;\n\
    \    }\n    return $levels;\n}\n", "    $result = [];\n    if ($n == 1) {\n  \
    \      $result[] = 1;\n        return $result;\n    }\n    for ($i = 2; $i <=\
    \ $n; $i += 2) {\n        $result[] = $i;\n    }\n    return $result;\n}\n", " \
    \   if ($n < 1) {\n        return array();\n    }\n    if ($n == 1) {\n      \
    \  return array($n);\n    }\n    if ($n % 2 == 0) {\n        $next = (int) ($n\
    \ / 2);\n        $even = make_a_pile($next);\n        return $even + array($next);\n\
    \    }\n    $next = (int) ($n / 2) + 1;\n    $odd = make_a_pile($next);\n    return\
    \ $even + $odd;\n}\n", "    $a = array(1);\n    for ($i = 1; $i <= $n; $i++) {\n\
    \        if ($i % 2 == 0) {\n            $a[$i] = $a[$i - 1] + $a[$i - 2];\n \
    \       } else {\n            $a[$i] = $a[$i - 1];\n        }\n    }\n    return\
    \ $a;\n}\n</code>\n<|/ a tags=php,algorithm |>\n<| c |>\nThanks, this is what\
    \ I was looking for, even though this seems like a pretty poor solution (a lot\
    \ of code for a relatively simple problem).\n<|/ c |>\n<| a tags=php,algorithm\
    \ dscore=2 |>\nHere is the recursive version (PHP >= 5.3 needed):\n<code>\n$stones\
    \ = 3;\n$pile = array();\n$pile[] = $stones;\n\n$numStones = count_pile($pile,\
    \ 0);\n", "    $pile = [];\n    if ($n % 2 == 1) {\n        // even\n        for\
    \ ($i = 1; $i < $n; $i += 2) {\n            $pile[] = $i;\n        }\n    } else\
    \ {\n        // odd\n        for ($i = 1; $i < $n; $i += 2) {\n            $pile[]\
    \ = $n - $i;\n        }\n    }\n\n    return $pile;\n}\n</code>\n<|/ a |>\n<|\
    \ a dscore=2 |>\nHere's a solution without recursion. \n<code>", "    $result\
    \ = array();\n    if ($n == 0) return $result;\n    if ($n%2 == 0) $result[] =\
    \ $n/2;\n    $result[] = $n;\n    $n = $n-1;\n    if ($n%2 == 0) $result[] = $n/2;\n\
    \    return $result;\n}", "    $pile = array();\n    $num = 1;\n    if ($n ===\
    \ 0) {\n        return $pile;\n    }\n    $pile[] = $n;\n    $num = 1;\n    for\
    \ ($i = 1; ($i < $n); $i++) {\n        if (($i % 2 === 0) || ($i === $n)) {\n\
    \            $pile[$i-1] += $num;\n        }\n        else {\n            $pile[$i-1]\
    \ += 2 * $num;\n        }\n        $num++;\n    }\n    return $pile;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nI like your solution but it does not work for n=3\
    \ in this case.  It returns an array of 0 instead of 1.  If you change the last\
    \ line to `return $pile;` it will work.\n<|/ c |>\n<| c |>\n: Thanks for pointing\
    \ that out. I've edited my answer.\n<|/ c |>\n<| c |>\nThe only difference with\
    \ this answer is how I find the even number. That's pretty cool.\n<|/ c |>\n<|\
    \ c |>\nYeah, I've been trying to keep it simple to keep it close to your original\
    \ approach. I haven't thought about using the remainder operator on the odd numbers.\n\
    <|/ c |>\n<| a tags=php |>\nHere's an idea I had:\n<code>\n$a[] = array(0, 0);\n\
    $a[1][0] = 1;\nfor ($i=2;$i<=4;$i+=2)\n    $a[1][$i+1] = $a[1][$i]*2;\n$a[2][0]\
    \ = 1;\nfor ($i=3;$i<=8;$i+=2)\n    $a[2][$i+1] = $a[2][$i]*2;\n$a[3][0] = 1;\n\
    for ($i=4;$i<=16;$i+=2)\n    $a[3][$i+1] = $a[3][$i]*2;\n$a[4][0] = 1;\nfor ($i=5;$i<=32;$i+=2)\n\
    \    $a[4][$i+1] = $a[4][$i]*2;\n$a[5][0] = 1;\nfor ($i=6;$i<=64;$i+=2)\n    $a[5][$i+1]\
    \ = $a[5][$i]*2;\n$a[6][0] = 1;\nfor ($i=7;$i<=128;$i+=2)\n    $a[6][$i+1] = $a[6][$i]*2;\n\
    $a[7][0] = 1;\nfor ($i=8;$i<=256;$i+=2)\n    $a[7][$i+1] = $a[7][$i]*2;\n$a[8][0]",
  "    $num_stones = array();\n    if ($n % 2 == 0) {\n        $num_stones[] = $n;\n\
    \        return $num_stones;\n    }\n    // $num_stones[] is the number of stones\
    \ in level 1\n    $num_stones[] = $n / 2;\n    $num_stones = make_a_pile($num_stones[0]);\n\
    \    if ($n % 2 == 1) {\n        // odd number of stones means we need the next\
    \ even number\n        $num_stones[] = $n / 2;\n    }\n    return $num_stones;\n\
    }\n", "    // Write your code here\n    if (is_integer($n)) {\n        if ($n\
    \ % 2 === 0) {\n            return array($n);\n        } else {\n            return\
    \ array($n - 1, $n * 2);\n        }\n    } else {\n        return array();\n \
    \   }\n}\nprint_r(make_a_pile(3));\n", "    $ret=array();\n    for($i=0; $i<$n;\
    \ $i++) {\n        if ($n%2==0) {\n            $ret[]=$i+1;\n            $ret[]=count($ret);\n\
    \        } else {\n            $ret[]=count($ret);\n        }\n    }\n    return\
    \ $ret;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks for your answer. The problem\
    \ with this solution is that it doesn't return the number of stones of each level.\
    \ For example, for make_a_pile(3): array(3,5,7); it must return array(3, 5, 7);\
    \ The first level has 3 stones.\n<|/ c |>\n<| c |>\nThanks again. You are correct,\
    \ I've modified my answer to reflect this :)\n<|/ c |>\n<| c |>\nI noticed that\
    \ your solution returns the first level even if it is not even. This might be\
    \ fine if there are no more levels, but if there are, it won't work. I modified\
    \ my solution to reflect this issue. Thanks again for your help :)\n<|/ c |>\n\
    <| c |>\nI changed my solution to reflect that issue. Thank you again!\n<|/ c\
    \ |>\n<| c |>\nGreat! I'm glad you found it useful.\n<|/ c |>\n<| a |>\nThis solution\
    \ should work (using PHP >= 5.4):\n<code>", "    if ($n < 1 || $n % 2 == 0) {\n\
    \        return array();\n    }\n\n    $a = array();\n    $a[0] = $n;\n\n    for\
    \ ($i = 1; $i < $n; $i++) {\n        $next = $i * 2 + 1;\n        $a[$i] = isset($a[$next])\
    \ ? $a[$next] : $next;\n    }\n    return $a;\n}\n", "    $counts = array();\n\
    \    $counts[$n] = 1;\n    for ($i = 1; $i <= $n; ++$i) {\n        if ($i % 2\
    \ == 0) {\n            $counts[$i] = $counts[$i - 1] + $counts[$i / 2];\n    \
    \    } else {\n            $counts[$i] = $counts[$i - 1] + $counts[$i / 2];\n\
    \        }\n    }\n    return $counts;\n}\n", "    $result = array(0);\n    $count\
    \ = 1;\n    $result = array_merge($result, make_level($n, $count));\n    return\
    \ $result;\n}\n", "    $pile = [1 => $n];\n    while ($n > 0) {\n        if ($n\
    \ % 2 == 0) {\n            $n = $n / 2;\n        } else {\n            $n = $n\
    \ * 3 + 1;\n        }\n        $pile[] = $n;\n    }\n    return $pile;\n}\n",
  "    $array = [];\n    for ($i = 1; $i <= $n; $i++) {\n        $array[] = $i;\n\
    \        if ($n % 2 == 0) {\n            $array[] = ($i + 1);\n        }\n   \
    \     if ($i % 2 == 1) {\n            $array[] = ($i * 2);\n        }\n    }\n\
    \    return $array;\n}\n", "    $pile = $n=3; for ($x=1; $x<=$n; $x+=2) {\n  \
    \      $pile += $n=$x; for ($y=1; $y<=$n; $y+=2) {\n            $pile += $n=$y;\
    \ for ($z=1; $z<=$n; $z+=2) {\n                $pile += $n=$z; for ($w=1; $w<=$n;\
    \ $w+=2) {\n                    $pile += $n=$w;\n                }\n         \
    \   }\n        }\n    }\n    return $pile;\n}\n", "    $n = abs($n);\n    $result\
    \ = array();\n    $p = 0;\n    $p = $n % 2 == 0 ? $p + 1 : $p;\n    while($n>0)\
    \ {\n        $result[$n] = $p;\n        $n = $n % 2 == 0 ? $n/2 : 2*$n + 1;\n\
    \        $p = $n % 2 == 0 ? $p + 1 : $p;\n    }\n    return $result;\n}\n", " \
    \ $stones = array();\n  if ($n % 2 == 0) $stones[] = $n;\n  for ($i = 1; $i <=\
    \ $n; $i += 2) {\n    if ($i % 2 == 0) $stones[] = $i;\n  }\n  return $stones;\n\
    }", "    if ($n == 0) {\n        return array(0);\n    }\n    if ($n > 0) {\n\
    \        $pile = array($n);\n        $pittle = make_a_pile($n % 2 == 0 ? $n -\
    \ 1 : $n - 1);\n        return array_merge($pile, array($n / 2));\n    } else\
    \ {\n        return array();\n    }\n}\n</code>\n<|/ a tags=php,recursion |>\n\
    <| c |>\ni like the idea of returning an array, but how do you handle negative\
    \ numbers?\n<|/ c |>\n<| c |>\nThe code will work fine as long as `n` is positive.\
    \ If `n` is negative, the code will produce an incorrect result.\n<|/ c |>\n<|\
    \ c |>\nIf `n` is negative, `make_a_pile` returns an empty array. The caller should\
    \ probably treat that as a special case; return `NULL` if `n` is negative, otherwise,\
    \ `make_a_pile` should return an array containing the correct number of `0` elements.\n\
    <|/ c |>\n<| c |>\nThe code works in Python too :)\n<|/ c |>\n<| c |>\nYes, that's\
    \ true. It just seems a bit pointless to treat negative numbers as special cases\
    \ in that case, since it's not what the user asked for. I guess the user should\
    \ just do something like `if ($n < 0) return NULL;` instead of using negative\
    \ numbers in any case.\n<|/ c |>\n<| a |>\nFor people looking for a recursive\
    \ solution in Ruby:\n<code>\ndef pilenumber(n)\n  return [(n+1)] if n.odd? &&\
    \ n != 0\n  (n/2).times.map { |p| pilenumber(n-p).inject(:+) }\nend\n</code>\n\
    <|/ a dscore=4 tags=php,recursion |>\n<| c |>\nThanks David. This is exactly what\
    \ I was looking for.\n<|/ c |>\n<| c |>\nI was looking for this exactly, and since\
    \ I'm new to Ruby I came up with the following in Python: `def pilenumber(n):\n\
    \    if n < 1:\n        return []\n    if n.is_integer() and n > 1:\n        return\
    \ pilenumber(n-1) + [(n+1)]\n    else:\n        return [(n - 1)] + pilenumber(n-1)`\n\
    <|/ c |>\n<| c |>\n`return [(n - 1)] + pilenumber(n-1)` this line will cause recursion\
    \ infinite loop. Because `pilenumber(n-1)` will call `pilenumber(n-1)` again and\
    \ again and again", "    $n2 = ($n % 2 == 0) ? $n : ( $n + 1 );\n    $count =\
    \ [$n];\n    for ($i = 2; $i <= $n2; $i+=2) {\n        $count[] = $i;\n    }\n\
    \    return $count;\n}\n", "    $pile = array();\n    if ($n % 2 == 0) {\n   \
    \     $pile[0] = $n / 2;\n    } else {\n        $pile[0] = $n / 2 + 1;\n    }\n\
    \    for ($i = 1; $i < $n; $i++) {\n        if ($i % 2 == 0) {\n            $pile[$i]\
    \ = $pile[$i - 1] + $i;\n        } else {\n            $pile[$i] = $pile[$i -\
    \ 1] + 2 * $i;\n        }\n    }\n    return $pile;\n}\n</code>\nFor instance,\
    \ if n = 5, make_a_pile(5) gives us\n<code>\narray(\n    0 => 5,\n    1 => 12,\n\
    \    2 => 25,\n    3 => 41,\n    4 => 60,\n);\n</code>\n<|/ a tags=math,php |>\n\
    <| c |>\nI don't think this is what the OP wants. I think he wants to know how\
    \ many levels there are in a pile\n<|/ c |>\n<| c |>\nI thought that was how he\
    \ wrote his question but just looked at the code... I will amend this answer with\
    \ how to solve this problem.\n<|/ c |>\n<| c |>\nThis is very close to what I\
    \ am looking for.  I added a for loop to return the number of levels in the array.\
    \  The only problem is it is returning the number of levels in the array instead\
    \ of number of stones per level.\n<|/ c |>\n<| c |>\nAh, sorry I missed that detail.\
    \ Can you show us an example of input and output?\n<|/ c |>\n<| c |>\nI added\
    \ an example of input/output above.\n<|/ c |>\n<| a tags=math,php |>\nThis is\
    \ similar to the code you already have, but I made some small changes in your\
    \ code:\n<code>\n$n = $_POST[\"n\"];\n\n$pile = make_a_pile($n);\n\n$count1 =\
    \ 0;\n$count2 = 0;\n\nfor ($i = count($pile); $i >= 1; $i--){\n    if ($pile[$i\
    \ - 1] % 2 != 0){\n        $count1 += $i;\n    } else {\n        $count2 += $i;\n\
    \    }\n}\n\n$result = array($count1, $count2);\n\nprint_r($result);\n</code>\n\
    Explanation: I start counting how many stones there are in the first level. After\
    \ that, start counting how many stones are in the next level. I keep track of\
    \ how many stones are in each level.\n<|/ a dscore=0 |>\n<| c |>\nThank you for\
    \ your help.  I am getting a syntax error on line 9 that says \"unexpected $\"\
    \ on the '[' and \"]\"\n<|/", "    $ret = [1];\n    for ($i = 1; $i <= $n; $i++)\
    \ {\n        $ret[$i] = $ret[$i - 1];\n        if ($n % 2) {\n            $ret[$i]\
    \ = $ret[$i] + 1;\n        } else {\n            $ret[$i] = $ret[$i] + 2;\n  \
    \      }\n        $n = $n >> 1;\n    }\n    return $ret;\n}\n", "    $levels=array($n);\n\
    \    for ($i=1; $i<$n; $i++) {\n        $levels[$i]=$levels[$i-1]+($i&1)?$i:$i-1;\n\
    \    }\n    return $levels;\n}\n", "    $pile = [];\n    $prev = $n = intval($n);\n\
    \    while ($n--) {\n        if ($n % 2 === 0) {\n            $pile[] = $n;\n\
    \        } else {\n            if ($prev % 2 === 0) {\n                $pile[]\
    \ = $prev;\n            }\n            $prev = $prev * 2 + 1;\n        }\n   \
    \ }\n    return $pile;\n}\n", "    $pile = array();\n    $first_level = 1;\n \
    \   $levels = array();\n    \n    if ($n % 2 == 0) {\n        for ($i = 0; $i\
    \ < $n; $i++) {\n            if ($i % 2 == 0) {\n                $pile[$i] = $first_level;\n\
    \                $first_level++;\n            } else {\n                $pile[$i]\
    \ = $levels[$i-1];\n            }\n        }\n    } else {\n        for ($i =\
    \ 0; $i < $n; $i++) {\n            if ($i % 2 == 0) {\n                $pile[$i]\
    \ = $first_level;\n                $first_level++;\n            } else {\n   \
    \             $levels[] = $pile[$i-1];\n                $pile[$i] = $levels[$i-1];\n\
    \            }\n        }\n    }\n    return $pile;\n}\n", "    return array_fill(0,\
    \ $n, 0);\n}\n", "    // Odd case: even\n    if ($n % 2 == 0) {\n        return\
    \ array($n);\n    }\n    // Even case: odd\n    return array(\n        ($n % 2)\
    \ ? $n : (int) ($n / 2) + 1,\n        (int) ($n / 2) + 1,\n    );\n}\n\n/**\n\
    \ * You are given a string that represents a mathematical expression. Write a\
    \ program to\n * evaluate this expression.\n * \n * Each character in the string\
    \ represents one of the operations (+, -, *, /)\n * \n * You should assume that\
    \ the string will only contain one operation, i.e.: \n *   + for addition\n *\
    \   - for subtraction\n *   * for multiplication\n *   / for division\n * \n *\
    \ You can assume the input string contains only integers\n * \n * For example\
    \ \"6+4*3\" should yield (10).\n * \n * Write a function to evaluate the given\
    \ expression\n * \n * EXAMPLE:\n * \n * >>> evalExpression(\"6+4*3\")\n * 10\n\
    \ * >>> evalExpression(\"6+4*3/2-6\")\n * 8\n * \n * Your code should pass these\
    \ tests:\n * \n * >>> assert(evalExpression(\"6+4*3\")==10)\n * >>> assert(evalExpression(\"\
    6+4*3/2-6\")==8)\n * >>> assert(evalExpression(\"3+2*5\")==7)\n */", "    $arr\
    \ = array();\n    while ($n>0) {\n        if ($n%2 === 0) {\n            $arr[]\
    \ = $n;\n            $n = n/2;\n        } else {\n            $arr[] = ($n*2+1);\n\
    \            $n = $n*2;\n        }\n    }\n    return $arr;\n}\n", "    $arr =\
    \ array();\n    for ($i = 0; $i < $n; $i++) {\n        $arr[$i] = $i + ($i % 2\
    \ == 0 ? 0 : 1);\n    }\n    return $arr;\n}\n", "    $pile = array();\n    for($i\
    \ = 0; $i < $n; $i++) {\n        $pile[] = $i + 1;\n    }\n    return $pile;\n\
    }", "  if ($n === 0) {\n    return array(0);\n  }\n\n  $pile = array(1);\n  if\
    \ ($n % 2) {\n    $pile[] = $pile[$n - 1];\n  }\n  $next_odd = floor($n / 2);\n\
    \  for ($i = 1; $i < $next_odd; $i++) {\n    $pile[] = $pile[$n - $i] + $pile[$n\
    \ - $i - 1];\n  }\n\n  $next_even = floor($n / 2);\n  for ($i = 1; $i < $next_even;\
    \ $i += 2) {\n    $pile[] = $pile[$n - $i] + $pile[$n - $i - 1];\n  }\n\n  return\
    \ $pile;\n}\n</code>\nNow that I have the code for this function, we can now use\
    \ it:\n<code>\n$pile = make_a_pile(20);\nprint_r($pile);\n</code>\nWhich yields:\n\
    <code>\nArray\n(\n    [0] => 3\n    [1] => 5\n    [2] => 7\n    [3] => 11\n  \
    \  [4] => 13\n    [5] => 17\n    [6] => 21\n    [7] => 23\n    [8] => 29\n   \
    \ [9] => 31\n    [10] => 37\n    [11] => 41\n    [12] => 49\n    [13] => 55\n\
    \    [14] => 59\n    [15] => 61\n    [16] => 67\n    [17] => 71\n    [18] => 77\n\
    \    [19] => 81\n)\n</code>\nThis looks pretty good so far, so we can implement\
    \ it into our solution:\n<code>", "  $levels = array();\n  \n  for($i = 1; $i\
    \ <= $n; $i++) {\n    if($i % 2 == 0) {\n      $levels[] = $i;\n    }\n    else\
    \ {\n      $levels[] = $i + $levels[$i-1];\n    }\n  }\n  return $levels;\n}",
  "    $ans = array();\n    $first = $n - 1;\n    $last = floor($n / 2);\n    for\
    \ ($i = $first; $i <= $last; $i++) {\n        if ($n % 2 == 0) {\n           \
    \ $ans[] = $i;\n            $n = $n / 2;\n        } else {\n            $ans[]\
    \ = 2 * $i;\n            $n = $n / 2;\n        }\n    }\n    return $ans;\n}\n",
  "    $pile = array();\n    for($i = 0; $i < $n; $i++) {\n        $pile[$i] = ($i\
    \ % 2 == 0) ? $i + 1 : $i;\n    }\n    return $pile;\n}\n", "    $pile = array(0\
    \ => 1);\n    $next_odd = 0;\n    $next_even = 0;\n    for ($i = 1; $i < $n; ++$i)\
    \ {\n        $next_odd = $next_odd + ($i % 2 ? $pile[$next_even]+1 : $pile[$next_even]);\n\
    \        $next_even = $next_even + ($i % 2 ? 0 : 1);\n        $pile[$i+1] = $next_odd\
    \ + $next_even;\n    }\n    return $pile;\n}\n</code>\n<|/ a tags=php,math,algorithm\
    \ dscore=0 |>\n<| a |>\nHere is my solution, no loops or anything :)\n<code>",
  "  $stones = array();\n  for ($i = 0; $i < $n; $i++) {\n    $stones[$i] = ($i %\
    \ 2 == 0) ? ($i + 1) : $i;\n  }\n  return $stones;\n}\n", "    $counts = array();\n\
    \    for ($i = 0; $i < $n; ++$i) {\n        $counts[] = $i + 1;\n    }\n    for\
    \ ($i = $n - 1; $i >= 0; --$i) {\n        $counts[] = $i % 2 == 0 ? $counts[($i\
    \ + 1) & ~1] : $counts[$i];\n    }\n    return $counts;\n}\n", "  if ($n % 2 ==\
    \ 0) {\n    return make_a_pile($n / 2) + 1;\n  } else {\n    return make_a_pile($n\
    \ / 2) + 0;\n  }\n}\n", "    $result = [];\n    for ($i = 0; $i < $n; $i++) {\n\
    \        $result[] = ($i % 2 == 0) ? $i + 1 : $i + 2;\n    }\n    return $result;\n\
    }\n", "    if (!is_int($n) || $n < 1) return null;\n    if ($n & 1) return 2 *\
    \ $n + 1;\n    return 2 * $n + 2;\n}\n</code>\nThis code has been tested using\
    \ PHP 5.5.9.\n<|/ a tags=php |>\n<| a tags=php |>\nThis solution uses a while\
    \ loop to continuously add stones until we have an odd number of stones:\n<code>",
  "    $pile = array();\n    $i = 0;\n    do {\n        $pile[$i] = $n;\n        $n\
    \ = ($n+1) % 2;\n        $i++;\n    } while ($n);\n    return $pile;\n}\n", " \
    \   $array = [];\n    for ($i = 1; $i <= $n; $i++) {\n        if ($i % 2 === 0)\
    \ {\n            $array[$i-1] += $i;\n        } else {\n            $array[$i-1]\
    \ += $i+1;\n        }\n    }\n    return $array;\n}\n", "    $stones = array($n);\
    \ \n    for ($i=1; $i<=$n; $i++) {\n        $stones[] = $i % 2 ? $stones[$i/2]\
    \ + $stones[$i/2+1] : $stones[$i/2]; \n    }\n    return $stones;\n}\n", "   \
    \ $result = array();\n    // If $n is even, there is nothing to do.\n    if ($n\
    \ % 2) {\n        return $result;\n    }\n    // If $n is odd, add the number\
    \ of levels with odd number of stones.\n    // Otherwise add the number of levels\
    \ with even number of stones.\n    $result[] = ($n + 1) + (2 * $n - 1);\n    //\
    \ While there are unused stones in the pile:\n    while ($n > 0) {\n        //\
    \ If $n is odd, subtract one from the number of levels with odd number of stones.\n\
    \        // Otherwise subtract one from the number of levels with even number\
    \ of stones.\n        $result[] = ($n % 2 ? ($n - 1) : ($n - 1));\n        $n\
    \ = $n / 2;\n    }\n    return $result;\n}\n\n/**\n * Calculate the least common\
    \ multiple of the given numbers\n *\n * @param $x int|array|float\n * @return\
    \ int|null\n */", "    sort($n);\n    $n1 = $n[1];\n    $n2 = $n[2];\n    $n3\
    \ = $n[3];\n    $n4 = $n[4];\n    if ($n1 % 2 == 1) {\n        return array($n3,\
    \ $n4, $n1);\n    } else {\n        return array($n4, $n2, $n3);\n    }\n}\n",
  "  $pile = array($n);\n  for($i = 1; $i <= $n; $i++) {\n    if ($n % 2 == 1) {\n\
    \      array_push($pile, 2 * $i);\n    } else {\n      array_push($pile, 2 * $i\
    \ + 1);\n    }\n  }\n  return $pile;\n}\n", "  $res = array($n);\n  if ($n % 2)\
    \ {\n    $res[] = ($n % 2) + 1;\n  }\n  return $res;\n}\n", "    $pile = array();\n\
    \    for ($i = 0; $i < $n; $i += 2) {\n        $pile[] = $n;\n    }\n    return\
    \ $pile;\n}\n", "    $arr=[];\n    for($i=0; $i<$n; $i++) {\n        $arr[$i]=intval($i%2==0)\
    \ ? ($i+1) : (intval($i/2+1));\n    }\n    return $arr;\n}\n</code>\n<|/ a tags=php,function\
    \ |>\n<| c |>\nWhy use intval($i/2+1) instead of $i+1?\n<|/ c |>\n<| c |>\nThis\
    \ is because in php integer division always rounds down. Thus when $i is even,\
    \ `$i/2` equals zero. Thus, it must be `+1` instead of just `+`.\n<|/ c |>\n<|\
    \ a dscore=3 |>\n<code>", "  $pile = array();\n  if ($n == 0) return $pile;\n\
    \  $even = $n % 2 == 0;\n  $nextEven = $even? $n: $n / 2;\n  $nextOdd = !$even?\
    \ $n: $n / 2;\n  if ($nextOdd > $nextEven) {\n    $pile[$nextOdd + 1] = make_a_pile($nextEven);\n\
    \    $pile[$nextEven] = make_a_pile($nextOdd - 1);\n  } else {\n    $pile[$nextEven]\
    \ = make_a_pile($nextOdd - 1);\n    $pile[$nextOdd + 1] = make_a_pile($nextEven);\n\
    \  }\n  return $pile;\n}\n", "  $pile = array();\n  $n = abs($n);\n  if ($n %\
    \ 2) {\n    $pile[] = $n / 2;\n  }\n  for ($i = 1; $i < $n; $i += 2) {\n    $pile[]\
    \ = $i + 1;\n  }\n  return $pile;\n}", "    if ($n <= 0) return array();\n   \
    \ $ret = array($n); // first level has $n stones\n    for ($i=1; $i<=$n; $i++)\
    \ {\n        $next = $i%2;\n        $ret[$i-1] += $next;\n    }\n    return $ret;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a tags=php,arrays |>\n<code>\n<?php\n\n    $arr\
    \ = array();\n\n    $arr[0] = 3; $arr[1] = 4; $arr[2] = 5; $arr[3] = 6; $arr[4]\
    \ = 7;\n    $arr[5] = 8; $arr[6] = 9; $arr[7] = 10; $arr[8] = 11; $arr[9] = 12;\n\
    \    $arr[10] = 13; $arr[11] = 14; $arr[12] = 15; $arr[13] = 16; $arr[14] = 17;\n\
    \    $arr[15] = 18; $arr[16] = 19; $arr[17] = 20; $arr[18] = 21; $arr[19] = 22;\n\
    \    $arr[20] = 23; $arr[21] = 24; $arr[22] = 25; $arr[23] = 26; $arr[24] = 27;\n\
    \    $arr[25] = 28; $arr[26] = 29; $arr[27] = 30; $arr[28] = 31; $arr[29] = 32;\n\
    \n    for($i = count($arr); $i >= 1; $i--){\n        if ($arr[$i] % 2 == 0) {\n\
    \            $arr[$i] /= 2;\n            $arr[$i-1] += $arr[$i];\n        }\n\
    \    }\n\n    var_dump($arr);\n</code>\n<|/ a dscore=2 |>\n<| a |>\nTry this one:\n\
    <code>\n<?php\n$arr[0] = 1;\n$arr[1] = 2;\n$arr[2] = 3;\n$arr[3] = 4;\n$arr[4]\
    \ = 5;\n$arr[5] = 6;\n\nfor ($i = 1; $i <= count($arr); $i++) {\n    if ($arr[$i]\
    \ % 2 == 1) {\n        $arr[$i]++;\n    }\n    else {\n        $arr[$i] = $arr[$i]\
    \ - ($arr[$i-1] / 2);\n    }\n}\n\nvar_dump($arr);\n</code>\n<|/ a dscore=1 tags=php,arrays\
    \ |>\n<| a |>\nHere is another approach using array_reduce() :\n<code>\n$arr =\
    \ array(3,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32);\n\
    \n$result = array_reduce($arr,function($prev", "    $pile = array();\n    for\
    \ ($i = 0; $i < $n; ++$i) {\n        $pile[$i] = $i + 1;\n        if ($i % 2 ==\
    \ 1) {\n            $pile[$i] = $pile[$i] * 3;\n        }\n    }\n\n    return\
    \ $pile;\n}\n\n/**\n * Return an array of all combinations of two arrays of equal\
    \ size.\n *\n * @param array $arr1 First array that will be combined\n * @param\
    \ array $arr2 Second array that will be combined\n *\n * @return array\n */",
  "    $result = Array();\n    if ( $n % 2 == 1 ) {\n        $result = Array($n);\n\
    \    } else {\n        $result[0] = make_a_pile($n - 1); // odd n\n        $result[1]\
    \ = make_a_pile($n / 2); // even n\n        if ( $n % 2 == 0 ) {\n           \
    \ $result[1][0] += $result[0][0];\n        }\n    }\n    return $result;\n}\n",
  "    $arr = array();\n    for($i = 0; $i < $n; $i++) {\n        $arr[] = $n + ($i\
    \ % 2 ? $i + 1 : $i);\n    }\n    return $arr;\n}\n\n$input = array();\n\necho\
    \ \"Input : \";\n$input = fgets(STDIN);\nprint_r($input);\necho \"<br/>\";\n\n\
    echo \"Output : \";\n$n = $input[0];\n$arr = make_a_pile($n);\nprint_r($arr);\n\
    echo \"<br/>\";", "  $arr = [];\n  while ($n > 0) {\n    if ($n % 2 == 1) {\n\
    \      $arr[] = $n++;\n    } else {\n      $arr[] = $n += 2;\n    }\n  }\n  return\
    \ $arr;\n}\n", "    $pile = array();\n    for($i = 1; $i <= $n; $i++) {\n    \
    \    $pile[] = ($n & 1 ? $i : $i + 1);\n        $n = ($n >> 1)+1;\n    }\n   \
    \ return $pile;\n}\n", "  $arr = array();\n  $n = (int) $n;\n  $i = 0;\n  while\
    \ ($n > 0) {\n    if ($n % 2) {\n      $arr[$i] = $n;\n      $i += 1;\n    }\n\
    \    $n /= 2;\n  }\n  return $arr;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI\
    \ really like this solution! I will have to study it a little to understand it\
    \ but it works perfectly. Thank you so much!\n<|/ c |>\n<| c |>\nThe only thing\
    \ I see here is that I don't have to create an array to store the pile. This can\
    \ be done much easier with a loop that increments $i by 1 each time. Thank you\
    \ again!\n<|/ c |>\n<| c |>\nYes, you could use a loop to increment `$i`. The\
    \ reason I used `$arr` is to make it clear what element we are dealing with when\
    \ working through the array. I wouldn't use this solution unless I wanted to avoid\
    \ looping.\n<|/ c |>\n<| c |>\nAhhh I see. I actually tried it with a loop but\
    \ I probably did it wrong because I kept getting an error. Thank you!\n<|/ c |>\n\
    <| c |>\nHmm, I'm getting an error where it says that $n cannot be converted to\
    \ an int. Do you know what could be causing that?\n<|/ c |>\n<| a dscore=0 |>\n\
    <code>\n<?php", "    $stones = array();\n    // if n is even or odd, make the\
    \ pile.\n    if ($n % 2 == 0) {\n        $stones[0] = $n;\n        $stones[1]\
    \ = $n;\n        return $stones;\n    }\n    // make an odd number of piles.\n\
    \    for ($i = 1; $i <= $n / 2; $i++) {\n        $stones[$i] = $n;\n    }\n  \
    \  $stones[$n / 2] = $n;\n    return $stones;\n}\n</code>\n<|/ a tags=arrays,algorithm,php\
    \ dscore=2 |>\n<| c |>\nThe question is about an algorithm, not an implementation.\n\
    <|/ c |>\n<| c |>\n- I believe the OP wants to know how to write it in PHP. I'm\
    \ not going to write the code for him because I'm not good at PHP.\n<|/ c |>\n\
    <| a |>\nI would write my own function. Something like this:\n<code>", "    for($i\
    \ = 0; $i < $n; $i++)\n        $pile[$i] = $n % 2 == 0 ? ($i+1) : ($i+2);\n  \
    \  return $pile;\n}", "    $pile = array();\n    if ($n % 2 == 0){\n        $pile[$n]\
    \ = $n;\n    }\n    else {\n        $pile[$n] = ($n - ($n & 1) + 1) + ($n & 1);\n\
    \    }\n    for ($i = 1; $i < $n; $i++){\n        $pile[$i] = ($pile[$i - 1] +\
    \ ($n & 1)) % $n;\n    }\n    return $pile;\n}\n", "  if ($n <= 0) {\n    return\
    \ array(0);\n  }\n  if ($n % 2 == 0) {\n    return array($n, make_a_pile($n -\
    \ 1));\n  }\n  return array(2 * $n, make_a_pile($n - 1));\n}\n", "  $pile = array();\n\
    \  $level = $n;\n  while ($level) {\n    if ($level % 2 == 0) {\n      $pile[]\
    \ = $level;\n      $level = floor($level / 2);\n    } else {\n      $level = ceil($level\
    \ / 2);\n    }\n  }\n  return $pile;\n}\n", "    $pile = array();\n    if ($n\
    \ % 2 == 0) {\n        for ($i = 1; $i <= $n; $i++) {\n            $pile[] = $i;\n\
    \        }\n        return $pile;\n    }\n    for ($i = 1; $i <= $n / 2; $i++)\
    \ {\n        $pile[] = $i;\n    }\n    for ($i = ($n + 1) / 2; $i <= $n; $i++)\
    \ {\n        $pile[] = $i;\n    }\n    return $pile;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nI dont think he is having problem with finding odd or even. He\
    \ is having problem in arranging the pile. Ex: If n = 3 then pile = array(1,3,5).\
    \ Here 1 is at 1, 3 is at 3 and 5 is at 5. He is having problem in arranging it.\n\
    <|/ c |>\n<| c |>\nYeah, I understood his problem a little differently, but I'm\
    \ not sure he understands how to manipulate arrays. I think the most confusing\
    \ part is how to determine the number of stones in the next level. He needs to\
    \ get the next odd or even number.\n<|/ c |>\n<| a tags=arrays,php |>\n<code>\n\
    $array1 = array(3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,55,57,59,61,63,65,67,69,71,73,75,77,79,81,83,85,87,89,91,93,95,97,99);\n\
    $array2 = array(3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,55,57,59,61,63,65,67,69,71,73,75,77,79,81,83,85,87,89,91,93,95,97,99);\n\
    \n$arr1 = array_chunk($array1, 2); // Split array into two (even) parts \n$arr2\
    \ = array_chunk($array2, 2); // Split array into two (even) parts\n", "    $total\
    \ = 1;\n    for ($i = 1; $i < $n; $i = $i + 2) {\n        $total = $total * ($i\
    \ + 1);\n    }\n    return array($total);\n}\n$n = 3;\n$arr = make_a_pile($n);",
  "    $i = 1;\n    $levels = array();\n    while ($i <= $n) {\n        if ($n % 2)\
    \ {\n            $levels[] = $i;\n        }\n        ++$i;\n    }\n    return\
    \ $levels;\n}\n", "    $result = [$n];\n    $nextOdd = $n >> 1;\n    $nextEven\
    \ = 2 * $n >> 1;\n    for($i = 1; $i < $n; $i++) {\n        $even = ($i % 2 ==\
    \ 0);\n        $odd = ($i % 2 == 1);\n        if($even) {\n            $result[$i\
    \ + 1] = $nextEven;\n        }\n        else if($odd) {\n            $result[$i\
    \ + 1] = $nextOdd;\n        }\n        else {\n            $result[$i + 1] = $nextOdd\
    \ + (2 * $nextEven);\n        }\n    }\n    return $result;\n}\n", "  // Odd even\
    \ check\n  if ($n % 2 === 0) {\n    $even = true;\n    $odd = true;\n  } else\
    \ {\n    $even = false;\n    $odd = false;\n  }\n  $arr = array();\n  for ($i\
    \ = 0; $i < $n; $i += 2) {\n    if ($even) {\n      $arr[] = $n - $i;\n    } else\
    \ {\n      $arr[] = $odd - $i;\n    }\n  }\n  return $arr;\n}\n", "    $arr =\
    \ array($n);\n    $nextNum = intval($n / 2);\n    $nextEvenNum = intval($nextNum\
    \ / 2);\n    if ($n % 2 == 0) {\n        $arr[] = $nextNum;\n    } else {\n  \
    \      $arr[] = $nextEvenNum;\n    }\n    return $arr;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nPlease don't use irrelevant and unrelated PHP tags.\n<|/ c |>\n\
    <| a dscore=0 |>\n<code>\n<?php", "  $pile = [];\n  if ($n < 0) return $pile;\n\
    \  if ($n % 2 == 0) {\n    for ($i = 0; $i < $n; $i++) {\n      $pile[$i] = 0;\n\
    \    }\n    return $pile;\n  }\n  for ($i = 0; $i < $n; $i += 2) {\n    $pile[$i]\
    \ = $pile[$i+1] = $n + $i;\n  }\n  return $pile;\n}\n", "    $piles = array();\n\
    \    // Level 1\n    $piles[] = $n;\n    // Level 2\n    $odd = $n % 2;\n    if\
    \ ($odd) {\n        $nextEven = $n - 1;\n    } else {\n        $nextEven = $n\
    \ + 1;\n    }\n    $piles[] = make_a_pile($nextEven);\n    // Level 3\n    $odd\
    \ = $nextEven % 2;\n    if ($odd) {\n        $nextOdd = $nextEven - 1;\n    }\
    \ else {\n        $nextOdd = $nextEven;\n    }\n    $piles[] = make_a_pile($nextOdd);\n\
    \    return $piles;\n}\n", "\t$pile = array();\n\tfor ($i = 0; $i < $n; $i++)\
    \ {\n\t\t$pile[$i] = $i + 1;\n\t\t$pile[$i % 2 == 0 ? 'even' : 'odd'] = $pile[$i\
    \ % 2 == 0 ? 'even' : 'odd'] + $pile[$i >> 1] + 1;\n\t}\n\treturn $pile;\n}\n",
  "    if ($n <= 0) {\n        return [];\n    }\n    return make_a_pile(ceil($n /\
    \ 2)) + [floor($n % 2 == 0 ? $n + 1 : $n) - 1];\n}\n", "    if ($n <= 0) {\n \
    \       return array(0);\n    }\n    $pile = make_a_pile($n / 2);\n    $pile[]\
    \ = $n % 2 == 0 ? $n : 2 * $n - 1;\n    return $pile;\n}", "    $p = [];\n   \
    \ for ($i = 1; $i <= $n; $i++) {\n        if ($i%2 == 1) {\n            $p[$i]\
    \ = $i;\n        } else {\n            $p[$i] = $i+($i+1);\n        }\n    }\n\
    \    return $p;\n}\n", "    $ans = array();\n    for ($i = 0; $i < $n; $i++) {\n\
    \        if ($n % 2 == 0) {\n            $ans[$i+1] = intval($n/2);\n        }\
    \ else {\n            $ans[$i+1] = intval($n*3-1)+1;\n        }\n        $n =\
    \ $ans[$i+1];\n    }\n    return $ans;\n}\n", "    sort($n);\n    $result = [];\n\
    \    for ($i = 0; $i < $n; $i++) {\n        $result[$i] = $n[$i];\n        if\
    \ ($n % 2) {\n            if ($i%2 == 1) {\n                $result[$i] += $n[$i-1];\n\
    \            } else {\n                $result[$i] += $n[$i-1] - $n[$i-2];\n \
    \           }\n        }\n    }\n    return $result;\n}\n</code>\n<|/ a |>\n<|\
    \ c |>\nI really like this. It doesn't require a for loop. Thanks\n<|/ c |>\n\
    <| c |>\nNice recursive solution!\n<|/ c |>\n<| c |>\nThis answer also works on\
    \ some edge cases where you cannot use the recursive function.\n<|/ c |>\n<| a\
    \ |>\nRecursion is a way of thinking about the problem, not the solution. It's\
    \ a way that you can solve problems by breaking them down into smaller problems\
    \ that you solve separately.\nIn your problem, you need to solve a problem of\
    \ the form \"What is the total number of stones in the first level?\" There are\
    \ 3 levels of stones: odd numbers, even numbers, and numbers whose mod is even\
    \ and odd.\nThe answer to the first level is n. The answer to the second level\
    \ is (n-1). The answer to the third level is (n-2).\nIn short, solve the first\
    \ level by summing the odd numbers from 1 to n, the second level by summing the\
    \ even numbers from 1 to n-1, and finally the third level by summing the odd numbers\
    \ from 1 to n-2.\nIn pseudocode:\n<code>\nint stones_in_first_level(n) {\n   \
    \ return n + n * (n-1) + (n-2) * (n-2);\n}\n\nint stones_in_second_level(n) {\n\
    \    return n + n * (n-1) * (n-2);\n}\n\nint stones_in_third_level(n) {\n    return\
    \ n + n * (n-1) * (n-2) * 2;\n}\n</code>\n<|/ a dscore=4 tags=php |>\n<| c |>\n\
    Thanks for the pseudocode. I think this is the best solution.\n<|/ c |>\n<| a\
    \ tags=php dscore=3 |>\nThis is just an alternative solution for people who want\
    \ to keep it simple. \n<code>", "    if ($n < 0 || $n >= 10000) {\n        throw\
    \ new InvalidArgumentException(\"$n is not a positive integer\");\n    }\n   \
    \ // Create a pile of n levels\n    $pile = array();\n    for ($i = 0; $i < $n;\
    \ $i++) {\n        $pile[$i] = ($n % 2 == 0) ? $i * 2 + 1 : $i * 2;\n        //\
    \ Add number of remaining stones to next level\n        $n = $n / 2;\n    }\n\
    \    return $pile;\n}\n", "    if ($n<0) return -1;\n    $p = [];\n    for ($i\
    \ = 1; $i<=n; $i++) {\n        if ($i%2) {\n            $p[$i-1] = $p[$i-1] +\
    \ 1;\n        } else {\n            $p[$i-1] = $p[$i-1];\n        }\n    }\n \
    \   return $p;\n}\n</code>\n<|/ a |>\n<| a tags=algorithm,php dscore=1 |>\nA simple\
    \ one-liner would be\n<code>\n$count = array_sum(array_map(function($n) { return\
    \ $n <= 0 ? -1 : ($n+($n % 2)/2); }, range(1,$n)));\n</code>\n<|/ a |>\n<| a dscore=1\
    \ |>\n<code>\n<?php\n\n$p = (int)$n;\n$q = 1;\n$r = $p;\n$t = 1;\n$u = array(0);\n\
    while ($u[0] < $p) {\n    $t = $u[0] > $p ? $u[0] : $p;\n    array_push($u, $t);\n\
    \    $u[0] += $p & 1;\n    $p >>= 1;\n    $q += $t;\n}\nreturn $q;\n", "    $pile\
    \ = array();\n    if ($n >= 0) {\n        $pile[$n] = $n;\n    }\n    while ($n\
    \ > 1) {\n        $n2 = $n & 1;\n        if ($n2 == 1) {\n            $n >>= 1;\n\
    \        } else {\n            $n >>= 1;\n            $pile[$n] = $n;\n      \
    \  }\n    }\n    return $pile;\n}\n", "    $pile = array();\n    while($n>0) {\n\
    \        if ($n&1) {\n            $pile[] = ($n+1)&1 ? $n+1 : $n;\n        }\n\
    \        ++$n;\n    }\n    return $pile;\n}\n", "    $count = array($n);\n   \
    \ if($n % 2) {\n        $count[] = 2 * $count[0];\n    }\n    foreach(range(1,\
    \ $n-1, 2) as $i) {\n        $count[] = 2 * $count[$i-1];\n    }\n    return $count;\n\
    }\n</code>\nI did it in python, here are some timings for n=10000 (python 3.5.1,\
    \ Ubuntu 16.04):\n<code>\n>>> timeit.timeit(make_a_pile(1000), number=100)\n0.349954496361\n\
    >>> timeit.timeit(make_a_pile(10000), number=100)\n0.550867407642\n>>> timeit.timeit(make_a_pile(100000),\
    \ number=100)\n3.79292433322\n</code>\nand n=100000 (python 3.7.3, Ubuntu 18.04):\n\
    <code>\n>>> timeit.timeit(make_a_pile(1000), number=100)\n0.401137619676\n>>>\
    \ timeit.timeit(make_a_pile(10000), number=100)\n0.702425446826\n>>> timeit.timeit(make_a_pile(100000),\
    \ number=100)\n11.4876652943\n</code>\n<|/ a dscore=4 |>\n<| c |>\nYour code is\
    \ great, just made a couple of changes and it works great. Here are the changes:\
    \ made $n=10000 since my problem was to solve the problem for n=100000 and changed\
    \ the last line to return $count; instead of print_r($count);\n<|/ c |>\n<| c\
    \ |>\nFor n=100000, I'm getting 1.1 sec. and 0.3 sec for n=10000\n<|/ c |>\n<|\
    \ c |>\nThe code I posted is for n=100000, I changed the `if` condition to `if($n\
    \ % 2 == 0)` so you can see better how it works for other even numbers. Btw, the\
    \ python script I posted is for n=10000, I don't have access to a computer with\
    \ n=100000 and my solution is slower than yours.\n<|/ c |>\n<| c |>\nThanks for\
    \ the explanation. This problem was just a fun puzzle for me. :)\n<|/ c |>\n<|\
    \ c |>\nBtw, even though my solution works, I wouldn't recommend it because it\
    \ requires you to write loops, which is very inefficient for python (although\
    \ it is possible with list comprehensions). I would suggest you stick to loops.\n\
    <|/ c |>\n<| a tags=php |>\n<code>\n<?php\n$num = 12345;\n", "    $levels = [];\n\
    \    $levels[] = $n;\n    $last_odd_num = intval(floor($n));\n    $last_even_num\
    \ = $last_odd_num + intval(floor($n/2));\n    if ($n % 2 == 0) {\n        $levels[]\
    \ = $last_even_num;\n    }\n    return $levels;\n}\n", "    $arr = [];\n    $arr[0]\
    \ = $n;\n    if ($n & 1) $arr[1] = ($n & 2);\n    $arr[2] = ($n & 4);\n    $arr[3]\
    \ = ($n & 8);\n    $arr[4] = ($n & 16);\n    return $arr;\n}\n", "    $pile =\
    \ array();\n    if ($n%2) {\n        $pile[] = $n;\n        return $pile;\n  \
    \  }\n    $pile[] = $n;\n    $pile = make_a_pile($n/2);\n    if ($n %2 == 0) {\n\
    \        $pile[] = $n;\n    }\n    return $pile;\n}\n", "    $piles = array();\n\
    \    $piles[] = $n;\n    for ($i = 1; $i < $n; $i += 2) {\n        $piles[] =\
    \ $n;\n    }\n    for ($i = 1; $i < $n; $i += 2) {\n        $piles[] = $n % 2\
    \ == 0 ? $n / 2 : $n * (3 - 1) + 1;\n    }\n    return $piles;\n}\n</code>\n<|/\
    \ a tags=php,arrays |>\n<| c |>\nA little explanation on how your code is working\
    \ would be great!\n<|/ c |>\n<| a dscore=1 |>\n<code>\n<?php\n$input=\"1 2 3 4\
    \ 5 6 7 8 9\";\npreg_match('/(?<=^|\\s)(\\d+ )+\\d+(?=\\s|$)/', $input, $matches);\n\
    $numbers = explode(\" \", $matches[0]);\n", "    $result = [];\n\n    for ($i\
    \ = 1; $i < $n; $i += 2)\n        $result[] = $i;\n\n    return $result;\n}",
  "    $pile = array();\n    // if n is even, there is one stone in the last level\n\
    \    if ($n & 1) {\n        $pile[] = 1;\n    }\n    // if n is odd, there are\
    \ two stones in the last level\n    else {\n        for ($i = 0; $i < $n / 2;\
    \ $i++) {\n            $pile[] = 2;\n        }\n    }\n    // now add another\
    \ level of stones\n    $n >>= 1;\n    for ($i = 0; $i < $n; $i++) {\n        $pile[]\
    \ = $n + $i;\n    }\n    return $pile;\n}\n\n$stones = make_a_pile(5);\nprint_r($stones);\n",
  "  if ($n <= 0) {\n    return array();\n  }\n\n  $levels = array();\n  foreach (range(0,\
    \ $n) as $i) {\n    if ($i % 2 == 0) {\n      $levels[] = $levels[($i + 1) % $n];\n\
    \    } else {\n      $levels[] = $levels[($i + 2) % $n];\n    }\n  }\n\n  return\
    \ $levels;\n}\n", "  $stones = array(1);\n  for ($i = 1; $i <= $n; $i++) {\n \
    \   // If the next level has odd\n    if ($n & 1 === 1) {\n      $stones[] = $stones[$i\
    \ - 1] ^ 1;\n    }\n    // If the next level has even\n    if ($n & 2 === 2) {\n\
    \      $stones[] = $stones[$i - 1] ^ 2;\n    }\n  }\n  return $stones;\n}\n",
  "    $n = abs($n);\n    $stones = array();\n    $first_level = 1;\n    if ($n %\
    \ 2 == 0) {\n        $next_odd = 0;\n    } else {\n        $next_even = -1;\n\
    \    }\n    $pile = array();\n    for ($i = 1; $i <= $n; ++$i) {\n        if ($i\
    \ == $n) {\n            $pile[$i] = $first_level;\n        } else {\n        \
    \    $pile[$i] = $next_odd * $i + $next_even * ($i - 1);\n        }\n    }\n \
    \   return $pile;\n}\n$result = make_a_pile(6);\necho \"The result is: \";\nprint_r($result);\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nI did a little refactoring, so you can see\
    \ what's changed. I think it's a lot more clear and easier to understand. Feel\
    \ free to give it a try and let me know if it works for you!\n<|/ c |>\n<| c |>\n\
    Thank you very much! It's a very clear explanation and your code is working fine.\
    \ Just another question: how do you find the code of a function you found online?\n\
    <|/ c |>\n<| c |>\nJust use [phpfiddle.org](https://phpfiddle.org) to test your\
    \ code, and then [copy the code](https://phpfiddle.org/main/code/r6z-6g8) and\
    \ paste it into your PHP code.\n<|/ c |>\n<| c |>\nThank you very much, that was\
    \ really helpful!\n<|/ c |>\n<| c |>\nNo worries, please consider marking my answer\
    \ as accepted, if it helped!\n<|/ c |>\n<| a dscore=2 |>\nHere is the most elegant\
    \ solution:\n<code>\n$stones = 3;\n$pile = array();\n\nfor ($i = 1; $i < $stones;\
    \ $i++)\n{\n    $pile[$i] = $i + 1;\n}\n\n$pile[$stones] = count($pile) - 1;\n\
    $pile[$stones - 1] += $pile[$stones];\n\necho(implode(', ', $pile));\n</code>\n\
    <|/ a tags=php,arrays |>\n<| a dscore=1 |>\n<code>\n$pile=array(1,2,3,4,5,6);\n\
    $count = array_slice($pile, count($pile)-2, 2);\n$last = $pile[count($pile)-1];\n\
    array_push($pile, count($pile)-2, $last+$count[1]);\nprint_r(array_slice($pile,0,-1)",
  "    if ($n <= 0) {\n        return array(0);\n    }\n\n    $pile = array(0);\n\
    \    $i = 1;\n    while (true) {\n        $pile[] = $i;\n        $i += ($n % 2)\
    \ === 0 ? 1 : 2;\n        $n = (int)($n / 2);\n    }\n\n    return $pile;\n}",
  "    $levels = array();\n    for ($i = 0; $i < $n; ++$i) {\n        if ($i % 2 ==\
    \ 0) {\n            $levels[$i] = 0;\n        } else {\n            $levels[$i]\
    \ = $i + 1;\n        }\n    }\n    return $levels;\n}\n", "  $arr = array(1);\n\
    \  for($i = 1; $i <= $n; $i++) {\n    $arr[] = (($i%2) === 1) ? $i + 1 : $i;\n\
    \  }\n  return $arr;\n}\n", "    if ($n == 0) {\n        return array();\n   \
    \ }\n    $a = array();\n    $a[] = $n;\n    if ($n % 2 == 0) {\n        $a[] =\
    \ make_a_pile($n/2);\n    }\n    return $a;\n}\n", "    return make_a_pile_helper(1,\
    \ $n, $n);\n}\n", "    $pile =  array_fill(0, $n+1, 0);\n    \n    // first level\
    \ has n stones\n    for ($i=0; $i<$n; $i++) {\n        $pile[$i]+=1;\n    }\n\n\
    \    // next level: odd\n    for ($i=1; $i<$n; $i+=2) {\n        $pile[$i]+=1;\n\
    \    }\n\n    // next level: even\n    for ($i=2; $i<$n; $i+=2) {\n        $pile[$i]+=1;\n\
    \    }\n    return $pile;\n}\n$a = make_a_pile(3);\nprint_r($a);\necho '<br>';\n\
    print_r(make_a_pile(5));\necho '<br>';\nprint_r(make_a_pile(6));\necho '<br>';\n\
    print_r(make_a_pile(8));\necho '<br>';\nprint_r(make_a_pile(10));\necho '<br>';\n\
    print_r(make_a_pile(12));\necho '<br>';\nprint_r(make_a_pile(15));\necho '<br>';\n\
    print_r(make_a_pile(18));\necho '<br>';\nprint_r(make_a_pile(20));\necho '<br>';\n\
    print_r(make_a_pile(25));\necho '<br>';\nprint_r(make_a_pile(30));\necho '<br>';\n\
    print_r(make_a_pile(35));\necho '<br>';\nprint_r(make_a_pile(40));\necho '<br>';\n\
    print_r(make_a_pile(45));\necho '<br>';\nprint_r(make_a_pile(50));\necho '<br>';\n\
    print_r(make_a_pile(55));\necho '<br>';\nprint_r(make_a_pile(60));\necho '<br>';\n\
    print_r(make_a_pile(65));\necho '<br>';\nprint_r(make_a_pile(70));\necho '<br>';\n\
    print_r(make_a_pile(75));\necho '<br>';\nprint_r(make_a_pile(80));\necho '<br>';\n\
    print_r(make_a_pile(85));\necho '<br>';\nprint_r(make_a_pile(90));\necho '<br>';\n\
    print_r(make_a_pile(95));\necho '<br>';\nprint_r(make_a_pile(100));\necho '<br>';\n\
    print_r(make_a_pile(101));\necho '<br>';\nprint_r(make_a_pile(102));\necho '<br>';\n\
    print_r(make_a_pile(103));\necho '<br>';\nprint_r(make_a_pile(104));\necho '<br>';\n\
    print_r(make_a_pile(105));\necho '<br>';\nprint_", "  $stones = array();\n  if\
    \ ($n <= 0) return $stones;\n  if ($n%2 === 1) {\n    // odd n\n    $stones[]\
    \ = $n;\n    for ($i = 1; $i <= $n; $i++) {\n      $stones[] = $i + $n + ($i%2\
    \ ? $n/2 : $n/2);\n    }\n  } else {\n    // even n\n    $stones[] = $n;\n   \
    \ for ($i = 1; $i <= $n; $i++) {\n      $stones[] = $i + $n + ($i%2 ? $n/2 : $n/2);\n\
    \    }\n  }\n  return $stones;\n}\n", "    $array = [];\n    for($i = 0; $i <=\
    \ $n; $i++) {\n        $array[] = ($n % 2 === 1 ? $i * ($i+1) : $i);\n    }\n\
    \    return $array;\n}\n", "    if ($n == 0) {\n        return array();\n    }\n\
    \    $pile = array();\n    for ($i = 0; $i < $n; $i++) {\n        if ($i%2 ==\
    \ 0) {\n            $pile[] = $n+1;\n        } else {\n            $pile[] = $n-1;\n\
    \        }\n    }\n    return $pile;\n}\nprint_r(make_a_pile(5));", "  $arr =\
    \ [$n];\n  while ($n-- > 0) {\n    $arr[] = is_int($n) ? $n : $n + 1;\n  }\n \
    \ return $arr;\n}\n", "  $a = array();\n  if ($n % 2 == 0) {\n    $a[] = $n;\n\
    \  }\n  while ($n > 0) {\n    $a[] = floor($n / 2);\n    $n = $n % 2;\n  }\n \
    \ return $a;\n}\n", "    $pile = array();\n    for ($i = 0; $i < $n; $i++) {\n\
    \        $pile[$i] = ($i % 2 === 0) ? $i + 1 : $i;\n    }\n    return $pile;\n\
    }\n", "    if ($n%2 != 0) $n++;\n    $ret = [1];\n    for($i=1; $i<=$n; $i++)\
    \ {\n        if ($i%2 != 0) {\n            $ret[] = $ret[$i-1] + 1;\n        }\
    \ else {\n            $ret[] = $ret[$i-1] + $i;\n        }\n    }\n    return\
    \ $ret;\n}", "    $result = array();\n    $result[] = $n;\n    $numOdd = 0;\n\
    \    $numEven = 0;\n    $i = 1; $k = -1;\n    while($i < $n) {\n        $result[$k]\
    \ = $result[$k - 1] + $numOdd % 2;\n        $numOdd = floor($numOdd / 2);\n  \
    \      $numEven = $numEven * 2;\n        $i++;\n        $k--;\n    }\n    return\
    \ $result;\n}", "    if ($n < 0)\n        return null;\n    if ($n == 0)\n   \
    \     return array();\n    if ($n%2 == 0)\n        return array($n+1);\n    $next\
    \ = 2 * $n + 1;\n    return array(\n        floor($n/2), // odd n\n        floor($next),\
    \ // even n\n    );\n}\n", "    $result = [];\n    for($i = 1; $i <= $n; $i++)\
    \ {\n        $result[$i] = $i % 2 === 1 ? $i : ($i + 1);\n    }\n    return $result;\n\
    }\n", "  $pile = array();\n  for ($i = 1; $i <= $n; $i++) {\n    if ($n % 2 ===\
    \ 0) {\n      $pile[$i] = $i;\n    } else {\n      $pile[$i] = $i + $n;\n    }\n\
    \  }\n  return $pile;\n}\n</code>\n<|/ a tags=php,recursion |>\n<| a dscore=1\
    \ |>\nThis is my solution.\n<code>\n<?php ", "    $counts = array($n);\n    if\
    \ ($n%2 == 0) {\n        for ($i = 1; $i <= $n; $i++) {\n            $counts[]\
    \ = $counts[($i-1)/2];\n        }\n    } else {\n        for ($i = 1; $i <= $n;\
    \ $i++) {\n            $counts[] = $counts[($i-1)/2+1];\n        }\n    }\n  \
    \  return $counts;\n}\n"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
