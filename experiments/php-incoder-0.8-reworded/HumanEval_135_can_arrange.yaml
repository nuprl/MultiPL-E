name: HumanEval_135_can_arrange
language: php
prompt: "<?php\n// Create a function which returns the largest index of an element\
  \ which\n// is not greater than or equal to the element immediately preceding it.\
  \ If\n// no such element exists then return -1. The given array will not contain\n\
  // duplicate values.\n// Examples:\n// >>> can_arrange(array(1, 2, 4, 3, 5))\n//\
  \ 3\n// >>> can_arrange(array(1, 2, 3))\n// -1\nfunction can_arrange($arr) {\n"
tests: "function candidate(...$args) {\n    return can_arrange(...$args);\n}\n\nfunction\
  \ test(): void {\n    if (candidate(array(1, 2, 4, 3, 5)) !== 3) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(array(1, 2, 4, 5)) !== -1) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(array(1, 4, 2, 5, 6, 7, 8, 9, 10)) !== 2)\
  \ { throw new Exception(\"Test failed!\"); }\n    if (candidate(array(4, 8, 5, 7,\
  \ 3)) !== 4) { throw new Exception(\"Test failed!\"); }\n    if (candidate(array())\
  \ !== -1) { throw new Exception(\"Test failed!\"); }\n}\n\ntest();"
completions: ["  $first_elem = array_shift($arr);\n  $first_not_greater_than = -1;\n\
    \  foreach ($arr as $key => $val) {\n    if ($val < $first_elem) {\n      continue;\n\
    \    }\n    if ($val >= $first_elem) {\n      $first_not_greater_than = $key;\n\
    \      break;\n    }\n  }\n  return $first_not_greater_than;\n}\n", "    foreach\
    \ ($arr as $key => $value) {\n        if ($value > $arr[$key - 1]) {\n       \
    \     return $key;\n        }\n    }\n    return -1;\n}\n", "  $prev = array_shift($arr);\n\
    \  foreach ($arr as $item) {\n    if ($item <= $prev) {\n      return -1;\n  \
    \  }\n    $prev = $item;\n  }\n  return array_search(max($arr), $arr);\n}\n</code>\n\
    <|/ a tags=arrays,php dscore=2 |>\n<| c |>\nWow, this is some pretty slick stuff.\
    \ I'm a little confused with the last line though? If we're getting the maximum\
    \ value of $arr then what's the point of checking if it's greater than the first\
    \ element in $arr?\n<|/ c |>\n<| c |>\nI've added an explanation to the answer.\
    \ The last line is just a shortcut for getting the index of the maximum element.\n\
    <|/ c |>\n<| a dscore=2 |>\nMy PHP solution:\n<code>\n<?php\n$arr = array(10,20,30,40,50);\n\
    $arr = array_slice($arr,0,$arr[0]+1);\n$arr = array_merge($arr, array_flip(array_slice($arr,1,count($arr)-1)));\n\
    $max = max($arr);\n$pos = array_search($max,$arr);\necho \"Max value is: \" .\
    \ $max . \", with index is: \" . $pos . \"\\n\";", "  $high = count($arr) - 1;\n\
    \  foreach ($arr as $v) {\n    if ($v > $high) {\n      $high = $v;\n    }\n \
    \ }\n  return $high;\n}\n", "  $last = null;\n  for ($i = 1; $i < count($arr);\
    \ $i++) {\n    if ($arr[$i] <= $last) {\n      return $i;\n    }\n    $last =\
    \ $arr[$i];\n  }\n  return -1;\n}\n", "  $keys = array_keys($arr);\n  $max_index\
    \ = max($keys);\n  $max_index += 1;\n  $last_index = $keys[$max_index];\n  $last_index_value\
    \ = $arr[$last_index];\n  if ($last_index_value >= $arr[$max_index - 1]) {\n \
    \   return $max_index;\n  }\n  return -1;\n}\n", "  sort($arr);\n  $first = array_shift($arr);\n\
    \  foreach ($arr as $v) {\n    if ($v > $first) return $v;\n  }\n  return -1;\n\
    }\n", "  for ($i = 0; $i < count($arr); $i++) {\n    if ($arr[$i] >= $arr[$i -\
    \ 1]) {\n      return $i;\n    }\n  }\n  return -1;\n}\n", "  arsort($arr);\n\
    \  foreach ($arr as $i => $num) {\n    if ($num != $arr[$i - 1]) return $i;\n\
    \  }\n  return -1;\n}\n\n/**\n * Helper function which returns true or false to\
    \ indicate whether a\n * function exists. Useful to avoid triggering a PHP E_NOTICE\
    \ on failure.\n *\n * @param callable $func Function to check for.\n */", "  \
    \  if (empty($arr)) {\n        return -1;\n    }\n    $result = -1;\n    $min\
    \ = min($arr);\n    $max = max($arr);\n    foreach ($arr as $key => $value) {\n\
    \        if ($value <= $min) {\n            $result = $key;\n            return\
    \ $result;\n        }\n        if ($value > $max) {\n            return -1;\n\
    \        }\n    }\n    return $result;\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=arrays,sorting,php,algorithm\
    \ |>\nA couple of observations:\n\nYou don't need to sort the array before determining\
    \ if you can arrange it because you're already trying to do that in your for loop.\n\
    If you look at your for-loop you only want to check if you've found the minimum\
    \ and maximum value of the array. In order to do this, you can use a variable\
    \ for the previous index to check to see if a value has been found that meets\
    \ your condition.\nIf you haven't found a previous value, you know the minimum\
    \ is greater than the current value. Thus, you don't need to check further because\
    \ the current value is equal to the minimum.\nIf you want to determine if an array\
    \ can be arranged in ascending order you can start by checking the last value\
    \ in the array and see if the current value is greater than that. If it is, then\
    \ you know that no value greater than the current value exists in the array. However,\
    \ if the current value is less than or equal to the previous value, then you know\
    \ that you can place your value at the current index and then set the previous\
    \ index to the current index. \n\nThe algorithm is as follows:\n<code>\n<?php",
  "  $largestIndex = $arr[0];\n  $smallestIndex = $arr[0];\n  foreach ($arr as $key\
    \ => $value) {\n    if ($value >= $smallestIndex) {\n      $smallestIndex = $key;\n\
    \    }\n    if ($value <= $largestIndex) {\n      $largestIndex = $key;\n    }\n\
    \  }\n  return $largestIndex;\n}\n</code>\n<|/ a dscore=3 |>\n<| a dscore=2 tags=php,sorting\
    \ |>\nThe array_search() function will help you to find the index where the key\
    \ you want is located. \n<code>\n$array1 = array('Apple','Mango','Orange','Pineapple','Grapes','Lemon');\n\
    $index = array_search('Grapes', $array1);\n$array2 = array('Apple','Mango','Orange','Pineapple','Grapes','Lemon');\n\
    $array2[$index] = 'Black';\nvar_dump($array2);\n</code>\n<|/ a |>\n<| a dscore=1\
    \ tags=php,sorting |>\nYou can do it with usort:\n<code>", "  $i = 0;\n  foreach\
    \ ($arr as $v) {\n    if ($v > $arr[$i]) {\n      break;\n    }\n    $i++;\n \
    \ }\n  return $i;\n}\n", "    $result = 0;\n\n    foreach ($arr as $key => $value)\
    \ {\n        if ($value <= $arr[($key - 1)]) {\n            $result = $key;\n\
    \        }\n    }\n\n    return $result;\n}\n</code>\n<|/ a |>\n<| c |>\nNot sure\
    \ if this is what I'm looking for. I already have a sorted array, I just need\
    \ a function that can tell me if I can arrange the array in the way I described,\
    \ i.e. by removing the element that comes before it if it exists or by inserting\
    \ it if it doesn't exist.\n<|/ c |>\n<| c |>\nThis is what I was looking for.\
    \ Thank you.\n<|/ c |>\n<| c |>\nThis answer is incomplete.\n<|/ c |>\n<| c |>\n\
    It's incomplete as in it doesn't actually answer the question.  What does this\
    \ do?  It does nothing.\n<|/ c |>\n<| a dscore=0 |>\nIf it's already sorted, all\
    \ you need to do is check if the current value is less than or equal to the next\
    \ one.  If so, then you can remove it, if not, then you can add it.\nEDIT\nIt\
    \ seems like you may need to write a method which searches for the point where\
    \ the array can be arranged such that it has equal values grouped together.\n\
    <|/ a tags=algorithm,sorting,php |>\n<| c |>\nIf it's already sorted, then you\
    \ just need to check if the current value is less than the next one.  If the current\
    \ is greater than the next, then you remove it.  If the current is less than the\
    \ next, then you add it.  You can't add it and then remove it without removing\
    \ it.  I believe I explained the algorithm for you.  You said you already have\
    \ a sorted array...  All you need to do is to check if the array is sorted first.\
    \  I'll write an example if you're still having trouble.\n<|/ c |>\n<| c |>\n\
    This isn't a correct algorithm. If you have an array `[1, 1, 2, 2]` then you'll\
    \ remove 1 before 2 and add 2 before 1, but you'll still have `[1, 1, 2]`.\n<|/\
    \ c |>\n<| c |>\nI already have an array sorted already. My question was how to\
    \ write a function that tells me if I can arrange the array in the way I described.\n\
    <|/ c |>\n<| c |>\nOk, I missed that part.  I'd suggest just trying each of the\
    \ 2 methods I suggested.  If they both work, great.  If not, then you'll need\
    \ to do a little extra logic to determine if the array can be arranged.  I'll\
    \ write it out for you now that I know more about what you're trying to accomplish.\
    \  Hope this helps.\n<|/ c |>\n<| c ", "    $largest = -1;\n    foreach ($arr\
    \ as $key => $val) {\n        if ($key > $largest || $val > $largest) {\n    \
    \        return $key;\n        }\n        $largest = $val;\n    }\n    return\
    \ -1;\n}\n</code>\nThe above function can now be used to check whether the array\
    \ can be arranged in any way.\n<code>", "    $maxIndex = -1;\n    foreach ($arr\
    \ as $key => $value) {\n        if ($key > 0 && $value > $arr[$key - 1]) {\n \
    \           $maxIndex = $key;\n        } else {\n            return -1;\n    \
    \    }\n    }\n    return $maxIndex;\n}\n", "    $n = count($arr);\n    // Find\
    \ largest index not greater than or equal to previous index.\n    $r = -1;\n \
    \   foreach ($arr as $i => $x) {\n        if ($x <= $r) {\n            $r = $i;\n\
    \        }\n    }\n    return $r;\n}\n", "  $largest = array_reduce($arr, function($acc,\
    \ $el) {\n    if ($acc > $el) {\n      return $el;\n    }\n    return $acc;\n\
    \  });\n  if ($largest === null) {\n    return -1;\n  }\n  foreach ($arr as $k\
    \ => $el) {\n    if ($el < $largest) {\n      return $k;\n    }\n  }\n  return\
    \ -1;\n}\n</code>\n<|/ a |>\n<| c |>\nThis is a very clever use of reduce to find\
    \ the largest element. I'm not sure if that algorithm can be improved, but it\
    \ certainly doesn't require an additional library.\n<|/ c |>\n<| c |>\nCan you\
    \ please post a version using only PHP core functions?\n<|/ c |>\n<| c |>\nThank\
    \ you! I did exactly the same (more or less), except that I didn't use an additional\
    \ library but only a function. :)\n<|/ c |>\n<| c |>\nI posted the function I\
    \ developed that works on PHP 5.5+\n<|/ c |>\n<| a dscore=4 |>\nYou can use the\
    \ sort method of arrays in PHP :\n<code>\n<?php\n\n$array = array(1, 2, 3, 4,\
    \ 5);\n\nsort($array);\n$largest = end($array);\nvar_dump($largest);\n</code>\n\
    <|/ a tags=algorithm,php,arrays,sorting |>\n<| c |>\nI think this should be the\
    \ accepted answer. Also `end()` is an alias for `rsort()` which does the same\
    \ thing as `sort()`\n<|/ c |>\n<| c |>\nThis is correct, but unfortunately it\
    \ doesn't answer the question. The question was \"how to get the largest item\
    \ from an array\", not \"how to sort an array\". It also doesn't address OP's\
    \ question of whether his array might contain duplicate elements.\n<|/ c |>\n\
    <| c |>\nIt's important to note that `end` requires that you already know the\
    \ length of the array in order for it to work. This will not work if you use an\
    \ iterator that doesn't have the length in advance.\n<|/ c |>\n<| a dscore=4 |>\n\
    You can use the usort function.\n<code>\n<?php\nusort($array, function($a, $b){\n\
    \    return $a > $b;\n});\nprint_r($array);", "\tforeach ($arr as $key => $value)\
    \ {\n\t\t$pos = $key - 1;\n\t\twhile ($pos >= 0) {\n\t\t\tif (!isset($arr[$pos])\
    \ || $arr[$pos] > $value) {\n\t\t\t\treturn $pos;\n\t\t\t}\n\t\t\t--$pos;\n\t\t\
    }\n\t}\n\treturn -1;\n}\n\n/**\n * Given an array of tasks, return true if the\
    \ tasks can be completed.\n * That is, each task is already completed or does\
    \ not require more work.\n *\n * If all tasks are completed, return true. If at\
    \ least one task is not\n * yet complete, return false.\n *\n * @param $arr array\
    \ of tasks to check\n * @return boolean true if the tasks can be completed, false\
    \ otherwise.\n */", "    foreach ($arr as $index => $value) {\n        if ($arr[$index]\
    \ <= $arr[$index - 1]) {\n            return $index;\n        }\n    }\n    return\
    \ -1;\n}\n\n/**\n * Determine if a set is sorted in ascending order.\n *\n * @param\
    \ mixed $arr\n *\n * @return bool\n */", "    $max = 0;\n    $idx = 0;\n    foreach\
    \ ($arr as $element) {\n        if ($idx > 0 && $element <= $arr[$idx]) {\n  \
    \          $idx = $idx;\n            $max = $element;\n        } else {\n    \
    \        $idx++;\n            if ($idx > $max) {\n                $max = $idx;\n\
    \            }\n        }\n    }\n    return $idx;\n}", "    $highest = -1;\n\
    \    $largest = -1;\n    foreach ($arr as $key => $val) {\n        if ($val >\
    \ $highest) {\n            $highest = $val;\n        } else if ($val > $largest)\
    \ {\n            $largest = $val;\n        }\n    }\n    return $highest;\n}\n",
  "  sort($arr);\n  $highest_index = array_search($arr[0], $arr);\n  unset($arr[0]);\n\
    \  sort($arr);\n  return $highest_index;\n}\n</code>\n<|/ a tags=sorting,php,arrays\
    \ dscore=3 |>\n<| c |>\nAwesome answer - I like this one.\n<|/ c |>\n<| c |>\n\
    Thank you sir, this is great\n<|/ c |>\n<| c |>\nYes. Just a little edit - I got\
    \ it working. But I had to change the code to `array_search($arr[0], $arr)` because\
    \ I wanted it to be able to handle empty arrays as well as full arrays.\n<|/ c\
    \ |>\n<| a |>\n<code>\n$array = array(0 => array('name' => 'test', 'type' => 'test1'),\n\
    \                1 => array('name' => 'test2', 'type' => 'test2'),\n         \
    \       2 => array('name' => 'test3', 'type' => 'test3'));\n$max = 0;\n$i = 0;\n\
    foreach($array as $key => $value){\n    if($value['type'] > $array[$key]['type'])\
    \ {\n        $max = max($array[$key]['type'], $max);\n    }\n    $i++;\n}\n</code>\n\
    <|/ a dscore=1 tags=sorting,php,arrays |>\n<| a dscore=1 |>\nI liked previous\
    \ solutions, except the one that didn't work for me. After some debugging i noticed\
    \ that array_search was not finding all the times. I solved it this way:\n<code>",
  "  $size = sizeof($arr);\n  for ($i = 1; $i < $size; $i++) {\n    if ($arr[$i] >\
    \ $arr[$i - 1]) {\n      return $i;\n    }\n  }\n  return -1;\n}\n", "    $max\
    \ = -1;\n    $last = 0;\n    foreach ($arr as $v) {\n        if ($v > $last) {\n\
    \            $max = $v;\n            $last = $v;\n        }\n    }\n    return\
    \ $max;\n}\n", "  $keys = array_keys($arr);\n  $largestKey = $keys[count($keys)-1];\n\
    \  $largestIndex = $keys[count($keys)-2];\n  $lastElem = $arr[$largestIndex];\n\
    \  for($i = 0; $i < count($arr); $i++) {\n    if($arr[$i] >= $lastElem) {\n  \
    \    if($lastElem === $largestIndex) {\n        return $i;\n      }\n      if($arr[$i]\
    \ > $largestIndex) {\n        $largestIndex = $arr[$i];\n      }\n    } else {\n\
    \      if($lastElem === $largestIndex) {\n        return -1;\n      }\n    }\n\
    \    $lastElem = $arr[$i];\n  }\n  return -1;\n}\n", "    sort($arr);\n    $largestIdx\
    \ = 0;\n    for ($i = 1; $i < count($arr); $i++) {\n        if ($arr[$i] > $arr[$largestIdx])\
    \ {\n            $largestIdx = $i;\n        }\n    }\n    return $largestIdx;\n\
    }\n", "  global $max;\n  $max = -1;\n  foreach ($arr as $v) {\n    if ($v > $max)\
    \ {\n      $max = $v;\n    }\n  }\n  return $max;\n}\n</code>\n<|/ a tags=php\
    \ |>\n<| a tags=php |>\n<code>\nclass NumberArrayHelper\n{\n    private static\
    \ $_lastMax = null;\n    public static function canArrange($arr){\n        if(null\
    \ === self::$_lastMax){\n            self::$_lastMax = max(self::arrange($arr));\n\
    \        }\n        return self::$_lastMax;\n    }\n    public static function\
    \ arrange($arr){\n        $max = -1;\n        foreach ($arr as $v) {\n       \
    \     if ($v > $max) {\n                $max = $v;\n            }\n        }\n\
    \        return $max;\n    }\n}\n</code>\nUsage\n<code>\necho NumberArrayHelper::canArrange(array(1,2,3,4,5,6,7,8,9));\n\
    </code>\n<|/ a dscore=0 |>\n<| a |>\nFor a more flexible way to define the \"\
    largest\" element of an array without iterating over the entire array, you could\
    \ use recursion.\n<code>", "  $largest = -1;\n  foreach ($arr as $index => $value)\
    \ {\n    if ($value <= $arr[($index-1)]) {\n      $largest = $index;\n    }\n\
    \  }\n  return $largest;\n}\n", "    $i = 0;\n    $len = count($arr);\n    while\
    \ ($i < $len) {\n        // The while condition here is to prevent a PHP warning\
    \ in PHP 5.4\n        // when $i == $len - 1.\n        $last = array_pop($arr);\n\
    \        if ($arr[$i] <= $last) {\n            return $i;\n        } else {\n\
    \            $i++;\n        }\n    }\n    return -1;\n}", "  $len = count($arr);\n\
    \n  for ($i = 1; $i < $len; ++$i) {\n    if ($arr[$i] <= $arr[$i - 1]) {\n   \
    \   return $i;\n    }\n  }\n\n  return -1;\n}\n\n/**\n * Returns the maximum value\
    \ from an array of values.\n *\n * @param  array $arr\n *\n * @return int\n */",
  "\tfor($i=1; $i<count($arr); $i++) {\n\t\tif($arr[$i] <= $arr[$i-1]) return $i;\n\
    \t}\n\treturn -1;\n}\n", "  $n = count($arr);\n  foreach ($arr as $k => $v) {\n\
    \    if ($v <= $arr[$k - 1]) return $k;\n  }\n  return -1;\n}\n", "    $max_index\
    \ = -1;\n\n    foreach ($arr as $key => $value) {\n        if ($max_index < $key\
    \ && $value < $arr[($key - 1)]) {\n            $max_index = $key;\n        }\n\
    \    }\n\n    return $max_index;\n}\n</code>\n<|/ a tags=algorithm,php dscore=2\
    \ |>\n<| a dscore=2 |>\nHere is another solution for you:\n<code>\n<?php\n\nclass\
    \ Knapsack{\n  private $capacity;\n  private $weights;\n  private $values;\n\n\
    \  public function __construct($capacity, $weights) {\n    $this->capacity = $capacity;\n\
    \    $this->weights = $weights;\n    $this->values = new Array($capacity);\n\n\
    \    $totalWeight = 0;\n    foreach ($this->weights as $weight) {\n      $totalWeight\
    \ += $weight;\n    }\n\n    for ($i = 0; $i < $capacity; $i++) {\n      $this->values[$i]\
    \ = max(\n        $this->values[$i] +\n        $this->weights[$i] * ($this->capacity\
    \ - $i),\n        $this->values[$i - 1] + $weights[$i - 1] * $totalWeight\n  \
    \    );\n    }\n  }\n\n  public function getWeights($values) {\n    $weights =\
    \ array();\n    $index = 0;\n\n    while($index < $this->capacity) {\n      if($values[$index]\
    \ > $this->values[$index]) {\n        break;\n      }\n\n      array_push($weights,\
    \ $this->weights[$index]);\n\n      ++$index;\n    }\n\n    return $weights;\n\
    \  }\n\n  public function getBestValues($values) {\n    $weights = $this->getWeights($values);\n\
    \    $index = 0;\n\n    while($index < $this->capacity) {\n      if($values[$index]\
    \ < $this->values[$index]) {\n        break;\n      }\n\n      array_push($values,\
    \ $this->values[$index]);\n      $index++;\n    }\n\n    return $values;\n  }\n\
    }\n\n$knapsack = new Knapsack(4, array(1, 2, 3));\n$values = $knapsack->getBestValues(array(10,\
    \ 20, 30, 40));\n\necho \"Best: \";\nprint_r($values);\n</code>\n<|/ a tags=algorithm,php\
    \ |>\n<| a tags=algorithm,php |>\nHere's a PHP implementation based on Dhruv Dor'Aryan's\
    \ solution. I've used a hash table in place of an array as the data structure\
    \ to allow the O(1) access time for checking a value and retrieving the corresponding\
    \ weights.\n<code>\n<?php\n\nclass Knapsack {\n\n  private $capacity;\n  private\
    \ $weights;\n  private $values;\n\n  public function ", "\t$max = 0;\n\t$res =\
    \ -1;\n\tforeach ($arr as $a) {\n\t\tif ($a > $arr[$max]) {\n\t\t\t$max = $a;\n\
    \t\t} elseif ($a == $arr[$max]) {\n\t\t\t$res = $a;\n\t\t}\n\t}\n\treturn $res;\n\
    }", "  $i = count($arr) - 1;\n  for ($i; $i >= 0; $i--) {\n    if ($arr[$i] <=\
    \ $arr[$i - 1]) {\n      return $i;\n    }\n  }\n  return -1;\n}\n", "    $max\
    \ = $min = PHP_INT_MAX;\n    $pos = -1;\n    foreach ($arr as $key => $value)\
    \ {\n        if ($max < $value) {\n            $max = $value;\n            $pos\
    \ = $key;\n        }\n        if ($min > $value) {\n            $min = $value;\n\
    \        }\n    }\n    return $pos;\n}\n", "    $max = 0;\n    foreach ($arr as\
    \ $key => $value) {\n        if ($key > $max) {\n            $max = $key;\n  \
    \      }\n    }\n    return $max;\n}\n", "    if (!is_array($arr)) {\n       \
    \ return -1;\n    }\n\n    $max = -1;\n    foreach ($arr as $key => $value) {\n\
    \        if ($key <= $max) {\n            return $key;\n        }\n\n        $max\
    \ = $key;\n    }\n\n    return $max;\n}\n", "    foreach ($arr as $i => $val)\
    \ {\n        if ($val > $arr[0]) {\n            return $i;\n        }\n    }\n\
    \    return -1;\n}\n", "  $largest = null;\n  for ($i = 0; $i < count($arr); $i++)\
    \ {\n    if ($i > 0 && $arr[$i] <= $arr[$largest]) {\n      $largest = $i;\n \
    \   }\n  }\n\n  return $largest === null ? -1 : max(0, count($arr) - $largest);\n\
    }\n", "  $result = -1;\n  $size = count($arr);\n  for ($i = 0; $i < $size; $i++)\
    \ {\n    if ($i > 0) {\n      $result = max($i, $result);\n    }\n    if ($arr[$i]\
    \ <= $arr[$i - 1]) {\n      return $result;\n    }\n  }\n  return $result;\n}\n\
    </code>\n<|/ a |>\n<| a tags=php |>\nUse this function for any range\n<code>",
  "  return max(array_keys($arr, $arr[0]));\n}\n</code>\n<|/ a tags=arrays,php |>\n\
    <| c |>\nNice solution, but what if there are no other elements which satisfy\
    \ the condition?\n<|/ c |>\n<| c |>\nThis is why I said \"...The given array will\
    \ not contain duplicate values.\"\n<|/ c |>\n<| c |>\nI'm pretty sure it isn't\
    \ possible to implement this solution without using some sort of loop.\n<|/ c\
    \ |>\n<| a tags=arrays,php |>\nYou can create a temporary array and compare all\
    \ elements with this temp array until the condition is met. Here is a working\
    \ example.\n<code>", "    foreach ($arr as $key => $value) {\n        if ($key\
    \ != 0) {\n            if ($arr[--$key] > $arr[$key-1]) {\n                return\
    \ $key;\n            }\n        }\n    }\n    return -1;\n}\n", "    $largest\
    \ = -1;\n    $last_key = -1;\n    foreach ($arr as $key => $value) {\n       \
    \ if ($key > $largest) {\n            $largest = $key;\n        }\n        if\
    \ ($key < $last_key + 1) {\n            $largest = -1;\n        }\n        $last_key\
    \ = $key;\n    }\n    return $largest;\n}\n", "    if (empty($arr)) {\n      \
    \  return -1;\n    }\n\n    $result = $arr[0];\n    foreach ($arr as $key => $value)\
    \ {\n        if ($value > $result) {\n            $result = $key;\n        }\n\
    \    }\n\n    return $result;\n}\n", "    $max = -1;\n    for ($i = 1; $i < count($arr);\
    \ $i++) {\n        if ($arr[$i] >= $arr[$max]) $max = $i;\n    }\n    return $max;\n\
    }\n</code>\n<|/ a |>\n<| a |>\nI've been trying to find an optimal solution but\
    \ couldn't come up with one.\nI think that the solution below is at least as fast\
    \ as it gets:\n<code>", "    if (count($arr) === 0) {\n        return -1;\n  \
    \  }\n    $largest = -1;\n    $last = $arr[0];\n    foreach ($arr as $key => $val)\
    \ {\n        if ($val <= $last) {\n            return -1;\n        }\n       \
    \ if ($val > $last) {\n            $largest = $key;\n        }\n        $last\
    \ = $val;\n    }\n    return $largest;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=arrays,algorithm,php\
    \ |>\nTry this one.\n<code>", "  $largest = -1;\n  foreach ($arr as $key => $val)\
    \ {\n    if ($largest < $key + 1) {\n      $largest = $key;\n    }\n  }\n  return\
    \ $largest;\n}\n</code>\n<|/ a tags=php,algorithm,sorting |>\n<| c |>\nI suspect\
    \ the complexity of the above approach should be `O(NlogN)`.  But it seems very\
    \ similar to my answer.\n<|/ c |>\n<| a tags=php,algorithm,sorting |>\nIn PHP\
    \ you can find the largest element of an array in O(n) time using array_search()\
    \ and array_slice():\n<code>\n$arr = array(1, 2, 4, 3, 5);\n$elem = array_search($max,\
    \ array_slice($arr, 0, $max));\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 tags=php,algorithm,sorting\
    \ |>\nHere's a fairly simple solution in PHP:\n<code>\n<?php\n", "    $largest\
    \ = -1;\n    $last_index = -1;\n    foreach ($arr as $key => $value) {\n     \
    \   if ($value > $arr[$last_index] || ($value === $arr[$last_index] && $key >\
    \ $last_index)) {\n            $last_index = $key;\n        }\n        if ($last_index\
    \ === $largest) {\n            return $last_index;\n        }\n    }\n    return\
    \ $largest;\n}\n", "    if (empty($arr)) return -1;\n\n    $last = array_pop($arr);\n\
    \    return array_search($last, $arr) ? -1 : $last;\n}", "  $min = min($arr);\n\
    \  $max = max($arr);\n  foreach ($arr as $k => $v) {\n    if ($v < $min) {\n \
    \     return -1;\n    } else if ($v > $max) {\n      return $k;\n    }\n  }\n\
    \  return 0;\n}\n", "    return max(array_keys(array_filter(function ($a, $i=0)\
    \ {\n        return $a < $arr[$i];\n    }), 0, $arr));\n}\n</code>\n<|/ a tags=algorithm,php\
    \ |>\n<| c |>\nThat is very clever and works. I didn't think to go down the `array_filter`\
    \ path like that. My question now is if it's possible to optimise it further,\
    \ as it seems quite a heavy function.\n<|/ c |>\n<| c |>\nI agree it is pretty\
    \ heavy, but I can't think of any other way off the top of my head. Maybe using\
    \ a regex that finds the next index but isn't a digit. I know regex aren't always\
    \ good but maybe it'll help.\n<|/ c |>\n<| c |>\nThanks for your help, much appreciated.\
    \ I'll be working on optimising it further after a few hours but you definitely\
    \ put me on the right track so thanks again.\n<|/ c |>\n<| a tags=algorithm,php\
    \ dscore=0 |>\nHere is my final solution that is a little more concise (and probably\
    \ a bit faster, which isn't really a deal breaker for me).\n<code>", "    $largest\
    \ = -1;\n    $curr = $arr[0];\n    for ($i = 0; $i < count($arr); $i++) {\n  \
    \      if ($arr[$i] <= $curr) {\n            $largest = $i;\n        } else {\n\
    \            $curr = $arr[$i];\n        }\n    }\n    return $largest;\n}", " \
    \ // $arr is expected to be ordered\n  $iLastElementPos = -1;\n  $iLastNonEqualElementPos\
    \ = -1;\n  for ($i = 0; $i < count($arr); $i++) {\n    if ($arr[$i] <= $arr[$iLastElementPos])\
    \ {\n      $iLastNonEqualElementPos = $i;\n    }\n    $iLastElementPos = $i;\n\
    \  }\n  return ($iLastNonEqualElementPos >= 0) ? $iLastNonEqualElementPos : -1;\n\
    }\n", "    $result = -1;\n    $len = count($arr);\n    for ($i = 0; $i < $len;\
    \ $i++) {\n        $j = $i;\n        for ($j = $i + 1; $j < $len; $j++) {\n  \
    \          if ($arr[$i] <= $arr[$j]) {\n                break;\n            }\n\
    \        }\n        if ($i == $j) {\n            $result = $i;\n        }\n  \
    \  }\n    return $result;\n}\n", "    $largest = array_shift($arr);\n    foreach\
    \ ($arr as $key => $val) {\n        if ($val >= $largest) {\n            $largest\
    \ = $key;\n        }\n    }\n    return ($largest < 0) ? -1 : (int) $largest;\n\
    }", "    $largest = -1;\n\n    foreach ($arr as $key => $val) {\n        $new_largest\
    \ = ($key > $largest) ? $key : $largest;\n    }\n\n    return $new_largest;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a |>\nMy answer:\n<code>", "  for ($i = 1; $i\
    \ < count($arr); $i++) {\n    if ($arr[$i - 1] >= $arr[$i]) {\n      return $i;\n\
    \    }\n  }\n  return -1;\n}\n</code>\n<|/ a tags=php,algorithm,sorting |>\n<|\
    \ a tags=php,algorithm,sorting |>\nYou can try this:\n<code>\n$a = [1, 2, 3, 4,\
    \ 5, 6, 7];\n$result = [];\nfor ($i = 0; $i < count($a); $i++) {\n    $index =\
    \ $i;\n    $result = array_filter($result, function($elem) use ($index) {\n  \
    \      return $elem < $a[$index];\n    });\n\n    if (count($result)) {\n    \
    \    array_push($result, $a[$index]);\n    }\n}\n\nprint_r($result);\n</code>\n\
    This results in:\n<code>\nArray\n(\n    [0] => 1\n    [1] => 2\n    [2] => 3\n\
    \    [3] => 4\n    [4] => 5\n    [5] => 6\n    [6] => 7\n)\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThank you! Works like a charm!\n<|/ c |>\n<| a dscore=2 tags=php,algorithm,sorting\
    \ |>\nHere is the solution using array_reduce:\n<code>\n$array = [1,2,3,4,5,6,7];\n\
    $result = array_reduce(\n    $array,\n    function($carry, $number) {\n      \
    \  if (!in_array($number, $carry)) {\n            return array_merge($carry, [$number]);\n\
    \        } else {\n            sort($carry);\n            return $carry;\n   \
    \     }\n    },\n    []\n);\n</code>\n<|/ a |>\n<| a dscore=2 |>\nYou can use\
    \ the following code. It will work both ways.\n<code>\n<?php\n\n$array = [1,2,3,4,5,6,7];\n\
    \n$result = array();\n$previous = null;\nforeach ($array as $key => $value) {\n\
    \    if ($previous == $value) {\n        if ($previous == 1) {\n            $result[]\
    \ = 1;\n        }\n    } else {\n        if ($value != $previous) {\n        \
    \    $result[] = $value;\n        }\n    }\n    $previous = $value;\n}\n", " \
    \   $len = count($arr);\n    $prev = $arr[0];\n    for ($i = 1; $i < $len; $i++)\
    \ {\n        if ($arr[$i] <= $prev) {\n            return $i;\n        } else\
    \ {\n            $prev = $arr[$i];\n        }\n    }\n    return -1;\n}\n", " \
    \   $n = count($arr);\n    foreach ($arr as $k => $v) {\n        if ($v >= $arr[$k\
    \ - 1]) return $k;\n    }\n    return -1;\n}\n", "    return max(array_keys(array_filter($arr,\
    \ function ($item) use ($arr) {\n        return !($item <= $arr[0]);\n    })));\n\
    }", "  for ($i = 1; $i < count($arr); $i++) {\n    if ($arr[$i] > $arr[$i - 1])\
    \ {\n      return $i - 1;\n    }\n  }\n  return -1;\n}\n", "    // Initialize\
    \ max\n    $max = -1;\n    // Loop through all values in array\n    foreach ($arr\
    \ as $value) {\n        // If value is greater than or equal to previous max value\
    \ return max\n        // value\n        if ($value >= $max) {\n            $max\
    \ = $value;\n        } // If value is less and equal to previous max value keep\
    \ current value\n        elseif ($value == $max) {\n        }\n    }\n    // Return\
    \ -1 if all values were equal\n    return $max == -1 ? -1 : -1;\n}", "    $max\
    \ = max($arr);\n    foreach ($arr as $i => $val) {\n        if ($val > $max) {\n\
    \            $max = max($max, $i);\n        }\n    }\n    return $max;\n}\n",
  "    foreach($arr as $key => $val) {\n        if (($prev = $arr[$key-1]) <= $val)\
    \ return $key;\n    }\n    return -1;\n}\n</code>\n<|/ a dscore=1 tags=sorting,php,algorithm\
    \ |>\n<| c |>\nSorry but I think it could be done in O(n) time. It will require\
    \ just one pass through the array and one pass through the sorted array.\n<|/\
    \ c |>\n<| c |>\n: That's a good point; I hadn't considered it could be done in\
    \ O(n) time. I'll do some research and see if I can come up with something better.\n\
    <|/ c |>\n<| c |>\nO(n) time is always possible because you have to traverse the\
    \ array once.\n<|/ c |>\n<| c |>\nYes, but you still have to do `n` array traversals,\
    \ right? And you only need to do that once. That's not O(n) time though, unless\
    \ I misunderstand what you're saying :)\n<|/ c |>\n<| c |>\nWhat about your second\
    \ example? It says it should return 3, but returns 4.\n<|/ c |>\n<| a tags=sorting,php,algorithm\
    \ dscore=1 |>\nThis isn't a PHP solution, but here's the code in C++:\n<code>",
  "  for ($i = 1; $i < count($arr); $i++) {\n    // If the previous value is greater\
    \ than or equal to the current value\n    // and the current value is less than\
    \ or equal to the next value\n    // then return this index.\n    if ($arr[$i\
    \ - 1] >= $arr[$i] && $arr[$i] <= $arr[$i + 1]) {\n      return $i;\n    }\n \
    \ }\n  return -1;\n}\n", "  $max = $arr[0];\n  for ($i = 1; $i < count($arr);\
    \ $i++) {\n    if ($arr[$i] <= $max) {\n      $max = $arr[$i];\n    }\n  }\n \
    \ return $max;\n}\n", "  if (empty($arr)) {\n    return -1;\n  }\n  $max_idx =\
    \ -1;\n  $max_elem = array_shift($arr);\n  foreach ($arr as $key => $value) {\n\
    \    if ($key <= $max_elem) {\n      $max_idx = $key;\n    }\n    if ($key >=\
    \ $max_elem) {\n      if ($max_idx != -1) {\n        return $max_idx;\n      }\n\
    \    }\n    if ($value > $max_elem) {\n      $max_elem = $value;\n      $max_idx\
    \ = $key;\n    }\n  }\n  return $max_idx;\n}\n</code>\n<|/ a dscore=4 tags=algorithm,php\
    \ |>\n<| c |>\nWow, I learned a lot from your answer. Thank you very much for\
    \ your time. :)\n<|/ c |>\n<| c |>\nNo problem, just added my answer! :)\n<|/\
    \ c |>\n<| c |>\nGreat work. I tried to make an algorithm for it, but couldn't\
    \ make it work until now.\n<|/ c |>\n<| a tags=algorithm,php |>\nI made an algorithm\
    \ for it. It works almost perfect, but I don't understand how it's working. :)\
    \ So please if someone wants to explain how it works, I'll be grateful.\nHere\
    \ it is:\n<code>", "    $largest = -1;\n    $current = false;\n    foreach ($arr\
    \ as $key => $val) {\n        if ($current !== false && $key <= $current) {\n\
    \            return $largest;\n        }\n        if ($key <= $largest) {\n  \
    \          $largest = $key;\n            $current = $val;\n        }\n    }\n\
    \    return $largest;\n}\n", "  if (is_array($arr)) {\n    $max = max($arr);\n\
    \    foreach ($arr as $idx => $num) {\n      if ($num >= $max) {\n        return\
    \ $idx;\n      }\n    }\n  }\n  return -1;\n}\n", "    $result = -1;\n\n    foreach\
    \ ($arr as $key => $value) {\n        if ($arr[$key] <= $result) {\n         \
    \   $result = $key;\n        }\n    }\n\n    return $result;\n}\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\nGreat solution ! Thank you :)\n<|/ c |>\n<| a |>\nHere\
    \ is a solution using only array_reduce:\n<code>\n$numbers = array(1, 2, 3, 4,\
    \ 4, 5, 6, 7, 8, 8, 8, 9, 10, 10, 11, 12, 12, 13, 13, 13, 13, 14, 14, 14, 15,\
    \ 16, 17, 18, 19, 20);\n\n$biggestIndex = array_reduce($numbers, function ($max,\
    \ $current) {\n    return $current > $max ? $current : $max;\n});\n\nvar_dump($biggestIndex);\
    \ // 22\n</code>\n<|/ a tags=php,arrays,algorithm,sorting dscore=2 |>\n<| a dscore=1\
    \ |>\nThis solution takes no extra memory and is much faster:\n<code>\n<?php\n\
    $input = array(1, 2, 3, 4, 4, 5, 6, 7, 8, 8, 8, 9, 10, 10, 11, 12, 12, 13, 13,\
    \ 13, 13, 14, 14, 14, 15, 16, 17, 18, 19, 20);\n$input = array_filter($input,\
    \ function ($k) { return $k >= 2; });\nasort($input);\n$biggestIndex = count($input)\
    \ - 1;\n</code>\n<|/ a tags=php,arrays,algorithm,sorting |>\n<| c |>\nThis solution\
    \ is very inefficient. It loops over every single element twice.\n<|/ c |>\n<|\
    \ a |>\n<code>\n$input = array(10, 2, 5, 3, 9, 4, 7, 8, 1);\n$input = array_filter($input,\
    \ function ($k) { return $k >= 2; });\nasort($input);\n$biggestIndex = count($input)\
    \ - 1;\n</code>\n<|/ a tags=php,arrays,algorithm,sorting dscore=1 |>\n<| c |>\n\
    This solution is very inefficient. It loops over every single element twice.\n\
    <|/ c |>\n<| a tags=php,arrays,algorithm,sorting |>\n<code>", "  // TODO: Implement\
    \ Function\n  return -1;\n}", "    foreach ($arr as $key => $val) {\n        if\
    \ ($key > 0) {\n            return $key;\n        }\n    }\n    return -1;\n}\n",
  "  return max(array_keys($arr, function ($e, $i) { return $i !== 0 && $e < $arr[$i\
    \ - 1]; }));\n}\n", "\tdo {\n\t\t$smallest = min($arr);\n\t\t$largest = max($arr);\n\
    \t\tif ($smallest < $largest) {\n\t\t\t$diff = $largest - $smallest + 1;\n\t\t\
    \tbreak;\n\t\t}\n\t\t$arr[] = $largest;\n\t} while (end($arr) != $largest);\n\n\
    \treturn $diff;\n}\n", "\t$largest = -1;\n\t$last_el = -1;\n\n\tforeach($arr as\
    \ $k => $v) {\n\t\tif($v > $last_el) {\n\t\t\t$largest = $k;\n\t\t} elseif($v\
    \ == $last_el) {\n\t\t\tif($k > $largest) {\n\t\t\t\t$largest = $k;\n\t\t\t}\n\
    \t\t}\n\t\t$last_el = $v;\n\t}\n\treturn $largest;\n}\n\n/**\n * Compare two arrays\
    \ for equal elements and sort them if they do not match\n *\n * @param array $arr1\
    \ Array to compare\n * @param array $arr2 Array to compare\n * @return array Array\
    \ containing the same elements as $arr1 but sorted if they do not match\n */",
  "    foreach ($arr as $key => $value) {\n        $next = $key + 1;\n        if (!($next\
    \ < count($arr) && $arr[$next] >= $value)) {\n            return $next;\n    \
    \    }\n    }\n    return -1;\n}\n", "    if (!is_array($arr)) {\n        return\
    \ -1;\n    }\n    $max = -1;\n    $prev = -1; // the element before the current\
    \ one\n    foreach ($arr as $key => $val) {\n        if ($val >= $prev) {\n  \
    \          if ($max < $key) {\n                $max = $key;\n            }\n \
    \       }\n        else {\n            $prev = $key;\n        }\n    }\n    return\
    \ $max;\n}\n", "\tfor ($i = 0; $i < count($arr) - 1; $i++) {\n\t\tif ($arr[$i]\
    \ <= $arr[$i + 1]) {\n\t\t\treturn $i;\n\t\t}\n\t}\n\treturn -1;\n}\n", "    //\
    \ TODO: Write the code here.\n}", "    $last_i = count($arr) - 1;\n\n    foreach\
    \ ($arr as $i => $x) {\n        if ($x <= $arr[$last_i]) {\n            $last_i\
    \ = $i;\n        }\n    }\n\n    return $last_i;\n}\n", "    $largest = 0;\n \
    \   for ($i = 0; $i < count($arr); $i++) {\n        if ($arr[$i] >= $arr[($largest)-1])\
    \ {\n            $largest = $i;\n        } else {\n            return -1;\n  \
    \      }\n    }\n    return $largest;\n}\n</code>\n<|/ a dscore=4 |>\n<| a dscore=2\
    \ |>\nI was looking to do something similar, and came across a similar question\
    \ and answer. I had an array that would have negative indexes, and the other answers\
    \ did not provide this functionality for negative indexes.\nHere is my modified\
    \ version of the function I found on another question:\n<code>", "    $max = -1;\n\
    \    foreach ($arr as $key => $value) {\n        if ($value <= $arr[($key - 1)])\
    \ {\n            $max = $key;\n        }\n    }\n    return $max;\n}", "  $max_index\
    \ = -1;\n  $prev_value = null;\n  foreach ($arr as $key => $value) {\n    if ($value\
    \ > $prev_value) {\n      $max_index = $key;\n    }\n    $prev_value = $value;\n\
    \  }\n  return $max_index;\n}\n", "    $largest = -1;\n    $index = -1;\n    $count\
    \  = count($arr);\n    for($i = 0; $i < $count; $i++) {\n        if($arr[$i] <=\
    \ $arr[$index]) {\n            return -1;\n        }\n        $largest = max($largest,\
    \ $i);\n    }\n    return $largest;\n}", "  $imax = -1;\n  $nmax = count($arr);\n\
    \  for ($i = 1; $i < $nmax; $i++) {\n    if ($arr[$i] > $arr[$i - 1]) {\n    \
    \  $imax = max($imax, $i - 1);\n    }\n  }\n  return $imax;\n}", "  // TODO: Write\
    \ your code in PHP; this is not a place for you to copy from\n}", "    $previous\
    \ = false;\n    for ($i = 0; $i < count($arr); $i++) {\n        if ($arr[$i] <=\
    \ $previous) {\n            return $i;\n        }\n        $previous = $arr[$i];\n\
    \    }\n    return -1;\n}", "    if (empty($arr)) {\n        return -1;\n    }\n\
    \n    $max = max($arr);\n\n    foreach ($arr as $idx => $value) {\n        if\
    \ ($value < $max) {\n            return $idx;\n        }\n    }\n\n    return\
    \ -1;\n}\n", "    $n = count($arr);\n    $a = $n-1;\n    $b = $n-1;\n    for ($i=1;$i<$n;$i++)\
    \ {\n        $c = $n-$i;\n        if ($arr[$i] > $arr[$a] && $arr[$i] > $arr[$b])\
    \ {\n            $a = $i;\n        } else if ($arr[$a] > $arr[$i] && $arr[$a]\
    \ > $arr[$b]) {\n            $b = $i;\n        } else if ($arr[$i] >= $arr[$a]\
    \ && $arr[$i] >= $arr[$b]) {\n            $a = $i;\n            $b = $i;\n   \
    \     }\n    }\n    return $a;\n}", "  $highest = $arr[0]; // We assume that the\
    \ first value is always the highest value.\n  for ($i = 1; $i < count($arr); $i++)\
    \ {\n    if ($arr[$i] >= $highest) {\n      unset($highest);\n      return $i;\n\
    \    }\n  }\n  return -1;\n}\n\n/**\n * Helper function to remove an item from\
    \ an array. If the array contains\n * multiple items, only the first matching\
    \ value is removed.\n *\n * @param string $key The key of the item to remove\n\
    \ * @param array $arr The array to remove from\n * @param int $offset The offset\
    \ in the array to begin removing from\n * @return bool true if the item was removed,\
    \ false if $key is not in the array\n */", "    $len = count($arr);\n    $max\
    \ = -1;\n    for ($i = 1; $i < $len; $i++) {\n        if ($arr[$i] > $arr[$i -\
    \ 1]) break;\n        if ($max < $i - 1) $max = $i;\n    }\n    return $max;\n\
    }", "    // Write your code here\n    $result = -1;\n    foreach($arr as $key\
    \ => $value) {\n        if($value < $arr[($key - 1)]) {\n            $result =\
    \ $key;\n        }\n    }\n    return $result;\n}\n\n$array = [1, 2, 4, 3, 5,\
    \ 6, 7, 9, 10, 12];\n$result = can_arrange($array);\nif ($result == -1) { \n \
    \   echo '-1';\n}\nelse {\n    echo 'index '.$result;\n}\n</code>\nOutput: index\
    \ = 3\n<|/ a dscore=0 tags=arrays,php |>\n<| a tags=arrays,php |>\nMy first question\
    \ would be, why do you want to do this? There must be a better way to do what\
    \ you want.\nThat being said, this is my attempt at solving your problem:\n<code>\n\
    <?php\n", "  $last_elem = end($arr);\n  foreach($arr as $item) {\n    if ($item\
    \ <= $last_elem) {\n      return $item;\n    }\n  }\n  return -1;\n}\n", "  $prev\
    \ = reset($arr);\n  for ($i = 0; $i < count($arr); $i++) {\n    if ($arr[$i] >\
    \ $prev) {\n      return $i;\n    }\n    $prev = $arr[$i];\n  }\n  return -1;\n\
    }\n", "    $max = -1;\n    $i = 0;\n    foreach ($arr as $key => $value) {\n \
    \       if ($value >= $arr[$i]) {\n            if ($key > $max) {\n          \
    \      $max = $key;\n            }\n            $i++;\n        } else {\n    \
    \        if ($max != -1) {\n                return $max;\n            }\n    \
    \    }\n    }\n    return -1;\n}\n", "    $largest = -1;\n\n    foreach ($arr\
    \ as $key => $val) {\n        if ($val >= $largest) {\n            $largest =\
    \ $key;\n        }\n    }\n\n    return $largest;\n}\n</code>\n<|/ a |>\n<| c\
    \ |>\nThanks for the answer but I'm afraid it's not what I'm looking for. Please\
    \ reread my question and you'll see I already mentioned that it doesn't work as\
    \ expected.\n<|/ c |>\n<| c |>\nOh, sorry I didn't see it :) I'll test it later\
    \ on today and will let you know.\n<|/ c |>\n<| c |>\nAlright, tested it and seems\
    \ like it's working as expected. Thank you very much. :) It's pretty funny how\
    \ stupid my question is. But anyway, thank you for answering it.\n<|/ c |>\n<|\
    \ a tags=php,algorithm |>\n<code>\n<?php\n$arr = [1, 2, 3, 4, 5];\nsort($arr);\n\
    $largest = array_pop($arr);\n</code>\nEdit\n<code>\n<?php\n$arr = [1, 2, 3, 4,\
    \ 5];\nsort($arr);\n$largest = null;\n$previous = null;\nfor ($i = 0; $i < count($arr);\
    \ $i++) {\n    if ($arr[$i] == $largest) {\n        $largest = $arr[$i];\n   \
    \ }\n    if ($arr[$i] == $previous) {\n        if ($previous === $largest) {\n\
    \            $largest = null;\n            $previous = $arr[$i - 1];\n       \
    \ }\n        else {\n            $largest = $previous;\n            $previous\
    \ = $arr[$i];\n        }\n    }\n    else {\n        $previous = $arr[$i];\n \
    \   }\n}\nvar_dump($largest);\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't\
    \ work. `array_pop` removes the last element and returns the popped one. This\
    \ will not work when there is only one element in the array.\n<|/ c |>\n<| c |>\n\
    Hi, thanks for your answer. But this doesn't work either. Please see my update.\n\
    <|/ c |>\n<| c |>\nYou're right. I updated my answer.\n<|/ c |>\n<| c |>\nThanks\
    \ for the answer. But this will also fail when there is only one element in the\
    \ array. That's why I said that the algorithm should also work when there is only\
    \ one element in the array.\n<|/ c |>\n<| c |>\nHi, thanks for your answer. This\
    \ looks nice but it fails when there is only one element in the array. I've tested\
    \ it.", "  $smallest_idx = array_search(min($arr), $arr);\n  if ($smallest_idx\
    \ === false) {\n    return -1;\n  }\n  $largest = $arr[$smallest_idx];\n  for\
    \ ($i = 1; $i < count($arr); $i++) {\n    if ($arr[$i] < $smallest_idx) {\n  \
    \    return -1;\n    }\n    if ($arr[$i] > $largest) {\n      return $i;\n   \
    \ }\n    $largest = $arr[$i];\n  }\n  return $largest;\n}\n", "  $max = $arr[0];\n\
    \  for ($i = 1; $i < count($arr); $i++) {\n    if ($arr[$i] > $max) {\n      $max\
    \ = $i;\n    }\n  }\n  return $max;\n}\n\n$arr2 = array(7, 2, 3, 7, 5, 3, 6, 2,\
    \ 8, 2, 3);\n$max2 = can_arrange($arr2);\nprint \"$max2 \\n\";\n</code>\n<|/ a\
    \ |>\n<| c |>\nWhile I do agree that your code is very good, it is actually *not*\
    \ a good answer to the question.\n<|/ c |>\n<| c |>\nI wrote a PHP script which\
    \ does exactly this. The code in the answer is just an implementation of your\
    \ function.\n<|/ c |>\n<| a |>\nHere is another solution which doesn't have to\
    \ use recursion and doesn't use extra memory:\n<code>", "  if ($arr === null)\
    \ {\n    return -1;\n  }\n  $max = $arr[0]; // initialize max to first array element\n\
    \  foreach ($arr as $key => $val) {\n    if ($val >= $max) {\n      return $key;\n\
    \    }\n    $max = $val;\n  }\n  return -1;\n}", "    $i = -1;\n    $n = count($arr);\n\
    \    while ($i < $n - 1) {\n        $i += 1;\n        if ($arr[$i] <= $arr[$i\
    \ - 1]) {\n            return $i;\n        }\n    }\n    return -1;\n}\n", " \
    \ if ($arr === null || empty($arr)) {\n    return -1;\n  }\n\n  $max = max($arr);\n\
    \  foreach ($arr as $key => $val) {\n    if ($val < $max) {\n      return $key;\n\
    \    }\n  }\n\n  return -1;\n}\n", "    return max(array_keys(array_filter(\n\
    \        array_slice($arr, 0, -1),\n        function($v) use ($arr) {\n      \
    \      return $arr[$v] <= $arr[$v - 1];\n        }\n    )));\n}\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\nThe problem is that the `ksort` sorts the array itself\
    \ (as opposed to the array's elements). Hence, the solution is O(n) instead of\
    \ O(nlogn). [This article](https://hackernoon.com/the-ksort-algorithm-in-php-79e05dab7971)\
    \ talks about this.\n<|/ c |>\n<| c |>\nGood point. I have updated the answer\
    \ to show how to sort the array in O(n) time.\n<|/ c |>\n<| a dscore=1 |>\nI implemented\
    \ a solution in PHP without recursive functions, just for fun.\n<code>\n<?php\n",
  "  for ($i = 1; $i < count($arr); $i++) {\n    if ($arr[$i] >= $arr[$i - 1]) {\n\
    \      return $i;\n    }\n  }\n  return -1;\n}\n", "  // Return value of -1 indicates\
    \ that there is no such element\n  $max = array_reduce($arr, function ($carry,\
    \ $item) {\n    return max($carry, $item);\n  });\n  return $max === -1 ? -1 :\
    \ $max;\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\nYou can use array_map() to reorder\
    \ your array in such a way that its elements appear consecutively and in any order.\
    \ You can then use array_sum() to find the \"largest\" element in the array. \n\
    <code>\n$new_array = array_map(function ($x, $y) { return $x . \" \" . $y; },\
    \ array_merge($array1, $array2), array_merge($array1, $array2));\n</code>\n<|/\
    \ a tags=arrays,php,sorting |>\n<| c |>\nThank you! This was perfect. Just needed\
    \ to add \"\\n\" between each element to make it appear in same order when printed.\n\
    <|/ c |>\n<| c |>\nOh yes indeed, I'll edit the answer. Glad I could help!\n<|/\
    \ c |>\n<| a |>\nYou could use array_walk() to reorder your array and array_sum()\
    \ to find the \"largest\" element.\n<code>\n$array1 = [1, 2, 4];\n$array2 = [2,\
    \ 3, 5, 6];\n\n$array3 = array_walk($array1, function ($value, $key) use ($array2)\
    \ {\n    $array3[] = $value . \" \" . $array2[$key];\n});\n\n$array3[] = \"\\\
    n\";\n\n$largest = array_sum($array3);\n\necho \"Largest element: \" . $largest;\n\
    </code>\nOutput:\n<code>\nLargest element: 6\n</code>\n<|/ a tags=arrays,php,sorting\
    \ dscore=0 |>\n<| c |>\nThank you! Works perfectly.\n<|/ c |>\n<| a dscore=0 |>\n\
    You can use simple sort function with array_diff to find the largest number.\n\
    <code>\n$arr = [5,8,7,9,2,4,6,1,3];\n$result = array_diff($arr,array_flip($arr));\n\
    echo max($result);\n</code>\n<|/ a tags=arrays,php,sorting |>\n<| c |>\nThis doesn't\
    \ solve the problem that \"the given array will not contain duplicate values\"\
    \n<|/ c |>\n<| c |>\nThis doesn't sort anything that isn't already sorted\n<|/\
    \ c |>\n<| c |>\nThis doesn't solve the problem that \"the given array will not\
    \ contain duplicate values\"\n<|/ c |>\n<| a tags=arrays,php", "    $size = count($arr);\n\
    \    foreach ($arr as $i => $el) {\n        if ($arr[$i - 1] >= $el) {\n     \
    \       return $i;\n        }\n    }\n    return -1;\n}\n", "    foreach ($arr\
    \ as $k => $v) {\n        $newArr = array();\n        $newArr[] = $arr[$k];\n\
    \        foreach ($arr as $kk => $vv) {\n            if ($kk !== $k && !($v >=\
    \ $vv)) {\n                $newArr[] = $vv;\n            }\n        }\n      \
    \  $newArr = array_unique($newArr);\n        $newArr = array_values($newArr);\n\
    \        $newArr = array_slice($newArr);\n        $newArr = array_slice($newArr,\
    \ 0, 1);\n        if ($newArr) {\n            return count($newArr);\n       \
    \ }\n    }\n    return -1;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for\
    \ your answer but I don't get it :( I'm trying something like this:\n<|/ c |>\n\
    <| c |>\nI added a comment to explain what this code does.\n<|/ c |>\n<| c |>\n\
    So I got it :) But it returns only the first two elements. But thanks for the\
    \ answer anyway.\n<|/ c |>\n<| a |>\nTry this,\n<code>\n$arr1 = array(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20);\n\
    $arr2 = array(9,8,7,6,5,4,3,2,1,10,9,8,7,6,5,4,3,2,1,10,9,8,7,6,5,4,3,2,1);\n\n\
    $ar1 = array_slice($arr1, 0, max(count($arr1), count($arr2)));\n$ar2 = array_slice($arr2,\
    \ 0, max(count($arr1), count($arr2)));\n\narray_splice($ar1, 0, count($ar1), $ar2);\n\
    </code>\n<|/ a tags=php,arrays,sorting dscore=0 |>\n<| c |>\nThanks for your answer\
    \ but I don't get it :( I'm trying something like this:\n<|/ c |>\n<| c |>\n$arr1\
    \ = array(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20);\n$arr2 = array(9,8,7,6,5,4,3,2,1,10,9,8,7,6,5,4,3,2,1,10,9,8,7,6,5,4,3,2,1);\n\
    \n$ar1 = array_slice($arr1, 0, max(count($arr1), count($arr2)));\n$ar2 = array_slice($arr2,\
    \ 0, max(count($arr1), count($arr2)));\n\n$arr1 = array_splice($ar1, 0, count($ar1),\
    \ $ar2);\n\nprint_r($arr1);\n<|/ c |>\n<| a tags=php,arrays,", "  $sorted = array_unique($arr);\n\
    \  if (count($sorted) === count($arr) && $sorted[0] > $sorted[1]) {\n    return\
    \ -1;\n  }\n  $prev = $sorted[0];\n  foreach ($sorted as $key => $value) {\n \
    \   if ($prev >= $value) {\n      return $key;\n    }\n    $prev = $value;\n \
    \ }\n  return -1;\n}\n", "  global $arrange;\n  $arrange = null;\n\n  if (empty($arr))\
    \ {\n    return -1;\n  }\n\n  for ($i = 1; $i < count($arr); $i++) {\n    if ($arr[$i]\
    \ >= $arr[$i - 1]) {\n      return -1;\n    }\n  }\n\n  return $i - 1;\n}\n",
  "    $res = null;\n    $len = count($arr);\n    for ($i = 0; $i < $len; $i++) {\n\
    \        if ($arr[$i] <= $arr[$i - 1]) {\n            $res = $i;\n        }\n\
    \    }\n    return $res;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nIt works with\
    \ your example, but I can't use it with my data because my array contains strings\
    \ and numbers.\n<|/ c |>\n<| c |>\nWhat does \"I can't use it with my data\" mean?\
    \ Is there an error? If so, which error?\n<|/ c |>\n<| c |>\nWhen I try to run\
    \ it with an array like `array(\n  \"1\" => \"A\",\n  \"2\" => \"A\",\n  \"3\"\
    \ => \"A\",\n  \"4\" => \"B\",\n  \"5\" => \"B\",\n  \"6\" => \"B\",\n  \"7\"\
    \ => \"B\",\n  \"8\" => \"B\",\n  \"9\" => \"C\",\n  \"10\" => \"C\",\n  \"11\"\
    \ => \"C\",\n  \"12\" => \"C\",\n  \"13\" => \"D\",\n  \"14\" => \"D\",\n  \"\
    15\" => \"D\",\n  \"16\" => \"D\",\n  \"17\" => \"D\",\n  \"18\" => \"D\"\n)`\
    \ it gives me an output `1`\n<|/ c |>\n<| c |>\nOkay, then you must be passing\
    \ in a string instead, then. You have not said that. You've just said that your\
    \ \"array\" contains strings and numbers. If you have strings or numbers, you\
    \ need to turn them into numbers (e.g., `intval($a)` or such), then apply my solution.\
    \ If you don't know how that is done, please clarify your question.\n<|/ c |>\n\
    <| c |>\nNo, I have all strings except ones in my array.\n<|/ c |>\n<| a dscore=0\
    \ tags=algorithm,arrays,php,sorting |>\n<code>", "  foreach ($arr as $key => $val)\
    \ {\n    if ($arr[$key] <= $arr[$key - 1]) {\n      return $key;\n    }\n  }\n\
    \  return -1;\n}\n", "    // We will start with the first value in the array and\
    \ look backward to\n    // find the index of the first value greater than or equal\
    \ to the first\n    // value. After that we will keep looking backward and find\
    \ the index\n    // of the first value greater than or equal to the second value\
    \ and\n    // so on until we reach the beginning of the array.\n    $first = $arr[0];\n\
    \    for ($i = 1; $i < count($arr); $i++) {\n        if ($arr[$i] <= $first) {\n\
    \            return -1;\n        }\n        $first = $arr[$i];\n    }\n    return\
    \ $i;\n}\n", "    return max(array_keys($arr), function($idx) use ($arr) {\n \
    \       return $arr[$idx] <= $arr[$idx-1];\n    });\n}\n", "    $largest = -1;\n\
    \    foreach ($arr as $key => $val) {\n        if ($arr[$key] <= $largest) {\n\
    \            $largest = $key;\n        }\n    }\n    return $largest;\n}\n", " \
    \ return max($arr) - min($arr);\n}\n", "  $largestIndex = $firstIndex = null;\n\
    \  for ($i = 0; $i < count($arr); $i++) {\n    if ($arr[$i] > $arr[$largestIndex])\
    \ {\n      $largestIndex = $i;\n    }\n    if ($arr[$i] == $arr[$firstIndex])\
    \ {\n      // We haven't compared the first element of the array against the\n\
    \      // largest, so we've found a duplicate value\n      return -1;\n    }\n\
    \    $firstIndex = $arr[$i];\n  }\n\n  return $largestIndex;\n}\n", "    $l =\
    \ count($arr);\n    for ($i = 0; $i < $l - 1; $i++) {\n        if ($arr[$i] <=\
    \ $arr[$i + 1]) {\n            return $i + 1;\n        }\n    }\n    return -1;\n\
    }\n", "    $max = -1;\n    $idx = count($arr);\n    if ($idx < 2) {\n        return\
    \ $idx;\n    }\n    foreach ($arr as $i => $x) {\n        if ($x <= $arr[($i -\
    \ 1)]) {\n            return -1;\n        }\n        if ($x > $max) {\n      \
    \      $max = $x;\n        }\n    }\n    return $max;\n}\n</code>\n<|/ a tags=arrays,php\
    \ |>\n<| c |>\nCan you explain how this works? How did you know that you can `return`\
    \ at any point and how do you know that you can `return` after `foreach ($arr\
    \ as $i => $x) {` ?\n<|/ c |>\n<| c |>\nYou don't need the `return` statement\
    \ at the end, since `foreach` breaks out of the `foreach` after it is done.\n\
    <|/ c |>\n<| c |>\nThanks, I understood now. Didn't know that :)\n<|/ c |>\n<|\
    \ c |>\nI didn't know that either. It would be nice to know why this works, especially\
    \ since I don't see it mentioned in the PHP documentation about `break`.\n<|/\
    \ c |>\n<| c |>\n`foreach` loops are one of the few cases where you can do a `break`\
    \ without having to do a `return`, but this wouldn't work here.\n<|/ c |>\n<|\
    \ a tags=arrays,php |>\nHere is the short way to find the maximum element in an\
    \ array in PHP :\n<code>\n$numbers = [1, 5, 12, 13, 21];\n\n$max = $numbers[0];\n\
    \nfor($i = 1; $i < count($numbers); $i++)\n{\n    if($numbers[$i] > $max)\n  \
    \  {\n        $max = $numbers[$i];\n    }\n}\n</code>\n<|/ a dscore=5 |>\n<| c\
    \ |>\nJust a suggestion: for large arrays, this will be slower than using `array_reduce()`\
    \ - https://stackoverflow.com/a/55348478/601228\n<|/ c |>\n<| c |>\nThank you\
    \ for the link. I think this approach is much faster but my case is not as big\
    \ as you think.\n<|/ c |>\n<| c |>\nYes, I believe this approach is more efficient\
    \ for small arrays\n<|/ c |>\n<| c |>\nI agree that this approach is more efficient.\
    \ I think a big advantage of this approach is that it works even if your array\
    \ is empty, in which case it gives you an `Undefined Offset` error.\n<|/ c |>\n\
    <| c |>\nIt's not really an advantage", "  $max = reset($arr);\n  foreach ($arr\
    \ as $item) {\n    if ($item >= $max) {\n      return -1;\n    }\n    $max = $item;\n\
    \  }\n  return $max + 1;\n}\n", "    // If there are no elements then return -1\n\
    \    if (empty($arr)) {\n        return -1;\n    }\n\n    // Get the first element\n\
    \    $first = $arr[0];\n\n    // If there is only one element then return it\n\
    \    if (count($arr) === 1) {\n        return $first;\n    }\n\n    // Get the\
    \ last element\n    $last = array_pop($arr);\n\n    // Loop over each element\
    \ and compare it to the first element\n    foreach ($arr as $item) {\n       \
    \ // If the element is not greater than or equal to the first element\n      \
    \  // then return its index\n        if ($item >= $first) {\n            return\
    \ array_search($item, $arr);\n        }\n    }\n\n    // If all elements are less\
    \ than or equal to the last element then\n    // return its index\n    return\
    \ array_search($last, $arr);\n}\n", "    $max = array_shift($arr);\n    $min =\
    \ array_shift($arr);\n\n    if (!empty($arr)) {\n        $index = max($max, $arr);\n\
    \        return $index + 1;\n    } else {\n        return -1;\n    }\n}\n</code>\n\
    <|/ a tags=php,sorting,arrays,algorithm dscore=3 |>\n<| c |>\nThis one worked\
    \ for me. But I had to add a few more lines of code. Like a separate if statement.\
    \ Sorry for that.\n<|/ c |>\n<| c |>\n`array_shift()` doesn't remove the first\
    \ element of an array; it removes the first element from an array.\n<|/ c |>\n\
    <| a tags=php,sorting,arrays,algorithm |>\nOne of the most useful sorts algorithms\
    \ are merge sort and quick sort. \nBoth algorithms require an already sorted array.\
    \ In your case the array is already sorted. Merge sort requires the array to be\
    \ sorted in ascending order whereas quick sort requires the array to be sorted\
    \ in descending order. \nThe merge sort algorithm works by recursively dividing\
    \ the array into smaller chunks of size 2 to recursively sort the smaller chunks\
    \ until it no longer needs to be sorted. In the worst case scenario, all smaller\
    \ chunks will need to be merged into one chunk before another is sorted. So the\
    \ array must be sorted twice. \nThe quick sort algorithm works by recursively\
    \ dividing the array into smaller chunks of size 2 and sorting the chunks in descending\
    \ order until it no longer needs to be sorted. In the worst case scenario all\
    \ chunks will be sorted into one chunk. \nThere are multiple implementations written\
    \ in various languages. The one I wrote in C# was written in an article by Ben\
    \ Adida. \nIf you have questions about a specific implementation I can try to\
    \ answer them but there are plenty of implementations out there. I believe that\
    \ most implementations use merge sort as the default implementation. \nMerge Sort:\n\
    <code>\npublic static void MergeSort(int[] array)\n{\n    if (array == null ||\
    \ array.Length == 0)\n        return;\n    int mid = array.Length / 2;\n    MergeSort(array,\
    \ new int[mid]);\n    MergeSort(array, new int[mid]);\n    int i, j = 0;\n   \
    \ int k = 0;\n    for (i = array.Length - 1; i > 0; i--)\n    {\n        while\
    \ (j < mid && array[j] < array[j + 1])\n        {\n            array[k++] = array[j++];\n\
    \        }\n\n        while (j > mid && array[j] > array[j + 1])\n        {\n\
    \            array[k++] = array[j--];\n        }\n\n        if (j == mid)\n  \
    \          array[k++] = array[j++];\n    }\n}\n", "    $i = count($arr) - 1;\n\
    \    while($i >= 0 && !is_greater_than($arr[$i], $arr[$i - 1])) {\n        --$i;\n\
    \    }\n    return $i;\n}\n", "    $len = count($arr);\n    for ($i = 1; $i <\
    \ $len; $i++) {\n        if ($arr[$i] <= $arr[$i - 1]) {\n            return $i;\n\
    \        }\n    }\n    return -1;\n}\n", "    $keys = array_keys($arr);\n    $vals\
    \ = array_values($arr);\n    return $vals[array_search($keys[0], $keys)] + 1;\n\
    }\n\n$filename = \"input.txt\";\n$file = fopen($filename, \"r\");\n$input = explode(\"\
    \ \", fread($file, filesize($filename)));\nfclose($file);\n\n$arr = array();\n\
    \n$current_states = $states_array;\n$new_states = array();\n$all_states = array();\n\
    $final_states = array();\n$current_states_count = count($current_states);\nfor\
    \ ($current_state = 0; $current_state < $current_states_count; $current_state++)\
    \ {\n    $current_states[$current_state] = 0;\n}\n\nforeach ($input as $line)\
    \ {\n    $states_array[$line]++;\n    $new_states[$line]++;\n    if ($current_states_count\
    \ < count($current_states)) {\n        $current_states[$current_states_count]++;\n\
    \    }\n    $all_states[$current_states_count]++;\n}\n\n$states_count = count($states_array);\n\
    $all_states_count = count($all_states);\n$current_states_count = count($current_states);\n\
    \nfor ($current_state = 0; $current_state < $current_states_count; $current_state++)\
    \ {\n    $new_states[$current_state] = 0;\n}\n", "    $max = array_pop($arr);\n\
    \    $index = array_search($max, $arr);\n    if ($max <= $arr[0]) {\n        return\
    \ -1;\n    }\n    return $index;\n}\n", "  $largest = 0;\n  $pos = 0;\n  foreach($arr\
    \ as $v) {\n    if ($v > $arr[++$pos]) {\n      if ($v > $largest) {\n       \
    \ $largest = $v;\n      }\n    }\n  }\n  return $pos;\n}\n", "  $max = $arr[0];\n\
    \  for ($i = 1; $i < count($arr); $i++) {\n    if ($max <= $arr[$i]) {\n     \
    \ $max = $arr[$i];\n    }\n  }\n  return $max;\n}\n", "    $keys = array_keys($arr);\n\
    \    $min = array_shift($keys);\n    return max($keys) > $min ? -1 : $min;\n}",
  "    $res = -1;\n    foreach($arr as $key => $value) {\n        if($key <= $res)\
    \ return $key;\n        $res = $key;\n    }\n    return $res;\n}\n", "    if ($arr\
    \ == array_reverse($arr)) {\n        return count($arr) - 1;\n    }\n\n    //\
    \ Iterate through every element of the array and\n    // compare it to the previous\
    \ element which is not greater or equal to\n    // it.\n    $max = count($arr)\
    \ - 1;\n    for ($i = 0; $i < count($arr); $i++) {\n        if ($arr[$i] <= $arr[$max\
    \ - 1]) {\n            $max--;\n        }\n    }\n\n    return $max;\n}\n", " \
    \   $max_index = 0;\n    $i = 0;\n    while (isset($arr[$i])) {\n        if ($arr[$i]\
    \ > $arr[$max_index]) {\n            $max_index = $i;\n        }\n        $i++;\n\
    \    }\n    return $max_index;\n}\n", "    if (count($arr) == 0) return -1;\n\
    \    $largest = -1;\n    $prev = null;\n    foreach ($arr as $k => $v) {\n   \
    \     if ($prev >= $k) {\n            return -1;\n        }\n        if ($largest\
    \ < $k) {\n            $largest = $k;\n        }\n        $prev = $k;\n    }\n\
    \    return $largest;\n}", "  $max = max($arr);\n  foreach ($arr as $key => $val)\
    \ {\n    if ($val == $max) {\n      return $key;\n    }\n  }\n  return -1;\n}\n",
  "    if (empty($arr)) return -1;\n    $last = count($arr) - 1;\n    $ret = $last;\n\
    \    foreach ($arr as $key => $val) {\n        if ($val >= $arr[$last - 1]) {\n\
    \            $ret = -1;\n            break;\n        }\n    }\n    return $ret;\n\
    }\n", "  $largest = 0;\n  foreach ($arr as $key => $value) {\n    if ($key > $largest)\
    \ {\n      $largest = $key;\n    }\n  }\n  return $largest === count($arr) - 1\
    \ ? -1 : max($largest, $arr[0]);\n}\n", "    $max_index = -1;\n    foreach ($arr\
    \ as $element) {\n        if ($element >= $max_index and $element != $max_index)\
    \ {\n            $max_index = $element;\n        }\n    }\n    return $max_index;\n\
    }\n", "  for ($i = 0; $i < count($arr); $i++) {\n    for ($j = $i; $j < count($arr);\
    \ $j++) {\n      if ($arr[$j] >= $arr[$i]) {\n        if ($arr[$j] == $arr[$i])\
    \ {\n          return -1;\n        }\n        return $j;\n      }\n    }\n  }\n\
    \  return -1;\n}\n", "  $index = $prev = null;\n  foreach ($arr as $k => $v) {\n\
    \    if ($prev < $k) $index = max($k, $index);\n    $prev = $k;\n  }\n  return\
    \ $index;\n}", "    $i = 1;\n    $max = -1;\n    while ($i < count($arr)) {\n\
    \        if ($arr[$i] <= $arr[$max]) {\n            $max = $i;\n        }\n  \
    \      $i++;\n    }\n    return $max;\n}\n", "  $maxIndex = -1;\n  foreach ($arr\
    \ as $key => $value) {\n    $maxIndex = ($maxIndex < $key) ? $key : $maxIndex;\n\
    \  }\n  return $maxIndex;\n}\n", "  $i = -1;\n  foreach ($arr as $item) {\n  \
    \  if ($item >= $arr[$i - 1]) {\n      $i = $item;\n    }\n  }\n  return $i;\n\
    }\n", "  if (!is_array($arr)) {\n    return -1;\n  }\n  for ($i = 0; $i < count($arr);\
    \ $i++) {\n    if ($arr[$i] > $arr[$i - 1]) {\n      return $i;\n    }\n  }\n\
    \  return -1;\n}\n", "    foreach ($arr as $index => $value) {\n        if ($value\
    \ <= $arr[$index - 1]) {\n            return $index;\n        }\n    }\n    return\
    \ -1;\n}", "    $len = count($arr);\n    if ($len < 2) {\n        return -1;\n\
    \    }\n    $largest = array_shift($arr);\n    $return = $largest;\n    foreach\
    \ ($arr as $key => $val) {\n        if ($val >= $largest) {\n            $largest\
    \ = $val;\n            $return = $key;\n        }\n    }\n    return $return;\n\
    }\n", "  if (!$arr) {\n    return -1;\n  }\n  $first = array_shift($arr);\n  if\
    \ ($first > $arr[0]) {\n    return -1;\n  }\n  $last = array_pop($arr);\n  if\
    \ ($last < $arr[0]) {\n    return -1;\n  }\n  for ($i = 2; $i < count($arr); $i++)\
    \ {\n    if ($arr[$i] == $arr[$i - 1]) {\n      return $i;\n    }\n  }\n  return\
    \ -1;\n}\n", "    $maxIndex = -1;\n    for ($i = 1; $i < count($arr); $i++) {\n\
    \        if ($arr[$i] > $arr[$maxIndex]) {\n            $maxIndex = $i;\n    \
    \    }\n    }\n    return $maxIndex;\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2\
    \ |>\nIf you don't have to use PHP to do this, you can use Sed/Awk to do this.\
    \  Just pipe the output from one to the other and it will give you the longest\
    \ sequence:\n<code>\n$ echo {1..500} | sed 's/./&,/g' | awk -F, '{if(length($1)>length($2))\
    \ print \"$1 $2\"; else print \"$2 $1\"; }'\n1,4 2,5 3,6 4,7 5,8 6,9 7,10 8,11\
    \ 9,12 10,13 11,14 12,15 13,16 14,17 15,18 16,19 17,20 18,21 19,22 20,23 21,24\
    \ 22,25 23,26 24,27 25,28 26,29 27,30 28,31 29,32 30,33 31,34 32,35 33,36 34,37\
    \ 35,38 36,39 37,40 38,41 39,42 40,43 41,44 42,45 43,46 44,47 45,48 46,49 47,50\
    \ 48,51 49,52 50,53 51,54 54,55 55,56 56,57 57,58 58,59 59,60 60,61 61,62 62,63\
    \ 63,64 64,65 65,66 66,67 67,68 68,69 69,70 70,71 71,72 72,73 73,74 74,75 75,76\
    \ 76,77 77,78 78,79 79,80 80,81 81,82 82,83 83,84 84,85 85,86 86,87 87,88 88,89\
    \ 89,90 90,91 91,92 92,93 93,94 94,95 95,96 96,97 97,98 98,99 99,100 100,101 101,102\
    \ 102,103 103,104 104,105 105,106 106,107 107,108 108,109 109,110 110,111 111,112\
    \ 112,113 113,114 114,115 115,116 116,11", "    return array_search($arr[0], array_reverse($arr))\
    \ !== false ? $arr[0] : -1;\n}\n", "    if (empty($arr)) {\n        return -1;\n\
    \    }\n    if (count($arr) > 1) {\n        $last = array_pop($arr);\n       \
    \ return array_search($last, $arr);\n    }\n    return array_search(array_pop($arr),\
    \ $arr);\n}\n</code>\n<|/ a tags=arrays,sorting,php |>\n<| a |>\n<code>\n<?php",
  "  $result = -1;\n  $j = 0;\n  $highest = 1;\n  foreach ($arr as $k) {\n    if ($k\
    \ > $highest) {\n      $result = $j;\n      $highest = $k;\n    }\n    $j++;\n\
    \  }\n  return $result;\n}\n</code>\n<|/ a dscore=2 tags=algorithm,arrays,php\
    \ |>\n<| a dscore=1 |>\n<code>\npublic function largestNotGreaterThan($numbers)\n\
    {\n    $max = 0;\n\n    foreach($numbers as $number)\n    {\n        if($number\
    \ > $max)\n        {\n            $max = $number;\n        }\n    }\n\n    foreach($numbers\
    \ as $number)\n    {\n        if($number > $max)\n        {\n            $max\
    \ = $number;\n        }\n    }\n    return $max;\n}\n</code>\n<|/ a tags=algorithm,arrays,php\
    \ |>\n<| a |>\nHere is a simple solution that I wrote with PHP:\n<code>", "  \
    \  $arr = array_reverse($arr);\n    $max = -1;\n    $min = 0;\n    foreach ($arr\
    \ as $key => $value) {\n        if ($max < $value && $value >= $min) {\n     \
    \       $max = $value;\n            $maxidx = $key;\n        }\n    }\n    return\
    \ ($maxidx > 0) ? $maxidx : -1;\n}\n</code>\n<|/ a dscore=0 tags=algorithm,sorting,php\
    \ |>\n<| a dscore=0 |>\nUse a for loop and a variable as your array index:\n<code>",
  "  for ($i = 1; $i < count($arr); $i++) {\n    if ($arr[$i] > $arr[$i - 1]) {\n\
    \      return $i;\n    }\n  }\n  return -1;\n}\n</code>\n<|/ a |>\n<| c |>\nThanks\
    \ this is exactly what i was looking for :)\n<|/ c |>\n<| a dscore=2 |>\nHere\
    \ is a php version for this using RecursiveIteratorIterator with array_filter:\n\
    <code>\n$a1 = array(1,2,4,3,5);\n$a2 = array(2,3,4,5,1,3);\n$a3 = array(2,3,4,5,6);\n\
    \n$it = new RecursiveIteratorIterator(new RecursiveArrayIterator($a1));\n$it->attachIterator(new\
    \ RecursiveArrayIterator($a2));\n$it->attachIterator(new RecursiveArrayIterator($a3));\n\
    \n$array = array_filter(iterator_to_array($it), function($i){\n    return ($i\
    \ > 1 );\n});\nprint_r($array);\n</code>\nOutput:\n<code>\nArray\n(\n    [0] =>\
    \ 2\n    [1] => 3\n    [2] => 4\n)\n</code>\nThis also works for mixed arrays:\n\
    <code>\n$a1 = array(1,2,4,3,5);\n$a2 = array(2,3,4,5,1,3, array('hello', 'world',\
    \ array(1,2,3,4,5)), array('hello', 'world', array(1,2,3,4,5), array(1,2)));\n\
    \n$it = new RecursiveIteratorIterator(new RecursiveArrayIterator($a1));\n$it->attachIterator(new\
    \ RecursiveArrayIterator($a2));\n\n$array = array_filter(iterator_to_array($it),\
    \ function($i){\n    return ($i > 1 );\n});\nprint_r($array);\n</code>\nOutput:\n\
    <code>\nArray\n(\n    [0] => 2\n    [1] => 3\n    [2] => 4\n    [3] => 5\n)\n\
    </code>\n<|/ a tags=arrays,algorithm,php |>\n<| c |>\nThanks for your help. This\
    \ does exactly what i was looking for. :)\n<|/ c |>\n<| a tags=arrays,algorithm,php\
    \ |>\n<code>\n<?php\n$a1 = array(1,2,4,3,5);\n$a2 = array(2,3,4,5,1,3);\n$a3 =\
    \ array(2,3,4,5,6);\n\n$arr1 = $a1;\n$arr2 = $a2;\n$arr3 = $a3;\n\n$arr = [$arr1,$arr2,$arr3];\n\
    \n$length = count($arr);\n$result = -1;\n\nfor($i=0;$i<$length;$i++){\n    if($i==0){\n\
    \        if(", "\t$smallest = min($arr);\n\t$largest = max($arr);\n\t$prev_smallest\
    \ = $smallest;\n\t$prev_largest = $largest;\n\tforeach ($arr as $val) {\n\t\t\
    if ($val != $smallest) {\n\t\t\tif ($val < $prev_smallest + 1) {\n\t\t\t\t$prev_smallest\
    \ = $val;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\
    }\n\t\tif ($val > $largest) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn $largest;\n\
    }\n", "    $max = count($arr)-1;\n    for ($i = 0; $i < count($arr); $i++) {\n\
    \        $x = $arr[$i];\n        if ($x > $max) {\n            return $x;\n  \
    \      }\n    }\n    return -1;\n}", "    return max(array_filter($arr, function\
    \ ($a) {\n        return $a < $arr[0];\n    }));\n}\n", "  $maxIdx = 0;\n  $maxElem\
    \ = $arr[0];\n  for ($i = 1; $i < count($arr); $i++) {\n    if ($maxElem >= $arr[$i])\
    \ {\n      $maxElem = $arr[$i];\n      $maxIdx = $i;\n    }\n  }\n  return $maxIdx;\n\
    }\n", "    $highest = 0;\n    $largest = -1;\n    foreach ($arr as $v) {\n   \
    \     if ($highest < $v) {\n            $highest = $v;\n        }\n        if\
    \ ($largest < $v) {\n            $largest = $v;\n        }\n    }\n    return\
    \ $largest;\n}\n", "  // Keep track of the largest index we've seen\n  $largest\
    \ = -1;\n  // Keep track of the last element we've seen\n  $last_seen = -1;\n\
    \  // Go through each element of the array\n  for ($i = 0; $i < count($arr); $i++)\
    \ {\n    // If we see a new value less than the current largest value\n    if\
    \ ($arr[$i] <= $last_seen) {\n      // Then we know we can't arrange this\n  \
    \    return -1;\n    }\n    // Set the new largest and last seen values\n    $largest\
    \ = $i;\n    $last_seen = $arr[$i];\n  }\n  return $largest;\n}\n", "    // Write\
    \ your PHP implementation\n    $highest = 0;\n    $lowest  = PHP_INT_MAX;\n  \
    \  foreach ($arr as $val) {\n        if ($val <= $lowest) {\n            $lowest\
    \ = $val;\n        } else if ($val >= $highest) {\n            $highest = $val;\n\
    \        }\n    }\n    return ($lowest === PHP_INT_MAX) ? -1 : (int) $highest;\n\
    }\n</code>\n<|/ a tags=php,algorithm dscore=0 |>\n<| a tags=php,algorithm |>\n\
    We can also do this using only 1 loop. Assuming we are starting from index 0.\
    \ \n<code>\n$minIndex=array();\n$maxIndex=array();\n$count=0;\nfor($i=0;$i<count($arr);$i++){\n\
    \    if($i!=0){\n        if($arr[count($arr)-1>$arr[$i-1]){\n            $count=0;\n\
    \            $minIndex[$i]=$minIndex[$i-1]+$count;\n            $maxIndex[$i]=$minIndex[$i-1]+$count;\n\
    \        }else{\n            $count++;\n            $minIndex[$i]=$minIndex[$i-1]+$count;\n\
    \        }\n    }else{\n        $count++;\n        $minIndex[$i]=$count;\n   \
    \ }\n}\n</code>\n$minIndex is your min and $maxIndex is your max and $arr is the\
    \ array to be sorted.\n<|/ a dscore=0 |>\n<| a |>\nThis is O(N) time complexity\
    \ as per my knowledge\n<code>\n<?php", "    return max_idx(\n        array_flip($arr),\n\
    \        function ($i, $arr) {\n            return ($arr[$i] <= $arr[$i - 1])\
    \ ? $i - 1 : -1;\n        }\n    );\n}\n", "  $max = -1;\n  $max_idx = -1;\n \
    \ foreach ($arr as $key => $value) {\n    if ($key >= $max && $value <= $arr[$key\
    \ - 1]) {\n      $max = $key;\n      $max_idx = $key;\n    }\n  }\n  return $max_idx;\n\
    }\n", "  // Return immediately if the array is empty.\n  if (!is_array($arr) ||\
    \ empty($arr)) {\n    return -1;\n  }\n\n  $first = reset($arr);\n  $last = end($arr);\n\
    \n  foreach ($arr as $key => $value) {\n    if ($value >= $first) {\n      if\
    \ ($value > $last) {\n        return $key;\n      }\n\n      return $key;\n  \
    \  }\n  }\n\n  return -1;\n}\n</code>\n<|/ a dscore=1 |>\n<| a |>\nThis is my\
    \ solution. I believe it is short and readable with O(n) time complexity.\n<code>\n\
    <?php", "    $largest = -1;\n    $first = true;\n    foreach ($arr as $k => $v)\
    \ {\n        if ($first && $largest < $k) {\n            $largest = $k;\n    \
    \    } else {\n            $first = false;\n        }\n    }\n    return $largest;\n\
    }\n", "    if (is_array($arr)) {\n        $sorted = array();\n        foreach\
    \ ($arr as $key => $item) {\n            if ($item >= $sorted[$key - 1]) {\n \
    \               continue;\n            }\n            array_push($sorted, $item);\n\
    \        }\n        $last = array_pop($sorted);\n        return $last < 1 ? -1\
    \ : count($sorted);\n    }\n    return -1;\n}\n</code>\n<|/ a |>\n<| a tags=sorting,php\
    \ |>\n<code>\n<?php\n$arr=[4,5,6,7,8,9];\n\n$max=($arr[0]);\nfor ($i=1;$i<count($arr);$i++)\
    \ {\n    if($arr[$i]>$max) {\n        $max=$arr[$i];\n    }\n}\n\necho $max;",
  "    $prev = $arr[0];\n    foreach ($arr as $v) {\n        if ($prev <= $v) {\n\
    \            $prev = $v;\n        }\n    }\n    return $prev;\n}", "    $max =\
    \ $i;\n    for ($i = 1; $i < count($arr); $i++) {\n        if ($arr[$i] > $arr[$max])\
    \ {\n            $max = $i;\n        }\n    }\n    return $max;\n}\n", "    //\
    \ Find the largest index less than or equal to the current index.\n    $l = array_search($arr[$i],\
    \ $arr);\n    if ($l !== false) {\n        // Find the largest index less than\
    \ or equal to the current index.\n        $r = array_search($arr[$i], $arr, $l);\n\
    \        // If the current index is the largest index then return it immediately.\n\
    \        if ($r === $l)\n            return $l;\n        // Otherwise compare\
    \ it to the previous index.\n        else\n            return $r;\n    }\n   \
    \ // Return -1 if the current index is not less than or equal to the array\n \
    \   // length.\n    return -1;\n}", "    return max(array_keys($arr, max($arr)));\n\
    }\n", "  $largest = -1;\n  $largestElement = -1;\n  $largestPrevious = -1;\n \
    \ foreach ($arr as $key => $val) {\n    if ($val > $largestElement) {\n      $largestElement\
    \ = $val;\n      $largest = $key;\n    }\n    if ($val > $largestPrevious) {\n\
    \      $largestPrevious = $val;\n    }\n  }\n  return $largest;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThanks, this works like a charm for the example provided. However,\
    \ I don't see how this works when the array isn't sorted.\n<|/ c |>\n<| a dscore=1\
    \ tags=php,arrays |>\n<code>\n<?php\n    $array1 = array(1,2,3,4,5,6,7,8,9,0);\n\
    \    $array2 = array(3,4,5,6,7,8,9,0,1,2,3);\n    $array3 = array(2,3,4,5,6,7,8,9,0,1,2,3);\n\
    \n    for($i = count($array1); $i >= 0; $i--){\n        if($array1[$i] > $array2[$i]\
    \ OR $array1[$i] > $array3[$i]){\n            $temp = $array1[$i];\n         \
    \   $array1[$i] = $array2[$i];\n            $array2[$i] = $array3[$i];\n     \
    \       $array3[$i] = $temp;\n        }\n    }\n    print_r($array1);\n    print_r($array2);\n\
    \    print_r($array3);", "    // First find the index (key) of the last element\
    \ which is not greater\n    // than or equal to the first element. If there is\
    \ no 'first' element or\n    // its index equals 0 then there is no such element,\
    \ so return -1.\n    $index = array_keys($arr);\n    if ($index[0] === 0 || $index[0]\
    \ === false) {\n        return -1;\n    }\n    for ($i = 0; $i <= $index[0]; ++$i)\
    \ {\n        if ($arr[$i] > $arr[$index[$i]]) {\n            $prev = $index[$i];\n\
    \            break;\n        }\n    }\n    return $prev;\n}\n", "    $largest\
    \ = -1;\n    $current = -1;\n    foreach($arr as $value) {\n        if ($value\
    \ > $largest) {\n            $largest = $value;\n            $current = $value;\n\
    \        }\n    }\n    return $current;\n}\n", "    $maxVal = count($arr);\n \
    \   foreach ($arr as $key => $val) {\n        if ($val > $maxVal) {\n        \
    \    $maxVal = $val;\n        }\n    }\n\n    return $maxVal;\n}\n", "    // Write\
    \ your code here\n    $max = 0;\n    foreach($arr as $key => $value) {\n     \
    \   if($arr[$key] > $max && $key != 0) {\n            $max = $key;\n        }\n\
    \    }\n    return $max;\n}\n", "    foreach ($arr as $k => $v) {\n        if\
    \ ($k != 0 && $arr[$k-1] >= $v) {\n            return $k;\n        }\n    }\n\
    \    return -1;\n}", "    // Start at the end\n    $max = -1;\n    for ($i = count($arr)\
    \ - 2; $i >= 0; $i--) {\n        if ($arr[$i] <= $arr[$i + 1]) {\n           \
    \ $max = $i;\n        }\n    }\n    return $max;\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| a tags=php,arrays,permutation |>\nI have written a very simple and efficient\
    \ solution for this. Hope that helps.\n<code>", "  // Sort the array by the element\
    \ immediately preceding it, i.e. if we\n  // sort by 5 the array will be arranged\
    \ so that the 5th element is\n  // immediately before the 5th element of the sorted\
    \ array.\n  arsort($arr);\n  // Now find the lowest index of an element which\
    \ is less than or equal to\n  // the element immediately preceding it. If there\
    \ is no such element\n  // then return -1\n  for ($i = 0; $i < count($arr) - 1;\
    \ $i++) {\n    if ($arr[$i] <= $arr[$i + 1]) {\n      return $i;\n    }\n  }\n\
    \  return -1;\n}\n", "  if (count($arr) <= 0) return -1;\n  $last_elem = array_pop($arr);\n\
    \  $highest_idx = array();\n  foreach ($arr as $val) {\n    $highest_idx[$val]\
    \ = $val == $last_elem ? -1 : $val > $last_elem ? $val : $highest_idx[$val];\n\
    \  }\n  return count($highest_idx) == count($arr) ? reset($highest_idx) : -1;\n\
    }\n\n/**\n * Returns a string with the HTML content of the element.\n * If the\
    \ $attrs parameter is omitted, the HTML attributes of the element\n * are returned.\n\
    \ *\n * @param DOMElement $elem The element to return HTML content for\n * @param\
    \ array      $attrs Optional, the HTML attributes of the element\n *\n * @return\
    \ string The string generated from the element's HTML\n */", "    for($i = 1;\
    \ $i < count($arr); $i++) {\n        if($arr[$i] <= $arr[$i - 1]) {\n        \
    \    return $i;\n        }\n    }\n    return -1;\n}", "    $max_index = -1;\n\
    \    foreach ($arr as $key => $value) {\n        if ($max_index < $key && $value\
    \ <= $arr[$key - 1]) {\n            $max_index = $key;\n        }\n    }\n   \
    \ return $max_index;\n}\n", "    $len = count($arr);\n    $result = 0;\n    for\
    \ ($i = 0; $i < $len; $i++) {\n        for ($j = $i + 1; $j < $len; $j++) {\n\
    \            if ($arr[$j] > $arr[$i]) {\n                $result = max($i, $j);\n\
    \            }\n        }\n    }\n    return $result;\n}", "  // Get index of\
    \ first element that does not have a value greater than or\n  // equal to the\
    \ element immediately preceding it.\n  $first = array_search($arr[0], $arr);\n\
    \  if ($first == false) $first = count($arr);\n  return $first;\n}\n", "    $size\
    \ = count($arr);\n    $highest = 0;\n    $smallest = $size - 1;\n    foreach ($arr\
    \ as $index => $item) {\n        if ($index == $smallest || $item >= $arr[$index\
    \ - 1]) {\n            $smallest = $index;\n        } else if ($index > $smallest\
    \ && $item > $arr[$index - 1]) {\n            $smallest = $index;\n          \
    \  $highest = $index;\n        }\n    }\n    return $highest + 1;\n}\n</code>\n\
    <|/ a tags=arrays,arraylist,sorting,php,algorithmic-traversal |>\n<| c |>\nThis\
    \ is very nice. Thanks!\n<|/ c |>\n<| c |>\nI love the fact that people like you\
    \ guys make StackOverflow the best place to learn stuff like this.\n<|/ c |>\n\
    <| c |>\nThis solution works great for me!\n<|/ c |>\n<| a dscore=5 |>\nThis worked\
    \ for me.  \n<code>", "  global $can;\n  $n = sizeof($arr);\n  $can = 0;\n  for($i=0;\
    \ $i<$n; $i++) {\n    $cur = $arr[$i];\n    if($i == 0 || $cur >= $arr[$i-1])\
    \ {\n      $can = $cur;\n    } else {\n      break;\n    }\n  }\n  return $can;\n\
    }\n\n/**\n * Find the sum of all the elements in the given array and return the\
    \ sum of\n * the elements in the given array. If no such element exists then return\
    \ 0.\n * The given array will not contain duplicate values.\n * Examples:\n *\
    \ >>> sum1(array(1, 2, 4, 3, 5))", "  $largest = 0;\n  for ($i = 1; $i < count($arr);\
    \ $i++) {\n    if ($arr[$i] <= $arr[$largest]) {\n      $largest = $i;\n    }\n\
    \  }\n  return ($largest == 0) ? -1 : $largest;\n}\n</code>\n<|/ a |>\n<| a dscore=0\
    \ tags=php |>\nI wrote a simple function that will return the largest value in\
    \ a given array. I hope you find it useful:\n<code>", "  $max = array_reduce($arr,\
    \ function ($max, $el) {\n    return $max > $el ? $max : $el;\n  }, -1);\n  return\
    \ $max > -1 ? $max : -1;\n}\n", "  for ($i = 0; $i < count($arr); ++$i) {\n  \
    \  $cur = $arr[$i];\n    for ($j = $i+1; $j < count($arr); ++$j) {\n      if ($cur\
    \ <= $arr[$j]) {\n        break;\n      }\n    }\n    if ($j === count($arr))\
    \ {\n      return $cur;\n    }\n  }\n  return -1;\n}\n", "    if (!is_array($arr))\
    \ {\n        return -1;\n    }\n    $sorted = $arr;\n    sort($sorted);\n    foreach\
    \ ($sorted as $value) {\n        if ($value < $sorted[0]) {\n            return\
    \ -1;\n        }\n    }\n    return 0;\n}\n\n$input = array(\"a\",\"b\",\"c\"\
    ,\"d\",\"e\",\"f\",\"g\");\nvar_dump(can_arrange($input));\n</code>\n<|/ a |>\n\
    <| c |>\nYou don't need `if (!is_array($arr))`, since `array_filter` will do that\
    \ for you.  You can also use `true` instead of `$arr`, but you don't need to do\
    \ that either\n<|/ c |>\n<| c |>\nyeah, thanks. I actually tried that but got\
    \ syntax errors with `true` so I opted to use an explicit check.\n<|/ c |>\n<|\
    \ c |>\nYou don't even need `$arr` at all, `array_filter` will take care of that\n\
    <|/ c |>\n<| c |>\nThanks everyone. As always, all solutions provided here are\
    \ great. I'd like to give credit to all answers here, as they all address the\
    \ same issue of finding the largest index without using sort() and looping. This\
    \ one seems to be the most efficient solution, although it also has room for improvement\
    \ with the use of array_reduce() instead of array_filter().\n<|/ c |>\n<| a dscore=1\
    \ tags=sorting,arrays,php |>\nI like this one:\n<code>\n$input = array(\"a\",\"\
    b\",\"c\",\"d\",\"e\",\"f\",\"g\");\n$result = [];\n$current = $result;\n$keys\
    \ = array_keys($input);\n$count = count($input);\nfor($i = 0; $i < $count; $i++)\
    \ {\n  if($i < $keys[count($keys) - 1]) {\n    $current = $input[$keys[$i]];\n\
    \  } else {\n    $current['max'] = $input[$i];\n  }\n  $current['index'] = $i;\n\
    \  array_push($result, $current);\n}\n</code>\nIt uses the keys to make an associative\
    \ array of the input array, then loops through each element and compares with\
    \ the next element. If next element is smaller than the current one, it adds the\
    \ current element to the result array. Otherwise, it adds the current element\
    \ to the result array and sets max property of the last element of the result\
    \ array to current element.\n<|/ a |>\n<| a tags=sorting,arrays,php |>\nNot sure\
    \ how efficient this is, but here's how I'd do it:\n<code>\n$input = array(\"\
    a\",\"b", "    $max_index = -1;\n    $max_value = -1;\n\n    // Loop through each\
    \ element in the array and compare it to the\n    // previous element. If this\
    \ is less than or equal to the previous element\n    // then store the new value\
    \ as the max index.\n    foreach ($arr as $i => $element) {\n        if ($element\
    \ <= $max_value) {\n            // The element at this index is not greater than\
    \ the previous\n            // element, so no more comparisons need to be made.\n\
    \            $max_value = $element;\n            $max_index = $i;\n        }\n\
    \    }\n\n    return $max_index;\n}\n", "    $last_index = count($arr);\n\n  \
    \  // Check all elements and see if we are in range\n    foreach ($arr as $index\
    \ => $element) {\n        if ($index < $last_index) {\n            if ($element\
    \ >= $arr[$index]) {\n                $last_index = $index;\n            }\n \
    \       }\n    }\n\n    // All elements must be in range\n    return $last_index;\n\
    }\n", "    $arr = array_reverse($arr);\n    $index = 0;\n    foreach ($arr as\
    \ $value) {\n        if (($value = array_search($value, $arr)) === false) {\n\
    \            return $index;\n        }\n        $index = $value - 1;\n    }\n\
    \    return -1;\n}\n", "  for ($i = 0; $i < count($arr) - 1; $i++) {\n    if ($arr[$i]\
    \ <= $arr[$i + 1]) {\n      return $i;\n    }\n  }\n  return -1;\n}\n", "  $l\
    \ = count($arr);\n  for($i = 1; $i < $l; $i++) {\n    if ($arr[$i] < $arr[$i -\
    \ 1]) {\n      return $i;\n    }\n  }\n  return -1;\n}\n", "    $ret = -1;\n \
    \   $largest = 0;\n    $max = $arr[0];\n\n    foreach ($arr as $i => $x) {\n \
    \       if ($x > $max) {\n            $max = $x;\n            $ret = $i;\n   \
    \     }\n    }\n\n    return $ret;\n}\n", "  $max = max($arr);\n  return array_search($max,\
    \ $arr) !== false ? array_search($max, $arr) + 1 : 0;\n}\n", "    $largest = -1;\n\
    \    $i = 0;\n    foreach ($arr as $value) {\n        if ($value < $arr[++$i])\
    \ {\n            return $i;\n        }\n        if ($value > $largest) {\n   \
    \         $largest = $value;\n        }\n    }\n    return $largest;\n}\n</code>\n\
    In order to be able to do this, I needed to have a way of sorting an array in\
    \ descending order. I chose to use the PHP array_multisort function. That function\
    \ can take 2 arrays of data, the keys and the values, and sort them both in ascending\
    \ or descending order. The sort function also takes a third optional parameter,\
    \ which is an associative array containing the sorting key for each element in\
    \ the second array:\n<code>\n<?php", "    if (count($arr) == 0) return -1;\n \
    \   $last = array_pop($arr);\n    foreach ($arr as $a) {\n        if ($a < $last)\
    \ {\n            return -1;\n        }\n        if ($a >= $last) return $last\
    \ - $a + 1;\n    }\n    return 0;\n}\n", "    $min = min($arr);\n    $max = max($arr);\n\
    \n    if ($min == $max) {\n        return $min;\n    }\n\n    $index = array_search($max,\
    \ $arr);\n\n    if ($index === false) {\n        return -1;\n    }\n\n    return\
    \ $index;\n}\n", "  $largest = $arr[0];\n  for ($i = 1; $i < count($arr); $i++)\
    \ {\n    if ($arr[$i] > $largest) {\n      $largest = $arr[$i];\n    }\n  }\n\
    \  return $largest;\n}\n", "    $max = -1;\n    $len = count($arr);\n    for ($i\
    \ = 0; $i < $len; $i++) {\n        if ($arr[$i] <= $arr[$max]) {\n           \
    \ $max = $i;\n        }\n    }\n    return $max;\n}\n$max = can_arrange($array);",
  "    $previous = array_shift($arr);\n    return array_search($previous, $arr);\n\
    }\n", "    $highest_index = -1;\n    for ($i = 0; $i < count($arr); $i++) {\n\
    \        if ($arr[$i] <= $highest_index) {\n            continue;\n        }\n\
    \        if ($highest_index >= 0) {\n            return -1;\n        }\n     \
    \   $highest_index = $arr[$i];\n    }\n    return $highest_index;\n}\n"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
