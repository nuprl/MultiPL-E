name: HumanEval_11_string_xor
language: php
prompt: "<?php\n// Input are two strings a and b consisting only of 1s and 0s.\n//\
  \ Perform binary XOR on these inputs and return result also as a string.\n// >>>\
  \ string_xor(\"010\", \"110\")\n// \"100\"\nfunction string_xor($a, $b) {\n"
tests: "function candidate(...$args) {\n    return string_xor(...$args);\n}\n\nfunction\
  \ test(): void {\n    if (candidate(\"111000\", \"101010\") !== \"010010\") { throw\
  \ new Exception(\"Test failed!\"); }\n    if (candidate(\"1\", \"1\") !== \"0\"\
  ) { throw new Exception(\"Test failed!\"); }\n    if (candidate(\"0101\", \"0000\"\
  ) !== \"0101\") { throw new Exception(\"Test failed!\"); }\n}\n\ntest();"
completions: ["    $c = str_split($a);\n    $d = str_split($b);\n    $result = \"\"\
    ;\n    foreach ($c as $key => $val) {\n        $result[$key] = chr(ord($val) ^\
    \ ord($d[$key]));\n    }\n    return implode('', $result);\n}\n", "  $ret = str_pad('',\
    \ max(strlen($a), strlen($b)), '0');\n  for ($i = 0; $i < strlen($a); $i++) {\n\
    \    $ret[$i] = $a[$i] ^ $b[$i];\n  }\n  return $ret;\n}\n", "  return  bin2hex(bin2dec($a)\
    \ ^ bin2dec($b));\n}\n", "  $result = '';\n  for ($i = 0; $i < strlen($a) && $i\
    \ < strlen($b); $i++) {\n    if (ord($a[$i]) ^ ord($b[$i])) {\n      $result .=\
    \ chr(0);\n    } else {\n      $result .= $a[$i];\n    }\n  }\n  return $result;\n\
    }\n", "  $xor = str_pad('', max(strlen($a), strlen($b)), '0');\n  for ($i = 0;\
    \ $i < max(strlen($a), strlen($b)); ++$i) {\n    $xor[$i] = $a[$i] ^ $b[$i];\n\
    \  }\n  return $xor;\n}", "  return bin2hex(bin2hex(~bin2hex($a) ^ $b));\n}\n\
    </code>\nThis should be simple and fast enough for what you're doing.\n<|/ a dscore=0\
    \ tags=bitwise-operators,xor,php |>\n<| a |>\n<code>\n<?php", "    $a = intval($a);\n\
    \    $b = intval($b);\n    if ($a == 0 || $b == 0) {\n        return \"0\";\n\
    \    }\n    $result = '';\n    $carry = 0;\n    while ($a || $b) {\n        $result\
    \ = $carry . $result . $b&~$a;\n        $a = $b&~$a;\n        $b = $carry & $b;\
    \ // Shift left 1 bit\n        $carry = ($carry << 1) & 0xff; // Shift right 1\
    \ bit\n    }\n    return $result;\n}\n", "    return base_convert(bin2hex(base_convert($a\
    \ ^ $b, 2, 16)), 16, 2);\n}\n", "    $a1 = str_pad($a, 8, '0', STR_PAD_LEFT);\n\
    \    $b1 = str_pad($b, 8, '0', STR_PAD_LEFT);\n    $result = str_pad(\n      \
    \  bin2hex(\n            call_user_func(\n                'pack',\n          \
    \      'H*', // Hex format is used for binary input.\n                $a1 ^ $b1\n\
    \            )\n        ),\n        8,\n        '0',\n        STR_PAD_LEFT\n \
    \   );\n    return $result;\n}\n", "  // Convert strings to integer representations\
    \ of 1 and 0.\n  $a_int = str_split($a);\n  $b_int = str_split($b);\n  // Create\
    \ array of bits that differs in both strings and sum them.\n  $a_diffs = array_map(\n\
    \    function($a) { return (1 ^ $a); },\n    $a_int\n  );\n  $b_diffs = array_map(\n\
    \    function($b) { return (1 ^ $b); },\n    $b_int\n  );\n  // Return XOR of\
    \ bits that differs in both strings\n  return implode(array_filter($a_diffs),\
    \ array_filter($b_diffs));\n}\n</code>\n<|/ a dscore=2 tags=xor,php,string |>\n\
    <| c |>\nGreat solution.  My use case is slightly different (but still pretty\
    \ useful).  I'm working with a hash and need to XOR some portion of that hash\
    \ with the original.  The only thing I can think of is to split the string into\
    \ smaller strings and XOR those strings together, but that would be a pain to\
    \ have to reproduce it all the time.  Thanks!\n<|/ c |>\n<| a |>\nThis is my solution:\n\
    <code>", "  return bin2hex(bin2hex($a) ^ bin2hex($b));\n}\n", "    if (strlen($a)\
    \ != strlen($b))\n        throw new \\Exception('String lengths must match');\n\
    \    $c = \"\";\n    for ($i = 0; $i < strlen($a); $i++) {\n        $c .= $a[$i]\
    \ ^ $b[$i];\n    }\n    return $c;\n}\n</code>\n<|/ a |>\n<| c |>\nNote that your\
    \ PHP version may already have this functionality in place already. See [my answer](https://stackoverflow.com/a/52457372/3586716)\
    \ for the PHP version specific solution.\n<|/ c |>\n<| a tags=php,bit-manipulation,javascript\
    \ |>\nTo get the result of binary xor in PHP:\n<code>", "  if ($a === $b) {\n\
    \    return $a;\n  }\n  if (strlen($a) != strlen($b)) {\n    return \"\";\n  }\n\
    \  $xor = 0;\n  for ($i = 0; $i < strlen($a); $i++) {\n    $xor ^= ($a[$i] ^ $b[$i]);\n\
    \  }\n  return dechex($xor);\n}\n", "    $result = array();\n    for($i = 0; $i\
    \ < strlen($a); $i++) {\n        if($a[$i] ^ $b[$i]) {\n            $result[]\
    \ = str_repeat(\"0\", strlen($a)-$i-1);\n            $result[] = $a[$i] ^ $b[$i];\n\
    \        } else {\n            $result[] = $a[$i];\n        }\n    }\n    return\
    \ implode('', $result);\n}\n</code>\n<|/ a tags=xor,php,string |>\n<| a dscore=1\
    \ |>\nTry this solution out:\n<code>\n<?php\n", "  $a_bin = base_convert($a, 2,\
    \ 2);\n  $b_bin = base_convert($b, 2, 2);\n\n  return base_convert(bin2hex(str_pad($a_bin\
    \ ^ $b_bin, 32, \"0\")), 2, 2);\n}\n</code>\n<|/ a dscore=4 |>\n<| a tags=php,cryptography,python\
    \ |>\nYou can try this (with PHP)\n<code>", "    return bin2hex((bin2hex(~bin2hex($a))\
    \ ^ bin2hex(~bin2hex($b))) & 0xff);\n}\n", "    $result = $a ^ $b; // binary XOR\n\
    \    return str_pad($result, strlen($result), '0', STR_PAD_LEFT);\n}\n", "  $xor\
    \ = array_fill(0, strlen($a), 0);\n  for ($i = 0; $i < strlen($a); $i++) {\n \
    \   $xor[$i] = $a[$i] ^ $b[$i];\n  }\n  return bin2hex(array_reduce($xor, \"array_merge\"\
    , array()));\n}\n", "    $a_int = str_split($a);\n    $b_int = str_split($b);\n\
    \    $xor_value = '';\n    foreach ($a_int as $k => $v) {\n        $xor_value\
    \ .= str_pad(bindec($a_int[$k] ^ $b_int[$k]), 8, '0', STR_PAD_LEFT);\n    }\n\
    \    return $xor_value;\n}\n", "    return bin2hex($a ^ $b);\n}\n", "  return\
    \ bin2hex(bin2hex($a) ^ $b);\n}\n ?>\n </body>\n</html>\n</code>\n<|/ a tags=php,xor\
    \ dscore=4 |>\n<| c |>\nThis seems to work fine. Thanks for the answer. It also\
    \ made me realize that I can just use Ajax to call this file without reloading\
    \ the page.\n<|/ c |>\n<| c |>\nIt also seems I got some really weird behavior\
    \ because I had to change `$_REQUEST['post']` to `$_POST['post']`. I'm going to\
    \ assume that's what was causing my weird behavior.\n<|/ c |>\n<| c |>\nYes, I\
    \ was using `$_REQUEST['post']` because I was copy/pasting from the OP's code.\
    \ You should use `isset($_POST['post'])` instead.\n<|/ c |>\n<| c |>\nOh, okay,\
    \ that makes sense.\n<|/ c |>\n<| c |>\nI didn't know that existed. Thanks\n<|/\
    \ c |>\n<| a tags=php,xor |>\nAs a PHP developer, I came across this question.\
    \ Based on the answers here I wrote a simpler code that would do the same thing\
    \ as XOR does.\n<code>\n<?php\n\n$a = '1';\n$b = '11';\n$string = '1000';\n$length\
    \ = strlen($string);\n\n$stringX = array();\nfor($i = 0; $i < $length; $i++) {\n\
    \    $stringX[] = substr($string, $i, 1);\n}\n\n$stringX = \"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "    $aBytes = str_split($a);\n    $bBytes = str_split($b);\n    $result = '';\n\
    \    foreach ($aBytes as $i => $aChar) {\n        $result .= $aChar ^ $bBytes[$i];\n\
    \    }\n    return $result;\n}\n", "  $xor = \"\";\n  for ($i = 0; $i < strlen($a);\
    \ $i++) {\n    if ($a[$i] === \"1\" && $b[$i] === \"1\") {\n      $xor .= \"1\"\
    ;\n    } else {\n      $xor .= \"0\";\n    }\n  }\n  return $xor;\n}\n", "  $c\
    \ = \"\";\n  for ($i = 0; $i < strlen($a); $i++) $c .= (ord($a[$i]) ^ ord($b[$i]));\n\
    \  return $c;\n}\n", "    $xor = array();\n    for ($i = 0, $len = mb_strlen($a,\
    \ '8bit'); !empty($a[$i]) && $i < $len; ++$i) {\n        $xor[] = ord($a[$i])\
    \ ^ ord($b[$i]);\n    }\n    return implode('', $xor);\n}\n</code>\n<|/ a dscore=3\
    \ tags=php |>\n<| a tags=php |>\n<code>\n$string1 = \"01010101\";\n$string2 =\
    \ \"01011010\";\n$result = '';\n$length1 = strlen($string1);\n$length2 = strlen($string2);\n\
    \nfor ($i=0, $i<$length1, $i++) {\n    $result .= $string1{$i} ^ $string2{$i};\n\
    }\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis is the simplest and most efficient\
    \ answer here.\n<|/ c |>\n<| a |>\nHere's a quick function I use to split up an\
    \ md5 hash. The hash can be any length, but it needs to contain an even number\
    \ of characters. If a hash is passed in, it returns that hash. Otherwise, it splits\
    \ the string into even-sized chunks and returns the hash.\n<code>", "\t$res =\
    \ \"\";\n\tfor ($i = 0; $i < strlen($a) && $i < strlen($b); $i++) {\n\t\t$res\
    \ .= $a[$i] ^ $b[$i];\n\t}\n\treturn $res;\n}\n", "    $result = \"\";\n    for\
    \ ($i = 0; $i < strlen($a) && $i < strlen($b); ++$i) {\n        $result .= $a[$i]\
    \ ^ $b[$i];\n    }\n    return $result;\n}\n", "    $result = \"\";\n    $len\
    \ = min(strlen($a), strlen($b));\n    for ($i = 0; $i < $len; $i++) {\n      \
    \  $result .= ($a[$i] ^ $b[$i]);\n    }\n    return $result;\n}\n", "  $result\
    \ = '';\n  for ($i = 0; $i < strlen($a); ++$i) {\n    $result .= chr(ord($a[$i])\
    \ ^ord($b[$i]));\n  }\n  return $result;\n}\n", "    $xor_string = $a ^ $b;\n\
    \    $xor_int = intval($xor_string, 2);\n    $xor_string = strtolower($xor_int);\n\
    \    return $xor_string;\n}", "\t$a_array = str_split($a);\n\t$b_array = str_split($b);\n\
    \n\t$c = '';\n\n\tforeach ($a_array as $k => $v) {\n\t\tif ($v == '1') {\n\t\t\
    \t$c .= $b_array[$k];\n\t\t}\n\t}\n\n\treturn $c;\n}\n", "    $a_length = strlen($a);\n\
    \    $b_length = strlen($b);\n    $result = array();\n    for ($i = 0; $i < $a_length;\
    \ $i++) {\n        $result[] = ($a[$i] ^ $b[$i]); // xor two chars\n    }\n  \
    \  return implode('', $result);\n}\n", "  return str_pad(str_pad(bin2hex(xor_bin($a,$b)),8,'0'),8,'0');\n\
    }", "  return $a ^ $b;\n}", "    $binA = ($a & 1) ? '1' : '0';\n    $binB = ($b\
    \ & 1) ? '1' : '0';\n    return $binA ^ $binB;\n}", "    return bin2hex(mcrypt_create_iv(bin2hex($a)\
    \ . bin2hex($b), MCRYPT_DEV_URANDOM));\n}\n</code>\n<|/ a |>\n<| c |>\nThis is\
    \ really helpful and has really helped me to understand the issue. Thanks!\n<|/\
    \ c |>\n<| a dscore=3 |>\nThe mcrypt_create_iv function expects two parameters,\
    \ the first is the length of the output and the second is the mode of operation\
    \ for the algorithm. Using these parameters corrects the problem:\n<code>\n$iv\
    \ = mcrypt_create_iv($cipherTextLen, MCRYPT_MODE_CFB);\n$encryptedText = mcrypt_encrypt(MCRYPT_RIJNDAEL_128,\
    \ $key, $plainText, $iv);\n</code>\n<|/ a tags=aes,mcrypt,php,encryption |>\n\
    <| a |>\nJust add this before you encrypt your plain text to make it work.\n<code>\n\
    $iv = mcrypt_create_iv($cipherTextLen, MCRYPT_MODE_CFB);\n</code>\n<|/ a tags=aes,mcrypt,php,encryption\
    \ dscore=2 |>\n<| a tags=aes,mcrypt,php,encryption |>\nFor anyone who might get\
    \ here with the same problem that I was having (I used the accepted answer) here\
    \ is my working code.\n<code>\n$key = '4A6F7DDA';\n$iv = '0';\n\n$plainText =\
    \ 'Hello World';\n\n$cipherText = mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $key, $plainText,\
    \ MCRYPT_MODE_CFB, $iv);\n$cipherText = base64_encode($cipherText);\n$iv = base64_encode($iv);\n\
    $encryptedText = base64_encode($cipherText);\n</code>\n<|/ a dscore=2 |>\n<| a\
    \ |>\nI faced the same problem. The problem was the IV i was passing was too long.\
    \ I just passed the IV as plain text and later added it after encrypting the data.\
    \ So here is my code:\n<code>\n$plainText = \"Hello World\";\n$iv = \"0123456789012345\"\
    ;\n$encryptedText = mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $key, $plainText, MCRYPT_MODE_CFB,\
    \ $iv);\n$encryptedText .= $iv;\n$encryptedText = base64_encode($encryptedText);\n\
    </code>\nNow the IV is passed as plain text and after that it is appended. Hope\
    \ this helps.\n<|/ a ", "  return ($a ^ $b);\n}\n", "    $ret = $a^$b; // Perform\
    \ binary XOR and return result also as a string.\n    $hex_string = bin2hex($ret);\
    \ // Convert the result from binary to hexadecimal.\n    return str_pad($hex_string,\
    \ 8, \"0\", STR_PAD_LEFT); // Pad the string with zeros to 8 digits with leading\
    \ zeros.\n}", "    $bin = str_split($a, 1);\n    $bin1 = str_split($b, 1);\n \
    \   $bin2 = array();\n    $c = 0;\n    foreach ($bin as $value) {\n        $bin2[$c]\
    \ = $bin1[$c] ^ ord($value);\n        $c++;\n    }\n    return implode('', $bin2);\n\
    }\n", "    return str_repeat(chr(0), (strlen($a) - strlen($b))) ^ str_repeat(chr(0),\
    \ strlen($b));\n}\n", "  $a = bin2hex($a);\n  $b = bin2hex($b);\n  return pack('H*',\
    \ str_replace([' ', ''], '', $a ^ $b));\n}\n", "  $result = '';\n  foreach (str_split($a)\
    \ as $x) {\n    $result .= chr(ord($x) ^ ord($b));\n  }\n  return $result;\n}\n",
  "    $xor = '';\n    foreach (str_split($a) as $i) {\n        $xor .= $b ^ $i;\n\
    \    }\n    return $xor;\n}\n", "  $c = bin2hex($a);\n  $d = bin2hex($b);\n  return\
    \ bin2hex(bin2hex($c) ^ $d);\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n\
    The solution using the \"XOR encryption\" method proposed by David Heffernan works,\
    \ but I figured I'd share the result of this project for future generations.\n\
    First I created 2 functions that I named \"xorEncode\" and \"xorDecode\", to encode\
    \ and decode strings from binary to hexadecimal and vice versa.\nThen I created\
    \ 2 functions that I named \"xorDecrypt\" and \"xorEncrypt\" that decrypt and\
    \ encode strings from hexadecimal to binary and vice versa.\nThen I created 2\
    \ functions to perform XOR and XOR encryption, based on those functions.\n<code>\n\
    <?php\n", "  $xor = array();\n  for ($i = 0; $i < strlen($a); $i++) {\n    $xor[$i]\
    \ = $a[$i] ^ $b[$i];\n  }\n  return bin2hex(implode('', $xor));\n}\n", "    $a_length\
    \ = strlen($a);\n    $b_length = strlen($b);\n    $result = \"\";\n    $i = 0;\n\
    \    while ($i < $a_length) {\n        $result .= $a[$i] ^ $b[$i];\n        $i++;\n\
    \    }\n    return $result;\n}", "  $a_arr = str_split($a);\n  $b_arr = str_split($b);\n\
    \  $result = '';\n\n  for ($i = 0; $i < max(count($a_arr), count($b_arr)); $i++)\
    \ {\n    $result .= $a_arr[$i] ^ $b_arr[$i];\n  }\n\n  return $result;\n}\n</code>\n\
    <|/ a tags=python,java,cryptography,php |>\n<| c |>\nI like the `array_diff` idea.\
    \ I didn't think of that.\n<|/ c |>\n<| a tags=python,java,cryptography,php dscore=0\
    \ |>\nIf you know what values are expected you can use this:\n<code>\ndef xor(a,\
    \ b):\n    return [x ^ y for (x, y) in zip(a, b)]\n\ndef xor_split(s):\n    chars\
    \ = []\n    for i in range(len(s)):\n        if s[i] == '0':\n            chars.append(i)\n\
    \    return chars\n\ns = input(\"Enter string: \")\na = xor_split(s)\nb = xor_split(a)\n\
    print(xor(a, b))\n</code>\n<|/ a |>\n<| c |>\n`def xor(a, b):\n    return list(map(lambda\
    \ x, y: x ^ y, a, b))`\n<|/ c |>\n<| c |>\nThis doesn't work if the strings are\
    \ of different length, as they are. The `xor` function assumes the lengths are\
    \ equal.\n<|/ c |>\n<| a |>\nFor a generic implementation in Python with arbitrary\
    \ lengths of input strings, it would be something like this\n<code>\ndef string_xor(str1,\
    \ str2):\n    if len(str1) < len(str2):\n        str1, str2 = str2, str1\n   \
    \ diff = []\n    for i, char in enumerate(str1):\n        if char != '0' and char\
    \ != '1' and char != 'X':\n            diff.append(i)\n    if len(diff) > 0:\n\
    \        return ''.join(str1[:i] for i, c in enumerate(str1) if c != '0') and\
    \ ''.join(str2[:i] for i, c in enumerate(str2) if c != '0')\n    else:\n     \
    \   return ''\n</code>\nIt also assumes that strings are always zero-padded to\
    \ the same length, and that the zero-padded strings aren't XORed together.\n<|/\
    \ a dscore=0 tags=python,java,cryptography,php |>\n<| c |>\nThis does not work\
    \ for arbitrary length strings. It also assumes no zero-padding is occurring,\
    \ which is inconsistent with the example provided.\n<|/ c |>\n<| c |>\nThe zero-padding\
    \ doesn't make any difference, because you simply can't XOR something with itself.\
    \ I simply added that assumption.\n<|/ c |>\n<| c |>\nBut it does assume that\
    \ strings are always zero", "    $result = '';\n    foreach (str_split($a) as\
    \ $char) {\n        $result = $char ^ $b;\n    }\n    return $result;\n}\n</code>\n\
    As far as I can see your code is all about converting a binary string to a decimal\
    \ string. Since I do not know what your input is I assumed a binary string where\
    \ the first char is always a \"1\" and the last is a \"0\". But you can of course\
    \ change that in any way you like.\nYou can read more about binary operations\
    \ here: http://en.wikipedia.org/wiki/Bitwise_operation\n<|/ a tags=string,binary,php\
    \ |>\n<| c |>\nThanks for the answer. Your code works great, but only when all\
    \ letters are either 0 or 1.\n\nIf the first character is \"0\" and all other\
    \ characters are \"1\", your code gives \"1\" as a result, when it should be \"\
    0\".\n<|/ c |>\n<| c |>\n: No it is not true. I tested it with this input `'01001110'`\
    \ and got this result `'000'` which is correct. Please have a look at the given\
    \ example.\n<|/ c |>\n<| c |>\nI tested it again: Your code works perfectly. Thanks\
    \ so much!\n<|/ c |>\n<| c |>\nIt would be interesting to see what this code does\
    \ if the first character is '0'. Is it the same?\n<|/ c |>\n<| c |>\n: No, `string_xor(\"\
    10\", \"110\")` results in `0` instead of `1`, because the first string starts\
    \ with a 0 in binary and so the XOR operation does not apply for the first character.\n\
    <|/ c |>\n<| a |>\nI modified the code a little bit.\n<code>\n<?php\n", "  return\
    \ bin2hex(str_pad(bin2hex($a) ^ $b, 32, '0', STR_PAD_LEFT));\n}\n", "  return\
    \ bin2hex( bin2hex( str_pad( $a, strlen( $b ), \"0\", STR_PAD_RIGHT ) ) ^ $b );\n\
    }", "    return bin2hex(mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $a, $b, MCRYPT_MODE_ECB));\n\
    }\n</code>\n<|/ a |>\n<| c |>\nNote that this only works for PHP 5.5+ as bin2hex\
    \ is not available in PHP 5.4.\n<|/ c |>\n<| c |>\nIf you're using an earlier\
    \ PHP version you can either downgrade to 5.4.4 or upgrade to 5.5+. 5.4.4 has\
    \ `bin2hex` but 5.4.4 doesn't support `MCRYPT_RIJNDAEL_256`. MCRYPT_RIJNDAEL_256\
    \ is only available in PHP 5.5+ but 5.4.4 and earlier don't support it either.\
    \ http://uk3.php.net/manual/en/book.mcrypt.php\n<|/ c |>\n<| a dscore=4 tags=encryption,php,rijndael,rijndael-cipher\
    \ |>\nI've created an example function for PHP 5.4 that uses mcrypt_encrypt\n\
    <code>\n<?php", "  $result = \"\";\n  for ($i = 0, $len = strlen($a); $i < $len;\
    \ $i++) {\n    $result .= ($a[$i] ^ $b[$i]) ? '1' : '0';\n  }\n  return $result;\n\
    }\n", "    $binA = $a;\n    $binB = $b;\n    $strA = $binA;\n    $strB = $binB;\n\
    \    for($i=0;$i<strlen($strA);$i++){\n        $strB[$i] = $strA[$i] ^ $strB[$i];\n\
    \    }\n    return $strB;\n}\n", "  $rev = array_reverse(str_split($b));\n  return\
    \ array_reduce($rev, function ($c, $i) {\n    return chr(ord($c) ^ ord($i));\n\
    \  });\n}\n", "    $len = max(strlen($a),strlen($b));\n    $a = array_pad($a,\
    \ $len, '0');\n    $b = array_pad($b, $len, '0');\n    $xor = '';\n    for ($i\
    \ = 0; $i < $len; $i++) {\n        $xor .= (($a[$i] & $b[$i]) ? '1' : '0');\n\
    \    }\n    return $xor;\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=bit,xor,php\
    \ |>\nAs I wrote in the comments above, this is a classic exercise in bit manipulation;\
    \ it's hard to find much about this particular subject on the web.\nTo do this,\
    \ I created a function which uses a for loop to get the sum of 1s from an array.\
    \ Then, I used a for loop to get the sum of 0s from an array. Then I used the\
    \ XOR operator to find the result of the sum of the two numbers. I added the result\
    \ to a variable. This function is called in the PHP script you posted above:\n\
    <code>", "    $a = preg_replace(\"/[^01]/\", \"\", $a);\n    $b = preg_replace(\"\
    /[^01]/\", \"\", $b);\n    return $a ^ $b;\n}\n", "    $xor = str_repeat(chr(1),\
    \ strlen($a)) ^ str_repeat(chr(1), strlen($b));\n    return str_pad($xor, strlen($a),\
    \ chr(0), STR_PAD_RIGHT);\n}\n", "    $xor = 0;\n    for($i = 0; $i < strlen($b);\
    \ $i++) {\n        $xor ^= bindec($a[$i]) ^ bindec($b[$i]);\n    }\n    return\
    \ base_convert($xor, 10, 2);\n}", "  return bin2hex(pack(\"H*\", $a ^ $b));\n}",
  "  $xor_result = \"\";\n  $n = strlen($a);\n  for ($i = 0; $i < $n; $i++) {\n  \
    \  $xor_result .= chr( ord($a[$i]) ^ ord($b[$i]) );\n  }\n  return $xor_result;\n\
    }", "  $result = $a ^ $b;\n  return (string)$result;\n}\n", "  return bin2hex(strtoupper(bin2hex(pack(\"\
    N\", $a) ^ pack(\"N\", $b))));\n}", "    $bstr = strtolower($b);\n    $astr =\
    \ strtolower($a);\n    $len = min(strlen($astr), strlen($bstr));\n    for ($i\
    \ = 0; $i < $len; $i++) {\n        $result[$i] = $astr[$i] ^ $bstr[$i];\n    }\n\
    \    return implode('', $result);\n}", "    $xor_result = '';\n    for ($i = 0;\
    \ $i < strlen($b); $i++) {\n        $xor_result .= $a[$i] ^ $b[$i];\n    }\n \
    \   return $xor_result;\n}", "  $xor = $a ^ $b;\n  return dechex($xor);\n}\n",
  "  $result = $a ^ $b;\n  return $result;\n}", "    $a = bindec($a);\n    $b = bindec($b);\n\
    \    $res = \"\";\n    $i = 0;\n    do {\n        $res .= chr(ord($a[$i]) ^ $b[$i]);\n\
    \        $i++;\n    } while (ord($a[$i]) != 0 && ord($b[$i]) != 0);\n    return\
    \ $res;\n}\n", "  $result = '';\n  for ($i = 0; $i < max(strlen($a), strlen($b));\
    \ ++$i) {\n    $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n", "  return\
    \ $a ^ $b;\n}\n</code>\n<|/ a |>\n<| c |>\nThanks for your effort. But this is\
    \ not giving me the result I need. I need the XOR of 2 strings. Please see my\
    \ example result in the original post.\n<|/ c |>\n<| c |>\nThat's exactly what\
    \ it does on my machine. Let me know if that doesn't work for you.\n<|/ c |>\n\
    <| c |>\nCan you please test it with 2 strings, instead of 2 arrays. I cannot\
    \ get it to work. Thanks.\n<|/ c |>\n<| c |>\nI made an edit to the first example\
    \ that does work on strings. I also added a second example that works similarly\
    \ with arrays. Hopefully this helps. Let me know if it still doesn't work for\
    \ you.\n<|/ c |>\n<| c |>\nI still cannot get it to work. I also added an example\
    \ in the original post. Can you please test it with that and let me know if it\
    \ works. Thanks.\n<|/ c |>\n<| a dscore=2 |>\nThe only way to get the result that\
    \ you have shown is to convert the binary strings into decimal integers and perform\
    \ the binary XOR operation on the integers.\nHere is one way to do that (not exactly\
    \ the most efficient, but I hope you get the idea):\n<code>", "  $xor = 0;\n \
    \ foreach (str_split($a) as $bit_a => $v) {\n    if ($v) $xor |= pow(2, $bit_a);\n\
    \  }\n  foreach (str_split($b) as $bit_b => $v) {\n    if ($v) $xor |= pow(2,\
    \ $bit_b);\n  }\n  return dechex($xor);\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    This assumes 32 bit integers, no? OP didn't specify 32 bit.\n<|/ c |>\n<| c |>\n\
    Ah yes, my bad. It has been so long since I wrote this answer that I can't remember\
    \ what I was thinking at the time.\n<|/ c |>\n<| a tags=php |>\n<code>\n<?php",
  "  return bin2hex(bin2hex(bin2hex($a) XOR bin2hex($b)));\n}\n", "    return bin2hex(mcrypt_create_iv(\n\
    \        mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_ECB), MCRYPT_RAND\n\
    \    ));\n}\n</code>\nSo you can use this function in a loop:\n<code>\n$iv = string_xor(\"\
    010\", \"110\");\n$plaintext = '010110';\n$key = '110';\n$ciphertext = mcrypt_encrypt(MCRYPT_RIJNDAEL_256,\
    \ $key, $plaintext, MCRYPT_MODE_CBC, $iv);\n</code>\n<|/ a dscore=3 tags=php,encryption,c#,mcrypt,rijndael\
    \ |>\n<| c |>\nAwesome! I used your example and was able to decrypt the ciphertext\
    \ in my C# console app. Thanks a lot, you rock!\n<|/ c |>\n<| c |>\n: No worries.\
    \ Glad it helped. Cheers!\n<|/ c |>\n<| a tags=php,encryption,c#,mcrypt,rijndael\
    \ dscore=2 |>\nIn C# you can call mcrypt_encrypt(). Just pass your secret key\
    \ as IV to it.\nIn PHP:\n<code>\n<?php\n$key = 'secretKey';\n$iv = 'secretIV';\n\
    \n$plainText = 'This text will be encrypted!';\n\n$encryptedText = mcrypt_encrypt(MCRYPT_RIJNDAEL_128,\
    \ $key, $plainText, MCRYPT_MODE_CBC, $iv);\n\necho $encryptedText;", "  return\
    \ str_pad(str_pad(base_convert($a, 2, 10), 2, 10, STR_PAD_LEFT), 2, 10, '0', STR_PAD_LEFT)\
    \ ^\n         str_pad(str_pad(base_convert($b, 2, 10), 2, 10, STR_PAD_LEFT), 2,\
    \ 10, '0', STR_PAD_LEFT);\n}\n</code>\nAnd now a test...\n<code>\n$strings = array(\n\
    \  '0000',\n  '0001',\n  '0010',\n  '0011',\n  '0100',\n  '0101',\n  '0110',\n\
    \  '0111',\n  '1000',\n  '1001',\n  '1010',\n  '1011',\n  '1100',\n  '1101',\n\
    \  '1110',\n  '1111',\n);\n\nforeach($strings as $string) {\n  echo \"'$string'\
    \ => \".base_convert($string, 2, 10).' => '.string_xor($string, base_convert($string,\
    \ 2, 10)).\"\\n\";\n}\n</code>\nOutput...\n<code>\n'0000' => 100 => 100\n'0001'\
    \ => 101 => 101\n'0010' => 110 => 100\n'0011' => 111 => 101\n'0100' => 101 =>\
    \ 101\n'0101' => 100 => 100\n'0110' => 100 => 101\n'0111' => 101 => 100\n'1000'\
    \ => 100 => 100\n'1001' => 101 => 101\n'1010' => 100 => 100\n'1011' => 101 =>\
    \ 101\n'1100' => 100 => 100\n'1101' => 101 => 101\n'1110' => 101 => 100\n'1111'\
    \ => 101 => 101\n</code>\nSo yes, if you want a really fast string xor... and\
    \ only on strings, you should use bitwise XOR.\n<|/ a dscore=4 |>\n<| c |>\nThis\
    \ is actually very nice, except that the result is all wrong... try the test string\
    \ `'1100'`, or `'1001'`.\n<|/ c |>\n<| c |>\nYour test cases are incorrect, they\
    \ should all be the XOR of `'0000'` and `'1000'` (which are binary `0` and `1`),\
    \ which yields `'1001'`.\n<|/ c |>\n<| c |>\n: Yeah, it is... and this is actually\
    \ a much better test... I missed that one. I will add it to the answer.\n<|/ c\
    \ |>\n<| a dscore=4 tags=php,bitwise-operators,bit-manipulation |>\nThe bitwise\
    \ XOR operator is ^", "  $result = \"\";\n  for ($i = 0; $i < strlen($a); $i++)\
    \ {\n    $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n", "    $xor_res\
    \ = \"\";\n    $res = strlen($a) + strlen($b);\n    for($i = 0; $i < $res; ++$i)\
    \ {\n        if($a[$i] !== \"1\") $xor_res[$i] = \"0\";\n        if($b[$i] !==\
    \ \"1\") $xor_res[$i] = \"1\";\n    }\n    return $xor_res;\n}\n</code>\n<|/ a\
    \ dscore=1 tags=php,javascript,encryption,xor,string |>\n<| c |>\nJust tested\
    \ this, this works and is faster than the other solutions.\n<|/ c |>\n<| c |>\n\
    I didnt test this, as my solutions are already working. But i did just test it,\
    \ thanks for the info.\n<|/ c |>\n<| a tags=php,javascript,encryption,xor,string\
    \ dscore=0 |>\nJust wanted to add another solution in JS, although not as fast\
    \ as the others, i think its easier to read. \n<code>", "    $res = '';\n    for\
    \ ($i = 0, $size = strlen($a); $i < $size; $i++) {\n        $res .= $a[$i] ^ $b[$i];\n\
    \    }\n    return $res;\n}\n", "    $c = 0;\n    for ($i = 0; $i < strlen($a);\
    \ $i++) {\n        $c += intval($a[$i]) ^ intval($b[$i]);\n    }\n    return str_pad($c,\
    \ strlen($a), '0', STR_PAD_LEFT);\n}\n", "    return $a ^ $b;\n}", "    $result\
    \ = '';\n    $len = min(count($a), count($b));\n    for ($i = 0; $i < $len; $i++)\
    \ {\n        $result .= chr(ord($a[$i]) ^ ord($b[$i]));\n    }\n    return $result;\n\
    }\n", "  global $binary_ops;\n  $a_len = strlen($a);\n  $b_len = strlen($b);\n\
    \  $output = '';\n  for ($i = 0; $i < $a_len; $i++) {\n    $output .= $binary_ops[$a[$i]]\
    \ ^ $binary_ops[$b[$i]];\n  }\n  return $output;\n}\n", "    return bin2hex(xor(str_split($a,\
    \ 2), str_split($b, 2)));\n}", "  return bin2hex(bin2hex(bin2hex($a) ^ bin2hex($b)));\n\
    }", "    $xor = array_map('ord', str_split(bin2hex(str_pad($a, 8, '0', STR_PAD_LEFT)\
    \ ^ $b)));\n    return implode('', array_map('chr', $xor));\n}\n", "  if (strlen($a)\
    \ !== strlen($b)) {\n    throw new InvalidArgumentException(\"The inputs must\
    \ be of equal length.\");\n  }\n  $xor = '';\n  for ($i = 0; $i < strlen($a);\
    \ $i++) {\n    $xor .= $a[$i] ^ $b[$i];\n  }\n  return $xor;\n}\n", "    $res\
    \ = '';\n    // Loop over characters a and b\n    for($i = 0; $i < min(strlen($a),\
    \ strlen($b)); $i++) {\n        $res .= ($a[$i] != $b[$i]) ? '1' : '0';\n    }\n\
    \    return $res;\n}\n", "  $result = '';\n  for ($i = 0; $i < strlen($a) && $i\
    \ < strlen($b); $i++) {\n    $result = $a[$i] ^ $b[$i];\n  }\n  return $result;\n\
    }\n", "    $a_bin = base_convert($a, 2, 2);\n    $b_bin = base_convert($b, 2,\
    \ 2);\n    $result = \"\";\n    for($i = 0, $l = min($a_bin, $b_bin); $i < $l;\
    \ $i++) {\n        $result .= ($a[$i] ^ $b[$i]);\n    }\n    return base_convert($result,\
    \ 2, 2);\n}", "    return bin2hex(str_pad(dechex(bin2de($a) ^  bin2de($b)), 4,\
    \ \"0\", STR_PAD_LEFT));\n}\n", "  $x = strlen($a);\n  $y = strlen($b);\n  $z\
    \ = 0;\n  for ($i = 0; $i < $x; $i++) {\n    $z += ord($a[$i]) ^ ord($b[$i]);\n\
    \  }\n  return chr(bin2hex($z));\n}", "  $xor = 0;\n  for ($i = 0; $i < strlen($a);\
    \ $i++) {\n    $xor |= (ord($a[$i]) ^ ord($b[$i]));\n  }\n  return str_pad($xor,\
    \ strlen($a), chr(0), STR_PAD_LEFT);\n}\n", "    $a = strtolower($a);\n    $b\
    \ = strtolower($b);\n    $result = $a ^ $b;\n    $result = str_pad($result, strlen($a),\
    \ '0', STR_PAD_LEFT);\n    return $result;\n}\n", "  $a_bin = str_split($a);\n\
    \  $b_bin = str_split($b);\n  $xor_array = [];\n  foreach ($a_value as $value)\
    \ {\n    if ($value == 1) {\n      $xor_array[] = 1;\n    } else {\n      $xor_array[]\
    \ = 0;\n    }\n  }\n  foreach ($b_value as $value) {\n    if ($value == 1) {\n\
    \      $xor_array[] = 1;\n    } else {\n      $xor_array[] = 0;\n    }\n  }\n\
    \  $xor_result = array_flip($xor_array);\n  $xor_str = \"\";\n  foreach ($xor_result\
    \ as $key => $value) {\n    if ($value == 1) {\n      $xor_str .= $key;\n    }\n\
    \  }\n  return $xor_str;\n}", "  $c = strlen($a);\n  $d = strlen($b);\n  $string\
    \ = \"\";\n  for ($i = 0; $i < $c; $i++) {\n    $string .= chr(bindec($a[$i] ^\
    \ $b[$i]));\n  }\n  return $string;\n}\n</code>\n<|/ a |>\n<| c |>\nThis will\
    \ not work in PHP 5.6+. I tried it with PHP 7.0.3 and got an \"Undefined offset:\
    \ -1\" error.\n<|/ c |>\n<| c |>\nThis also has a bug with empty strings. As an\
    \ example, if `a = 'a'` and `b = '\\0'`, then `string_xor(a,b)` will return `'\\\
    0'`. I found this out when converting a library from PHP 5.3 to 7.2 and it took\
    \ me a while to figure out why it wasn't working as expected and I was scratching\
    \ my head for a bit.\n<|/ c |>\n<| a tags=xor,php,string |>\nThe simplest way\
    \ is to apply strxor:\n<code>\n<?php", "  $res = '';\n  for ($i = 0; $i < strlen($b);\
    \ $i++) {\n    $res .= chr(ord($a[$i]) ^ ord($b[$i]));\n  }\n  return $res;\n\
    }\n", "    $res = '';\n    for ($i = 0, $l = strlen($a); $i < $l; $i++) {\n  \
    \      $res .= $a[$i] ^ $b[$i];\n    }\n    return $res;\n}\n</code>\nAnd the\
    \ final function which returns the bitwise XOR of the two string inputs $a and\
    \ $b and concatenates the result to a string: \n<code>\n<?php", "  $res = \"\"\
    ;\n  for ($i = 0; $i < strlen($a); $i++) {\n    $res .= (ord($a[$i]) ^ ord($b[$i]));\n\
    \  }\n  return $res;\n}", "  // XOR returns 1 if both inputs are '1', or 0 if\
    \ both inputs are '0'\n  // XOR performs bitwise operation and returns a single\
    \ binary digit.\n  // return (a xor b) mod 2\n  return bin2hex(bin2hex(decbin(ord($a))\
    \ ^ decbin(ord($b))) mod 2);\n}\n", "    if (strlen($a) != strlen($b)) {\n   \
    \     return \"Invalid lengths\";\n    }\n    $result = '';\n    for ($i = 0;\
    \ $i < strlen($a); $i++) {\n        $result .= (ord($a[$i]) ^ (ord($b[$i]) & 0xff));\n\
    \    }\n    return $result;\n}", "    $length = strlen($a);\n    $result = '';\n\
    \    for ($i = 0; $i < $length; $i++) {\n        $result .= $a[$i] ^ $b[$i];\n\
    \    }\n    return $result;\n}\n", "    $a = unpack(\"C*\", $a); // pack string\
    \ into array\n    $b = unpack(\"C*\", $b); // pack string into array\n    $c =\
    \ \"\"; // initialize result\n\n    foreach ($a as $val) {\n        $c .= chr(ord($val)\
    \ ^ ord($b[count($b) - 1]));\n    }\n    return $c;\n}", "    return bin2hex((bin2hex($a)\
    \ ^ bin2hex($b))); // return hex\n}\n", "    // Get binary length of input strings\n\
    \    $a_len = strlen($a);\n    $b_len = strlen($b);\n    $a_len = min($a_len,\
    \ $b_len);\n    $xor_str = '';\n    for ($i = 0; $i < $a_len; $i++) {\n      \
    \  $xor_str .= chr((ord($a[$i]) ^ (ord($b[$i]) << ($b_len - $i))));\n    }\n \
    \   return $xor_str;\n}\n", "  $ret = '';\n  for ($i = 0; $i < strlen($a); $i++)\
    \ {\n    $ret .= $a[$i] ^ $b[$i];\n  }\n  return $ret;\n}", "  $xor = \"\";\n\
    \  for ($i = 0; $i < strlen($b); $i++) {\n    $xor .= ($a[$i] != $b[$i]) ? '1'\
    \ : '0';\n  }\n  return $xor;\n}", "\t$binA = \"\"; // Initialise binary string.\n\
    \t$binB = \"\"; // Initialise binary string.\n\tfor ($i = 0; $i < strlen($a);\
    \ $i++) {\n\t\t$binA .= $a[$i];\n\t\t$binB .= $b[$i];\n\t}\n\treturn bin2hex(pack(\"\
    H*\", $binA ^ $binB));\n}", "    $x = array_fill(0, strlen($b), 0);\n    array_walk($x,\
    \ 'str_xor', $a, $b);\n    return implode('', $x);\n}\n", "    $ret = '';\n  \
    \  for ($i = 0; $i < min(strlen($a), strlen($b)); $i++) {\n        $ret .= $a{$i}\
    \ ^ $b{$i};\n    }\n    return $ret;\n}\n", "  return bin2hex(bin2hex(bin2hex(bin2hex(str_pad($a,\
    \ 4, '0', STR_PAD_LEFT))) ^\n         bin2hex(bin2hex(str_pad($b, 4, '0', STR_PAD_LEFT)))));\n\
    }", "  $a = str_split($a);\n  $b = str_split($b);\n  $xor = '';\n\n  foreach (array_keys($a)\
    \ as $key) {\n    $xor .= $a[$key] ^ $b[$key];\n  }\n\n  return $xor;\n}\n</code>\n\
    <|/ a |>\n<| a tags=xor,php,bit-manipulation |>\nThe function below is what I\
    \ used, and I thought I should share it in case anyone was looking for the same:\n\
    <code>", "  $length = max(strlen($a), strlen($b));\n  $c = '';\n  for($i = 0;\
    \ $i < $length; $i++) {\n    $c .= $a[$i] ^ $b[$i];\n  }\n  return $c;\n}\n",
  "  return bin2hex(bin2hex(bin2hex($a) ^ bin2hex($b)));\n}\n", "    return ltrim(str_pad(bin2hex(mcrypt_generic_init('rijndael-128',\n\
    \                                                   $key = '12345678',\n     \
    \                                              $mode= 'cbc',\n               \
    \                                    $keysize = 128)),\n                     \
    \      mcrypt_generic_block_size('rijndael-128'), \n                         \
    \  mcrypt_generic_mode('rijndael-128')), \"\\n\");\n}\n", "  $res = '';\n  $len\
    \ = max(strlen($a), strlen($b));\n  for ($i = 0; $i < $len; $i++) {\n    $res\
    \ .= $a[$i] ^ $b[$i];\n  }\n  return $res;\n}\n</code>\nThe above is a very basic\
    \ XOR function. However if you need an XOR that can handle arbitrary length strings\
    \ you would need to use a more powerful algorithm than XOR.\n<|/ a |>\n<| a tags=php,bit-manipulation,arrays\
    \ |>\n<code>", "  // Return empty string if either input is empty.\n  if (!$a\
    \ || !$b) return '';\n\n  // Convert string to array and perform XOR.\n  $a =\
    \ str_split($a);\n  $b = str_split($b);\n  $r = array_map(function($x, $y) { return\
    \ chr(ord($x) ^ ord($y)); }, $a, $b);\n  return implode('', $r);\n}\n</code>\n\
    The PHP 7 solution\n<code>", "    return str_pad(dechex(bindec($a ^ $b)), \"16\"\
    , '0', STR_PAD_LEFT);\n}\n</code>\n<|/ a tags=xor,bit-manipulation,php,binary\
    \ |>\n<| c |>\nThanks for the reply.  I already have something similar to this.\
    \  It only works if you know the length of the string.  It doesn't work with the\
    \ string length unknown.\n<|/ c |>\n<| c |>\n: yes, you can do `$strLen = strlen($str);\
    \ $bits = array_fill(0, $strLen, \"0\");` to initialize the array with zeros,\
    \ then just feed the bits in.  No loop needed.\n<|/ c |>\n<| c |>\n, please see\
    \ my update above with PHP code using an associative array to initialize the bits.\n\
    <|/ c |>\n<| c |>\nThanks for the update.  I added a description of what I was\
    \ trying to accomplish to my original post.  In addition to what you are suggesting,\
    \ I will be doing a lot of string manipulation with these binary strings.\n<|/\
    \ c |>\n<| a tags=xor,bit-manipulation,php,binary dscore=1 |>\nYou want to do\
    \ a bitwise XOR, which means you need to use bitwise operators.\nPHP has a bit\
    \ array data type that can help you here.  I wrote a quick bit array class here\
    \ that takes two integers and outputs a bitwise XOR of the two integers.\n<code>\n\
    <?php\n\nclass BitArray {\n    public $num;\n    public function __construct($num)\
    \ {\n        if ($num > 0) {\n            $this->num = $num;\n        }\n    }\n\
    \n    public function getBits() {\n        $bits = \"\";\n        for ($i=0; $i\
    \ < $this->num; $i++) {\n            $bits .= (1 << $i);\n        }\n        return\
    \ $bits;\n    }\n}\n\n$a = new BitArray(10);\n$b = $a->getBits();\n$result = $a\
    \ ^ new BitArray($b);\n</code>\n<|/ a |>\n<| c |>\nThanks for the reply.  I don't\
    \ necessarily need to use PHP.  I just needed a way to do this in PHP.  I didn't\
    \ know that PHP had a bit-array data type.\n<|/ c |>\n<| a dscore=0 tags=xor,bit-manipulation,php,binary\
    \ |>\nThis can do it.  It takes two strings and returns a string with the bits\
    \ xor'd.\n<code>", "  $a_len = strlen($a);\n  $b_len = strlen($b);\n  if ($a_len\
    \ > $b_len) {\n    $b = str_pad($b, $a_len, '0');\n  }\n  $xor = $a ^ $b;\n  $str\
    \ = str_pad($xor, $a_len, '0');\n  return $str;\n}\n", "    return bin2hex(bin2hex($a)\
    \ xor bin2hex($b));\n}\n", "  $result = \"\";\n  for($i = 0; $i < strlen($a) &&\
    \ $i < strlen($b); $i++) {\n    $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n\
    }\n", "    $xor = 0;\n    foreach (str_split($a) as $a_bit) {\n        $xor ^=\
    \ $b;\n        $b = chr(ord($b) ^ ord($a_bit));\n    }\n    return chr($xor);\n\
    }\n", "  return bin2hex(openssl_xor_digest($a, $b));\n}\n", "    $xor = '';\n\
    \    for ($i = 0; $i < strlen($a); $i++) {\n        $xor .= $a[$i] ^ $b[$i];\n\
    \    }\n    return $xor;\n}\n", "  echo \"XOR (\" . $a . \", \" . $b . \") = \"\
    \ . bin2hex(xor_bin($a, $b));\n}\n", "  // Convert strings to arrays of 1s and\
    \ 0s\n  $a_bin = str_split($a);\n  $b_bin = str_split($b);\n  // Perform XOR on\
    \ the arrays of 1s and 0s\n  $a_bin_xor = array_flip($a_bin);\n  $b_bin_xor =\
    \ array_flip($b_bin);\n  // Return XOR of all arrays resulting from flipping the\
    \ bits in them\n  return implode('', array_map(function($x) { return $a_bin_xor[$x];\
    \ }, $b_bin_xor));\n}\n", "    return bin2hex(bin2hex($a) ^ $b);\n}\n", "  return\
    \ pack('H*', str_pad(dechex(bin2hex($a ^ $b)), 8, '0', STR_PAD_LEFT));\n}", " \
    \ $r = \"\";\n  for ($i = 0; $i < max(strlen($a), strlen($b)); $i++) {\n    if\
    \ ($a[$i] == $b[$i]) {\n      $r .= $a[$i];\n    }\n    else {\n      $r .= '0';\n\
    \    }\n  }\n  return $r;\n}", "    $binA = (string)bin2hex($a);\n    $binB =\
    \ (string)bin2hex($b);\n    return str_replace(array('0', '1', '2', '3', '4',\
    \ '5', '6', '7', '8', '9'), array('', '', '', '', '', '', '', '', '', '', ''),\
    \ $binA^$binB);\n}\n", "  $xor_a = bin2hex($a) ^ (bin2hex($b) ^ (bin2hex($b) ^\
    \ (bin2hex($a)));\n  $xor_b = bin2hex($b) ^ (bin2hex($a) ^ (bin2hex($a) ^ (bin2hex($b)));\n\
    \  return bin2hex($xor_a ^ $xor_b);\n}\n", "    $a = str_pad($a, 8, '0', STR_PAD_LEFT);\n\
    \    $b = str_pad($b, 8, '0', STR_PAD_LEFT);\n    $result = str_pad('', 8, '0',\
    \ STR_PAD_RIGHT);\n    foreach (str_split($a) as $i => $achar) {\n        $result[$i]\
    \ = $b[$i] ^ $achar;\n    }\n    return $result;\n}\n</code>\nSo to convert this\
    \ algorithm into PHP, you need to first convert the code from the algorithm into\
    \ some PHP-readable code. Then, once you have that code you need to convert it\
    \ into PHP. That process involves some trial and error and some careful thought\
    \ about what you are doing, to make sure you are doing things the right way.\n\
    <|/ a dscore=0 tags=php,algorithm |>\n<| c |>\nThanks for answering!\nI did not\
    \ understand how your code could solve this problem:\n01011010\n11010001 \nwould\
    \ give this answer:\n01110110\n10001111 \nDo you mean to convert 01011010 to 01110110\
    \ and then perform the XOR and then convert it back to 01011010?\n<|/ c |>\n<|\
    \ c |>\nI understand how that algorithm works now, but how do I convert the code\
    \ into a PHP function and how do I convert the code into a PHP function? I'm sorry\
    \ if I'm asking dumb questions, but I'm a noob.\n<|/ c |>\n<| c |>\n: What did\
    \ you mean by \"convert the code into a PHP function\"? I suggested you write\
    \ the algorithm in PHP in the first sentence of my answer. That is what you need\
    \ to do. Once you have that algorithm in PHP code, you then need to convert it\
    \ into PHP code that does what you want.\n<|/ c |>\n<| c |>\nI understand your\
    \ algorithm and I see how your code is written. I know exactly what you mean by\
    \ \"convert the code into a PHP function\". I don't know exactly what you mean\
    \ by \"convert the code into a PHP function that does the same thing as the code\"\
    . How does my code do the same thing as the code? I don't understand.\n<|/ c |>\n\
    <| c |>\n: Well, your code does something different from your algorithm. I guess\
    \ that is what you meant. Your code converts the characters into their integer\
    \ representations and then performs the XOR to get the result you want. My code\
    \ converts the characters into their integer representations and then performs\
    \ the XOR on the integers to get the result you want.\n<|/ c |>\n<| a |>\nYou\
    \ can try this:\n<code>", "  global $np;\n  $result = '';\n  $n = (strlen($a)\
    \ + strlen($b)) / 2;\n  for ($i = 0; $i < $n; $i++) {\n    $result .= (($a[$i]\
    \ != $b[$i]) ? 1 : 0);\n  }\n  return $result;\n}\n", "    $result = '';\n   \
    \ for ($i = 0, $iMax = strlen($a); $i < $iMax; $i++) {\n        $c1 = $a[$i];\n\
    \        $c2 = $b[$i];\n        if ($c1 != $c2) {\n            $result .= $c1;\n\
    \        }\n    }\n    return $result;\n}\n", "    $c = strlen($a);\n    $d =\
    \ strlen($b);\n    $s = array();\n    if ($c > $d) $d = $c;\n    for ($i = 0;\
    \ $i < $d; $i++) {\n        $s[] = ($a[$i] ^ $b[$i]);\n    }\n    return implode('',\
    \ $s);\n}\n", "  $a = ltrim($a, \"0\");\n  $b = ltrim($b, \"0\");\n  $result =\
    \ $a ^ $b;\n  return $result;\n}\n", "  $result = \"\";\n  for ($i = 0; $i < strlen($a);\
    \ $i++) {\n    $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n", "  \
    \  $res = '';\n    $xor = 0;\n    for ($i=0; $i<strlen($a); $i++) {\n        $c1\
    \ = ord($a[$i]);\n        $c2 = ord($b[$i]);\n        $xor += ($c1 ^ $b[$i]);\n\
    \        $res .= chr($xor % 256);\n        $xor = $c1 & $xor;\n    }\n    return\
    \ $res;\n}\n", "    return $b^$a;\n}", "    $ret = $a;\n    for($i = 0; $i < strlen($b);\
    \ $i++) {\n        $ret ^= $b[$i];\n    }\n    return $ret;\n}\n", "    return\
    \ bin2hex(bin2hex(hex2bin(bin2hex($a) ^ bin2hex($b))) . str_repeat(\"0\", 7 -\
    \ bin2hex(strlen($a) + strlen($b))))\n}\n</code>\n<|/ a tags=php |>\n<| c |>\n\
    You missed \"hex\" in the return statement.\n<|/ c |>\n<| c |>\nThanks for the\
    \ catch.  Corrected.\n<|/ c |>\n<| c |>\nI appreciate this answer, but it does\
    \ not work for me (php 7.1). [Example output](https://eval.in/173761)\n<|/ c |>\n\
    <| c |>\nI assume you meant that the example output does not work for you.  It\
    \ works for me when tested and verified against the accepted answer.\n<|/ c |>\n\
    <| a |>\nA more simpler solution (tested in PHP7.2.8)\n<code>", "  $result = '';\n\
    \  for ($i = 0; $i < strlen($a) && $i < strlen($b); $i++) {\n    $result .= $a[$i]\
    \ ^ $b[$i];\n  }\n  return $result;\n}", "    $ret = $a ^ $b;\n    return str_pad(decbin($ret),\
    \ 8, \"0\", STR_PAD_LEFT);\n}\n", "  $a = array_map(\n    function ($x) {\n  \
    \    return bindec(substr($x, 1));\n    },\n    str_split($a, 2));\n  $b = array_map(\n\
    \    function ($x) {\n      return bindec(substr($x, 1));\n    },\n    str_split($b,\
    \ 2));\n\n  $x = strlen($a);\n  $y = strlen($b);\n\n  $r = $x;\n  while ($x--\
    \ > 0) {\n    $r &= $y--;\n    if ($r < 0) {\n      $r += $y;\n      $r--;\n \
    \   }\n  }\n  return substr($r, 0, 1);\n}\n", "  $xor = 0;\n  for ($i = 0; $i\
    \ < strlen($a); $i++) $xor ^= (ord($a[$i]) ^ ord($b[$i]));\n  $result = \"\";\n\
    \  for ($i = 0; $i < strlen($a); $i++) $result .= chr(ord($a[$i]) ^ $xor);\n \
    \ return $result;\n}\n", "    if (strlen($a) != strlen($b)) {\n        trigger_error(\n\
    \            \"Invalid input: string lengths are not equal\", E_USER_ERROR);\n\
    \    }\n\n    $xor = '';\n    for ($i = 0; $i < strlen($a); $i++) {\n        $xor\
    \ .= $a[$i] ^ $b[$i];\n    }\n    return $xor;\n}", "  $result = $a ^ $b;\n  echo\
    \ sprintf('%X', $result).\"\\n\";\n}\n", "    $result = '';\n    for ($i = 0,\
    \ $c = count($a); $i < $c; $i++) {\n        $result .= $a[$i] ^ $b[$i];\n    }\n\
    \    return $result;\n}", "  return bin2hex(substr(pack(\"H*\", bin2hex(bin2hex($a))\
    \ ^ bin2hex($b)), -4));\n}", "  $res = '';\n  for ($i = 0; $i < strlen($a); $i++)\
    \ {\n    if ($a{$i} ^ $b{$i}) {\n      $res .= '1';\n    } else {\n      $res\
    \ .= '0';\n    }\n  }\n  return $res;\n}", "    $xor = '';\n    for($i = 0; $i\
    \ < strlen($a); $i++) {\n        $xor .= (ord(substr($a, $i, 1)) ^ ord(substr($b,\
    \ $i, 1)));\n    }\n    return $xor;\n}\n", "    return bin2hex($a ^ $b);\n}\n\
    </code>\n<|/ a dscore=5 |>\n<| c |>\nHow to use it in php ?\n<|/ c |>\n<| c |>\n\
    Thanks a lot! The first line is perfect for me :)\n<|/ c |>\n<| a tags=string,php\
    \ dscore=3 |>\n<code>\n$str1 = \"11110000\";\n$str2 = \"01010000\";\n$str3 = \"\
    01110000\";\n$str4 = \"10100001\";\n$str5 = \"11100001\";\n$str6 = \"10011111\"\
    ;\n$str7 = \"110100011\";\n$str8 = \"110100111\";\n$str9 = \"110101001\";\n$str10\
    \ = \"110101111\";\n\n$str1 = \"11110000\"; //for str1\n$str2 = \"01010000\";\
    \ //for str2\n$str3 = \"01110000\"; //for str3\n$str4 = \"10100001\"; //for str4\n\
    $str5 = \"11100001\"; //for str5\n$str6 = \"10011111\"; //for str6\n$str7 = \"\
    110100011\"; //for str7\n$str8 = \"110100111\"; //for str8\n$str9 = \"110101001\"\
    ; //for str9\n$str10 = \"110101111\"; //for str10\n\n$a = str_split($str1);\n\
    $b = str_split($str2);\n$c = str_split($str3);\n$d = str_split($str4);\n$e = str_split($str5);\n\
    $f = str_split($str6);\n$g = str_split($str7);\n$h = str_split($str8);\n$i = str_split($str9);\n\
    $j = str_split($str10);\n\n$a = array_map(\"ord\", $a);\n$b = array_map(\"ord\"\
    , $b);\n$c = array_map(\"ord\", $c);\n$d = array_map(\"ord\", $d);\n$e = array_map(\"\
    ord\", $e);\n$f = array_map(\"ord\", $f);\n$g = array_map(\"ord\", $g);\n$h =\
    \ array_map(\"ord\", $h);\n$i = array_map(\"ord\", $i);\n$j = array_map(\"ord\"\
    , $j);\n\n$str1 = array_sum(array_map(\"chr\", $a));\n$str2 = array_sum(array_map(\"\
    chr\", $b));\n$str3 = array_sum(array_map(\"chr\", $c));", "  return bin2hex(pack(\"\
    H*\", str_pad(sha1($a . $b), 2, \"0\", STR_PAD_RIGHT)));\n}", "    $xor = \"\"\
    ;\n    for ($i = 0; $i < min(strlen($a), strlen($b)); $i++) {\n        $xor .=\
    \ chr(ord($a[$i]) ^ ord($b[$i]));\n    }\n    return $xor;\n}\n</code>\n<|/ a\
    \ dscore=0 |>\n<| c |>\nThis isn't correct. You're just throwing away the least\
    \ significant bit in each character, and replacing it with a `0`.\n<|/ c |>\n\
    <| a tags=php,bit-manipulation,bitwise-operators |>\nIf you have some control\
    \ over the format of the data, you could use the fact that x^y = x & (~(x | y))\
    \ - i.e. for each bit position that doesn't match each other bit, flip it, and\
    \ put in the first bit where it matches:\n<code>\n$result = preg_replace('/(0\\\
    1{4})/', '\\1\\3', $source);\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nA\
    \ solution without looping, only 1 regexp and a replacement function with a variable\
    \ number of arguments. \n<code>", "    $result = '';\n    for ($i = 0; $i < strlen($a)\
    \ && $i < strlen($b); $i++) {\n        if ($a[$i] == $b[$i]) {\n            $result\
    \ .= $a[$i];\n        } else {\n            $result .= '0';\n        }\n    }\n\
    \    return $result;\n}\n", "    return bin2hex(xor(dechex(bin2de($a)), dechex(bin2de($b))));\n\
    }\n", "  $result = $a;\n  for ($i = 0; $i < strlen($a); ++$i) {\n    $result .=\
    \ $b[$i] ^ $a[$i];\n  }\n  return $result;\n}\n", "    $result = '';\n    $carry\
    \ = 0;\n    for ($i = 0; $i < strlen($a) && $i < strlen($b); $i++) {\n       \
    \ $res = ($a[$i] ^ $b[$i]) + $carry;\n        $carry = ($res < 26) ? ($res + 9)\
    \ : $res % 26;\n        $result = chr($res) . $result;\n    }\n    if ($carry\
    \ > 0) {\n        $result = chr($carry) . $result;\n    }\n    return $result;\n\
    }\n", "  $bin = str_repeat(\"0\", max(strlen($a), strlen($b))); // pad shorter\
    \ strings with 0's.\n  for ($i = 0; $i < strlen($bin); $i++) {\n    $bin[$i] =\
    \ $bin[$i] ^ substr($bin, $i, 1);\n  }\n  return bin2hex($bin);\n}", "  if ( strlen($a)\
    \ != strlen($b) ) {\n    return \"Error: strings not the same length\";\n  }\n\
    \  $res = '';\n  for ($i = 0; $i < strlen($a); $i++) {\n    $res .= $a[$i] ^ $b[$i];\n\
    \  }\n  return $res;\n}\n", "    $result = '';\n    $num_a = strlen($a);\n   \
    \ $num_b = strlen($b);\n    for ($i = 0; $i < $num_a; $i++) {\n        $result\
    \ .= $a[$i] ^ $b[$i];\n    }\n    return $result;\n}", "  return str_replace(array_map(function\
    \ ($e) {\n    return bindec($e);\n  }, str_split($a ^ $b)), \"\", $a ^ $b);\n\
    }\n", "  return str_pad(base_convert(bin2hex(Xor($a, $b)), 16, 2), 8, '0', STR_PAD_LEFT);\n\
    }\n</code>\nThe Xor function can be found in this answer\n<|/ a tags=encryption,php,c#,hash,md5\
    \ dscore=1 |>\n<| c |>\nThanks for the XOR function - that's very helpful. I'm\
    \ going to hold out for a solution that uses the php mcrypt_hash function though.\n\
    <|/ c |>\n<| c |>\nPHP has [md5()](http://php.net/manual/en/function.md5.php)\
    \ and [sha1()](http://php.net/manual/en/function.sha1.php), but they are for hashing\
    \ binary data, not strings of binary characters.  You'd have to convert those\
    \ strings into hex before hashing them, which would then be the only character\
    \ that could be XORed between them.  In that case, you should look at [Mcrypt](http://php.net/manual/en/book.mcrypt.php)\
    \ instead.\n<|/ c |>\n<| c |>\nAh yeah, I see what you mean - so I would have\
    \ to do the XOR on the string, not the individual bits. Thanks for the info!\n\
    <|/ c |>\n<| c |>\nYes, you'd have to convert them first before XORing.  It really\
    \ depends on the type of data you're working with.  If it's just a string, you\
    \ could use [`preg_replace()`](http://php.net/manual/en/function.preg-replace.php)\
    \ to replace all non-alphanumeric characters with the empty string (`''`).  Then\
    \ you could XOR those two strings together.\n<|/ c |>\n<| c |>\n: XORing characters\
    \ with another character is the same as XORing them with that character itself\
    \ (except with some weird characters like `-` and `+`). This might be a bad idea,\
    \ because the XOR function doesn't really work on characters, it works on bits\
    \ (numbers). So what happens if I XOR `a` and `b`? What if I XOR `A` and `B`?\
    \ Or `1` and `0`, or any other combination of those two characters. If you want\
    \ to XOR text with text, you might want to use the XOR function of `md5` or `sha1`.\n\
    <|/ c |>\n<| a |>\nI think this answer could help.\n<code>", "    $res = \"\"\
    ;\n    for ($i = 0, $c = count($a); $i < $c; $i++) {\n        $tmp = $a[$i] ^\
    \ $b[$i];\n        $res .= chr($tmp & 0xFF);\n    }\n    return $res;\n}\n", " \
    \ return bin2hex(xor_binary($a, $b));\n}\n", "    return str_pad(dechex(bindec($a\
    \ ^ $b)), 2, '0', STR_PAD_LEFT);\n}\n", "  $result = $a ^ $b;\n  return (string)\
    \ $result;\n}", "  return bin2hex($a ^ $b);\n}\n", "  $len = min(count($a), count($b));\n\
    \  $c = '';\n  for ($i = 0; $i < $len; ++$i) {\n    $c .= chr(ord($a[$i]) ^ ord($b[$i]));\n\
    \  }\n  return $c;\n}", "    return $a ^ $b;\n}\n</code>\n<|/ a dscore=0 tags=bitwise-operators,php,bit-manipulation,php-5.3\
    \ |>\n<| c |>\nThanks. I guess this is what I am looking for.\n<|/ c |>\n<| a\
    \ dscore=0 |>\nMy first attempt was this:\n<code>\n$binstring = \"101\";\n$binstring2\
    \ = \"110\";\n\n$bitstring1 = $binstring ^ $binstring2;\n\necho $bitstring1;\n",
  "  $result = '';\n  for ($i = 0; $i < strlen($a); ++$i) {\n    $result .= substr($a,\
    \ $i, 1) ^ substr($b, $i, 1);\n  }\n  return $result;\n}\n", "  $result = '';\n\
    \  for($i = 0, $len = strlen($a); $i < $len; $i++) {\n    $result .= chr(bindec($a[$i]\
    \ . $b[$i]));\n  }\n  return $result;\n}\n", "    return bin2hex(bin2hex(bin2hex(bin2hex($a)\
    \ ^ bin2hex($b))));\n}\n</code>\n<|/ a tags=php,algorithm |>\n<| a tags=php,algorithm\
    \ |>\nIn PHP, you could use the base_convert function together with the hexdec()\
    \ function.\n<code>\n<?php\n\n$a = \"010\";\n$b = \"110\";\n\n$xor_hex = base_convert($a,\
    \ 2, 10) + base_convert($b, 2, 10);\n\n$xor_hex = hexdec($xor_hex);\n\necho $xor_hex;\n",
  "    $res = '';\n    $len = max(strlen($a), strlen($b));\n    for ($i = 0; $i <\
    \ $len; $i++) {\n        $res .= $a{$i} ^ $b{$i};\n    }\n    return $res;\n}\n",
  "  $x = '';\n  for ($i = 0, $len = strlen($a); $i < $len; $i++) {\n    $x .= substr($b,\
    \ strpos($b, $a{$i}), 1);\n  }\n  return $x;\n}\n", "  $xor = $a ^ $b; // Perform\
    \ XOR\n  return str_pad(decbin($xor), 8, '0', STR_PAD_LEFT); // Pad and convert\
    \ to string\n}", "  return bin2hex(pack(\"H*\", str_replace(\"\\n\", '', $a ^\
    \ $b)));\n}\n", "    return bin2hex(binxor_bin2hex(pack(\"H*\", $a), pack(\"H*\"\
    , $b)));\n}\n</code>\n<|/ a |>\n<| c |>\nIf someone asks why I hate PHP for doing\
    \ things that should be simple - I agree with them. Sadly, PHP is so simple that\
    \ there is no efficient function for it (except perhaps `strlen()`).\n<|/ c |>\n\
    <| c |>\nThe reason that PHP is so simple is because its designers didn't want\
    \ to force every function to do something different from others. So it just forces\
    \ them to do everything else with different syntax and different semantics. That's\
    \ why it's so slow. One of the most famous PHP features was the ability to write\
    \ libraries that work without modifying core code, and that's where the PHP developers\
    \ spend most of their time in. It's really really really not that simple to write\
    \ an efficient library...\n<|/ c |>\n<| c |>\nPHP isn't slow! It just has many\
    \ features that PHP doesn't have. Also, PHP is *slow* because it doesn't have\
    \ many core functions. The core has hundreds of functions. I wrote my own string\
    \ functions (see http://code.google.com/p/php-string-fns/). As for performance,\
    \ PHP was designed from ground up from the ground up to do what it needed to do.\
    \ I also wrote my own extensions in C and C++. There are many PHP extensions written\
    \ in C.\n<|/ c |>\n<| c |>\nWhat PHP has that Python doesn't has is string functions,\
    \ and string objects. You can write extensions in Python, too! I wrote a PHP extension\
    \ for string objects in Python once. It was slow. Maybe it was because I had to\
    \ write it in C.\n<|/ c |>\n<| c |>\nSure you can write extensions in Python,\
    \ but it's much slower than PHP. Because Python has multiple cores and extensions\
    \ require Python libraries, and Python libraries require Python modules. Because\
    \ Python has multiple cores and extensions require Python libraries, it requires\
    \ Python to run PHP every time. PHP runs PHP once, and just because it's a language\
    \ is slow, it's because it doesn't have all the features that Python does.\n<|/\
    \ c |>\n<| a dscore=5 |>\nHere's a way I've solved this problem in the past:\n\
    <code>\n<?php", "  $result = '';\n  for ($i = 0, $len = strlen($a); $i < $len;\
    \ $i++) {\n    $result .= ($a[$i] XOR $b[$i]);\n  }\n  return $result;\n}\n",
  "    // Convert the inputs to binary strings. We do this because the bitwise operations\n\
    \    // will be applied to their binary representations.\n    $a_bin = str_pad(decbin($a),\
    \ 8, '0', STR_PAD_LEFT);\n    $b_bin = str_pad(decbin($b), 8, '0', STR_PAD_LEFT);\n\
    \n    // Perform binary XOR operation on both binary strings and return the result\
    \ as a string.\n    return bin2hex(bindec($a_bin) ^ bindec($b_bin));\n}\n</code>\n\
    <|/ a |>\n<| a |>\nA simple way to get binary output in php is to use sprintf().\n\
    <code>\n$binary = sprintf('%08b', $number);\n</code>\nThis will output a binary\
    \ string in the correct format.\n<|/ a dscore=2 tags=bit-manipulation,php,xor,bitwise-operators\
    \ |>\n<| c |>\nThis isn't portable. `%08b` only works in PHP 5.2 and newer (i.e.\
    \ >= 5.2.1).\n<|/ c |>\n<| a |>\nFor those who need a short (but portable) way\
    \ to get binary number string from int in PHP:\n<code>\n$a = 123;\n$b = 123;\n\
    $bin = sprintf('%032b', decbin($a) ^ decbin($b));\n</code>\n<|/ a tags=bit-manipulation,php,xor,bitwise-operators\
    \ dscore=2 |>\n<| a |>\nFor those who need a short (but portable) way to get binary\
    \ number string from int in PHP:\n<code>\n$a = 0x58;\n$b = 0x28;\n$bin = sprintf('%032b',\
    \ decbin($a) ^ decbin($b));\n</code>\n<|/ a tags=bit-manipulation,php,xor,bitwise-operators\
    \ dscore=2 |>\n<| c |>\nYou probably mean `%08b` since `sprintf` won't output\
    \ leading zeros.\n<|/ c |>\n<| c |>\nOh yes, sorry about that :)\n<|/ c |>\n<|\
    \ a |>\n<code>\n$a = 0x112;\n$b = 0x04;\n\necho bin2hex(xor_bin($a, $b));\n",
  "    $c = strlen($a);\n    $d = strlen($b);\n    $c2 = $c >> 1;\n    $d3 = $d >>\
    \ 1;\n    $res = \"\";\n    for ($i = 0; $i < $c; ++$i) {\n        $res .= $a[$i]\
    \ ^ $b[$c2 - $i];\n    }\n    for ($j = 0; $j < $d; ++$j) {\n        $res .= $b[$d3\
    \ - $j] ^ $a[$c2 - $j];\n    }\n    return $res;\n}", "  $result = '';\n  for\
    \ ($i = strlen($a) - 1; $i >= 0; $i--) {\n    $result .= $a[$i] ^ $b[$i];\n  }\n\
    \  return $result;\n}", "  $len = min(strlen($a), strlen($b));\n  for($i = 0;\
    \ $i < $len; $i++) {\n    if ($a[$i] != $b[$i])\n      $ret = $a[$i];\n  }\n \
    \ return $ret;\n}\n</code>\nSo you see that the function returns a string if the\
    \ two inputs are the same.\nI checked the code and it works fine. \n<code>\n$str\
    \ = \"00101001\";\n$str_xor = string_xor($str, $str);\necho \"$str_xor\";\n</code>\n\
    Output:\n<code>\n101000\n</code>\nIn order to test it I have used strings from\
    \ https://oeis.org/search?q=0110100101101011010110101010111100000110100011011100101101001100101101011010110001001110101110100101101001011111000111110101011110111100101110101101101100101101011001110101110100101101011010110001001101010110110110010111010110110110010110101100111010111010010110101101011000100101101001011111000111110101011110111100101110101101101100101101011001110101110100101101011010110001001101010010111110001111101010111101111001011101011011011001011010110011101011101001011010110101100010010011010101101101100101110101101101100101101011001110101110100101101011010110001001010010110100101111100011111010101111011110010111010110110110010110101100111010111010010110101101011000100100101001011010010111110001111101010111101111001011101011011011001011010110011101011101001011010110101100010011010100101111100011111010101111011110010111010110110110010110101100111010111010010110101101011000100101001001101010110110110010111010110110110010110101100111010111010010110101101011000100100110101001011111000111110101011110111100101110101101101100101101011001110101110100101101011010110001001001010010110100101111100011111010101111011110010111010110110110010110",
  "    $c = strlen($a);\n    $d = strlen($b);\n    $len = max($c, $d);\n    $ret =\
    \ '';\n    for ($i = 0; $i < $len; ++$i) {\n        $ret .= ($a[$i] ^ $b[$i]);\n\
    \    }\n    return $ret;\n}\n", "    $a = str_pad($a, 8, \"0\", STR_PAD_BOTH);\n\
    \    $b = str_pad($b, 8, \"0\", STR_PAD_BOTH);\n    $res = \"\";\n    for ($i\
    \ = 0; $i < 8; $i++) {\n        $c1 = $a[$i];\n        $c2 = $b[$i];\n       \
    \ $res = ($c1 ^ $c2) . $res;\n    }\n    return $res;\n}", "  return bin2hex(bin2hex(bin2hex($a)\
    \ xor bin2hex($b)));\n}\n", "    $a_bit_array = [];\n    $a_array = str_split($a);\n\
    \    $b_array = str_split($b);\n    foreach ($a_array as $v) {\n        foreach\
    \ ($b_array as $v1) {\n            $a_bit_array[] = chr(ord($v) ^ $v1);\n    \
    \    }\n    }\n    return implode(\"\", $a_bit_array);\n}\n", "    $bina = \"\
    0\".dechex(ord($a[1]) ^ ord($b[1]));\n    $binb = \"0\".dechex(ord($a[2]) ^ ord($b[2]));\n\
    \    $result = \"$bina$binb\";\n    return $result;\n}\n</code>\n<|/ a tags=php,xor\
    \ |>\n<| c |>\nThis assumes both strings are hex values, which isn't true in the\
    \ question.  For a binary XOR it needs to be a string.  In addition, you're assuming\
    \ all characters within each string are printable.  For instance, `string_xor(\"\
    00\", \"00\")` will result in `\"00\"`.  While this is probably fine for an XOR\
    \ like this, it isn't correct for the general case.\n<|/ c |>\n<| c |>\nWell,\
    \ the OP has just two input strings, he said \"binary XOR\". My solution assumes\
    \ binary strings as input. If not, it just returns $a, which is why I added a\
    \ comment \"Input are two strings a and b consisting only of 1s and 0s.\"\n<|/\
    \ c |>\n<| c |>\nThe way I read the question is that OP is working with hex values,\
    \ not binary values.\n<|/ c |>\n<| c |>\nExactly. OP's code isn't working with\
    \ hex values, the function he posted isn't working with hex values, the question\
    \ isn't clear at all and the problem isn't stated at all.\n<|/ c |>\n<| c |>\n\
    What does OP mean by \"binary XOR\"? The function shown seems to work with binary\
    \ strings, not hex ones.\n<|/ c |>\n<| a |>\nYou can use the following function\
    \ to do that in one line if you'd like:\n<code>", "  $a_len = strlen($a);\n  $b_len\
    \ = strlen($b);\n  if ($a_len > $b_len) {\n    return $a;\n  }\n  if ($b_len >\
    \ $a_len) {\n    return $b;\n  }\n  $xor = $a;\n  for ($i = 0; $i < $a_len; $i++)\
    \ {\n    $xor .= $a[$i] ^ $b[$i];\n  }\n  return $xor;\n}", "  return str_pad(base_convert(bin2hex(bindec($a)\
    \ ^ bindec($b)), 16, 2), 64, '0', STR_PAD_LEFT);\n}", "  return bin2hex(pack('H*',\
    \ str_replace($a, '', $b)));\n}\n", "  $xor = 0;\n  foreach (str_split($a) as\
    \ $bit_a) {\n    foreach (str_split($b) as $bit_b) {\n      $xor |= (1 << (($bit_a^$bit_b)));\n\
    \    }\n  }\n  return base_convert($xor, 10, 2);\n}\n</code>\n<|/ a tags=php,xor,binary\
    \ dscore=2 |>\n<| c |>\nThank you so much for this great answer.\n<|/ c |>\n<|\
    \ c |>\nSorry for taking so long to accept your answer. I was working on other\
    \ things for my company and I ended up having to work on something else, so I\
    \ haven't been able to try it, but I do believe that this is the answer I was\
    \ looking for. Thanks again!\n<|/ c |>\n<| c |>\n: No need to apologize. I am\
    \ glad I could help. It was a great exercise, and it took me a while to figure\
    \ it out :-)\n<|/ c |>\n<| c |>\nAs a personal note, I've been working on a project\
    \ for about 2 months at work and it took me a little while to figure it out. It's\
    \ also a great solution, so I really appreciate it. Thanks again for your help!\n\
    <|/ c |>\n<| c |>\nYou really know your stuff. Thanks again for your help and\
    \ time taken.\n<|/ c |>\n<| a dscore=2 |>\nI wrote this for fun, maybe it can\
    \ be of use to you:\n<code>\n<?php", "    // convert binary numbers to binary\
    \ strings\n    $a = str_split($a);\n    $b = str_split($b);\n    // loop through\
    \ each binary string in both a and b\n    foreach (array_combine($a, $b) as $char)\
    \ {\n        // xor each character with the next character in each string\n  \
    \      $xor = ord($char[0]) ^ (ord($char[1]) + 1);\n        // convert back to\
    \ a binary string\n        $result = chr($xor);\n    }\n    return $result;\n\
    }\n", "  $binary = str_pad('', max(strlen($a), strlen($b)), '0', STR_PAD_LEFT);\n\
    \  for($i = 0; $i < strlen($a); $i++) {\n    $binary[$i] ^= $a[$i];\n  }\n  for($i\
    \ = 0; $i < strlen($b); $i++) {\n    $binary[$i + strlen($a)] ^= $b[$i];\n  }\n\
    \  return bin2hex(str_rot47($binary));\n}", "    // Return empty string if either\
    \ input is empty or only consists of spaces.\n    if (empty($a) || trim($a) !==\
    \ \"\" || trim($b) !== \"\") {\n        return \"\";\n    }\n\n    // XOR returns\
    \ 0 if the inputs are the same.\n    if ($a === $b) {\n        return \"0\";\n\
    \    }\n\n    // XOR returns 1 if the first input is 1, and the second is 0.\n\
    \    if ($a === \"1\" || $b === \"0\") {\n        return \"1\";\n    }\n\n   \
    \ // XOR returns 1 if the second input is 1, and the first is 0.\n    if ($a ===\
    \ \"0\" && $b === \"1\") {\n        return \"0\";\n    }\n\n    // Otherwise,\
    \ XOR returns 0.\n    return \"0\";\n}\n", "    $c = array();\n    $count = min(strlen($a),\
    \ strlen($b));\n    for ($i = 0; $i < $count; $i++) {\n        $c[] = bindec($a[$i])\
    \ ^ bindec($b[$i]);\n    }\n    return implode('', $c);\n}\n", "  // Make sure\
    \ both strings are the same length.\n  $lena = strlen($a);\n  $lenb = strlen($b);\n\
    \  if ($lena != $lenb) {\n    throw new \\Exception (sprintf('Input strings must\
    \ have same length (%d)', $lena));\n  }\n\n  // Initialize output to empty string.\n\
    \  $out = \"\";\n  for ($i = 0; $i < $lena; $i++) {\n    $out .= $a[$i] ^ $b[$i];\n\
    \  }\n\n  return $out;\n}\n", "    $r = \"\";\n    for ($i = 0; $i < min(count($a),\
    \ count($b)); ++$i) {\n        $r .= $a[$i] ^ $b[$i];\n    }\n    return $r;\n\
    }\n\n/**\n * Convert an integer to binary string representation using given radix\n\
    \ *\n * @param $num       number to convert\n * @param $radix     integer base\
    \ to use to represent the number\n * @param $padChar   character to use to pad\
    \ the number with zeros\n * @param $padLength length of padding to use\n *\n *\
    \ @return binary string representation of the number\n */", "    $a = str_split($a);\n\
    \    $b = str_split($b);\n\n    $ret = '';\n    for ($i = 0; $i < max(count($a),\
    \ count($b)); $i++) {\n        $ret .= $a[$i] ^ $b[$i];\n    }\n    return $ret;\n\
    }", "  $xor_str = '';\n  for ($i = 0; $i < min(strlen($a), strlen($b)); $i++)\
    \ {\n    $xor_str .= chr(bindec($a[$i]) ^ bindec($b[$i]));\n  }\n  return $xor_str;\n\
    }\n", "  $a_int = bindec(a);\n  $b_int = bindec(b);\n  $result = '';\n  for ($i\
    \ = 0; $i < 8; $i++) {\n    $result .= chr(bindec($a_int) ^ (bindec($b_int) <<\
    \ $i));\n  }\n  return $result;\n}", "  return bin2hex(openssl_xor_string($a,\
    \ $b));\n}\n", "  $r = $a;\n  for ($i = 0; $i < strlen($b); $i++) {\n    $r .=\
    \ $a[$b[$i]];\n  }\n  return $r;\n}"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
