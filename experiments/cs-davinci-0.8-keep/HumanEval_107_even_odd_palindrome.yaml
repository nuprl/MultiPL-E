name: HumanEval_107_even_odd_palindrome
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // Given a positive integer n, return a tuple that has the number\
  \ of even and odd\n    // integer palindromes that fall within the range(1, n),\
  \ inclusive.\n    // Example 1:\n    // Input: 3\n    // Output: (1, 2)\n    //\
  \ Explanation:\n    // Integer palindrome are 1, 2, 3. one of them is even, and\
  \ two of them are odd.\n    // Example 2:\n    // Input: 12\n    // Output: (4,\
  \ 6)\n    // Explanation:\n    // Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8,\
  \ 9, 11. four of them are even, and 6 of them are odd.\n    // Note:\n    // 1.\
  \ 1 <= n <= 10^3\n    // 2. returned tuple has the number of even and odd integer\
  \ palindromes respectively.\n    public static Tuple<long, long> EvenOddPalindrome(long\
  \ n) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(EvenOddPalindrome((123L)).Equals((Tuple.Create(8L,\
  \ 13L))));\n    Debug.Assert(EvenOddPalindrome((12L)).Equals((Tuple.Create(4L, 6L))));\n\
  \    Debug.Assert(EvenOddPalindrome((3L)).Equals((Tuple.Create(1L, 2L))));\n   \
  \ Debug.Assert(EvenOddPalindrome((63L)).Equals((Tuple.Create(6L, 8L))));\n    Debug.Assert(EvenOddPalindrome((25L)).Equals((Tuple.Create(5L,\
  \ 6L))));\n    Debug.Assert(EvenOddPalindrome((19L)).Equals((Tuple.Create(4L, 6L))));\n\
  \    Debug.Assert(EvenOddPalindrome((9L)).Equals((Tuple.Create(4L, 5L))));\n   \
  \ Debug.Assert(EvenOddPalindrome((1L)).Equals((Tuple.Create(0L, 1L))));\n    }\n\
  \n}\n"
completions: ["        long[] digitCount = new long[(int)Math.Log10(n) + 1];\n   \
    \     for (long i = 0; i < digitCount.Length; i++) {\n            digitCount[i]\
    \ = (long)Math.Pow(10, i);\n        }\n        digitCount[0] = 0;\n        long[]\
    \ oddCount = new long[digitCount.Length];\n        long[] evenCount = new long[digitCount.Length];\n\
    \        long[] nineCount = new long[digitCount.Length];\n        for (long i\
    \ = 1; i < digitCount.Length; i++) {\n            oddCount[i] = oddCount[i - 1]\
    \ + digitCount[i - 1] * 9;\n            evenCount[i] = evenCount[i - 1] + digitCount[i\
    \ - 1] * 9;\n            nineCount[i] = nineCount[i - 1] + digitCount[i - 1] *\
    \ 9;\n        }\n        Tuple<long, long> result = new Tuple<long, long>(0, 0);\n\
    \        long nn = n;\n        long pow = (long)Math.Pow(10, digitCount.Length\
    \ - 1);\n        for (long i = 0; i < digitCount.Length; i++) {\n            if\
    \ (nn < digitCount[i]) {\n                result = new Tuple<long, long>(result.Item1\
    \ + evenCount[i - 1], result.Item2 + oddCount[i - 1]);\n                break;\n\
    \            }\n            else {\n                if (nn / pow < 9) {\n    \
    \                result = new Tuple<long, long>(result.Item1 + evenCount[i - 1]\
    \ + nn / pow * digitCount[i - 1], result.Item2 + oddCount[i - 1] + nn / pow *\
    \ digitCount[i - 1]);\n                    break;\n                }\n       \
    \         else {\n                    result = new Tuple<long, long>(result.Item1\
    \ + evenCount[i - 1] + nineCount[i - 1], result.Item2 + oddCount[i - 1] + nineCount[i\
    \ - 1]);\n                    nn -= nineCount[i - 1] * pow;\n                }\n\
    \            }\n            pow /", "        if (n == 1) {\n            return\
    \ new Tuple<long, long>(0, 1);\n        }\n        // The odds:\n        // If\
    \ n has an odd number of digits, then the number of palindromes with odd\n   \
    \     // digits is just the number of odd digits at each position:\n        //\
    \ Sum(1 to (n + 1) / 2) 1 = ((n + 1) / 2) ^ 2\n        // If n has an even number\
    \ of digits, then the number of palindromes with odd\n        // digits is the\
    \ number of odd digits at each position except the middle one,\n        // which\
    \ there are as many digits as the middle digit can be:\n        // Sum(1 to n\
    \ / 2) (1 * 9) = ((n / 2) * 9) ^ 2\n        long odd = (n % 2 == 0) ? ((n / 2)\
    \ * 9) : (((n + 1) / 2) * ((n + 1) / 2));\n        // The evens:\n        // The\
    \ count of even palindromes is easier to compute. The middle digit is a factor.\n\
    \        // If n has an odd number of digits, then there is only a single middle\
    \ digit,\n        // and it is either even (if n is > 10) or odd(if n is < 10).\n\
    \        // If n has an even number of digits, then there are as many even palindromes\
    \ as there\n        // are middle digits.\n        // Sum(1 to (n + 1) / 2) 2\
    \ = ((n + 1) / 2) * 2\n        long even = (n % 2 == 0) ? ((n + 1) / 2) : (n >\
    \ 10 ? 1 : 0);\n        return new Tuple<long, long>(even, odd);", "        long\
    \ even = 0;\n        long odd = 0;\n        return Tuple.Create(even, odd);",
  "        long even = 0;\n        long odd = 0;\n        for (long i = 1; i <= n;\
    \ i++) {\n            if (IsPalindrome(i)) {\n                if (i % 2 == 0)\
    \ {\n                    even++;\n                } else {\n                 \
    \   odd++;\n                }\n            }\n        }\n        return new Tuple<long,\
    \ long>(even, odd);", "        var odd = 0L;\n        var even = 0L;\n       \
    \ var count = 0L;\n        for (long number = 1; number <= n; number++) {\n  \
    \          var flag = true;\n            var str = number.ToString();\n      \
    \      for (var i = 0; i < str.Length / 2; i++) {\n                if (str[i]\
    \ != str[str.Length - 1 - i]) {\n                    flag = false;\n         \
    \           break;\n                }\n            }\n            if (flag) {\n\
    \                count++;\n                if (str.Length % 2 == 0)\n        \
    \            even++;\n                else\n                    odd++;\n     \
    \       }\n        }\n        return new Tuple<long, long>(even, odd);", "   \
    \     long even = 0;\n        long odd = 0;\n        return Tuple.Create(even,\
    \ odd);", "        // throw new NotImplementedException();\n        long odd =\
    \ 1;\n        long even = 0;\n        for (long i = 1; i <= n; i++) {\n      \
    \      if (i % 2 == 0) {\n                if (IsPalindrome(i)) {\n           \
    \         even++;\n                }\n            } else {\n                if\
    \ (IsPalindrome(i)) {\n                    odd++;\n                }\n       \
    \     }\n        }\n        return new Tuple<long, long>(even, odd);", "     \
    \   // the number of odd palindromes for n digits is equal to the number of odd\
    \ numbers\n        // for n digits. \n        // So we just need to find the number\
    \ of odd numbers between 1 and n.\n        long e = 0;\n        long o = 0;\n\
    \        while (n > 0) {\n            // if the first digit is odd, then the number\
    \ is odd as well\n            if (n % 10 % 2 == 1) o++;\n            n /= 10;\n\
    \        }\n        // the number of even palindromes is (n+1)/2\n        e =\
    \ (n + 1) / 2;\n        return new Tuple<long, long>(e, o);", "        long ev,\
    \ od;\n        ev = od = 0;\n        for (long i = 1; i <= n; i++) {\n       \
    \     if (i % 2 == 0) {\n                ev++;\n            } else {\n       \
    \         od++;\n            }\n        }\n        return new Tuple<long, long>(ev,\
    \ od);", "        Tuple<long, long> result = new Tuple<long, long>(0, 0);\n  \
    \      // add code here.\n        // EvenOddPalindrome(1): (1, 0)\n        //\
    \ EvenOddPalindrome(2): (2, 0)\n        // EvenOddPalindrome(3): (1, 2)\n    \
    \    // EvenOddPalindrome(4): (4, 0)\n        // EvenOddPalindrome(5): (1, 4)\n\
    \        // EvenOddPalindrome(6): (6, 0)\n        // EvenOddPalindrome(7): (1,\
    \ 6)\n        // EvenOddPalindrome(8): (8, 0)\n        // EvenOddPalindrome(9):\
    \ (1, 8)\n        // EvenOddPalindrome(10): (10, 0)\n        // EvenOddPalindrome(11):\
    \ (1, 10)\n        // EvenOddPalindrome(12): (4, 6)\n        // Notice that there\
    \ is a pattern. \n        // When the input number is a single digit number, i.e.\
    \ 1, 2, 3, ... 9, there is one integer palindrome, which is odd.\n        // When\
    \ the input number is a double digit number, i.e. 10, 11, 12, ... 99, there are\
    \ two integer palindromes, which are odd.\n        // When the input number is\
    \ a triple digit number, i.e. 100, 101, 102, ... 999, there are four integer palindromes,\
    \ which are odd.\n        // From this observation, it is clear that, the odd\
    \ integer palindromes are (1 + 2 + 4 + ...) = 2 ^ (d - 1) where d is the number\
    \ of digits of the input number.\n        // For even integer palindromes, the\
    \ same pattern applies except that 1 is replaced by 2, i.e. (2 + 4 + 8 + ...)\
    \ = 2 ^ d - 1.\n        long evenPalindrome = 0;\n        long oddPalindrome =\
    \ 0;\n        if (n == 1) {\n            evenPalindrome = 1;\n        } else {\n\
    \            // Calculate the number of digits of n\n            long numberOf",
  "        long nEven = 0;\n        long nOdd = 0;\n        return Tuple.Create(nEven,\
    \ nOdd);", "        if (n <= 0) {\n            return new Tuple<long, long>(0,\
    \ 0);\n        }\n        long odds = n / 2;\n        long evens = n % 2 == 0\
    \ ? n / 2 : n / 2 + 1;\n        return new Tuple<long, long>(evens, odds);", " \
    \       if (n < 1 || n > Math.Pow(10, 3))\n            throw new ArgumentOutOfRangeException(\"\
    n\");\n        long even = 0;\n        long odd = 0;\n        for (long i = 1;\
    \ i <= n; i++) {\n            string s = i.ToString();\n            bool isPalindrome\
    \ = true;\n            for (int j = 0; j < s.Length / 2; j++) {\n            \
    \    if (s[j] != s[s.Length - 1 - j]) {\n                    isPalindrome = false;\n\
    \                    break;\n                }\n            }\n            if\
    \ (isPalindrome) {\n                if (s.Length % 2 == 0)\n                 \
    \   even++;\n                else\n                    odd++;\n            }\n\
    \        }\n        return new Tuple<long, long>(even, odd);", "        long even\
    \ = 0;\n        long odd = 0;\n        for (long i = 1; i <= n; i++) {\n     \
    \       if (i < 10) {\n                odd++;\n            } else if (i % 10 ==\
    \ 0) {\n                continue;\n            } else {\n                string\
    \ numStr = i.ToString();\n                bool isPalindrome = true;\n        \
    \        for (int j = 0; j < numStr.Length / 2; j++) {\n                    if\
    \ (numStr[j] != numStr[numStr.Length - 1 - j]) {\n                        isPalindrome\
    \ = false;\n                        break;\n                    }\n          \
    \      }\n                if (isPalindrome) {\n                    if (numStr.Length\
    \ % 2 == 0) {\n                        even++;\n                    } else {\n\
    \                        odd++;\n                    }\n                }\n  \
    \          }\n        }\n        return new Tuple<long, long>(even, odd);", " \
    \       // Write your code here.\n        return Tuple.Create(0L, 0L);", "   \
    \     // Fill this in.\n        var odd = 0;\n        var even = 0;\n        for\
    \ (var i = 1; i <= n; i++) {\n            if (IsPalindrome(i)) {\n           \
    \     if (i % 2 == 0)\n                    even++;\n                else\n   \
    \                 odd++;\n            }\n        }\n        return new Tuple<long,\
    \ long>(even, odd);", "        if (n < 1 || n > Math.Pow(10, 3)) throw new ArgumentOutOfRangeException();\n\
    \        long even = 0, odd = 0;\n        long root = (long)Math.Floor(Math.Sqrt(n));\n\
    \        for (long i = 1; i <= root; i++) {\n            long num = i * i;\n \
    \           if (IsPalindrome(num)) {\n                if (num % 2 == 0) even++;\n\
    \                else odd++;\n            }\n        }\n        return new Tuple<long,\
    \ long>(even, odd);", '        // Write your code here.', "        // see leetcode.com/problems/palindrome-number/\n\
    \        long even = 0;\n        long odd = 0;\n        for (int i = 1; i <= n;\
    \ i++) {\n            if (IsPalindrome(i)) {\n                if (i % 2 == 0)\
    \ {\n                    even++;\n                } else {\n                 \
    \   odd++;\n                }\n            }\n        }\n        return new Tuple<long,\
    \ long>(even, odd);", '        return Tuple.Create(0L, 0L);']
stop_tokens:
- "\n    }\n"
