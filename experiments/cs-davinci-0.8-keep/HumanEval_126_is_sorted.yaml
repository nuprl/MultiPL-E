name: HumanEval_126_is_sorted
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // Given a list of numbers, return whether or not they are sorted\n\
  \    // in ascending order. If list has more than 1 duplicate of the same\n    //\
  \ number, return False. Assume no negative numbers and only integers.\n    // Examples\n\
  \    // is_sorted([5]) \u279E True\n    // is_sorted([1, 2, 3, 4, 5]) \u279E True\n\
  \    // is_sorted([1, 3, 2, 4, 5]) \u279E False\n    // is_sorted([1, 2, 3, 4, 5,\
  \ 6]) \u279E True\n    // is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n    // is_sorted([1,\
  \ 3, 2, 4, 5, 6, 7]) \u279E False\n    // is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
  \    // is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\n    public static bool IsSorted(List<long>\
  \ lst) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(IsSorted((new\
  \ List<long>(new long[]{(long)5L}))) == (true));\n    Debug.Assert(IsSorted((new\
  \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))) ==\
  \ (true));\n    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)3L,\
  \ (long)2L, (long)4L, (long)5L}))) == (false));\n    Debug.Assert(IsSorted((new\
  \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L})))\
  \ == (true));\n    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)2L,\
  \ (long)3L, (long)4L, (long)5L, (long)6L, (long)7L}))) == (true));\n    Debug.Assert(IsSorted((new\
  \ List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)4L, (long)5L, (long)6L,\
  \ (long)7L}))) == (false));\n    Debug.Assert(IsSorted((new List<long>())) == (true));\n\
  \    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L}))) == (true));\n\
  \    Debug.Assert(IsSorted((new List<long>(new long[]{(long)3L, (long)2L, (long)1L})))\
  \ == (false));\n    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)2L,\
  \ (long)2L, (long)2L, (long)3L, (long)4L}))) == (false));\n    Debug.Assert(IsSorted((new\
  \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)3L, (long)3L, (long)4L})))\
  \ == (false));\n    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)2L,\
  \ (long)2L, (long)3L, (long)3L, (long)4L}))) == (true));\n    Debug.Assert(IsSorted((new\
  \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))) == (true));\n\
  \    }\n\n}\n"
completions: ['        return lst.Zip(lst.Skip(1), (a, b) => a < b).All(x => x);',
  "        if (lst.Count == 1) {\n            return true;\n        }\n        long\
    \ last = lst[0];\n        Dictionary<long, long> distincts = new Dictionary<long,\
    \ long>();\n        distincts.Add(last, 1);\n        for (int i = 1; i < lst.Count;\
    \ i++) {\n            long curr = lst[i];\n            if (curr >= last) {\n \
    \               if (distincts.ContainsKey(curr)) {\n                    distincts[curr]\
    \ += 1;\n                    if (distincts[curr] > 1) {\n                    \
    \    return false;\n                    }\n                } else {\n        \
    \            distincts.Add(curr, 1);\n                }\n                last\
    \ = curr;\n            } else {\n                return false;\n            }\n\
    \        }\n        return true;", "        long last = 0;\n        int count\
    \ = 0;\n        foreach (long i in lst) {\n            if (count > 0 && i <= last)\
    \ {\n                return false;\n            }\n            last = i;\n   \
    \         count++;\n        }\n        return true;", "        for (long i = 0;\
    \ i < lst.Count - 1; i++) {\n            if (lst[(int)i] >= lst[(int)i + 1]) {\n\
    \                return false;\n            }\n        }\n        return true;",
  "        HashSet<long> hs = new HashSet<long>();\n        for (int i = 0; i < lst.Count;\
    \ i++) {\n            if (hs.Contains(lst[i])) {\n                return false;\n\
    \            }\n            hs.Add(lst[i]);\n        }\n        for (int i = 0;\
    \ i < lst.Count - 1; i++) {\n            if (lst[i] > lst[i + 1]) {\n        \
    \        return false;\n            }\n        }\n        return true;", "   \
    \     // Initialize vars\n        var test = new List<long>();\n        var prevNum\
    \ = new long();\n        var isSorted = true;\n        // Check inputs\n     \
    \   if (lst.Count < 1) {\n            return false;\n        }\n        if (lst.Count\
    \ == 1) {\n            return true;\n        }\n        // Sort list\n       \
    \ test = lst.OrderBy(i => i).ToList();\n        // Compare vals\n        for (int\
    \ i = 0; i < test.Count; i++) {\n            if (i == 0) {\n                prevNum\
    \ = test[i];\n            } else {\n                if (test[i] == prevNum) {\n\
    \                    isSorted = false;\n                    break;\n         \
    \       } else {\n                    prevNum = test[i];\n                }\n\
    \            }\n        }\n        return isSorted;", "        var prev = lst[0];\n\
    \        var count = 0;\n        foreach (var num in lst) {\n            if (num\
    \ < prev) {\n                return false;\n            }\n            if (num\
    \ == prev) {\n                count++;\n            }\n            if (count >\
    \ 1) {\n                return false;\n            }\n            prev = num;\n\
    \        }\n        return true;", "        HashSet<long> set = new HashSet<long>();\n\
    \        for (int i = 0; i < lst.Count; i++) {\n            if (set.Contains(lst[i]))\
    \ return false;\n            set.Add(lst[i]);\n        }\n        List<long> arr\
    \ = new List<long>(set);\n        arr.Sort();\n        return arr.SequenceEqual(lst);",
  "        // Loop through the list and check if the previous value is less than or\
    \ equal to the next value\n        // If the previous value is greater than the\
    \ next value, return false\n        for (int i = 0; i < lst.Count - 1; i++) {\n\
    \            if (lst[i] > lst[i + 1]) {\n                return false;\n     \
    \       }\n        }\n        return true;", "        bool ret = true;\n     \
    \   if (lst.Count == 1) {\n            return ret;\n        }\n        long prev\
    \ = lst[0];\n        bool match = false;\n        foreach (long i in lst) {\n\
    \            if (prev == i) {\n                if (match) {\n                \
    \    ret = false;\n                    break;\n                }\n           \
    \     match = true;\n            }\n            if (prev > i) {\n            \
    \    ret = false;\n                break;\n            }\n            prev = i;\n\
    \        }\n        return ret;", "        List<long> sort = new List<long>(lst);\n\
    \        sort.Sort();\n        bool flag = true;\n        for (int i = 0; i <\
    \ lst.Count; i++) {\n            if (lst[i] != sort[i]) {\n                flag\
    \ = false;\n                break;\n            }\n        }\n        return flag;",
  "        // Your code goes here\n        return false;", "        bool sorted =\
    \ true;\n        //loop through the list\n        for (int i = 0; i < lst.Count\
    \ - 1; i++) {\n            if (lst[i] > lst[i + 1]) {\n                //if the\
    \ number is greater than the next number\n                sorted = false;\n  \
    \              break;\n            }\n        }\n        return sorted;", "  \
    \      bool works = true;\n        for (int i = 0; i < lst.Count - 1; i++) {\n\
    \            if (lst[i] > lst[i + 1]) works = false;\n        }\n        if (works)\
    \ {\n            List<long> dedupe = new List<long>();\n            foreach (var\
    \ i in lst) {\n                if (!dedupe.Contains(i)) dedupe.Add(i);\n     \
    \       }\n            return dedupe.Count == lst.Count;\n        }\n        return\
    \ false;", "        // first, remove duplicates and put in new list\n        List<long>\
    \ tmp = new List<long>();\n        foreach (long l in lst) {\n            if (!tmp.Contains(l))\
    \ {\n                tmp.Add(l);\n            }\n        }\n        // now, add\
    \ all numbers in tmp to set\n        // and check if we have same size\n     \
    \   HashSet<long> tmpSet = new HashSet<long>();\n        foreach (long l in tmp)\
    \ {\n            tmpSet.Add(l);\n        }\n        if (tmp.Count != tmpSet.Count)\
    \ {\n            return false;\n        }\n        // finally, check if sorted\n\
    \        long last = tmp[0];\n        foreach (long l in tmp) {\n            if\
    \ (l < last) {\n                return false;\n            }\n            last\
    \ = l;\n        }\n        return true;", "        bool sorted = true;\n     \
    \   if (lst.Count > 1) {\n            for (int i = 0; i < lst.Count - 1; i++)\
    \ {\n                if (lst[i] > lst[i + 1]) {\n                    sorted =\
    \ false;\n                    break;\n                }\n            }\n     \
    \   }\n        return sorted;", "        var max = lst.Max();\n        var min\
    \ = lst.Min();\n        if(max != min) {\n            var len = lst.Count;\n \
    \           for(var i = 0; i < len - 1; i++) {\n                if(lst[i] > lst[i\
    \ + 1]) {\n                    return false;\n                }\n            }\n\
    \        }\n        return true;", "        bool result = true;\n        long\
    \ current = lst[0];\n        HashSet<long> check = new HashSet<long>();\n    \
    \    foreach (long item in lst) {\n            if (item > current) {\n       \
    \         check.Add(item);\n                current = item;\n            } else\
    \ {\n                result = false;\n                break;\n            }\n\
    \        }\n        if (check.Count != lst.Count) {\n            result = false;\n\
    \        }\n        return result;", "        // <---- Solution starts here ---->\n\
    \        // For lists shorter than 2 elements it is always true\n        if (lst.Count\
    \ <= 1) return true;\n        // For each number we check if there is a lower\
    \ one in the list,\n        // and if there is one it means that it isn't sorted\n\
    \        for (int i = 0; i < lst.Count - 1; i++) {\n            if (lst.IndexOf(lst[i])\
    \ > lst.IndexOf(lst[i + 1])) return false;\n        }\n        // If we get here,\
    \ list is sorted\n        return true;\n        // <---- Solution ends here ---->",
  "        bool allUnique = (lst.Count == lst.Distinct().Count());\n        bool sorted\
    \ = true;\n        long previous = lst[0];\n        for (int i = 1; i < lst.Count;\
    \ i++) {\n            long current = lst[i];\n            if (current < previous)\
    \ {\n                sorted = false;\n                break;\n            }\n\
    \            previous = current;\n        }\n        return allUnique && sorted;"]
stop_tokens:
- "\n    }\n"
