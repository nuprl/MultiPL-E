name: HumanEval_120_maximum
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // Given an array arr of integers and a positive integer k, return\
  \ a sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
  \ Example 1:\n    // Input: arr = [-3, -4, 5], k = 3\n    // Output: [-4, -3, 5]\n\
  \    // Example 2:\n    // Input: arr = [4, -4, 4], k = 2\n    // Output: [4, 4]\n\
  \    // Example 3:\n    // Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n    //\
  \ Output: [2]\n    // Note:\n    // 1. The length of the array will be in the range\
  \ of [1, 1000].\n    // 2. The elements in the array will be in the range of [-1000,\
  \ 1000].\n    // 3. 0 <= k <= len(arr)\n    public static List<long> Maximum(List<long>\
  \ arr, long k) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(Maximum((new\
  \ List<long>(new long[]{(long)-3L, (long)-4L, (long)5L})), (3L)).Equals((new List<long>(new\
  \ long[]{(long)-4L, (long)-3L, (long)5L}))));\n    Debug.Assert(Maximum((new List<long>(new\
  \ long[]{(long)4L, (long)-4L, (long)4L})), (2L)).Equals((new List<long>(new long[]{(long)4L,\
  \ (long)4L}))));\n    Debug.Assert(Maximum((new List<long>(new long[]{(long)-3L,\
  \ (long)2L, (long)1L, (long)2L, (long)-1L, (long)-2L, (long)1L})), (1L)).Equals((new\
  \ List<long>(new long[]{(long)2L}))));\n    Debug.Assert(Maximum((new List<long>(new\
  \ long[]{(long)123L, (long)-123L, (long)20L, (long)0L, (long)1L, (long)2L, (long)-3L})),\
  \ (3L)).Equals((new List<long>(new long[]{(long)2L, (long)20L, (long)123L}))));\n\
  \    Debug.Assert(Maximum((new List<long>(new long[]{(long)-123L, (long)20L, (long)0L,\
  \ (long)1L, (long)2L, (long)-3L})), (4L)).Equals((new List<long>(new long[]{(long)0L,\
  \ (long)1L, (long)2L, (long)20L}))));\n    Debug.Assert(Maximum((new List<long>(new\
  \ long[]{(long)5L, (long)15L, (long)0L, (long)3L, (long)-13L, (long)-8L, (long)0L})),\
  \ (7L)).Equals((new List<long>(new long[]{(long)-13L, (long)-8L, (long)0L, (long)0L,\
  \ (long)3L, (long)5L, (long)15L}))));\n    Debug.Assert(Maximum((new List<long>(new\
  \ long[]{(long)-1L, (long)0L, (long)2L, (long)5L, (long)3L, (long)-10L})), (2L)).Equals((new\
  \ List<long>(new long[]{(long)3L, (long)5L}))));\n    Debug.Assert(Maximum((new\
  \ List<long>(new long[]{(long)1L, (long)0L, (long)5L, (long)-7L})), (1L)).Equals((new\
  \ List<long>(new long[]{(long)5L}))));\n    Debug.Assert(Maximum((new List<long>(new\
  \ long[]{(long)4L, (long)-4L})), (2L)).Equals((new List<long>(new long[]{(long)-4L,\
  \ (long)4L}))));\n    Debug.Assert(Maximum((new List<long>(new long[]{(long)-10L,\
  \ (long)10L})), (2L)).Equals((new List<long>(new long[]{(long)-10L, (long)10L}))));\n\
  \    Debug.Assert(Maximum((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
  \ (long)-23L, (long)243L, (long)-400L, (long)0L})), (0L)).Equals((new List<long>())));\n\
  \    }\n\n}\n"
completions: ["        long[] freq = new long[2002];\n        long max = -1001;\n\
    \        long min = 1001;\n        foreach (long x in arr) {\n            if (x\
    \ > max) max = x;\n            if (x < min) min = x;\n            freq[x + 1000]++;\n\
    \        }\n        List<long> result = new List<long>();\n        for (long i\
    \ = max; i >= min; i--) {\n            if (freq[i + 1000] > 0) {\n           \
    \     result.Add(i);\n                k--;\n                if (k == 0) break;\n\
    \            }\n        }\n        return result;", "        // Runtime: 92 ms,\
    \ faster than 100.00% of C# online submissions for Maximum k Numbers.\n      \
    \  // Memory Usage: 29.1 MB, less than 100.00% of C# online submissions for Maximum\
    \ k Numbers.\n        List<long> ans = new List<long>();\n        int len = arr.Count;\n\
    \        for (int i = 0; i < len; i++) {\n            for (int j = 0; j < k &&\
    \ j < ans.Count; j++) {\n                if (arr[i] < ans[j]) {\n            \
    \        ans.Insert(j, arr[i]);\n                    break;\n                }\n\
    \                if (j == k - 1 || j == ans.Count - 1) {\n                   \
    \ ans.Add(arr[i]);\n                    break;\n                }\n          \
    \  }\n            if (ans.Count < k) {\n                ans.Add(arr[i]);\n   \
    \         }\n            if (ans.Count > k) {\n                ans.RemoveAt(k);\n\
    \            }\n        }\n        return ans;", "        if (arr.Count == 0)\
    \ return new List<long>();\n        if (arr.Count == 1) return arr;\n        var\
    \ left = new List<long>();\n        var right = new List<long>();\n        var\
    \ pivot = arr[0];\n        for (int i = 1; i < arr.Count; i++) {\n           \
    \ if (arr[i] > pivot) {\n                left.Add(arr[i]);\n            } else\
    \ {\n                right.Add(arr[i]);\n            }\n        }\n        var\
    \ leftCount = left.Count;\n        if (leftCount >= k) {\n            return Maximum(left,\
    \ k);\n        } else if (leftCount == k - 1) {\n            left.Add(pivot);\n\
    \            return left;\n        } else {\n            left.Add(pivot);\n  \
    \          return Maximum(left, k).Concat(Maximum(right, k - leftCount - 1)).ToList();\n\
    \        }", "        List<long> ans = new List<long>();\n        for (int i =\
    \ 0; i < k; i++) {\n            long max = -1000000001;\n            int idx =\
    \ -1;\n            for (int j = 0; j < arr.Count; j++) {\n                if (arr[j]\
    \ > max) {\n                    max = arr[j];\n                    idx = j;\n\
    \                }\n            }\n            ans.Add(max);\n            arr.RemoveAt(idx);\n\
    \        }\n        return ans;", "        // use min heap to maintain the maximum\
    \ k numbers\n        // For each element, check if it is larger than the smallest\
    \ element in the heap\n        // If so, remove the smallest and add the new element\n\
    \        // O(nlogk)\n        var s = new SortedSet<long>();\n        foreach\
    \ (var v in arr) {\n            if (s.Count < k) {\n                s.Add(v);\n\
    \            } else {\n                var min = s.Min;\n                if (v\
    \ > min) {\n                    s.Remove(min);\n                    s.Add(v);\n\
    \                }\n            }\n        }\n        return s.ToList();", " \
    \       Debug.Assert(k > 0);\n        List<long> result = new List<long>();\n\
    \        long count = 0;\n        long min = long.MinValue;\n        foreach (long\
    \ a in arr) {\n            if (count < k) {\n                result.Add(a);\n\
    \                count++;\n                min = Math.Max(min, a);\n         \
    \   } else if (a < min) {\n                continue;\n            } else {\n \
    \               result.Remove(min);\n                result.Add(a);\n        \
    \        min = result.Min();\n            }\n        }\n        return result;",
  '        return arr.OrderByDescending(x => x).Take((int)k).ToList();', "       \
    \ // The main idea is to use Merge Sort to sort the array\n        // We use a\
    \ min heap to store the k-1 smallest numbers in arr\n        // This way we can\
    \ always make the heap contain the k-1 smallest numbers in arr\n        // Thus\
    \ the last element in the heap is the kth smallest number in arr\n        // Time\
    \ Complexity: O(n log n)\n        // Space Complexity: O(n)\n        // where\
    \ n is the length of arr\n        // Observe that we can return the k largest\
    \ numbers in arr by returning the n-k smallest numbers in arr\n        List<long>\
    \ result = new List<long>();\n        // Check if k is in the range of [1, length\
    \ of arr]\n        if (k < 1 || k > arr.Count) return result;\n        // Store\
    \ the k-1 smallest numbers in arr in a min heap\n        // This way the min heap\
    \ will always store the k-1 smallest numbers in arr\n        // Thus the last\
    \ element in the heap is the kth smallest number in arr\n        // Our goal is\
    \ to fill the heap using the first k-1 elements in arr\n        // Store the result\
    \ in a max heap, so that we can return the kth largest number in arr\n       \
    \ SortedSet<long> heap = new SortedSet<long>();\n        for (int i = 0; i < k-1;\
    \ i++) {\n            heap.Add(arr[i]);\n        }\n        // Now we can swap\
    \ the kth smallest number in arr with the kth largest number in arr\n        //\
    \ And merge sort the array\n        // By doing this, the kth largest number in\
    \ arr will be the last element in the result list\n        // And the k-1 largest\
    \ numbers in arr will be in the heap\n        for (int i = k-1; i < arr.Count;\
    \ i++) {\n            heap.Add(arr[i]);\n            long kth = heap.Min;\n  \
    \          heap.Remove(kth);\n            result.Add(kth);\n        }\n      \
    \  // Now we need to reverse the result list, so that we can return the k largest\
    \ numbers in arr\n        // instead of the k smallest numbers in arr\n      \
    \  result.Reverse();\n        return result;", "        List<long> answer = new\
    \ List<long>();\n        if (arr.Count < k) {\n            return arr;\n     \
    \   }\n        // We keep a max heap of length k. We compare the top element to\
    \ our newly sorted\n        // element, and if the new element is bigger, we pop\
    \ the top element and push the\n        // new element. We do this as we iterate\
    \ through the array.\n        Heap maxHeap = new Heap(arr[0]);\n        int i\
    \ = 1;\n        while (i < k) {\n            maxHeap.Push(arr[i]);\n         \
    \   i++;\n        }\n        while (i < arr.Count) {\n            if (arr[i] >\
    \ maxHeap.Top()) {\n                maxHeap.Pop();\n                maxHeap.Push(arr[i]);\n\
    \            }\n            i++;\n        }\n        return maxHeap.ToList();",
  "        // Get the max k numbers from arr.\n        // Use the solution for MergeKSortedArrays\
    \ to merge the k maximum numbers\n        // into a sorted array of size k.\n\
    \        var result = new List<long>();\n        if (arr.Count == 0) return result;\n\
    \        var values = new List<long>();\n        var indexes = new List<long>();\n\
    \        var sorted = new List<long>();\n        foreach (var n in arr) {\n  \
    \          if (values.Count >= k) {\n                var i = 0;\n            \
    \    while (i < values.Count && values[i] > n) i++;\n                if (i ==\
    \ values.Count) continue;\n                values.Insert(i, n);\n            \
    \    values.RemoveAt(values.Count - 1);\n                indexes.Insert(i, n);\n\
    \                indexes.RemoveAt(indexes.Count - 1);\n            } else {\n\
    \                values.Add(n);\n                indexes.Add(n);\n           \
    \ }\n        }\n        for (var i = 0; i < k; i++) {\n            result.Add(0);\n\
    \        }\n        foreach (var i in indexes) {\n            arr.Remove(i);\n\
    \        }\n        MergeSort(ref values, 0, values.Count - 1);\n        MergeSort(ref\
    \ arr, 0, arr.Count - 1);\n        for (var i = 0; i < k; i++) {\n           \
    \ result[i] = values[i];\n        }\n        var j = k - 1;\n        var k0 =\
    \ k;\n        var end = k - 1;\n        while (k0 < arr.Count && j >= 0) {\n \
    \           while (j >= 0 && result[j] >= arr[k0]) {\n                j--;\n \
    \           }\n            if (j >= 0) {\n                while (end > j) {\n\
    \                    result[end] = result[end - 1];\n                    end--;\n\
    \                }\n                result[j] = arr[k0];\n                k0++;\n\
    \                j--;\n            }\n        }\n        return result;", "  \
    \      if (arr.Count == 0) {\n            return new List<long>();\n        }\n\
    \        if (arr.Count == 1) {\n            return arr;\n        }\n        if\
    \ (arr.Count == k) {\n            return arr;\n        }\n        if (k == 1)\
    \ {\n            return new List<long> { arr.Max() };\n        }\n        if (k\
    \ == 2) {\n            var temp = new List<long> { arr[0], arr[1] };\n       \
    \     if (temp[0] < temp[1]) {\n                temp[0] = arr[1];\n          \
    \      temp[1] = arr[0];\n            }\n            for (int i = 2; i < arr.Count;\
    \ i++) {\n                if (arr[i] > temp[0]) {\n                    temp[1]\
    \ = temp[0];\n                    temp[0] = arr[i];\n                } else if\
    \ (arr[i] > temp[1]) {\n                    temp[1] = arr[i];\n              \
    \  }\n            }\n            return temp;\n        }\n        var temp2 =\
    \ new List<long>();\n        for (int i = 0; i < k; i++) {\n            temp2.Add(arr[i]);\n\
    \        }\n        long min = temp2.Min();\n        int minIndex = temp2.IndexOf(min);\n\
    \        for (int i = k; i < arr.Count; i++) {\n            if (arr[i] > min)\
    \ {\n                temp2[minIndex] = arr[i];\n                min = temp2.Min();\n\
    \                minIndex = temp2.IndexOf(min);\n            }\n        }\n  \
    \      return temp2;", "        int length = arr.Count;\n        List<long> result\
    \ = new List<long>();\n        if (k == length) return arr;\n        result.Add(arr[0]);\n\
    \        for (int i = 1; i < k; i++) {\n            result.Add(arr[i]);\n    \
    \        int index = i;\n            while (index > 0 && result[index] > result[index\
    \ - 1]) {\n                Swap(result, index, index - 1);\n                index--;\n\
    \            }\n        }\n        if (k == length) return result;\n        for\
    \ (int i = k; i < length; i++) {\n            if (arr[i] > result[0]) {\n    \
    \            result[0] = arr[i];\n                int index = 0;\n           \
    \     while (index < k - 1 && result[index] > result[index + 1]) {\n         \
    \           Swap(result, index, index + 1);\n                    index++;\n  \
    \              }\n            }\n        }\n        return result;", "       \
    \ // Assume that there exists a function called Partition() that partitions a\
    \ list around\n        // a given pivot, which puts all the values smaller than\
    \ the pivot at the beginning of\n        // the list, and all the values greater\
    \ than the pivot at the end of the list.\n        // This can be done using a\
    \ similar algorithm to QuickSort.\n        // The algorithm below is an implementation\
    \ of the following pseudocode:\n        // List<long> quickselect(List<long> A,\
    \ int k) {\n        //   List<long> S = new List<long>();\n        //   while(A.Count\
    \ > 1) {\n        //     p = choose_pivot(A);\n        //     A = partition(A,\
    \ p);\n        //     if(A.Count == k) {\n        //       S.Add(p);\n       \
    \ //       A.Remove(p);\n        //     }\n        //     else if(A.Count > k)\
    \ {\n        //       S.Add(p);\n        //       A.Remove(p);\n        //   \
    \  }\n        //     else {\n        //       A.AddRange(S);\n        //     \
    \  S.Clear();\n        //     }\n        //   }\n        //   return A;\n    \
    \    // }\n        List<long> S = new List<long>();\n        while(arr.Count >\
    \ 1) {\n            long p = arr[arr.Count / 2];\n            arr = Partition(arr,\
    \ p);\n            if(arr.Count == k) {\n                S.Add(p);\n         \
    \       arr.Remove(p);\n            }\n            else if(arr.Count > k) {\n\
    \                S.Add(p);\n                arr.Remove(p);\n            }\n  \
    \          else {\n                arr.AddRange(S);\n                S.Clear();\n\
    \            }\n        }\n        return arr;", "        long max = 0;\n    \
    \    List<long> ret = new List<long>();\n        arr.Sort();\n        for (int\
    \ i = arr.Count - 1; i >= arr.Count - k; i--) {\n            ret.Add(arr[i]);\n\
    \        }\n        return ret;", "        List<long> res = new List<long>();\n\
    \        arr.Sort();\n        for (int i = arr.Count - 1; i >= arr.Count - k;\
    \ i--) {\n            res.Add(arr[i]);\n        }\n        return res;", "   \
    \     // Your code goes here.\n        return null;", "        // Initialize sorted\
    \ list to return.\n        List<long> sol = new List<long>();\n        // Use\
    \ an auxilary list with an index and element.\n        List<Tuple<long, long>>\
    \ aux = new List<Tuple<long, long>>();\n        // Add all elements from arr to\
    \ the auxilary list.\n        for (long i = 0; i < arr.Count; i++) {\n       \
    \     aux.Add(new Tuple<long, long>(i, arr[(int)i]));\n        }\n        // Sort\
    \ the auxilary list by ascending elements.\n        aux.Sort((x, y) => x.Item2.CompareTo(y.Item2));\n\
    \        // Add the k maximum elements to the solution list.\n        for (long\
    \ i = aux.Count - 1; i >= aux.Count - k; i--) {\n            sol.Add(aux[(int)i].Item2);\n\
    \        }\n        // Return the solution list.\n        return sol;", "    \
    \    List<long> sorted = new List<long>();\n        long prev = long.MinValue;\n\
    \        for (int i = 0; i < arr.Count; i++) {\n            long curr = arr[i];\n\
    \            if (curr >= prev) {\n                sorted.Add(curr);\n        \
    \        prev = curr;\n            } else {\n                int j = 0;\n    \
    \            while (j < sorted.Count && sorted[j] > curr) {\n                \
    \    j++;\n                }\n                sorted.Insert(j, curr);\n      \
    \          sorted.RemoveAt(sorted.Count - 1);\n            }\n        }\n    \
    \    List<long> ans = new List<long>();\n        for (int i = 0; i < k; i++) {\n\
    \            ans.Add(sorted[i]);\n        }\n        return ans;", "        List<long>\
    \ list = new List<long>();\n        foreach (long num in arr) {\n            if\
    \ (list.Count < k) {\n                list.Add(num);\n            } else {\n \
    \               list.Sort();\n                if (num > list[0]) {\n         \
    \           list[0] = num;\n                }\n            }\n        }\n    \
    \    list.Sort();\n        return list;", "        // this is the problem where\
    \ a heap (priority queue) is perfect\n        // best case O(k*log(n))\n     \
    \   // average O(n+k*log(n))\n        // worst case O(n+k*log(n))\n        //\
    \ say we are given a sorted array {1,2,3,4,5} and asked to give the largest 3\
    \ numbers\n        // in the array. we can do this by taking the maximum of each\
    \ adjacent pair and then \n        // recursively applying this process with half\
    \ the size of the input array.\n        // if we want the largest 4 numbers in\
    \ the array we could take the 4 largest pairs \n        // and then recursively\
    \ apply the same process to get the two largest pairs which \n        // would\
    \ contain the four largest numbers.\n        // we can implement this algorithm\
    \ in O(n+k*log(n)) by using a heap. for a 2^n\n        // input we can just create\
    \ a heap of size n to represent the partial results \n        // then repeatedly\
    \ add new data from the end of the array and pop the heap until\n        // its\
    \ size is k. we can use the same heap to store the final results.\n        //\
    \ because we only need to store k numbers at a time, we only need to build a \n\
    \        // heap of size k then add the largest results to the front of the output\
    \ array\n        // until the size of the heap is 0.\n        // this is essentially\
    \ just a heap sort for the largest k elements in the input\n        // heap sort\
    \ is O(n*log(n)) this is O(n+k*log(n)) so its better for k << n\n        // in\
    \ particular if k is around n/2 or less this is much better than O(n*log(n))\n\
    \        // best case O(k*log(n))\n        // average O(n+k*log(n))\n        //\
    \ worst case O(n+k*log(n))\n        // actually i guess its just a heap sort\n\
    \        // best case O(n+k*log(n))\n        // average O(n+k*log(n))\n      \
    \  // worst case O(n+k*log(n))\n        // space O(k)\n        if (k <= 0) return\
    \ new List"]
stop_tokens:
- "\n    }\n"
