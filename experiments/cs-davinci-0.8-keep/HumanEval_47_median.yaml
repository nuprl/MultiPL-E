name: HumanEval_47_median
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // Return median of elements in the list l.\n    // >>> median([3,\
  \ 1, 2, 4, 5])\n    // 3\n    // >>> median([-10, 4, 6, 1000, 10, 20])\n    // 15.0\n\
  \    public static float Median(List<long> l) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(Median((new\
  \ List<long>(new long[]{(long)3L, (long)1L, (long)2L, (long)4L, (long)5L}))) ==\
  \ (float)3L);\n    Debug.Assert(Median((new List<long>(new long[]{(long)-10L, (long)4L,\
  \ (long)6L, (long)1000L, (long)10L, (long)20L}))) == (8.0f));\n    Debug.Assert(Median((new\
  \ List<long>(new long[]{(long)5L}))) == (float)5L);\n    Debug.Assert(Median((new\
  \ List<long>(new long[]{(long)6L, (long)5L}))) == (5.5f));\n    Debug.Assert(Median((new\
  \ List<long>(new long[]{(long)8L, (long)1L, (long)3L, (long)9L, (long)9L, (long)2L,\
  \ (long)7L}))) == (float)7L);\n    }\n\n}\n"
completions: ["        // Sort the list.\n        l.Sort();\n        int mid = l.Count\
    \ / 2;\n        if (l.Count % 2 == 0) {\n            return (l[mid - 1] + l[mid])\
    \ / 2.0f;\n        } else {\n            return l[mid];\n        }", "       \
    \ int size = l.Count;\n        int mid = size / 2;\n        if (size % 2 == 0)\
    \ {\n            return (l[mid] + l[mid - 1]) / 2.0f;\n        } else {\n    \
    \        return l[mid];\n        }", "        l.Sort();\n        if (l.Count %\
    \ 2 == 0)\n            return (l[l.Count / 2] + l[l.Count / 2 - 1]) / 2.0f;\n\
    \        else\n            return l[l.Count / 2];", "        l.Sort();\n     \
    \   int len = l.Count;\n        int mid = len / 2;\n        return (len % 2 ==\
    \ 0) ? (l[mid] + l[mid - 1]) / 2.0f : l[mid];", "        if (l.Count % 2 == 0)\
    \ {\n            return (l[l.Count / 2] + l[l.Count / 2 - 1]) / 2.0f;\n      \
    \  } else {\n            return l[l.Count / 2];\n        }", "        var t =\
    \ l.OrderBy(x => x).ToList();\n        int m = t.Count;\n        if (m % 2 ==\
    \ 0) {\n            return (t[m / 2 - 1] + t[m / 2]) / 2.0f;\n        } else {\n\
    \            return t[m / 2];\n        }", "        l.Sort();\n        var n =\
    \ l.Count;\n        float median;\n        if (n % 2 == 0) {\n            median\
    \ = (l[n / 2] + l[n / 2 - 1]) / 2.0f;\n        } else {\n            median =\
    \ l[n / 2];\n        }\n        return median;", "        int n = l.Count;\n \
    \       l.Sort();\n        if (n % 2 == 0)\n            return (l[n / 2 - 1] +\
    \ l[n / 2]) / 2.0f;\n        else\n            return l[n / 2];", "        l.Sort();\n\
    \        if (l.Count % 2 == 0) {\n            return (l[l.Count / 2] + l[l.Count\
    \ / 2 - 1]) / 2.0f;\n        } else {\n            return l[l.Count / 2];\n  \
    \      }", "        l.Sort();\n        int mid = l.Count / 2;\n        if (l.Count\
    \ % 2 == 0)\n            return (l[mid] + l[mid - 1]) / 2.0f;\n        else\n\
    \            return l[mid];", "        if (l.Count % 2 == 0) {\n            return\
    \ (l[l.Count / 2] + l[l.Count / 2 - 1]) / 2f;\n        } else {\n            return\
    \ l[l.Count / 2];\n        }", "        int n = l.Count;\n        List<long> ll\
    \ = new List<long>(l);\n        ll.Sort();\n        if (n % 2 == 1) {\n      \
    \      return ll[n / 2];\n        } else {\n            return (ll[n / 2 - 1]\
    \ + ll[n / 2]) / 2.0f;\n        }", "        if (l.Count == 0) return 0;\n   \
    \     if (l.Count % 2 == 1) return l[l.Count / 2];\n        return (l[l.Count\
    \ / 2 - 1] + l[l.Count / 2]) / 2.0f;", "        int n = l.Count;\n        l.Sort();\n\
    \        if (n % 2 == 0) {\n            // n is even.\n            return (l[n\
    \ / 2 - 1] + l[n / 2]) / 2.0f;\n        } else {\n            // n is odd.\n \
    \           return l[n / 2];\n        }", "        var sl = new SortedList<long,\
    \ int>(l.Count);\n        foreach (var e in l) {\n            if (sl.ContainsKey(e))\
    \ {\n                sl[e]++;\n            } else {\n                sl.Add(e,\
    \ 1);\n            }\n        }\n        var n = l.Count;\n        var half =\
    \ n / 2;\n        var k = 0;\n        var m1 = 0L;\n        var m2 = 0L;\n   \
    \     foreach (var e in sl.Keys) {\n            var c = sl[e];\n            if\
    \ (c == 1) {\n                k++;\n                if (k == half + 1) {\n   \
    \                 m1 = e;\n                } else if (k == half + 2) {\n     \
    \               m2 = e;\n                    break;\n                }\n     \
    \       } else {\n                if (k <= half && half < k + c) {\n         \
    \           m1 = e;\n                } else if (k + c - 1 == half) {\n       \
    \             m2 = e;\n                    break;\n                }\n       \
    \         k += c;\n            }\n        }\n        if (n % 2 == 1) {\n     \
    \       return m1;\n        } else {\n            return (m1 + m2) / 2.0f;\n \
    \       }", "        long middle = l.Count / 2;\n        if (l.Count % 2 == 0)\
    \ {\n            return (l[middle - 1] + l[middle]) / 2.0f;\n        } else {\n\
    \            return l[middle];\n        }", "        int n = l.Count;\n      \
    \  if (n == 0) {\n            throw new InvalidOperationException(\"Median of\
    \ empty list\");\n        }\n        l.Sort();\n        if (n % 2 == 1) {\n  \
    \          return l[n / 2];\n        } else {\n            return (l[n / 2 - 1]\
    \ + l[n / 2]) / 2.0f;\n        }", "        float med = 0;\n        int len =\
    \ l.Count;\n        if (len == 0) {\n            return 0;\n        }\n      \
    \  else if (len % 2 == 0) {\n            med = (l[len / 2] + l[len / 2 - 1]) /\
    \ 2;\n        }\n        else {\n            med = l[len / 2];\n        }\n  \
    \      return med;", "        int n = l.Count;\n        long[] t = l.ToArray();\n\
    \        Array.Sort(t);\n        float m;\n        if (n % 2 == 0) {\n       \
    \     m = ((float)t[n / 2] + (float)t[n / 2 - 1]) / 2;\n        } else {\n   \
    \         m = (float)t[n / 2];\n        }\n        return m;", "        if (l.Count\
    \ == 0)\n            return 0;\n        int i = l.Count / 2;\n        if (l.Count\
    \ % 2 == 0)\n            return (l[i - 1] + l[i]) / 2.0f;\n        else\n    \
    \        return l[i];"]
stop_tokens:
- "\n    }\n"
