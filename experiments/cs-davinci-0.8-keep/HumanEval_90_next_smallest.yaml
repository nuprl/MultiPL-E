name: HumanEval_90_next_smallest
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // You are given a list of integers.\n    // Write a function next_smallest()\
  \ that returns the 2nd smallest element of the list.\n    // Return None if there\
  \ is no such element.\n    // next_smallest([1, 2, 3, 4, 5]) == 2\n    // next_smallest([5,\
  \ 1, 4, 3, 2]) == 2\n    // next_smallest([]) == None\n    // next_smallest([1,\
  \ 1]) == None\n    public static Nullable<long> NextSmallest(List<long> lst) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(NextSmallest((new\
  \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))).Equals(2L));\n\
  \    Debug.Assert(NextSmallest((new List<long>(new long[]{(long)5L, (long)1L, (long)4L,\
  \ (long)3L, (long)2L}))).Equals(2L));\n    Debug.Assert(NextSmallest((new List<long>())).Equals(null));\n\
  \    Debug.Assert(NextSmallest((new List<long>(new long[]{(long)1L, (long)1L}))).Equals(null));\n\
  \    Debug.Assert(NextSmallest((new List<long>(new long[]{(long)1L, (long)1L, (long)1L,\
  \ (long)1L, (long)0L}))).Equals(1L));\n    Debug.Assert(NextSmallest((new List<long>(new\
  \ long[]{(long)1L, (long)1L}))).Equals(null));\n    Debug.Assert(NextSmallest((new\
  \ List<long>(new long[]{(long)-35L, (long)34L, (long)12L, (long)-45L}))).Equals(-35L));\n\
  \    }\n\n}\n"
completions: ["        // TODO\n        throw new NotImplementedException();", " \
    \       // TODO: return the 2nd smallest element of the list\n        // or null\
    \ if there is no such element\n        long min = lst[0];\n        long min2 =\
    \ long.MaxValue;\n        for (int i = 1; i < lst.Count; i++) {\n            if\
    \ (lst[i] < min) {\n                min2 = min;\n                min = lst[i];\n\
    \            } else if (lst[i] < min2) {\n                min2 = lst[i];\n   \
    \         }\n        }\n        if (min2 == long.MaxValue) {\n            return\
    \ null;\n        }\n        return min2;", "        if (lst.Count < 2) {\n   \
    \         return null;\n        }\n        lst.Sort();\n        for (int i = 1;\
    \ i < lst.Count; i++) {\n            if (lst[i] != lst[i - 1]) {\n           \
    \     return lst[i];\n            }\n        }\n        return null;", '        throw
    new NotImplementedException();', "        if (lst.Count == 0) {\n            return\
    \ null;\n        }\n        var min1 = lst[0];\n        var min2 = long.MaxValue;\n\
    \        for (int i = 1; i < lst.Count; i++) {\n            if (lst[i] < min1)\
    \ {\n                min2 = min1;\n                min1 = lst[i];\n          \
    \  } else if (lst[i] < min2) {\n                min2 = lst[i];\n            }\n\
    \        }\n        if (min2 == long.MaxValue) {\n            return null;\n \
    \       }\n        return min2;", "        if (lst.Count < 2) {\n            return\
    \ null;\n        }\n\n        // Sort in ascending order\n        lst.Sort();\n\
    \n        // The 2nd smallest element is the first element of the list that isn't\
    \ equal to the first element\n        if (lst[0] == lst[1]) {\n            return\
    \ null;\n        } else {\n            return lst[1];\n        }", "        var\
    \ sorted = lst.OrderBy(x => x).ToList();\n        if (sorted.Count < 2) return\
    \ null;\n        return sorted[1];", "        //BEGIN\n        if (lst.Count ==\
    \ 0)\n            return null;\n        lst.Sort();\n        if (lst.Count ==\
    \ 1)\n            return null;\n        if (lst[0] != lst[1])\n            return\
    \ lst[1];\n        for (int i = 2; i < lst.Count; i++)\n            if (lst[i]\
    \ != lst[i - 1])\n                return lst[i];\n        return null;\n     \
    \   //END", "        if (lst.Count < 2) return null;\n        long smallest =\
    \ long.MaxValue;\n        long nextSmallest = long.MaxValue;\n        foreach\
    \ (long l in lst) {\n            if (l < smallest) {\n                nextSmallest\
    \ = smallest;\n                smallest = l;\n            } else if (l < nextSmallest)\
    \ {\n                nextSmallest = l;\n            }\n        }\n        if (nextSmallest\
    \ == long.MaxValue) return null;\n        return nextSmallest;", "        if (lst.Count\
    \ == 0) return null;\n        if (lst.Count == 1) return null;\n        var min\
    \ = long.MaxValue;\n        var min2 = long.MaxValue;\n        foreach (var i\
    \ in lst) {\n            if (i < min) {\n                min2 = min;\n       \
    \         min = i;\n            } else if (i < min2) {\n                min2 =\
    \ i;\n            }\n        }\n        if (min2 == long.MaxValue) return null;\n\
    \        return min2;", "        // your solution here\n        return null;",
  "        long smallest = long.MaxValue;\n        long smallestNext = long.MaxValue;\n\
    \        foreach (long x in lst) {\n            if (x <= smallest) {\n       \
    \         smallestNext = smallest;\n                smallest = x;\n          \
    \  } else if (x < smallestNext) {\n                smallestNext = x;\n       \
    \     }\n        }\n        if (smallestNext == long.MaxValue) {\n           \
    \ return null;\n        }\n        return smallestNext;", "        if (lst.Count\
    \ < 2) return null;\n        long mn = Math.Min(lst[0], lst[1]);\n        long\
    \ sm = Math.Max(lst[0], lst[1]);\n        for (int i = 2; i < lst.Count; i++)\
    \ {\n            if (lst[i] < mn) {\n                sm = mn;\n              \
    \  mn = lst[i];\n            } else if (lst[i] < sm) {\n                sm = lst[i];\n\
    \            }\n        }\n        return sm == mn ? (Nullable<long>)null : sm;",
  "        if (lst.Count == 0) return null;\n        else if (lst.Count == 1) return\
    \ null;\n        else if (lst.Count == 2) {\n            if (lst[0] == lst[1])\
    \ return null;\n            else return lst[0] < lst[1] ? lst[0] : lst[1];\n \
    \       }\n        else {\n            // find the minimum\n            long min\
    \ = lst[0];\n            foreach (long n in lst) {\n                if (n < min)\
    \ min = n;\n            }\n            // find the second minimum\n          \
    \  long secondMin = long.MaxValue;\n            foreach (long n in lst) {\n  \
    \              if (n != min && n < secondMin) secondMin = n;\n            }\n\
    \            return secondMin;\n        }", "        // Your code here!\n    \
    \    return null;", "        // Your code goes here\n        // Replace the return\
    \ statement below with your code\n        long smallest = lst[0];\n        long\
    \ secondSmallest = lst[0];\n        foreach (long number in lst)\n        {\n\
    \            if (number < smallest)\n            {\n                secondSmallest\
    \ = smallest;\n                smallest = number;\n            }\n           \
    \ else if (number < secondSmallest && number != smallest)\n            {\n   \
    \             secondSmallest = number;\n            }\n        }\n        if (secondSmallest\
    \ == smallest)\n        {\n            return null;\n        }\n        return\
    \ secondSmallest;", "        if (lst.Count == 0) {\n            return null;\n\
    \        }\n        else if (lst.Count == 1) {\n            return null;\n   \
    \     }\n        else {\n            long min = lst[0];\n            long nextMin\
    \ = lst[1];\n            for (int i = 1; i < lst.Count; i++) {\n             \
    \   if (lst[i] < min) {\n                    nextMin = min;\n                \
    \    min = lst[i];\n                }\n                else if (lst[i] < nextMin)\
    \ {\n                    nextMin = lst[i];\n                }\n            }\n\
    \            if (min == nextMin) {\n                return null;\n           \
    \ }\n            else {\n                return nextMin;\n            }\n    \
    \    }", "        long first = long.MaxValue;\n        long second = long.MaxValue;\n\
    \        int sz = lst.Count;\n        for (int i = 0; i < sz; i++) {\n       \
    \     if (lst[i] < first) {\n                second = first;\n               \
    \ first = lst[i];\n            } else if (lst[i] < second && lst[i] != first)\
    \ {\n                second = lst[i];\n            }\n        }\n        if (second\
    \ == long.MaxValue) {\n            return null;\n        }\n        return second;",
  "        lst.Sort();\n        if (lst.Count < 2) {\n            return null;\n \
    \       }\n        if (lst[0] == lst[1]) {\n            return null;\n       \
    \ }\n        return lst[1];", "        // Nullable<long> is like a long with a\
    \ \"null\" option\n        // (since long has no \"null\" option).\n        throw\
    \ new NotImplementedException();"]
stop_tokens:
- "\n    }\n"
