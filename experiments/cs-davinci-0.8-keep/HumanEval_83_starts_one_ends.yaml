name: HumanEval_83_starts_one_ends
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // Given a positive integer n, return the count of the numbers\
  \ of n-digit\n    // positive integers that start or end with 1.\n    public static\
  \ long StartsOneEnds(long n) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(StartsOneEnds((1L))\
  \ == (1L));\n    Debug.Assert(StartsOneEnds((2L)) == (18L));\n    Debug.Assert(StartsOneEnds((3L))\
  \ == (180L));\n    Debug.Assert(StartsOneEnds((4L)) == (1800L));\n    Debug.Assert(StartsOneEnds((5L))\
  \ == (18000L));\n    }\n\n}\n"
completions: ["        if (n == 1) {\n            return 10;\n        } else if (n\
    \ == 2) {\n            return 55;\n        } else {\n            return (10 *\
    \ StartsOneEnds(n - 1) - 9 * StartsOneEnds(n - 2));\n        }", "        if (n\
    \ == 1) return 1;\n        return (n - 1) * n / 2 + n + 1;", "        if (n ==\
    \ 1) {\n            return 10;\n        }\n        if (n == 2) {\n           \
    \ return 81;\n        }\n        if (n > 19) {\n            // The answer is infinite.\n\
    \            return 1;\n        }\n        return (1 + 9 * n) * StartsOneEnds(n\
    \ - 1);", "        // Assume n > 0\n        if (n == 1) {\n            return\
    \ 10;\n        } else if (n == 2) {\n            return 9 * 10;\n        }\n \
    \       long[] cache = new long[n];\n        cache[0] = 10;\n        cache[1]\
    \ = 9 * 10;\n        for (int i = 2; i < n; i++) {\n            cache[i] = 10\
    \ * cache[i - 1] - cache[i - 2];\n        }\n        return 2 * cache[n - 1] -\
    \ cache[n - 2];", "        if (n == 1) return 1;\n        // Use:\n        //\
    \   f(n) = 2 * (1 + f(n-1)) - 1\n        // which is a linear recurrence with\
    \ constant coefficients.\n        long[] a = new long[(int)n + 1];\n        a[1]\
    \ = 1;\n        for (int i = 2; i <= n; i++) {\n            a[i] = 2 * (1 + a[i\
    \ - 1]) - 1;\n        }\n        return a[n];", "        long result = 0;\n  \
    \      int digit = 1;\n        for (int i = 1; i <= n; i++) {\n            result\
    \ += digit;\n            digit *= 10;\n        }\n        return result;", " \
    \       // The first digit has to be a 1, so we can imagine a (n-1)-digit number\n\
    \        // without the first digit. So we solve the problem for (n-1) and then\n\
    \        // multiply the result by 9.\n        if (n == 1) {\n            return\
    \ 1;\n        } else {\n            return 9 * StartsOneEnds(n - 1);\n       \
    \ }", "        // 2 valid ones at the beginning\n        long[,] dp = new long[n,\
    \ 2];\n        dp[0, 0] = 2;\n        dp[0, 1] = 0;\n        for (int i = 1; i\
    \ < n; i++) {\n            // number of numbers that start and end with 1\n  \
    \          dp[i, 1] = dp[i - 1, 0];\n            // number of numbers that end\
    \ with 1 but don't start with 1\n            dp[i, 0] = 9 * dp[i - 1, 0] + 10\
    \ * dp[i - 1, 1];\n        }\n        return dp[n - 1, 0] + dp[n - 1, 1];", " \
    \       if (n == 1) return 1;\n        var start = n - 1;\n        var middle\
    \ = (BigInteger)10;\n        for (long i = 1; i < n - 1; i++) {\n            middle\
    \ *= 10;\n        }\n        var end = 1;\n        if (n == 2) end = 0;\n    \
    \    return start + (long)middle + end;", "        BigInteger a = BigInteger.Pow(10,\
    \ n) - 2 * BigInteger.Pow(9, n) + BigInteger.Pow(8, n);\n        BigInteger b\
    \ = (BigInteger.Pow(10, n) - BigInteger.Pow(9, n));\n        BigInteger d = BigInteger.GreatestCommonDivisor(a,\
    \ b);\n        return (long)(a / d);", "        if (n == 1) {\n            return\
    \ 1;\n        }\n        // Suppose the number starts with 1. Then the number\
    \ of ways to fill in\n        // the rest is simply 9 ^ (n - 1).\n        // Suppose\
    \ the number ends with 1. Then the number of ways to fill in the\n        // rest\
    \ is (9 ^ (n - 1) - 1) since we don't want the number to start with\n        //\
    \ 0.\n        // Finally add the two and subtract 1 since otherwise we overcounted\
    \ the\n        // numbers that start and end with 1.\n        return (9L * 9.Pow(n\
    \ - 1) - 1) + (9L * 9.Pow(n - 1) - 1) - 1;", "        Debug.Assert(n > 0);\n \
    \       var start = n - 1;\n        var end = 1;\n        var zeroes = n - 2;\n\
    \        if (n == 1) {\n            return 1;\n        }\n        if (n == 2)\
    \ {\n            return 11;\n        }\n        if (n == 3) {\n            return\
    \ 111;\n        }\n        var res = start * 10;\n        res += 10 + (1 * 2 *\
    \ 10);\n        while (zeroes > 1) {\n            res += 10 * 10 * 9;\n      \
    \      zeroes--;\n        }\n        return res;", "        var dp = new long[n\
    \ + 1];\n        dp[1] = 1;\n        for (int i = 2; i <= n; i++) {\n        \
    \    // Choose ending digit of n.\n            dp[i] = dp[i - 1] * 10;\n     \
    \       // Choose starting digit of n.\n            dp[i] += dp[i - 1];\n    \
    \        // Choose ending digit of n - 1.\n            dp[i] += dp[i - 1] * 9;\n\
    \        }\n        return dp[n];", "        // Staring with 1, the digit can\
    \ end in any of the remaining n-1 digits.\n        // Stopping with 1, the digit\
    \ can start with any of the remaining n-1\n        // digits.\n        return\
    \ (n - 1) * (long)Math.Pow(10, n - 2);", "        var dp = new long[n + 1];\n\
    \        dp[1] = 2;\n        for (int i = 2; i <= n; i++) {\n            dp[i]\
    \ = dp[i - 1] + 8 * (long)Math.Pow(10, i - 2);\n        }\n        return dp[n];",
  "        if (n == 1) return 2;\n        return 10 * Stirling(n - 1) - 9;", "   \
    \     // We can think of the numbers as composed of two parts: the\n        //\
    \ \"end\" digits and the \"middle\" digits.\n        // The end digits are either\
    \ 01 or 10.\n        // Given some middle digits, the number of possible numbers\
    \ is\n        // 10^(n-2).\n        //\n        // However, there is a restriction\
    \ that we must abide by: the\n        // middle digits must be strictly non-decreasing.\n\
    \        //\n        // For example, for n = 3 we have\n        // 10, 11, 12,\
    \ 13, 14, 15, 16, 17, 18, 19\n        // 20, 21, 22, 23, 24, 25, 26, 27, 28, 29\n\
    \        // 30, 31, 32, 33, 34, 35, 36, 37, 38, 39\n        // 40, 41, 42, 43,\
    \ 44, 45, 46, 47, 48, 49\n        // 50, 51, 52, 53, 54, 55, 56, 57, 58, 59\n\
    \        // 60, 61, 62, 63, 64, 65, 66, 67, 68, 69\n        // 70, 71, 72, 73,\
    \ 74, 75, 76, 77, 78, 79\n        // 80, 81, 82, 83, 84, 85, 86, 87, 88, 89\n\
    \        // 90, 91, 92, 93, 94, 95, 96, 97, 98, 99\n        //\n        // We\
    \ see that the first digit of the middle digits must be 0 to be\n        // non-decreasing,\
    \ and since we have n-2 middle digits, there are\n        // 9 choices for the\
    \ first digit and 8 choices for the remaining\n        // digits.\n        //\
    \ \n        // The count of middle digits is the number of ways to choose\n  \
    \      // n-2 non-negative integers that sum to 9.\n        //\n        // The\
    \ number of ways to choose k positive integers that sum to n\n        // is the\
    \ partition number p(n, k).\n        // There is an algorithm that computes these\
    \ numbers in O(n^2).\n        //\n        // To compute the number of ways to\
    \ choose n-2 non-negative integers\n        // that sum to 9, we note that this\
    \ is the same as the number of ways\n        // to choose n-1 positive integers\
    \ that sum", '        return StartsWithOneEnds(n) + EndsWithOneStarts(n);', " \
    \       if (n == 1) {\n            return 1;\n        }\n        if (n == 2) {\n\
    \            return 2;\n        }\n        if (n == 3) {\n            return 3;\n\
    \        }\n        long res = 0;\n        if (n % 2 == 0) {\n            res\
    \ += 2;\n        }\n        res += StartsOneEnds(n - 1);\n        res += StartsOneEnds(n\
    \ - 2);\n        return res;", "        // Dynamic programming.\n        long[]\
    \ a = new long[n + 1];\n        long[] b = new long[n + 1];\n        a[1] = b[1]\
    \ = 2;\n        for (int i = 2; i <= n; i++) {\n            a[i] = a[i - 1] +\
    \ b[i - 1];\n            b[i] = a[i - 1];\n        }\n        return a[n] + b[n];"]
stop_tokens:
- "\n    }\n"
