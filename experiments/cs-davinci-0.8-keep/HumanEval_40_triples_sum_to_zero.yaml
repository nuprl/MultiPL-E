name: HumanEval_40_triples_sum_to_zero
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // triples_sum_to_zero takes a list of integers as an input.\n\
  \    // it returns True if there are three distinct elements in the list that\n\
  \    // sum to zero, and False otherwise.\n    // >>> triples_sum_to_zero([1, 3,\
  \ 5, 0])\n    // False\n    // >>> triples_sum_to_zero([1, 3, -2, 1])\n    // True\n\
  \    // >>> triples_sum_to_zero([1, 2, 3, 7])\n    // False\n    // >>> triples_sum_to_zero([2,\
  \ 4, -5, 3, 9, 7])\n    // True\n    // >>> triples_sum_to_zero([1])\n    // False\n\
  \    public static bool TriplesSumToZero(List<long> l) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(TriplesSumToZero((new\
  \ List<long>(new long[]{(long)1L, (long)3L, (long)5L, (long)0L}))) == (false));\n\
  \    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)3L,\
  \ (long)5L, (long)-1L}))) == (false));\n    Debug.Assert(TriplesSumToZero((new List<long>(new\
  \ long[]{(long)1L, (long)3L, (long)-2L, (long)1L}))) == (true));\n    Debug.Assert(TriplesSumToZero((new\
  \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)7L}))) == (false));\n\
  \    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)2L,\
  \ (long)5L, (long)7L}))) == (false));\n    Debug.Assert(TriplesSumToZero((new List<long>(new\
  \ long[]{(long)2L, (long)4L, (long)-5L, (long)3L, (long)9L, (long)7L}))) == (true));\n\
  \    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)1L}))) == (false));\n\
  \    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)3L,\
  \ (long)5L, (long)-100L}))) == (false));\n    Debug.Assert(TriplesSumToZero((new\
  \ List<long>(new long[]{(long)100L, (long)3L, (long)5L, (long)-100L}))) == (false));\n\
  \    }\n\n}\n"
completions: ["        // Your code here.\n        long zero = 0;\n        int i =\
    \ 0;\n        while (i < l.Count()) {\n            long first = l[i];\n      \
    \      int j = i + 1;\n            while (j < l.Count()) {\n                long\
    \ second = l[j];\n                int k = j + 1;\n                while (k < l.Count())\
    \ {\n                    long third = l[k];\n                    if (first + second\
    \ + third == zero) {\n                        return true;\n                 \
    \   }\n                    k++;\n                }\n                j++;\n   \
    \         }\n            i++;\n        }\n        return false;", "        //\
    \ Fill in your solution here.\n        List<Tuple<long, long, long>> result =\
    \ new List<Tuple<long, long, long>>();\n        for (int i = 0; i < l.Count; i++)\
    \ {\n            for (int j = i + 1; j < l.Count; j++) {\n                for\
    \ (int k = j + 1; k < l.Count; k++) {\n                    if (l[i] + l[j] + l[k]\
    \ == 0) {\n                        result.Add(new Tuple<long, long, long>(l[i],\
    \ l[j], l[k]));\n                    }\n                }\n            }\n   \
    \     }\n        return result.Count > 0;", "        // It's a good idea to start\
    \ with a brute force solution, and think\n        // about ways to make it faster.\
    \  For example, if all the elements\n        // in the list are the same, then\
    \ you can return False right away.\n        if (l.Count < 3) return false;\n \
    \       for (int i = 0; i < l.Count; i++) {\n            for (int j = i + 1; j\
    \ < l.Count; j++) {\n                for (int k = j + 1; k < l.Count; k++) {\n\
    \                    if (l[i] + l[j] + l[k] == 0) {\n                        return\
    \ true;\n                    }\n                }\n            }\n        }\n\
    \        return false;", "        // Your code here.\n        throw new NotImplementedException();",
  "        for (int i = 0; i < l.Count - 2; i++) {\n            for (int j = i + 1;\
    \ j < l.Count - 1; j++) {\n                for (int k = j + 1; k < l.Count; k++)\
    \ {\n                    if (l[i] + l[j] + l[k] == 0) {\n                    \
    \    return true;\n                    }\n                }\n            }\n \
    \       }\n        return false;", "        // todo: fill in this implementation.\n\
    \        return true;", "        foreach (var num in l) {\n            if (TriplesSumTo(l,\
    \ -num)) {\n                return true;\n            }\n        }\n        return\
    \ false;", "        // your code here\n        return false;", '        return
    true;', "        bool result = false;\n        // TODO: Your solution goes here\n\
    \        return result;", "        l.Sort();\n        int n = l.Count;\n     \
    \   for (int i = 0; i < n - 2; i++) {\n            int j = i + 1;\n          \
    \  int k = n - 1;\n            while (j < k) {\n                if (l[i] + l[j]\
    \ + l[k] == 0) {\n                    return true;\n                } else if\
    \ (l[i] + l[j] + l[k] < 0) {\n                    j++;\n                } else\
    \ {\n                    k--;\n                }\n            }\n        }\n \
    \       return false;", '        return true;', '        return false;', "   \
    \     if (l.Count < 3) {\n            return false;\n        }\n        List<Tuple<long,\
    \ long, long>> result = new List<Tuple<long, long, long>>();\n        for (int\
    \ i = 0; i < l.Count; i++) {\n            for (int j = i + 1; j < l.Count; j++)\
    \ {\n                for (int k = j + 1; k < l.Count; k++) {\n               \
    \     if (l[i] + l[j] + l[k] == 0) {\n                        result.Add(new Tuple<long,\
    \ long, long>(l[i], l[j], l[k]));\n                    }\n                }\n\
    \            }\n        }\n        if (result.Count > 0) {\n            return\
    \ true;\n        }\n        return false;", "        // YOUR CODE HERE\n     \
    \   HashSet<long> hash = new HashSet<long>();\n        for (int i = 0; i < l.Count;\
    \ i++) {\n            for (int j = i + 1; j < l.Count; j++) {\n              \
    \  if (hash.Contains(l[i] + l[j])) {\n                    return true;\n     \
    \           }\n            }\n            hash.Add(l[i]);\n        }\n       \
    \ return false;", "        // insert your code here\n        return false;", " \
    \       if (l.Count < 3) return false;\n        long n = l.Count;\n        for\
    \ (long i = 0; i < n; i++) {\n            for (long j = i + 1; j < n; j++) {\n\
    \                for (long k = j + 1; k < n; k++) {\n                    if (l[(int)i]\
    \ + l[(int)j] + l[(int)k] == 0) {\n                        return true;\n    \
    \                }\n                }\n            }\n        }\n        return\
    \ false;", "        //raise Exception(\"Not implemented\")\n        return false;",
  "        l.Sort();\n        for (int i = 0; i < l.Count; i++) {\n            int\
    \ a = i;\n            int b = a + 1;\n            int c = l.Count - 1;\n     \
    \       while (b < c) {\n                long sum = l[a] + l[b] + l[c];\n    \
    \            if (sum < 0) {\n                    b++;\n                } else\
    \ if (sum > 0) {\n                    c--;\n                } else {\n       \
    \             return true;\n                }\n            }\n        }\n    \
    \    return false;", "        if (l.Count < 3) return false;\n        var cache\
    \ = new HashSet<long>();\n        foreach (var i in l) {\n            cache.Add(i);\n\
    \        }\n        foreach (var i in l) {\n            foreach (var j in l) {\n\
    \                if (cache.Contains(-i - j)) return true;\n            }\n   \
    \     }\n        return false;"]
stop_tokens:
- "\n    }\n"
