name: HumanEval_55_fib
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // Return n-th Fibonacci number.\n    // >>> fib(10)\n    // 55\n\
  \    // >>> fib(1)\n    // 1\n    // >>> fib(8)\n    // 21\n    public static long\
  \ Fib(long n) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(Fib((10L))\
  \ == (55L));\n    Debug.Assert(Fib((1L)) == (1L));\n    Debug.Assert(Fib((8L)) ==\
  \ (21L));\n    Debug.Assert(Fib((11L)) == (89L));\n    Debug.Assert(Fib((12L)) ==\
  \ (144L));\n    }\n\n}\n"
completions: ["        if (n <= 1) {\n            return n;\n        }\n        long\
    \ a = 0;\n        long b = 1;\n        for (long i = 0; i < n; i++) {\n      \
    \      long c = a + b;\n            a = b;\n            b = c;\n        }\n  \
    \      return a;", "        long f0 = 0;\n        long f1 = 1;\n        for (long\
    \ i = 0; i < n; i++) {\n            long f2 = f0 + f1;\n            f0 = f1;\n\
    \            f1 = f2;\n        }\n        return f0;", "        if (n == 0) {\n\
    \            return 0;\n        }\n        if (n == 1) {\n            return 1;\n\
    \        }\n        return Fib(n - 1) + Fib(n - 2);", '        return (n == 0)
    ? 0 : Fib(n, 0, 1);', "        var a = 1L;\n        var b = 1L;\n        for (long\
    \ i = 2; i < n; i++) {\n            var c = a + b;\n            a = b;\n     \
    \       b = c;\n        }\n        return b;", "        //if (n < 1) return 0;\n\
    \        //if (n == 1) return 1;\n        //return Fib(n - 1) + Fib(n - 2);\n\
    \        var a = new BigInteger(0);\n        var b = new BigInteger(1);\n    \
    \    for (long i = 0; i < n; i++) {\n            var tmp = a;\n            a =\
    \ b;\n            b = tmp + b;\n        }\n        return (long)a;", "       \
    \ var fib = new long[n + 1];\n        fib[0] = 0;\n        fib[1] = 1;\n     \
    \   for (long i = 2; i <= n; i++) {\n            fib[i] = fib[i - 1] + fib[i -\
    \ 2];\n        }\n        return fib[n];", "        var pisano_length = (long)1e6;\n\
    \        n %= pisano_length;\n        if (n == 0) {\n            return 0;\n \
    \       }\n        if (n == 1) {\n            return 1;\n        }\n        long\
    \ a = 0;\n        long b = 1;\n        for (long i = 2; i <= n; i++) {\n     \
    \       long t = a + b;\n            a = b;\n            b = t;\n        }\n \
    \       return b;", "        if (n <= 1) {\n            return n;\n        }\n\
    \        long n1 = 0;\n        long n2 = 1;\n        long tmp;\n        for (long\
    \ i = 2; i <= n; i++) {\n            tmp = n1 + n2;\n            n1 = n2;\n  \
    \          n2 = tmp;\n        }\n        return n2;", "        long a = 0;\n \
    \       long b = 1;\n        for (long i = 0; i < n; i++) {\n            long\
    \ c = a + b;\n            a = b;\n            b = c;\n        }\n        return\
    \ a;", "        Debug.Assert(n >= 0);\n        long first = 0;\n        long second\
    \ = 1;\n        while (n > 0) {\n            var tmp = first;\n            first\
    \ = second;\n            second = tmp + second;\n            n--;\n        }\n\
    \        return first;", "        if (n == 0) return 0;\n        if (n == 1) return\
    \ 1;\n        long a = 0;\n        long b = 1;\n        for (long i = 2; i <=\
    \ n; i++) {\n            long c = a + b;\n            a = b;\n            b =\
    \ c;\n        }\n        return b;", "        if (n <= 1) {\n            return\
    \ n;\n        }\n        return Fib(n - 1) + Fib(n - 2);", "        if (n == 0)\
    \ return 0;\n        if (n == 1) return 1;\n        long v1 = 0;\n        long\
    \ v2 = 1;\n        for (long i = 1; i < n; i++) {\n            long v3 = v1 +\
    \ v2;\n            v1 = v2;\n            v2 = v3;\n        }\n        return v2;",
  "        // naive\n        // if (n == 0) return 0;\n        // return n == 1 ?\
    \ 1 : Fib(n - 1) + Fib(n - 2);\n\n        // DP\n        // if (n == 0) return\
    \ 0;\n        // long[] fib = new long[n + 1];\n        // fib[0] = 0;\n     \
    \   // fib[1] = 1;\n        // for (int i = 2; i <= n; i++)\n        //     fib[i]\
    \ = fib[i - 1] + fib[i - 2];\n        // return fib[n];\n\n        // Matrix\n\
    \        // using Matrix.FindInverse()\n        // long[,] M = { { 1, 1 }, { 1,\
    \ 0 } };\n        // long[,] R = Matrix.Power(M, n);\n        // return R[0, 0];\n\
    \n        // Matrix with Modulo\n        // using Matrix.FindInverse()\n     \
    \   // var M = new ModuloMatrix(2, 2, 10007);\n        // M[0, 0] = 1; M[0, 1]\
    \ = 1;\n        // M[1, 0] = 1; M[1, 1] = 0;\n        // M = M.Power(n);\n   \
    \     // return M[0, 0].Value;\n\n        // Matrix with Modulo\n        // using\
    \ ModuloMatrix.Inverse()\n        // var M = new ModuloMatrix(2, 2, 10007);\n\
    \        // M[0, 0] = 1; M[0, 1] = 1;\n        // M[1, 0] = 1; M[1, 1] = 0;\n\
    \        // M = M.Power(n);\n        // return M[0, 0].Value;\n\n        // Matrix\
    \ with Modulo\n        // using Modulo.Pow()\n        // var M = new ModuloMatrix(2,\
    \ 2, 10007);\n        // M[0, 0] = 1; M[0, 1] = 1;\n        // M[1, 0] = 1; M[1,\
    \ 1] = 0;\n        // M = M.Power(n);\n        // return M[0, 0].Value;\n\n  \
    \      // see https://www.nayuki.io/", "        long a = 0;\n        long b =\
    \ 1;\n        for (long i = 0; i < n; i++) {\n            long c = a + b;\n  \
    \          a = b;\n            b = c;\n        }\n        return a;", "      \
    \  if (n <= 1) return n;\n        long prevprev = 0;\n        long prev = 1;\n\
    \        for (long i = 0; i < n - 1; i++) {\n            long cur = prev + prevprev;\n\
    \            prevprev = prev;\n            prev = cur;\n        }\n        return\
    \ prev;", "        long a = 0;\n        long b = 1;\n        for (long i = 0;\
    \ i < n; i++) {\n            long c = a + b;\n            a = b;\n           \
    \ b = c;\n        }\n        return a;", "        BigInteger a = 0;\n        BigInteger\
    \ b = 1;\n        for (int i = 0; i < n; i++) {\n            BigInteger c = a\
    \ + b;\n            a = b;\n            b = c;\n        }\n        return (long)a;",
  "        if (n == 0) {\n            return 0;\n        }\n        long a = 0;\n\
    \        long b = 1;\n        for (long i = 2; i <= n; i++) {\n            long\
    \ c = a + b;\n            a = b;\n            b = c;\n        }\n        return\
    \ b;"]
stop_tokens:
- "\n    }\n"
