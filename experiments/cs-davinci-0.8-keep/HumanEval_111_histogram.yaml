name: HumanEval_111_histogram
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // Given a string representing a space separated lowercase letters,\
  \ return a dictionary\n    // of the letter with the most repetition and containing\
  \ the corresponding count.\n    // If several letters have the same occurrence,\
  \ return all of them.\n    // Example:\n    // histogram('a b c') == {'a': 1, 'b':\
  \ 1, 'c': 1}\n    // histogram('a b b a') == {'a': 2, 'b': 2}\n    // histogram('a\
  \ b c a b') == {'a': 2, 'b': 2}\n    // histogram('b b b b a') == {'b': 4}\n   \
  \ // histogram('') == {}\n    public static Dictionary<string,long> Histogram(string\
  \ test) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(Histogram((\"\
  a b b a\")).Equals((new Dictionary<string,long>(){{\"a\", 2L}, {\"b\", 2L}})));\n\
  \    Debug.Assert(Histogram((\"a b c a b\")).Equals((new Dictionary<string,long>(){{\"\
  a\", 2L}, {\"b\", 2L}})));\n    Debug.Assert(Histogram((\"a b c d g\")).Equals((new\
  \ Dictionary<string,long>(){{\"a\", 1L}, {\"b\", 1L}, {\"c\", 1L}, {\"d\", 1L},\
  \ {\"g\", 1L}})));\n    Debug.Assert(Histogram((\"r t g\")).Equals((new Dictionary<string,long>(){{\"\
  r\", 1L}, {\"t\", 1L}, {\"g\", 1L}})));\n    Debug.Assert(Histogram((\"b b b b a\"\
  )).Equals((new Dictionary<string,long>(){{\"b\", 4L}})));\n    Debug.Assert(Histogram((\"\
  r t g\")).Equals((new Dictionary<string,long>(){{\"r\", 1L}, {\"t\", 1L}, {\"g\"\
  , 1L}})));\n    Debug.Assert(Histogram((\"\")).Equals((new Dictionary<string,long>())));\n\
  \    Debug.Assert(Histogram((\"a\")).Equals((new Dictionary<string,long>(){{\"a\"\
  , 1L}})));\n    }\n\n}\n"
completions: ["        var dict = new Dictionary<string,long>();\n        var current\
    \ = new Dictionary<string,long>();\n        var max = 0L;\n        foreach (var\
    \ c in test.Split(' ')) {\n            var v = c;\n            if (current.ContainsKey(v))\n\
    \                current[v]++;\n            else\n                current[v] =\
    \ 1;\n            if (current[v] == max)\n                dict[v] = max;\n   \
    \         else if (current[v] > max) {\n                max = current[v];\n  \
    \              dict = new Dictionary<string,long>();\n                dict[v]\
    \ = max;\n            }\n        }\n        return dict;", "        var dict =\
    \ new Dictionary<string,long>();\n        foreach (var c in test.Split(' ')) {\n\
    \            if (dict.ContainsKey(c)) {\n                dict[c] += 1;\n     \
    \       } else {\n                dict[c] = 1;\n            }\n        }\n   \
    \     var max = dict.Values.Max();\n        var keys = dict.Where(x => x.Value\
    \ == max).Select(x => x.Key).ToList();\n        return keys.ToDictionary(x =>\
    \ x, x => max);", "        var result = new Dictionary<string,long>();\n     \
    \   var words = test.Split(' ');\n        var max = 0;\n        foreach (var word\
    \ in words) {\n            if (result.ContainsKey(word)) {\n                result[word]++;\n\
    \            } else {\n                result[word] = 1;\n            }\n    \
    \        if (result[word] > max) {\n                max = (int)result[word];\n\
    \            }\n        }\n        var answer = new Dictionary<string,long>();\n\
    \        foreach (var word in result.Keys) {\n            if (result[word] ==\
    \ max) {\n                answer[word] = result[word];\n            }\n      \
    \  }\n        return answer;", "        Dictionary<string,long> result = new Dictionary<string,long>();\n\
    \        Dictionary<string,long> tmp = new Dictionary<string,long>();\n      \
    \  string[] arr = test.Split(' ');\n        foreach (string s in arr) {\n    \
    \        if (tmp.ContainsKey(s)) {\n                tmp[s] += 1;\n           \
    \ } else {\n                tmp[s] = 1;\n            }\n        }\n        long\
    \ max_value = tmp.Values.Max();\n        foreach (string s in tmp.Keys) {\n  \
    \          if (tmp[s] == max_value) {\n                result[s] = max_value;\n\
    \            }\n        }\n        return result;", "        Dictionary<string,long>\
    \ histogram = new Dictionary<string,long>();\n        foreach (string word in\
    \ test.Split(' ')) {\n            if (histogram.ContainsKey(word)) {\n       \
    \         histogram[word]++;\n            } else {\n                histogram[word]\
    \ = 1;\n            }\n        }\n        return histogram;", "        Dictionary<string,long>\
    \ _histogram = new Dictionary<string,long>();\n        string[] _tokens = test.Split('\
    \ ');\n        long _count = 0;\n        foreach (string token in _tokens) {\n\
    \            if (_histogram.TryGetValue(token, out _count)) {\n              \
    \  _histogram[token] = _count + 1;\n            } else {\n                _histogram.Add(token,\
    \ 1);\n            }\n        }\n        return _histogram;", "        var histogram\
    \ = new Dictionary<string,long>();\n        foreach (var c in test.Split(' '))\
    \ {\n            if (histogram.ContainsKey(c)) {\n                histogram[c]++;\n\
    \            } else {\n                histogram[c] = 1;\n            }\n    \
    \    }\n        var max = histogram.Values.Max();\n        var maxSet = new HashSet<string>();\n\
    \        foreach (var kvp in histogram) {\n            if (kvp.Value == max) {\n\
    \                maxSet.Add(kvp.Key);\n            }\n        }\n        return\
    \ maxSet.ToDictionary(key => key, key => max);", '        return null;', "   \
    \     var chars = test.Split(new char[] {' '}, StringSplitOptions.RemoveEmptyEntries).ToList();\n\
    \        Dictionary<string, long> letterCount = new Dictionary<string, long>();\n\
    \        foreach (var letter in chars) {\n            if (letterCount.ContainsKey(letter))\
    \ {\n                letterCount[letter] += 1;\n            } else {\n       \
    \         letterCount.Add(letter, 1);\n            }\n        }\n        //  Write\
    \ code here\n        return letterCount;", "        Dictionary<string,long> letters\
    \ = new Dictionary<string,long>();\n        if (test.Equals(\"\")) return letters;\n\
    \        string[] tokens = test.Split(' ');\n        for (int i = 0; i < tokens.Length;\
    \ i++) {\n            string letter = tokens[i];\n            if (letters.ContainsKey(letter))\
    \ {\n                letters[letter] += 1;\n            } else {\n           \
    \     letters.Add(letter, 1);\n            }\n        }\n        long maxValue\
    \ = letters.Values.Max();\n        List<string> maxLetters = new List<string>();\n\
    \        foreach (KeyValuePair<string,long> pair in letters) {\n            if\
    \ (pair.Value == maxValue) {\n                maxLetters.Add(pair.Key);\n    \
    \        }\n        }\n        foreach (string key in letters.Keys.ToList()) {\n\
    \            if (!maxLetters.Contains(key)) {\n                letters.Remove(key);\n\
    \            }\n        }\n        return letters;", "        // Your code goes\
    \ here\n        return null;", "        // Use a dictionary to keep track of how\
    \ many times a letter occurs.\n        Dictionary<string,long> d = new Dictionary<string,long>();\n\
    \        // Skip over letters that are repeated.\n        string[] t = test.Split('\
    \ ');\n        for (int i = 0; i < t.Length; i++) {\n            if (d.ContainsKey(t[i]))\
    \ {\n                d[t[i]]++;\n            } else {\n                d.Add(t[i],\
    \ 1);\n            }\n        }\n        // If the frequency contains a key with\
    \ the max frequency, add all key:value\n        // pairs to the output.\n    \
    \    Dictionary<string,long> output = new Dictionary<string,long>();\n       \
    \ long max_v = d.Values.Max();\n        foreach (KeyValuePair<string,long> entry\
    \ in d) {\n            if (entry.Value == max_v) {\n                output.Add(entry.Key,\
    \ entry.Value);\n            }\n        }\n        return output;", "        var\
    \ result = new Dictionary<string,long>();\n        var chars = test.Split(new\
    \ [] {' '}, StringSplitOptions.RemoveEmptyEntries);\n        var orderedChars\
    \ = chars.OrderBy(x => x);\n        foreach (var item in orderedChars) {\n   \
    \         if (result.ContainsKey(item)) {\n                result[item] += 1;\n\
    \            } else {\n                result[item] = 1;\n            }\n    \
    \    }\n        return result;", "        Dictionary<string,long> output = new\
    \ Dictionary<string,long>();\n        if (test.Length == 0) {\n            return\
    \ output;\n        }\n        string[] split = test.Split(' ');\n        Dictionary<string,long>\
    \ histogram = new Dictionary<string,long>();\n        for (int i = 0; i < split.Length;\
    \ i++) {\n            long value = 0;\n            histogram.TryGetValue(split[i],\
    \ out value);\n            histogram[split[i]] = value + 1;\n        }\n     \
    \   long max = 0;\n        foreach (KeyValuePair<string,long> entry in histogram)\
    \ {\n            if (entry.Value > max) {\n                max = entry.Value;\n\
    \            }\n        }\n        foreach (KeyValuePair<string,long> entry in\
    \ histogram) {\n            if (entry.Value == max) {\n                output[entry.Key]\
    \ = entry.Value;\n            }\n        }\n        return output;", "       \
    \ var d = new Dictionary<string,long>();\n        var max = 0L;\n        var match\
    \ = new List<string>();\n        // split the string into a list of characters\n\
    \        var l = test.Split(new char[] {' '}, StringSplitOptions.RemoveEmptyEntries);\n\
    \        // loop the characters\n        foreach (var k in l) {\n            //\
    \ if the dictionary doesn't have the key, add it\n            if (!d.ContainsKey(k))\
    \ {\n                d.Add(k, 0);\n            }\n            // increment the\
    \ count\n            d[k]++;\n            // if the count is greater than the\
    \ maximum, then the list of matching characters\n            // is the single\
    \ letter found and the maximum is the count\n            if (d[k] > max) {\n \
    \               max = d[k];\n                match = new List<string> {k};\n \
    \           }\n            // if the count is equal to the maximum and the current\
    \ letter is not already in the list\n            // of matching letters, then\
    \ add it to the list\n            else if (d[k] == max && !match.Contains(k))\
    \ {\n                match.Add(k);\n            }\n        }\n        // if there\
    \ are any matches, loop the dictionary removing anything that is not in the list\n\
    \        // of matches\n        if (match.Count > 0) {\n            foreach (var\
    \ k in d.Keys.ToList()) {\n                if (!match.Contains(k)) {\n       \
    \             d.Remove(k);\n                }\n            }\n        }\n    \
    \    // return the dictionary\n        return d;", "        var result = new Dictionary<string,long>();\n\
    \        // Implement this function.\n        test = test.Replace(\" \", \"\"\
    );\n        if (test.Length == 0)\n            return result;\n        var max\
    \ = 1;\n        var best = \"\";\n        foreach (var c in test) {\n        \
    \    if (result.ContainsKey(c.ToString())) {\n                result[c.ToString()]\
    \ += 1;\n                if (result[c.ToString()] > max) {\n                 \
    \   max = result[c.ToString()];\n                    best = c.ToString();\n  \
    \              }\n            } else {\n                result.Add(c.ToString(),\
    \ 1);\n            }\n        }\n        // Return only the best letter(s)\n \
    \       var first = new Dictionary<string,long>();\n        foreach (var pair\
    \ in result) {\n            if (pair.Value == max) {\n                first.Add(pair.Key,\
    \ pair.Value);\n            }\n        }\n        return first;", "        Dictionary<string,long>\
    \ d = new Dictionary<string,long>();\n        if (test == \"\") return d;\n  \
    \      string[] letters = test.Split(' ');\n        Dictionary<string, long> letter_count\
    \ = new Dictionary<string, long>();\n        foreach (string letter in letters)\
    \ {\n            if (letter_count.ContainsKey(letter)) {\n                letter_count[letter]\
    \ += 1;\n            } else {\n                letter_count[letter] = 1;\n   \
    \         }\n        }\n        long max_occurrence = letter_count.Values.Max();\n\
    \        foreach (KeyValuePair<string, long> kvp in letter_count) {\n        \
    \    if (kvp.Value == max_occurrence) {\n                d[kvp.Key] = kvp.Value;\n\
    \            }\n        }\n        return d;", "        // insert your code here\n\
    \        return null;", "        var histogram = new Dictionary<string,long>();\n\
    \        foreach (var c in test.Split(' ')) {\n            if (histogram.ContainsKey(c))\
    \ {\n                histogram[c]++;\n            } else {\n                histogram[c]\
    \ = 1;\n            }\n        }\n        return histogram;", "        string[]\
    \ letters = test.Split(' ');\n        Dictionary<string, long> histogram = new\
    \ Dictionary<string, long>();\n        // For each letter, add it to the dictionary\
    \ if it is not already in there\n        // If it is already in there, increment\
    \ its count by 1\n        foreach (string letter in letters) {\n            if\
    \ (histogram.ContainsKey(letter)) {\n                histogram[letter] += 1;\n\
    \            } else {\n                histogram.Add(letter, 1);\n           \
    \ }\n        }\n        // Get the keys of the dictionary and convert it to a\
    \ list\n        List<string> keys = histogram.Keys.ToList();\n        // Loop\
    \ over the keys\n        for (int i = 0; i < keys.Count; i++) {\n            //\
    \ If the count of the current key is not equal to the maximum count\n        \
    \    // Then remove it from the dictionary\n            if (histogram[keys[i]]\
    \ != histogram.Values.Max()) {\n                histogram.Remove(keys[i]);\n \
    \           }\n        }\n        return histogram;"]
stop_tokens:
- "\n    }\n"
