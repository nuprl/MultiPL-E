name: HumanEval_39_prime_fib
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // prime_fib returns n-th number that is a Fibonacci number and\
  \ it's also prime.\n    // >>> prime_fib(1)\n    // 2\n    // >>> prime_fib(2)\n\
  \    // 3\n    // >>> prime_fib(3)\n    // 5\n    // >>> prime_fib(4)\n    // 13\n\
  \    // >>> prime_fib(5)\n    // 89\n    public static long PrimeFib(long n) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(PrimeFib((1L))\
  \ == (2L));\n    Debug.Assert(PrimeFib((2L)) == (3L));\n    Debug.Assert(PrimeFib((3L))\
  \ == (5L));\n    Debug.Assert(PrimeFib((4L)) == (13L));\n    Debug.Assert(PrimeFib((5L))\
  \ == (89L));\n    Debug.Assert(PrimeFib((6L)) == (233L));\n    Debug.Assert(PrimeFib((7L))\
  \ == (1597L));\n    Debug.Assert(PrimeFib((8L)) == (28657L));\n    Debug.Assert(PrimeFib((9L))\
  \ == (514229L));\n    Debug.Assert(PrimeFib((10L)) == (433494437L));\n    }\n\n\
  }\n"
completions: ["        long f1 = 2;\n        long f2 = 3;\n        long f3 = 5;\n\
    \        long i = 3;\n        while (true) {\n            if (IsPrime(f3)) {\n\
    \                i += 1;\n                if (i == n) {\n                    return\
    \ f3;\n                }\n            }\n            f1 = f2;\n            f2\
    \ = f3;\n            f3 = f1 + f2;\n        }", "        Debug.Assert(n >= 1);\n\
    \        long[] a = new long[2];\n        a[0] = 2;\n        a[1] = 3;\n     \
    \   for (long i = 2; i < n; i++) {\n            long c = a[0] + a[1];\n      \
    \      if (IsPrime(c)) {\n                a[0] = a[1];\n                a[1] =\
    \ c;\n            }\n        }\n        return a[1];", "        long max_n = 100;\n\
    \        var f = new long[max_n];\n        f[0] = 0;\n        f[1] = 1;\n    \
    \    f[2] = 1;\n        long j = 0;\n        for (long i = 3; i < max_n; i++)\
    \ {\n            f[i] = f[i - 1] + f[i - 2];\n            if (IsPrime(f[i])) {\n\
    \                j++;\n            }\n            if (j == n) {\n            \
    \    return f[i];\n            }\n        }\n        return -1;", "        var\
    \ fib = new Dictionary<long, BigInteger>();\n        fib[0] = 0;\n        fib[1]\
    \ = 1;\n        fib[2] = 1;\n        fib[3] = 2;\n        fib[4] = 3;\n      \
    \  fib[5] = 5;\n        fib[6] = 8;\n        fib[7] = 13;\n        fib[8] = 21;\n\
    \        fib[9] = 34;\n        fib[10] = 55;\n        fib[11] = 89;\n        fib[12]\
    \ = 144;\n        fib[13] = 233;\n        fib[14] = 377;\n        fib[15] = 610;\n\
    \        fib[16] = 987;\n        fib[17] = 1597;\n        fib[18] = 2584;\n  \
    \      fib[19] = 4181;\n        fib[20] = 6765;\n        fib[21] = 10946;\n  \
    \      fib[22] = 17711;\n        fib[23] = 28657;\n        fib[24] = 46368;\n\
    \        fib[25] = 75025;\n        fib[26] = 121393;\n        fib[27] = 196418;\n\
    \        fib[28] = 317811;\n        fib[29] = 514229;\n        fib[30] = 832040;\n\
    \        fib[31] = 1346269;\n        fib[32] = 2178309;\n        fib[33] = 3524578;\n\
    \        fib[34] = 5702887;\n        fib[35] = 9227465;\n        fib[36] = 14930352;\n\
    \        fib[37] = 24157817;\n        fib[38] = 39088169;\n        fib[39] = 63245986;\n\
    \        fib[40] = 102334155;\n        fib[41] = 165580141;\n        fib[42] =\
    \ 267914296;\n        fib[43] = 433494437;\n        fib[44] = 701408733;\n   \
    \     fib[45] = 1134903170;\n        fib[46] = 1836311903;\n        fib[47] =\
    \ 2971215073;\n", "        var p = MathUtil.PrimeSieveEratosthenes((long)Math.Pow(10,\
    \ 7));\n        var f = new List<long>();\n        f.Add(2);\n        f.Add(3);\n\
    \        while (true) {\n            var next = f[f.Count - 1] + f[f.Count - 2];\n\
    \            if (next > p[p.Count - 1]) {\n                break;\n          \
    \  }\n            f.Add(next);\n        }\n        var count = 0;\n        foreach\
    \ (var i in f) {\n            if (p.BinarySearch(i) >= 0) {\n                count++;\n\
    \                if (count == n) {\n                    return i;\n          \
    \      }\n            }\n        }\n        return -1;", "        long a = 1;\n\
    \        long b = 1;\n        long c = a + b;\n        long t = 0;\n        long\
    \ f = 1;\n        for (int i = 0; i < n; i++) {\n            if (f == 1 && IsPrime(c))\
    \ {\n                t = c;\n                f++;\n            }\n           \
    \ a = b;\n            b = c;\n            c = a + b;\n        }\n        return\
    \ t;", "        Debug.Assert(n >= 1);\n        var fibs = new List<long>();\n\
    \        fibs.Add(1);\n        fibs.Add(2);\n        long count = 2;\n       \
    \ long last_index = 1;\n        while (count < n) {\n            last_index +=\
    \ 1;\n            long f = fibs[last_index - 1] + fibs[last_index - 2];\n    \
    \        if (Util.IsPrime(f)) {\n                fibs.Add(f);\n              \
    \  count += 1;\n            }\n        }\n        return fibs[last_index];", " \
    \       var u = 0;\n        var v = 1;\n        var t = 0;\n        long nthPrimeFib\
    \ = 0;\n        long count = 0;\n        while (nthPrimeFib == 0) {\n        \
    \    t = u + v;\n            u = v;\n            v = t;\n            if (BigInteger.Parse(v.ToString()).IsProbablePrime(100))\
    \ {\n                count += 1;\n                if (count == n) {\n        \
    \            nthPrimeFib = v;\n                }\n            }\n        }\n \
    \       return nthPrimeFib;", "        var fib = new List<long>();\n        fib.Add(1);\
    \ fib.Add(1);\n        int idx = 2;\n        while (idx < n) {\n            fib.Add(fib[idx\
    \ - 1] + fib[idx - 2]);\n            idx += 1;\n        }\n        return fib[idx\
    \ - 1];", "        // fibonacci sequence generator.\n        IEnumerable<BigInteger>\
    \ fib = new BigInteger[] { 0, 1 }.Concat(Fib());\n        // prime number generator.\n\
    \        IEnumerable<BigInteger> primes = PrimeGen(fib);\n        return primes.ElementAt((int)n);",
  "        long a = 1;\n        long b = 1;\n        long count = 2;\n        while\
    \ (true) {\n            long c = a + b;\n            if (Util.IsPrime(c)) {\n\
    \                count++;\n                if (count == n) {\n               \
    \     return c;\n                }\n            }\n            a = b;\n      \
    \      b = c;\n        }", "        var fib = 0L;\n        var x = new BigInteger(0);\n\
    \        var y = new BigInteger(1);\n        var iter = 0L;\n        while (iter\
    \ < n) {\n            fib = (long)x + (long)y;\n            x = y;\n         \
    \   y = fib;\n            if (IsPrime(fib)) {\n                iter++;\n     \
    \       }\n        }\n        return fib;", "        Debug.Assert(n >= 1);\n \
    \       long fn1 = 2;\n        long fn2 = 3;\n        for (int i = 2; i < n; i++)\
    \ {\n            long fn = fn1 + fn2;\n            fn1 = fn2;\n            fn2\
    \ = fn;\n            while (!IsPrime(fn)) {\n                fn += fn1;\n    \
    \        }\n            fn2 = fn;\n        }\n        return fn2;", "        int\
    \ pos = 1;\n        long nth_prime_fib = 1;\n        while (pos < n) {\n     \
    \       long a = nth_prime_fib;\n            long b = a + a;\n            while\
    \ (b <= 1000000000000000000) {\n                if (IsPrime(b)) {\n          \
    \          pos++;\n                    nth_prime_fib = b;\n                  \
    \  if (pos == n)\n                        return nth_prime_fib;\n            \
    \    }\n                a = b;\n                b = a + nth_prime_fib;\n     \
    \       }\n        }\n        return nth_prime_fib;", "        var f = new BigInteger(1);\n\
    \        var f1 = new BigInteger(1);\n        for (var i = 1; ; i++) {\n     \
    \       var tmp = f;\n            f = f + f1;\n            f1 = tmp;\n       \
    \     if (IsPrime(f))\n                n--;\n            if (n == 0)\n       \
    \         return (long)f;\n        }", "        long p = 2;\n        long q =\
    \ 3;\n        for (int i = 2; i < n; i++) {\n            long p1 = p;\n      \
    \      long q1 = q;\n            p = q1;\n            q = p1 + q1;\n        }\n\
    \        return q;", "        BigInteger[] fib = { BigInteger.Zero, BigInteger.One\
    \ };\n        long i = 1;\n        while (i < n) {\n            fib[0] += fib[1];\n\
    \            var tmp = fib[0];\n            fib[0] = fib[1];\n            fib[1]\
    \ = tmp;\n            if (Tools.isPrime(fib[1]))\n                i++;\n     \
    \   }\n        return (long)fib[1];", "        //(M^n)%p\n        BigInteger p\
    \ = BigInteger.Parse(\"618970019642690137449562111\");\n        BigInteger M =\
    \ BigInteger.Parse(\"1\");\n        BigInteger P = BigInteger.Pow(M, n);\n   \
    \     BigInteger sum = P % p;\n        long res = (long)sum;\n        return res;",
  "        if (n == 1) {\n            return 2;\n        }\n        long a = 2;\n\
    \        long b = 3;\n        long c = 5;\n        for (long i = 3; i <= n; i++)\
    \ {\n            a = b;\n            b = c;\n            c = a + b;\n        \
    \    while (!IsPrime(c)) {\n                c += b;\n            }\n        }\n\
    \        return c;", "        long i = 0;\n        long p = 0;\n        do {\n\
    \            p = Fib(i);\n            i++;\n        } while (!IsPrime(p) || n--\
    \ > 1);\n        return p;"]
stop_tokens:
- "\n    }\n"
