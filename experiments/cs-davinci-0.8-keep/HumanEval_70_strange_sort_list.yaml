name: HumanEval_70_strange_sort_list
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // Given list of integers, return list in strange order.\n    //\
  \ Strange sorting, is when you start with the minimum value,\n    // then maximum\
  \ of the remaining integers, then minimum and so on.\n    // Examples:\n    // strange_sort_list([1,\
  \ 2, 3, 4]) == [1, 4, 2, 3]\n    // strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
  \ 5]\n    // strange_sort_list([]) == []\n    public static List<long> StrangeSortList(List<long>\
  \ lst) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(StrangeSortList((new\
  \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
  \ long[]{(long)1L, (long)4L, (long)2L, (long)3L}))));\n    Debug.Assert(StrangeSortList((new\
  \ List<long>(new long[]{(long)5L, (long)6L, (long)7L, (long)8L, (long)9L}))).Equals((new\
  \ List<long>(new long[]{(long)5L, (long)9L, (long)6L, (long)8L, (long)7L}))));\n\
  \    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)1L, (long)2L,\
  \ (long)3L, (long)4L, (long)5L}))).Equals((new List<long>(new long[]{(long)1L, (long)5L,\
  \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(StrangeSortList((new List<long>(new\
  \ long[]{(long)5L, (long)6L, (long)7L, (long)8L, (long)9L, (long)1L}))).Equals((new\
  \ List<long>(new long[]{(long)1L, (long)9L, (long)5L, (long)8L, (long)6L, (long)7L}))));\n\
  \    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)5L, (long)5L,\
  \ (long)5L, (long)5L}))).Equals((new List<long>(new long[]{(long)5L, (long)5L, (long)5L,\
  \ (long)5L}))));\n    Debug.Assert(StrangeSortList((new List<long>())).Equals((new\
  \ List<long>())));\n    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)1L,\
  \ (long)2L, (long)3L, (long)4L, (long)5L, (long)6L, (long)7L, (long)8L}))).Equals((new\
  \ List<long>(new long[]{(long)1L, (long)8L, (long)2L, (long)7L, (long)3L, (long)6L,\
  \ (long)4L, (long)5L}))));\n    Debug.Assert(StrangeSortList((new List<long>(new\
  \ long[]{(long)0L, (long)2L, (long)2L, (long)2L, (long)5L, (long)5L, (long)-5L,\
  \ (long)-5L}))).Equals((new List<long>(new long[]{(long)-5L, (long)5L, (long)-5L,\
  \ (long)5L, (long)0L, (long)2L, (long)2L, (long)2L}))));\n    Debug.Assert(StrangeSortList((new\
  \ List<long>(new long[]{(long)111111L}))).Equals((new List<long>(new long[]{(long)111111L}))));\n\
  \    }\n\n}\n"
completions: ["        // Your solution goes here.\n        return null;", "     \
    \   // TODO: Implement me\n        return lst;", "        // This can be much\
    \ more efficient.\n        if (lst.Count == 0) {\n            return lst;\n  \
    \      }\n        List<long> ans = new List<long>();\n        ans.Add(lst.Min());\n\
    \        lst.Remove(lst.Min());\n        while (lst.Count > 0) {\n           \
    \ ans.Add(lst.Max());\n            lst.Remove(lst.Max());\n            if (lst.Count\
    \ == 0) {\n                break;\n            }\n            ans.Add(lst.Min());\n\
    \            lst.Remove(lst.Min());\n        }\n        return ans;", "      \
    \  // Input: List<long> lst\n        // Output: List<long>\n        return new\
    \ List<long>();", "        // We are going to keep track of the current minimum\
    \ and maximum\n        // as well as a boolean to tell us if we need to add to\
    \ the front\n        // or back of the list.\n        long min = lst.Min();\n\
    \        long max = lst.Max();\n        bool front = true;\n        // In order\
    \ to get the strange sort, we need to remove the\n        // integers we use.\
    \ We will use a HashSet to keep track of\n        // the numbers we have used.\n\
    \        HashSet<long> used = new HashSet<long>();\n        // Our output list\n\
    \        List<long> lst2 = new List<long>();\n        while (lst.Count > 0) {\n\
    \            // If we are supposed to add to the front, then take the\n      \
    \      // minimum value and add it to the front.\n            if (front) {\n \
    \               lst2.Insert(0, min);\n                // Remove the current minimum\
    \ from the list and update\n                // the minimum to be the next smallest\
    \ value.\n                lst.Remove(min);\n                min = lst.Min();\n\
    \            }\n            // Same process for adding to the back.\n        \
    \    else {\n                lst2.Add(max);\n                lst.Remove(max);\n\
    \                max = lst.Max();\n            }\n            // Flip the boolean\
    \ so we alternate adding to the front and back.\n            front = !front;\n\
    \        }\n        return lst2;", "        var s = new List<long>();\n      \
    \  var ordered = lst.OrderBy(i => i).ToList();\n        while (ordered.Count >\
    \ 0) {\n            s.Add(ordered[0]);\n            ordered.RemoveAt(0);\n   \
    \         if (ordered.Count > 0) {\n                s.Add(ordered[ordered.Count\
    \ - 1]);\n                ordered.RemoveAt(ordered.Count - 1);\n            }\n\
    \        }\n        return s;", "        List<long> res = new List<long>();\n\
    \        while (lst.Count > 0) {\n            res.Add(lst.Min());\n          \
    \  lst.Remove(lst.Min());\n            if (lst.Count == 0) {\n               \
    \ break;\n            }\n            res.Add(lst.Max());\n            lst.Remove(lst.Max());\n\
    \        }\n        return res;", "        var res = new List<long>();\n     \
    \   lst.Sort();\n        for (int i = 0; i < lst.Count; i++) {\n            if\
    \ (i % 2 == 0) {\n                res.Add(lst[i]);\n            } else {\n   \
    \             res.Add(lst[lst.Count - i / 2 - 1]);\n            }\n        }\n\
    \        return res;", "        // Best solution would be sort the list and walk\
    \ up and down.\n        // That would be O(n log n) and would be hard to beat\n\
    \        // in python.\n        // But we can do even better:\n        // We know\
    \ that the min element is at the start.\n        // If the list is sorted, our\
    \ task is easy.\n        // So lets sort the list, find the min and max,\n   \
    \     // and swap them, then remove them from the list,\n        // and do the\
    \ same with the rest of the list,\n        // untill we are done.\n        //\
    \ Now this is O(n log n + n + n + n + ...) = O(n log n)\n        // That is a\
    \ bit better than the naive solution.\n        // Note that we can easily use\
    \ binary search to find\n        // the min and max, which would give us O(n log\
    \ n + n log n + n + n + ...)\n        // = O(n log n)\n        // But since we\
    \ actually have the list sorted we don't need binary search.\n        lst.Sort();\n\
    \        var result = new List<long>();\n        while (lst.Count > 0) {\n   \
    \         result.Add(lst[0]);\n            if (lst.Count > 1) {\n            \
    \    result.Add(lst[lst.Count - 1]);\n            }\n            lst.RemoveRange(0,\
    \ lst.Count);\n        }\n        return result;", "        var result = new List<long>();\n\
    \        var wtf = new List<long>(lst);\n        while (wtf.Count > 0) {\n   \
    \         var min = wtf.Min();\n            result.Add(min);\n            wtf.Remove(min);\n\
    \            if (wtf.Count == 0) break;\n            var max = wtf.Max();\n  \
    \          result.Add(max);\n            wtf.Remove(max);\n        }\n       \
    \ return result;", '        return new List<long>();', "        List<long> lstRes\
    \ = new List<long>();\n        while (lst.Count != 0) {\n            lstRes.Add(lst.Min());\n\
    \            lst.Remove(lst.Min());\n            if (lst.Count != 0) {\n     \
    \           lstRes.Add(lst.Max());\n                lst.Remove(lst.Max());\n \
    \           }\n        }\n        return lstRes;", "        lst.Sort();\n    \
    \    var res = new List<long>();\n        var i = 0;\n        var j = lst.Count-1;\n\
    \        while (i <= j) {\n            res.Add(lst[i]);\n            if (i !=\
    \ j) {\n                res.Add(lst[j]);\n            }\n            i++;\n  \
    \          j--;\n        }\n        return res;", "        if (lst.Count == 0)\
    \ {\n            return lst;\n        }\n\n        List<long> res = new List<long>();\n\
    \        long min = lst.Min();\n        int minIdx = lst.IndexOf(min);\n     \
    \   res.Add(min);\n        lst.RemoveAt(minIdx);\n\n        int len = lst.Count;\n\
    \        int i = 0;\n        while (lst.Count > 0) {\n            int maxIdx =\
    \ lst.IndexOf(lst.Max());\n            res.Add(lst[maxIdx]);\n            lst.RemoveAt(maxIdx);\n\
    \            if (lst.Count == 0) {\n                break;\n            }\n  \
    \          int minIdx2 = lst.IndexOf(lst.Min());\n            res.Add(lst[minIdx2]);\n\
    \            lst.RemoveAt(minIdx2);\n        }\n\n        return res;", '        return
    lst;', "        if (lst.Count == 0) return lst;\n        if (lst.Count == 1) return\
    \ lst;\n        List<long> odd = new List<long>();\n        List<long> even =\
    \ new List<long>();\n        lst.Sort();\n        bool oddEven = true;\n     \
    \   while (lst.Count > 0) {\n            if (oddEven) {\n                odd.Add(lst[0]);\n\
    \                lst.RemoveAt(0);\n            } else {\n                odd.Add(lst[lst.Count\
    \ - 1]);\n                lst.RemoveAt(lst.Count - 1);\n            }\n      \
    \      oddEven = !oddEven;\n        }\n        return odd;", '        return lst;',
  "        // write code here\n        var sorted = lst.OrderBy(x => x).ToList();\n\
    \        var result = new List<long>();\n        while (sorted.Count > 0) {\n\
    \            result.Add(sorted[0]);\n            sorted.RemoveAt(0);\n       \
    \     if (sorted.Count == 0) break;\n            result.Add(sorted[sorted.Count\
    \ - 1]);\n            sorted.RemoveAt(sorted.Count - 1);\n        }\n        return\
    \ result;", "        // put your code here\n        lst.Sort();\n        List<long>\
    \ result = new List<long>();\n        int start = 0;\n        int end = lst.Count\
    \ - 1;\n        while (start <= end) {\n            result.Add(lst[start]);\n\
    \            if (start != end)\n                result.Add(lst[end]);\n      \
    \      start++;\n            end--;\n        }\n        return result;", "   \
    \     if (lst.Count == 0) {\n            return lst;\n        }\n        var sorted\
    \ = lst.OrderBy(x => x).ToList();\n        var positive = sorted[0];\n       \
    \ var negative = sorted[sorted.Count - 1];\n        var result = new List<long>();\n\
    \        var i = 0;\n        while (result.Count < lst.Count) {\n            result.Add(positive);\n\
    \            positive = i % 2 == 0 ? sorted[i / 2 + 1] : sorted[sorted.Count -\
    \ 1 - i / 2];\n            i++;\n        }\n        return result;"]
stop_tokens:
- "\n    }\n"
