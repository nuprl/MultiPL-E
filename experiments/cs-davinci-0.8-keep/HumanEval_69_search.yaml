name: HumanEval_69_search
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // You are given a non-empty list of positive integers. Return\
  \ the greatest integer that is greater than \n    // zero, and has a frequency greater\
  \ than or equal to the value of the integer itself. \n    // The frequency of an\
  \ integer is the number of times it appears in the list.\n    // If no such a value\
  \ exist, return -1.\n    // Examples:\n    // search([4, 1, 2, 2, 3, 1]) == 2\n\
  \    // search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n    // search([5, 5, 4, 4, 4])\
  \ == -1\n    public static long Search(List<long> lst) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(Search((new\
  \ List<long>(new long[]{(long)5L, (long)5L, (long)5L, (long)5L, (long)1L}))) ==\
  \ (1L));\n    Debug.Assert(Search((new List<long>(new long[]{(long)4L, (long)1L,\
  \ (long)4L, (long)1L, (long)4L, (long)4L}))) == (4L));\n    Debug.Assert(Search((new\
  \ List<long>(new long[]{(long)3L, (long)3L}))) == (-1L));\n    Debug.Assert(Search((new\
  \ List<long>(new long[]{(long)8L, (long)8L, (long)8L, (long)8L, (long)8L, (long)8L,\
  \ (long)8L, (long)8L}))) == (8L));\n    Debug.Assert(Search((new List<long>(new\
  \ long[]{(long)2L, (long)3L, (long)3L, (long)2L, (long)2L}))) == (2L));\n    Debug.Assert(Search((new\
  \ List<long>(new long[]{(long)2L, (long)7L, (long)8L, (long)8L, (long)4L, (long)8L,\
  \ (long)7L, (long)3L, (long)9L, (long)6L, (long)5L, (long)10L, (long)4L, (long)3L,\
  \ (long)6L, (long)7L, (long)1L, (long)7L, (long)4L, (long)10L, (long)8L, (long)1L})))\
  \ == (1L));\n    Debug.Assert(Search((new List<long>(new long[]{(long)3L, (long)2L,\
  \ (long)8L, (long)2L}))) == (2L));\n    Debug.Assert(Search((new List<long>(new\
  \ long[]{(long)6L, (long)7L, (long)1L, (long)8L, (long)8L, (long)10L, (long)5L,\
  \ (long)8L, (long)5L, (long)3L, (long)10L}))) == (1L));\n    Debug.Assert(Search((new\
  \ List<long>(new long[]{(long)8L, (long)8L, (long)3L, (long)6L, (long)5L, (long)6L,\
  \ (long)4L}))) == (-1L));\n    Debug.Assert(Search((new List<long>(new long[]{(long)6L,\
  \ (long)9L, (long)6L, (long)7L, (long)1L, (long)4L, (long)7L, (long)1L, (long)8L,\
  \ (long)8L, (long)9L, (long)8L, (long)10L, (long)10L, (long)8L, (long)4L, (long)10L,\
  \ (long)4L, (long)10L, (long)1L, (long)2L, (long)9L, (long)5L, (long)7L, (long)9L})))\
  \ == (1L));\n    Debug.Assert(Search((new List<long>(new long[]{(long)1L, (long)9L,\
  \ (long)10L, (long)1L, (long)3L}))) == (1L));\n    Debug.Assert(Search((new List<long>(new\
  \ long[]{(long)6L, (long)9L, (long)7L, (long)5L, (long)8L, (long)7L, (long)5L, (long)3L,\
  \ (long)7L, (long)5L, (long)10L, (long)10L, (long)3L, (long)6L, (long)10L, (long)2L,\
  \ (long)8L, (long)6L, (long)5L, (long)4L, (long)9L, (long)5L, (long)3L, (long)10L})))\
  \ == (5L));\n    Debug.Assert(Search((new List<long>(new long[]{(long)1L}))) ==\
  \ (1L));\n    Debug.Assert(Search((new List<long>(new long[]{(long)8L, (long)8L,\
  \ (long)10L, (long)6L, (long)4L, (long)3L, (long)5L, (long)8L, (long)2L, (long)4L,\
  \ (long)2L, (long)8L, (long)4L, (long)6L, (long)10L, (long)4L, (long)2L, (long)1L,\
  \ (long)10L, (long)2L, (long)1L, (long)1L, (long)5L}))) == (4L));\n    Debug.Assert(Search((new\
  \ List<long>(new long[]{(long)2L, (long)10L, (long)4L, (long)8L, (long)2L, (long)10L,\
  \ (long)5L, (long)1L, (long)2L, (long)9L, (long)5L, (long)5L, (long)6L, (long)3L,\
  \ (long)8L, (long)6L, (long)4L, (long)10L}))) == (2L));\n    Debug.Assert(Search((new\
  \ List<long>(new long[]{(long)1L, (long)6L, (long)10L, (long)1L, (long)6L, (long)9L,\
  \ (long)10L, (long)8L, (long)6L, (long)8L, (long)7L, (long)3L}))) == (1L));\n  \
  \  Debug.Assert(Search((new List<long>(new long[]{(long)9L, (long)2L, (long)4L,\
  \ (long)1L, (long)5L, (long)1L, (long)5L, (long)2L, (long)5L, (long)7L, (long)7L,\
  \ (long)7L, (long)3L, (long)10L, (long)1L, (long)5L, (long)4L, (long)2L, (long)8L,\
  \ (long)4L, (long)1L, (long)9L, (long)10L, (long)7L, (long)10L, (long)2L, (long)8L,\
  \ (long)10L, (long)9L, (long)4L}))) == (4L));\n    Debug.Assert(Search((new List<long>(new\
  \ long[]{(long)2L, (long)6L, (long)4L, (long)2L, (long)8L, (long)7L, (long)5L, (long)6L,\
  \ (long)4L, (long)10L, (long)4L, (long)6L, (long)3L, (long)7L, (long)8L, (long)8L,\
  \ (long)3L, (long)1L, (long)4L, (long)2L, (long)2L, (long)10L, (long)7L}))) == (4L));\n\
  \    Debug.Assert(Search((new List<long>(new long[]{(long)9L, (long)8L, (long)6L,\
  \ (long)10L, (long)2L, (long)6L, (long)10L, (long)2L, (long)7L, (long)8L, (long)10L,\
  \ (long)3L, (long)8L, (long)2L, (long)6L, (long)2L, (long)3L, (long)1L}))) == (2L));\n\
  \    Debug.Assert(Search((new List<long>(new long[]{(long)5L, (long)5L, (long)3L,\
  \ (long)9L, (long)5L, (long)6L, (long)3L, (long)2L, (long)8L, (long)5L, (long)6L,\
  \ (long)10L, (long)10L, (long)6L, (long)8L, (long)4L, (long)10L, (long)7L, (long)7L,\
  \ (long)10L, (long)8L}))) == (-1L));\n    Debug.Assert(Search((new List<long>(new\
  \ long[]{(long)10L}))) == (-1L));\n    Debug.Assert(Search((new List<long>(new long[]{(long)9L,\
  \ (long)7L, (long)7L, (long)2L, (long)4L, (long)7L, (long)2L, (long)10L, (long)9L,\
  \ (long)7L, (long)5L, (long)7L, (long)2L}))) == (2L));\n    Debug.Assert(Search((new\
  \ List<long>(new long[]{(long)5L, (long)4L, (long)10L, (long)2L, (long)1L, (long)1L,\
  \ (long)10L, (long)3L, (long)6L, (long)1L, (long)8L}))) == (1L));\n    Debug.Assert(Search((new\
  \ List<long>(new long[]{(long)7L, (long)9L, (long)9L, (long)9L, (long)3L, (long)4L,\
  \ (long)1L, (long)5L, (long)9L, (long)1L, (long)2L, (long)1L, (long)1L, (long)10L,\
  \ (long)7L, (long)5L, (long)6L, (long)7L, (long)6L, (long)7L, (long)7L, (long)6L})))\
  \ == (1L));\n    Debug.Assert(Search((new List<long>(new long[]{(long)3L, (long)10L,\
  \ (long)10L, (long)9L, (long)2L}))) == (-1L));\n    }\n\n}\n"
completions: ["        var n = lst.Select(x => new { x, c = lst.Count(y => y == x)\
    \ }).OrderByDescending(x => x.c).FirstOrDefault();\n        if (n == null) return\
    \ -1;\n        return n.c >= n.x ? n.x : -1;", "        var idx = new Dictionary<long,\
    \ long>();\n        for (var i = 0; i < lst.Count; i++) {\n            if (!idx.ContainsKey(lst[i]))\
    \ {\n                idx[lst[i]] = 0;\n            }\n            idx[lst[i]]\
    \ += 1;\n        }\n        foreach (var kv in idx) {\n            if (kv.Key\
    \ == 0) {\n                continue;\n            }\n            if (kv.Value\
    \ >= kv.Key) {\n                return kv.Key;\n            }\n        }\n   \
    \     return -1;", "        // your code goes here\n        long result = -1;\n\
    \        long value = 0;\n        long counter = 0;\n        for (int i = 0; i\
    \ < lst.Count; i++) {\n            for (int x = 0; x < lst.Count; x++) {\n   \
    \             if (lst[i] == lst[x]) {\n                    counter++;\n      \
    \          }\n            }\n            if (counter >= lst[i] && lst[i] > value)\
    \ {\n                value = lst[i];\n            }\n            counter = 0;\n\
    \        }\n        if (value > 0) {\n            result = value;\n        }\n\
    \        return result;", "        long result = -1;\n        long counter = 0;\n\
    \        for (int i = 1; i <= lst.Count(); i++) {\n            counter = 0;\n\
    \            for (int j = 0; j < lst.Count(); j++) {\n                if (lst[j]\
    \ == i) {\n                    counter++;\n                }\n            }\n\
    \            if (counter >= i) {\n                result = i;\n            }\n\
    \        }\n        return result;", "        var groups = lst.GroupBy(g => g);\n\
    \        var maxValue = groups.Max(g => g.Key);\n        var maxCount = groups.Max(g\
    \ => g.Count());\n        var tuple = groups.FirstOrDefault(g => g.Key == maxCount);\n\
    \        if (tuple != null) {\n            return tuple.Key;\n        }\n    \
    \    return -1;", '        // Your code goes here', "        long cnt = 0;\n \
    \       long max = -1;\n        long[] arr = new long[lst.Count];\n        lst.CopyTo(arr);\n\
    \        Array.Sort(arr);\n        long tmp = arr[0];\n        for (int i = 0;\
    \ i < arr.Length; i++) {\n            if (tmp == arr[i]) {\n                cnt++;\n\
    \            } else {\n                if (cnt >= tmp)\n                    max\
    \ = tmp;\n                cnt = 1;\n                tmp = arr[i];\n          \
    \  }\n        }\n        if (cnt >= tmp)\n            max = tmp;\n        return\
    \ max;", "        // Try to work with the given list of integers.\n        //\
    \ If that doesn't work, move to a list of frequencies.\n        Dictionary<long,\
    \ long> freq = new Dictionary<long, long>();\n        long result = -1;\n    \
    \    foreach (long num in lst) {\n            if (freq.ContainsKey(num)) {\n \
    \               freq[num]++;\n            } else {\n                freq[num]\
    \ = 1;\n            }\n        }\n        foreach (long k in freq.Keys) {\n  \
    \          if (k <= freq[k]) {\n                result = Math.Max(result, k);\n\
    \            }\n        }\n        return result;", "        var groups = from\
    \ number in lst\n                     group number by number into g\n        \
    \             let c = g.Count()\n                     where c >= g.Key\n     \
    \                orderby c descending\n                     select g.Key;\n  \
    \      return groups.FirstOrDefault();", "        // // Solution is O(n log n)\
    \ time and O(n) space.\n        var sorted = lst.OrderBy(x => x).ToList();\n \
    \       var grouped = sorted.GroupBy(x => x).ToList();\n        var element =\
    \ grouped.OrderByDescending(x => x.Count()).ThenByDescending(x => x.Key).FirstOrDefault();\n\
    \        return element != null && element.Count() >= element.Key ? element.Key\
    \ : -1;", '        return -1;', "        // Your code goes here.\n        return\
    \ -1;", "        // Generate the counts of each number in the list.\n        var\
    \ counts = new Dictionary<long, long>();\n        foreach (var v in lst) {\n \
    \           if (!counts.ContainsKey(v)) {\n                counts[v] = 0;\n  \
    \          }\n            counts[v] += 1;\n        }\n        // Find the maximum\
    \ count.\n        var maxCount = counts.Values.Max();\n        // Look for the\
    \ highest number with a count at least that large.\n        // Search backwards\
    \ through the list so that we get the highest such number.\n        for (int i\
    \ = maxCount; i >= 1; i--) {\n            var v = i;\n            if (counts.ContainsKey(v)\
    \ && counts[v] >= v) {\n                return v;\n            }\n        }\n\
    \        // Didn't find one.\n        return -1;", "        var s = lst.GroupBy(x\
    \ => x).OrderByDescending(x => x.Key).ToList();\n        long max = s.First().Key;\n\
    \        return s.Any(x => x.Key >= x.Count() && x.Key <= max) ? s.First(x =>\
    \ x.Key >= x.Count() && x.Key <= max).Key : -1;", "        long res = -1;\n  \
    \      long maxFrequency = -1;\n        var frequencyDict = new Dictionary<long,\
    \ long>();\n        foreach (var num in lst) {\n            if (frequencyDict.ContainsKey(num))\
    \ {\n                frequencyDict[num]++;\n            } else {\n           \
    \     frequencyDict[num] = 1;\n            }\n        }\n        foreach (var\
    \ frequency in frequencyDict) {\n            var num = frequency.Key;\n      \
    \      var frequencyCount = frequency.Value;\n            if (num <= frequencyCount\
    \ && frequencyCount > maxFrequency) {\n                maxFrequency = frequencyCount;\n\
    \                res = num;\n            }\n        }\n        return res;", " \
    \       // Your code here!\n        long result = -1;\n        long counter =\
    \ 0;\n        for (int i = 0; i < lst.Count; i++) {\n            counter = 0;\n\
    \            for (int j = 0; j < lst.Count; j++) {\n                if (lst[i]\
    \ == lst[j]) {\n                    counter++;\n                }\n          \
    \  }\n            if (counter >= lst[i] && lst[i] > result) {\n              \
    \  result = lst[i];\n            }\n        }\n        return result;", "    \
    \    var groups = lst.GroupBy(x => x).ToDictionary(x => x.Key, x => x.Count());\n\
    \        var orderedByValue = groups.OrderByDescending(x => x.Value).ToList();\n\
    \        if (orderedByValue.Count < 1) return -1;\n        var maxVal = orderedByValue[0].Key;\n\
    \        if (orderedByValue[0].Value < maxVal) return -1;\n        return maxVal;",
  "        // Create a dictionary of the number of times each number appears in the\
    \ list\n        Dictionary<long, long> dict = new Dictionary<long, long>();\n\
    \        foreach (long x in lst) {\n            if (dict.ContainsKey(x)) {\n \
    \               dict[x]++;\n            } else {\n                dict[x] = 1;\n\
    \            }\n        }\n        // Loop through the dictionary to find the\
    \ largest number that is greater than zero, and has a frequency \n        // equal\
    \ to or greater than the value of the integer itself.\n        long result = -1;\n\
    \        foreach (KeyValuePair<long, long> kvp in dict) {\n            if (kvp.Key\
    \ > 0 && kvp.Key <= kvp.Value && kvp.Key > result) {\n                result =\
    \ kvp.Key;\n            }\n        }\n        return result;", "        long count\
    \ = 0;\n        long number = -1;\n        foreach (var item in lst) {\n     \
    \       var fq = lst.Count(x => x == item);\n            if (fq >= item && fq\
    \ > count) {\n                count = fq;\n                number = item;\n  \
    \          }\n        }\n        return number;", "        long greatest = -1;\n\
    \        long greatestCount = 0;\n        long counter = 0;\n        for (int\
    \ i = 0; i < lst.Count; i++) {\n            if (lst[i] > greatest) {\n       \
    \         greatest = lst[i];\n                greatestCount = 0;\n           \
    \ }\n            if (lst[i] == greatest) {\n                greatestCount++;\n\
    \            }\n        }\n        if (greatestCount >= greatest) {\n        \
    \    return greatest;\n        }\n        return -1;"]
stop_tokens:
- "\n    }\n"
