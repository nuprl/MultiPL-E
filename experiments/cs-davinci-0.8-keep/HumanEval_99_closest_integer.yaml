name: HumanEval_99_closest_integer
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // Create a function that takes a value (string) representing a\
  \ number\n    // and returns the closest integer to it. If the number is equidistant\n\
  \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
  \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n   \
  \ // 15\n    // Note:\n    // Rounding away from zero means that if the given number\
  \ is equidistant\n    // from two integers, the one you should return is the one\
  \ that is the\n    // farthest from zero. For example closest_integer(\"14.5\")\
  \ should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n \
  \   public static long ClosestInteger(string value) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"\
  10\")) == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"\
  -15.5\")) == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n\
  \    Debug.Assert(ClosestInteger((\"0\")) == (0L));\n    }\n\n}\n"
completions: ["        // Find the closest integer to the given value\n        long\
    \ ret = 0;\n        if (value == null) {\n            return ret;\n        }\n\
    \        var dbl = double.Parse(value);\n        ret = (long)dbl;\n        if\
    \ (dbl < 0) {\n            if (ret == dbl) {\n                ret -= 1;\n    \
    \        }\n        } else {\n            if (ret != dbl) {\n                ret\
    \ += 1;\n            }\n        }\n        return ret;", "        // ...\n   \
    \     // TODO: Implement your solution here\n        // ...\n        return 0;",
  "        // TODO\n        // return Convert.ToInt64(Math.Round(Double.Parse(value)));\n\
    \        return (long) Math.Round(Double.Parse(value));", '        throw new NotImplementedException();',
  "        // Your code goes here\n        long num = (long)Math.Round(Double.Parse(value));\n\
    \        return num;", "        // write your code here\n        return default(long);",
  "        long rounded = (long)Math.Round(double.Parse(value));\n        double diff\
    \ = Math.Abs(double.Parse(value) - rounded);\n        return diff < 0.5 ? rounded\
    \ : rounded + (long)Math.Sign(rounded);", '        return (long)Math.Round(Double.Parse(value));',
  "        long integer = 0;\n        string[] split = value.Split('.');\n       \
    \ // Check if the number is a whole number\n        if (split.Length == 1) {\n\
    \            return long.Parse(value);\n        } else {\n            // If the\
    \ number is a decimal, check the decimal part\n            float decimalPart =\
    \ float.Parse(split[1]);\n            if (decimalPart > 5) {\n               \
    \ integer = long.Parse(split[0]) + 1;\n            } else {\n                integer\
    \ = long.Parse(split[0]);\n            }\n        }\n        return integer;",
  "        double num = double.Parse(value);\n        if (num < 0) {\n           \
    \ num -= 0.5;\n        } else {\n            num += 0.5;\n        }\n        return\
    \ (long)num;", "        var remaining_error = double.Parse(value);\n        var\
    \ digit = 0;\n        var closest_integer = 0;\n        while (remaining_error\
    \ > 0) {\n            var digit_plus_one = Math.Ceiling(remaining_error * 10);\n\
    \            var digit_minus_one = Math.Floor(remaining_error * 10);\n       \
    \     if (Math.Abs(digit_plus_one - remaining_error * 10) < Math.Abs(digit_minus_one\
    \ - remaining_error * 10)) {\n                closest_integer += 1 * (long)Math.Pow(10,\
    \ digit);\n                remaining_error -= 1;\n            } else {\n     \
    \           closest_integer += 0 * (long)Math.Pow(10, digit);\n              \
    \  remaining_error -= 0;\n            }\n            remaining_error *= 10;\n\
    \            digit += 1;\n        }\n        return closest_integer;", "     \
    \   var number = long.Parse(value);\n        return number;", "        float val\
    \ = float.Parse(value);\n        return (long)Math.Round(val, 0, MidpointRounding.AwayFromZero);",
  "        long closest = long.MaxValue;\n        try {\n            closest = Convert.ToInt64(value);\n\
    \        } catch {\n            char[] val = value.ToCharArray();\n          \
    \  int len = val.Length;\n            int i = val.Length - 1;\n            for\
    \ (; i >= 0; i--) {\n                if (val[i] == '.') break;\n            }\n\
    \            if (i < 0) throw new ArgumentException();\n            i++;\n   \
    \         int s = 1;\n            if (val[0] == '-') {\n                s = -1;\n\
    \                i = 1;\n            }\n            int d = val[i] - '0';\n  \
    \          if (d >= 5) {\n                int j = i - 1;\n                for\
    \ (; j >= 0; j--) {\n                    if (val[j] == '-') break;\n         \
    \           val[j]++;\n                    if (val[j] == '9' + 1) {\n        \
    \                val[j] = '0';\n                    } else {\n               \
    \         break;\n                    }\n                }\n                if\
    \ (j < 0) {\n                    string outStr = new string(val);\n          \
    \          return Convert.ToInt64(outStr);\n                }\n            }\n\
    \            if (i < len) val[i] = '\\0';\n            string outStrr = new string(val);\n\
    \            closest = Convert.ToInt64(outStrr);\n        }\n        return closest;",
  "        // convert value to a number\n        double val = double.Parse(value);\n\
    \        // round the number to get the closest integer\n        long rounded\
    \ = (long)Math.Round(val);\n        // return the value of the closest integer\n\
    \        return rounded;", '        throw new NotImplementedException();', " \
    \       // Check whether the value is a valid number\n        if (!double.TryParse(value,\
    \ out double doubleValue)) {\n            throw new ArgumentException(\"The value\
    \ must be a valid number.\");\n        }\n        // If the number is an integer,\
    \ return that value\n        if (doubleValue % 1 == 0) {\n            return (long)doubleValue;\n\
    \        }\n        // Round the value away from zero\n        doubleValue = Math.Round(doubleValue,\
    \ MidpointRounding.AwayFromZero);\n        // Convert back to an integer\n   \
    \     return (long)doubleValue;", '        return Math.Round(Convert.ToDouble(value));',
  "        double d = double.Parse(value);\n        return (long)d;", "        //\
    \ Your code here\n        return 0;"]
stop_tokens:
- "\n    }\n"
