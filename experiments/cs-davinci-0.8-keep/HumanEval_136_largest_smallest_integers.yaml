name: HumanEval_136_largest_smallest_integers
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // Create a function that returns a tuple (a, b), where 'a' is\n\
  \    // the largest of negative integers, and 'b' is the smallest\n    // of positive\
  \ integers in a list.\n    // If there is no negative or positive integers, return\
  \ them as None.\n    // Examples:\n    // largest_smallest_integers([2, 4, 1, 3,\
  \ 5, 7]) == (None, 1)\n    // largest_smallest_integers([]) == (None, None)\n  \
  \  // largest_smallest_integers([0]) == (None, None)\n    public static Tuple<Nullable<long>,\
  \ Nullable<long>> LargestSmallestIntegers(List<long> lst) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(LargestSmallestIntegers((new\
  \ List<long>(new long[]{(long)2L, (long)4L, (long)1L, (long)3L, (long)5L, (long)7L}))).Equals(Tuple.Create((Nullable<long>)null,\
  \ 1L)));\n    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)2L,\
  \ (long)4L, (long)1L, (long)3L, (long)5L, (long)7L, (long)0L}))).Equals(Tuple.Create((Nullable<long>)null,\
  \ 1L)));\n    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)1L,\
  \ (long)3L, (long)2L, (long)4L, (long)5L, (long)6L, (long)-2L}))).Equals(Tuple.Create(-2L,\
  \ 1L)));\n    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)4L,\
  \ (long)5L, (long)3L, (long)6L, (long)2L, (long)7L, (long)-7L}))).Equals(Tuple.Create(-7L,\
  \ 2L)));\n    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)7L,\
  \ (long)3L, (long)8L, (long)4L, (long)9L, (long)2L, (long)5L, (long)-9L}))).Equals(Tuple.Create(-9L,\
  \ 2L)));\n    Debug.Assert(LargestSmallestIntegers((new List<long>())).Equals(Tuple.Create((Nullable<long>)null,\
  \ (Nullable<long>)null)));\n    Debug.Assert(LargestSmallestIntegers((new List<long>(new\
  \ long[]{(long)0L}))).Equals(Tuple.Create((Nullable<long>)null, (Nullable<long>)null)));\n\
  \    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)-1L,\
  \ (long)-3L, (long)-5L, (long)-6L}))).Equals(Tuple.Create(-1L, (Nullable<long>)null)));\n\
  \    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)-1L,\
  \ (long)-3L, (long)-5L, (long)-6L, (long)0L}))).Equals(Tuple.Create(-1L, (Nullable<long>)null)));\n\
  \    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)-6L,\
  \ (long)-4L, (long)-4L, (long)-3L, (long)1L}))).Equals(Tuple.Create(-3L, 1L)));\n\
  \    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)-6L,\
  \ (long)-4L, (long)-4L, (long)-3L, (long)-100L, (long)1L}))).Equals(Tuple.Create(-3L,\
  \ 1L)));\n    }\n\n}\n"
completions: ["        Nullable<long> largestNegativeInt = null;\n        Nullable<long>\
    \ smallestPositiveInt = null;\n        for (int i = 0; i < lst.Count; i++) {\n\
    \            if (lst[i] < 0) {\n                if (largestNegativeInt == null)\
    \ {\n                    largestNegativeInt = lst[i];\n                } else\
    \ if (lst[i] > largestNegativeInt) {\n                    largestNegativeInt =\
    \ lst[i];\n                }\n            } else if (lst[i] > 0) {\n         \
    \       if (smallestPositiveInt == null) {\n                    smallestPositiveInt\
    \ = lst[i];\n                } else if (lst[i] < smallestPositiveInt) {\n    \
    \                smallestPositiveInt = lst[i];\n                }\n          \
    \  }\n        }\n        Tuple<Nullable<long>, Nullable<long>> result = new Tuple<Nullable<long>,\
    \ Nullable<long>>(largestNegativeInt, smallestPositiveInt);\n        return result;",
  "        var min = lst.Where(x => x > 0).Min();\n        var max = lst.Where(x =>\
    \ x < 0).Max();\n        return new Tuple<Nullable<long>, Nullable<long>>(max,\
    \ min);", "        // WRITE YOUR CODE BELOW THIS LINE\n        var min = lst.Where(x\
    \ => x > 0).DefaultIfEmpty().Min();\n        var max = lst.Where(x => x < 0).DefaultIfEmpty().Max();\n\
    \        return new Tuple<Nullable<long>, Nullable<long>>(max, min);\n       \
    \ // WRITE YOUR CODE ABOVE THIS LINE", "        // TODO: solve it\n        return\
    \ null;", '        throw new NotImplementedException();', "        lst.Sort();\n\
    \        long? a = null;\n        long? b = null;\n        foreach (var i in lst)\
    \ {\n            if (i > 0) {\n                b = i;\n                break;\n\
    \            }\n            if (i < 0) {\n                a = i;\n           \
    \ }\n        }\n        return new Tuple<Nullable<long>, Nullable<long>>(a, b);",
  "        long? maxNeg = null;\n        long? minPos = null;\n        foreach (long\
    \ x in lst) {\n            if (x >= 0) {\n                if (minPos == null ||\
    \ x < minPos) {\n                    minPos = x;\n                }\n        \
    \    } else {\n                if (maxNeg == null || x > maxNeg) {\n         \
    \           maxNeg = x;\n                }\n            }\n        }\n       \
    \ return new Tuple<Nullable<long>, Nullable<long>>(maxNeg, minPos);", "      \
    \  // your code goes here.\n        return new Tuple<Nullable<long>, Nullable<long>>(null,\
    \ null);", "        if (lst.Count == 0)\n            return new Tuple<Nullable<long>,\
    \ Nullable<long>>(null, null);\n        long m = lst[0];\n        long M = lst[0];\n\
    \        long c = 0;\n        long d = 0;\n        foreach (long i in lst) {\n\
    \            if (i > 0) {\n                if (d == 0)\n                    m\
    \ = i;\n                else if (i < m)\n                    m = i;\n        \
    \        d++;\n            }\n            if (i < 0) {\n                if (c\
    \ == 0)\n                    M = i;\n                else if (i > M)\n       \
    \             M = i;\n                c++;\n            }\n        }\n       \
    \ return new Tuple<Nullable<long>, Nullable<long>>(c == 0 ? null : (Nullable<long>)M,\
    \ d == 0 ? null : (Nullable<long>)m);", "        var a = (Nullable<long>)null;\n\
    \        var b = (Nullable<long>)null;\n        for (int i = 0; i < lst.Count;\
    \ i++) {\n            if (lst[i] < 0) {\n                if (a == null || lst[i]\
    \ > a) {\n                    a = lst[i];\n                }\n            } else\
    \ if (lst[i] > 0) {\n                if (b == null || lst[i] < b) {\n        \
    \            b = lst[i];\n                }\n            }\n        }\n      \
    \  return new Tuple<Nullable<long>, Nullable<long>>(a, b);", "        long min\
    \ = lst.Count > 0 ? lst.Min() : 0;\n        long max = lst.Count > 0 ? lst.Max()\
    \ : 0;\n        long a = lst.Count > 0 ? lst.Where(x => x < 0).Max() : (long?)null;\n\
    \        long b = lst.Count > 0 ? lst.Where(x => x > 0).Min() : (long?)null;\n\
    \        return new Tuple<Nullable<long>, Nullable<long>>(a, b);", "        //\
    \ Your code goes here.\n        // You can change the return value if needed.\n\
    \        return new Tuple<Nullable<long>, Nullable<long>>(0, 0);", "        var\
    \ a = lst.FindAll(x => x > 0).Min();\n        var b = lst.FindAll(x => x < 0).Max();\n\
    \        return new Tuple<Nullable<long>, Nullable<long>>(b, a);", "        long\
    \ max = long.MinValue;\n        long min = long.MaxValue;\n        bool flag =\
    \ false;\n        long temp;\n        Nullable<long> nmax = null;\n        Nullable<long>\
    \ nmin = null;\n        foreach (long x in lst) {\n            temp = x;\n   \
    \         if (temp > 0) {\n                flag = true;\n                if (temp\
    \ < min) {\n                    min = temp;\n                }\n            }\n\
    \            if (temp < 0) {\n                flag = true;\n                if\
    \ (temp > max) {\n                    max = temp;\n                }\n       \
    \     }\n        }\n        if (flag) {\n            nmax = max;\n           \
    \ nmin = min;\n        }\n        return Tuple.Create(nmax, nmin);", "       \
    \ long min = long.MaxValue;\n        long max = long.MinValue;\n        foreach\
    \ (var x in lst) {\n            if (x < 0) {\n                max = Math.Max(max,\
    \ x);\n            } else if (x > 0) {\n                min = Math.Min(min, x);\n\
    \            }\n        }\n        if (min == long.MaxValue) {\n            min\
    \ = 0;\n        }\n        if (max == long.MinValue) {\n            max = 0;\n\
    \        }\n        return new Tuple<Nullable<long>, Nullable<long>>(max == 0\
    \ ? null : (long?)max, min == 0 ? null : (long?)min);", "        // your code\
    \ here\n        long minPos = long.MaxValue;\n        long maxNeg = long.MinValue;\n\
    \        bool foundPos = false;\n        bool foundNeg = false;\n        foreach\
    \ (var item in lst)\n        {\n            if (item > 0)\n            {\n   \
    \             if (item < minPos)\n                {\n                    minPos\
    \ = item;\n                }\n                foundPos = true;\n            }\n\
    \            else if (item < 0)\n            {\n                if (item > maxNeg)\n\
    \                {\n                    maxNeg = item;\n                }\n  \
    \              foundNeg = true;\n            }\n        }\n        return new\
    \ Tuple<Nullable<long>, Nullable<long>>(\n            foundNeg ? maxNeg : (Nullable<long>)null,\n\
    \            foundPos ? minPos : (Nullable<long>)null);", "        // create a\
    \ variable that you assign the smallest number to\n        long Smallest = long.MaxValue;\n\
    \        // create a variable that you assign the largest number to\n        long\
    \ Largest = long.MinValue;\n        // create a variable that you assign the smallest\
    \ number to\n        // create a variable that you assign the largest number to\n\
    \        // loop through the array\n        foreach (long number in lst) {\n \
    \           // if the number is smaller than the smallest\n            if (number\
    \ < Smallest) {\n                // then set the smallest to the number\n    \
    \            Smallest = number;\n            }\n            // if the number is\
    \ greater than the largest\n            if (number > Largest) {\n            \
    \    // then set the largest to the number\n                Largest = number;\n\
    \            }\n        }\n        // if the largest is less than 0\n        if\
    \ (Largest < 0) {\n            // set it to null\n            Largest = long.MinValue;\n\
    \        }\n        // if the smallest is greater than 0\n        if (Smallest\
    \ > 0) {\n            // set it to null\n            Smallest = long.MaxValue;\n\
    \        }\n        // return the largest and smallest numbers\n        return\
    \ new Tuple<Nullable<long>, Nullable<long>>(Largest, Smallest);", "        var\
    \ min = lst.Where(x => x > 0).DefaultIfEmpty().Min();\n        var max = lst.Where(x\
    \ => x < 0).DefaultIfEmpty().Max();\n        return new Tuple<Nullable<long>,\
    \ Nullable<long>>(max, min);", "        Nullable<long> largest = null;\n     \
    \   Nullable<long> smallest = null;\n        foreach (var num in lst) {\n    \
    \        if (num < 0) {\n                if (largest == null || num > largest)\
    \ {\n                    largest = num;\n                }\n            } else\
    \ if (num > 0) {\n                if (smallest == null || num < smallest) {\n\
    \                    smallest = num;\n                }\n            }\n     \
    \   }\n        return new Tuple<Nullable<long>, Nullable<long>>(largest, smallest);",
  "        Nullable<long> max = null;\n        Nullable<long> min = null;\n      \
    \  foreach (long value in lst) {\n            if (value < 0) {\n             \
    \   if (max == null || value > max) {\n                    max = value;\n    \
    \            }\n            } else if (value > 0) {\n                if (min ==\
    \ null || value < min) {\n                    min = value;\n                }\n\
    \            }\n        }\n        return new Tuple<Nullable<long>, Nullable<long>>(max,\
    \ min);"]
stop_tokens:
- "\n    }\n"
