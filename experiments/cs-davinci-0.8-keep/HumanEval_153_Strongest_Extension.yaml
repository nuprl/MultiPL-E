name: HumanEval_153_Strongest_Extension
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // You will be given the name of a class (a string) and a list\
  \ of extensions.\n    // The extensions are to be used to load additional classes\
  \ to the class. The\n    // strength of the extension is as follows: Let CAP be\
  \ the number of the uppercase\n    // letters in the extension's name, and let SM\
  \ be the number of lowercase letters \n    // in the extension's name, the strength\
  \ is given by the fraction CAP - SM. \n    // You should find the strongest extension\
  \ and return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
  \    // If there are two or more extensions with the same strength, you should\n\
  \    // choose the one that comes first in the list.\n    // For example, if you\
  \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
  \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
  \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n  \
  \  // Example:\n    // for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) ==\
  \ 'my_class.AA'\n    public static string StrongestExtension(string class_name,\
  \ List<string> extensions) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(StrongestExtension((\"\
  Watashi\"), (new List<string>(new string[]{(string)\"tEN\", (string)\"niNE\", (string)\"\
  eIGHt8OKe\"}))).Equals((\"Watashi.eIGHt8OKe\")));\n    Debug.Assert(StrongestExtension((\"\
  Boku123\"), (new List<string>(new string[]{(string)\"nani\", (string)\"NazeDa\"\
  , (string)\"YEs.WeCaNe\", (string)\"32145tggg\"}))).Equals((\"Boku123.YEs.WeCaNe\"\
  )));\n    Debug.Assert(StrongestExtension((\"__YESIMHERE\"), (new List<string>(new\
  \ string[]{(string)\"t\", (string)\"eMptY\", (string)\"nothing\", (string)\"zeR00\"\
  , (string)\"NuLl__\", (string)\"123NoooneB321\"}))).Equals((\"__YESIMHERE.NuLl__\"\
  )));\n    Debug.Assert(StrongestExtension((\"K\"), (new List<string>(new string[]{(string)\"\
  Ta\", (string)\"TAR\", (string)\"t234An\", (string)\"cosSo\"}))).Equals((\"K.TAR\"\
  )));\n    Debug.Assert(StrongestExtension((\"__HAHA\"), (new List<string>(new string[]{(string)\"\
  Tab\", (string)\"123\", (string)\"781345\", (string)\"-_-\"}))).Equals((\"__HAHA.123\"\
  )));\n    Debug.Assert(StrongestExtension((\"YameRore\"), (new List<string>(new\
  \ string[]{(string)\"HhAas\", (string)\"okIWILL123\", (string)\"WorkOut\", (string)\"\
  Fails\", (string)\"-_-\"}))).Equals((\"YameRore.okIWILL123\")));\n    Debug.Assert(StrongestExtension((\"\
  finNNalLLly\"), (new List<string>(new string[]{(string)\"Die\", (string)\"NowW\"\
  , (string)\"Wow\", (string)\"WoW\"}))).Equals((\"finNNalLLly.WoW\")));\n    Debug.Assert(StrongestExtension((\"\
  _\"), (new List<string>(new string[]{(string)\"Bb\", (string)\"91245\"}))).Equals((\"\
  _.Bb\")));\n    Debug.Assert(StrongestExtension((\"Sp\"), (new List<string>(new\
  \ string[]{(string)\"671235\", (string)\"Bb\"}))).Equals((\"Sp.671235\")));\n  \
  \  }\n\n}\n"
completions: ["        var class_name_extension = $\"{class_name}.\";\n        var\
    \ strongest_extension = extensions.Select(x => new\n        {\n            x,\n\
    \            strength = x.Count(Char.IsUpper) - x.Count(Char.IsLower)\n      \
    \  }).Aggregate((x, y) => x.strength > y.strength ? x : y);\n        var result\
    \ = $\"{class_name_extension}{strongest_extension.x}\";\n        return result;",
  "        string strongest_extension = extensions[0];\n        float strongest_strength\
    \ = 0;\n        for (int i = 0; i < extensions.Count; i++) {\n            int\
    \ upper_case_letters = 0;\n            int lower_case_letters = 0;\n         \
    \   for (int j = 0; j < extensions[i].Length; j++) {\n                if (char.IsUpper(extensions[i][j]))\n\
    \                    upper_case_letters++;\n                else\n           \
    \         lower_case_letters++;\n            }\n            float strength = upper_case_letters\
    \ - lower_case_letters;\n            if (strength > strongest_strength) {\n  \
    \              strongest_strength = strength;\n                strongest_extension\
    \ = extensions[i];\n            }\n        }\n        return class_name + \".\"\
    \ + strongest_extension;", "        var classname = \".\" + class_name;\n    \
    \    var best = extensions.Aggregate((x, y) => x.ToUpper().Length - x.ToLower().Length\
    \ < y.ToUpper().Length - y.ToLower().Length ? y : x);\n        return classname\
    \ + \".\" + best;", "        string strongest = \"\";\n        double max_strength\
    \ = 0;\n        // Find the strongest extension from the list.\n        foreach\
    \ (string ext in extensions) {\n            int capital_count = 0;\n         \
    \   int small_count = 0;\n            for (int i = 0; i < ext.Length; i++) {\n\
    \                if (Char.IsUpper(ext[i])) {\n                    capital_count++;\n\
    \                } else {\n                    small_count++;\n              \
    \  }\n            }\n            double strength = (double)capital_count - (double)small_count;\n\
    \            if (strength > max_strength) {\n                max_strength = strength;\n\
    \                strongest = ext;\n            }\n        }\n        return class_name\
    \ + \".\" + strongest;", "        // write your code here.\n        return \"\"\
    ;", "        // Write your code here...\n        int max = 0;\n        int ind\
    \ = 0;\n        for (int i = 0; i < extensions.Count; i++) {\n            int\
    \ cap = 0;\n            int sm = 0;\n            foreach (char c in extensions[i])\
    \ {\n                if (char.IsUpper(c)) {\n                    cap++;\n    \
    \            } else {\n                    sm++;\n                }\n        \
    \    }\n            if (cap - sm > max) {\n                max = cap - sm;\n \
    \               ind = i;\n            }\n        }\n        return $\"{class_name}.{extensions[ind]}\"\
    ;", '        throw new NotImplementedException();', "        var strongest = 0;\n\
    \        var strongest_extension = string.Empty;\n        foreach (var extension\
    \ in extensions) {\n            var cap = extension.Count(c => char.IsUpper(c));\n\
    \            var sm = extension.Count(c => char.IsLower(c));\n            var\
    \ strength = cap - sm;\n            if (strength > strongest) {\n            \
    \    strongest = strength;\n                strongest_extension = extension;\n\
    \            }\n        }\n        return $\"{class_name}.{strongest_extension}\"\
    ;", "        int strongest = 0;\n        string strongestExtension = \"\";\n \
    \       for (int i = 0; i < extensions.Count; i++) {\n            int current\
    \ = 0;\n            for (int j = 0; j < extensions[i].Length; j++) {\n       \
    \         if (char.IsUpper(extensions[i][j])) {\n                    current++;\n\
    \                } else {\n                    current--;\n                }\n\
    \            }\n            if (Math.Abs(current) > Math.Abs(strongest)) {\n \
    \               strongest = current;\n                strongestExtension = extensions[i];\n\
    \            }\n        }\n        return $\"{class_name}.{strongestExtension}\"\
    ;", '        // Your code here', "        var strengths = extensions.Select(e\
    \ => { \n            return new {\n                strength = (double)e.Count(c\
    \ => char.IsUpper(c)) - e.Count(c => char.IsLower(c)),\n                ext =\
    \ e\n            };\n        }).ToList();\n        var max_strength = strengths.Max(s\
    \ => s.strength);\n        var strongest = strengths.Where(s => s.strength ==\
    \ max_strength).First().ext;\n        return class_name + \".\" + strongest;",
  "        // your code\n        if (extensions.Count == 0) return class_name;\n \
    \       return class_name + \".\" + extensions.OrderByDescending(\n          \
    \  x => x.Count(ch => char.IsUpper(ch)) -\n            x.Count(ch => char.IsLower(ch))).First();",
  "        double max = -1;\n        int maxInd = 0;\n        for (int i = 0; i <\
    \ extensions.Count; i++) {\n            int upper = 0;\n            int lower\
    \ = 0;\n            foreach (char x in extensions[i]) {\n                if (char.IsUpper(x))\
    \ {\n                    upper++;\n                } else {\n                \
    \    lower++;\n                }\n            }\n            double val = (double)upper\
    \ / (double)lower;\n            if (val > max) {\n                max = val;\n\
    \                maxInd = i;\n            }\n        }\n        return class_name\
    \ + \".\" + extensions[maxInd];", "        // Write the solution here\n      \
    \  if (extensions.Count == 0)\n            return class_name;\n        int max\
    \ = 0;\n        string s = extensions[0];\n        for (int i = 0; i < extensions.Count;\
    \ i++)\n        {\n            int caps = extensions[i].Count(char.IsUpper);\n\
    \            int small = extensions[i].Count(char.IsLower);\n            if (caps\
    \ - small > max)\n            {\n                max = caps - small;\n       \
    \         s = extensions[i];\n            }\n        }\n        return class_name\
    \ + \".\" + s;", "        var strongest = new Tuple<string, float>(\"\", float.MinValue);\n\
    \        foreach (var ext in extensions) {\n            var strength = ((float)ext.Count(c\
    \ => char.IsUpper(c))) -\n                           ((float)ext.Count(c => char.IsLower(c)));\n\
    \            if (strength > strongest.Item2) {\n                strongest = new\
    \ Tuple<string, float>(ext, strength);\n            }\n        }\n        return\
    \ class_name + \".\" + strongest.Item1;", "        // Your code here.\n      \
    \  return \"\";", '        throw new NotImplementedException();', "        //\
    \ Write your code here.\n        string[] a = new string[3];\n        int[] c\
    \ = new int[3];\n        int[] d = new int[3];\n        int j = 0;\n        int\
    \ k = 0;\n        int r = 0;\n        for (int i = 0; i < extensions.Count; i++)\n\
    \        {\n            a[i] = extensions[i];\n            c[i] = 0;\n       \
    \     d[i] = 0;\n            char[] b = a[i].ToCharArray();\n            foreach\
    \ (char ch in b)\n            {\n                if (Char.IsUpper(ch))\n     \
    \           {\n                    c[i] = c[i] + 1;\n                }\n     \
    \           else if (Char.IsLower(ch))\n                {\n                  \
    \  d[i] = d[i] + 1;\n                }\n            }\n        }\n        int[]\
    \ e = new int[3];\n        for (int i = 0; i < c.Length; i++)\n        {\n   \
    \         e[i] = c[i] - d[i];\n        }\n        int f = e[0];\n        for (int\
    \ i = 0; i < e.Length; i++)\n        {\n            if (e[i] > f)\n          \
    \  {\n                f = e[i];\n                j = i;\n            }\n     \
    \   }\n        int g = c[0];\n        for (int i = 0; i < c.Length; i++)\n   \
    \     {\n            if (c[i] > g)\n            {\n                g = c[i];\n\
    \                k = i;\n            }\n        }\n        int h = d[0];\n   \
    \     for (int i = 0; i < d.Length; i++)\n        {\n            if (d[i] > h)\n\
    \            {\n                h = d[i];\n                r = i;\n          \
    \  }\n        }\n        if (j == k)\n        {\n            return class_name\
    \ + \".\" + a[k];\n        }\n        else if (j == r)\n        {\n          \
    \  return class_name + \".\" + a[r];\n        }\n        else\n        {\n   \
    \        ", "        float maxStrength = float.MinValue;\n        string maxExtension\
    \ = null;\n        int maxCap = 0;\n        int maxSm = 0;\n        int i = 0;\n\
    \        foreach (string ext in extensions) {\n            maxCap = 0;\n     \
    \       maxSm = 0;\n            for (i = 0; i < ext.Length; i++) {\n         \
    \       if (char.IsUpper(ext[i]))\n                    maxCap++;\n           \
    \     else if (char.IsLower(ext[i]))\n                    maxSm++;\n         \
    \   }\n            if (maxCap - maxSm > maxStrength) {\n                maxStrength\
    \ = maxCap - maxSm;\n                maxExtension = ext;\n            }\n    \
    \    }\n        return class_name + \".\" + maxExtension;", "        float best\
    \ = 0;\n        string best_name = \"\";\n        foreach (string name in extensions)\
    \ {\n            float strength = 0;\n            foreach (char c in name) {\n\
    \                if (char.IsUpper(c)) {\n                    strength += 1;\n\
    \                } else {\n                    strength -= 1;\n              \
    \  }\n            }\n            if (strength > best) {\n                best\
    \ = strength;\n                best_name = name;\n            }\n        }\n \
    \       return class_name + \".\" + best_name;"]
stop_tokens:
- "\n    }\n"
