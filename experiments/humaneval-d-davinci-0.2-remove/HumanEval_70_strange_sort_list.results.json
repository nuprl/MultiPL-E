{
  "language": "d",
  "name": "HumanEval_70_strange_sort_list",
  "results": [
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool is_min = true;\n    foreach(i; 0 .. lst.length)\n    {\n        if(is_min)\n        {\n            result[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n        }\n        else\n        {\n            result[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n        }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmphkuuwd_8.d(21): Error: no property `min` for type `long[]`\n/tmp/tmphkuuwd_8.d(22): Error: no property `remove` for type `long[]`\n/tmp/tmphkuuwd_8.d(26): Error: no property `max` for type `long[]`\n/tmp/tmphkuuwd_8.d(27): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphkuuwd_8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool is_min = true;\n    foreach(i; 0 .. lst.length)\n    {\n        if(is_min)\n        {\n            result[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n        }\n        else\n        {\n            result[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n        }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmphkuuwd_8.d(21): Error: no property `min` for type `long[]`\n/tmp/tmphkuuwd_8.d(22): Error: no property `remove` for type `long[]`\n/tmp/tmphkuuwd_8.d(26): Error: no property `max` for type `long[]`\n/tmp/tmphkuuwd_8.d(27): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphkuuwd_8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    while(lst.length > 0)\n    {\n        long min = lst[0];\n        long max = lst[0];\n        foreach(el; lst)\n        {\n            if(el < min)\n                min = el;\n            if(el > max)\n                max = el;\n        }\n        res[i] = min;\n        res[i+1] = max;\n        lst = lst.filter!(el => el != min && el != max);\n        i += 2;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprc4qsn51.d(29): Error: no property `filter` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprc4qsn51.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    while (lst.length > 0) {\n        result[i] = lst[0];\n        lst = lst[1..$];\n        if (lst.length > 0) {\n            result[i] = lst[$-1];\n            lst = lst[0..$-1];\n        }\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmphnvhjlwu.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x428915]\n??:? void tmphnvhjlwu.__unittest_L27_C1() [0x428042]\n??:? void tmphnvhjlwu.__modtest() [0x428698]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9f3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b886]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b11]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fc0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a9d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b85d]\n??:? runModuleUnitTests [0x42c7c9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428dd8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    int j = 0;\n    while (lst_copy.length > 0) {\n        result[i] = lst_copy[j];\n        lst_copy = lst_copy[0..$-1];\n        if (lst_copy.length > 0) {\n            result[i+1] = lst_copy[lst_copy.length-1];\n            lst_copy = lst_copy[0..$-1];\n        }\n        i += 2;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpkze3yedl.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x429a99]\n??:? void tmpkze3yedl.__unittest_L29_C1() [0x428246]\n??:? void tmpkze3yedl.__modtest() [0x428a10]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e6d7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x429722]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b461]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b4f0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b3ed]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x4296f9]\n??:? runModuleUnitTests [0x42e4ad]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429fb0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    while(lst_copy.length > 0)\n    {\n        result[i] = lst_copy.min;\n        lst_copy.remove(lst_copy.min);\n        if(lst_copy.length > 0)\n        {\n            result[i+1] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n        }\n        i += 2;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjyb5233f.d(19): Error: no property `min` for type `long[]`\n/tmp/tmpjyb5233f.d(20): Error: no property `remove` for type `long[]`\n/tmp/tmpjyb5233f.d(23): Error: no property `max` for type `long[]`\n/tmp/tmpjyb5233f.d(24): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjyb5233f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    long[] lst_sorted = lst.dup.sort();\n    bool is_min = true;\n    int i = 0;\n    int j = 0;\n    while (i < lst.length)\n    {\n        if (is_min)\n        {\n            res[i] = lst_sorted[j];\n            j++;\n        }\n        else\n        {\n            res[i] = lst_sorted[lst.length - j];\n        }\n        is_min = !is_min;\n        i++;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1kn4twjl.d(15): Error: no property `sort` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1kn4twjl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result;\n    auto min = min(lst);\n    auto max = max(lst);\n    auto min_index = indexOf(lst, min);\n    auto max_index = indexOf(lst, max);\n    result ~= min;\n    result ~= max;\n    lst[min_index] = 0;\n    lst[max_index] = 0;\n    while(lst.length > 0)\n    {\n        min = min(lst);\n        max = max(lst);\n        min_index = indexOf(lst, min);\n        max_index = indexOf(lst, max);\n        result ~= min;\n        result ~= max;\n        lst[min_index] = 0;\n        lst[max_index] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppn92is7b.d(15): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmppn92is7b.d(16): Error: undefined identifier `max`, did you mean function `fmax`?\n/tmp/tmppn92is7b.d(17): Error: undefined identifier `indexOf`\n/tmp/tmppn92is7b.d(18): Error: undefined identifier `indexOf`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppn92is7b.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <= j) {\n        if (k % 2 == 0) {\n            result[k] = lst[i];\n            i++;\n        } else {\n            result[k] = lst[j];\n            j--;\n        }\n        k++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmgzuyx7x.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmgzuyx7x.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n    int i = 0;\n    int j = sorted.length - 1;\n    int k = 0;\n    while (i <= j) {\n        result[k++] = sorted[i++];\n        if (i <= j) {\n            result[k++] = sorted[j--];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp3p260i7_.d(15): Error: no property `sort` for type `long[]`\n/tmp/tmp3p260i7_.d(17): Error: cannot implicitly convert expression `sorted.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3p260i7_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <= j)\n    {\n        if (k % 2 == 0)\n        {\n            result[k] = lst[i];\n            i++;\n        }\n        else\n        {\n            result[k] = lst[j];\n            j--;\n        }\n        k++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpimzrdujr.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpimzrdujr.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] sorted = new long[lst.length];\n    long[] remaining = lst.dup;\n    int i = 0;\n    bool ascending = true;\n    while (remaining.length > 0)\n    {\n        if (ascending)\n        {\n            sorted[i] = remaining.min;\n            remaining = remaining.remove(remaining.min);\n        }\n        else\n        {\n            sorted[i] = remaining.max;\n            remaining = remaining.remove(remaining.max);\n        }\n        i++;\n        ascending = !ascending;\n    }\n    return sorted;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp67x4g032.d(22): Error: no property `min` for type `long[]`\n/tmp/tmp67x4g032.d(23): Error: no property `remove` for type `long[]`\n/tmp/tmp67x4g032.d(27): Error: no property `max` for type `long[]`\n/tmp/tmp67x4g032.d(28): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp67x4g032.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    long min = lst_copy[0];\n    long max = lst_copy[0];\n    foreach (el; lst_copy)\n    {\n        if (el < min)\n            min = el;\n        if (el > max)\n            max = el;\n    }\n    res[0] = min;\n    lst_copy.remove(min);\n    res[1] = max;\n    lst_copy.remove(max);\n    int i = 2;\n    while (lst_copy.length > 0)\n    {\n        min = lst_copy[0];\n        max = lst_copy[0];\n        foreach (el; lst_copy)\n        {\n            if (el < min)\n                min = el;\n            if (el > max)\n                max = el;\n        }\n        res[i] = min;\n        lst_copy.remove(min);\n        i++;\n        res[i] = max;\n        lst_copy.remove(max);\n        i++;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpres9z6jb.d(28): Error: no property `remove` for type `long[]`\n/tmp/tmpres9z6jb.d(30): Error: no property `remove` for type `long[]`\n/tmp/tmpres9z6jb.d(44): Error: no property `remove` for type `long[]`\n/tmp/tmpres9z6jb.d(47): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpres9z6jb.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    long[] lst2 = lst.dup;\n    lst2.sort;\n    int i = 0;\n    int j = lst2.length - 1;\n    foreach(e; lst)\n    {\n        if(e == lst2[i])\n        {\n            res[i] = e;\n            i++;\n        }\n        else\n        {\n            res[j] = e;\n            j--;\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp7zbseznv.d(16): Error: no property `sort` for type `long[]`\n/tmp/tmp7zbseznv.d(18): Error: cannot implicitly convert expression `lst2.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7zbseznv.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] ret = new long[lst.length];\n    long[] lst2 = lst[];\n    int i = 0;\n    while (lst2.length > 0)\n    {\n        ret[i] = lst2[0];\n        lst2 = lst2[1..$];\n        if (lst2.length == 0)\n            break;\n        ret[i+1] = lst2[$-1];\n        lst2 = lst2[0..$-1];\n        i += 2;\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp71_vtrdh.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x428935]\n??:? void tmp71_vtrdh.__unittest_L29_C1() [0x4282b3]\n??:? void tmp71_vtrdh.__modtest() [0x4286b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca13]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8a6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b31]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fe0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430abd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b87d]\n??:? runModuleUnitTests [0x42c7e9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428df8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool flag = true;\n    while (i <= j)\n    {\n        if (flag)\n        {\n            result[i] = lst[i];\n            i++;\n        }\n        else\n        {\n            result[j] = lst[j];\n            j--;\n        }\n        flag = !flag;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpix2cm0wj.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpix2cm0wj.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n    int i = 0;\n    int j = sorted.length - 1;\n    int k = 0;\n    while (i <= j) {\n        result[k++] = sorted[i++];\n        if (i <= j) {\n            result[k++] = sorted[j--];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp3p260i7_.d(15): Error: no property `sort` for type `long[]`\n/tmp/tmp3p260i7_.d(17): Error: cannot implicitly convert expression `sorted.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3p260i7_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    while (lst.length > 0) {\n        long min = lst[0];\n        long max = lst[0];\n        foreach (el; lst) {\n            if (el < min) {\n                min = el;\n            }\n            if (el > max) {\n                max = el;\n            }\n        }\n        result[i] = min;\n        i++;\n        result[i] = max;\n        i++;\n        lst = lst.filter!(el => el != min && el != max);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpiqfgxrzc.d(31): Error: no property `filter` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiqfgxrzc.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool asc = true;\n    while (i <= j)\n    {\n        if (asc)\n        {\n            res[i] = lst[i];\n            i++;\n        }\n        else\n        {\n            res[j] = lst[j];\n            j--;\n        }\n        asc = !asc;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpm7gx5pe_.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm7gx5pe_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    while (i <= j) {\n        if (is_min) {\n            result[i] = lst[i];\n            i++;\n        } else {\n            result[j] = lst[j];\n            j--;\n        }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp6qfw2d3a.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6qfw2d3a.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    while (lst_copy.length > 0) \n    {\n        result[i] = lst_copy.min;\n        lst_copy.remove(lst_copy.min);\n        if (lst_copy.length > 0) \n        {\n            result[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n        }\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_tcct287.d(19): Error: no property `min` for type `long[]`\n/tmp/tmp_tcct287.d(20): Error: no property `remove` for type `long[]`\n/tmp/tmp_tcct287.d(23): Error: no property `max` for type `long[]`\n/tmp/tmp_tcct287.d(24): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_tcct287.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool ascending = true;\n    foreach(i; 0 .. lst.length)\n    {\n        if(ascending)\n        {\n            result[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n        }\n        else\n        {\n            result[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n        }\n        ascending = !ascending;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp69bw2ttv.d(21): Error: no property `min` for type `long[]`\n/tmp/tmp69bw2ttv.d(22): Error: no property `remove` for type `long[]`\n/tmp/tmp69bw2ttv.d(26): Error: no property `max` for type `long[]`\n/tmp/tmp69bw2ttv.d(27): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp69bw2ttv.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    foreach(e; lst)\n    {\n        if(is_min)\n        {\n            result[i] = e;\n            i++;\n        }\n        else\n        {\n            result[j] = e;\n            j--;\n        }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpov9oqqai.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpov9oqqai.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <= j)\n    {\n        if (k % 2 == 0)\n        {\n            res[k] = lst[i];\n            i++;\n        }\n        else\n        {\n            res[k] = lst[j];\n            j--;\n        }\n        k++;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppuyipqy7.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppuyipqy7.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result;\n    long[] sorted_lst = sort(lst);\n    long[] sorted_lst_rev = sort(lst, (a, b) => b < a);\n    bool is_even = true;\n    foreach(elem; sorted_lst)\n    {\n        if(is_even)\n        {\n            result ~= elem;\n        }\n        else\n        {\n            result = elem ~ result;\n        }\n        is_even = !is_even;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpk27wghqz.d(15): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpk27wghqz.d(16): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk27wghqz.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n    bool asc = true;\n    int i = 0;\n    while (sorted.length > 0)\n    {\n        if (asc)\n        {\n            result[i] = sorted[0];\n            sorted = sorted[1..$];\n        }\n        else\n        {\n            result[i] = sorted[$-1];\n            sorted = sorted[0..$-1];\n        }\n        asc = !asc;\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpfml8mdyq.d(15): Error: no property `sort` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfml8mdyq.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res;\n    bool asc = true;\n    long min, max;\n    long[] lst_remaining;\n    while (lst.length > 0)\n    {\n        if (asc)\n        {\n            min = lst[0];\n            foreach (i; lst)\n            {\n                if (i < min)\n                    min = i;\n            }\n            res ~= min;\n            lst_remaining = lst.filter!(i => i != min);\n            lst = lst_remaining;\n        }\n        else\n        {\n            max = lst[0];\n            foreach (i; lst)\n            {\n                if (i > max)\n                    max = i;\n            }\n            res ~= max;\n            lst_remaining = lst.filter!(i => i != max);\n            lst = lst_remaining;\n        }\n        asc = !asc;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpwfzhmn4r.d(29): Error: no property `filter` for type `long[]`\n/tmp/tmpwfzhmn4r.d(41): Error: no property `filter` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwfzhmn4r.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res;\n    long[] tmp;\n    long min;\n    long max;\n    long min_idx;\n    long max_idx;\n    long i;\n    long j;\n    long k;\n    long l;\n    long m;\n    long n;\n    long o;\n    long p;\n    long q;\n    long r;\n    long s;\n    long t;\n    long u;\n    long v;\n    long w;\n    long x;\n    long y;\n    long z;\n    long aa;\n    long ab;\n    long ac;\n    long ad;\n    long ae;\n    long af;\n    long ag;\n    long ah;\n    long ai;\n    long aj;\n    long ak;\n    long al;\n    long am;\n    long an;\n    long ao;\n    long ap;\n    long aq;\n    long ar;\n    long as;\n    long at;\n    long au;\n    long av;\n    long aw;\n    long ax;\n    long ay;\n    long az;\n    long ba;\n    long bb;\n    long bc;\n    long bd;\n    long be;\n    long bf;\n    long bg;\n    long bh;\n    long bi;\n    long bj;\n    long bk;\n    long bl;\n    long bm;\n    long bn;\n    long bo;\n    long bp;\n    long bq;\n    long br;\n    long bs;\n    long bt;\n    long bu;\n    long bv;\n    long bw;\n    long bx;\n    long by;\n    long bz;\n    long ca;\n    long cb;\n    long cc;\n    long cd;\n    long ce;\n    long cf;\n    long cg;\n    long ch;\n    long ci;\n    long cj;\n    long ck;\n    long cl;\n    long cm;\n    long cn;\n    long co;\n    long cp;\n    long cq;\n    long cr;\n   \nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmz0fijc5.d(109): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmz0fijc5.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <= j) \n    {\n        if (k % 2 == 0) \n        {\n            res[k] = lst_copy.min();\n            lst_copy.remove(lst_copy.min());\n            i++;\n        }\n        else \n        {\n            res[k] = lst_copy.max();\n            lst_copy.remove(lst_copy.max());\n            j--;\n        }\n        k++;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpv0ql7w8q.d(17): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\n/tmp/tmpv0ql7w8q.d(23): Error: no property `min` for type `long[]`\n/tmp/tmpv0ql7w8q.d(24): Error: no property `remove` for type `long[]`\n/tmp/tmpv0ql7w8q.d(29): Error: no property `max` for type `long[]`\n/tmp/tmpv0ql7w8q.d(30): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv0ql7w8q.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <= j) \n    {\n        if (k % 2 == 0) \n        {\n            res[k] = lst[i];\n            i++;\n        }\n        else \n        {\n            res[k] = lst[j];\n            j--;\n        }\n        k++;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprk27g1_v.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprk27g1_v.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <= j)\n    {\n        res[k++] = lst[i++];\n        if (i <= j)\n            res[k++] = lst[j--];\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpa8kqw5ii.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa8kqw5ii.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool asc = true;\n    while (i <= j)\n    {\n        if (asc)\n        {\n            res[i] = lst[i];\n            i++;\n        }\n        else\n        {\n            res[j] = lst[j];\n            j--;\n        }\n        asc = !asc;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpm7gx5pe_.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm7gx5pe_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool asc = true;\n    foreach(e; lst)\n    {\n        if(asc)\n        {\n            res[i] = e;\n            i++;\n        }\n        else\n        {\n            res[j] = e;\n            j--;\n        }\n        asc = !asc;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpw7y6y7ge.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw7y6y7ge.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    bool is_min = true;\n    while (i <= j)\n    {\n        if (is_min)\n        {\n            result[k] = min(lst[i], lst[j]);\n            if (lst[i] < lst[j])\n                i++;\n            else\n                j--;\n        }\n        else\n        {\n            result[k] = max(lst[i], lst[j]);\n            if (lst[i] > lst[j])\n                i++;\n            else\n                j--;\n        }\n        is_min = !is_min;\n        k++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpnkckbdou.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\n/tmp/tmpnkckbdou.d(23): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmpnkckbdou.d(31): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnkckbdou.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    while (i <= j) {\n        if (is_min) {\n            result[i] = lst[i];\n            i++;\n        } else {\n            result[j] = lst[j];\n            j--;\n        }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp6qfw2d3a.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6qfw2d3a.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    while (lst_copy.length > 0)\n    {\n        res[i] = lst_copy[0];\n        lst_copy = lst_copy[1..$];\n        if (lst_copy.length > 0)\n        {\n            res[i+1] = lst_copy[$-1];\n            lst_copy = lst_copy[0..$-1];\n        }\n        i += 2;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp_t5t1si7.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x429aa1]\n??:? void tmp_t5t1si7.__unittest_L30_C1() [0x42849f]\n??:? void tmp_t5t1si7.__modtest() [0x428a14]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e6df]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42972a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b469]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b4f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b3f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x429701]\n??:? runModuleUnitTests [0x42e4b5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429fb8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] ret = new long[lst.length];\n    auto min_max = minmax(lst);\n    long min = min_max[0];\n    long max = min_max[1];\n    long min_idx = 0;\n    long max_idx = lst.length - 1;\n    long idx = 0;\n    while (idx < lst.length) \n    {\n        if (idx % 2 == 0) \n        {\n            ret[idx] = min;\n            min_idx++;\n            min = lst[min_idx];\n        } \n        else \n        {\n            ret[idx] = max;\n            max_idx--;\n            max = lst[max_idx];\n        }\n        idx++;\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmps2qp0dyg.d(15): Error: undefined identifier `minmax`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps2qp0dyg.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] ret = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    while (lst_copy.length > 0) {\n        ret[i] = lst_copy.min;\n        lst_copy = lst_copy.remove(lst_copy.min);\n        i++;\n        if (lst_copy.length == 0) break;\n        ret[i] = lst_copy.max;\n        lst_copy = lst_copy.remove(lst_copy.max);\n        i++;\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpechhl7lz.d(18): Error: no property `min` for type `long[]`\n/tmp/tmpechhl7lz.d(19): Error: no property `remove` for type `long[]`\n/tmp/tmpechhl7lz.d(22): Error: no property `max` for type `long[]`\n/tmp/tmpechhl7lz.d(23): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpechhl7lz.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    while (lst_copy.length > 0) \n    {\n        res[i] = lst_copy.min;\n        lst_copy = lst_copy.remove(lst_copy.min);\n        if (lst_copy.length > 0) \n        {\n            res[i + 1] = lst_copy.max;\n            lst_copy = lst_copy.remove(lst_copy.max);\n        }\n        i += 2;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjlq0pw5w.d(19): Error: no property `min` for type `long[]`\n/tmp/tmpjlq0pw5w.d(20): Error: no property `remove` for type `long[]`\n/tmp/tmpjlq0pw5w.d(23): Error: no property `max` for type `long[]`\n/tmp/tmpjlq0pw5w.d(24): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjlq0pw5w.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool asc = true;\n    lst.sort();\n    foreach(e; lst)\n    {\n        if(asc)\n        {\n            res[i] = e;\n            i++;\n        }\n        else\n        {\n            res[j] = e;\n            j--;\n        }\n        asc = !asc;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp96il0m9g.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\n/tmp/tmp96il0m9g.d(18): Error: no property `sort` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp96il0m9g.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    foreach(e; lst)\n    {\n        if(i % 2 == 0)\n        {\n            res[i] = min(lst);\n            lst = lst[1..$];\n        }\n        else\n        {\n            res[i] = max(lst);\n            lst = lst[0..$-1];\n        }\n        i++;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp0iv2rcpt.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\n/tmp/tmp0iv2rcpt.d(21): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmp0iv2rcpt.d(26): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0iv2rcpt.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool inc = true;\n    while (i <= j)\n    {\n        if (inc)\n        {\n            result[i] = lst[i];\n            i++;\n        }\n        else\n        {\n            result[j] = lst[j];\n            j--;\n        }\n        inc = !inc;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp53m9rq4d.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp53m9rq4d.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result;\n    long[] sorted_lst = lst.dup;\n    sorted_lst.sort;\n    bool is_min = true;\n    foreach(elem; sorted_lst)\n    {\n        if(is_min)\n        {\n            result ~= elem;\n            is_min = false;\n        }\n        else\n        {\n            result.insert(0, elem);\n            is_min = true;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpb8padfgk.d(16): Error: no property `sort` for type `long[]`\n/tmp/tmpb8padfgk.d(27): Error: no property `insert` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb8padfgk.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <= j) \n    {\n        res[k++] = sorted[i++];\n        if (i <= j) \n        {\n            res[k++] = sorted[j--];\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpbuslrynw.d(15): Error: no property `sort` for type `long[]`\n/tmp/tmpbuslrynw.d(17): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbuslrynw.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    lst_copy.sort;\n    int i = 0;\n    int j = lst_copy.length - 1;\n    int k = 0;\n    while (i <= j) \n    {\n        result[k] = lst_copy[i];\n        i++;\n        k++;\n        if (i <= j) \n        {\n            result[k] = lst_copy[j];\n            j--;\n            k++;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp0xa7835c.d(16): Error: no property `sort` for type `long[]`\n/tmp/tmp0xa7835c.d(18): Error: cannot implicitly convert expression `lst_copy.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0xa7835c.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    long[] lst2 = lst.dup;\n    bool asc = true;\n    int i = 0;\n    while (lst2.length > 0)\n    {\n        if (asc)\n        {\n            res[i] = lst2.min;\n            lst2.remove(lst2.min);\n        }\n        else\n        {\n            res[i] = lst2.max;\n            lst2.remove(lst2.max);\n        }\n        i++;\n        asc = !asc;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpu9583c1l.d(22): Error: no property `min` for type `long[]`\n/tmp/tmpu9583c1l.d(23): Error: no property `remove` for type `long[]`\n/tmp/tmpu9583c1l.d(27): Error: no property `max` for type `long[]`\n/tmp/tmpu9583c1l.d(28): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu9583c1l.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] temp = lst.dup;\n    temp.sort;\n    int i = 0;\n    int j = temp.length - 1;\n    foreach(e; temp)\n    {\n        if(i % 2 == 0)\n        {\n            result[i] = temp[j];\n            j--;\n        }\n        else\n        {\n            result[i] = temp[j];\n            j++;\n        }\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpqiauud9v.d(16): Error: no property `sort` for type `long[]`\n/tmp/tmpqiauud9v.d(18): Error: cannot implicitly convert expression `temp.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqiauud9v.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    auto min = lst[0];\n    auto max = lst[0];\n    foreach(i; lst)\n    {\n        if(i < min)\n            min = i;\n        if(i > max)\n            max = i;\n    }\n    auto min_index = 0;\n    auto max_index = lst.length - 1;\n    foreach(i; 0..lst.length)\n    {\n        if(i % 2 == 0)\n        {\n            result[i] = min;\n            min_index++;\n            min = lst[min_index];\n            foreach(j; lst)\n            {\n                if(j < min && j > result[i])\n                    min = j;\n            }\n        }\n        else\n        {\n            result[i] = max;\n            max_index--;\n            max = lst[max_index];\n            foreach(j; lst)\n            {\n                if(j > max && j < result[i])\n                    max = j;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp38dh6z0t.d(60): unittest failure\n----------------\n??:? _d_unittestp [0x428b05]\n??:? void tmp38dh6z0t.__unittest_L53_C1() [0x428487]\n??:? void tmp38dh6z0t.__modtest() [0x428888]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cbe3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba76]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430d01]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4311b0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c8d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba4d]\n??:? runModuleUnitTests [0x42c9b9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428fc8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    foreach(e; lst)\n    {\n        if(is_min)\n        {\n            result[i] = e;\n            i++;\n        }\n        else\n        {\n            result[j] = e;\n            j--;\n        }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpov9oqqai.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpov9oqqai.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] ret = new long[lst.length];\n    long[] lst2 = lst.dup;\n    lst2.sort;\n    bool asc = true;\n    int i = 0;\n    while (lst2.length > 0)\n    {\n        if (asc)\n        {\n            ret[i] = lst2[0];\n            lst2 = lst2[1..$];\n        }\n        else\n        {\n            ret[i] = lst2[$-1];\n            lst2 = lst2[0..$-1];\n        }\n        i++;\n        asc = !asc;\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmqxb7gm3.d(16): Error: no property `sort` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmqxb7gm3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result;\n    long[] sorted_lst = lst.dup;\n    sorted_lst.sort;\n    bool is_min = true;\n    foreach(el; sorted_lst)\n    {\n        if(is_min)\n        {\n            result ~= el;\n            is_min = false;\n        }\n        else\n        {\n            result.insert(0, el);\n            is_min = true;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpvwyd_foh.d(16): Error: no property `sort` for type `long[]`\n/tmp/tmpvwyd_foh.d(27): Error: no property `insert` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvwyd_foh.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n    long[] reversed = sorted.dup.reverse;\n    bool is_reversed = false;\n    foreach(i, ref e; result)\n    {\n        if(is_reversed)\n        {\n            result[i] = reversed.front;\n            reversed.popFront;\n        }\n        else\n        {\n            result[i] = sorted.front;\n            sorted.popFront;\n        }\n        is_reversed = !is_reversed;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp93jay5st.d(15): Error: no property `sort` for type `long[]`\n/tmp/tmp93jay5st.d(16): Error: template `std.typecons.reverse` cannot deduce function from argument types `!()(long[])`, candidates are:\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T t) if (isTuple!T)`\n/tmp/tmp93jay5st.d(22): Error: no property `front` for type `long[]`\n/tmp/tmp93jay5st.d(23): Error: no property `popFront` for type `long[]`\n/tmp/tmp93jay5st.d(27): Error: no property `front` for type `long[]`\n/tmp/tmp93jay5st.d(28): Error: no property `popFront` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp93jay5st.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    while (lst_copy.length > 0) \n    {\n        result[i] = lst_copy.min;\n        lst_copy.remove(lst_copy.min);\n        i++;\n        if (lst_copy.length > 0) \n        {\n            result[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n            i++;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp2ff7vqc2.d(19): Error: no property `min` for type `long[]`\n/tmp/tmp2ff7vqc2.d(20): Error: no property `remove` for type `long[]`\n/tmp/tmp2ff7vqc2.d(24): Error: no property `max` for type `long[]`\n/tmp/tmp2ff7vqc2.d(25): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2ff7vqc2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    bool asc = true;\n    while (i <= j)\n    {\n        if (asc)\n        {\n            result[k] = lst[i];\n            i++;\n        }\n        else\n        {\n            result[k] = lst[j];\n            j--;\n        }\n        k++;\n        asc = !asc;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmr4iua6p.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmr4iua6p.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] ret = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    while (lst_copy.length > 0) {\n        ret[i] = lst_copy.min;\n        lst_copy.remove(lst_copy.min);\n        i++;\n        if (lst_copy.length > 0) {\n            ret[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n            i++;\n        }\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpy2rig_c3.d(18): Error: no property `min` for type `long[]`\n/tmp/tmpy2rig_c3.d(19): Error: no property `remove` for type `long[]`\n/tmp/tmpy2rig_c3.d(22): Error: no property `max` for type `long[]`\n/tmp/tmpy2rig_c3.d(23): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy2rig_c3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n    long[] reversed = sorted.dup.reverse;\n    bool is_reversed = false;\n    foreach(i, ref e; result)\n    {\n        if(is_reversed)\n        {\n            e = reversed.front;\n            reversed = reversed[1..$];\n        }\n        else\n        {\n            e = sorted.front;\n            sorted = sorted[1..$];\n        }\n        is_reversed = !is_reversed;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpdguf5kcn.d(15): Error: no property `sort` for type `long[]`\n/tmp/tmpdguf5kcn.d(16): Error: template `std.typecons.reverse` cannot deduce function from argument types `!()(long[])`, candidates are:\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T t) if (isTuple!T)`\n/tmp/tmpdguf5kcn.d(22): Error: no property `front` for type `long[]`\n/tmp/tmpdguf5kcn.d(27): Error: no property `front` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdguf5kcn.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] ret = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    while (lst_copy.length > 0) {\n        ret[i] = lst_copy.min;\n        lst_copy.remove(lst_copy.min);\n        i++;\n        if (lst_copy.length > 0) {\n            ret[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n            i++;\n        }\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpy2rig_c3.d(18): Error: no property `min` for type `long[]`\n/tmp/tmpy2rig_c3.d(19): Error: no property `remove` for type `long[]`\n/tmp/tmpy2rig_c3.d(22): Error: no property `max` for type `long[]`\n/tmp/tmpy2rig_c3.d(23): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy2rig_c3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result;\n    result.length = lst.length;\n    auto lst_copy = lst.dup;\n    auto lst_copy_sorted = lst_copy.sort;\n    auto lst_copy_sorted_reversed = lst_copy_sorted.dup.reverse;\n    int i = 0;\n    int j = 0;\n    foreach(e; lst_copy_sorted)\n    {\n        result[i] = e;\n        i += 2;\n    }\n    foreach(e; lst_copy_sorted_reversed)\n    {\n        result[j] = e;\n        j += 2;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpnvqh1ew2.d(17): Error: no property `sort` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnvqh1ew2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] temp = lst.dup;\n    temp.sort;\n    int i = 0;\n    int j = temp.length - 1;\n    int k = 0;\n    while (i <= j)\n    {\n        result[k] = temp[i];\n        i++;\n        k++;\n        if (i <= j)\n        {\n            result[k] = temp[j];\n            j--;\n            k++;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpdlacnsqs.d(16): Error: no property `sort` for type `long[]`\n/tmp/tmpdlacnsqs.d(18): Error: cannot implicitly convert expression `temp.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdlacnsqs.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    while (lst_copy.length > 0)\n    {\n        result[i] = lst_copy.min;\n        lst_copy.remove(lst_copy.min);\n        i++;\n        if (lst_copy.length > 0)\n        {\n            result[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n            i++;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp0mv_pmlq.d(19): Error: no property `min` for type `long[]`\n/tmp/tmp0mv_pmlq.d(20): Error: no property `remove` for type `long[]`\n/tmp/tmp0mv_pmlq.d(24): Error: no property `max` for type `long[]`\n/tmp/tmp0mv_pmlq.d(25): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0mv_pmlq.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result;\n    long[] sorted_lst = lst.dup;\n    sorted_lst.sort;\n    bool is_min = true;\n    foreach(elem; sorted_lst)\n    {\n        if(is_min)\n        {\n            result ~= elem;\n            is_min = false;\n        }\n        else\n        {\n            result.insert(0, elem);\n            is_min = true;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpb8padfgk.d(16): Error: no property `sort` for type `long[]`\n/tmp/tmpb8padfgk.d(27): Error: no property `insert` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb8padfgk.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    while (i <= j) {\n        if (is_min) {\n            result[i] = lst[i];\n            i++;\n        } else {\n            result[j] = lst[j];\n            j--;\n        }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp6qfw2d3a.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6qfw2d3a.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    while (lst_copy.length > 0) \n    {\n        result[i] = lst_copy.min;\n        lst_copy = lst_copy.remove(lst_copy.min);\n        if (lst_copy.length > 0) \n        {\n            result[i + 1] = lst_copy.max;\n            lst_copy = lst_copy.remove(lst_copy.max);\n        }\n        i += 2;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp8rvx7suj.d(19): Error: no property `min` for type `long[]`\n/tmp/tmp8rvx7suj.d(20): Error: no property `remove` for type `long[]`\n/tmp/tmp8rvx7suj.d(23): Error: no property `max` for type `long[]`\n/tmp/tmp8rvx7suj.d(24): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8rvx7suj.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool is_min = true;\n    foreach(i; 0 .. lst.length)\n    {\n        if(is_min)\n        {\n            result[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n        }\n        else\n        {\n            result[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n        }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmphkuuwd_8.d(21): Error: no property `min` for type `long[]`\n/tmp/tmphkuuwd_8.d(22): Error: no property `remove` for type `long[]`\n/tmp/tmphkuuwd_8.d(26): Error: no property `max` for type `long[]`\n/tmp/tmphkuuwd_8.d(27): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphkuuwd_8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n    int i = 0;\n    int j = sorted.length - 1;\n    bool is_min = true;\n    foreach(e; lst) \n    {\n        if (is_min) \n        {\n            result[i] = sorted[i];\n            i++;\n        } \n        else \n        {\n            result[j] = sorted[j];\n            j--;\n        }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpytdru00o.d(15): Error: no property `sort` for type `long[]`\n/tmp/tmpytdru00o.d(17): Error: cannot implicitly convert expression `sorted.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpytdru00o.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    while(lst_copy.length > 0)\n    {\n        result[i] = lst_copy.min;\n        lst_copy = lst_copy.remove(lst_copy.min);\n        i++;\n        if(lst_copy.length > 0)\n        {\n            result[i] = lst_copy.max;\n            lst_copy = lst_copy.remove(lst_copy.max);\n            i++;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpnd3d6e5u.d(19): Error: no property `min` for type `long[]`\n/tmp/tmpnd3d6e5u.d(20): Error: no property `remove` for type `long[]`\n/tmp/tmpnd3d6e5u.d(24): Error: no property `max` for type `long[]`\n/tmp/tmpnd3d6e5u.d(25): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnd3d6e5u.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool is_min = true;\n    int i = 0;\n    while (lst_copy.length > 0) {\n        if (is_min) {\n            res[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n        } else {\n            res[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n        }\n        is_min = !is_min;\n        i++;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpvno4bpgh.d(20): Error: no property `min` for type `long[]`\n/tmp/tmpvno4bpgh.d(21): Error: no property `remove` for type `long[]`\n/tmp/tmpvno4bpgh.d(23): Error: no property `max` for type `long[]`\n/tmp/tmpvno4bpgh.d(24): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvno4bpgh.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool flag = true;\n    while (i <= j) {\n        if (flag) {\n            result[i] = lst[i];\n            i++;\n        } else {\n            result[j] = lst[j];\n            j--;\n        }\n        flag = !flag;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpc4gl007n.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc4gl007n.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    while (i <= j) {\n        if (is_min) {\n            res[i] = lst[i];\n            i++;\n        } else {\n            res[j] = lst[j];\n            j--;\n        }\n        is_min = !is_min;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprp2utyi0.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprp2utyi0.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] temp = lst.dup;\n    temp.sort;\n    int i = 0;\n    int j = temp.length - 1;\n    int k = 0;\n    while (i <= j)\n    {\n        result[k] = temp[i];\n        k++;\n        if (i != j)\n        {\n            result[k] = temp[j];\n            k++;\n        }\n        i++;\n        j--;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpzouupttv.d(16): Error: no property `sort` for type `long[]`\n/tmp/tmpzouupttv.d(18): Error: cannot implicitly convert expression `temp.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzouupttv.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool asc = true;\n    while (i <= j) {\n        if (asc) {\n            res[i] = min(lst);\n            lst = remove(lst, min(lst));\n            i++;\n        } else {\n            res[j] = max(lst);\n            lst = remove(lst, max(lst));\n            j--;\n        }\n        asc = !asc;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpzbt2uz_6.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\n/tmp/tmpzbt2uz_6.d(20): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmpzbt2uz_6.d(21): Error: undefined identifier `remove`\n/tmp/tmpzbt2uz_6.d(24): Error: undefined identifier `max`, did you mean function `fmax`?\n/tmp/tmpzbt2uz_6.d(25): Error: undefined identifier `remove`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzbt2uz_6.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool asc = true;\n    int i = 0;\n    while (lst_copy.length > 0) \n    {\n        if (asc) \n        {\n            res[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n        }\n        else \n        {\n            res[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n        }\n        i++;\n        asc = !asc;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpcn4ud7si.d(22): Error: no property `min` for type `long[]`\n/tmp/tmpcn4ud7si.d(23): Error: no property `remove` for type `long[]`\n/tmp/tmpcn4ud7si.d(27): Error: no property `max` for type `long[]`\n/tmp/tmpcn4ud7si.d(28): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcn4ud7si.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    while (i <= j)\n    {\n        if (is_min)\n        {\n            result[i] = lst[i];\n            i++;\n        }\n        else\n        {\n            result[j] = lst[j];\n            j--;\n        }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp8j550_23.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8j550_23.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    lst_copy.sort;\n    bool is_min = true;\n    int i = 0;\n    while (lst_copy.length > 0) {\n        if (is_min) {\n            result[i] = lst_copy[0];\n            lst_copy = lst_copy[1..$];\n        } else {\n            result[i] = lst_copy[$-1];\n            lst_copy = lst_copy[0..$-1];\n        }\n        is_min = !is_min;\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpbd4ad5el.d(16): Error: no property `sort` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbd4ad5el.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] remaining = lst.dup;\n    long[] min_max = new long[2];\n    int i = 0;\n    while (remaining.length > 0) {\n        min_max = min_max_tuple(remaining);\n        result[i] = min_max[0];\n        remaining = remaining.remove(min_max[0]);\n        if (remaining.length > 0) {\n            result[i+1] = min_max[1];\n            remaining = remaining.remove(min_max[1]);\n        }\n        i += 2;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1omxflk6.d(19): Error: undefined identifier `min_max_tuple`\n/tmp/tmp1omxflk6.d(21): Error: no property `remove` for type `long[]`\n/tmp/tmp1omxflk6.d(24): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1omxflk6.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool asc = true;\n    while (i <= j)\n    {\n        if (asc)\n        {\n            res[i] = lst[i];\n            i++;\n        }\n        else\n        {\n            res[j] = lst[j];\n            j--;\n        }\n        asc = !asc;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpm7gx5pe_.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm7gx5pe_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool is_min = true;\n    int index = 0;\n    while (lst_copy.length > 0) {\n        if (is_min) {\n            result[index] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n        } else {\n            result[index] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n        }\n        is_min = !is_min;\n        index++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpxwxpe56z.d(20): Error: no property `min` for type `long[]`\n/tmp/tmpxwxpe56z.d(21): Error: no property `remove` for type `long[]`\n/tmp/tmpxwxpe56z.d(23): Error: no property `max` for type `long[]`\n/tmp/tmpxwxpe56z.d(24): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxwxpe56z.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool is_min = true;\n    int i = 0;\n    while(lst_copy.length > 0)\n    {\n        if(is_min)\n        {\n            result[i] = lst_copy.min;\n            lst_copy = lst_copy.remove(lst_copy.min);\n        }\n        else\n        {\n            result[i] = lst_copy.max;\n            lst_copy = lst_copy.remove(lst_copy.max);\n        }\n        is_min = !is_min;\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpo65tl9ux.d(22): Error: no property `min` for type `long[]`\n/tmp/tmpo65tl9ux.d(23): Error: no property `remove` for type `long[]`\n/tmp/tmpo65tl9ux.d(27): Error: no property `max` for type `long[]`\n/tmp/tmpo65tl9ux.d(28): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo65tl9ux.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    while (i <= j) {\n        if (is_min) {\n            result[i] = lst[i];\n            i++;\n        } else {\n            result[j] = lst[j];\n            j--;\n        }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp6qfw2d3a.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6qfw2d3a.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n    int i = 0;\n    int j = sorted.length - 1;\n    foreach(e; lst)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = sorted[i / 2];\n        }\n        else\n        {\n            result[i] = sorted[j];\n            j--;\n        }\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpq29_sryr.d(15): Error: no property `sort` for type `long[]`\n/tmp/tmpq29_sryr.d(17): Error: cannot implicitly convert expression `sorted.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq29_sryr.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int r = 0;\n    while(lst.length > 0)\n    {\n        result[r++] = lst[0];\n        lst = lst[1..$];\n        if(lst.length > 0)\n        {\n            result[r++] = lst[$-1];\n            lst = lst[0..$-1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp42eofxqw.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x42891d]\n??:? void tmp42eofxqw.__unittest_L28_C1() [0x42829b]\n??:? void tmp42eofxqw.__modtest() [0x42869c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b88e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b19]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fc8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430aa5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b865]\n??:? runModuleUnitTests [0x42c7d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428de0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result;\n    long[] sorted_lst = lst.dup;\n    sorted_lst.sort;\n    bool is_min = true;\n    foreach(elem; sorted_lst)\n    {\n        if(is_min)\n        {\n            result ~= elem;\n            is_min = false;\n        }\n        else\n        {\n            result.insert(0, elem);\n            is_min = true;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpb8padfgk.d(16): Error: no property `sort` for type `long[]`\n/tmp/tmpb8padfgk.d(27): Error: no property `insert` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb8padfgk.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    while (lst_copy.length > 0)\n    {\n        result[i] = lst_copy.min;\n        lst_copy.remove(lst_copy.min);\n        if (lst_copy.length > 0)\n        {\n            result[i+1] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n        }\n        i += 2;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp27rtq4qf.d(19): Error: no property `min` for type `long[]`\n/tmp/tmp27rtq4qf.d(20): Error: no property `remove` for type `long[]`\n/tmp/tmp27rtq4qf.d(23): Error: no property `max` for type `long[]`\n/tmp/tmp27rtq4qf.d(24): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp27rtq4qf.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] ret = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    while (lst_copy.length != 0) {\n        ret[i] = lst_copy.min;\n        lst_copy = lst_copy.remove(ret[i]);\n        i++;\n        if (lst_copy.length == 0) break;\n        ret[i] = lst_copy.max;\n        lst_copy = lst_copy.remove(ret[i]);\n        i++;\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpasrvpzmv.d(18): Error: no property `min` for type `long[]`\n/tmp/tmpasrvpzmv.d(19): Error: no property `remove` for type `long[]`\n/tmp/tmpasrvpzmv.d(22): Error: no property `max` for type `long[]`\n/tmp/tmpasrvpzmv.d(23): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpasrvpzmv.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    while (i <= j) {\n        if (is_min) {\n            result[i] = lst[i];\n            i++;\n        } else {\n            result[j] = lst[j];\n            j--;\n        }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp6qfw2d3a.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6qfw2d3a.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] sorted = lst.dup.sort();\n    int i = 0;\n    int j = sorted.length - 1;\n    int k = 0;\n    while (i <= j)\n    {\n        result[k++] = sorted[i++];\n        if (i <= j)\n            result[k++] = sorted[j--];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4z57g7_a.d(15): Error: no property `sort` for type `long[]`\n/tmp/tmp4z57g7_a.d(17): Error: cannot implicitly convert expression `sorted.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4z57g7_a.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool asc = true;\n    while (i <= j) {\n        if (asc) {\n            result[i] = lst[i];\n            i++;\n        } else {\n            result[j] = lst[j];\n            j--;\n        }\n        asc = !asc;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmph_ppw4hf.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph_ppw4hf.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    res[0] = lst[0];\n    int i = 1;\n    int j = lst.length - 1;\n    int k = 1;\n    while (i <= j)\n    {\n        if (k % 2 == 1)\n        {\n            res[k] = lst[j];\n            j--;\n        }\n        else\n        {\n            res[k] = lst[i];\n            i++;\n        }\n        k++;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpz034beft.d(19): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz034beft.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    while(lst_copy.length > 0)\n    {\n        result[i] = lst_copy.min;\n        lst_copy = lst_copy.filter!(x => x != lst_copy.min)();\n        i++;\n        if(lst_copy.length > 0)\n        {\n            result[i] = lst_copy.max;\n            lst_copy = lst_copy.filter!(x => x != lst_copy.max)();\n            i++;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppz1p2evu.d(19): Error: no property `min` for type `long[]`\n/tmp/tmppz1p2evu.d(20): Error: no property `filter` for type `long[]`\n/tmp/tmppz1p2evu.d(24): Error: no property `max` for type `long[]`\n/tmp/tmppz1p2evu.d(25): Error: no property `filter` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppz1p2evu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] copy = lst.dup;\n    int i = 0;\n    while (copy.length > 0) {\n        result[i] = copy.min;\n        copy.remove(copy.min);\n        i++;\n        if (copy.length > 0) {\n            result[i] = copy.max;\n            copy.remove(copy.max);\n            i++;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpwrka3rr9.d(18): Error: no property `min` for type `long[]`\n/tmp/tmpwrka3rr9.d(19): Error: no property `remove` for type `long[]`\n/tmp/tmpwrka3rr9.d(22): Error: no property `max` for type `long[]`\n/tmp/tmpwrka3rr9.d(23): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwrka3rr9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool is_max = true;\n    int i = 0;\n    while (lst_copy.length > 0) {\n        if (is_max) {\n            result[i] = max(lst_copy);\n            lst_copy = lst_copy.filter!(x => x != result[i]);\n        } else {\n            result[i] = min(lst_copy);\n            lst_copy = lst_copy.filter!(x => x != result[i]);\n        }\n        is_max = !is_max;\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpcin2uyvz.d(20): Error: undefined identifier `max`, did you mean function `fmax`?\n/tmp/tmpcin2uyvz.d(21): Error: no property `filter` for type `long[]`\n/tmp/tmpcin2uyvz.d(23): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmpcin2uyvz.d(24): Error: no property `filter` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcin2uyvz.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result;\n    long[] sorted_lst = sort(lst);\n    long[] reversed_lst = reverse(sorted_lst);\n    bool is_reversed = false;\n    foreach(i; 0 .. lst.length)\n    {\n        if(!is_reversed)\n        {\n            result ~= sorted_lst[i];\n            is_reversed = true;\n        }\n        else\n        {\n            result ~= reversed_lst[i];\n            is_reversed = false;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmph6ir786d.d(15): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmph6ir786d.d(16): Error: template `std.typecons.reverse` cannot deduce function from argument types `!()(long[])`, candidates are:\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T t) if (isTuple!T)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph6ir786d.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool is_min = true;\n    int i = 0;\n    while (lst_copy.length != 0) {\n        if (is_min) {\n            result[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n        } else {\n            result[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n        }\n        is_min = !is_min;\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpbwtt8as_.d(20): Error: no property `min` for type `long[]`\n/tmp/tmpbwtt8as_.d(21): Error: no property `remove` for type `long[]`\n/tmp/tmpbwtt8as_.d(23): Error: no property `max` for type `long[]`\n/tmp/tmpbwtt8as_.d(24): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbwtt8as_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    foreach(e; lst)\n    {\n        if(is_min)\n        {\n            result[i] = e;\n            i++;\n        }\n        else\n        {\n            result[j] = e;\n            j--;\n        }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpov9oqqai.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpov9oqqai.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    lst_copy.sort;\n    int i = 0;\n    int j = lst_copy.length - 1;\n    while (i < lst_copy.length) \n    {\n        result[i] = lst_copy[j];\n        i += 1;\n        if (i < lst_copy.length) \n        {\n            result[i] = lst_copy[i];\n            i += 1;\n        }\n        j -= 1;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp0u2nxm11.d(16): Error: no property `sort` for type `long[]`\n/tmp/tmp0u2nxm11.d(18): Error: cannot implicitly convert expression `lst_copy.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0u2nxm11.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool is_min = true;\n    foreach(i; 0 .. lst.length)\n    {\n        if(is_min)\n        {\n            result[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n        }\n        else\n        {\n            result[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n        }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmphkuuwd_8.d(21): Error: no property `min` for type `long[]`\n/tmp/tmphkuuwd_8.d(22): Error: no property `remove` for type `long[]`\n/tmp/tmphkuuwd_8.d(26): Error: no property `max` for type `long[]`\n/tmp/tmphkuuwd_8.d(27): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphkuuwd_8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool is_min = true;\n    long min_val = 0;\n    long max_val = 0;\n    long min_idx = 0;\n    long max_idx = 0;\n    long idx = 0;\n    while (lst_copy.length > 0)\n    {\n        if (is_min)\n        {\n            min_val = lst_copy[0];\n            min_idx = 0;\n            foreach (i, val; lst_copy)\n            {\n                if (val < min_val)\n                {\n                    min_val = val;\n                    min_idx = i;\n                }\n            }\n            result[idx] = min_val;\n            lst_copy = lst_copy[0..min_idx] ~ lst_copy[min_idx+1..$];\n            is_min = false;\n        }\n        else\n        {\n            max_val = lst_copy[0];\n            max_idx = 0;\n            foreach (i, val; lst_copy)\n            {\n                if (val > max_val)\n                {\n                    max_val = val;\n                    max_idx = i;\n                }\n            }\n            result[idx] = max_val;\n            lst_copy = lst_copy[0..max_idx] ~ lst_copy[max_idx+1..$];\n            is_min = true;\n        }\n        idx++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <= j) {\n        result[k++] = lst[i++];\n        if (i <= j) {\n            result[k++] = lst[j--];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpx0l3rbqk.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx0l3rbqk.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] ret = new long[lst.length];\n    int i = 0;\n    while (lst.length > 0) \n    {\n        ret[i] = lst[0];\n        lst = lst[1..$];\n        if (lst.length > 0) \n        {\n            ret[i] = lst[$-1];\n            lst = lst[0..$-1];\n        }\n        i++;\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpxgi99lvh.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x428915]\n??:? void tmpxgi99lvh.__unittest_L29_C1() [0x428042]\n??:? void tmpxgi99lvh.__modtest() [0x428698]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9f3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b886]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b11]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fc0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a9d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b85d]\n??:? runModuleUnitTests [0x42c7c9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428dd8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    while (i <= j) {\n        if (is_min) {\n            result[i] = lst[i];\n            i++;\n        } else {\n            result[j] = lst[j];\n            j--;\n        }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp6qfw2d3a.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6qfw2d3a.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    while (i <= j) {\n        if (is_min) {\n            res[i] = min(lst);\n            lst = remove(lst, min(lst));\n            i++;\n        } else {\n            res[j] = max(lst);\n            lst = remove(lst, max(lst));\n            j--;\n        }\n        is_min = !is_min;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp8lkabr8q.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\n/tmp/tmp8lkabr8q.d(20): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmp8lkabr8q.d(21): Error: undefined identifier `remove`\n/tmp/tmp8lkabr8q.d(24): Error: undefined identifier `max`, did you mean function `fmax`?\n/tmp/tmp8lkabr8q.d(25): Error: undefined identifier `remove`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8lkabr8q.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool is_min = true;\n    foreach(i; 0 .. lst.length)\n    {\n        if(is_min)\n        {\n            res[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n        }\n        else\n        {\n            res[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n        }\n        is_min = !is_min;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpm1l8mpjw.d(21): Error: no property `min` for type `long[]`\n/tmp/tmpm1l8mpjw.d(22): Error: no property `remove` for type `long[]`\n/tmp/tmpm1l8mpjw.d(26): Error: no property `max` for type `long[]`\n/tmp/tmpm1l8mpjw.d(27): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm1l8mpjw.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    while (i <= j) {\n        if (is_min) {\n            result[i] = lst[i];\n            i++;\n        } else {\n            result[j] = lst[j];\n            j--;\n        }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp6qfw2d3a.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6qfw2d3a.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] remaining = lst.dup;\n    int i = 0;\n    while (remaining.length > 0) \n    {\n        result[i] = remaining[0];\n        remaining = remaining[1..$];\n        if (remaining.length > 0) \n        {\n            result[i+1] = remaining[$-1];\n            remaining = remaining[0..$-2];\n        }\n        i += 2;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpi5rcq9zu.d(34): unittest failure\n----------------\n??:? _d_unittestp [0x429aa1]\n??:? void tmpi5rcq9zu.__unittest_L30_C1() [0x42824a]\n??:? void tmpi5rcq9zu.__modtest() [0x428a14]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e6df]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42972a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b469]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b4f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b3f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x429701]\n??:? runModuleUnitTests [0x42e4b5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429fb8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result;\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) \n    {\n        result ~= lst_copy[i];\n        result ~= lst_copy[j];\n        i++;\n        j--;\n    }\n    if (i == j) \n    {\n        result ~= lst_copy[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5a9nwy3v.d(17): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5a9nwy3v.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool is_min = true;\n    foreach(i; 0 .. lst.length)\n    {\n        if(is_min)\n        {\n            result[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n        }\n        else\n        {\n            result[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n        }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmphkuuwd_8.d(21): Error: no property `min` for type `long[]`\n/tmp/tmphkuuwd_8.d(22): Error: no property `remove` for type `long[]`\n/tmp/tmphkuuwd_8.d(26): Error: no property `max` for type `long[]`\n/tmp/tmphkuuwd_8.d(27): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphkuuwd_8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    while (lst_copy.length > 0) \n    {\n        result[i] = lst_copy.min;\n        lst_copy = lst_copy.remove(lst_copy.min);\n        if (lst_copy.length == 0) break;\n        result[i+1] = lst_copy.max;\n        lst_copy = lst_copy.remove(lst_copy.max);\n        i += 2;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpbdilqqjl.d(19): Error: no property `min` for type `long[]`\n/tmp/tmpbdilqqjl.d(20): Error: no property `remove` for type `long[]`\n/tmp/tmpbdilqqjl.d(22): Error: no property `max` for type `long[]`\n/tmp/tmpbdilqqjl.d(23): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbdilqqjl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n    int i = 0;\n    int j = sorted.length - 1;\n    foreach(e; lst)\n    {\n        if (e == sorted[i])\n        {\n            result[i] = e;\n            i++;\n        }\n        else\n        {\n            result[j] = e;\n            j--;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpev9_4z06.d(15): Error: no property `sort` for type `long[]`\n/tmp/tmpev9_4z06.d(17): Error: cannot implicitly convert expression `sorted.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpev9_4z06.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    while(lst_copy.length > 0)\n    {\n        result[i] = lst_copy.min;\n        lst_copy.remove(lst_copy.min);\n        if(lst_copy.length > 0)\n        {\n            result[i+1] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n        }\n        i += 2;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjyb5233f.d(19): Error: no property `min` for type `long[]`\n/tmp/tmpjyb5233f.d(20): Error: no property `remove` for type `long[]`\n/tmp/tmpjyb5233f.d(23): Error: no property `max` for type `long[]`\n/tmp/tmpjyb5233f.d(24): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjyb5233f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool ascending = true;\n    while (i <= j) {\n        if (ascending) {\n            result[i] = lst[i];\n            i++;\n        } else {\n            result[j] = lst[j];\n            j--;\n        }\n        ascending = !ascending;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprm55eewd.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprm55eewd.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    long[] lst_sorted = lst.dup.sort;\n    int i = 0;\n    while (lst_sorted.length > 0)\n    {\n        res[i] = lst_sorted[0];\n        lst_sorted = lst_sorted[1..$];\n        if (lst_sorted.length > 0)\n        {\n            res[i+1] = lst_sorted[$-1];\n            lst_sorted = lst_sorted[0..$-1];\n        }\n        i += 2;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpp6txcmub.d(15): Error: no property `sort` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp6txcmub.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <= j)\n    {\n        if (k % 2 == 0)\n        {\n            result[k] = lst[i];\n            i++;\n        }\n        else\n        {\n            result[k] = lst[j];\n            j--;\n        }\n        k++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpimzrdujr.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpimzrdujr.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    while (i <= j) {\n        if (is_min) {\n            res[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n            i++;\n        } else {\n            res[j] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n            j--;\n        }\n        is_min = !is_min;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp2pp7p6a8.d(17): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\n/tmp/tmp2pp7p6a8.d(21): Error: no property `min` for type `long[]`\n/tmp/tmp2pp7p6a8.d(22): Error: no property `remove` for type `long[]`\n/tmp/tmp2pp7p6a8.d(25): Error: no property `max` for type `long[]`\n/tmp/tmp2pp7p6a8.d(26): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2pp7p6a8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    auto minmax = minmaxElement(lst);\n    bool is_min = true;\n    int i = 0;\n    while (lst.length != 0)\n    {\n        if (is_min)\n        {\n            result[i] = minmax.min;\n            lst = lst.remove(minmax.min);\n        }\n        else\n        {\n            result[i] = minmax.max;\n            lst = lst.remove(minmax.max);\n        }\n        is_min = !is_min;\n        i++;\n        minmax = minmaxElement(lst);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpy59oftb6.d(15): Error: undefined identifier `minmaxElement`\n/tmp/tmpy59oftb6.d(23): Error: no property `remove` for type `long[]`\n/tmp/tmpy59oftb6.d(28): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy59oftb6.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] ret = new long[lst.length];\n    long[] tmp = lst.dup;\n    int i = 0;\n    while (tmp.length != 0) \n    {\n        ret[i] = tmp.min;\n        tmp = tmp.remove(tmp.min);\n        if (tmp.length != 0) \n        {\n            ret[i + 1] = tmp.max;\n            tmp = tmp.remove(tmp.max);\n        }\n        i += 2;\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpz5dj7oe3.d(19): Error: no property `min` for type `long[]`\n/tmp/tmpz5dj7oe3.d(20): Error: no property `remove` for type `long[]`\n/tmp/tmpz5dj7oe3.d(23): Error: no property `max` for type `long[]`\n/tmp/tmpz5dj7oe3.d(24): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz5dj7oe3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool asc = true;\n    int i = 0;\n    while(lst_copy.length > 0)\n    {\n        if(asc)\n        {\n            result[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n        }\n        else\n        {\n            result[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n        }\n        i++;\n        asc = !asc;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpnpiuczfm.d(22): Error: no property `min` for type `long[]`\n/tmp/tmpnpiuczfm.d(23): Error: no property `remove` for type `long[]`\n/tmp/tmpnpiuczfm.d(27): Error: no property `max` for type `long[]`\n/tmp/tmpnpiuczfm.d(28): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnpiuczfm.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] sorted = lst.dup;\n    sorted.sort;\n    long[] result = new long[sorted.length];\n    int i = 0;\n    int j = sorted.length - 1;\n    foreach(e; sorted)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = sorted[j];\n            j--;\n        }\n        else\n        {\n            result[i] = sorted[j];\n            j++;\n        }\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpahvfpjai.d(15): Error: no property `sort` for type `long[]`\n/tmp/tmpahvfpjai.d(18): Error: cannot implicitly convert expression `sorted.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpahvfpjai.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    while (i <= j) {\n        if (is_min) {\n            result[i] = lst[i];\n            i++;\n        } else {\n            result[j] = lst[j];\n            j--;\n        }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp6qfw2d3a.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6qfw2d3a.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    auto min_max_lst = zip(lst.min, lst.max);\n    auto min_max_lst_sorted = min_max_lst.sort!((a, b) => a[0] > b[0]);\n    return min_max_lst_sorted.map!(a => a[1]).array;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp3yrdu9w2.d(14): Error: undefined identifier `zip`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3yrdu9w2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result;\n    if (lst.length == 0) \n    {\n        return lst;\n    }\n    else \n    {\n        long min = lst[0];\n        long max = lst[0];\n        foreach (i; lst) \n        {\n            if (i < min) \n            {\n                min = i;\n            }\n            if (i > max) \n            {\n                max = i;\n            }\n        }\n        result = [min];\n        long[] remaining = lst[1..$];\n        while (remaining.length > 0) \n        {\n            long next_max = remaining[0];\n            long next_max_index = 0;\n            foreach (i; remaining) \n            {\n                if (i > next_max) \n                {\n                    next_max = i;\n                    next_max_index = i;\n                }\n            }\n            result ~= next_max;\n            remaining = remaining[0..next_max_index] ~ remaining[next_max_index + 1..$];\n            if (remaining.length == 0) \n            {\n                break;\n            }\n            long next_min = remaining[0];\n            long next_min_index = 0;\n            foreach (i; remaining) \n            {\n                if (i < next_min) \n                {\n                    next_min = i;\n                    next_min_index = i;\n                }\n            }\n            result ~= next_min;\n            remaining = remaining[0..next_min_index] ~ remaining[next_min_index + 1..$];\n        }\n        return result;\n    }\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpolxv51ez.d(49): Range violation\n----------------\n??:? _d_arrayboundsp [0x428ca6]\n??:? long[] tmpolxv51ez.strange_sort_list(long[]) [0x4280a2]\n??:? void tmpolxv51ez.__unittest_L70_C1() [0x4282af]\n??:? void tmpolxv51ez.__modtest() [0x428978]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d7ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c63e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430f49]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4313f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ed5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c615]\n??:? runModuleUnitTests [0x42d581]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int fun",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool is_min = true;\n    foreach(i; 0 .. lst.length)\n    {\n        long min_max = is_min ? lst_copy.min : lst_copy.max;\n        res[i] = min_max;\n        lst_copy.remove(min_max);\n        is_min = !is_min;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpiw1hbje6.d(19): Error: no property `min` for type `long[]`\n/tmp/tmpiw1hbje6.d(19): Error: no property `max` for type `long[]`\n/tmp/tmpiw1hbje6.d(21): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiw1hbje6.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool asc = true;\n    int i = 0;\n    while(lst_copy.length > 0)\n    {\n        if(asc)\n        {\n            result[i] = lst_copy.min;\n            lst_copy = lst_copy.remove(lst_copy.min);\n        }\n        else\n        {\n            result[i] = lst_copy.max;\n            lst_copy = lst_copy.remove(lst_copy.max);\n        }\n        i++;\n        asc = !asc;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpajar2z1d.d(22): Error: no property `min` for type `long[]`\n/tmp/tmpajar2z1d.d(23): Error: no property `remove` for type `long[]`\n/tmp/tmpajar2z1d.d(27): Error: no property `max` for type `long[]`\n/tmp/tmpajar2z1d.d(28): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpajar2z1d.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    while (lst.length > 0) {\n        result[i] = lst[0];\n        lst = lst[1..$];\n        if (lst.length > 0) {\n            result[i] = lst[$-1];\n            lst = lst[0..$-1];\n        }\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmphnvhjlwu.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x428915]\n??:? void tmphnvhjlwu.__unittest_L27_C1() [0x428042]\n??:? void tmphnvhjlwu.__modtest() [0x428698]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9f3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b886]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b11]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fc0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a9d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b85d]\n??:? runModuleUnitTests [0x42c7c9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428dd8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <= j) {\n        result[k++] = sorted[i++];\n        if (i <= j) {\n            result[k++] = sorted[j--];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp32ffaq20.d(15): Error: no property `sort` for type `long[]`\n/tmp/tmp32ffaq20.d(17): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp32ffaq20.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n    int i = 0;\n    int j = sorted.length - 1;\n    int k = 0;\n    while (i <= j) {\n        result[k++] = sorted[i++];\n        if (i <= j) {\n            result[k++] = sorted[j--];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp3p260i7_.d(15): Error: no property `sort` for type `long[]`\n/tmp/tmp3p260i7_.d(17): Error: cannot implicitly convert expression `sorted.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3p260i7_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <= j)\n    {\n        result[k++] = lst[i++];\n        if (i <= j)\n            result[k++] = lst[j--];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5l2w_69o.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5l2w_69o.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    while (lst.length != 0)\n    {\n        res[i] = lst[0];\n        lst = lst[1..$];\n        if (lst.length == 0)\n            break;\n        res[i+1] = lst[$-1];\n        lst = lst[0..$-1];\n        i += 2;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp5rawaf4_.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x428925]\n??:? void tmp5rawaf4_.__unittest_L28_C1() [0x4282a3]\n??:? void tmp5rawaf4_.__modtest() [0x4286a4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca03]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b896]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b21]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430aad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b86d]\n??:? runModuleUnitTests [0x42c7d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428de8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n    bool is_min = true;\n    foreach(i, ref e; res)\n    {\n        if(is_min)\n        {\n            res[i] = sorted[0];\n            sorted = sorted[1..$];\n        }\n        else\n        {\n            res[i] = sorted[$-1];\n            sorted = sorted[0..$-1];\n        }\n        is_min = !is_min;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpsmd05_s0.d(15): Error: no property `sort` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsmd05_s0.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    while(lst_copy.length > 0)\n    {\n        result[i] = lst_copy.min;\n        lst_copy.remove(lst_copy.min);\n        i++;\n        if(lst_copy.length > 0)\n        {\n            result[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n            i++;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpcjr656m5.d(19): Error: no property `min` for type `long[]`\n/tmp/tmpcjr656m5.d(20): Error: no property `remove` for type `long[]`\n/tmp/tmpcjr656m5.d(24): Error: no property `max` for type `long[]`\n/tmp/tmpcjr656m5.d(25): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcjr656m5.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n    int i = 0;\n    int j = sorted.length - 1;\n    foreach(x; sorted)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = sorted[j];\n            j--;\n        }\n        else\n        {\n            result[i] = sorted[j];\n            j++;\n        }\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpeqni7n_l.d(15): Error: no property `sort` for type `long[]`\n/tmp/tmpeqni7n_l.d(17): Error: cannot implicitly convert expression `sorted.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeqni7n_l.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    long[] lst_sorted = lst.dup.sort;\n    bool asc = true;\n    int i = 0;\n    while (lst_sorted.length > 0)\n    {\n        if (asc)\n        {\n            res[i] = lst_sorted[0];\n            lst_sorted = lst_sorted[1..$];\n        }\n        else\n        {\n            res[i] = lst_sorted[$-1];\n            lst_sorted = lst_sorted[0..$-1];\n        }\n        i++;\n        asc = !asc;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp3k_f4m6_.d(15): Error: no property `sort` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3k_f4m6_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    long[] lst_sorted = lst.dup.sort();\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <= j) \n    {\n        res[k++] = lst_sorted[i++];\n        if (i <= j) \n        {\n            res[k++] = lst_sorted[j--];\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp04cpplwr.d(15): Error: no property `sort` for type `long[]`\n/tmp/tmp04cpplwr.d(17): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp04cpplwr.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    while (lst_copy.length > 0)\n    {\n        res[i] = lst_copy[0];\n        lst_copy = lst_copy[1..$];\n        if (lst_copy.length > 0)\n        {\n            res[i+1] = lst_copy[$-1];\n            lst_copy = lst_copy[0..$-1];\n        }\n        i += 2;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp_t5t1si7.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x429aa1]\n??:? void tmp_t5t1si7.__unittest_L30_C1() [0x42849f]\n??:? void tmp_t5t1si7.__modtest() [0x428a14]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e6df]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42972a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b469]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b4f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b3f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x429701]\n??:? runModuleUnitTests [0x42e4b5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429fb8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool is_min = true;\n    foreach(i; 0 .. lst.length)\n    {\n        if(is_min)\n        {\n            result[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n        }\n        else\n        {\n            result[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n        }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmphkuuwd_8.d(21): Error: no property `min` for type `long[]`\n/tmp/tmphkuuwd_8.d(22): Error: no property `remove` for type `long[]`\n/tmp/tmphkuuwd_8.d(26): Error: no property `max` for type `long[]`\n/tmp/tmphkuuwd_8.d(27): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphkuuwd_8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    while(lst_copy.length > 0)\n    {\n        result[i] = lst_copy.min;\n        lst_copy = lst_copy.remove(lst_copy.min);\n        if(lst_copy.length > 0)\n        {\n            result[i+1] = lst_copy.max;\n            lst_copy = lst_copy.remove(lst_copy.max);\n        }\n        i += 2;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpxktn267k.d(19): Error: no property `min` for type `long[]`\n/tmp/tmpxktn267k.d(20): Error: no property `remove` for type `long[]`\n/tmp/tmpxktn267k.d(23): Error: no property `max` for type `long[]`\n/tmp/tmpxktn267k.d(24): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxktn267k.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    while (lst_copy.length > 0) \n    {\n        result[i] = lst_copy.min;\n        lst_copy = lst_copy.remove(lst_copy.min);\n        i++;\n        if (lst_copy.length > 0) \n        {\n            result[i] = lst_copy.max;\n            lst_copy = lst_copy.remove(lst_copy.max);\n            i++;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpaq_3lk7j.d(19): Error: no property `min` for type `long[]`\n/tmp/tmpaq_3lk7j.d(20): Error: no property `remove` for type `long[]`\n/tmp/tmpaq_3lk7j.d(24): Error: no property `max` for type `long[]`\n/tmp/tmpaq_3lk7j.d(25): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpaq_3lk7j.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] remaining = lst.dup;\n    bool ascending = true;\n    int i = 0;\n    while (remaining.length > 0) \n    {\n        if (ascending) \n        {\n            result[i] = remaining.min;\n            remaining.remove(remaining.min);\n        } \n        else \n        {\n            result[i] = remaining.max;\n            remaining.remove(remaining.max);\n        }\n        i++;\n        ascending = !ascending;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpds2_by4s.d(22): Error: no property `min` for type `long[]`\n/tmp/tmpds2_by4s.d(23): Error: no property `remove` for type `long[]`\n/tmp/tmpds2_by4s.d(27): Error: no property `max` for type `long[]`\n/tmp/tmpds2_by4s.d(28): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpds2_by4s.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    while (i <= j)\n    {\n        if (is_min)\n        {\n            result[i] = lst[i];\n            i++;\n        }\n        else\n        {\n            result[j] = lst[j];\n            j--;\n        }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp8j550_23.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8j550_23.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] temp = lst.dup;\n    temp.sort;\n    int i = 0;\n    int j = temp.length - 1;\n    bool flag = true;\n    foreach(e; temp)\n    {\n        if(flag)\n        {\n            result[i] = e;\n            i++;\n        }\n        else\n        {\n            result[j] = e;\n            j--;\n        }\n        flag = !flag;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpm76jpcgh.d(16): Error: no property `sort` for type `long[]`\n/tmp/tmpm76jpcgh.d(18): Error: cannot implicitly convert expression `temp.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm76jpcgh.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n    int i = 0;\n    int j = sorted.length - 1;\n    foreach(e; lst)\n    {\n        if(e == sorted[i])\n        {\n            res[i] = e;\n            i++;\n        }\n        else\n        {\n            res[j] = e;\n            j--;\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpky_lhm55.d(15): Error: no property `sort` for type `long[]`\n/tmp/tmpky_lhm55.d(17): Error: cannot implicitly convert expression `sorted.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpky_lhm55.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] ret = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    foreach(e; lst)\n    {\n        if(is_min)\n        {\n            ret[i] = e;\n            i++;\n        }\n        else\n        {\n            ret[j] = e;\n            j--;\n        }\n        is_min = !is_min;\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp04kep12n.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp04kep12n.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] temp = new long[lst.length];\n    temp = lst.dup;\n    temp.sort;\n    bool flag = true;\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < lst.length)\n    {\n        if (flag)\n        {\n            result[i] = temp[i];\n            i++;\n        }\n        else\n        {\n            result[i] = temp[j];\n            j--;\n        }\n        flag = !flag;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5pa72mr4.d(17): Error: no property `sort` for type `long[]`\n/tmp/tmp5pa72mr4.d(20): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5pa72mr4.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool asc = true;\n    foreach(e; lst)\n    {\n        if(asc)\n        {\n            result[i] = e;\n            i++;\n        }\n        else\n        {\n            result[j] = e;\n            j--;\n        }\n        asc = !asc;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpuvt67387.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuvt67387.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] remaining = lst.dup;\n    bool ascending = true;\n    foreach(i; 0 .. lst.length)\n    {\n        if(ascending)\n        {\n            result[i] = remaining.min;\n            remaining.remove(remaining.min);\n        }\n        else\n        {\n            result[i] = remaining.max;\n            remaining.remove(remaining.max);\n        }\n        ascending = !ascending;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpp2k6_rbs.d(21): Error: no property `min` for type `long[]`\n/tmp/tmpp2k6_rbs.d(22): Error: no property `remove` for type `long[]`\n/tmp/tmpp2k6_rbs.d(26): Error: no property `max` for type `long[]`\n/tmp/tmpp2k6_rbs.d(27): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp2k6_rbs.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool ascending = true;\n    while (i <= j)\n    {\n        if (ascending)\n        {\n            result[i] = lst[i];\n            i++;\n        }\n        else\n        {\n            result[j] = lst[j];\n            j--;\n        }\n        ascending = !ascending;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpivoan3n4.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n    bool is_min = true;\n    foreach(i, ref e; sorted)\n    {\n        if(is_min)\n        {\n            result[i] = e;\n            is_min = false;\n        }\n        else\n        {\n            result[result.length - i - 1] = e;\n            is_min = true;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpqv_n64x8.d(15): Error: no property `sort` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqv_n64x8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool is_min = true;\n    int i = 0;\n    while (lst_copy.length > 0)\n    {\n        if (is_min)\n        {\n            result[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n        }\n        else\n        {\n            result[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n        }\n        is_min = !is_min;\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpy6acx31f.d(22): Error: no property `min` for type `long[]`\n/tmp/tmpy6acx31f.d(23): Error: no property `remove` for type `long[]`\n/tmp/tmpy6acx31f.d(27): Error: no property `max` for type `long[]`\n/tmp/tmpy6acx31f.d(28): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy6acx31f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] temp = lst.dup;\n    temp.sort;\n    int i = 0;\n    int j = temp.length - 1;\n    foreach(e; temp)\n    {\n        if(i <= j)\n        {\n            result[i] = temp[i];\n            i++;\n        }\n        if(i <= j)\n        {\n            result[j] = temp[j];\n            j--;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_m1y6zs3.d(16): Error: no property `sort` for type `long[]`\n/tmp/tmp_m1y6zs3.d(18): Error: cannot implicitly convert expression `temp.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_m1y6zs3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <= j) \n    {\n        result[k++] = sorted[i++];\n        if (i <= j) \n        {\n            result[k++] = sorted[j--];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpyz6sd1sx.d(15): Error: no property `sort` for type `long[]`\n/tmp/tmpyz6sd1sx.d(17): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyz6sd1sx.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <= j)\n    {\n        res[k++] = lst[i++];\n        if (i <= j)\n            res[k++] = lst[j--];\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpa8kqw5ii.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa8kqw5ii.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    while (lst_copy.length > 0) \n    {\n        res[i] = lst_copy[0];\n        lst_copy = lst_copy[1..$];\n        if (lst_copy.length > 0) \n        {\n            res[i+1] = lst_copy[$-1];\n            lst_copy = lst_copy[0..$-2];\n        }\n        i += 2;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp1sdepnhs.d(34): unittest failure\n----------------\n??:? _d_unittestp [0x429aa1]\n??:? void tmp1sdepnhs.__unittest_L30_C1() [0x42824a]\n??:? void tmp1sdepnhs.__modtest() [0x428a14]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e6df]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42972a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b469]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b4f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b3f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x429701]\n??:? runModuleUnitTests [0x42e4b5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429fb8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] tmp = lst.dup;\n    int i = 0;\n    while (tmp.length > 0) {\n        result[i] = tmp.min;\n        tmp = tmp.remove(tmp.min);\n        if (tmp.length > 0) {\n            result[i + 1] = tmp.max;\n            tmp = tmp.remove(tmp.max);\n        }\n        i += 2;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpqiw06h76.d(18): Error: no property `min` for type `long[]`\n/tmp/tmpqiw06h76.d(19): Error: no property `remove` for type `long[]`\n/tmp/tmpqiw06h76.d(21): Error: no property `max` for type `long[]`\n/tmp/tmpqiw06h76.d(22): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqiw06h76.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    bool asc = true;\n    while (k < lst.length) {\n        if (asc) {\n            res[k] = lst[i];\n            ++i;\n        } else {\n            res[k] = lst[j];\n            --j;\n        }\n        asc = !asc;\n        ++k;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp7o0v6mkr.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7o0v6mkr.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    bool asc = true;\n    while (k < lst.length) \n    {\n        if (asc) \n        {\n            res[k] = lst[i];\n            i++;\n        } \n        else \n        {\n            res[k] = lst[j];\n            j--;\n        }\n        asc = !asc;\n        k++;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmped13qliu.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmped13qliu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool is_max = true;\n    for (int i = 0; i < lst.length; i++)\n    {\n        long max_val = lst_copy[0];\n        long min_val = lst_copy[0];\n        int max_idx = 0;\n        int min_idx = 0;\n        for (int j = 0; j < lst_copy.length; j++)\n        {\n            if (lst_copy[j] > max_val)\n            {\n                max_val = lst_copy[j];\n                max_idx = j;\n            }\n            if (lst_copy[j] < min_val)\n            {\n                min_val = lst_copy[j];\n                min_idx = j;\n            }\n        }\n        if (is_max)\n        {\n            res[i] = max_val;\n            lst_copy[max_idx] = -1;\n        }\n        else\n        {\n            res[i] = min_val;\n            lst_copy[min_idx] = -1;\n        }\n        is_max = !is_max;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp1xm0tofa.d(54): unittest failure\n----------------\n??:? _d_unittestp [0x429b81]\n??:? void tmp1xm0tofa.__unittest_L50_C1() [0x42832e]\n??:? void tmp1xm0tofa.__modtest() [0x428af8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e7bf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42980a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b549]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b5d8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b4d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x4297e1]\n??:? runModuleUnitTests [0x42e595]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x42a098]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool asc = true;\n    while (i <= j)\n    {\n        if (asc)\n        {\n            res[i] = lst[i];\n            i++;\n        }\n        else\n        {\n            res[j] = lst[j];\n            j--;\n        }\n        asc = !asc;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpm7gx5pe_.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm7gx5pe_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool asc = true;\n    while (i <= j) {\n        if (asc) {\n            result[i] = lst[i];\n            i++;\n        } else {\n            result[j] = lst[j];\n            j--;\n        }\n        asc = !asc;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmph_ppw4hf.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph_ppw4hf.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    bool is_min = true;\n    while (i <= j)\n    {\n        if (is_min)\n        {\n            result[k] = min(lst[i], lst[j]);\n            if (lst[i] == result[k])\n                i++;\n            else\n                j--;\n        }\n        else\n        {\n            result[k] = max(lst[i], lst[j]);\n            if (lst[i] == result[k])\n                i++;\n            else\n                j--;\n        }\n        is_min = !is_min;\n        k++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpq8w5efkh.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\n/tmp/tmpq8w5efkh.d(23): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmpq8w5efkh.d(31): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq8w5efkh.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool is_min = true;\n    foreach(i; 0 .. lst.length)\n    {\n        if(is_min)\n        {\n            result[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n        }\n        else\n        {\n            result[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n        }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmphkuuwd_8.d(21): Error: no property `min` for type `long[]`\n/tmp/tmphkuuwd_8.d(22): Error: no property `remove` for type `long[]`\n/tmp/tmphkuuwd_8.d(26): Error: no property `max` for type `long[]`\n/tmp/tmphkuuwd_8.d(27): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphkuuwd_8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    while (lst_copy.length > 0) \n    {\n        res[i] = lst_copy.min;\n        lst_copy = lst_copy.remove(lst_copy.min);\n        if (lst_copy.length > 0) \n        {\n            res[i] = lst_copy.max;\n            lst_copy = lst_copy.remove(lst_copy.max);\n        }\n        i++;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpc6a6n_ye.d(19): Error: no property `min` for type `long[]`\n/tmp/tmpc6a6n_ye.d(20): Error: no property `remove` for type `long[]`\n/tmp/tmpc6a6n_ye.d(23): Error: no property `max` for type `long[]`\n/tmp/tmpc6a6n_ye.d(24): Error: no property `remove` for type `long[]`\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    foreach(e; lst)\n    {\n        if(is_min)\n        {\n            result[i] = e;\n            i++;\n        }\n        else\n        {\n            result[j] = e;\n            j--;\n        }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpov9oqqai.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpov9oqqai.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <= j) \n    {\n        result[k++] = sorted[i++];\n        if (i <= j) \n        {\n            result[k++] = sorted[j--];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpyz6sd1sx.d(15): Error: no property `sort` for type `long[]`\n/tmp/tmpyz6sd1sx.d(17): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyz6sd1sx.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    long[] lst_sorted = lst.dup.sort;\n    int i = 0;\n    int j = lst.length - 1;\n    foreach(e; lst)\n    {\n        if(i % 2 == 0)\n        {\n            res[i] = lst_sorted[j];\n            j--;\n        }\n        else\n        {\n            res[i] = lst_sorted[0];\n            lst_sorted = lst_sorted[1..$];\n        }\n        i++;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpghq84_61.d(15): Error: no property `sort` for type `long[]`\n/tmp/tmpghq84_61.d(17): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpghq84_61.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <= j) \n    {\n        if (k % 2 == 0) \n        {\n            res[k] = min(lst[i], lst[j]);\n            if (lst[i] < lst[j]) \n            {\n                i++;\n            } \n            else \n            {\n                j--;\n            }\n        } \n        else \n        {\n            res[k] = max(lst[i], lst[j]);\n            if (lst[i] > lst[j]) \n            {\n                i++;\n            } \n            else \n            {\n                j--;\n            }\n        }\n        k++;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpbeg3a3d9.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\n/tmp/tmpbeg3a3d9.d(22): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmpbeg3a3d9.d(34): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbeg3a3d9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    long[] lst_sorted = lst.dup.sort;\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <= j)\n    {\n        res[k++] = lst_sorted[i++];\n        if (i <= j)\n            res[k++] = lst_sorted[j--];\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpffd4h6wq.d(15): Error: no property `sort` for type `long[]`\n/tmp/tmpffd4h6wq.d(17): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    while(lst_copy.length > 0)\n    {\n        result[i] = lst_copy.min;\n        lst_copy.remove(lst_copy.min);\n        i++;\n        if(lst_copy.length > 0)\n        {\n            result[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n            i++;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpcjr656m5.d(19): Error: no property `min` for type `long[]`\n/tmp/tmpcjr656m5.d(20): Error: no property `remove` for type `long[]`\n/tmp/tmpcjr656m5.d(24): Error: no property `max` for type `long[]`\n/tmp/tmpcjr656m5.d(25): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcjr656m5.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    foreach(e; lst)\n    {\n        if(is_min)\n        {\n            result[i] = e;\n            i++;\n        }\n        else\n        {\n            result[j] = e;\n            j--;\n        }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpov9oqqai.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpov9oqqai.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    while (i <= j)\n    {\n        if (is_min)\n        {\n            result[i] = min(lst);\n            lst = remove(lst, min(lst));\n            i++;\n        }\n        else\n        {\n            result[j] = max(lst);\n            lst = remove(lst, max(lst));\n            j--;\n        }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpzrcjzdi1.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\n/tmp/tmpzrcjzdi1.d(22): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmpzrcjzdi1.d(23): Error: undefined identifier `remove`\n/tmp/tmpzrcjzdi1.d(28): Error: undefined identifier `max`, did you mean function `fmax`?\n/tmp/tmpzrcjzdi1.d(29): Error: undefined identifier `remove`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzrcjzdi1.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] remaining = lst.dup;\n    bool even = true;\n    foreach(i; 0 .. lst.length) {\n        if (even) {\n            result[i] = remaining.min;\n        } else {\n            result[i] = remaining.max;\n        }\n        remaining.remove(result[i]);\n        even = !even;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpuz52vln_.d(19): Error: no property `min` for type `long[]`\n/tmp/tmpuz52vln_.d(21): Error: no property `max` for type `long[]`\n/tmp/tmpuz52vln_.d(23): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuz52vln_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] ret = new long[lst.length];\n    long[] tmp = lst.dup;\n    tmp.sort();\n    int i = 0;\n    while (tmp.length > 0) {\n        ret[i] = tmp[0];\n        tmp = tmp[1..$];\n        if (tmp.length > 0) {\n            ret[i+1] = tmp[$-1];\n            tmp = tmp[0..$-1];\n        }\n        i += 2;\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpeyuy139m.d(16): Error: no property `sort` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeyuy139m.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    long[] sorted = lst.dup.sort();\n    bool asc = true;\n    long i = 0;\n    long j = 0;\n    while (i < lst.length)\n    {\n        if (asc)\n        {\n            res[i] = sorted[j];\n            j++;\n        }\n        else\n        {\n            res[i] = sorted[sorted.length - j - 1];\n        }\n        i++;\n        asc = !asc;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4ty9jtq1.d(15): Error: no property `sort` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4ty9jtq1.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n    int i = 0;\n    int j = sorted.length - 1;\n    int k = 0;\n    while (i <= j)\n    {\n        result[k++] = sorted[i++];\n        if (i <= j)\n            result[k++] = sorted[j--];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpnesbm38e.d(15): Error: no property `sort` for type `long[]`\n/tmp/tmpnesbm38e.d(17): Error: cannot implicitly convert expression `sorted.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnesbm38e.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result;\n    long[] temp;\n    long min;\n    long max;\n    long i;\n    long j;\n    long k;\n    long l;\n    long m;\n    long n;\n    long o;\n    long p;\n    long q;\n    long r;\n    long s;\n    long t;\n    long u;\n    long v;\n    long w;\n    long x;\n    long y;\n    long z;\n    long aa;\n    long ab;\n    long ac;\n    long ad;\n    long ae;\n    long af;\n    long ag;\n    long ah;\n    long ai;\n    long aj;\n    long ak;\n    long al;\n    long am;\n    long an;\n    long ao;\n    long ap;\n    long aq;\n    long ar;\n    long as;\n    long at;\n    long au;\n    long av;\n    long aw;\n    long ax;\n    long ay;\n    long az;\n    long ba;\n    long bb;\n    long bc;\n    long bd;\n    long be;\n    long bf;\n    long bg;\n    long bh;\n    long bi;\n    long bj;\n    long bk;\n    long bl;\n    long bm;\n    long bn;\n    long bo;\n    long bp;\n    long bq;\n    long br;\n    long bs;\n    long bt;\n    long bu;\n    long bv;\n    long bw;\n    long bx;\n    long by;\n    long bz;\n    long ca;\n    long cb;\n    long cc;\n    long cd;\n    long ce;\n    long cf;\n    long cg;\n    long ch;\n    long ci;\n    long cj;\n    long ck;\n    long cl;\n    long cm;\n    long cn;\n    long co;\n    long cp;\n    long cq;\n    long cr;\n    long cs;\n    long ct;\n    long cu;\n   \nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpi1o5cg4u.d(110): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi1o5cg4u.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool ascending = true;\n    foreach(e; lst)\n    {\n        if(ascending)\n        {\n            result[i] = e;\n            i++;\n        }\n        else\n        {\n            result[j] = e;\n            j--;\n        }\n        ascending = !ascending;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpcwxcake3.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcwxcake3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n    int i = 0;\n    int j = sorted.length - 1;\n    foreach(e; lst) {\n        if (e == sorted[i]) {\n            result[i] = e;\n            i++;\n        } else {\n            result[j] = e;\n            j--;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpbxsb7t7i.d(15): Error: no property `sort` for type `long[]`\n/tmp/tmpbxsb7t7i.d(17): Error: cannot implicitly convert expression `sorted.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbxsb7t7i.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result;\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    while (i <= j) {\n        if (is_min) {\n            result ~= lst[i];\n            i++;\n        } else {\n            result ~= lst[j];\n            j--;\n        }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp9uzhhbec.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9uzhhbec.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result;\n    long[] sorted_lst = lst.dup;\n    sorted_lst.sort;\n    result = [];\n    bool is_min = true;\n    foreach(elem; sorted_lst)\n    {\n        if(is_min)\n        {\n            result ~= elem;\n            is_min = false;\n        }\n        else\n        {\n            result.insert(0, elem);\n            is_min = true;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5bk0arab.d(16): Error: no property `sort` for type `long[]`\n/tmp/tmp5bk0arab.d(28): Error: no property `insert` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5bk0arab.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool asc = true;\n    foreach(e; lst)\n    {\n        if(asc)\n        {\n            res[i] = e;\n            i++;\n        }\n        else\n        {\n            res[j] = e;\n            j--;\n        }\n        asc = !asc;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpw7y6y7ge.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw7y6y7ge.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    while (lst_copy.length > 0) {\n        res[i] = lst_copy[0];\n        lst_copy = lst_copy[1..$];\n        if (lst_copy.length > 0) {\n            res[i] = lst_copy[$-1];\n            lst_copy = lst_copy[0..$-1];\n        }\n        i += 1;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnbmwjxyb.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x429a99]\n??:? void tmpnbmwjxyb.__unittest_L28_C1() [0x428242]\n??:? void tmpnbmwjxyb.__modtest() [0x428a0c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e6d7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x429722]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b461]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b4f0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b3ed]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x4296f9]\n??:? runModuleUnitTests [0x42e4ad]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429fb0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164215
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    while (i <= j)\n    {\n        if (is_min)\n        {\n            res[i] = min(lst);\n            lst = remove(lst, min(lst));\n            i++;\n        }\n        else\n        {\n            res[j] = max(lst);\n            lst = remove(lst, max(lst));\n            j--;\n        }\n        is_min = !is_min;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpj015eg_q.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\n/tmp/tmpj015eg_q.d(22): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmpj015eg_q.d(23): Error: undefined identifier `remove`\n/tmp/tmpj015eg_q.d(28): Error: undefined identifier `max`, did you mean function `fmax`?\n/tmp/tmpj015eg_q.d(29): Error: undefined identifier `remove`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj015eg_q.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool is_min = true;\n    size_t i = 0;\n    while (lst_copy.length > 0)\n    {\n        if (is_min)\n        {\n            result[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n        }\n        else\n        {\n            result[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n        }\n        is_min = !is_min;\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpwxsb625_.d(22): Error: no property `min` for type `long[]`\n/tmp/tmpwxsb625_.d(23): Error: no property `remove` for type `long[]`\n/tmp/tmpwxsb625_.d(27): Error: no property `max` for type `long[]`\n/tmp/tmpwxsb625_.d(28): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwxsb625_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res;\n    long[] temp;\n    long min;\n    long max;\n    long min_index;\n    long max_index;\n    long i;\n    long j;\n    long k;\n    long l;\n    bool is_min;\n    bool is_max;\n    bool is_odd;\n    bool is_even;\n    bool is_first;\n    bool is_last;\n    bool is_first_even;\n    bool is_first_odd;\n    bool is_last_even;\n    bool is_last_odd;\n    bool is_even_index;\n    bool is_odd_index;\n    bool is_even_index_first;\n    bool is_odd_index_first;\n    bool is_even_index_last;\n    bool is_odd_index_last;\n    bool is_even_index_first_even;\n    bool is_even_index_first_odd;\n    bool is_even_index_last_even;\n    bool is_even_index_last_odd;\n    bool is_odd_index_first_even;\n    bool is_odd_index_first_odd;\n    bool is_odd_index_last_even;\n    bool is_odd_index_last_odd;\n    bool is_even_index_first_even_even;\n    bool is_even_index_first_even_odd;\n    bool is_even_index_first_odd_even;\n    bool is_even_index_first_odd_odd;\n    bool is_even_index_last_even_even;\n    bool is_even_index_last_even_odd;\n    bool is_even_index_last_odd_even;\n    bool is_even_index_last_odd_odd;\n    bool is_odd_index_first_even_even;\n    bool is_odd_index_first_even_odd;\n    bool is_odd_index_first_odd_even;\n    bool is_odd_index_first_odd_odd;\n    bool is_odd_index_last_even_even;\n    bool is_odd_index_last_even_odd;\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpu7hjz6_y.d(62): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu7hjz6_y.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result;\n    long[] sorted_lst = lst.dup;\n    sorted_lst.sort;\n    bool is_max = true;\n    foreach(elem; sorted_lst)\n    {\n        if(is_max)\n        {\n            result ~= elem;\n            is_max = false;\n        }\n        else\n        {\n            result.insert(0, elem);\n            is_max = true;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpp1yfzpvk.d(16): Error: no property `sort` for type `long[]`\n/tmp/tmpp1yfzpvk.d(27): Error: no property `insert` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp1yfzpvk.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    while (i <= j)\n    {\n        if (is_min)\n        {\n            res[i] = lst[i];\n            i++;\n        }\n        else\n        {\n            res[j] = lst[j];\n            j--;\n        }\n        is_min = !is_min;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpeze426n1.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeze426n1.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    while (lst.length > 0) {\n        result[i] = lst[0];\n        lst = lst[1..$];\n        if (lst.length > 0) {\n            auto max = maxElement(lst);\n            result[i+1] = max;\n            lst = lst[0..max] ~ lst[max+1..$];\n        }\n        i += 2;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmporacgor4.d(20): Error: undefined identifier `maxElement`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmporacgor4.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result;\n    long[] sorted_lst = lst.dup;\n    sorted_lst.sort;\n    result.length = lst.length;\n    bool is_min = true;\n    int i = 0;\n    int j = 0;\n    while (i < lst.length)\n    {\n        if (is_min)\n        {\n            result[i] = sorted_lst[j];\n            j++;\n        }\n        else\n        {\n            result[i] = sorted_lst[sorted_lst.length - j - 1];\n        }\n        is_min = !is_min;\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpdpzwtej8.d(16): Error: no property `sort` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdpzwtej8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result;\n    auto minmax = minmaxElement(lst);\n    auto min = minmax.min;\n    auto max = minmax.max;\n    bool is_min = true;\n    while(lst.length > 0)\n    {\n        if(is_min)\n        {\n            result ~= min;\n            lst = lst.filter!(x => x != min);\n            is_min = false;\n        }\n        else\n        {\n            result ~= max;\n            lst = lst.filter!(x => x != max);\n            is_min = true;\n        }\n        minmax = minmaxElement(lst);\n        min = minmax.min;\n        max = minmax.max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpp5thu_oq.d(15): Error: undefined identifier `minmaxElement`\n/tmp/tmpp5thu_oq.d(24): Error: no property `filter` for type `long[]`\n/tmp/tmpp5thu_oq.d(30): Error: no property `filter` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp5thu_oq.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    foreach(e; lst)\n    {\n        if(is_min)\n        {\n            result[i] = e;\n            i++;\n        }\n        else\n        {\n            result[j] = e;\n            j--;\n        }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpov9oqqai.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpov9oqqai.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool is_min = true;\n    int i = 0;\n    while (lst_copy.length > 0)\n    {\n        if (is_min)\n        {\n            result[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n        }\n        else\n        {\n            result[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n        }\n        is_min = !is_min;\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpy6acx31f.d(22): Error: no property `min` for type `long[]`\n/tmp/tmpy6acx31f.d(23): Error: no property `remove` for type `long[]`\n/tmp/tmpy6acx31f.d(27): Error: no property `max` for type `long[]`\n/tmp/tmpy6acx31f.d(28): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy6acx31f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    foreach(e; lst)\n    {\n        if(is_min)\n        {\n            res[i] = e;\n            i++;\n        }\n        else\n        {\n            res[j] = e;\n            j--;\n        }\n        is_min = !is_min;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp0p1_arve.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0p1_arve.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n    bool asc = true;\n    foreach(i, ref e; result)\n    {\n        if (asc)\n        {\n            e = sorted[0];\n            sorted = sorted[1..$];\n        }\n        else\n        {\n            e = sorted[$-1];\n            sorted = sorted[0..$-1];\n        }\n        asc = !asc;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpymjgcklp.d(15): Error: no property `sort` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpymjgcklp.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0) return lst;\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool inc = true;\n    while (i <= j) {\n        if (inc) {\n            res[i] = lst[i];\n            i++;\n        } else {\n            res[j] = lst[i];\n            j--;\n        }\n        inc = !inc;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpxpo8oz56.d(17): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxpo8oz56.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164215
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    sort(lst);\n    foreach(e; lst)\n    {\n        if(is_min)\n        {\n            res[i] = e;\n            i++;\n        }\n        else\n        {\n            res[j] = e;\n            j--;\n        }\n        is_min = !is_min;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpf51l_gq0.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\n/tmp/tmpf51l_gq0.d(18): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf51l_gq0.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164215
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    while (lst.length != 0)\n    {\n        res[i] = lst[0];\n        lst = lst[1..$];\n        if (lst.length == 0)\n            break;\n        res[i+1] = lst[$-1];\n        lst = lst[0..$-1];\n        i += 2;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp5rawaf4_.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x428925]\n??:? void tmp5rawaf4_.__unittest_L28_C1() [0x4282a3]\n??:? void tmp5rawaf4_.__modtest() [0x4286a4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca03]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b896]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b21]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430aad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b86d]\n??:? runModuleUnitTests [0x42c7d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428de8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    while (lst_copy.length > 0) \n    {\n        result[i] = lst_copy.min;\n        lst_copy.remove(result[i]);\n        i++;\n        if (lst_copy.length > 0) \n        {\n            result[i] = lst_copy.max;\n            lst_copy.remove(result[i]);\n            i++;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpqhuz7x0p.d(19): Error: no property `min` for type `long[]`\n/tmp/tmpqhuz7x0p.d(20): Error: no property `remove` for type `long[]`\n/tmp/tmpqhuz7x0p.d(24): Error: no property `max` for type `long[]`\n/tmp/tmpqhuz7x0p.d(25): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqhuz7x0p.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164215
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool min = true;\n    while (i <= j) {\n        if (min) {\n            res[i] = lst[i];\n            i++;\n        } else {\n            res[j] = lst[j];\n            j--;\n        }\n        min = !min;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpj9xp28e0.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj9xp28e0.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    while (i <= j) {\n        if (is_min) {\n            result[i] = lst[i];\n            i++;\n        } else {\n            result[j] = lst[j];\n            j--;\n        }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp6qfw2d3a.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6qfw2d3a.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164213
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    while (lst_copy.length > 0)\n    {\n        result[i] = lst_copy.min;\n        lst_copy = lst_copy.remove(result[i]);\n        i++;\n        if (lst_copy.length > 0)\n        {\n            result[i] = lst_copy.max;\n            lst_copy = lst_copy.remove(result[i]);\n            i++;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppn6_ota6.d(19): Error: no property `min` for type `long[]`\n/tmp/tmppn6_ota6.d(20): Error: no property `remove` for type `long[]`\n/tmp/tmppn6_ota6.d(24): Error: no property `max` for type `long[]`\n/tmp/tmppn6_ota6.d(25): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppn6_ota6.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164215
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    int index = 0;\n    bool is_min = true;\n    while (lst_copy.length > 0) {\n        if (is_min) {\n            result[index] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n        } else {\n            result[index] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n        }\n        index++;\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpro7u4d35.d(20): Error: no property `min` for type `long[]`\n/tmp/tmpro7u4d35.d(21): Error: no property `remove` for type `long[]`\n/tmp/tmpro7u4d35.d(23): Error: no property `max` for type `long[]`\n/tmp/tmpro7u4d35.d(24): Error: no property `remove` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpro7u4d35.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164214
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    foreach(long val; lst)\n    {\n        if(is_min)\n        {\n            result[i] = val;\n            i++;\n        }\n        else\n        {\n            result[j] = val;\n            j--;\n        }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp7nd87j83.d(16): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7nd87j83.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164215
    }
  ]
}