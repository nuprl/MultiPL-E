name: HumanEval_104_unique_digits
language: sh
prompt: "#!/bin/bash\n# Given a list of positive integers x. return a sorted list\
  \ of all \n# elements that hasn't any even digit.\n# Note: Returned list should\
  \ be sorted in increasing order.\n# For example:\n# >>> unique_digits([15, 33, 1422,\
  \ 1])\n# [1, 15, 33]\n# >>> unique_digits([152, 323, 1422, 10])\n# []\n#\n# $1 is\
  \ a space-separated list\nunique_digits() {\n"
tests: "}\n\ncandidate() {\n    unique_digits \"$@\"\n}\n\nset -e\nrun_test() {\n\
  \    [[ $(candidate \"15 33 1422 1\") = \"1 15 33\" ]]\n    [[ $(candidate \"152\
  \ 323 1422 10\") = \"\" ]]\n    [[ $(candidate \"12345 2033 111 151\") = \"111 151\"\
  \ ]]\n    [[ $(candidate \"135 103 31\") = \"31 135\" ]]\n}\n\nrun_test"
completions: ["  awk '{\n     split($1, a, \"[[:space:]]+\");\n     for(i in a) \n\
    \       if (a[i]%2 == 0) {\n         delete a[i];\n         print a[i]\" \";\n\
    \       }\n     }' $1", "    local number=$1\n    \n    local array=()\n    #\
    \ Loop through the list, one at a time, removing each digit one at a time\n  \
    \  for number in $@; do\n        local digit=\"${number//%/}\"\n        if [ \"\
    ${digit}\" = \"$digit\" ]; then\n            array+=($digit)\n        fi\n   \
    \ done\n    \n    # Sort array\n    IFS=$'\\n' read -a array <<< \"${array[*]}\"\
    \n    sort -u <<< \"${array[*]}\"", "    local x=\"$1\"\n    local output=\"\"\
    \n\n    for element in \"${x}\"; do\n        if [[ \"${element}\" =~ [0-9] ]];\
    \ then\n            if [[ \"${element}\" == *[0-9]* ]]; then\n               \
    \ output=\"${output} ${element}\"\n            fi\n        fi\n    done\n    echo\
    \ \"${output}\"", "    local digits=\"$1\"\n    local i=0 \n    local result=()\n\
    \    for d in \"${digits[@]}\"; do\n        (( i % 2 != 0 )) && result+=(\"$d\"\
    )\n        (( i++ ))\n    done\n    echo \"${result[@]}\" | sort -n", "  local\
    \ x=\"${1}\"\n  local output\n  output=\"$(echo \"${x}\" | awk '{print $1}' |\
    \ sort | uniq)\"\n  echo \"${output}\"", "   x=\"$1\"\n   x=\"${x// }\"\n   x=\"\
    ${x// /}\"\n   x=\"${x% }\"\n   x=\"${x// }\"\n   x=\"${x// /}\"\n   x=\"${x%\
    \ }\"\n   x=\"${x// }\"\n   x=\"${x// /}\"\n   x=\"${x% }\"\n   x=\"${x// }\"\n\
    \   x=\"${x// /}\"\n   x=\"${x% }\"\n   x=\"${x// }\"\n   x=\"${x// /}\"\n   x=\"\
    ${x% }\"\n   x=\"${x// }\"\n   x=\"${x// /}\"\n   x=\"${x% }\"\n   x=\"${x// }\"\
    \n   x=\"${x// /}\"\n   x=\"${x% }\"\n   x=\"${x// }\"\n   x=\"${x// /}\"\n  \
    \ x=\"${x% }\"\n   x=\"${x// }\"\n   x=\"${x// /}\"\n   x=\"${x% }\"\n   x=\"\
    ${x// }\"\n   x=\"${x// /}\"\n   x=\"${x% }\"\n   x=\"${x// }\"\n   x=\"${x//\
    \ /}\"\n   x=\"${x% }\"\n   x=\"${x// }\"\n   x=\"${x// /}\"\n   x=\"${x% }\"\n\
    \   x=\"${x// }\"\n   x=\"${x// /}\"\n   x=\"${x% }\"\n   x=\"${x// }\"\n   x=\"\
    ${x// /}\"\n   x=\"${x% }\"\n   x=\"${x// }\"\n   x=\"${x// /}\"\n   x=\"${x%\
    \ }\"\n   x=\"${x// }\"\n   x=\"${x// /}\"\n   x=\"${x% }\"\n   x=\"${x// }\"\n\
    \   x=\"${x// /}\"\n   x=\"${x% }\"\n   x=\"${x// }\"\n   x=\"${x// /}\"\n   x=\"\
    ${x% }\"\n   x=\"${x// }\"\n   x=\"${x// /}\"\n   x=\"${x% }\"\n   x=\"${x// }\"\
    \n   x=\"${x// /}\"\n   x=\"${x% }\"\n   x=\"${x// }\"\n   x=\"${x// /}\"\n  \
    \ x=\"${x% }\"\n   x=\"${x// }\"\n   x=\"${x// /}\"\n   x=\"${x% }\"\n   x=\"\
    ${x// }\"\n   x=\"${x// /}\"\n   x=\"${x% }\"\n   ", "  x=\"$1\"\n\n  for i in\
    \ $x; do\n     #echo \"$i\"\n     if [[ $i =~ ^[0-9]+$ ]]; then\n        (( i++\
    \ ))\n     fi\n  done\n  # echo \"$x\"\n\n  # echo $i\n  for i in $x; do\n   \
    \  # if [[ $i =~ ^[0-9]+$ ]]; then\n     if (( $i % 2 == 0 ))\n     then\n   \
    \     echo $i\n     fi\n  done", "    local a=$1\n    local n=$(($#a))\n    local\
    \ i j\n    \n    # find non-digit elements in $a\n    for((i = 0; i < $n; ++i));\
    \ do\n        j=$i\n        while [[ $(($j--)) ]]; do\n            [[ ${a:$j:1}\
    \ = . ]] && break\n        done\n        ((j--))\n        \n        ((i>0)) &&\
    \ j++\n        # remove non-digit elements from a\n        i=$((i-1))\n      \
    \  for ((j=$i; j <= $n; ++j)); do\n            [[ ${a:$j:1} = . ]] && break\n\
    \        done\n        # find non-digit elements a again\n        i=$((i+1))\n\
    \    done\n    \n    # return sorted unique elements\n    local l\n    for((i\
    \ = 0; i < $n; ++i)); do\n        [[ -z ${a[$i]} ]] && continue\n        l=${a[$i]}\n\
    \        \n        if [[ \"$l\" =~ ^0 ]]; then\n            continue\n       \
    \ fi\n        \n        for((j=$((i+1)); j <= $n; ++j)); do\n            [[ ${a[j]:0:1}\
    \ = . ]] && break\n        done\n        ((j--))\n        a[$i]=${a[$j]}\n   \
    \ done\n    \n    echo $a", "    local i x y\n\n    x=\"$1\"\n\n    for i in $(seq\
    \ 0 $(($#x - 1))); do\n      y=\"${x:$i:1}\"\n      if (( ($y%2) == 0 )); then\n\
    \        echo \"$y\"\n      fi\n    done", "    echo \"$1\" |grep -Ev '^ *$'|grep\
    \ -v '^ *$'|awk '{ print $1 }'|awk '{\n    seen[$1]++;\n    for (i=2;i<=NF;i++)\
    \ {\n        if (seen[$i]++ == 1) {\n            printf \"%s%s\",$i,i==NF ? \"\
    \\n\" : \",\"\n        }\n    }", "    x=(\"$@\")\n    printf \"%s\\n\" \"${x[@]}\"\
    \ | grep -o \"^[0-9]*$\" | sort -u | tr -d '\\n'", "    local x=\"$1\"\n    #\
    \ convert each of its element to string and store it in an array\n    local tmp\n\
    \    for x in ${x//,/ }; do\n        tmp=`echo \"$x\" | awk '{print $1; exit}'`\n\
    \        arr+=(\"$tmp\")\n    done\n    arr2=()\n    # find out how many unique\
    \ digits there are\n    len=${#arr[@]}\n    # sort and remove duplicates\n   \
    \ arr2=`sort -n \"${arr[@]}\"`\n    # loop through sorted array and remove duplicates\n\
    \    for x in ${arr2[@]}; do\n        found=false\n        for y in ${arr[@]};\
    \ do\n            if [ \"$x\" -eq \"$y\" ]; then\n                found=true\n\
    \                break\n            fi\n        done\n        if [ \"$found\"\
    \ == \"false\" ]; then\n            arr2+=(\"$x\")\n        fi\n    done\n   \
    \ echo \"${arr2[@]}\"", "\tlocal i len $1 prev cur tmp out \n\tlen=$#\n\tout=$1\n\
    \tfor ((i=1; i<len; i++)); do\n\t\tprev=$out\n\t\tcur=\"${out##* }\"\n\t\tif [[\
    \ $cur != *[!0]* ]]; then\n\t\t\twhile [[ $cur != *[!0]* ]]; do\n\t\t\t\tcur=\"\
    ${cur%?}\"\n\t\t\t\tif [[ $cur != *[!0]* ]]; then\n\t\t\t\t\ttmp=$cur\n\t\t\t\t\
    fi\n\t\t\t\tlet \"i++\"\n\t\t\tdone\n\t\t\tout=\"${prev}${tmp}\"\n\t\tfi\n\tdone\n\
    \techo \"$out\"", "  local x=\"$1\"\n  echo \"${x}\" | tr \" \" \"\\n\" | sort\
    \ | uniq | grep -E \"^[[:digit:]]+$\" | sort -n", "    awk '{for(i=1;i<=NF;i++){a[i]+=$i}}END{asort(a);for(i=1;i<=NF;i++){if($i%2==0){a[i]=a[i];};};for(i=1;i<=NF;i++){a[i]=a[i]+0};print\
    \ a[1]}'\"$1\"", "    local input=$1\n    local digits=($input)\n    local len=${#digits[@]}\n\
    \    for i in $(seq 0 $((len-1))); do\n        digits[i]=${digits[i]:1:1}\n  \
    \  done\n    local res\n    local x\n    for x in $(echo $input | tr \" \" \"\\\
    n\"); do\n        res=\"$res $(echo $x | grep \"[0-9]\" | grep -v \"^0$\" | sort\
    \ -n)\"\n    done\n    echo $res", "    local array=$1\n    local unique=()\n\
    \    local len=0\n    for ele in $array; do\n        len=$((${#unique[@]}+1))\n\
    \        unique[$len]=$ele\n    done\n    local i=0\n    while [ $i -lt $len ];\
    \ do\n        if [[ ${unique[$i]} | grep -v '0' ]]; then\n            unique+=(\
    \ ${unique[$i]} )\n            unset unique[$i]\n        fi\n        ((i++))\n\
    \    done\n    unique_digits=( \"${unique[@]}\" )", "    local x=\"${@:1}\"\n\
    \    local c\n    # sort each number in increasing order\n    x=\"$(echo \"${x}\"\
    \ | tr \" \" \"\\n\" | sort -n)\"\n    # for each number in x, check if it has\
    \ even digits\n    for c; do\n        test ${#c} -gt 0 && test ${c%%$c} = \"0\"\
    \ && break\n    done\n    # output the result\n    echo \"${x}\"", "    local\
    \ numbers=$1\n    local result\n    local counter=0\n    local value\n    local\
    \ digit\n    local temp_counter=1\n    local temp_result\n    \n    while [ $counter\
    \ -lt ${#numbers} ]\n    do\n        counter=$((counter+1))\n        value=${numbers[$counter]}\n\
    \        digit=${value#0}\n        \n        if [ $counter -eq 1 ]\n        then\n\
    \            temp_counter=$((counter))\n            temp_result=$((value))\n \
    \       else\n            temp_counter=$((counter-1))\n            temp_result=${numbers[$temp_counter]}\n\
    \        fi\n        \n        if [ $temp_counter -eq $(( ${#temp_result} / 2\
    \ )) ]\n        then\n            # remove the even digit from temp_result\n \
    \           tmp_digit=${tmp_digit#0}\n            tmp_counter=$(( $counter-1 ))\n\
    \            temp_result=${numbers[$tmp_counter]}\n            tmp_counter=$((\
    \ ${#temp_result} / 2 ))\n            temp_result=${temp_result#0}\n         \
    \   tmp_digit=${tmp_digit#0}\n            \n            if [ \"$value\" = \"$temp_result\"\
    \ -a \"$value\" = \"$tmp_digit\" ]\n            then\n                # remove\
    \ temp_digit from numbers\n                numbers=${numbers/$temp_result/$temp_result}\n\
    \                counter=$((counter-1))\n            else\n                # add\
    \ temp_digit to numbers\n                numbers=$numbers\",\"$temp_result\n \
    \               counter=$((counter+1))\n            fi\n        else\n       \
    \     if [ \"$value\" = \"$digit\" ]\n            then\n                # remove\
    \ digit from numbers\n                numbers=${numbers//$value/$value}\n    \
    \            counter=$((counter-1))\n            else\n                # add digit\
    \ to numbers\n                numbers=$numbers\",\"$value\n                counter=$((counter+1))\n\
    \            fi\n        fi\n    done\n    \n    result=$(echo \"$numbers\" |\
    \ cut -d \",\" -f 2-)\n    echo \"$result\"", "    local x=\"$1\"\n    local y\n\
    \    local -a arr\n    local i=0;\n    for y in \"${x}\"; do\n        [[ $y -eq\
    \ 0 || $y -gt 9 ]] || { echo \"$y\" >&2; return 1; }\n        arr[i]=\"$y\"\n\
    \        ((i++))\n    done\n    # sort arr\n    sort -n <(sort -n \"${arr[@]}\"\
    )"]
stop_tokens:
- "\n}"
