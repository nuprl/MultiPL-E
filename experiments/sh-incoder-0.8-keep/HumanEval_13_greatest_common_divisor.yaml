name: HumanEval_13_greatest_common_divisor
language: sh
prompt: "#!/bin/bash\n# Return a greatest common divisor of two integers a and b\n\
  # >>> greatest_common_divisor(3, 5)\n# 1\n# >>> greatest_common_divisor(25, 15)\n\
  # 5\n#\n# $1 is an integer\n# $2 is an integer\ngreatest_common_divisor() {\n"
tests: "}\n\ncandidate() {\n    greatest_common_divisor \"$@\"\n}\n\nset -e\nrun_test()\
  \ {\n    [[ $(candidate \"3\" \"7\") = \"1\" ]]\n    [[ $(candidate \"10\" \"15\"\
  ) = \"5\" ]]\n    [[ $(candidate \"49\" \"14\") = \"7\" ]]\n    [[ $(candidate \"\
  144\" \"60\") = \"12\" ]]\n}\n\nrun_test"
completions: ["\techo \"$(( (${1%/*}+${1#*/})%${2%/*}+${2#*/}))\"", "    local a b\n\
    \    a=$1\n    b=$2\n    if [ $a -gt $b ]\n    then\n        b=$a\n        a=$b\n\
    \    fi\n    echo $(($b / $a))", "    local a b c\n    [[ -z $1 ]] && {\n    \
    \    echo 1>&2 \"Usage: greatest_common_divisor <integer> <integer>\"\n      \
    \  return 1\n    }\n    [[ -z $2 ]] && {\n        echo 1>&2 \"Usage: greatest_common_divisor\
    \ <integer> <integer>\"\n        return 1\n    }\n    [[ -z $3 ]] && {\n     \
    \   echo 1>&2 \"Usage: greatest_common_divisor <integer> <integer>\"\n       \
    \ return 1\n    }\n    [[ -z $4 ]] && {\n        echo 1>&2 \"Usage: greatest_common_divisor\
    \ <integer> <integer>\"\n        return 1\n    }\n    [[ -z $5 ]] && {\n     \
    \   echo 1>&2 \"Usage: greatest_common_divisor <integer> <integer>\"\n       \
    \ return 1\n    }\n    [[ $1 == 0 ]] && {\n        echo 1>&2 \"Usage: greatest_common_divisor\
    \ <integer> <integer>\"\n        return 1\n    }\n    [[ $2 == 0 ]] && {\n   \
    \     echo 1>&2 \"Usage: greatest_common_divisor <integer> <integer>\"\n     \
    \   return 1\n    }\n    [[ $3 == 0 ]] && {\n        echo 1>&2 \"Usage: greatest_common_divisor\
    \ <integer> <integer>\"\n        return 1\n    }\n    [[ $4 == 0 ]] && {\n   \
    \     echo 1>&2 \"Usage: greatest_common_divisor <integer> <integer>\"\n     \
    \   return 1\n    }\n    [[ $5 == 0 ]] && {\n        echo 1>&2 \"Usage: greatest_common_divisor\
    \ <integer> <integer>\"\n        return 1\n    }\n    a=$1\n    b=$2\n    c=$3\n\
    \    while [ $c -gt 0 ]; do\n        [ $c -eq 0 ] && c=1\n        [ $b -lt $a\
    \ ] && b=$b - 1\n        [ $b -lt $c ] && c=$c-1\n    done\n    echo $b", "  \
    \  [[ -z \"$1\" ]] || [[ -z \"$2\" ]] || [ \"$1\" -gt \"$2\" ] && return 1\n \
    \   local a b\n    a=$1\n    b=$2\n    while [ $a -gt 0 ]; do\n        test $b\
    \ -gt 0 && break\n        test $a -gt $b -a $b -gt 0 && a=$(( $a / $b ))\n   \
    \     b=$(( $b / $a ))\n    done\n    echo $a", "\ta=$1\n\tb=$2\n\t[[ $a -lt 0\
    \ || $b -lt 0 || $a -gt $b  ]] || return 1\n\tlet \"div=$(b**.1/a**.1)+1\"\n\t\
    echo \"$div\"", "    if [ $# -eq 0 ]; then\n        echo \"Usage: $0 [integer]\
    \ integer\"\n        exit 1\n    elif [ $# -eq 1 ]; then\n        echo \"Usage:\
    \ $0 [integer] integer\"\n        exit 1\n    elif [ $# -gt 1 ]; then\n      \
    \  echo \"Usage: $0 [integer] integer\"\n        exit 1\n    fi\n\n    local a\
    \ b\n    a=$1\n    b=$2\n\n    local a_bits a_low a_high b_low b_high\n    a_bits=$((\n\
    \        $( expr \"${a}\" - \"$(b)\" +\n            expr \"${a}\" | cut -c 1-9\
    \ ) *\n        $( expr \"${b}\" - \"$(a)\" +\n            expr \"${b}\" | cut\
    \ -c 1-9 )\n    ))\n\n    a_low=$( expr \"${a}\" | cut -c 1-9 )\n    a_high=$(\
    \ expr \"${a}\" | cut -c 10- )\n    b_low=$( expr \"${b}\" | cut -c 1-9 )\n  \
    \  b_high=$( expr \"${b}\" | cut -c 10- )\n\n    while [ \"$a_bits\" -gt 0 ];\
    \ do\n        a_bits=$(( ${a_bits} % $b_low ))\n    done\n\n    return $( expr\
    \ \"${a_bits} + $b_low\" )", "    local a b\n    a=$1; b=$2\n    # Looping until\
    \ one remains\n    while [ $(( a % b )) -eq 0 ]; do\n        a=$(( a/10 ))\n \
    \       b=$(( b/10 ))\n    done\n    echo \"$b\"", "\t[[ $1 != $2 ]] && echo \"\
    $1 is not a multiple of $2\" && return 1\n\tlocal d=$1\n\twhile (( $1 >= 1 ));\
    \ do\n\t\t(( $1 % $2 != 0 )) && break\n\t\t(( $1 == 1 )) && break\n\t\t(( d *=\
    \ 2 ))\n\t\t(( d %= $2 ))\n\tdone\n\techo $d", "    local i j\n    # $1 is dividend\n\
    \    # $2 is divisor\n    local answer=\n    local divisor_of_dividend=\n    local\
    \ remainder=\n    local quotient=\n    local remainder_of_quotient=\n    local\
    \ number_of_divisors=\n    local factor=\n    local greatest_common_divisor=\n\
    \    shift\n    shift\n    for (( i=1; i <= $1; i++ )); do\n        [ $2 -eq 0\
    \ ] && ( echo \"$1 is a divisor of 0!\" && return 0 ) ;;\n        (( divisor_of_dividend==i\
    \ )) && [ \"$2\" -eq 0 ] && ( echo \"$1 is a divisor of $i!\" && return 0 ) ;;\n\
    \        (( number_of_divisors )) && [ \"$2\" -lt \"$number_of_divisors\" ] &&\
    \ ( echo \"$1 is a divisor of $number_of_divisors!\" && return 0 ) ;;\n      \
    \  (( dividend_of_divisors )) && [ \"$2\" -ge \"$number_of_divisors\" ] && ( echo\
    \ \"$1 is a divisor of $number_of_divisors!\" && return 0 ) ;;\n        (( number_of_divisors\
    \ )) && [ \"$2\" -eq \"$number_of_divisors\" ] && ( echo \"$1 is a divisor of\
    \ $number_of_divisors!\" && return 0 ) ;;\n        (( divisor_of_dividend==0 ))\
    \ && [ \"$2\" -ge \"$number_of_divisors\" ] && ( echo \"$1 is a divisor of $number_of_divisors!\"\
    \ && return 0 ) ;;\n        (( divisor_of_dividend==i )) && [ \"$2\" -eq \"$divisor_of_dividend\"\
    \ ] && ( echo \"$1 is a divisor of $divisor_of_dividend!\" && return 0 ) ;;\n\
    \        (( divisor_of_dividend )) && [ \"$2\" -eq \"$divisor_of_dividend\" ]\
    \ && ( echo \"$1 is a divisor of $divisor_of_dividend!\" && return 0 ) ;;\n  \
    \      (( number_of_divisors )) && [ \"$2\" -le \"$number_of_divisors\" ] && (\
    \ echo \"$1 is a divisor of $number_of_divisors!\" && return 0 ) ;;\n        ((\
    \ dividend_of_divisors )) && [ \"$2\" -eq \"$number_of_divisors\" ] && ( echo\
    \ \"$1 is a divisor of $number_of_divisors!\" && return 0 ) ;;\n        (( dividend_of_divisors\
    \ )) && [ \"$2\" -le \"$number_of_divisors\" ] && ( echo \"$1 is a divisor of\
    \ $number_of_divisors!\" && return 0 ) ;;\n        (( dividend_of_divisors ",
  "    [[ $(type -t $1) == function ]] || { echo \"Error: first parameter must be\
    \ a function\" >&2; exit 1; }\n    [[ $(type -t $2) == function ]] || { echo \"\
    Error: second parameter must be a function\" >&2; exit 1; }\n\n    local a b\n\
    \    local x y\n    a=$1\n    b=$2\n    while [ $b -ne 0 ]; do\n        x=$(($a\
    \ / $b))\n        y=$(($a % $b))\n        a=$x\n        b=$y\n    done\n    echo\
    \ $a", "    local a b\n    local -i div\n    a=$1\n    b=$2\n    if (( a < b ));\
    \ then\n        div=$a\n        a=$b\n        b=$div\n    fi\n    while (( a >\
    \ 0 )); do\n        div=$(( a / b ))\n        a=$b\n        b=$div\n    done\n\
    \    return $div", "    local a b\n    a=$1\n    b=$2\n    while [ $a -le $b ];\
    \ do\n        a=$(($a % $b))\n        b=$b\n    done\n    echo \"$a\"", "    if\
    \ [ $1 -gt $2 ]; then\n        echo $2\n    elif [ $1 -lt $2 ]; then\n       \
    \ echo $2\n    elif [ $1 -eq $2 ]; then\n        echo $2\n    else\n        echo\
    \ $(( $1 % $2 ))\n    fi", "    local a=$1\n    local b=$2\n    local greatest_divisor\
    \ remainder\n\n    while [[ $a -gt 0 ]]; do\n        remainder=$((b % a))\n  \
    \      if [[ $remainder -gt 0 ]]; then\n            greatest_divisor=$a\n    \
    \        a=$remainder\n        else\n            a=$b\n            b=$remainder\n\
    \        fi\n    done\n\n    echo $greatest_divisor", "    (( ! $2 )) && echo\
    \ \"Must supply 2nd argument to greatest_common_divisor function\" && exit 1\n\
    \    local a b\n    a=$1\n    b=$2\n    [ $a -gt $b ] && { echo \"$a is less than\
    \ $b\"; exit 1; }\n    [ $a -lt $b ] && { echo \"$a is greater than $b\"; exit\
    \ 1; }\n    local quotient\n    while [ $b -gt 0 ]\n    do\n        a=$((a/b))\n\
    \        b=$((b%a))\n    done\n    echo $a", "    local a b\n    shift\n    a=$1\n\
    \    b=$1\n    while [ \"$a\" -gt \"$b\" ]\n    do\n        a=$(($a - $b))\n \
    \       b=$b\n    done\n    echo $a", "\tlocal x y c\n\tx=\"${1}\"\n\ty=\"${2}\"\
    \n\tc=\"${x}\"\n\twhile [ \"${x}\" -gt \"0\" ] || [ \"${y}\" -gt \"0\" ] ; do\n\
    \t\t((x = x % y)) && [ \"${c}\" -gt \"0\" ] && break\n\t\t((y = y % x)) && [ \"\
    ${c}\" -gt \"0\" ] && break\n\t\t((c = c % y)) && [ \"${c}\" -gt \"0\" ] && break\n\
    \tdone\n\techo \"${c}\"", "    local a b\n    [[ $1 =~ ^[0-9]+$ ]] || { echo \"\
    Parameter 1 must be a number\" ; exit 1; }\n    [[ $2 =~ ^[0-9]+$ ]] || { echo\
    \ \"Parameter 2 must be a number\" ; exit 1; }\n    a=$1\n    b=$2\n\n    # ensure\
    \ integers\n    if [[ $a =~ \"^[0-9]+$\" ]] ; then\n        a=$(awk '{print $1}'\
    \ <<< \"$a\")\n    fi\n    if [[ $b =~ \"^[0-9]+$\" ]] ; then\n        b=$(awk\
    \ '{print $1}' <<< \"$b\")\n    fi\n\n    # ensure a and b are positive\n    if\
    \ [[ \"$a\" < 0 || \"$b\" < 0 ]] ; then\n        echo \"Parameter a or b must\
    \ be positive\"\n        exit 1\n    fi\n\n    # ensure b is not a multiple of\
    \ a\n    if [[ \"$a\" -eq \"$b\" ]] ; then\n        echo \"Parameter a and b cannot\
    \ be equal\"\n        exit 1\n    fi\n\n    local c=1\n    # loop through until\
    \ c does not equal b\n    while [[ $c -le $b ]] ; do\n        local d=$c\n   \
    \     c=$((a*$c + $b))\n        if [[ $d -eq \"$b\" ]] ; then\n            break\n\
    \        fi\n    done\n    echo \"$c\"", "  local a=$1\n  local b=$2\n  local\
    \ c=$a\n  local d=$b\n\n  while [[ $c -eq 0 ]]; do\n    c=$((a * $c))\n    d=$((b\
    \ * d))\n  done\n\n  [[ $d -eq $a ]] && echo $d", "\t(( $# < 2 )) && { echo \"\
    Error: insufficient arguments\"; exit 2; }\n\tlocal a b x\n\ta=$(( $1 ))\n\tb=$((\
    \ $2 ))\n\tx=$(( b % a ))\n\twhile [[ $x -ne 0 ]]; do\n\t\tb=$(( $a ))\n\t\ta=$((\
    \ $b ))\n\t\tx=$(( $b % $a ))\n\tdone\n\techo \"$a\""]
stop_tokens:
- "\n}"
