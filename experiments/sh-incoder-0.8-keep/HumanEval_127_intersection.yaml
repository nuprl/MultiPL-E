name: HumanEval_127_intersection
language: sh
prompt: "#!/bin/bash\n# You are given two intervals,\n# where each interval is a pair\
  \ of integers. For example, interval = (start, end) = (1, 2).\n# The given intervals\
  \ are closed which means that the interval (start, end)\n# includes both start and\
  \ end.\n# For each given interval, it is assumed that its start is less or equal\
  \ its end.\n# Your task is to determine whether the length of intersection of these\
  \ two \n# intervals is a prime number.\n# Example, the intersection of the intervals\
  \ (1, 3), (2, 4) is (2, 3)\n# which its length is 1, which not a prime number.\n\
  # If the length of the intersection is a prime number, return \"YES\",\n# otherwise,\
  \ return \"NO\".\n# If the two intervals don't intersect, return \"NO\".\n# [input/output]\
  \ samples:\n# intersection((1, 2), (2, 3)) ==> \"NO\"\n# intersection((-1, 1), (0,\
  \ 4)) ==> \"NO\"\n# intersection((-3, -1), (-5, 5)) ==> \"YES\"\n#\n# $1 is a space-separated\
  \ list\n# $2 is a space-separated list\nintersection() {\n"
tests: "}\n\ncandidate() {\n    intersection \"$@\"\n}\n\nset -e\nrun_test() {\n \
  \   [[ $(candidate \"1 2\" \"2 3\") = \"NO\" ]]\n    [[ $(candidate \"-1 1\" \"\
  0 4\") = \"NO\" ]]\n    [[ $(candidate \"-3 -1\" \"-5 5\") = \"YES\" ]]\n    [[\
  \ $(candidate \"-2 2\" \"-4 0\") = \"YES\" ]]\n    [[ $(candidate \"-11 2\" \"-1\
  \ -1\") = \"NO\" ]]\n    [[ $(candidate \"1 2\" \"3 5\") = \"NO\" ]]\n    [[ $(candidate\
  \ \"1 2\" \"1 2\") = \"NO\" ]]\n    [[ $(candidate \"-2 -2\" \"-3 -2\") = \"NO\"\
  \ ]]\n}\n\nrun_test"
completions: ["  local intersection interval_start\n  local length\n  for interval_start\
    \ in \"$1\"; do\n    local interval_end\n    local prime\n    for interval_end\
    \ in \"$2\"; do\n      prime=$(expr $interval_start \\* $interval_end)\n     \
    \ if [[ \"$prime\" -eq \"2\" ]]; then\n        length=$(expr $interval_end - $interval_start)\n\
    \        if [[ \"$length\" -eq \"2\" ]]; then\n          echo \"$interval_start,\
    \ $interval_end\"\n        fi\n      fi\n    done\n  done", "  local interval\n\
    \  local firstInt=0\n  local secondInt=0\n  local firstIntLen=1\n  local secondIntLen=1\n\
    \  local intLength=0\n  local isPrime=1\n  for interval in $(echo \"$1 $2\" |\
    \ tr ' ' '\\n');do\n    firstInt=$(echo $interval | cut -d'(' -f 2 | cut -d')'\
    \ -f 1)\n    secondInt=$(echo $interval | cut -d'(' -f 2 | cut -d')' -f 2)\n \
    \   firstIntLen=$((${#firstInt}))\n    secondIntLen=$((${#secondInt}))\n    intLength=$((firstIntLen\
    \ < secondIntLen ? firstIntLen : secondIntLen))\n    \n    if ((${firstInt} <=\
    \ ${secondInt})); then\n      ((isPrime==1)) && break\n    else\n      ((isPrime==0))\
    \ && break\n    fi\n  done\n  echo \"$isPrime\"", "  local start=$1\n  local end=$2\n\
    \  \n  local length=$((end - start))\n  local result=$(expr `expr $start \\* $length`\
    \ \\+ `expr $end \\* $length`)\n  \n  if [ ${result} -eq 0 ]\n  then\n    echo\
    \ \"NO\"\n  else\n    echo \"YES\"\n  fi", "  local i j\n  read -r i j\n  [[ -z\
    \ $i ]] && return 0\n  [[ -z $j ]] && return 0\n  if [[ $(expr $j - $i \\* $i\
    \ \\> $j) -eq 0 ]]; then\n    echo \"YES\"\n  else\n    echo \"NO\"\n  fi", " \
    \   local intersec1=$(echo \"$1\" | awk '{for(i=1;i<=NF;i++) if(i==1) a[i]=$i;else\
    \ a[i]=$i}END{for(i=1;i<=NF;i++) if(a[i]<a[i]+a[i-1]) print a[i]}')\n    local\
    \ intersec2=$(echo \"$2\" | awk '{for(i=1;i<=NF;i++) if(i==1) a[i]=$i;else a[i]=$i}END{for(i=1;i<=NF;i++)\
    \ if(a[i]<a[i]+a[i-1]) print a[i]}')\n\n    local length_int1=$(echo \"$1\" |\
    \ awk '{for(i=1;i<=NF;i++) if(i==1) a[i]=$i;else a[i]=$i}END{for(i=1;i<=NF;i++)\
    \ if(a[i]>a[i-1]) print a[i]}')\n    local length_int2=$(echo \"$2\" | awk '{for(i=1;i<=NF;i++)\
    \ if(i==1) a[i]=$i;else a[i]=$i}END{for(i=1;i<=NF;i++) if(a[i]>a[i-1]) print a[i]}')\n\
    \    local length_int1_2=$(echo \"$1\" | awk '{for(i=1;i<=NF;i++) if(i==1) a[i]=$i;else\
    \ a[i]=$i}END{for(i=1;i<=NF;i++) if(a[i]>a[i]) print a[i]}')\n    local length_int2_2=$(echo\
    \ \"$2\" | awk '{for(i=1;i<=NF;i++) if(i==1) a[i]=$i;else a[i]=$i}END{for(i=1;i<=NF;i++)\
    \ if(a[i]>a[i]) print a[i]}')\n\n    if (( ${#intersec1} == 1 ) || ( ${#intersec2}\
    \ == 1 )) {\n        return \"NO\"\n    }\n    if (( ${#intersec1} == 2 ) || (\
    \ ${#intersec2} == 2 )) {\n        echo \"YES\"\n        return\n    }\n    if\
    \ (( ${#intersec1} == 1 ) || ( ${#intersec2} == 2 )) {\n        echo \"NO\"\n\
    \        return\n    }\n    echo \"YES\"", "    local interval=$1\n    local interval2=$2\n\
    \    local len1=0\n    local len2=0\n    local len=0\n    local flag=0\n    local\
    \ i=0\n\n    while [ $i -lt ${#interval[@]} ]; do\n        if [ $i -lt ${#interval2[@]}\
    \ ]; then\n            len1=$(expr $len1 + ${interval[$i]})\n            len2=$(expr\
    \ $len2 + ${interval2[$i]})\n            len=$(expr $len + ${interval[$i]} + ${interval2[$i]})\n\
    \        else\n            if [ $(expr $len + ${interval[$i]} + ${interval2[$i]})\
    \ -eq 0 ]; then\n                len=$((len+${interval[$i]}))\n            else\n\
    \                len=$((len-${interval[$i]}))\n                flag=1\n      \
    \          break\n            fi\n        fi\n        i=$(expr $i+1)\n    done\n\
    \n    if [ $flag ]; then\n        echo \"YES\"\n    else\n        echo \"NO\"\n\
    \    fi", "\tlocal interval1=$1\n\tlocal interval2=$2\n\tlocal output\n\tlocal\
    \ count1\n\tlocal count2\n\tlocal start1\n\tlocal end1\n\tlocal start2\n\tlocal\
    \ end2\n\tlocal length1\n\tlocal length2\n\tlocal prime1\n\tlocal prime2\n\tlocal\
    \ j\n\tlocal k\n\tlocal i\n\tlocal l\n\tlocal result\n\tcount1=0\n\tcount2=0\n\
    \tstart1=$interval1[1]\n\tend1=$interval1[2]\n\tstart2=$interval2[1]\n\tend2=$interval2[2]\n\
    \tprime1=\"1\"\n\tprime2=\"1\"\n\tj=0\n\tk=0\n\ti=0\n\tl=0\n\tresult=\"NO\"\n\t\
    if [ \"$end1\" -le \"$end2\" ]; then\n\t\tif [ \"$start1\" -ge \"$end2\" ]; then\n\
    \t\t\tif [ \"$start1\" -le \"$end1\" ]; then\n\t\t\t\tcount1=$((end1-start1))\n\
    \t\t\t\tlength1=$((end1-start1))\n\t\t\t\twhile [ \"$count1\" -gt 0 ]; do\n\t\t\
    \t\t\tprime1=$((prime1*2))\n\t\t\t\t\tcount1=$((count1/2))\n\t\t\t\tdone\n\t\t\
    \t\tlength1=$((length1-1))\n\t\t\t\tfor ((i=$((length1+1)); i<$end1; i++)) do\n\
    \t\t\t\t\tprime1=$((prime1*3))\n\t\t\t\tdone\n\t\t\t\tprime1=$((prime1-1))\n\t\
    \t\t\tfor ((j=$((length2+1)); j<$end2; j++)) do\n\t\t\t\t\tprime2=$((prime2*3))\n\
    \t\t\t\tdone\n\t\t\t\tprime2=$((prime2-1))\n\t\t\t\tfor ((i=$((length1+1)); i<$start1;\
    \ i++)) do\n\t\t\t\t\tprime1=$((prime1*4))\n\t\t\t\tdone\n\t\t\t\tfor ((j=$((length2+1));\
    \ j<$start2; j++)) do\n\t\t\t\t\tprime2=$((prime2*4))\n\t\t\t\tdone\n\t\t\t\t\
    prime1=$((prime1-1))\n\t\t\t\tfor ((i=$((length2+1)); i<$end2; i++)) do\n\t\t\t\
    \t\tprime2=$((prime2*5))\n\t\t\t\tdone\n\t\t\t\tprime2=$((prime2-1))\n\t\t\t\t\
    for ((j=$((length1+1)); j<$end1; j++)) do\n\t\t\t\t\tprime1=$((prime1*6))\n\t\t\
    \t\tdone\n\t\t\t\tfor ((i=$((length2+1)); i<$start2; i++)) do\n\t\t\t\t\tprime2=$((prime2*6))\n\
    \t\t\t\tdone\n\t\t\t\tfor ((j=$((length1+1))", "\t\n\t# your code goes here\n\t\
    \n\techo \"Enter two integers and an intersect and return the result.\"\n\techo\
    \ \"The integers are the first and second numbers of an interval.\"\n\techo \"\
    The intersect is the intersection of these two intervals.\"\n\techo \"Please enter\
    \ the two integers and an intersect and return the result.\"\n\tread -r a\n\t\
    read -r b\n\tread -r c\n\t\n\tif [ \"$a\" -ge \"$b\" ] && [ \"$a\" -le \"$c\"\
    \ ]\n\tthen\n\t\t\n\t\tif [ \"$b\" -ge \"$c\" ]\n\t\tthen\n\t\t\t\n\t\t\tif [\
    \ \"$a\" -eq \"$b\" ]\n\t\t\tthen\n\t\t\t\techo \"YES\"\n\t\t\telse\n\t\t\t\t\
    echo \"NO\"\n\t\t\tfi\n\t\telse\n\t\t\t\n\t\t\tif [ \"$a\" -eq \"$c\" ]\n\t\t\t\
    then\n\t\t\t\techo \"YES\"\n\t\t\telse\n\t\t\t\techo \"NO\"\n\t\t\tfi\n\t\tfi\n\
    \telse\n\t\techo \"NO\"\n\tfi", "\tinput=$1\n\tref=$2\n\tfor i in $input; do\n\
    \t\tstart=$i\n\t\tend=$((i+1))\n\t\t(( start <= ref )) && \\\n\t\t(( end <= ref\
    \ )) && \\\n\t\t(( start <= end )) && \\\n\t\t(( start <= ref )) && \\\n\t\t((\
    \ start < end )) && \\\n\t\t(( start < ref )) && \\\n\t\t(( ref < end )) && \\\
    \n\t\t(( ref < ref )) && \\\n\t\t(( $start <= $end )) && \\\n\t\t(( $start <=\
    \ $ref )) && \\\n\t\t(( $ref <= $end )) && \\\n\t\t(( $ref <= $ref ))\n\tdone\n\
    \techo \"YES\"", "    read -r a b < <(echo \"$1\")\n    read -r c d < <(echo \"\
    $2\")\n\n    if [[ \"$a\" = \"$c\" && \"$b\" = \"$d\" ]]; then\n        echo \"\
    NO\"\n        return\n    fi\n    \n    if [[ $(( a <= b && b <= c )) != 0 ]];\
    \ then\n        (( AB = $(awk \"BEGIN{a=1;b=$(awk \"BEGIN{c=$b;d=0;}($b>=$c||$c>=$d){print\
    \ ($b-$c>$d)?($b-$c+1):1}END{print a;}\" <<< \"$a\") ))\n        if [[ $(( a <=\
    \ b && b <= c )) == 1 ]]; then\n            echo \"YES\"\n        else\n     \
    \       echo \"NO\"\n        fi\n    fi", "    local firstInterval=$1\n    local\
    \ secondInterval=$2\n    # firstInterval would be a pair of integers such as (1,\
    \ 2)\n    # secondInterval would be a pair of integers such as (2, 3)\n    local\
    \ lengthOfIntersection=0\n    local checkIfIsPrimeNumber=0\n    local primeNumber=\"\
    YES\"\n    local primeNumber2=\"NO\"\n\n    # firstInterval would be a pair of\
    \ integers such as (1, 2)\n    # secondInterval would be a pair of integers such\
    \ as (2, 3)\n    # lengthOfIntersection would be the length of the intersection\n\
    \    # checkIfIsPrimeNumber would be 1 if the length of intersection is a prime\
    \ number\n    # and 0 if it is a not prime number\n    # primeNumber would be\
    \ \"YES\" if the length of intersection is a prime number\n    # and \"NO\" if\
    \ it is a not prime number\n    # primeNumber2 would be \"NO\" if the length of\
    \ intersection is a prime number\n    # and \"YES\" if it is a not prime number\n\
    \    local lengthOfIntersection\n    local checkIfIsPrimeNumber\n    local primeNumber\n\
    \    local primeNumber2\n\n    local lengthOfIntersection\n    local checkIfIsPrimeNumber\n\
    \    local primeNumber\n    local primeNumber2\n\n    for i in $( seq 1 $( ${#firstInterval}\
    \ -1 )); do\n        lengthOfIntersection=$(( ${firstInterval}[i] + ${firstInterval}[i+1]\
    \ ))\n        checkIfIsPrimeNumber=$(( ${lengthOfIntersection} == 2 ))\n     \
    \   if [ \"${checkIfIsPrimeNumber}\" -eq 1 ]; then\n            primeNumber=\"\
    YES\"\n            break\n        fi\n    done\n    \n    for i in $( seq 1 $(\
    \ ${#secondInterval} -1 )); do\n        lengthOfIntersection=$(( ${secondInterval}[i]\
    \ + ${secondInterval}[i+1] ))\n        checkIfIsPrimeNumber=$(( ${lengthOfIntersection}\
    \ == 2 ))\n        if [ \"${checkIfIsPrimeNumber}\" -eq 1 ]; then\n          \
    \  primeNumber2=\"YES\"\n            break\n        fi\n    done\n    \n    if\
    \ [[ \"${primeNumber}\" == \"YES\" ]] || [[ \"${primeNumber2}\" == \"YES\" ]];\
    \ then\n        echo \"${primeNumber}\"\n    else\n        echo \"${primeNumber2}\"\
    \n    fi", "\t# We assume that $1 is sorted and $2 is sorted\n\tlocal interval1=($(echo\
    \ \"$1\"|tr ' ' '\\n'))\n\tlocal interval2=($(echo \"$2\"|tr ' ' '\\n'))\n\tlocal\
    \ length1=${#interval1[@]}\n\tlocal length2=${#interval2[@]}\n\tlocal length\n\
    \tlocal start\n\tlocal end\n\tlocal interval\n\tlocal result\n\tlocal interval1\n\
    \tlocal interval2\n\tlocal length1\n\tlocal length2\n\tlocal current\n\tlocal\
    \ next\n\tlocal check\n\tlocal count\n\tlocal interval1Index\n\tlocal interval2Index\n\
    \tlocal prime\n\n\tinterval1Index=0\n\tinterval2Index=0\n\n\tlength=${#interval1[@]}\n\
    \twhile [ $interval1Index -le $length1 ]; do\n\t\tinterval=${interval1[$interval1Index]}\n\
    \t\tinterval1Index=$(( $interval1Index + 1 ))\n\t\tstart=${interval%,*}\n\t\t\
    end=${interval#*,}\n\n\t\tlength=${#interval2[@]}\n\t\twhile [ $interval2Index\
    \ -le $length2 ]; do\n\t\t\tinterval=${interval2[$interval2Index]}\n\t\t\tinterval2Index=$((\
    \ $interval2Index + 1 ))\n\t\t\tinterval2=${interval%,*}\n\t\t\tnext=${interval#*,}\n\
    \n\t\t\tcheck=false\n\t\t\tcurrent=start\n\t\t\tcount=3\n\t\t\twhile [ $count\
    \ -le $end ]; do\n\t\t\t\tif [ \"$current\" -eq \"$next\" ]; then\n\t\t\t\t\t\
    check=true\n\t\t\t\t\tbreak\n\t\t\t\telse\n\t\t\t\t\tcurrent=$next\n\t\t\t\t\t\
    current=$(( $current + 1 ))\n\t\t\t\t\tcount=$(( $count + 1 ))\n\t\t\t\tfi\n\t\
    \t\tdone\n\t\t\tif [ \"$check\" = true ]; then\n\t\t\t\tprime=false\n\t\t\t\t\
    break\n\t\t\telse\n\t\t\t\tprime=true\n\t\t\t\tbreak\n\t\t\tfi\n\t\tdone\n\t\t\
    if [ $prime -eq true ]; then\n\t\t\tresult=\"YES\"\n\t\t\tbreak\n\t\telse\n\t\t\
    \tresult=\"NO\"\n\t\t\tbreak\n\t\tfi\n\tdone\n\techo \"$result\"", "    local\
    \ start\n    local end\n    local length\n    local start2\n    local end2\n \
    \   local result\n    local num\n\n    read -r -a arr1 <<< \"$1\"\n    read -r\
    \ -a arr2 <<< \"$2\"\n    length=\"${#arr1[@]}\"\n    length=\"${#arr2[@]}\"\n\
    \n    if [[ \"${length}\" -eq 0 ]]\n    then\n        echo \"NO\"\n        return\n\
    \    fi\n    for (( i=0; i < length; i++ ));\n    do\n        start=\"${arr1[i]}\"\
    \n        end=\"${arr2[i]}\"\n        start2=\"${arr1[((i + 1) % length)]}\"\n\
    \        end2=\"${arr2[((i + 1) % length)]}\"\n        result=\"$(( ((end - start)\
    \ * (end - start2))/2 ))\"\n        if [[ \"$result\" -eq \"2\" ]]\n        then\n\
    \            echo \"YES\"\n            return\n        fi\n    done\n    echo\
    \ \"NO\"", "    local x1 y1 x2 y2 x3 y3\n    read -r x1 y1 < <(printf '%s\\n'\
    \ \"$@\")\n    read -r x2 y2 < <(printf '%s\\n' \"$@\")\n    read -r x3 y3 < <(printf\
    \ '%s\\n' \"$@\")\n    echo \"$((y2-y1)+(x3-x1))\"", "    local start end result=$1\n\
    \    for element in $2\n    do\n        if [ -z \"$result\" ]\n        then\n\
    \            start=$(echo \"$element\"|cut -d '(' -f2)\n            end=$(echo\
    \ \"$element\"|cut -d ')' -f1)\n        else\n            start=$(echo \"$result\"\
    |cut -d '(' -f2)\n            end=$(echo \"$result\"|cut -d ')' -f1)\n       \
    \ fi\n        if [ \"$start\" -gt \"$end\" ]\n        then\n            start=$(expr\
    \ \"$start\" + 1)\n        fi\n        if [ \"$end\" -gt \"$start\" ]\n      \
    \  then\n            end=$(expr \"$end\" + 1)\n        fi\n        echo -n $start\n\
    \        if [ \"$start\" -eq \"$end\" ]\n        then\n            echo \"$end\"\
    \n        fi\n    done", "    local interval_1 interval_2\n    interval_1=${1//\
    \ /}\n    interval_2=${2// /}\n    if [ $((${#interval_1} > ${#interval_2})) =\
    \ false ]; then\n        echo \"NO\" \n    else\n        echo $((${#interval_1}\
    \ & ${#interval_2}))\n    fi", "  local a b\n  a=( $1 )\n  b=( $2 )\n  result=\"\
    NO\"\n  for i in ${a[@]}; do\n    for j in ${b[@]}; do\n      if[ $i -le $j ];\
    \ then\n        if[ $i -le $((j+1))]; then\n          result=$((result))\n   \
    \     fi\n      fi\n    done\n  done\n  echo \"$result\"", "  local list_1=$1\n\
    \  local list_2=$2\n  local length_of_list1=$#list_1\n  local length_of_list2=$#list_2\n\
    \  local length_of_intersection=0\n  local first_interval_start\n  local first_interval_end\n\
    \  local second_interval_start\n  local second_interval_end\n  local first_interval_start2\n\
    \  local first_interval_end2\n  local second_interval_start2\n  local second_interval_end2\n\
    \  local intersecting_list\n\n  first_interval_start=$(expr ${list_1}[0] ${list_2}[1])\n\
    \  first_interval_end=$(expr ${list_1}[1] ${list_2}[2])\n  second_interval_start=$(expr\
    \ ${list_2}[0] ${list_1}[1])\n  second_interval_end=$(expr ${list_2}[1] ${list_1}[2])\n\
    \  first_interval_start2=$(expr ${list_1}[0] ${list_2}[1])\n  first_interval_end2=$(expr\
    \ ${list_1}[1] ${list_2}[2])\n  second_interval_start2=$(expr ${list_2}[0] ${list_1}[1])\n\
    \  second_interval_end2=$(expr ${list_2}[1] ${list_1}[2])\n  intersecting_list=${list_1}\
    \ ${list_2}\n\n  ((length_of_list1 < length_of_list2)) && echo \"NO\" && return\
    \ 0\n  ((length_of_list1 > length_of_list2)) && echo \"NO\" && return 0\n  ((length_of_list1\
    \ == length_of_list2)) && echo \"NO\" && return 0\n  ((length_of_list1 == length_of_list2))\
    \ && echo \"NO\" && return 0\n  ((length_of_list1 == length_of_list2)) && echo\
    \ \"NO\" && return 0\n  ((length_of_list1 == length_of_list2)) && echo \"NO\"\
    \ && return 0\n  ((length_of_list1 == length_of_list2)) && echo \"NO\" && return\
    \ 0\n  ((length_of_list1 == length_of_list2)) && echo \"NO\" && return 0\n  ((length_of_list1\
    \ == length_of_list2)) && echo \"NO\" && return 0\n  ((length_of_list1 == length_of_list2))\
    \ && echo \"NO\" && return 0\n  ((length_of_list1 == length_of_list2)) && echo\
    \ \"NO\" && return 0\n  ((length_of_list1 == length_of_list2)) && echo \"NO\"\
    \ && return 0\n  ((length_of_list1 == length_of_list2)) && echo \"NO\" && return\
    \ 0\n  ((length_of_list1 == length_of_list2)) && echo \"NO\" && return 0\n  ((length_of_list1\
    \ == length_of_list2)) && echo \"NO\" && return 0\n  ((length_of_list", "    local\
    \ a b\n    while read a b; do\n        if [ $a -le $b ]; then\n            echo\
    \ \"NO\"\n            return\n        fi\n    done < <(intersect $1 $2)", "  \
    \  local intersected intersectLength list\n    intersectLength=$(( ${#1} + ${#2}\
    \ ))\n    list=\"$1 $2\"\n    if [ ${#intersectLength} -eq 0 ]; then\n       \
    \ echo \"NO\"\n        return 0\n    fi\n    for (( i = 0; i < ${#list}; i++ ));\
    \ do\n        intersectLength=$(( $intersectLength - ${#${list}}))\n        if\
    \ [ ${#list} == 0 ] || [ ${#list} -eq ${#list} ] && [ \"${list}\" = \"${list#*\
    \ }\" ]; then\n            echo \"NO\"\n            return 0\n        fi\n   \
    \     list=\"${list#* }\"\n    done\n    local listLength isPrime i\n    isPrime=false\n\
    \    listLength=0\n    for (( i = 0; i < ${#list}; i++ )); do\n        listLength=$((\
    \ $listLength + ${#${list}}))\n        if [ \"${list}\" = \"${list#* }\" ]; then\n\
    \            listLength=$(( $listLength - ${#list}))\n            listLength=$((\
    \ $listLength / 2))\n        fi\n    done\n    if [ ${listLength} -eq 0 ]; then\n\
    \        echo \"NO\"\n        return 0\n    fi\n    for (( i = 0; i < ${#list};\
    \ i++ )); do\n        if [ ${listLength} -eq ${listLength} ] && [ ${listLength}\
    \ -ge ${listLength} ] && [ ${listLength} -le ${listLength} ]; then\n         \
    \   isPrime=true\n            if [ ${#${list}} -eq ${#list} ] && [ ${list} -eq\
    \ ${list#* } ]; then\n                echo \"YES\"\n                return 0\n\
    \            fi\n        fi\n    done\n    if [ ${isPrime} == \"true\" ]; then\n\
    \        echo \"YES\"\n        return 0\n    else\n        echo \"NO\"\n     \
    \   return 0\n    fi"]
stop_tokens:
- "\n}"
