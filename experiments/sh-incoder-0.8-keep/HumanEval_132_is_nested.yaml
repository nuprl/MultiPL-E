name: HumanEval_132_is_nested
language: sh
prompt: "#!/bin/bash\n# Create a function that takes a string as input which contains\
  \ only square brackets.\n# The function should return True if and only if there\
  \ is a valid subsequence of brackets \n# where at least one bracket in the subsequence\
  \ is nested.\n# is_nested('[[]]') \u279E True\n# is_nested('[]]]]]]][[[[[]') \u279E\
  \ False\n# is_nested('[][]') \u279E False\n# is_nested('[]') \u279E False\n# is_nested('[[][]]')\
  \ \u279E True\n# is_nested('[[]][[') \u279E True\n#\n# $1 is a string\nis_nested()\
  \ {\n"
tests: "}\n\ncandidate() {\n    is_nested \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
  \ $(candidate \"[[]]\") = \"true\" ]]\n    [[ $(candidate \"[]]]]]]][[[[[]\") =\
  \ \"false\" ]]\n    [[ $(candidate \"[][]\") = \"false\" ]]\n    [[ $(candidate\
  \ \"[]\") = \"false\" ]]\n    [[ $(candidate \"[[[[]]]]\") = \"true\" ]]\n    [[\
  \ $(candidate \"[]]]]]]]]]]\") = \"false\" ]]\n    [[ $(candidate \"[][][[]]\")\
  \ = \"true\" ]]\n    [[ $(candidate \"[[]\") = \"false\" ]]\n    [[ $(candidate\
  \ \"[]]\") = \"false\" ]]\n    [[ $(candidate \"[[]][[\") = \"true\" ]]\n    [[\
  \ $(candidate \"[[][]]\") = \"true\" ]]\n    [[ $(candidate \"\") = \"false\" ]]\n\
  \    [[ $(candidate \"[[[[[[[[\") = \"false\" ]]\n    [[ $(candidate \"]]]]]]]]\"\
  ) = \"false\" ]]\n}\n\nrun_test"
completions: ["  local -r STR=\"$1\"\n  local -r NESTED_BRACKETS='[' '<' ']' '<' '['\
    \ ']' ']' '[' '<' ']' '<' '[' ']' '<' '[' '<' ']' '<' '[' ']' '<' ']'\n  local\
    \ -r VALID_BRACKETS='[<>]'\n\n  local -r BRACKET_COUNT=0\n  local -r VALID_BRACKET_COUNT=0\n\
    \n  # Remove leading and trailing brackets if present\n  STR=\"${STR#?}\"\n  STR=\"\
    ${STR%?}\"\n\n  for BRACKET_COUNT in \"${!NESTED_BRACKETS[@]}\"; do\n    VALID_BRACKET_COUNT=$((VALID_BRACKET_COUNT\
    \ + ${#NESTED_BRACKETS[BRACKET_COUNT]} - 1))\n  done\n\n  # Remove valid brackets\n\
    \  VALID_BRACKET_COUNT=$((VALID_BRACKET_COUNT + BRACKET_COUNT))\n  if [ \"${STR}\"\
    \ != \"${VALID_BRACKETS:-}\" ]; then\n    return 0\n  fi\n\n  for BRACKET_COUNT\
    \ in \"${!VALID_BRACKETS[@]}\"; do\n    VALID_BRACKET_COUNT=$((VALID_BRACKET_COUNT\
    \ + ${#VALID_BRACKETS[BRACKET_COUNT]} - 1))\n  done\n\n  return 1", "    local\
    \ str=$1\n    local nest=0\n    local start=0\n    local bracket=0\n    local\
    \ count=0\n    local i=0\n    local lastbrack=0\n\n    while [[ $i -lt ${#str}\
    \ ]]; do\n        if [[ ${str:$i,1} == '[' ]]; then\n            bracket=1;\n\
    \            start=$i;\n        elif [[ ${str:$i,1} == ']' ]]; then\n        \
    \    if (( $nest > 0 )); then\n                if (( $bracket == 0 )); then\n\
    \                    if (( $start == 0 )); then\n                        if ((\
    \ $count == 0 )); then\n                            return 1;\n              \
    \          else\n                            return 0;\n                     \
    \   fi\n                    else\n                        return 1;\n        \
    \            fi\n                else\n                    return 1;\n       \
    \         fi\n            fi\n            bracket=0;\n        elif [[ ${str:$i,1}\
    \ == '(' )]]; then\n            count=$(( $count + 1))\n        elif [[ ${str:$i,1}\
    \ == ')' ]]; then\n            count=$(( $count - 1 ))\n            if (( $count\
    \ < 0 )); then\n                if (( $nest == 0 )); then\n                  \
    \  return 0;\n                else\n                    return 1;\n          \
    \      fi\n            fi\n        fi\n        i=$(( $i + 1 ))\n    done\n\n \
    \   return 1;", "  local str=$1\n  local level=0\n  local bracket_count=0\n  local\
    \ char_count=0\n  local inside_bracket=false\n  local bracket_inside=false\n \
    \ for ((i=0; i<${#str}; i++)); do\n    char=${str:$i:1}\n    if [ $char_count\
    \ -lt 3 ] ; then\n      if [ $char_count -eq 0 ] ; then\n        char_count=$char\n\
    \        level=1\n      else\n        level=$(expr ${level} + 1)\n      fi\n \
    \   fi\n    char_count=$(($char_count + 1))\n    if [ $char =~ ^[[]$ ] ; then\n\
    \      if [ $level -gt 1 ] ; then\n        inside_bracket=false\n      else\n\
    \        inside_bracket=true\n      fi\n    fi\n    if [ $inside_bracket ] ; then\n\
    \      if [ $bracket_count -lt 3 ] ; then\n        bracket_count=$bracket_count\
    \ + 1\n        if [ $bracket_count -eq 2 ] ; then\n          inside_bracket=false\n\
    \        fi\n      else\n        inside_bracket=false\n      fi\n    fi\n    if\
    \ [ $inside_bracket ] ; then\n      if [ $char =~ ^[[]$ ] ; then\n        bracket_inside=true\n\
    \      fi\n    fi\n    if [ $bracket_inside ] ; then\n      if [ $char == '['\
    \ ] ; then\n        bracket_inside=false\n        bracket_count=$(($bracket_count\
    \ + 1))\n      fi\n      if [ $char == ']' ] ; then\n        bracket_inside=true\n\
    \        bracket_count=$(($bracket_count + 1))\n        if [ $bracket_count -eq\
    \ 1 ] ; then\n          inside_bracket=false\n          bracket_count=0\n    \
    \      break\n        fi\n      fi\n    fi\n  done\n  return $inside_bracket",
  '    [[ $1 == ([]*[)] ]] && return 0 || return 1', "    local string=\"$1\"\n  \
    \  if [ -z \"$string\" ] ; then\n        return 0\n    fi\n    local len=${#string}\n\
    \    local count=0\n    local brackets='[]'\n    while [ $count -lt $len ] ; do\n\
    \        if [ $count -gt 0 ] && [[ $string == *$brackets* ]] ; then\n        \
    \    return 0\n        fi\n        local current=${string:$count:1}\n        if\
    \ [ \"$current\" == \"$brackets\" ] ; then\n            ((count++))\n        else\n\
    \            brackets=\"$current$brackets\"\n        fi\n    done\n    return\
    \ 1", "    local s='$1';\n    local opens='()[]{}'\n    local closes='[]{}'\n\n\
    \    while [[ \"$s\" =~ $opens ]]; do\n        echo \"${BASH_REMATCH[1]}\"\n \
    \       s=${s//\\1/}\n    done\n    echo \"${s}\"\n    echo \"${s//\\1/}\"\n \
    \   echo \"${s//$closes/}\"\n    echo \"${s//$opens/}\"\n    echo \"${s//$opens/}\"",
  "\tlocal substring=$1\n\tlocal opens=${substring//\\{\\{/}\n\tlocal closes=${substring//\\\
    }\\}/}\n\tlocal length1=${#opens}\n\tlocal length2=${#closes}\n\tlocal length=$((\
    \ (length1 > length2) ? length1 : length2 ))\n\tlocal nums=$(( (length1 > length2)\
    \ ? 1 : 0 ))\n\tlocal nested=0\n\tlocal count=0\n\tlocal i\n\tlocal j\n\t\n\t\
    for ((i = 0; i < length; i++)) \n\tdo\n\t\tcount=$(( (count+nums) > length ))\n\
    \t\t\n\t\tfor ((j = i+1 ; j < length; j++)) \n\t\tdo\n\t\t\t\n\t\t\tif [[ -z \"\
    ${opens:${j}}\" ]]\n\t\t\tthen\n\t\t\t\tlet nested=$nested+1\n\t\t\tfi\n\t\t\t\
    \n\t\t\tif [[ -z \"${closes:$j}}\" ]]\n\t\t\tthen\n\t\t\t\tlet nested=$nested-1\n\
    \t\t\tfi\n\t\t\t\n\t\t\tif [[ \"${opens:$j}\" != \"${closes:$j}\" ]]\n\t\t\tthen\n\
    \t\t\t\tcount=$(( count + nums ))\n\t\t\tfi\n\t\tdone\n\tdone\n\t\n\tif [[ $nested\
    \ -eq 0 ]]\n\tthen\n\t\treturn 1\n\telse\n\t\treturn 0\n\tfi", "    local _nesting_depth=0\n\
    \    local _nesting_open=false\n    local _nesting_close=false\n    local _nesting_opening=false\n\
    \    local _nesting_closing=false\n    local _nesting_opening_num=false\n    local\
    \ _nesting_closing_num=false\n    local _is_nesting=0\n    local _has_open_opening_num=0\n\
    \    local _has_open_closing_num=0\n    local _has_closed_num=false\n    local\
    \ _has_open_opening_num=$1\n    local _has_open_closing_num=$1\n    local _has_closed_num=$1\n\
    \n    while [ \"$_has_open_opening_num\" -le \"$_has_open_closing_num\" ]; do\n\
    \        if [ \"$_nesting_open\" -eq false ]; then\n            if [ \"$_nesting_opening\"\
    \ -eq false ]; then\n                if [ \"$_nesting_closing\" -eq false ]; then\n\
    \                    if [ \"$_nesting_opening_num\" -eq \"$_nesting_opening_num\"\
    \ ]; then\n                        _has_open_opening_num=false\n             \
    \           _has_open_closing_num=false\n                        _nesting_opening_num=$_nesting_opening_num\n\
    \                        _nesting_closing_num=$_nesting_opening_num\n        \
    \                _nesting_open=true\n                        _nesting_opening=true\n\
    \                        _nesting_closing=true\n                        _nesting_close=false\n\
    \                        _nesting_opening_num=false\n                    fi\n\
    \                fi\n            fi\n        fi\n        if [ \"$_has_closed_num\"\
    \ -eq \"$_nesting_opening_num\" ]; then\n            _has_closed_num=false\n \
    \           _nesting_closing=false\n            _nesting_opening_num=$_nesting_closing_num\n\
    \            _nesting_opening_num=false\n            _nesting_closing_num=false\n\
    \        fi\n        if [ \"$_nesting_opening_num\" -le \"$_nesting_closing_num\"\
    \ ]; then\n            if [ \"$_nesting_open\" -eq true ]; then\n            \
    \    if [ \"$_nesting_closing\" -eq true ]; then\n                    if [ \"\
    $_nesting_opening_num\" -le \"$_nesting_closing_num\" ]; then\n              \
    \          if [ \"$_nesting_closing\" -eq true ]; then\n                     \
    \       if [ \"$_nesting_opening_num\" -eq \"$_nesting_opening_num\" ]; then\n\
    \                                _has_open_opening_num=true\n                \
    \                _nesting_opening_num=false\n                                _nesting_open=false\n\
    \                                _nesting_closing", "    local -i brackets=0\n\
    \    local -i start=0\n    local -i end=0\n    local -i in=0\n    local -i last=0\n\
    \    local -i prev=0\n\n    local -i opening=0\n\n    # Loop through each character\n\
    \    for ((i=0; i<${#1}; i++)); do\n        \n        # If we encounter a opening\
    \ bracket, increase the brackets count\n        if [[ ${1:i:1} == '[' ]]; then\n\
    \            brackets++\n            \n        # If we encounter a closing bracket,\
    \ decrease the brackets count\n        elif [[ ${1:i:1} == ']' ]]; then\n    \
    \        brackets--\n            \n        # If we encounter an opening bracket,\
    \ increment the opening count\n        elif [[ ${1:i:1} == '['* ]]; then\n   \
    \         opening++\n        \n        # If we encounter a closing bracket, decrement\
    \ the opening count\n        elif [[ ${1:i:1} == '*' ]]; then\n            opening--\n\
    \        \n        # If brackets are equal, then we are in a nested bracket\n\
    \        elif (( brackets == 0 )); then\n            if (( opening == 0 )); then\n\
    \                start=i\n            else\n                end=i\n          \
    \  fi\n        fi\n    done\n\n    # Return the result of the test\n    echo ${#start:-2}\
    \ == ${#end:-2}", "  local input=\"${1}\"\n  [[ \"$input\" =~ ^\\[.*\\]$ ]] &&\
    \ return 0\n  [[ \"$input\" =~ ^[^\\[]*\\[[^]]*$] ]] && return 0\n  [[ \"$input\"\
    \ =~ ^[^\\[]*\\[[^]]*\\][^]]*$] ]] && return 0\n  [[ \"$input\" =~ ^[^\\[]*\\\
    [[^]]*\\][^[]*$] ]] && return 0\n  [[ \"$input\" =~ ^[^\\[]*\\[[^]]*\\][^[]*\\\
    ][^[]*$] ]] && return 0\n  [[ \"$input\" =~ ^[^\\[]*\\[[^]]*\\][^[]*\\][^[]*\\\
    ][^[]*$] ]] && return 0\n  return 1", "    local input=$1\n    local nested=0\n\
    \    for i in {1..${#input}};\n    do\n        if [[ \"${input:i:1}\" =~ ^([[{])$\
    \ ]];\n        then\n            nested=1\n            break\n        fi\n   \
    \ done\n    return ${nested}", '    [[ $1 =~ ^[^[]*]*(\[[^[]*])* ]]', "  local\
    \ str=$1\n  local depth=0\n  while [[ $str != \"\" ]]; do\n    if [[ \"$str\"\
    \ =~ \\[\\[\\] ]]; then\n      depth=$((depth + 1))\n    elif [[ \"$str\" =~ \\\
    [\\]\\] ]]; then\n      depth=$((depth - 1))\n    elif [[ \"$str\" =~ \\[\\[ ]];\
    \ then\n      depth=$((depth + 1))\n    elif [[ \"$str\" =~ \\]\\] ]]; then\n\
    \      depth=$((depth - 1))\n    fi\n    str=\"${str#*[]}\"\n  done\n  [[ \"$depth\"\
    \ -gt 0 ]]", "\tstring=\"$1\"\n\tfirstbrackets=\"${string%[}\"\n\tlastbrackets=\"\
    ${string##*]}\"\n\tif [[ \"$string\" =~ \"$firstbrackets\" ]]; then\n\t\tif [[\
    \ \"$string\" =~ \"$lastbrackets\" ]]; then\n\t\t\treturn 1\n\t\tfi\n\tfi\n\t\
    return 0", '    [[ "$1" =~ (\[.*\]) ]]', "    local STR=\"$1\" # a string\n  \
    \  local VALID=$(echo \"$STR\" | sed 's/[][]//g') # valid subsequence without\
    \ outer brackets\n    local OUTER=$(echo \"$STR\" | sed 's/[][][][]//g') # outer\
    \ brackets\n    local NESTED=$(echo \"$STR\" | sed 's/[][][][][]//g') # inner\
    \ brackets\n\n    if [[ $VALID != \"\" ]]\n    then\n        if [[ \"$OUTER\"\
    \ != \"\" ]]\n        then\n            if [[ \"$NESTED\" != \"\" ]]\n       \
    \     then\n                return True\n            else\n                return\
    \ False\n            fi\n        else\n            if [[ \"$NESTED\" != \"\" ]]\n\
    \            then\n                return False\n            else\n          \
    \      return False\n            fi\n        fi\n    else\n        return False\n\
    \    fi", "  test -n \"$1\" || return 1\n  local opening_count=0\n  local closings_count=`echo\
    \ \"$1\" | sed -e 's/[][]//g' | wc -l`\n  if [ \"$closings_count\" -eq \"0\" ];\
    \ then\n    return 1\n  else\n    for i in $(seq 1 \"$closings_count\");\n   \
    \ do\n      test \"$1\" =~ $'\\\\['$i':'$(($i-1))'\\\\]\\\\[' || return 0\n  \
    \  done\n    return 1\n  fi", "    local string=$1\n    local count=0\n    # count\
    \ the number of nested brackets\n    for symbol in ${string//\\//}; do\n     \
    \   ((count++))\n    done\n    # if the number of nested brackets equals the number\
    \ of characters in the string \n    # then return true\n    if [ $count -eq $((\
    \ ${#string} + 1 )) ]; then\n        true\n    else\n        false\n    fi", "\t\
    for i in $1 \n\tdo \n\t\tlet \"char=i[$((${#i}-1))]\"\n\t\tif [ \"$char\" != \"\
    ]\" ];then\n\t\t\tis_nested_helper\n\t\telse\n\t\t\ttrue\n\t\tfi\n\tdone", " \
    \   local x\n    x=\"${1}\"\n    [[ \"${x}\" =~ ^\\[[]+$ ]] || return 1\n    [[\
    \ \"${x}\" =~ ^\\[]+\\]\\[]+$ ]] || return 1\n    [[ \"${x}\" =~ ^\\[]+\\]$ ]]\
    \ || return 1\n    [[ \"${x}\" =~ ^\\[]+$ ]] || return 1\n    return 0"]
stop_tokens:
- "\n}"
