name: HumanEval_39_prime_fib
language: sh
prompt: "#!/bin/bash\n# prime_fib returns n-th number that is a Fibonacci number and\
  \ it's also prime.\n# >>> prime_fib(1)\n# 2\n# >>> prime_fib(2)\n# 3\n# >>> prime_fib(3)\n\
  # 5\n# >>> prime_fib(4)\n# 13\n# >>> prime_fib(5)\n# 89\n#\n# $1 is an integer\n\
  prime_fib() {\n"
tests: "}\n\ncandidate() {\n    prime_fib \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
  \ $(candidate \"1\") = \"2\" ]]\n    [[ $(candidate \"2\") = \"3\" ]]\n    [[ $(candidate\
  \ \"3\") = \"5\" ]]\n    [[ $(candidate \"4\") = \"13\" ]]\n    [[ $(candidate \"\
  5\") = \"89\" ]]\n    [[ $(candidate \"6\") = \"233\" ]]\n    [[ $(candidate \"\
  7\") = \"1597\" ]]\n    [[ $(candidate \"8\") = \"28657\" ]]\n    [[ $(candidate\
  \ \"9\") = \"514229\" ]]\n    [[ $(candidate \"10\") = \"433494437\" ]]\n}\n\nrun_test"
completions: ["\tif [ $1 -eq 1 ] || [ $1 -eq 2 ]; then\n\t\techo \"2\"\n\telse\n\t\
    \tlocal x\n\t\tx=$(( $1 % 2 ))\n\t\tlocal y\n\t\ty=$(( $1 / 2 ))\n\t\twhile [\
    \ $x -le $y ]; do\n\t\t\tx=$(( $x + 1 ))\n\t\t\ty=$(( $y + 1 ))\n\t\tdone\n\t\t\
    echo \"$x\"\n\tfi", "    local N=$1\n    local i\n    local i1=$((N-1))\n    if\
    \ [[ $(($N%2)) != 0 ]]; then\n        for i in $(seq 1 $i1); do\n            if\
    \ [[ $(prime_fib $(($N+$i)) | awk '{print $1}') == $(($N+$i)) ]]; then\n     \
    \           echo \"$((N+$i))\"\n                return\n            fi\n     \
    \   done\n    fi\n    if [[ $(($N%2)) == 0 ]]; then\n        for i in $(seq 1\
    \ $i1); do\n            if [[ $(prime_fib $(($N+$i)) | awk '{print $1}') < $(($N+$i))\
    \ ]]; then\n                echo \"$((N+$i))\"\n                return\n     \
    \       fi\n        done\n    fi", "  if [ $1 -lt 2 ]; then\n    return 1;\n \
    \ fi\n  echo \"$(($1 + $2))\"\n  prime_fib \"$(( $2 - 1 ))\"", "    n=$1\n   \
    \ if [ $n -eq 1 ]; then\n        echo \"$n\"\n    elif [ $n -eq 2 ]; then\n  \
    \      echo \"$n\"\n    elif [ $n -ge 3 ] && [ $n -le $(( $(echo \"$n - 1\" |\
    \ bc -l) ) ) ]; then\n        echo \"$n\"\n    else\n        echo \"$(( $(echo\
    \ \"$(( $(echo \"$n-1\" | bc -l)/2 )\" | bc -l) + 1 ))\"\n    fi", "  local num=\"\
    $1\"\n\n  if (( num == 1 )); then\n     echo \"$1\"\n     return 0\n  fi\n  local\
    \ last1\n  local last2\n  local fibnum\n  local prime\n  local max\n  last1=$(prime_fib\
    \ \"$((num-1))\")\n  last2=$(prime_fib \"$((num-2))\")\n  fibnum=\"$(( (\"$last1\"\
    \ - \"$last2\" ) + 1 ))\"\n  prime=\"$(( (\"$fibnum\" > \"$last2\" ) ? \"$fibnum\"\
    \ : $last2 ))\"\n  max=\"$(( $num + 1 ))\"\n\n  echo \"$prime\"\n\n  (( $max >\
    \ $prime )) || { echo \"$num\"; return 1 }", "    local n=$1 i\n    local a b\n\
    \    read -a b <<<\"$2\"\n    a=$b[1]\n    b=$b[${#b[@]} - 1]\n    echo $(($n\
    \ % $((${#b[@]} * $((a+b))) % $((${#b[@]} + $((a+b))))))", "    declare -i i\n\
    \    declare -i n\n\n    echo \"${1:-0}\"\n    shift\n\n    i=$(( ${1:-0} - 1\
    \ ))\n\n    while [[ $i -le $2 ]]; do\n        (( i++ ))\n        n=$(( ${i:-0}\
    \ * ( ${i:-0} + 1 ) ))\n        echo -n $n\n    done", "\tlet number=$1\n\tif\
    \ (( number == 1 || number == 2 )) \n\tthen\n\t\techo $number\n\telse\n\t\tlet\
    \ fibNumber=$(( 2 * $number + 1 ))\n\t\techo $fibNumber\n\t\tlet primeNumber=$((\
    \ 0 ))\n\t\tlet primeNumber=$(( $primeNumber + 1 ))\n\t\twhile (( $fibNumber <=\
    \ $number )) \n\t\tdo\n\t\t\tif [ $fibNumber == $number ]\n\t\t\tthen\n\t\t\t\t\
    echo $fibNumber\n\t\t\telse\n\t\t\t\tlet fibNumber=$(( $fibNumber + $number ))\n\
    \t\t\tfi\n\t\tdone\n\tfi", "    if [ $1 -eq 1 ]; then echo 1; return 1; fi\n \
    \   if [ $1 -eq 2 ]; then echo 2; return 1; fi\n    if [ $1 -le 3 ]; then \n \
    \       if [ $1 -le 5 ]; then echo 3; return 1; fi\n        if [ $1 -le 13 ];\
    \ then echo 5; return 1; fi\n        if [ $1 -le 89 ]; then echo 13; return 1;\
    \ fi\n    fi\n    prime_fib \"$(($1-1))\"", "   case $1 in\n      1) echo \"$2\"\
    ;;\n      2) echo \"$3\";;\n      *) let n=$1\n         let n1=2\n         let\
    \ n2=3\n         let i=2\n         while [ \"$n\" -le \"$i\" ]\n         do\n\
    \            let n3=$n1 + $n2\n            let n1=$n2\n            let n2=$n3\n\
    \            let i=$i+1\n            let n=$n3\n         done\n         let n3=$n1\
    \ + $n2\n         let n4=$n3 + $n\n         echo \"$n4\"\n         ;;\n   esac",
  "  local n=$1\n  local fib0=0\n  local fib1=1\n  local fib2=1\n  local i\n  local\
    \ t\n  local flag\n\n  flag=0\n  if [ $n -eq 0 ]; then\n    t=fib0\n  elif [ $n\
    \ -eq 1 ]; then\n    t=fib1\n  elif [ $n -eq 2 ]; then\n    t=fib2\n  else\n \
    \   i=2\n    while [ $i -le $n ]; do\n      t=`expr $fib0 + $fib1`\n      fib0=$fib1\n\
    \      fib1=$t\n      i=`expr $i + 1`\n    done\n  fi\n  if [ $flag -eq 1 ]; then\n\
    \    t=`expr $fib0 + $fib1`\n  fi\n  echo $t", "\tif [ -n \"$1\" -a -z \"$2\"\
    \ ] ; then\n\t\techo \"Usage: $0 <n> <fib_number>\" >&2\n\t\techo \"$0 <n> <fib_number>\
    \ [-n]\" >&2\n\t\texit 1\n\tfi\n\tlocal n=\"$1\"\n\tlocal fib_number=\"$2\"\n\t\
    local prime\n\tprime=\"$(( ( $fib_number + 1 )/2 ))\"\n\t(( n <= prime )) || return\
    \ $prime\n\tlocal i\n\tlocal p\n\t(( i <= n )) || return $prime\n\t(( n == 2 ))\
    \ || return $fib_number\n\tlocal current\n\tlocal prev\n\tlocal temp\n\t(( n ==\
    \ $prime )) || return $prime\n\ti=1\n\tp=1\n\tcurrent=$(( $p ))\n\tprev=$(( $p\
    \ ))\n\t(( i <= n )) || return $prime\n\twhile [ $i -le $n ]; do\n\t\ttemp=$((\
    \ $prev + $current ))\n\t\t(( p <= $current )) || return $prime\n\t\t(( i == n\
    \ )) || return $temp\n\t\tcurrent=$temp\n\t\tprev=$current\n\t\ti=$(( i + 1 ))\n\
    \tdone", "    local x=$1\n    local result\n    # Base case\n    if [ $x -eq 1\
    \ ]; then return 1; fi\n    # Find the square root of x\n    local i=1\n    local\
    \ square_root=`echo $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x\
    \ \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x\
    \ \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x\
    \ \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x\
    \ \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x\
    \ \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x\
    \ \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x\
    \ \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x\
    \ \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x\
    \ \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x\
    \ \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\* $x \\", "    local\
    \ n=$1 prev curr remainder\n\n    curr=$((2${!n}-1)) # find n-th Fibonacci number\n\
    \    while (( curr < $((4${!n})) )) ; do\n        prev=$curr\n        curr=$((prev\
    \ + curr))\n    done\n    remainder=$((4${!n} - curr))\n    if (( remainder ==\
    \ 0)) ; then\n        echo $curr\n    else\n        echo $((prev + curr))\n  \
    \  fi", "\tif [ $1 -eq 1 ] || [ $1 -eq 2 ]\n\tthen\n\t\techo $2\n\telse\n\t\t\
    let \"a = $2-1; b = $3-1; c = $2-b; d = $3-c; echo $(( (( ($a+$b+$c+$d) | gcd\
    \ $((2*$a+$b-$c+$d)) | mod  ((2*$a+$b-$c+$d)) ) )  + 1))\"\n\tfi", "  local n=$1\n\
    \  if [[ $n -eq 1 ]]; then\n    return 2\n  elif [[ $n -eq 2 ]]; then\n    return\
    \ 3\n  elif [[ $n -le 0 ]]; then\n    echo \"Illegal argument: Fibonacci Number\
    \ must be greater than 0\"\n    return -1\n  fi\n  local a=0\n  local b=1\n  local\
    \ c=1\n  local d=1\n  while [[ $n -gt 0 ]]; do\n    local tmp=$((a + b))\n   \
    \ a=$b\n    b=$c\n    c=$tmp\n    local tmp2=$((a + b))\n    a=$b\n    b=$tmp2\n\
    \    echo $((c))\n    n=$((n-1))\n  done", "    if [ $1 -lt 1 -o $1 -gt 10 ];\
    \ then\n        return 0\n    fi\n\n    prime_fib_prev=\"${prime_fib_prev:-$(prime_fib\
    \ $(($1/2)) - 1 )}\";\n\n    if [ $(($1%2)) -eq 0 ]; then\n        $prime_fib_prev\n\
    \    else\n        (( prime_fib_prev + prime_fib_prev ))\n    fi", "  local n=$1\n\
    \  local fib\n  local fibs a\n  local i p\n\n  if [[ $n -eq 1 ]]; then\n    return\
    \ 1\n  fi\n\n  fibs=$(awk '{fibs[$1+0]+=$1;fibs[$1+1]+=$2}END{for(i in fibs){print\
    \ i}}' 0 1 $((n-1)))\n  (( ${#fibs[@]} > 2 ))\n\n  a=$(( ${fibs[@]} / 2 ))\n \
    \ (( p ))\n\n  while (( $a ))\n  do\n    if (( n <= $a ))\n    then\n      ((\
    \ n = 2 * n + 1 ))\n      break\n    fi\n    (( a = $(( fibs[$a] / 2 )) ))\n \
    \   (( p++ ))\n  done\n\n  echo $n", "  (( $# < 2 )) && return 1\n  (( $1 == 1\
    \ )) && return 1\n  (( $1 == 2 )) && return 2\n  (( $1 > 2 )) && return prime_fib($1\
    \ - 1) + prime_fib($1 - 2)", "  if [ $# -eq 1 ]; then\n    local n=$1\n    # fibonacci\
    \ numbers sequence\n    ( ( ${n} == 2 )) && return $n || return $(prime_fib $((\
    \ $n - 1 ))) && return $n || return $(prime_fib $(( $n - 2 ))) && return $n\n\
    \  else\n    echo 1\n  fi"]
stop_tokens:
- "\n}"
