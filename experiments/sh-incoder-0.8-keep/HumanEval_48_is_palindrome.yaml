name: HumanEval_48_is_palindrome
language: sh
prompt: "#!/bin/bash\n# Checks if given string is a palindrome\n# >>> is_palindrome('')\n\
  # True\n# >>> is_palindrome('aba')\n# True\n# >>> is_palindrome('aaaaa')\n# True\n\
  # >>> is_palindrome('zbcd')\n# False\n#\n# $1 is a string\nis_palindrome() {\n"
tests: "}\n\ncandidate() {\n    is_palindrome \"$@\"\n}\n\nset -e\nrun_test() {\n\
  \    [[ $(candidate \"\") = \"true\" ]]\n    [[ $(candidate \"aba\") = \"true\"\
  \ ]]\n    [[ $(candidate \"aaaaa\") = \"true\" ]]\n    [[ $(candidate \"zbcd\")\
  \ = \"false\" ]]\n    [[ $(candidate \"xywyx\") = \"true\" ]]\n    [[ $(candidate\
  \ \"xywyz\") = \"false\" ]]\n    [[ $(candidate \"xywzx\") = \"false\" ]]\n}\n\n\
  run_test"
completions: ["    local -r string=$1\n    [[ -z \"${string}\" ]] && return 1\n\n\
    \    # ${var//substring/replacement} substitutes all matches of 'substring' with\
    \ 'replacement'\n    # using Bash's built-in regular expression substitution.\n\
    \    [[ $string =~ [[:alpha:]] ]] && return 0\n    [[ $string =~ [[:digit:]] ]]\
    \ && return 0\n    [[ $string =~ [[:lower:]] ]] && return 0\n    [[ $string =~\
    \ [[:upper:]] ]] && return 0\n    [[ $string =~ [[:punct:]] ]] && return 0\n \
    \   [[ $string =~ [[:space:]] ]] && return 0\n    local reverse=${string//([^a-zA-Z0-9])/}\n\
    \    [[ $reverse =~ [[:alpha:]] ]] && return 0\n    [[ $reverse =~ [[:digit:]]\
    \ ]] && return 0\n    [[ $reverse =~ [[:lower:]] ]] && return 0\n    [[ $reverse\
    \ =~ [[:upper:]] ]] && return 0\n    [[ $reverse =~ [[:punct:]] ]] && return 0\n\
    \    [[ $reverse =~ [[:space:]] ]] && return 0\n    local length=\"${#string}\"\
    \n    [[ \"${length}\" -eq 1 ]] && return 1\n\n    # if the string length is odd,\
    \ middle character is also odd\n    [[ \"${length}\" -eq 2 ]] && (( length % 2\
    \ == 1)) && return 0\n\n    # reverse each character and compare\n    local i\n\
    \    for i in $(seq 0 $((length / 2)) )\n    do\n        local c=\"${string:$i:1}\"\
    \n        local r=\"${reverse:$i:1}\"\n        [[ $c -eq $r ]] || return 0\n \
    \   done\n\n    return 1", "\tlocal string=\"$1\"\n\techo \"$string\" | sed 's/./\
    \ /g' | tac | grep -Eq '^\\s*$' > /dev/null", "    local string=$1\n    local\
    \ i=$((${#string}-1))\n    while (( $i )); do\n        [ \"${string:$i:1}\" ==\
    \ \"${string:$(($i-1)):1}\" ] && return 0\n        i=$(( $i - 1 ))\n    done\n\
    \    return 1", "  local STRING=\"$1\"\n  echo \"$STRING\" | rev | cut -c1 | rev",
  "    echo \" $1\"\n    test \"$1\" != \"$1\" && echo \"not a palindrome\"\n    test\
    \ \"$1\" == \"${1,,}\" && echo \"palindrome\"", "    local string=$1\n    [[ \"\
    $string\" =~ $REGEXP_STRING_PALINDROME ]] && return 0\n    return 1", "    local\
    \ str=$1\n\n    local i=${#str}\n    local last\n    local flag=0\n\n    while\
    \ [[ $i -ge 0 ]]; do\n        local c=${str:$i:1}\n\n        if [[ ${str:$((i\
    \ - 1))} == ${str:$i} ]]; then\n            (( flag = 1 ))\n        fi\n\n   \
    \     if [[ ${last} == $c ]]; then\n            (( flag = 1 ))\n        fi\n\n\
    \        if [[ ${flag} == 1 ]]; then\n            return 1\n        fi\n\n   \
    \     (( i = i - 1 ))\n        last=$c\n    done\n\n    return 0", "  echo \"\
    $1\" | rev | sed 's/^.\\{1,\\}$//' | rev", "    local STRING=\"$1\"\n    local\
    \ LENGTH=\"${#STRING}\"\n\n    if [ $LENGTH -eq 0 ]; then return 1; fi\n\n   \
    \ for i in {1..$LENGTH/2};\n    do\n        if [ \"${STRING:$i:1}\" != \"${STRING:$((LENGTH\
    \ - 1 - i)):1}\" ]; then\n            return 0;\n        fi\n    done\n    return\
    \ 1;", '    echo "$1" | rev | cut -c 1- | rev', "  [[ \"$1\" =~ (([[:alpha:]]+)(([[:alpha:]]+))*([[:alpha:]]+))\
    \ ]] || return 1\n  local str=$1\n  local rev=\"\"\n  [[ $str != \"$rev\" ]] &&\
    \ return 1 || return 0\n  local i\n  for ((i=1; i<${#str}; i+=2)); do\n    local\
    \ j\n    [[ \"$rev\" == \"${str:i:1}${str:i+1}\" ]] || return 0\n    [[ \"$rev\"\
    \ == \"${str:i+1:1}${str:i:1}\" ]] || return 0\n    local k\n    for ((k=1; k<${#str};\
    \ k+=3)); do\n      [[ \"$rev\" == \"${str:i+k:1}${str:i-1:1}${str:i+k+1:1}\"\
    \ ]] || return 0\n    done\n    rev=\"${str:i+2:1}${str:i-1:1}\"\n  done\n  return\
    \ 1", "\t[ -z \"$1\" ] || [ $1 -gt 0 ] || [ $1 -lt 100 ] && return 1\n\t[ \"$1\"\
    \ == \"$( echo \"$1\" | rev | cut -c -$(( ${#1} / 2 )) )\" ] || return 1\n\treturn\
    \ 0", "    echo \"$1\" | sed -r 's/(.)/\\1\\1\\1/' | grep -qwFf - && echo \"True\"\
    \ || echo \"False\"", "    declare -i len=${#1#*}\n    declare -i i\n    declare\
    \ -i j\n    declare -r char\n\n    for ((i=0; i<len/2; i++)); do\n        char=${1:i:len}\n\
    \        j=\"${i}\"\n        is_char=\"$( echo ${char} | rev | cut -d ' ' -f1\
    \ )\"\n        [[ \"$is_char\" == \"$char\" ]] && (( ++j))\n    done\n    [ \"\
    $j\" -eq \"$len\" ] && return 0\n    return 1", "    local string=$1\n    local\
    \ len=${#string}\n    local i=0\n    local rev\n    local p\n    \n    while [[\
    \ $i -lt ${len} ]]\n    do\n        rev=${string:$i:$((len-i))}\n        p=${string:$i:$((len-i-1))}\n\
    \        [[ \"$string\" == \"$rev\" ]] && return 0 || (( ++i < len && p != $rev\
    \ && is_palindrome \"${string:$i:$((len-i-1))}\" ) )\n    done\n    return 1",
  '    [[ $1 == $(echo $1|rev) && $1 == $1 ]] && return 0 || return 1', "    [ \"\
    $1\" = \"\" ] && return 1 || [ \"$1\" = \"--help\" ] && return 0\n\n    # Split\
    \ string on white space (space or tab)\n    IFS=$'\\t' read -r -a strarray <<<\
    \ \"$1\"\n\n    # Create a substring from middle and reverse it\n    middle=$(printf\
    \ '%s\\n' \"${strarray[@]:2}\")\n    reverse=$(printf '%s\\n' \"${strarray[@]:0:2}\"\
    )\n\n    # Compare substrings\n    if [ \"${middle}\" = \"${reverse}\" ]\n   \
    \ then\n        return 0\n    else\n        return 1\n    fi", "  local -r input=\"\
    $1\"\n  local -r palindrome=\"${input}\"\n\n  local len=\"${#palindrome}\"\n \
    \ [ \"$len\" -gt 0 ] || return 1\n\n  local first_index\n  first_index=\"$((${#palindrome}-1))\"\
    \n\n  while ((first_index > 0)), ((${#palindrome} > 0)); do\n    local next_index\n\
    \    next_index=\"$((first_index+1))\"\n    local char=\"${palindrome:$first_index:1}\"\
    \n    local next_char=\"${palindrome:$next_index:1}\"\n    [ \"$char\" == \"$next_char\"\
    \ ] || return 0\n    shift \"$((first_index-1))\" ;;\n  done\n  return 1", " \
    \   local x=\"$1\"\n    [[ \"$x\" == \"\" ]] && return 1\n    local y=\"$x\"\n\
    \    [[ \"$y\" == \"$x\" || \"$y\" == \"\" ]] && return 0\n    local i=0\n   \
    \ local c=\"\"\n    local z=\"\"\n    while [ \"$y\" != \"\" ]; do\n        i=$((\
    \ $i + 1 ))\n        c=$c$y\n        y=${y:0:${#y}-1}\n    done\n    for i in\
    \ $(seq 0 $(( ${#c} / 2 ))); do\n        z=$z$c\n        c=${c:0:$(( ${#c} % 2\
    \ ))}\n    done\n    [[ \"$z\" == \"$x\" ]] && return 0\n    return 1", "  local\
    \ rev=\"${1:-}\"\n  [[ $rev == \"\" ]] && return 1 || [[ $rev != \"${rev#????}\"\
    \ ]] && return 0\n  local revrev=\"${rev#????}\"\n  local tail=\"${revrev%????}\"\
    \n  [[ $tail == \"\" ]] && return 1 || [[ $tail != \"${revrev#????}\" ]] && return\
    \ 0\n  local tailtail=\"${tail#????}\"\n  [[ $tailtail == \"\" ]] && return 1\
    \ || [[ $tailtail != \"${revrev#????}\" ]] && return 0\n  [[ $tailtail == $revtail\
    \ ]]"]
stop_tokens:
- "\n}"
