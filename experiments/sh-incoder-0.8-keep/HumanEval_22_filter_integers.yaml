name: HumanEval_22_filter_integers
language: sh
prompt: "#!/bin/bash\n# Filter given list of any python values only for integers\n\
  # >>> filter_integers(['a', 3.14, 5])\n# [5]\n# >>> filter_integers([1, 2, 3, 'abc',\
  \ {}, []])\n# [1, 2, 3]\n#\n# $1 is a space-separated list\nfilter_integers() {\n"
tests: "}\n\ncandidate() {\n    filter_integers \"$@\"\n}\n\nset -e\nrun_test() {\n\
  \    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"4   23.2 9 adasd\") =\
  \ \"4 9\" ]]\n    [[ $(candidate \"3 c 3 3 a b\") = \"3 3 3\" ]]\n}\n\nrun_test"
completions: ["  local IFS=$1\n  shift\n  IFS=\" \" # use space as separator\n  local\
    \ filtered=()\n  local element\n  local len=${#IFS}\n  local idx\n  for idx=0;\
    \ idx<${#1}; idx=$((idx+1)) && [ \"$idx\" -lt \"$len\" ]; then\n    element=${1[idx]}\n\
    \    if ! [[ $element =~ ^[0-9]+$ ]]; then\n      filtered+=(\"${element}\")\n\
    \    fi\n  done\n  unset IFS\n  echo \"${filtered[@]}\"", "    local x\n    for\
    \ x in $1; do\n        if [[ $x =~ ^[0-9]+$ ]]; then\n            echo $x\n  \
    \      fi\n    done", "    local arg\n    for arg; do\n        case \"$arg\" in\n\
    \            -*)\n                local IFS=\"-\" arr\n                IFS=' '\
    \ arr=($arg)\n                local len=${#arr[@]}\n                echo \"${arr[@]}\"\
    \ | xargs -I{} echo -ne \"{} \"\n                ;;\n            *)\n        \
    \        if [[ $arg =~ ^-?[0-9]+$ ]]; then\n                    echo \"$arg\"\n\
    \                else\n                    echo \"$arg\" | xargs -I{} echo -ne\
    \ \"{} \"\n                fi\n                ;;\n        esac\n    done", " \
    \   IFS=$'\\t' read -r -a array <<<\"$1\"\n    local filter=\"${array[1]}\"\n\
    \    local value=\"${array[2]}\"\n    local out\n    if [[ ${value} =~ ^[0-9]+$\
    \ ]]; then\n        out=(\"${array[@]:2}\")\n    else\n        out=()\n    fi\n\
    \    printf '%s\\n' \"${out[@]}\"", "  local IFS=$1\n  shift\n  local RESULT\n\
    \  RESULT=()\n  for i in \"$@\"; do\n    if [[ $i =~ ^(-?[0-9]+)$ ]]; then\n \
    \     RESULT+=(\"$i\")\n    fi\n  done\n  echo \"${RESULT[@]}\"", "    local integers=$1\n\
    \    integers=( $integers )\n    integers=( \"${integers[@]}\" )\n    integers=(\
    \ \"${integers[*]}\" )\n    integers=( \"${integers[@]//[^0-9]}\" )\n\n    for\
    \ index in \"${!integers[@]}\"; do\n        integers[index]=${integers[index]}\n\
    \    done\n\n    local filtered=${#integers[@]}\n    for index in \"${!integers[@]}\"\
    ; do\n        if [[ $integers[index] =~ ^-?[0-9]+$ ]]; then\n            filtered=${filtered}\n\
    \        else\n            integers[index]=\n        fi\n    done\n\n    integers=(\
    \ \"${integers[@]}\" )\n    echo \"${integers[@]}\"", "  echo \"$1\" | awk '{for\
    \ (i=1; i<=NF; i+=1) if ($i ~ /^[0-9]+$/) print $i}'", "  local IFS=$1\n  shift\n\
    \  echo \"$*\" | grep \"^[0-9]*$\" | grep -v -E '^-+$' | grep -v -E '^+-+$' 2>/dev/null\
    \ \\\n    | sed 's/^[ \\t]*//' | sort -u", "  local IFS=$'  '\n  # If $1 is a\
    \ string, expand it and return\n  local IFS=$'  '  # If $1 is a string, expand\
    \ it and return\n  local output\n  output=$(echo \"$1\" | sed -e 's/,/\" \"/g'\
    \ -e 's/^\"//' -e 's/\"$//')\n  # echo \"$output\" | sed -E 's/^([^ ]* +){3}/\\\
    1/g'\n  # echo \"$output\" | sed -E 's/^([^ ]* +){3}/\\1/g'\n  echo \"$output\"",
  "    local values=$1\n    local out\n\n    # If the list is empty, return empty\
    \ list\n    if [ -z \"$values\" ]; then\n        return 0\n    fi\n\n    # Convert\
    \ list of strings to list of integers\n    # >>> map(int, ['a', 3.14, 5])\n  \
    \  # [1, 2, 3, 5]\n    values=( $values )\n    # Filter out non-integer values\n\
    \    # >>> map(int, filter(int, ['a', 3.14, 5]))\n    # [1, 2, 3, 5]\n    out=()\n\
    \    for i in ${values[@]}; do\n        if [[ $i =~ ^-?[0-9]+$ ]]; then\n    \
    \        out+=( $i )\n        fi\n    done\n\n    # Return filtered list\n   \
    \ return ${out[@]}", "  local list=\"$1\"\n  local int\n  IFS=', ' read -r -a\
    \ list <<< \"$list\"\n  for int in \"${list[@]}\"; do\n    if [[ $int =~ ^[0-9]+$\
    \ ]]; then\n      echo \"$int\"\n    fi\n  done", "    local integers\n    integers=($(echo\
    \ \"$1\" | grep \"^[0-9]+$\"))\n    echo \"${integers[@]}\"", "  local items=$1\n\
    \  local list=\"$2\"\n  list=$( echo $list | sed 's/^ *//g' | tr -d '\\n' )\n\
    \  list=$( echo $list | sed 's/^ *//g' | tr -d '\\n' )\n  list=$( echo $list |\
    \ sed 's/^ *//g' | tr -d '\\n' )\n  list=$( echo $list | sed 's/^ *//g' | tr -d\
    \ '\\n' )\n  list=$( echo $list | sed 's/^ *//g' | tr -d '\\n' )\n  list=$( echo\
    \ $list | sed 's/^ *//g' | tr -d '\\n' )\n  list=$( echo $list | sed 's/^ *//g'\
    \ | tr -d '\\n' )\n  list=$( echo $list | sed 's/^ *//g' | tr -d '\\n' )\n  list=$(\
    \ echo $list | sed 's/^ *//g' | tr -d '\\n' )\n  list=$( echo $list | sed 's/^\
    \ *//g' | tr -d '\\n' )\n  list=$( echo $list | sed 's/^ *//g' | tr -d '\\n' )\n\
    \  list=$( echo $list | sed 's/^ *//g' | tr -d '\\n' )\n  list=$( echo $list |\
    \ sed 's/^ *//g' | tr -d '\\n' )\n  list=$( echo $list | sed 's/^ *//g' | tr -d\
    \ '\\n' )\n  list=$( echo $list | sed 's/^ *//g' | tr -d '\\n' )\n  list=$( echo\
    \ $list | sed 's/^ *//g' | tr -d '\\n' )\n  list=$( echo $list | sed 's/^ *//g'\
    \ | tr -d '\\n' )\n  list=$( echo $list | sed 's/^ *//g' | tr -d '\\n' )\n  list=$(\
    \ echo $list | sed 's/^ *//g' | tr -d '\\n' )\n  list=$( echo $list | sed 's/^\
    \ *//g' | tr -d '\\n' )\n  list=$( echo $list | sed 's/^ *//g' | tr -d '\\n' )\n\
    \  list=$( echo $list | sed 's/^ *//g' | tr -d '\\n' )\n  list=$( echo $list |\
    \ sed 's/^ *//g' | tr", "    local item=\"$1\"\n    # $IFS holds the current input\
    \ field separator, $IFS defaults to $' \\t\\n'\n    local IFS=\"$2\"\n    # $1\
    \ is now the complete first argument\n    local first_integer=\"$1\"\n    local\
    \ i\n    # First try a quick regular expression\n    if ! [[ $item =~ ^[+-]?[[:digit:]]+$\
    \ ]]; then\n        # No match? Return original list\n        echo \"$item\"\n\
    \        return\n    fi\n\n    # No whitespace? No problem.\n    if [[ \"$item\"\
    \ == *\"[[:space:]]\" ]]; then\n        echo \"$item\"\n        return\n    fi\n\
    \n    # First item is whitespace, so remove it\n    first_integer=\"${first_integer//[[:space:]]/}\"\
    \n\n    for i in \"${item}\"; do\n        # Skip non-integers? No problem.\n \
    \       if [[ \"$i\" != [[:digit:]] ]]; then\n            # Return original list\n\
    \            echo \"$item\"\n            return\n        fi\n    done\n\n    #\
    \ Strip spaces in front and end of list items\n    first_integer=\"$(echo \"$first_integer\"\
    \ | sed 's/^[[:space:]]//' | sed 's/[[:space:]]$//')\"\n\n    # Return integer\
    \ list\n    echo \"$first_integer\"", "    local IFS=$1; shift\n    local i; i=1;\
    \ while (( i<$# )); do case \"$1\" in\n        -*) echo \"Error $1 is for integers\
    \ only\"; return 1; esac; i=$((i+1)); done\n    echo $(( $# ))", "  # shellcheck\
    \ disable=SC2034\n  local args integer index integer output integer output2 \\\
    \n    integer output3 integers=()\n  # shellcheck disable=SC2034\n  args=(\"$@\"\
    )\n  for index in \"${!args[@]}\"; do\n    integer=\"${args[$index]}\"\n    output3=0\n\
    \    output2=0\n    output=0\n    integers=()\n    for integer in \"$integer\"\
    ; do\n      integers=(\"${integers[@]}\" \"$integer\")\n    done\n    for integer\
    \ in \"${integers[@]}\"; do\n      if [[ ${integer} -eq ${integer}e ]]; then\n\
    \        output3=1\n      elif [[ ${integer} -eq ${integer}p ]]; then\n      \
    \  output2=1\n      elif [[ ${integer} -eq ${integer}f ]]; then\n        output2=1\n\
    \      else\n        output=1\n      fi\n    done\n    if [[ $output3 -eq 1 ]]\
    \ && [[ $output2 -eq 1 ]] && [[ $output -eq 1 ]]; then\n      echo \"$index\"\n\
    \    fi\n  done", "    local integer non_integer non_positive\n    integer=()\n\
    \    non_integer=()\n    non_positive=()\n    local item\n    for item; do\n \
    \       case \"$item\" in\n            ${non_integer//[^-0-9]}*)\n           \
    \     non_integer+=(\"$item\")\n                ;;\n            *)\n         \
    \       integer+=(\"$item\")\n                ;;\n        esac\n    done\n   \
    \ set -- \"$integer[@]\"\n    if [[ -n \"$1\" ]]; then\n        integer+=(\"$1\"\
    )\n    fi\n    set -- \"$non_integer[@]\"\n    if [[ -n \"$1\" ]]; then\n    \
    \    non_integer+=(\"$1\")\n    fi\n    set -- \"$non_positive[@]\"\n    if [[\
    \ -n \"$1\" ]]; then\n        non_positive+=(\"$1\")\n    fi\n    set -- \"$integer[@]\"\
    \n    integer=(\"${integer[@]/-[0-9][0-9]}\")\n    integer=(\"${integer[@]/-/}\"\
    )\n    integer=(\"${integer[@]/-[0-9]/}\")\n    integer=(\"${integer[@]/\\+-[0-9]/}\"\
    )\n    non_integer=(\"${non_integer[@]/-[0-9][0-9]}\")\n    non_integer=(\"${non_integer[@]/-/}\"\
    )\n    non_integer=(\"${non_integer[@]/-[0-9]/}\")\n    non_integer=(\"${non_integer[@]/\\\
    +-[0-9]/}\")\n    integer=(\"${integer[@]/[0-9][0-9]/}\")\n    integer=(\"${integer[@]/[0-9]/}\"\
    )\n    integer=(\"${integer[@]/[0-9][0-9]/}\")\n    integer=(\"${integer[@]/[0-9]/}\"\
    )\n    non_integer=(\"${non_integer[@]/[0-9][0-9]/}\")\n    non_integer=(\"${non_integer[@]/[0-9]/}\"\
    )\n    non_integer=(\"${non_integer[@]/[0-9][0-9]/}\")\n    non_integer=(\"${non_integer[@]/[0-9]/}\"\
    )\n    non_integer=(\"${non_integer[@]/[0-9]/}\")\n    non_positive=(\"${non_positive[@]/[0-9][0-9]/}\"\
    )\n    non_positive=(\"${non_positive[@]/[0-9]/}\")\n    non_positive=(\"${non_positive[@]/[0-9][0-9]/}\"\
    )\n    non_positive=(\"${non_positive[@]/[0-9]/}\")\n    non_positive=(\"${non_positive[@]/[0-9][0-9]/}\"\
    )\n    non_positive=(\"${non_positive[@]/[0-9]/}\")\n    integer=(\"${integer[@]//[0-9]-[0-9]/}\"\
    )\n    ", '    echo "$1" | tr " " "\n" | grep -E "^\d+$" | sort -n | uniq', " \
    \   local items=(\"$@\")\n    local integer integer integers integers\n\n    integers=()\n\
    \    for item in \"${items[@]}\"; do\n        integer+=$(( ${item} ))\n      \
    \  integers+=($integer)\n    done\n    echo \"${integers[@]}\"", "    local _list=\"\
    $1\"\n    _filter_integers"]
stop_tokens:
- "\n}"
