language: sh
name: HumanEval_17_parse_music
results:
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string representing musical\
    \ notes in a special ASCII format.\n# Your task is to parse this string and return\
    \ list of integers corresponding to how many beats does each\n# not last.\n# Here\
    \ is a legend:\n# 'o' - whole note, lasts four beats\n# 'o|' - half note, lasts\
    \ two beats\n# '.|' - quater note, lasts one beat\n# >>> parse_music('o o| .|\
    \ o| o| .| .| .| .| o o')\n# [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n#\n# $1 is a string\n\
    parse_music() {\n  local str=$1\n\n  # parse each note and count number of beats\n\
    \  # for instance '.' is '.|' and '.|' is 'o.|' so we should add 1 to the sum\n\
    \  local i=0\n  local sum=0\n\n  while [ $i -lt ${#str} ]; do\n    local c=${str[$i]}\n\
    \    case \"${c}\" in\n      'o' ) sum=$((sum + 4)); i=$(( i + 1 )); break;;\n\
    \      'o|' ) sum=$((sum + 2)); i=$(( i + 1 )); break;;\n      '.|' ) sum=$((sum\
    \ + 1)); i=$(( i + 1 )); break;;\n      * ) break;;\n    esac\n  done\n\n  # print\
    \ results\n  printf \"%s\\n\" \"${str[@]:0:i}\"\n  printf \"%s\\n\" \"${str[@]:i}\"\
    \n  printf \"%s\\n\" \"${str[@]:i+1}\"\n\n  # return sum\n  printf \"%s\\n\" \"\
    ${sum}\"\n}\n\ncandidate() {\n    parse_music \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"o o o o\") = \"\
    4 4 4 4\" ]]\n    [[ $(candidate \".| .| .| .|\") = \"1 1 1 1\" ]]\n    [[ $(candidate\
    \ \"o| o| .| .| o o o o\") = \"2 2 1 1 4 4 4 4\" ]]\n    [[ $(candidate \"o| .|\
    \ o| .| o o| o o|\") = \"2 1 2 1 4 2 4 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660054664
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string representing musical\
    \ notes in a special ASCII format.\n# Your task is to parse this string and return\
    \ list of integers corresponding to how many beats does each\n# not last.\n# Here\
    \ is a legend:\n# 'o' - whole note, lasts four beats\n# 'o|' - half note, lasts\
    \ two beats\n# '.|' - quater note, lasts one beat\n# >>> parse_music('o o| .|\
    \ o| o| .| .| .| .| o o')\n# [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n#\n# $1 is a string\n\
    parse_music() {\n  local music_string=$1\n  local music_array\n  local music_arraysize\n\
    \  music_arraysize=$(echo \"$music_string\" | wc -w)\n  music_array=($(echo \"\
    $music_string\" | tr '\\0' '\\n'))\n  local music_offset=0\n  local music_lastbeat\n\
    \  local music_lastnote\n  local music_lastbeatlen\n  local music_lastnotelen\n\
    \  local music_lastnotecount\n  local music_notlast\n  local music_notlastlen\n\
    \  local music_notlastcount\n  local music_notlastcount2\n  local music_notlastcount3\n\
    \  local music_notlastcount4\n  local music_notlastcount5\n  local music_notlastcount6\n\
    \  local music_notlastcount7\n  local music_notlastcount8\n  local music_notlastcount9\n\
    \  local music_notlastcount10\n  local music_notlastcount11\n  local music_notlastcount12\n\
    \  local music_notlastcount13\n  local music_notlastcount14\n  local music_notlastcount15\n\
    \  local music_notlastcount16\n  local music_notlastcount17\n  local music_notlastcount18\n\
    \  local music_notlastcount19\n  local music_notlastcount20\n  local music_notlastcount21\n\
    \  local music_notlastcount22\n  local music_notlastcount23\n  local music_notlastcount24\n\
    \  local music_notlastcount25\n  local music_notlastcount26\n  local music_notlastcount27\n\
    \  local music_notlastcount28\n  local music_notlastcount29\n  local music_notlastcount30\n\
    \  local music_notlastcount31\n  local music_notlastcount32\n  local music_notlastcount33\n\
    \  local music_notlastcount34\n  local music_notlastcount35\n  local music_notlastcount36\n\
    \  local music_notlastcount37\n  local music_notlastcount38\n  local music_notlastcount39\n\
    \  local music_notlastcount40\n  local music_notlastcount41\n  local music_notlastcount42\n\
    \  local music_notlastcount43\n  local music_notlastcount44\n}\n\ncandidate()\
    \ {\n    parse_music \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\"\
    ) = \"\" ]]\n    [[ $(candidate \"o o o o\") = \"4 4 4 4\" ]]\n    [[ $(candidate\
    \ \".| .| .| .|\") = \"1 1 1 1\" ]]\n    [[ $(candidate \"o| o| .| .| o o o o\"\
    ) = \"2 2 1 1 4 4 4 4\" ]]\n    [[ $(candidate \"o| .| o| .| o o| o o|\") = \"\
    2 1 2 1 4 2 4 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660054664
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string representing musical\
    \ notes in a special ASCII format.\n# Your task is to parse this string and return\
    \ list of integers corresponding to how many beats does each\n# not last.\n# Here\
    \ is a legend:\n# 'o' - whole note, lasts four beats\n# 'o|' - half note, lasts\
    \ two beats\n# '.|' - quater note, lasts one beat\n# >>> parse_music('o o| .|\
    \ o| o| .| .| .| .| o o')\n# [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n#\n# $1 is a string\n\
    parse_music() {\n  local music=$1\n  local music_len=${#music}\n  local beat_len=${music_len\
    \ % 4}\n  local music_halflen=$((music_len / 4))\n  local music_notes=()\n  local\
    \ music_notes_length=()\n  local music_notes_count=()\n  local music_notes_last_beat=()\n\
    \  local music_notes_last_beat_length=()\n  local music_notes_last_beat_count=()\n\
    \  local music_notes_next_beat=()\n  local music_notes_next_beat_length=()\n \
    \ local music_notes_next_beat_count=()\n  local music_notes_next_beat_last_beat=()\n\
    \  local music_notes_next_beat_last_beat_length=()\n  local music_notes_next_beat_last_beat_count=()\n\
    \  local music_notes_last_beat_next_beat=()\n  local music_notes_last_beat_next_beat_length=()\n\
    \  local music_notes_last_beat_next_beat_count=()\n  local music_notes_last_beat_next_beat_last_beat=()\n\
    \  local music_notes_last_beat_next_beat_last_beat_length=()\n  local music_notes_last_beat_next_beat_last_beat_count=()\n\
    \  local music_notes_last_beat_next_beat_last_beat_next_beat=()\n  local music_notes_last_beat_next_beat_last_beat_next_beat_length=()\n\
    \  local music_notes_last_beat_next_beat_last_beat_next_beat_count=()\n  local\
    \ music_notes_last_beat_next_beat_last_beat_next_beat_last_beat=()\n  local music_notes_last_beat_next_beat_last_beat_next_beat_last_beat_length=()\n\
    \  local music_notes_last_beat_next_beat_last_beat_next_beat_last_beat_count=()\n\
    \  local music_notes_last_beat_next_beat_last_beat_next_beat_last_beat_next_beat_last_beat=()\n\
    \  local music_notes_last_beat_next_beat_last_beat_next_beat_last_beat_next_beat_last_beat_length=()\n\
    \  local music_notes_last_beat_next_beat_last_beat_next_beat_last_beat_next_beat_last_beat_count=()\n\
    \n  local music_notes_next_beat_last_be\n}\n\ncandidate() {\n    parse_music \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate\
    \ \"o o o o\") = \"4 4 4 4\" ]]\n    [[ $(candidate \".| .| .| .|\") = \"1 1 1\
    \ 1\" ]]\n    [[ $(candidate \"o| o| .| .| o o o o\") = \"2 2 1 1 4 4 4 4\" ]]\n\
    \    [[ $(candidate \"o| .| o| .| o o| o o|\") = \"2 1 2 1 4 2 4 2\" ]]\n}\n\n\
    run_test"
  status: Exception
  stderr: '/tmp/tmpbgwqvl9d.sh: line 16: beat_len=${music_len % 4}: bad substitution

    /tmp/tmpbgwqvl9d.sh: line 16: beat_len=${music_len % 4}: bad substitution

    '
  stdout: ''
  timestamp: 1660054664
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string representing musical\
    \ notes in a special ASCII format.\n# Your task is to parse this string and return\
    \ list of integers corresponding to how many beats does each\n# not last.\n# Here\
    \ is a legend:\n# 'o' - whole note, lasts four beats\n# 'o|' - half note, lasts\
    \ two beats\n# '.|' - quater note, lasts one beat\n# >>> parse_music('o o| .|\
    \ o| o| .| .| .| .| o o')\n# [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n#\n# $1 is a string\n\
    parse_music() {\n    # Convert input string to array of ints\n    music_str=$1\n\
    \    music_str=${music_str// /}\n    music_str=${music_str//\\#/ }\n    music_str=${music_str//\\\
    % }\n    music_str=${music_str//\\* }\n    music_str=${music_str//\\( }\n    music_str=${music_str//\\\
    ) }\n    music_str=${music_str//\\` }\n    music_str=${music_str//\\- }\n    music_str=${music_str//\\\
    - }\n    music_str=${music_str//\\# }\n    music_str=${music_str//\\# }\n    music_str=${music_str//\\\
    % }\n    music_str=${music_str//\\% }\n    music_str=${music_str//\\* }\n    music_str=${music_str//\\\
    * }\n    music_str=${music_str//\\( }\n    music_str=${music_str//\\( }\n    music_str=${music_str//\\\
    # }\n    music_str=${music_str//\\# }\n    music_str=${music_str//\\# }\n    music_str=${music_str//\\\
    % }\n    music_str=${music_str//\\% }\n    music_str=${music_str//\\% }\n    music_str=${music_str//\\\
    # }\n    music_str=${music_str//\\# }\n    music_str=${music_str//\\% }\n    music_str=${music_str//\\\
    % }\n    music_str=${music_str//\\% }\n    music_str=${music_str//\\% }\n    music_str=${music_str//\\\
    % }\n    music_str=${music_str//\\% }\n    music_str=${music_str//\\% }\n    music_str=${music_str//\\\
    % }\n    music_str=${music_str//\\% }\n    music_str=${music_str//\\% }\n    music_str=${music_str//\\\
    % }\n    music_str=${music_str//\\% }\n    music_str=${music_str//\\% }\n    music_\n\
    }\n\ncandidate() {\n    parse_music \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"o o o o\") = \"4 4 4 4\" ]]\n\
    \    [[ $(candidate \".| .| .| .|\") = \"1 1 1 1\" ]]\n    [[ $(candidate \"o|\
    \ o| .| .| o o o o\") = \"2 2 1 1 4 4 4 4\" ]]\n    [[ $(candidate \"o| .| o|\
    \ .| o o| o o|\") = \"2 1 2 1 4 2 4 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpi6f07_mt.sh: line 54: music_: command not found

    /tmp/tmpi6f07_mt.sh: line 54: music_: command not found

    '
  stdout: ''
  timestamp: 1660054664
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string representing musical\
    \ notes in a special ASCII format.\n# Your task is to parse this string and return\
    \ list of integers corresponding to how many beats does each\n# not last.\n# Here\
    \ is a legend:\n# 'o' - whole note, lasts four beats\n# 'o|' - half note, lasts\
    \ two beats\n# '.|' - quater note, lasts one beat\n# >>> parse_music('o o| .|\
    \ o| o| .| .| .| .| o o')\n# [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n#\n# $1 is a string\n\
    parse_music() {\n    local music=$1\n    local music_counter=0\n\n    # find every\
    \ note in input\n    local notes=$(echo $music | sed \"s/[^.]//g\")\n\n    for\
    \ notes in $notes\n    do\n        music_counter=$((music_counter + ${notes//[^0-9]}/4))\n\
    \    done\n\n    # print result\n    echo $music_counter\n}\n\ncandidate() {\n\
    \    parse_music \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\") =\
    \ \"\" ]]\n    [[ $(candidate \"o o o o\") = \"4 4 4 4\" ]]\n    [[ $(candidate\
    \ \".| .| .| .|\") = \"1 1 1 1\" ]]\n    [[ $(candidate \"o| o| .| .| o o o o\"\
    ) = \"2 2 1 1 4 4 4 4\" ]]\n    [[ $(candidate \"o| .| o| .| o o| o o|\") = \"\
    2 1 2 1 4 2 4 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660054664
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string representing musical\
    \ notes in a special ASCII format.\n# Your task is to parse this string and return\
    \ list of integers corresponding to how many beats does each\n# not last.\n# Here\
    \ is a legend:\n# 'o' - whole note, lasts four beats\n# 'o|' - half note, lasts\
    \ two beats\n# '.|' - quater note, lasts one beat\n# >>> parse_music('o o| .|\
    \ o| o| .| .| .| .| o o')\n# [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n#\n# $1 is a string\n\
    parse_music() {\n  local note=$1\n  echo \"$note\" | awk '{print $1}' | sed 's/\\\
    (.\\)/\\1 /g' | sed 's/\\(.\\)/\\1 /g' | sed 's/\\(.\\)/\\1 /g' | sed 's/\\(.\\\
    )/\\1 /g' | sed 's/\\(.\\)/\\1 /g' | sed 's/\\(.\\)/\\1 /g' | sed 's/\\(.\\)/\\\
    1 /g'\n}\n\ncandidate() {\n    parse_music \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"o o o o\") = \"4 4 4\
    \ 4\" ]]\n    [[ $(candidate \".| .| .| .|\") = \"1 1 1 1\" ]]\n    [[ $(candidate\
    \ \"o| o| .| .| o o o o\") = \"2 2 1 1 4 4 4 4\" ]]\n    [[ $(candidate \"o| .|\
    \ o| .| o o| o o|\") = \"2 1 2 1 4 2 4 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660054664
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string representing musical\
    \ notes in a special ASCII format.\n# Your task is to parse this string and return\
    \ list of integers corresponding to how many beats does each\n# not last.\n# Here\
    \ is a legend:\n# 'o' - whole note, lasts four beats\n# 'o|' - half note, lasts\
    \ two beats\n# '.|' - quater note, lasts one beat\n# >>> parse_music('o o| .|\
    \ o| o| .| .| .| .| o o')\n# [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n#\n# $1 is a string\n\
    parse_music() {\n    local music=$1\n    # empty string represents whole note\n\
    \    local notes=()\n    for note in $music; do\n        notes+=( $( expr $note\
    \ : '^\\(\\?\\([ao|\\.]\\)\\?\\)$' ) )\n    done\n    return ${notes[@]}\n}\n\n\
    candidate() {\n    parse_music \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"\") = \"\" ]]\n    [[ $(candidate \"o o o o\") = \"4 4 4 4\" ]]\n    [[ $(candidate\
    \ \".| .| .| .|\") = \"1 1 1 1\" ]]\n    [[ $(candidate \"o| o| .| .| o o o o\"\
    ) = \"2 2 1 1 4 4 4 4\" ]]\n    [[ $(candidate \"o| .| o| .| o o| o o|\") = \"\
    2 1 2 1 4 2 4 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660054664
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string representing musical\
    \ notes in a special ASCII format.\n# Your task is to parse this string and return\
    \ list of integers corresponding to how many beats does each\n# not last.\n# Here\
    \ is a legend:\n# 'o' - whole note, lasts four beats\n# 'o|' - half note, lasts\
    \ two beats\n# '.|' - quater note, lasts one beat\n# >>> parse_music('o o| .|\
    \ o| o| .| .| .| .| o o')\n# [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n#\n# $1 is a string\n\
    parse_music() {\n  local music=$1\n  local output=$(echo $music | tr 'o|.|' 'o|\
    \ |')\n  local outputs=($output)\n\n  outputs=()\n\n  for symbol in \"${outputs[@]}\"\
    ; do\n    if [[ \"$symbol\" == \"o\" ]];then\n      outputs+=(4)\n    elif [[\
    \ \"$symbol\" == \"o|\" ]];then\n      outputs+=(2)\n    elif [[ \"$symbol\" ==\
    \ \".|\" ]];then\n      outputs+=(1)\n    fi\n  done\n\n  echo $outputs\n}\n\n\
    candidate() {\n    parse_music \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"\") = \"\" ]]\n    [[ $(candidate \"o o o o\") = \"4 4 4 4\" ]]\n    [[ $(candidate\
    \ \".| .| .| .|\") = \"1 1 1 1\" ]]\n    [[ $(candidate \"o| o| .| .| o o o o\"\
    ) = \"2 2 1 1 4 4 4 4\" ]]\n    [[ $(candidate \"o| .| o| .| o o| o o|\") = \"\
    2 1 2 1 4 2 4 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660054664
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string representing musical\
    \ notes in a special ASCII format.\n# Your task is to parse this string and return\
    \ list of integers corresponding to how many beats does each\n# not last.\n# Here\
    \ is a legend:\n# 'o' - whole note, lasts four beats\n# 'o|' - half note, lasts\
    \ two beats\n# '.|' - quater note, lasts one beat\n# >>> parse_music('o o| .|\
    \ o| o| .| .| .| .| o o')\n# [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n#\n# $1 is a string\n\
    parse_music() {\n    local string=\"${1}\"\n    local notes=()\n    local last_note\n\
    \    local last_time\n    local note_size\n    local last_beat\n    local next_beat\n\
    \    local beat_size\n    local next_beat_size\n    local duration\n    local\
    \ beat\n\n    # Fill up notes array\n    while read -n 1 note; do\n        notes+=(\"\
    ${note}\")\n    done <<< \"$string\"\n\n    # Calculate note size\n    note_size=${#notes[@]}\n\
    \    beat_size=${note_size}\n\n    # Calculate number of beats\n    for note in\
    \ ${notes[@]}; do\n        duration=0\n        beat=0\n        while [[ \"${note:$beat_size:1}\"\
    \ == \".\" ]]; do\n            beat+=1\n            duration=$((duration+1))\n\
    \            note=${note:0:$beat_size}\n        done\n        if [[ \"${note:$beat_size:1}\"\
    \ == \"|\" ]]; then\n            duration=$((duration+1))\n            beat+=1\n\
    \        fi\n        notes[$note]=$((beat*duration))\n    done\n    \n    # Sort\
    \ notes in ascending order of last beat\n    notes=( ${notes[@]} ) \n    sort_notes=(\
    \ ${notes[@]} )\n    for i in \"${!sort_notes[@]}\"; do\n        note=\"${sort_notes[$i]}\"\
    \n        note_size=\"${#note}\"\n        last_note=\"${note:$note_size-1:1}\"\
    \n        last_time=\"${note:$note_size:1}\"\n        last_beat=\"${note:0:$note_size}\"\
    \n        \n        next_beat_size=\"$((note_size+1))\"\n        next_beat=\"\
    ${note:$next_beat_size:1}\"\n        \n        duration=0\n        while [[ \"\
    ${next_beat:$next_beat_size:1}\" == \"|\" ]]; do\n            next_beat_size=\"\
    $((next_beat_size+1))\"\n            next_beat=\"${next_beat:0:$next_beat_size}\"\
    \n        done\n        \n        beat=0\n        while [[ \"${next_beat:$next_beat_size:1}\"\
    \ == \".\" ]]; do\n            beat+=1\n            next_beat_size=\"$((next_beat_size+1))\"\
    \n            next_beat=\"${next_beat:0:$next_beat_size}\"\n        done\n   \
    \     \n        notes[$note]=$((beat*duration))\n    done\n\n    # Return list\
    \ of number of beats\n    echo \"${notes[@]}\"\n}\n\ncandidate() {\n    parse_music\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\") = \"\" ]]\n    [[\
    \ $(candidate \"o o o o\") = \"4 4 4 4\" ]]\n    [[ $(candidate \".| .| .| .|\"\
    ) = \"1 1 1 1\" ]]\n    [[ $(candidate \"o| o| .| .| o o o o\") = \"2 2 1 1 4\
    \ 4 4 4\" ]]\n    [[ $(candidate \"o| .| o| .| o o| o o|\") = \"2 1 2 1 4 2 4\
    \ 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660054664
- exit_code: 2
  program: "#!/bin/bash\n# Input to this function is a string representing musical\
    \ notes in a special ASCII format.\n# Your task is to parse this string and return\
    \ list of integers corresponding to how many beats does each\n# not last.\n# Here\
    \ is a legend:\n# 'o' - whole note, lasts four beats\n# 'o|' - half note, lasts\
    \ two beats\n# '.|' - quater note, lasts one beat\n# >>> parse_music('o o| .|\
    \ o| o| .| .| .| .| o o')\n# [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n#\n# $1 is a string\n\
    parse_music() {\n    local music_string=\"$1\"\n    local music_notes=$(echo \"\
    $music_string\" | cut -c1-5)\n    local music_beats=$(echo \"$music_string\" |\
    \ cut -c6-10)\n    local music_rest=$(echo \"$music_string\" | cut -c4-$music_beats)\n\
    \    local music_notes_array=()\n    for note in $music_notes; do\n        case\
    \ \"$note\" in\n        'o')\n            local music_notes_array+=(\"o\")\n \
    \           ;;\n        'o|')\n            local music_notes_array+=(\"o|\")\n\
    \            ;;\n        '.|')\n            local music_notes_array+=(\".|\")\n\
    \            ;;\n        esac\n    done\n    local music_beats_array=()\n    for\
    \ beat in $music_beats; do\n        case \"$beat\" in\n        'o')\n        \
    \    local music_beats_array+=(\"o\")\n            ;;\n        'o|')\n       \
    \     local music_beats_array+=(\"o|\")\n            ;;\n        '.|')\n     \
    \       local music_beats_array+=(\".|\")\n            ;;\n        esac\n    done\n\
    \    local music_rest_array=()\n    for rest in $music_rest; do\n        case\
    \ \"$rest\" in\n        'o')\n            local music_rest_array+=(\"o\")\n  \
    \          ;;\n        'o|')\n            local music_rest_array+=(\"o|\")\n \
    \           ;;\n        '.|')\n            local music_rest_array+=(\".|\")\n\
    \            ;;\n        esac\n    done\n    local music_notes_array_count=0\n\
    \    local music_beats_array_count=0\n    local music_rest_array_count=0\n   \
    \ local music_notes_array_sum=0\n    local music_beats_array_sum=0\n    local\
    \ music_rest_array_sum=0\n    for note in ${music_notes_array[@]}; do\n      \
    \  music_notes_array_count=$((music_notes_array_count + 1))\n        case \"$note\"\
    \ in\n        'o')\n            music_notes_array_sum=$((music_notes_array_sum\
    \ + 4))\n            ;;\n        'o|')\n            music_notes_array_sum=$((music_notes_array_sum\
    \ + 2))\n            ;;\n        '.|')\n            music_notes_array_sum=$((music_notes_array_sum\
    \ + 1))\n\n}\n\ncandidate() {\n    parse_music \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"o o o o\") = \"\
    4 4 4 4\" ]]\n    [[ $(candidate \".| .| .| .|\") = \"1 1 1 1\" ]]\n    [[ $(candidate\
    \ \"o| o| .| .| o o o o\") = \"2 2 1 1 4 4 4 4\" ]]\n    [[ $(candidate \"o| .|\
    \ o| .| o o| o o|\") = \"2 1 2 1 4 2 4 2\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp3nw1mqmf.sh: line 78: syntax error near unexpected token `}''

    /tmp/tmp3nw1mqmf.sh: line 78: `}''

    '
  stdout: ''
  timestamp: 1660054664
- exit_code: 2
  program: "#!/bin/bash\n# Input to this function is a string representing musical\
    \ notes in a special ASCII format.\n# Your task is to parse this string and return\
    \ list of integers corresponding to how many beats does each\n# not last.\n# Here\
    \ is a legend:\n# 'o' - whole note, lasts four beats\n# 'o|' - half note, lasts\
    \ two beats\n# '.|' - quater note, lasts one beat\n# >>> parse_music('o o| .|\
    \ o| o| .| .| .| .| o o')\n# [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n#\n# $1 is a string\n\
    parse_music() {\n  # Your code here\n  # example: echo $1 | wc -w\n  local input=$1\n\
    \  local len=${#input}\n  local last\n\n  local result\n\n  if [ $len -eq 0 ]\
    \ ; then\n    echo 0\n    return\n  fi\n\n  if [ $len -gt 11 ] ; then\n    echo\
    \ 0 # this should not happen\n    return\n  fi\n\n  result=0\n  last=${input:0:1}\n\
    \n  # check for 'o|' and add two if not present\n  case $last in o|.) ;; *) result=$((result+2))\
    \ ;; *) result=$((result+4)) ;; *) result=$((result+1)) ;; *) result=$((result+1))\
    \ ;; *) result=$((result+1)) ;; *) result=$((result+1)) ;; *) result=$((result+1))\
    \ ;; *) result=$((result+1)) ;; *) result=$((result+1)) ;; *) result=$((result+1))\
    \ ;; *) result=$((result+1)) ;; *) result=$((result+1)) ;; *) result=$((result+1))\
    \ ;; *) result=$((result+1)) ;; *) result=$((result+1)) ;; *) result=$((result+1))\
    \ ;; *) result=$((result+1)) ;; *) result=$((result+1)) ;; *) result=$((result+1))\
    \ ;; *) result=$((result+1)) ;; *) result=$((result+1)) ;; *) result=$((result+1))\
    \ ;; *) result=$((result+1)) ;; *) result=$((result+1)) ;; *) result=$((result+1))\
    \ ;; *) result=$((result+1)) ;; *) result=$((result+1)) ;; *) result=$((result+1))\
    \ ;; *) result=$((result+1)) ;; *) result=$((result+1)) ;; *) result=$((result+1))\
    \ ;; *) result=$((result+1)) ;; *) result=$((result+1)) ;; *) result=$((result+1))\
    \ ;; *) result=$((result+1)) ;; *) result=$((result+1)) ;; *) result=$((result+1))\
    \ ;; *) result=$((result+1)) ;; *) result=$((result+1)) ;; *) result=$((result+1))\
    \ ;; *) result=$((result+1)) ;; *) result=$((result+1)) ;; *) result=$((result+1))\
    \ ;; *) result=$((result+1)) ;; *) result\n}\n\ncandidate() {\n    parse_music\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\") = \"\" ]]\n    [[\
    \ $(candidate \"o o o o\") = \"4 4 4 4\" ]]\n    [[ $(candidate \".| .| .| .|\"\
    ) = \"1 1 1 1\" ]]\n    [[ $(candidate \"o| o| .| .| o o o o\") = \"2 2 1 1 4\
    \ 4 4 4\" ]]\n    [[ $(candidate \"o| .| o| .| o o| o o|\") = \"2 1 2 1 4 2 4\
    \ 2\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpuqg3eat9.sh: line 37: syntax error near unexpected token `}''

    /tmp/tmpuqg3eat9.sh: line 37: `}''

    '
  stdout: ''
  timestamp: 1660054664
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string representing musical\
    \ notes in a special ASCII format.\n# Your task is to parse this string and return\
    \ list of integers corresponding to how many beats does each\n# not last.\n# Here\
    \ is a legend:\n# 'o' - whole note, lasts four beats\n# 'o|' - half note, lasts\
    \ two beats\n# '.|' - quater note, lasts one beat\n# >>> parse_music('o o| .|\
    \ o| o| .| .| .| .| o o')\n# [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n#\n# $1 is a string\n\
    parse_music() {\n    local string=$1\n\n    # we need a dictionary to store beats\n\
    \    local beats=$(python -c 'print({\"0\": 4, \"1\": 1, \"2\": 2, \"3\": 2, \"\
    4\": 2, \"5\": 2, \"6\": 2, \"7\": 2, \"8\": 2, \"9\": 1})')\n\n    # we need\
    \ a temporary variable\n    local tmp=\"\"\n\n    # parse input string\n    for\
    \ char in $string; do\n        if [[ \"$char\" == \"o\" ]]; then\n           \
    \ tmp+=\"1\"\n        elif [[ \"$char\" == \"|\" ]]; then\n            tmp+=\"\
    2\"\n        elif [[ \"$char\" == \".\" ]]; then\n            tmp+=\"3\"\n   \
    \     else\n            tmp+=\"4\"\n        fi\n    done\n\n    # return result\n\
    \    echo \"${beats[tmp]}\"\n}\n\ncandidate() {\n    parse_music \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"\
    o o o o\") = \"4 4 4 4\" ]]\n    [[ $(candidate \".| .| .| .|\") = \"1 1 1 1\"\
    \ ]]\n    [[ $(candidate \"o| o| .| .| o o o o\") = \"2 2 1 1 4 4 4 4\" ]]\n \
    \   [[ $(candidate \"o| .| o| .| o o| o o|\") = \"2 1 2 1 4 2 4 2\" ]]\n}\n\n\
    run_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660054664
- exit_code: 2
  program: "#!/bin/bash\n# Input to this function is a string representing musical\
    \ notes in a special ASCII format.\n# Your task is to parse this string and return\
    \ list of integers corresponding to how many beats does each\n# not last.\n# Here\
    \ is a legend:\n# 'o' - whole note, lasts four beats\n# 'o|' - half note, lasts\
    \ two beats\n# '.|' - quater note, lasts one beat\n# >>> parse_music('o o| .|\
    \ o| o| .| .| .| .| o o')\n# [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n#\n# $1 is a string\n\
    parse_music() {\n  local notes=$1\n  local output\n  output=$((`echo $notes |\
    \ awk '{print $1}' | sed 's/./ /g'`))\n  output=$(($output + `echo $notes | awk\
    \ '{print $2}' | sed 's/./ /g'`))\n  output=$(($output + `echo $notes | awk '{print\
    \ $3}' | sed 's/./ /g'`))\n  output=$(($output + `echo $notes | awk '{print $4}'\
    \ | sed 's/./ /g'`))\n  output=$(($output + `echo $notes | awk '{print $5}' |\
    \ sed 's/./ /g'`))\n  output=$(($output + `echo $notes | awk '{print $6}' | sed\
    \ 's/./ /g'`))\n  output=$(($output + `echo $notes | awk '{print $7}' | sed 's/./\
    \ /g'`))\n  output=$(($output + `echo $notes | awk '{print $8}' | sed 's/./ /g'`))\n\
    \  output=$(($output + `echo $notes | awk '{print $9}' | sed 's/./ /g'`))\n  output=$(($output\
    \ + `echo $notes | awk '{print $10}' | sed 's/./ /g'`))\n  output=$(($output +\
    \ `echo $notes | awk '{print $11}' | sed 's/./ /g'`))\n  output=$(($output + `echo\
    \ $notes | awk '{print $12}' | sed 's/./ /g'`))\n  output=$(($output + `echo $notes\
    \ | awk '{print $13}' | sed 's/./ /g'`))\n  output=$(($output + `echo $notes |\
    \ awk '{print $14}' | sed 's/./ /g'`))\n  output=$(($output + `echo $notes | awk\
    \ '{print $15}' | sed 's/./ /g'`))\n  output=$(($output + `echo $notes | awk '{print\
    \ $16}' | sed 's/./ /g'`))\n  output=$(($output + `echo $notes | awk '{print $17}'\
    \ | sed 's/./ /g'`))\n  output=$(($output + `echo $notes | awk '{print $18}' |\
    \ sed 's/./ /g'`))\n  output=$(($output + `echo $notes | awk '{print $19}' | sed\
    \ 's/./ \n}\n\ncandidate() {\n    parse_music \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"o o o o\") = \"\
    4 4 4 4\" ]]\n    [[ $(candidate \".| .| .| .|\") = \"1 1 1 1\" ]]\n    [[ $(candidate\
    \ \"o| o| .| .| o o o o\") = \"2 2 1 1 4 4 4 4\" ]]\n    [[ $(candidate \"o| .|\
    \ o| .| o o| o o|\") = \"2 1 2 1 4 2 4 2\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpf4chu71q.sh: line 34: unexpected EOF while looking for matching
    ``''

    /tmp/tmpf4chu71q.sh: line 51: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660054664
- exit_code: 2
  program: "#!/bin/bash\n# Input to this function is a string representing musical\
    \ notes in a special ASCII format.\n# Your task is to parse this string and return\
    \ list of integers corresponding to how many beats does each\n# not last.\n# Here\
    \ is a legend:\n# 'o' - whole note, lasts four beats\n# 'o|' - half note, lasts\
    \ two beats\n# '.|' - quater note, lasts one beat\n# >>> parse_music('o o| .|\
    \ o| o| .| .| .| .| o o')\n# [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n#\n# $1 is a string\n\
    parse_music() {\n    local music_str=\"$1\"\n    local music_beats=()\n    local\
    \ music_notes=()\n    local music_count=0\n    local music_octave=0\n    while\
    \ read -r music_note; do\n        case \"$music_note\" in\n            o|O|.|\
    \ )\n                music_notes+=($music_count)\n                music_beats+=(4)\n\
    \                music_octave=$((music_octave + 1))\n                music_count=1\n\
    \                ;;\n            o| O| .| )\n                music_notes+=($music_count)\n\
    \                music_beats+=(2)\n                music_count=1\n           \
    \     ;;\n            o| .| )\n                music_notes+=($music_count)\n \
    \               music_beats+=1\n                music_count=1\n              \
    \  ;;\n        esac\n    done <<< \"$music_str\"\n    echo \"$music_notes\"\n\
    }\n\ncandidate() {\n    parse_music \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"o o o o\") = \"4 4 4 4\" ]]\n\
    \    [[ $(candidate \".| .| .| .|\") = \"1 1 1 1\" ]]\n    [[ $(candidate \"o|\
    \ o| .| .| o o o o\") = \"2 2 1 1 4 4 4 4\" ]]\n    [[ $(candidate \"o| .| o|\
    \ .| o o| o o|\") = \"2 1 2 1 4 2 4 2\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpb9xz2odz.sh: line 21: syntax error near unexpected token `)''

    /tmp/tmpb9xz2odz.sh: line 21: `            o|O|.| )''

    '
  stdout: ''
  timestamp: 1660054664
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string representing musical\
    \ notes in a special ASCII format.\n# Your task is to parse this string and return\
    \ list of integers corresponding to how many beats does each\n# not last.\n# Here\
    \ is a legend:\n# 'o' - whole note, lasts four beats\n# 'o|' - half note, lasts\
    \ two beats\n# '.|' - quater note, lasts one beat\n# >>> parse_music('o o| .|\
    \ o| o| .| .| .| .| o o')\n# [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n#\n# $1 is a string\n\
    parse_music() {\n    local notes=$1;\n    local result='';\n    for ((i=0; i<${#notes};\
    \ i++)); do\n        case \"${notes:$i:1}\" in\n            'o') result+=\"4\"\
    ;;\n            'o|') result+=\"2\";;\n            '.|') result+=\"1\";;\n   \
    \     *) echo \"Bad input note $notes\" 1>&2;\n           exit 1;;\n        esac\n\
    \    done\n    echo $result\n}\n\ncandidate() {\n    parse_music \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"\
    o o o o\") = \"4 4 4 4\" ]]\n    [[ $(candidate \".| .| .| .|\") = \"1 1 1 1\"\
    \ ]]\n    [[ $(candidate \"o| o| .| .| o o o o\") = \"2 2 1 1 4 4 4 4\" ]]\n \
    \   [[ $(candidate \"o| .| o| .| o o| o o|\") = \"2 1 2 1 4 2 4 2\" ]]\n}\n\n\
    run_test"
  status: Exception
  stderr: 'Bad input note o o o o

    '
  stdout: ''
  timestamp: 1660054664
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string representing musical\
    \ notes in a special ASCII format.\n# Your task is to parse this string and return\
    \ list of integers corresponding to how many beats does each\n# not last.\n# Here\
    \ is a legend:\n# 'o' - whole note, lasts four beats\n# 'o|' - half note, lasts\
    \ two beats\n# '.|' - quater note, lasts one beat\n# >>> parse_music('o o| .|\
    \ o| o| .| .| .| .| o o')\n# [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n#\n# $1 is a string\n\
    parse_music() {\n\tlocal result\n\tresult=$(echo \"$1\" | sed -e 's/^\\([0-9]*\\\
    )o \\([0-9]*\\)\\| \\([0-9]*\\)\\.\\([0-9]*\\)$/\\1 \\2 \\3/' -e 's/^[0-9]\\([0-9]*\\\
    )o \\([0-9]*\\)$/\\1 \\2/' -e 's/^[0-9]\\([0-9]*\\)o \\([0-9]*\\)\\.\\([0-9]*\\\
    )$/\\1 \\2 \\3/' -e 's/^[0-9]\\([0-9]*\\)\\.\\([0-9]*\\)$/\\1 \\2 \\3/' -e 's/^[0-9]*\\\
    ([0-9]*\\)$/\\1 \\2/')\n\techo ${result}\n}\n\ncandidate() {\n    parse_music\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\") = \"\" ]]\n    [[\
    \ $(candidate \"o o o o\") = \"4 4 4 4\" ]]\n    [[ $(candidate \".| .| .| .|\"\
    ) = \"1 1 1 1\" ]]\n    [[ $(candidate \"o| o| .| .| o o o o\") = \"2 2 1 1 4\
    \ 4 4 4\" ]]\n    [[ $(candidate \"o| .| o| .| o o| o o|\") = \"2 1 2 1 4 2 4\
    \ 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'sed: -e expression #4, char 41: invalid reference \3 on `s'' command''s
    RHS

    sed: -e expression #4, char 41: invalid reference \3 on `s'' command''s RHS

    '
  stdout: ''
  timestamp: 1660054664
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string representing musical\
    \ notes in a special ASCII format.\n# Your task is to parse this string and return\
    \ list of integers corresponding to how many beats does each\n# not last.\n# Here\
    \ is a legend:\n# 'o' - whole note, lasts four beats\n# 'o|' - half note, lasts\
    \ two beats\n# '.|' - quater note, lasts one beat\n# >>> parse_music('o o| .|\
    \ o| o| .| .| .| .| o o')\n# [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n#\n# $1 is a string\n\
    parse_music() {\n    local i\n    local notes\n    local result\n\n    notes=\"\
    $1\"\n    \n    result=()\n    for i in $(seq 0 ${#notes}); do\n        if [[\
    \ \"$notes\" =~ \".${i}.\" ]]; then\n            result[${#result[@]}]=$((${i}\
    \ - 1))\n        fi\n    done\n\n    echo \"${result[@]}\"\n}\n\ncandidate() {\n\
    \    parse_music \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\") =\
    \ \"\" ]]\n    [[ $(candidate \"o o o o\") = \"4 4 4 4\" ]]\n    [[ $(candidate\
    \ \".| .| .| .|\") = \"1 1 1 1\" ]]\n    [[ $(candidate \"o| o| .| .| o o o o\"\
    ) = \"2 2 1 1 4 4 4 4\" ]]\n    [[ $(candidate \"o| .| o| .| o o| o o|\") = \"\
    2 1 2 1 4 2 4 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660054664
- exit_code: 2
  program: "#!/bin/bash\n# Input to this function is a string representing musical\
    \ notes in a special ASCII format.\n# Your task is to parse this string and return\
    \ list of integers corresponding to how many beats does each\n# not last.\n# Here\
    \ is a legend:\n# 'o' - whole note, lasts four beats\n# 'o|' - half note, lasts\
    \ two beats\n# '.|' - quater note, lasts one beat\n# >>> parse_music('o o| .|\
    \ o| o| .| .| .| .| o o')\n# [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n#\n# $1 is a string\n\
    parse_music() {\n    local str=$1\n    local notes\n    local beats\n    local\
    \ last\n\n    notes=()\n    beats=()\n\n    last=0\n\n    while [[ $str ]]; do\n\
    \        if [[ $str == o ]]; then\n            if [ ${#beats} -eq 0 ]; then\n\
    \                beats=( ${#notes} )\n            fi\n\n            notes+=(${last})\n\
    \        elif [[ $str == o\\|* ]]; then\n            if [ ${#beats} -eq 0 ]; then\n\
    \                beats=( ${#notes} )\n            fi\n\n            last=${notes[-1]}\n\
    \            notes=( ${notes[-1]} ${str#*|} )\n            beats=( ${beats[-1]}\
    \ ${beats[-1]} )\n        elif [[ $str == \\.\\|* ]]; then\n            if [ ${#beats}\
    \ -eq 0 ]; then\n                beats=( ${#notes} )\n            fi\n\n     \
    \       last=${notes[-1]}\n            notes=( ${notes[-1]} ${str#*|} )\n    \
    \        beats=( ${beats[-1]} ${beats[-1]} ${beats[-1]} )\n        elif [[ $str\
    \ == *|* ]]; then\n            if [ ${#beats} -eq 0 ]; then\n                beats=(\
    \ ${#notes} )\n            fi\n\n            beats=( ${beats[-1]} ${str#*|} )\n\
    \        else\n            str=${str#*|}\n            if [ ${#beats} -eq 0 ];\
    \ then\n                beats=( ${#notes} )\n            fi\n\n            beats=(\
    \ ${beats[-1]} ${beats[-1]} ${beats[-1]} )\n        fi\n\n        str=${str%|*}\n\
    \    done\n\n    echo \"${beats[@]}\"\n}\n\ncandidate() {\n    parse_music \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate\
    \ \"o o o o\") = \"4 4 4 4\" ]]\n    [[ $(candidate \".| .| .| .|\") = \"1 1 1\
    \ 1\" ]]\n    [[ $(candidate \"o| o| .| .| o o o o\") = \"2 2 1 1 4 4 4 4\" ]]\n\
    \    [[ $(candidate \"o| .| o| .| o o| o o|\") = \"2 1 2 1 4 2 4 2\" ]]\n}\n\n\
    run_test"
  status: SyntaxError
  stderr: '/tmp/tmpc66vi_70.sh: line 47: syntax error in conditional expression: unexpected
    token `|''

    /tmp/tmpc66vi_70.sh: line 47: syntax error near `|*''

    /tmp/tmpc66vi_70.sh: line 47: `        elif [[ $str == *|* ]]; then''

    '
  stdout: ''
  timestamp: 1660054664
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string representing musical\
    \ notes in a special ASCII format.\n# Your task is to parse this string and return\
    \ list of integers corresponding to how many beats does each\n# not last.\n# Here\
    \ is a legend:\n# 'o' - whole note, lasts four beats\n# 'o|' - half note, lasts\
    \ two beats\n# '.|' - quater note, lasts one beat\n# >>> parse_music('o o| .|\
    \ o| o| .| .| .| .| o o')\n# [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n#\n# $1 is a string\n\
    parse_music() {\n  local input_str=$1\n  # Split the string into list of notes\n\
    \  local notes=($input_str)\n  # Remove space between notes\n  local notes=$(printf\
    \ \"%s\" \"${notes[@]}\" | sed 's/ //g')\n  # Convert to integer representation\n\
    \  local notes=$(echo \"${notes}\" | sed 's/o o\\|\\.\\|o o\\|\\.\\|\\.\\|\\.\\\
    |\\.\\|o o/\\#/' | sed 's/o o\\|\\.\\|o o\\|\\.\\|\\.\\|\\.\\|\\.\\|o o/\\|#/')\n\
    \  # Convert back\n  notes=$(echo \"${notes}\" | sed 's/\\#/\\o o\\|\\.\\|o o\\\
    |\\.\\|\\.\\|\\.\\|\\.\\|o o/')\n  echo $notes\n}\n\ncandidate() {\n    parse_music\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\") = \"\" ]]\n    [[\
    \ $(candidate \"o o o o\") = \"4 4 4 4\" ]]\n    [[ $(candidate \".| .| .| .|\"\
    ) = \"1 1 1 1\" ]]\n    [[ $(candidate \"o| o| .| .| o o o o\") = \"2 2 1 1 4\
    \ 4 4 4\" ]]\n    [[ $(candidate \"o| .| o| .| o o| o o|\") = \"2 1 2 1 4 2 4\
    \ 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660054664
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string representing musical\
    \ notes in a special ASCII format.\n# Your task is to parse this string and return\
    \ list of integers corresponding to how many beats does each\n# not last.\n# Here\
    \ is a legend:\n# 'o' - whole note, lasts four beats\n# 'o|' - half note, lasts\
    \ two beats\n# '.|' - quater note, lasts one beat\n# >>> parse_music('o o| .|\
    \ o| o| .| .| .| .| o o')\n# [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n#\n# $1 is a string\n\
    parse_music() {\n    local music notes\n    music=\"$1\"\n    notes=$(echo $music\
    \ | sed -e \"s/\\(.\\)\\(.\\)/\\1 \\2/g\" | sed -e \"s/\\(.\\)\\(.\\)\\(.\\)/\\\
    1 \\2 \\3/g\" | sed -e \"s/\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)/\\1 \\2 \\3 \\\
    4 \\5/g\")\n    echo \"$notes\"\n}\n\ncandidate() {\n    parse_music \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate\
    \ \"o o o o\") = \"4 4 4 4\" ]]\n    [[ $(candidate \".| .| .| .|\") = \"1 1 1\
    \ 1\" ]]\n    [[ $(candidate \"o| o| .| .| o o o o\") = \"2 2 1 1 4 4 4 4\" ]]\n\
    \    [[ $(candidate \"o| .| o| .| o o| o o|\") = \"2 1 2 1 4 2 4 2\" ]]\n}\n\n\
    run_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660054664
