name: HumanEval_49_modp
language: sh
prompt: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3,\
  \ 5)\n# 3\n# >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n\
  # 8\n# >>> modp(100, 101)\n# 1\n#\n# $1 is an integer\n# $2 is an integer\nmodp()\
  \ {\n"
tests: "}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
  \ \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n   \
  \ [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"\
  8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\"\
  \ \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
completions: ["\tlocal n=$1\n\tlocal p=$2\n\tlocal nmodp=$(( (n-1) % p ))\n\t[ \"\
    $nmodp\" -eq 0 ] && nmodp=$p\n\techo $nmodp", "\tlocal n=$1\n\tlocal p=$2\n\t\
    local i\n\tlocal res\n\t[[ $p == 0 ]] && return 1\n\t[[ $n == 0 ]] && return 1\n\
    \t[[ $p == 1 ]] && return $n\n\t[[ $p == 2 ]] && return $n\n\t[[ $p -le $(( 32\
    \ - 1 )) ]] && return $(( 1 << ( ( p - 1 ) * 8 ) ))\n\tres=0\n\ti=$(( 32 - 1 ))\n\
    \twhile (( i > ( n - 1 ) )) do\n\t\tres=$(( res + $i ))\n\t\ti=$(( i - 1 ))\n\t\
    done\n\tres=$(( res + $n ))\n\treturn $(( res % $p ))", "    local n x p\n\n \
    \   n=$1; shift\n    x=$1; shift\n    p=$1; shift\n\n    # n is zero, return 1\
    \ (mod p).\n    if [ \"$n\" = \"0\" ]; then\n        echo \"1\"\n        return\n\
    \    fi\n\n    # n is negative.\n    if [ \"$n\" = \"-$n\" ]; then\n        echo\
    \ \"-1\"\n        return\n    fi\n\n    local b\n    # n is odd, b is zero\n \
    \   if [ \"$n\" = \"$((n-1))\" ]; then\n        b=0\n    elif [ \"$n\" -lt \"\
    $p\" ]; then\n        b=1\n    else\n        b=$(( ($n % ($p+1)) ))\n    fi\n\
    \    if [ \"$n\" -ge \"$p\" ]; then\n        b=$(( $n - $p ))\n    fi\n    echo\
    \ \"$b\"", "    local -r a=$(echo \"$1\" | bc -l)\n    local -r b=$(echo \"$2\"\
    \ | bc -l)\n\n    # $((b ** a % p))\n    echo \"$(((b ** a) % $b))\"", "  local\
    \ i result\n  local a b p m n\n\n  a=$1\n  b=$2\n  p=$(( $a >= $b ? $a : $b ))\n\
    \  m=$(( $p - 1 ))\n  n=$(( $p - 2 ))\n\n  for (( i=1; i <= $m; i++ )); do\n \
    \   a=$((a * $p % $b))\n  done\n\n  echo \"$a\"\n\n  # for (( i=1; i <= $n; i++\
    \ )); do\n  #   b=$(( b * $p % $a ))\n  # done\n\n  # echo $b", "    local a b\n\
    \    if [ $1 -gt 0 ]; then a=$1; else a=0; fi\n    if [ $2 -gt 0 ]; then b=$2;\
    \ else b=0; fi\n    a=$(( ${a}%$b ))\n    return $a", "    if [ $# -lt 2 ]; then\n\
    \        echo \"usage: modp <integer> <integer>\"\n        return 1\n    fi\n\n\
    \    [ $1 -eq 0 ] && return 1\n    [ $1 -lt 0 ] || return 1\n    [ $2 -eq 0 ]\
    \ || return 1\n    [ $2 -lt 0 ] || return 1\n\n    local m=$1\n    local n=$2\n\
    \n    local b=0\n    while [ $n -gt 0 ]; do\n        [ $n -gt 1 ] && b=$(( b <<\
    \ 1 ))\n        [ $n -eq 2 ] && b=$(( b << 1 ))\n\n        m=$(( m % $2 ))\n \
    \       n=$(( n - 1 ))\n    done\n    [ $m -lt $b ] && return $b\n    [ $m -eq\
    \ $b ] || return $m", "    if [ \"$1\" -eq \"$2\" ]\n    then\n        return\
    \ 1\n    elif [ \"$1\" -gt \"$2\" ]\n    then\n        if [ \"$1\" -le \"$2\"\
    \ ]\n        then\n            local n=$1\n            local p=$2\n          \
    \  local res=0\n            while [ \"$n\" -ge \"$p\" ]\n            do\n    \
    \            (( res+=1 ))\n                n=$(( $n//$2 ))\n            done\n\
    \            echo $res\n        fi\n    else\n        if [ \"$1\" -lt \"$2\" ]\n\
    \        then\n            local n=$1\n            local p=$2\n            local\
    \ res=0\n            while [ \"$n\" -le \"$p\" ]\n            do\n           \
    \     (( res+=1 ))\n                n=$(( $n*$2 ))\n            done\n       \
    \     echo $res\n        fi\n    fi", "    local n p r\n    read -r n p <<< \"\
    $2 $1\"\n    r=$(( n % p ))\n    if [ \"$r\" -gt \"0\" ]; then\n        r=$((\
    \ r + p ))\n    fi\n    echo \"$r\"", "  local n=$1 p=$2\n\n  (( n % p )) || ((\
    \ n += p ))\n  printf \"%s\" \"$n\"", "  local n=$1\n  local p=$2\n  test $n -gt\
    \ 1 && test $p -gt 1 && return $(( 2**$n % $p ))", "\techo \"$(($1/$2))\" &>/dev/null",
  "\tif (( $# < 2 )); then\n\t\techo \"Usage: $0 num1 num2\" >&2\n\t\treturn 1\n\t\
    fi\n\n\tlocal num1=$1\n\tlocal num2=$2\n\n\tif (( num2 <= 0 ));\n\tthen\n\t\t\
    echo \"Error: num2 is 0\" >&2\n\t\treturn 1\n\tfi\n\n\tif (( num1 > num2 ));\n\
    \tthen\n\t\techo \"Error: num1 is greater than num2\" >&2\n\t\treturn 1\n\tfi\n\
    \n\tlocal mod=1\n\tlocal div=num2\n\tlocal rem\n\n\twhile (( rem != 0 ));\n\t\
    do\n\t\trem=$(( $div % num1 ))\n\t\tdiv=$(( $div / num1 ))\n\t\tmod=$(( $mod *\
    \ num1 ))\n\tdone\n\n\tif (( $mod != 0 ));\n\tthen\n\t\techo \"Error: could not\
    \ find factor\" >&2\n\t\treturn 1\n\tfi\n\n\treturn $div", "  local a b c d n\n\
    \  a=$1\n  b=$2\n  c=3\n  d=1\n  n=0\n  while [ $c -lt $b ]; do\n    d=$((c*d))\n\
    \    n=$((n+d))\n    c=$((c+1))\n  done\n  echo \"$n\"", "    local -i a=$1 b=$2\n\
    \    local -r n=${#b}\n    if [[ $n -eq 0 ]]; then\n        echo \"1\";\n    \
    \    return\n    fi\n    local -r p=$(( b % n ))\n    while [[ \"$p\" -eq \"0\"\
    \ ]]; do\n        (( p-- ))\n    done\n    echo $(( 2 * $p - 1 ))", "    local\
    \ n=$1\n    local p=$2\n    if [ \"$n\" -gt 0 ]; then\n        if [ \"$p\" -gt\
    \ 0 ]; then\n            # $n = $n % $p\n            if (( $n % $p )); then\n\
    \                n=`expr $n - $p`\n            else\n                n=`expr $p\
    \ + $n`\n            fi\n        fi\n    fi\n    if [ \"$n\" -eq 0 ]; then\n \
    \       n=1\n    fi\n    echo \"$n\"", "  if [ \"$2\" -eq 1 ] ; then\n    echo\
    \ \"${1}\"\n  else\n    echo \"${1} * 2^(${2} - 1)\"\n  fi", "  if [ $# -eq 0\
    \ ]\n  then\n    echo \"Usage: $0 [integer] [integer]\"\n    exit 1\n  fi\n  local\
    \ n=$1\n  local p=$2\n  if [ $n -lt 0 ]\n  then\n    echo \"Usage: $0 [integer]\
    \ [integer]\"\n    exit 1\n  fi\n  if [ $n -eq 0 ]\n  then\n    echo \"Usage:\
    \ $0 [integer] [integer]\"\n    exit 1\n  fi\n  if [ $p -lt 0 ]\n  then\n    echo\
    \ \"Usage: $0 [integer] [integer]\"\n    exit 1\n  fi\n  if [ $p -eq 0 ]\n  then\n\
    \    echo \"Usage: $0 [integer] [integer]\"\n    exit 1\n  fi\n  local i\n  local\
    \ j\n  local ret\n  local q\n  local remainder\n  local n\n  n=$(( $n % $p ))\n\
    \  ret=$(( $n ))\n  j=$(( $p ))\n  q=$(( $p ))\n  while [ $j -ne $n ]\n  do\n\
    \    remainder=$(( $n % $j ))\n    if [ $remainder -gt 0 ]\n    then\n      q=$(($q\
    \ + $remainder))\n    fi\n    j=$(($j - 1))\n  done\n  if [ $n -eq 0 ]\n  then\n\
    \    echo \"$ret\"\n  else\n    echo \"$q\"\n  fi", "    local a=\"$1\"\n    local\
    \ b=\"$2\"\n    local m=\"$1\"\n    local p=\"$2\"\n    local n=$((b - m))\n \
    \   if [ \"$n\" -eq 0 ]; then\n        echo 1\n    elif [ \"$n\" -gt 0 ]; then\n\
    \        modp $((m + 1)) $((p + 1))\n        local c=$((m + a))\n        local\
    \ d=$((p + b))\n        local r=$((a + b))\n        modp $((c - 1)) $((d + 1))\n\
    \        modp $((r - 1)) $((c + b))\n        echo $((d+c))\n    else\n       \
    \ echo 0\n    fi", "\tlocal n=$1\n\tlocal i\n\n\tfor i in $(seq 2 $2); do\n\t\t\
    n=$(echo \"$n * $i\" | bc)\n\tdone\n\techo \"$n\""]
stop_tokens:
- "\n}"
