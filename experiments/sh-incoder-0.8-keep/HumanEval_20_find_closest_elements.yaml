name: HumanEval_20_find_closest_elements
language: sh
prompt: "#!/bin/bash\n# From a supplied list of numbers (of length at least two) select\
  \ and return two that are the closest to each\n# other and return them in order\
  \ (smaller number, larger number).\n# >>> find_closest_elements([1.0, 2.0, 3.0,\
  \ 4.0, 5.0, 2.2])\n# (2.0, 2.2)\n# >>> find_closest_elements([1.0, 2.0, 3.0, 4.0,\
  \ 5.0, 2.0])\n# (2.0, 2.0)\n#\n# $1 is a space-separated list\nfind_closest_elements()\
  \ {\n"
tests: "}\n\ncandidate() {\n    find_closest_elements \"$@\"\n}\n\nset -e\nrun_test()\
  \ {\n    [[ $(candidate \"1.0 2.0 3.9 4.0 5.0 2.2\") = \"3.9 4.0\" ]]\n    [[ $(candidate\
  \ \"1.0 2.0 5.9 4.0 5.0\") = \"5.0 5.9\" ]]\n    [[ $(candidate \"1.0 2.0 3.0 4.0\
  \ 5.0 2.2\") = \"2.0 2.2\" ]]\n    [[ $(candidate \"1.0 2.0 3.0 4.0 5.0 2.0\") =\
  \ \"2.0 2.0\" ]]\n    [[ $(candidate \"1.1 2.2 3.1 4.1 5.1\") = \"2.2 3.1\" ]]\n\
  }\n\nrun_test"
completions: ["    local list=$1 num=${#list[@]}\n    if [ $num -eq 0 ] ; then\n \
    \       echo \"Usage: $FUNCNAME list-of-numbers\"\n        exit 1\n    fi\n  \
    \  local minimum=$(echo \"$list[0]\" | bc)\n    local minimum_index=0 result\n\
    \    # Find minimum value in list\n    for (( i = 1 ; i <= num ; i++ )); do\n\
    \        if [[ $list[i] -lt $minimum ]]; then\n            minimum=$list[i]\n\
    \            minimum_index=i\n        fi\n    done\n    # Remove minimum from\
    \ list\n    list=(\"${list[@]:$minimum_index}\")\n    # Find minimum value in\
    \ list\n    minimum=$(echo \"$list[1]\" | bc)\n    minimum_index=1\n    result=\n\
    \    for (( i = 1 ; i <= num ; i++ )); do\n        if [[ $list[i] -lt $minimum\
    \ ]]; then\n            minimum=$list[i]\n            minimum_index=i\n      \
    \      result=$list[i]\n        fi\n    done\n    echo \"$result\"", "  # $1 is\
    \ a list of numeric values\n  # We need to split out the values into a list\n\
    \  local numbers=( $1 )\n  local smallest=0\n  local largest=0\n\n  # For each\
    \ number in the list...\n  local elements=()\n  for element in \"${numbers[@]}\"\
    ; do\n    # If this element is the smallest so far...\n    if [ \"$smallest\"\
    \ -eq 0 ]; then\n      # Set the smallest to the first element\n      smallest=$element\n\
    \      largest=$element\n    elif [ \"$smallest\" -le \"$element\" ]; then\n \
    \     # Set the smallest to the new value\n      smallest=$element\n    elif [\
    \ \"$largest\" -le \"$element\" ]; then\n      # Set the largest to the new value\n\
    \      largest=$element\n    # Append this element to the list of elements\n \
    \   elements+=(\"$element\")\n  done\n\n  # Return the two elements\n  echo \"\
    ${elements[@]}\"", "    local numbers=$1\n    local smallest\n    local largest\n\
    \    smallest=$(bc <<< \"$numbers\" | awk '{print $1 < $2 ? $1 : $2}')\n    largest=$(bc\
    \ <<< \"$numbers\" | awk '{print $1 > $2 ? $1 : $2}')\n    echo \"$smallest $largest\"",
  "    local array=$1\n    local element1=${array[1]}\n    local element2=${array[0]}\n\
    \    local minimum=100000000000000\n    local maximum=0\n    for element in \"\
    ${array[@]:2}\"; do\n        local difference=$(( ${element} - ${element2} ))\n\
    \        if (( ${difference} < 0 )) ; then\n            difference=-${difference}\n\
    \        fi\n        if (( ${difference} < ${minimum} )) ; then\n            minimum=${difference}\n\
    \        fi\n        if (( ${difference} > ${maximum} )) ; then\n            maximum=${difference}\n\
    \        fi\n    done\n    if [ ${minimum} -lt ${maximum} ] ; then\n        local\
    \ new_element=${array[1]}\n        local new_element2=${array[0]}\n        for\
    \ element in \"${array[@]:2}\"; do\n            local difference=$(( ${element}\
    \ - ${new_element2} ))\n            if (( ${difference} < 0 )) ; then\n      \
    \          difference=-${difference}\n            fi\n            if (( ${difference}\
    \ < ${minimum} )) ; then\n                minimum=${difference}\n            fi\n\
    \            if (( ${difference} > ${maximum} )) ; then\n                maximum=${difference}\n\
    \            fi\n        done\n        echo \"${new_element},${new_element2}\"\
    \n    else\n        echo \"${element1},${element2}\"\n    fi", "    local elements=\"\
    ${1}\"\n    local min=\"${2}\"\n    # Convert elements to array in case they are\
    \ already one\n    local IFS=','\n    local elems=\"${elements}\"\n    local len=\"\
    ${#elements}\"\n    local d=\"$(echo \"scale=3; ${elems}/$min\" | bc -l)\"\n \
    \   # Loop through the elements and find the smallest and largest one that lie\
    \ within $min and $max\n    # then return them.\n    for (( i=1; i<=len; i++ ));\
    \ do\n        local ele=\"${elems}[$i]\"\n        local elems=\"${elems%,$i},$ele\"\
    \n        local d=\"${elems}/$d\"\n        if [[ \"$d\" -le \"$min\" ]] && [[\
    \ \"$d\" -ge \"$max\" ]]; then\n            echo $ele\n            break\n   \
    \     fi\n    done", "    numbers=\"$1\"\n    smallest=\"$2\"\n    largest=\"\
    $3\"\n    local i\n    local smallestIndex\n    local largestIndex\n    local\
    \ i\n    for (( i=0; i<${#numbers}; i+=2 )); do\n        smallestIndex=$i\n  \
    \      largestIndex=$((i + 1))\n        if [ $(($largestIndex-$smallestIndex))\
    \ -gt 0 ]; then\n            if (( $smallest > ${numbers[$smallestIndex]} && ${numbers[$smallestIndex]}\
    \ > ${numbers[$largestIndex]} )) ; then\n                smallestIndex=$largestIndex\n\
    \            fi\n        fi\n        if [ $(($smallestIndex-$largestIndex)) -gt\
    \ 0 ]; then\n            if (( $smallest > ${numbers[$smallestIndex]} && ${numbers[$smallestIndex]}\
    \ > ${numbers[$largestIndex]} )) ; then\n                largestIndex=$smallestIndex\n\
    \            fi\n        fi\n    done\n    echo \"$smallest, $largest\"", "  local\
    \ LIST=\"$1\"\n  local NUMS=$(echo \"${LIST}\" | tr \" \" \",\")\n  local MIN=\n\
    \  local MAX=\n  local DIFFS=\"\"\n  local NUM=\"\"\n  for NUM in ${NUMS} ; do\n\
    \    MIN=$( echo \"${NUM}\" | awk -F, \"{print $1} < ${MIN}\" )\n    MAX=$( echo\
    \ \"${NUM}\" | awk -F, \"{print $1} > ${MAX}\" )\n    DIFFS=\"$DIFFS ${NUM}\"\n\
    \  done\n  echo \"${MIN},${MAX}\"", "  local elements=$1\n  local -a arr=()\n\
    \  local element\n  local closest\n  local count\n  local i\n  local j\n  for\
    \ element in ${elements[*]}; do\n    arr+=(\"$element\")\n  done\n  count=${#arr[@]}\n\
    \  for i in $(seq 0 $((count-1))); do\n    closest=${arr[$i]}\n    for j in $(seq\
    \ 0 $((count-1))); do\n      if [[ $((i-j)) -eq 0 ]]; then\n        ((dist=$((\
    \ (${arr[$j]} - $closest)**2 )) )) && \\\n          closest=${arr[$j]}\n     \
    \ elif [[ $((i-j)) -eq 1 ]]; then\n        ((dist=$(( (${arr[$j]} - $closest)**2\
    \ )) )) && \\\n          closest=${arr[$j]}\n      elif [[ $((i-j)) -gt 1 ]];\
    \ then\n        ((dist=$(( (${arr[$j]} - $closest)**2 )) )) && \\\n          closest=${arr[$j]}\n\
    \      fi\n    done\n    arr[i]=$closest\n  done\n  for i in $(seq 0 $((count-1)));\
    \ do\n    arr[$i]=${arr[i]}\n  done\n  echo ${arr[*]}", "    local list=\"${1:-}\"\
    \n    echo \"${list// /, }\" | sort -n -t, -k2 -k 1 > /tmp/tmp.$$\n    echo -n\
    \ \"(\"\n    cat /tmp/tmp.$$ | while read elem; do\n        echo -n \"${elem},\"\
    \n    done\n    echo \")\"\n    rm /tmp/tmp.$$", "    local lst_numbers=\"$1\"\
    \n    local smallest_number=\"$2\"\n    local max_number=\"$3\"\n\n    local smallest_number_found=\n\
    \    local max_number_found=\n    local number=$smallest_number\n    local number2=$max_number\n\
    \    while read line\n    do\n        if [ \"$smallest_number_found\" == \"\"\
    \ ]\n        then\n            smallest_number_found=\"$number\"\n        elif\
    \ [ \"$max_number_found\" == \"\" ]\n        then\n            max_number_found=\"\
    $number\"\n        elif [ \"$smallest_number_found\" -gt \"$number\" -a \"$max_number_found\"\
    \ -lt \"$number\" ]\n        then\n            smallest_number_found=\"$number\"\
    \n        elif [ \"$smallest_number_found\" -lt \"$number\" -a \"$max_number_found\"\
    \ -gt \"$number\" ]\n        then\n            smallest_number_found=\"$number\"\
    \n        elif [ \"$smallest_number_found\" -eq \"$number\" -a \"$max_number_found\"\
    \ -eq \"$number\" ]\n        then\n            smallest_number_found=\"$number\"\
    \n        elif [ \"$smallest_number_found\" -eq \"$number\" -a \"$max_number_found\"\
    \ -eq \"$number\" ]\n        then\n            smallest_number_found=\"$number\"\
    \n        elif [ \"$smallest_number_found\" -eq \"$number\" -a \"$max_number_found\"\
    \ -eq \"$number\" ]\n        then\n            smallest_number_found=\"$number\"\
    \n        elif [ \"$smallest_number_found\" -eq \"$number\" -a \"$max_number_found\"\
    \ -eq \"$number\" ]\n        then\n            smallest_number_found=\"$number\"\
    \n        elif [ \"$smallest_number_found\" -gt \"$number\" -a \"$max_number_found\"\
    \ -eq \"$number\" ]\n        then\n            smallest_number_found=\"$number\"\
    \n        elif [ \"$smallest_number_found\" -lt \"$number\" -a \"$max_number_found\"\
    \ -eq \"$number\" ]\n        then\n            smallest_number_found=\"$number\"\
    \n        elif [ \"$smallest_number_found\" -gt \"$number\" -a \"$max_number_found\"\
    \ -gt \"$number\" ]\n        then\n            smallest_number_found=\"$number\"\
    \n        elif [ \"$smallest_number_found\" -lt \"$number\" -a \"$max_number_found\"\
    \ -gt \"$number\" ]\n        then\n            smallest_number_found=\"$number\"\
    \n        elif [ \"$smallest_number_found\" -eq \"$number\" -a \"$max_number_found\"\
    \ -eq \"$number\" ]\n        then\n            smallest_number_found=\"$number\"\
    \n        elif ", "  local numbers=$1\n  local smallest_distance=$2\n  local next_smallest\n\
    \  local next_largest\n\n  if [ \"$smallest_distance\" -eq 0 ]; then\n    smallest_distance=$1\n\
    \    next_smallest=$2\n    next_largest=$3\n  fi\n\n  local distance=0\n  local\
    \ i\n  local smallest=$smallest_distance\n  local largest=$smallest_distance\n\
    \n  for ((i=1; i<${#numbers[@]}; i++)); do\n    local x=${numbers[$i]}\n    local\
    \ y=${numbers[$((i-1))]}\n\n    distance=$(echo \"scale=4; ${x} - ${y}\" | bc)\n\
    \    if [ \"$distance\" -lt \"$smallest\" ]; then\n      smallest=$distance\n\
    \      next_smallest=$x\n    fi\n    if [ \"$distance\" -gt \"$largest\" ]; then\n\
    \      largest=$distance\n      next_largest=$y\n    fi\n  done\n\n  printf \"\
    (%s, %s)\\n\" \"$smallest\" \"$largest\"", "    local list=\"$1\"\n\n    local\
    \ smaller=\"$(expr $(echo \"$list\" | tr ' ' '\\n' | sort -V | head -n 1) \\\n\
    \    | cut -d ' ' -f 1)\"\n    local larger=\"$(expr $(echo \"$list\" | tr ' '\
    \ '\\n' | sort -V | tail -n 1) \\\n    | cut -d ' ' -f 1)\"\n    \n    echo \"\
    $smaller,$larger\"", "\tlocal -n arr=$1\n\tlocal -a arr1=()\n\tlocal -a arr2=()\n\
    \tlocal len=${#arr[@]}\n\tlocal val1\n\tlocal val2\n\tlocal index1\n\tlocal index2\n\
    \tlocal minIndex\n\tlocal maxIndex\n\n\tif [ \"$len\" -eq 0 ]; then\n\t\treturn\
    \ 0\n\tfi\n\n\tminIndex=0\n\tmaxIndex=$(($len-1))\n\n\tfor i in $(seq 0 $(($len-1)));\
    \ do\n\t\tval1=${arr[$i]}\n\t\tindex1=$(expr $i - 1)\n\t\tval2=${arr[$index1]}\n\
    \t\tindex2=$(expr $index1 - 1)\n\t\tarr1+=(\"$val1\")\n\t\tarr2+=(\"$val2\")\n\
    \t\tif [ \"$val1\" -gt \"$val2\" ]; then\n\t\t\tminIndex=$i\n\t\tfi\n\t\tif [\
    \ \"$val1\" -lt \"$val2\" ]; then\n\t\t\tmaxIndex=$i\n\t\tfi\n\tdone\n\tprintf\
    \ \"[${arr1[@]}]\\n[${arr2[@]}]\"", "    if [ \"$#\" -lt 2 ]\n    then\n     \
    \   echo \"Usage: find_closest_elements <numbers>\"\n        exit 1\n    fi\n\n\
    \    # Split the first argument into a list\n    local list=\"$1\"\n    local\
    \ elements=()\n    local smallest\n    local largest\n\n    # Convert list to\
    \ an array so we can use \"${list[*]}\" to access all elements\n    IFS=' ' read\
    \ -r -a elements <<< \"$list\"\n\n    # Search for two closest elements\n    for\
    \ element in \"${elements[@]}\"; do\n        smallest=\"${smallest:-$element}\"\
    \n        largest=\"${largest:-$element}\"\n        if [ \"$smallest\" -gt \"\
    $element\" ]\n        then\n            smallest=\"$element\"\n        fi\n  \
    \      if [ \"$largest\" -lt \"$element\" ]\n        then\n            largest=\"\
    $element\"\n        fi\n    done\n\n    # Return smallest element first\n    local\
    \ smallest_index\n    smallest_index=\"${elements[@]}\" | grep -E -o \"$smallest\"\
    \ | wc -l\n    smallest=\"${elements[$smallest_index-1]}\"\n    echo \"$smallest\"\
    \n\n    # Return largest element second\n    local largest_index\n    largest_index=\"\
    ${elements[@]}\" | grep -E -o \"$largest\" | wc -l\n    largest=\"${elements[$largest_index-1]}\"\
    \n    echo \"$largest\"", "    local array arrayName index diff max min temp totalElements\
    \ value\n    totalElements=${#${1// /}}\n    \n    if [ $totalElements -lt 2 ]\n\
    \    then\n        echo \"Invalid number of elements supplied\"\n        echo\
    \ \"Please provide a space-separated list of at least two elements\"\n       \
    \ return 2\n    fi\n    \n    arrayName=${1//,/-}\n    \n    array=${!arrayName}\n\
    \    \n    index=0\n    min=$(echo $array | cut -c2- | sort -n | tail -1)\n  \
    \  max=$(echo $array | cut -c2- | sort -n | head -1)\n    \n    while [ $index\
    \ -lt $totalElements ]\n    do\n        value=${array[$index]//,/}\n        \n\
    \        diff=$(echo \"$value - $min\" | bc)\n        \n        if [ $diff -eq\
    \ 0 ]\n        then\n            echo \"$value\" > $arrayName\n        fi\n  \
    \      \n        diff=$(echo \"$max - $value\" | bc)\n        \n        if [ $diff\
    \ -eq 0 ]\n        then\n            echo \"$max\" > $arrayName\n        fi\n\
    \        \n        ((index++))\n        \n        min=$(echo $array | cut -c2-\
    \ | sort -n | tail -1)\n        max=$(echo $array | cut -c2- | sort -n | head\
    \ -1)\n    done\n    \n    echo \"$min\"\n    echo \"$max\"", "    local n=$1\
    \ s=${#n} v1 v2\n    local ind i\n    for (( ind=0; ind<$s; ind+=1 )); do\n  \
    \      v1=${n[$ind]}\n        ind=0\n        while [ \"$ind\" -lt \"$s\" ]; do\n\
    \            v2=${n[$ind]}\n            # Check if both numbers are equal by adding\
    \ them and checking if they are equal or greater than\n            # v1. We will\
    \ take this as our comparison for the closest number. We will then restart ind\n\
    \            # and move on to the next number if the distance between them is\
    \ greater than v1.\n            if [ \"$v1\" -gt \"$v2\" ]; then\n           \
    \     # Keep looping until we've found two numbers that are equal or greater.\n\
    \                ind=$(( ind + 1 ))\n                continue\n            fi\n\
    \            # Check if our new distance between the two numbers exceeds v1.\n\
    \            if [ \"$v1\" -lt \"$v2\" ]; then\n                # Keep looping\
    \ until we've found two numbers that are equal.\n                ind=$(( ind +\
    \ 1 ))\n                continue\n            fi\n            # Check if our new\
    \ distance between the two numbers is the same as the distance\n            #\
    \ between them but smaller.\n            if [ \"$v1\" -eq \"$v2\" ] && [ \"$v1\"\
    \ -lt \"$v2\" ]; then\n                # Keep looping until we've found two numbers\
    \ that are the same or smaller.\n                ind=$(( ind + 1 ))\n        \
    \        continue\n            fi\n            echo \"$v1 $v2\"\n            ind=$((\
    \ ind + 1 ))\n        done\n    done", "\tlocal numbers=(\"${@}\")\n\tlocal min\n\
    \tlocal max\n\tlocal min_index\n\tlocal max_index\n\tlocal result\n\tfor ((index\
    \ = 0; index < ${#numbers[@]}; ++index)) {\n\t\tlocal current_number=\"${numbers[index]}\"\
    \n\t\tif [[ ${current_number} -lt ${min} ]]; then\n\t\t\tmin=${current_number}\n\
    \t\t\tmin_index=${index}\n\t\telif [[ ${current_number} -gt ${max} ]]; then\n\t\
    \t\tmax=${current_number}\n\t\t\tmax_index=${index}\n\t\tfi\n\t}\n\tresult=\"\
    ${numbers[${min_index}]}\"\n\tresult=\"${result},${numbers[${max_index}]}\"\n\t\
    echo \"$result\"", "  local first_element=$1\n  local array=$2\n  local smallest_difference=$3\n\
    \  local smallest_element=$4\n  local smallest_element_number=$5\n  local smallest_element_number_index=$6\n\
    \  local second_element=$7\n  local second_element_number=$8\n  local second_element_number_index=$9\n\
    \n  # Convert the string to an array\n  IFS=$'\\n' read -r -a array <<< \"$first_element\"\
    \n\n  local smallest_difference_index=0\n  local second_element_number_index=0\n\
    \n  # Find the smallest difference and number in the array and store it for the\
    \ next loop.\n  for i in \"${!array[@]}\"; do\n    local difference=$((array[$i]\
    \ - first_element))\n    local element_number=$((i + 1))\n    local element_number_index=$((element_number))\n\
    \n    if [ $(($element_number - first_element_number_index)) -lt $smallest_difference\
    \ ]; then\n      smallest_difference=$element_number\n      smallest_difference_index=$i\n\
    \    fi\n    if [ $(($element_number_index - second_element_number_index)) -lt\
    \ $smallest_element_number ]; then\n      smallest_element_number=$element_number\n\
    \      smallest_element_number_index=$i\n    fi\n    if [ $(($element_number -\
    \ second_element_number_index)) -lt $smallest_difference ]; then\n      second_element_number=$element_number\n\
    \      second_element_number_index=$i\n    fi\n  done\n\n  # Return the two values\n\
    \  echo \"$array[$smallest_difference_index], $array[$second_element_number_index]\"",
  "    local N=${#1}\n    local i=1\n    local min=\"$(echo \"${1}\" | sort -n | tail\
    \ -1)\"\n    local max=\"$(echo \"${1}\" | sort -n | head -1)\"\n    local out\n\
    \n    while [ $i -le $N ]; do\n        if [ $i -eq 1 ]; then\n            out=\"\
    $min\"\n            ((i++))\n        else\n            if [ \"$max\" = \"$min\"\
    \ ]; then\n                ((i++))\n                continue\n            fi\n\
    \            local v=\"$(\"${GREP}\" \"$min\" <(echo \"${1}\" | sort -n | head\
    \ -$i))\"\n            local w=\"$(\"${GREP}\" \"$max\" <(echo \"${1}\" | sort\
    \ -n | tail -$i))\"\n            out=\"$(($v + $w))\"\n        fi\n        ((i++))\n\
    \    done\n    echo \"$out\"", "    local i=1\n    local closest\n    local distance\n\
    \    local element\n    local elements\n\n    if [ \"$#\" -eq 1 ]; then\n    \
    \    elements=($1)\n    else\n        elements=($(cat $1 | tr \" \" \"\\n\"))\n\
    \    fi\n\n    closest=$elements[1]\n    distance=${elements[1]}\n    while [\
    \ $i -lt ${#elements[@]} ]; do\n        element=${elements[$i]}\n        if [\
    \ ${distance} -gt ${element} ]; then\n            distance=${element}\n      \
    \      closest=$element\n        else\n            elements[$i]=${closest}\n \
    \       fi\n        ((i++))\n    done\n    echo \"${closest} ${distance}\""]
stop_tokens:
- "\n}"
