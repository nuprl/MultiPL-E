name: HumanEval_115_max_fill
language: ts
prompt: "//You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n// and each 1 in a row represents a single unit of water.\n// Each well\
  \ has a corresponding bucket that can be used to extract water from it, \n// and\
  \ all buckets have the same capacity.\n// Your task is to use the buckets to empty\
  \ the wells.\n// Output the number of times you need to lower the buckets.\n// Example\
  \ 1:\n// >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n// 6\n// Example\
  \ 2:\n// >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
  \ 2)\n// 5\n// Example 3:\n// >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n// 0\n//\
  \ Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n\
  // * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity\
  \ <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1,\
  \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0,\
  \ 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0,\
  \ 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1,\
  \ 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n\
  }\n\ntest();"
completions: ["  let [rows, cols] = grid.length\n  let [wells, buckets] = [[0] * rows,\
    \ [0] * rows]\n  let [wells_filled, buckets_filled] = [[0] * rows, [0] * rows]\n\
    \  let [wells_filled_count, buckets_filled_count] = [0, 0]\n  for (let i = 0;\
    \ i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      wells[i][j] =\
    \ grid[i][j]\n      if (wells[i][j] === 1) {\n        wells_filled[i][j] = 1\n\
    \        wells_filled_count++\n      }\n    }\n  }\n  for (let i = 0; i < rows;\
    \ i++) {\n    for (let j = 0; j < cols; j++) {\n      buckets[i][j] = capacity\n\
    \      if (wells[i][j] === 1) {\n        buckets_filled[i][j] = 1\n        buckets_filled_count++\n\
    \      }\n    }\n  }\n  let [wells_filled_count_new, buckets_filled_count_new]\
    \ = [0, 0]\n  while (wells_filled_count_new < wells_filled_count) {\n    for (let\
    \ i = 0; i < rows; i++) {\n      for (let j = 0; j < cols; j++) {\n        if\
    \ (wells_filled[i][j] === 1 && buckets[i][j] > 0) {\n          wells_filled[i][j]\
    \ = 0\n          wells_filled_count_new++\n          buckets[i][j]--\n       \
    \ }\n      }\n    }\n  }\n  return buckets_filled_count_new\n}\n", "  let [rows,\
    \ cols] = grid.length\n  let [rows2, cols2] = grid[0].length\n  let [rows3, cols3]\
    \ = grid[0][0].length\n  let [rows4, cols4] = grid[0][0][0].length\n  let [rows5,\
    \ cols5] = grid[0][0][0][0].length\n  let [rows6, cols6] = grid[0][0][0][0][0].length\n\
    \  let [rows7, cols7] = grid[0][0][0][0][0][0].length\n  let [rows8, cols8] =\
    \ grid[0][0][0][0][0][0][0].length\n  let [rows9, cols9] = grid[0][0][0][0][0][0][0][0].length\n\
    \  let [rows10, cols10] = grid[0][0][0][0][0][0][0][0][0].length\n  let [rows11,\
    \ cols11] = grid[0][0][0][0][0][0][0][0][0][0].length\n  let [rows12, cols12]\
    \ = grid[0][0][0][0][0][0][0][0][0][0][0].length\n  let [rows13, cols13] = grid[0][0][0][0][0][0][0][0][0][0][0][0].length\n\
    \  let [rows14, cols14] = grid[0][0][0][0][0][0][0][0][0][0][0][0][0].length\n\
    \  let [rows15, cols15] = grid[0][0][0][0][0][0][0][0][0][0][0][0][0][0].length\n\
    \  let [rows16, cols16] = grid[0][0][0][0][0][0][0][0][0][0][0][0][0][0][0].length\n\
    \  let [rows17, cols17] = grid[0][0][0][0][0][0][0][0][0][0][0", "  let [rows,\
    \ cols] = grid.length\n  let [wells, buckets] = [[0] * rows, [0] * rows]\n  for\
    \ (let i = 0; i < rows; i++) {\n    wells[i] = grid[i][0]\n    buckets[i] = capacity\n\
    \  }\n  for (let i = 0; i < rows; i++) {\n    for (let j = 1; j < cols; j++) {\n\
    \      if (wells[i] === 1) {\n        wells[i] = 0\n        buckets[i] -= 1\n\
    \      }\n      if (wells[i] === 0 && buckets[i] > 0) {\n        wells[i] = 1\n\
    \        buckets[i] -= 1\n      }\n    }\n  }\n  let count = 0\n  for (let i =\
    \ 0; i < rows; i++) {\n    if (wells[i] === 1) {\n      count += 1\n    }\n  }\n\
    \  return count\n}\n", "  let max = 0;\n  for (let i = 0; i < grid.length; i++)\
    \ {\n    for (let j = 0; j < grid[i].length; j++) {\n      let cur = 0;\n    \
    \  let left = i - 1;\n      let right = i + 1;\n      let up = j - 1;\n      let\
    \ down = j + 1;\n      if (left >= 0 && grid[left][j] === 1) {\n        cur +=\
    \ 1;\n      }\n      if (right < grid.length && grid[right][j] === 1) {\n    \
    \    cur += 1;\n      }\n      if (up >= 0 && grid[i][up] === 1) {\n        cur\
    \ += 1;\n      }\n      if (down < grid[i].length && grid[i][down] === 1) {\n\
    \        cur += 1;\n      }\n      max = Math.max(max, cur);\n    }\n  }\n  return\
    \ max;\n}\n", "    let [rows, cols] = grid.length;\n    let [rows2, cols2] = grid[0].length;\n\
    \    let [rows3, cols3] = grid[0][0].length;\n    let [rows4, cols4] = grid[0][0][0].length;\n\
    \    let [rows5, cols5] = grid[0][0][0][0].length;\n    let [rows6, cols6] = grid[0][0][0][0][0].length;\n\
    \    let [rows7, cols7] = grid[0][0][0][0][0][0].length;\n    let [rows8, cols8]\
    \ = grid[0][0][0][0][0][0][0].length;\n    let [rows9, cols9] = grid[0][0][0][0][0][0][0][0].length;\n\
    \    let [rows10, cols10] = grid[0][0][0][0][0][0][0][0][0].length;\n    let [rows11,\
    \ cols11] = grid[0][0][0][0][0][0][0][0][0][0].length;\n    let [rows12, cols12]\
    \ = grid[0][0][0][0][0][0][0][0][0][0][0].length;\n    let [rows13, cols13] =\
    \ grid[0][0][0][0][0][0][0][0][0][0][0][0].length;\n    let [rows14, cols14] =\
    \ grid[0][0][0][0][0][0][0][0][0][0][0][0][0].length;\n    let [rows15, cols15]\
    \ = grid[0][0][0][0][0][0][0][0][0][0][0][0][0][0].length;\n    let [rows16, cols16]\
    \ = grid[0][0][0][0][0][0][0][0][0][0][0][0][0][0][0].length;\n    let [rows17,\
    \ cols17] = grid[0][0][0", "  let max = 0\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    let cur = 0\n    for (let j = 0; j < grid[i].length; j++) {\n  \
    \    if (grid[i][j] === 1) {\n        cur += 1\n      }\n      if (cur > max)\
    \ {\n        max = cur\n      }\n    }\n  }\n  let count = 0\n  for (let i = 0;\
    \ i < grid.length; i++) {\n    let cur = 0\n    for (let j = 0; j < grid[i].length;\
    \ j++) {\n      if (grid[i][j] === 1) {\n        cur += 1\n      }\n      if (cur\
    \ === max) {\n        count += 1\n      }\n    }\n  }\n  return count\n}\n", " \
    \ let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let curr = 0;\n\
    \    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n\
    \        curr += 1;\n        if (curr > max) {\n          max = curr;\n      \
    \  }\n      }\n    }\n  }\n  let curr = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j]\
    \ === 1) {\n        curr += 1;\n        if (curr > max) {\n          max = curr;\n\
    \        }\n      }\n    }\n  }\n  return max;\n}\n", "    let [rows, cols] =\
    \ grid.length;\n    let [row, col] = [0, 0];\n    let [max_fill, max_fill_row,\
    \ max_fill_col] = [0, 0, 0];\n    let [max_fill_row_col, max_fill_row_col_row,\
    \ max_fill_row_col_col] = [0, 0, 0];\n    let [max_fill_row_col_row_col, max_fill_row_col_row_col_row,\
    \ max_fill_row_col_row_col_col] = [0, 0, 0];\n    let [max_fill_row_col_row_col_row_col_row_col,\
    \ max_fill_row_col_row_col_row_col_row_col_row, max_fill_row_col_row_col_row_col_row_col_row_col]\
    \ = [0, 0, 0];\n    let [max_fill_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col_row_col",
  "    let [rows, cols] = grid.length;\n    let [wells, buckets] = grid;\n    let\
    \ [wells_count, buckets_count] = [0, 0];\n    let [wells_max, buckets_max] = [0,\
    \ 0];\n    let [wells_min, buckets_min] = [0, 0];\n    let [wells_max_count, buckets_max_count]\
    \ = [0, 0];\n    let [wells_min_count, buckets_min_count] = [0, 0];\n    for (let\
    \ i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n        \
    \    if (wells[i][j] === 1) {\n                wells_count++;\n              \
    \  wells_max = Math.max(wells_max, wells_count);\n                wells_min =\
    \ Math.min(wells_min, wells_count);\n                wells_max_count = Math.max(wells_max_count,\
    \ wells_count);\n                wells_min_count = Math.min(wells_min_count, wells_count);\n\
    \            }\n            if (wells[i][j] === 0) {\n                buckets_count++;\n\
    \                buckets_max = Math.max(buckets_max, buckets_count);\n       \
    \         buckets_min = Math.min(buckets_min, buckets_count);\n              \
    \  buckets_max_count = Math.max(buckets_max_count, buckets_count);\n         \
    \       buckets_min_count = Math.min(buckets_min_count, buckets_count);\n    \
    \        }\n        }\n    }\n    let max_fill = 0;\n    for (let i = wells_min;\
    \ i <= wells_max; i++) {\n        let max_fill_count = 0;\n        for (let j\
    \ = buckets_min; j <= buckets_max; j++) {\n            if (wells[i - wells_min][j\
    \ - buckets_min] === 1) {\n                max_fill_count++;\n               \
    \ if (max_fill_count === capacity) {\n                    max_fill++;\n      \
    \              break;\n                }\n            ", "  let [rows, cols] =\
    \ grid.length\n  let [r, c] = [0, 0]\n  let [max_fill, max_fill_count] = [0, 0]\n\
    \  let [max_fill_count_r, max_fill_count_c] = [0, 0]\n  let [max_fill_count_r_c,\
    \ max_fill_count_c_r] = [0, 0]\n  let [max_fill_count_r_c_r, max_fill_count_c_r_c]\
    \ = [0, 0]\n  let [max_fill_count_r_c_r_c, max_fill_count_c_r_c_r] = [0, 0]\n\
    \  let [max_fill_count_r_c_r_c_r, max_fill_count_c_r_c_r_c] = [0, 0]\n  let [max_fill_count_r_c_r_c_r_c,\
    \ max_fill_count_c_r_c_r_c_r] = [0, 0]\n  let [max_fill_count_r_c_r_c_r_c_r_c,\
    \ max_fill_count_c_r_c_r_c_r_c_r] = [0, 0]\n  let [max_fill_count_r_c_r_c_r_c_r_c_r_c,\
    \ max_fill_count_c_r_c_r_c_r_c_r_c_r] = [0, 0]\n  let [max_fill_count_r_c_r_c_r_c_r_c_r_c_r_c,\
    \ max_fill_count_c_r_c_r_c_r_c_r_c_r_c_r] = [0, 0]\n  let [max_fill_count_r_c_r_c_r_c_r_c_r_c_r_c_r_c,\
    \ max_fill_count_c_r_c_r_c_r_c_r_c_r_"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
