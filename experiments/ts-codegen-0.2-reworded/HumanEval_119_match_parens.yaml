name: HumanEval_119_match_parens
language: ts
prompt: "//You are given an array of two strings, both strings consist of open\n//\
  \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
  \ is possible to concatenate the two strings in\n// some order, that the resulting\
  \ string will be good.\n// A string S is considered to be good if and only if all\
  \ parentheses in S\n// are balanced. For example: the string '(())()' is good, while\
  \ the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good\
  \ string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([\"()(\"\
  , \")\"])\n// \"Yes\"\n// >>> match_parens([\")\", \")\"])\n// \"No\"\nfunction\
  \ match_parens(lst: string[]): string {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"()(\"\
  , \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
  (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
  ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\");\n\
  \  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
  (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
  ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
  )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\");\n\
  \  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
completions: ["    let stack = [];\n    for (let i = 0; i < lst.length; i++) {\n \
    \       if (lst[i] === '(') {\n            stack.push(lst[i]);\n        } else\
    \ if (lst[i] === ')') {\n            if (stack.length === 0) {\n             \
    \   return \"No\";\n            } else {\n                stack.pop();\n     \
    \       }\n        }\n    }\n    return stack.length === 0 ? \"Yes\" : \"No\"\
    ;\n}\n", "    let stack = [];\n    for (let i = 0; i < lst.length; i++) {\n  \
    \      if (lst[i] === '(') {\n            stack.push(lst[i]);\n        } else\
    \ {\n            if (stack.length === 0) {\n                return \"No\";\n \
    \           } else {\n                stack.pop();\n            }\n        }\n\
    \    }\n    if (stack.length === 0) {\n        return \"Yes\";\n    } else {\n\
    \        return \"No\";\n    }\n}\n", "    let stack = [];\n    for (let i = 0;\
    \ i < lst.length; i++) {\n        if (lst[i] === '(') {\n            stack.push(lst[i]);\n\
    \        } else if (lst[i] === ')') {\n            if (stack.length === 0) {\n\
    \                return \"No\";\n            } else {\n                stack.pop();\n\
    \            }\n        }\n    }\n    if (stack.length === 0) {\n        return\
    \ \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n", "  let stack =\
    \ [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n \
    \     stack.push(lst[i]);\n    } else {\n      if (stack.length === 0) {\n   \
    \     return 'No';\n      } else {\n        stack.pop();\n      }\n    }\n  }\n\
    \  if (stack.length === 0) {\n    return 'Yes';\n  } else {\n    return 'No';\n\
    \  }\n}\n", "    let stack = [];\n    for (let i = 0; i < lst.length; i++) {\n\
    \        if (lst[i] === '(') {\n            stack.push(lst[i]);\n        } else\
    \ {\n            if (stack.length === 0) {\n                return \"No\";\n \
    \           }\n            if (lst[i] === ')') {\n                stack.pop();\n\
    \            }\n        }\n    }\n    if (stack.length === 0) {\n        return\
    \ \"Yes\";\n    }\n    return \"No\";\n}\n", "    let stack = [];\n    for (let\
    \ i = 0; i < lst.length; i++) {\n        if (lst[i] === '(') {\n            stack.push(lst[i]);\n\
    \        } else if (lst[i] === ')') {\n            if (stack.length === 0) {\n\
    \                return \"No\";\n            }\n            stack.pop();\n   \
    \     }\n    }\n    return stack.length === 0 ? \"Yes\" : \"No\";\n}\n", "   \
    \ let stack = [];\n    for (let i = 0; i < lst.length; i++) {\n        if (lst[i]\
    \ === '(') {\n            stack.push(lst[i]);\n        } else if (lst[i] === ')')\
    \ {\n            if (stack.length === 0) {\n                return \"No\";\n \
    \           } else {\n                stack.pop();\n            }\n        }\n\
    \    }\n    return stack.length === 0 ? \"Yes\" : \"No\";\n}\n", "    let stack\
    \ = [];\n    for (let i = 0; i < lst.length; i++) {\n        if (lst[i] === '(')\
    \ {\n            stack.push(lst[i]);\n        } else if (lst[i] === ')') {\n \
    \           if (stack.length === 0) {\n                return \"No\";\n      \
    \      }\n            stack.pop();\n        }\n    }\n    if (stack.length ===\
    \ 0) {\n        return \"Yes\";\n    }\n    return \"No\";\n}\n", "    let res\
    \ = \"No\";\n    for (let i = 0; i < lst.length; i++) {\n        if (lst[i] ===\
    \ \")\") {\n            if (lst[i - 1] === \"(\") {\n                res = \"\
    Yes\";\n                break;\n            }\n        } else if (lst[i] === \"\
    (\") {\n            if (lst[i - 1] === \")\") {\n                res = \"Yes\"\
    ;\n                break;\n            }\n        }\n    }\n    return res;\n\
    }\n", "    let stack = [];\n    for (let i = 0; i < lst.length; i++) {\n     \
    \   if (lst[i] === '(') {\n            stack.push(lst[i]);\n        } else if\
    \ (lst[i] === ')') {\n            if (stack.length === 0) {\n                return\
    \ \"No\";\n            } else {\n                stack.pop();\n            }\n\
    \        }\n    }\n    return stack.length === 0 ? \"Yes\" : \"No\";\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
