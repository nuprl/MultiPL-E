name: HumanEval_159_eat
language: ts
prompt: "//You're a hungry rabbit, and you already have eaten a certain number of\
  \ carrots,\n// but now you need to eat more carrots to complete the day's meals.\n\
  // you should return an array of [ total number of eaten carrots after your meals,\n\
  // the number of carrots left after your meals ]\n// if there are not enough remaining\
  \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
  // >>> eat(5, 6, 10)\n// [11, 4]\n// >>> eat(4, 8, 9)\n// [12, 1]\n// >>> eat(1,\
  \ 10, 10)\n// [11, 0]\n// >>> eat(2, 11, 5)\n// [7, 0]\n// Variables:\n// @number\
  \ : integer\n// the number of carrots that you have eaten.\n// @need : integer\n\
  // the number of carrots that you need to eat.\n// @remaining : integer\n// the\
  \ number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number\
  \ <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\n\
  function eat(number: number, need: number, remaining: number): number[] {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = eat;\n  assert.deepEqual(candidate(5, 6, 10),[11,\
  \ 4]);\n  assert.deepEqual(candidate(4, 8, 9),[12, 1]);\n  assert.deepEqual(candidate(1,\
  \ 10, 10),[11, 0]);\n  assert.deepEqual(candidate(2, 11, 5),[7, 0]);\n  assert.deepEqual(candidate(4,\
  \ 5, 7),[9, 2]);\n  assert.deepEqual(candidate(4, 5, 1),[5, 0]);\n}\n\ntest();"
completions: ["    let result = [];\n    let eaten = 0;\n    let left = 0;\n    if\
    \ (need > remaining) {\n        result.push(need);\n        result.push(0);\n\
    \        return result;\n    }\n    while (need > 0) {\n        if (need > remaining)\
    \ {\n            eaten += remaining;\n            left = 0;\n        } else {\n\
    \            eaten += need;\n            left = need - remaining;\n        }\n\
    \        need -= eaten;\n        result.push(eaten);\n        result.push(left);\n\
    \    }\n    return result;\n}\n", "    let [total, left] = [number, remaining];\n\
    \    let [left_eat, left_remaining] = eat(left, need, left);\n    total += left_eat;\n\
    \    left -= left_eat;\n    if (left < 0) {\n        left = 0;\n    }\n    return\
    \ [total, left];\n}\n", "    let result = [];\n    let eaten = 0;\n    let left\
    \ = 0;\n    let i = 0;\n    while (i < number) {\n        if (remaining > 0) {\n\
    \            if (need <= remaining) {\n                eaten += need;\n      \
    \          left = remaining - need;\n                remaining = 0;\n        \
    \    } else {\n                eaten += remaining;\n                left = 0;\n\
    \                remaining -= need;\n            }\n        } else {\n       \
    \     eaten += need;\n            left = 0;\n        }\n        result.push(eaten);\n\
    \        i++;\n    }\n    result.push(left);\n    return result;\n}\n", "    let\
    \ result = [];\n    let eaten = 0;\n    let left = 0;\n    if (need > remaining)\
    \ {\n        eaten = remaining;\n        left = 0;\n    } else {\n        eaten\
    \ = need;\n        left = remaining - need;\n    }\n    result.push(eaten);\n\
    \    result.push(left);\n    return result;\n}\n", "    let result = [];\n   \
    \ let eaten = 0;\n    let left = 0;\n    if (number >= need) {\n        result.push(need);\n\
    \        result.push(0);\n        return result;\n    }\n    if (number < need)\
    \ {\n        result.push(number);\n        result.push(need - number);\n     \
    \   return result;\n    }\n    while (left < need) {\n        if (remaining >\
    \ 0) {\n            result.push(left + 1);\n            result.push(remaining\
    \ - 1);\n            left++;\n        } else {\n            result.push(left);\n\
    \            result.push(need - left);\n            left = 0;\n        }\n   \
    \ }\n    return result;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
